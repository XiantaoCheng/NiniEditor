### 节点
地址, 的, 空间投影, 目录, 的, 的, 节点数目统计, 20210411, 的, 的, 正文, html, 的, 场景, 的, 坐标系, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 选中区域, 的, 的, 输出, HTML, 的, 的, 输出, 输入, 的, 的, 的, 的, 的, 的, 起点, 尺寸, 类型, 原点, x坐标, y坐标, 可选, 的, z轴, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线型, 线粗细, 矩形, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 选中区域, 的, 的, 输出, HTML, 的, 的, 输出, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 起点, 尺寸, 类型, 文字, 字体, 线型, 线粗细, 面颜色, 线颜色, 矩形, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 选中区域, 的, 的, 输出, HTML, 的, 的, 输出, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 起点, 尺寸, 类型, 文字, 字体, 线型, 线粗细, 面颜色, 线颜色, 直线, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线型, 线粗细, 直线, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线型, 线粗细, 直线, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线型, 线粗细, 直线, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线型, 线粗细, 直线, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线型, 线粗细, 比例, 的, 尺寸, 的, 原点, 的, 坐标系, 20210516, 的, 20210517, 的, 的, 网页画板, 的, 平面空间位置, html, 的, 直线灭点和垂直平面灭线, M函数, 20210528, 的, 20210815, 的, 的, 相机投影, html, 20211205, 的, 的, 投影逆向, html, 的, 空间角, 的, 平面约束, 公式, 的, 给定坐标, 公式, 的, 平面约束推导, 公式, 的, 三维坐标, 公式, 的, 线性约束, 公式, 的, 线性约束推导, 公式, 的, 线性约束推导_p, 公式, 的, 线性约束推导结果_p, 公式, 的, 线性约束推导结果_q, 公式, 的, 三维旋转, 的, 相机坐标系, 公式, 的, 局域坐标变换, 公式, 的, 平面约束_矢量形式, 公式, 的, 平面约束_矢量变换, 公式, 的, 平面约束_坐标变换, 公式, 的, 线性约束_矢量形式, 公式, 的, 线性约束_矢量变换, 公式, 的, 线性约束_坐标变换, 公式, 20211209, 的, 的, 测试函数, M函数, 20211210, 的, 的, getPointOnLine, M函数, 的, GetPointOnPlane, M函数, 的, 地址, 20221026, 的, 的, 正投影, html, 的, [1]., 表达式, 的, 公式, 的, [2]., 表达式, 的, 公式, 的, [3]., 表达式, 的, 公式, 的, [4]., 的, [5]., 表达式, 的, 公式, 表达式, 的, 公式, 的, [6]., 表达式, 的, 公式, 的, [7]., 表达式, 的, 公式, 的, [8]., 表达式, 的, 公式, 的, [9]., 表达式, 的, 公式, 的, [10]., 的, [11]., 的, [12]., 的, [13]., 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, 的, [13.B]., 的, [11.B]., 表达式, 的, 公式, 表达式, 的, 公式, 的, [14]., 表达式, 的, 公式, 的, [15]., 表达式, 的, 公式, 的, [16]., 表达式, 的, 公式, 的, [17]., 表达式, 的, 公式, 的, 球面约束, html, 的, [1]., 的, [2]., 的, [3]., 的, [4]., 的, [5]., 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, 的, [6]., 的, [7]., 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, b, 的, a, 的, 表达式, 的, 公式, b, 的, a, 的, b, 的, a, 的, b, 的, a, 的, 的, [8]., 的, [9]., 的, [10]., 表达式, 的, 公式, 新结构, 表达式, 的, 公式, 新结构, 新结构, 的, [11]., 的, [12]., 的, [13]., 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, 的, [14]., 的, [15]., 的, [16]., 表达式, 的, 公式, 表达式, 的, 公式, 的, [17]., 表达式, 的, 公式, 表达式, 的, 公式, 的, [18]., 的, [19]., 的, [20]., 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, 的, [21]., 的, [22]., 表达式, 的, 公式, 表达式, 的, 公式, 的, [23]., 表达式, 的, 公式, 的, [24]., 的, [25]., 表达式, 的, 公式, 表达式, 的, 公式, 的, [26]., 的, [27]., 表达式, 的, 公式, 表达式, 的, 公式, 的, [28]., 表达式, 的, 公式, 的, 验证公式, M函数, 的, 地址, GetPointOnPlane, 的, 记忆, GetPointOnPlane, getPointOnLine, 的, getPointOnLine, 的, 保存, 的, 保存, 的, 直线约束, html, 的, [1]., 的, [2]., 的, [3]., 表达式, 的, 公式, 的, 表达式, 的, 公式, 的, 表达式, 的, 公式, 的, 的, [4]., 的, [5]., 的, [6]., 表达式, 的, 公式, 的, b, 的, a, 的, 的, 的, b, 的, a, 的, 的, 的, 表达式, 的, 公式, 的, 表达式, 的, 公式, 的, 的, [7]., 表达式, 的, 公式, 的, 的, [8]., 表达式, 的, 公式, 的, 的, [9]., 表达式, 的, 公式, 的, 的, [10]., 的, [11]., 的, [12]., 表达式, 的, 公式, 的, 表达式, 的, 公式, 的, 表达式, 的, 公式, 的, 在, 在, 在, 在, 的, 测试, 读取, 
### 关联
#, 2#0, #, #, 3#2, 3#6, #, #, 6#7, 2#10, #, 10#, 10#13, #, 13#15, #, 15#26, 15#34, 15#38, 15#49, 15#50, 15#51, 15#52, 15#53, 15#54, 15#55, #, 26#42, 26#31, 26#32, 26#33, #, #, #, #, 34#37, 34#42, #, #, 38#41, 38#42, #, #, 42#50, 42#49, 42#52, 42#53, 42#54, 42#55, #, #, #, #, #, #, #, 13#57, #, 57#95, 57#96, 57#67, 57#75, 57#76, 57#97, 57#98, 57#99, 57#87, #, 67#89, 67#72, 67#73, 67#74, #, #, #, #, #, 76#80, 76#83, 76#84, #, 80#95, 80#96, #, #, 84#86, #, #, 87#89, #, 89#95, 89#96, 89#97, 89#98, 89#99, #, #, #, #, #, #, 13#100, 100#114, 100#122, 100#126, 100#139, 100#140, 100#141, 100#142, 100#143, 100#144, 100#145, 100#146, 100#147, #, 114#130, 114#119, 114#120, 114#121, #, #, #, #, 122#125, 122#130, #, #, 126#129, 126#130, #, #, 130#146, 130#147, 130#144, 130#145, 130#142, 130#143, 130#140, 130#139, #, #, #, #, #, #, #, #, #, #, 13#148, 148#162, 148#170, 148#174, 148#187, 148#188, 148#189, 148#190, 148#191, 148#192, 148#193, 148#194, 148#195, #, 162#178, 162#167, 162#168, 162#169, #, #, #, #, 170#173, 170#178, #, #, 174#177, 174#178, #, #, 178#194, 178#195, 178#192, 178#193, 178#190, 178#191, 178#188, 178#187, #, #, #, #, #, #, #, #, #, #, 13#196, 196#235, 196#236, 196#207, 196#215, 196#216, 196#237, 196#238, 196#239, 196#227, #, 207#229, 207#212, 207#213, 207#214, #, #, #, #, #, 216#220, 216#223, 216#224, #, 220#235, 220#236, #, #, 224#226, #, #, 227#229, #, 229#235, 229#236, 229#237, 229#238, 229#239, #, #, #, #, #, #, 13#240, 240#279, 240#280, 240#251, 240#259, 240#260, 240#281, 240#282, 240#283, 240#271, #, 251#273, 251#256, 251#257, 251#258, #, #, #, #, #, 260#264, 260#267, 260#268, #, 264#279, 264#280, #, #, 268#270, #, #, 271#273, #, 273#279, 273#280, 273#281, 273#282, 273#283, #, #, #, #, #, #, 13#284, 284#323, 284#324, 284#295, 284#303, 284#304, 284#325, 284#326, 284#327, 284#315, #, 295#317, 295#300, 295#301, 295#302, #, #, #, #, #, 304#308, 304#311, 304#312, #, 308#323, 308#324, #, #, 312#314, #, #, 315#317, #, 317#323, 317#324, 317#325, 317#326, 317#327, #, #, #, #, #, #, 13#328, 328#367, 328#368, 328#339, 328#347, 328#348, 328#369, 328#370, 328#371, 328#359, #, 339#361, 339#344, 339#345, 339#346, #, #, #, #, #, 348#352, 348#355, 348#356, #, 352#367, 352#368, #, #, 356#358, #, #, 359#361, #, 361#367, 361#368, 361#369, 361#370, 361#371, #, #, #, #, #, #, 13#372, 372#411, 372#412, 372#383, 372#391, 372#392, 372#413, 372#414, 372#415, 372#403, #, 383#405, 383#388, 383#389, 383#390, #, #, #, #, #, 392#396, 392#399, 392#400, #, 396#411, 396#412, #, #, 400#402, #, #, 403#405, #, 405#411, 405#412, 405#413, 405#414, 405#415, #, #, #, #, #, #, 422#416, #, 422#418, #, 422#420, 13#, #, 6#423, #, 6#425, 2#428, #, 2#430, #, 430#, 10#433, #, 433#, #, 6#435, #, 6#437, 2#440, #, 440#, #, 6#442, 2#445, #, 445#, 2#448, #, 445#450, #, 450#, 445#453, #, 453#, 445#456, #, 456#, 445#459, #, 459#, 445#462, #, 462#, 445#465, #, 465#, 445#468, #, 468#, 445#471, #, 471#, 445#474, #, 474#, 2#477, #, 445#479, #, 479#, 445#482, #, 482#, 445#485, #, 485#, 445#488, #, 488#, 445#491, #, 491#, 445#494, #, 494#, 445#497, #, 497#, 445#500, #, 500#, #, 6#502, 445#505, #, 505#, #, 6#507, 505#510, #, 510#, 505#513, #, 513#, 510#516, #, #, 6#517, 2#520, #, 520#, 520#523, #, #, 523#524, 523#, 520#528, #, #, 528#529, 528#, 520#533, #, #, 533#534, 533#, 520#538, #, 520#540, #, #, 538#541, 538#, #, 540#544, 540#, 520#548, #, #, 548#549, 548#, 520#553, #, #, 553#554, 553#, 520#558, #, #, 558#559, 558#, 520#563, #, #, 563#564, 563#, 520#568, #, 520#570, #, 520#572, #, 520#574, #, #, 568#575, 568#, #, 570#578, 570#, #, 572#581, 572#, #, 574#584, 574#, 520#588, #, 520#590, #, #, 588#591, 588#, #, 590#594, 590#, 520#598, #, #, 598#599, 598#, 520#603, #, #, 603#604, 603#, 520#608, #, #, 608#609, 608#, 520#613, #, #, 613#614, 613#, 445#618, #, 618#, 618#621, #, 618#623, #, 618#625, #, 618#627, #, 618#629, #, #, 621#630, 621#, #, 623#633, 623#, #, 625#636, 625#, 618#640, #, 618#642, #, #, 627#643, 627#, #, 629#646, 629#, #, 640#649, 640#, #, 630#652, #, 630#654, #, 642#656, 642#, #, 636#659, #, 636#661, #, 643#663, #, 643#665, #, 633#667, #, 633#669, 618#672, #, 618#674, #, 618#676, #, #, 672#677, 672#, #, #, 674#681, 674#, #, #, 618#687, #, 618#689, #, 618#691, #, #, 676#692, 676#, #, 687#695, 687#, #, 689#698, 689#, #, 691#701, 691#, 618#705, #, 618#707, #, 618#709, #, #, 705#710, 705#, #, 707#713, 707#, 618#717, #, #, 709#718, 709#, #, 717#721, 717#, 618#725, #, 618#727, #, 618#729, #, #, 725#730, 725#, #, 727#733, 727#, #, 729#736, 729#, 618#740, #, 618#742, #, #, 740#743, 740#, #, 742#746, 742#, 618#750, #, #, 750#751, 750#, 618#755, #, 618#757, #, #, 755#758, 755#, #, 757#761, 757#, 618#765, #, 618#767, #, #, 765#768, 765#, #, 767#771, 767#, 618#775, #, #, 775#776, 775#, 618#780, #, 780#, 513#783, #, #513, 786#784, 3#, #, #510, 786#788, #, 513#792, #, 510#794, #, 445#796, #, 796#, 796#799, #, 796#801, #, 796#803, #, #, 799#804, 799#, 804#del, #, 801#808, 801#, 808#del, #, 803#812, 803#, 812#del, 796#817, #, 796#819, #, 796#821, #, #, 817#822, 817#, 822#del, #, 804#826, #, 804#828, 828#del, 826#del, #, 812#832, #, 812#834, 834#del, 832#del, #, 819#838, 819#, 838#del, #, 821#842, 821#, 842#del, 796#847, #, #, 847#848, 847#, 848#del, 796#853, #, #, 853#854, 853#, 854#del, 796#859, #, #, 859#860, 859#, 860#del, 796#865, #, 796#867, #, 796#869, #, #, 865#870, 865#, 870#del, #, 867#874, 867#, 874#del, #, 869#878, 869#, 878#del, #, #, #, #, 510#887, #, del#445, 
### 内容
#0, 17:
文档\数学问题\空间投影.ftxt
## end
#2, 639:
+[返回目录](,空间投影)
地址::文档\数学问题\空间投影.ftxt

网页画板::文档\S应用\网页画板.ftxt
+[打开文件](+新窗口,网页画板)
空间角::文档\数学问题\空间角.ftxt
+[打开文件](+新窗口,空间角)
三维旋转::文档\数学问题\三维旋转.ftxt
+[打开文件](+新窗口,三维旋转)

Nini, 导入天书的库
Nini, 导入公式分析器的库


解决两个问题:
1.给定相片参数(空间方向, 中心位置, 尺寸), 计算三维场景(地平线和z方向点)在相片上的投影; 
2.在相片上标记地平线和z方向点, 计算相片参数. 

已知相机参数, 计算投影到相机上的图形坐标. 
正文(html):...
+[H函数](,正文)

接着要根据坐标系投影, 确定相机参数(空间角+位置+投影平面距离). 
等价于找投影图形在3D空间中的坐标. 
重要问题::平面上所有的灭点构成一条直线, 那么直线方程是什么? 
(正文里面回答过了)

坐标系有6个变量. 因此只需要3条参考线即可确定坐标系. 分别为:
x轴方向+灭点(2+2)
y轴方向+比例尺. 

平面空间位置(html):...



+[新建阅读窗口](,相机投影)
相机投影(html):...
+[H函数](,相机投影)
投影逆向(html):...
+[H函数](,投影逆向)
投影逆向是在给定约束条件下, 从照片上的二维坐标逆向计算出三维坐标
正投影(html):...



## end
#3, 48:
空间投影:...
创建于 20210411

节点数目统计::
+[设置结构](,节点数目统计)
## end
#7, 3:
433
## end
#10, 1189:
<!--
+[返回目录](,正文)

+[H函数](,正文)

场景(画板):...
+[画板](+中心投影,场景)
场景->画板(场景,)->+[del](,画板)
-->

%场景<br>
先不考虑相片参数. 假设投影点在原点, 方向指向z轴方向, 相片在\((0,0,1)\)的位置. 中心投影时, 空间点\((x,y,z)\)会投影到相片上的\((x',y')\)的位置. 那么,
$$
\begin{cases}
x'=\frac{x}{z}
\\
y'=\frac{y}{z}
\end{cases}
$$
一条空间直线\(l\), 可以写作\(l(t)\),
$$
\begin{cases}
x=v_x t+x_0
\\
y=v_y t+y_0
\\
z=v_z t+z_0
\end{cases}
$$
那么, 相片上对应的轨迹为, 
$$
x'=\frac{x}{z}=\frac{v_x t+x_0}{v_z t+z_0}
$$$$
y'=\frac{y}{z}=\frac{v_y t+y_0}{v_z t+z_0}
$$
这条轨迹是直线, 因为,
$$
x'=\frac{v_y t+y_0}{v_z t+z_0}
=\frac{v_x/v_z (v_z t+z_0-z_0+x_0 v_z/v_x)}{v_z t+z_0}
\\
=\frac{v_x}{v_z}-\frac{x_0-z_0 v_x/v_z}{v_z t+ z_0}
$$
$$
\Rightarrow
\left(x'-\frac{v_x}{v_z}\right)=-\frac{x_0-z_0 v_x/v_z}{v_z t+ z_0}
$$
于是, 
$$
\frac{x'-v_x/v_z}{y'-v_y/v_z}=\frac{x_0 v_z-z_0 v_x}{y_0 v_z-z_0 v_y}
$$
显然, 空间中两条平行线的投影交点为,  
$$
\lim_{t\rightarrow \infty} (x',y')=(v_x/v_z, v_y/v_z)
$$
而, 对于空间中的平面, 如果其法向量为\(\vec{v}=(a,b,c)\)很容易有, 
$$
ax+by+cz=0
$$
于是这个平面所有的灭点构成一条直线, 
$$
ax'+by'+c=0
$$
该平面垂直方向的交点为, 
$$
p=(a/c,b/c)
$$
<br>
至于其它的可变因素, 有如下几点:<br>
1.相片方向只是个空间旋转问题, 可以转化为了三维坐标之后再做处理; 
2.相片位置对无穷远点没有影响;
3.如果投影中心不在相片中心应该会引起一些扭曲. 这个可以用平面的地平线和其法线的交点位置来确定.

<!--
+[H函数](,正文)

直线灭点和垂直平面灭线(M函数):...
-->
## end
#13, 60:
+[返回目录](,场景)

坐标系:...
+[创建坐标系](,坐标系)
z轴:...
+[创建单向箭头](,z轴)


## end
#15, 140:
+[返回目录](,坐标系)
+[设置结构](,坐标系)

起点::-200,100
尺寸::100,100
类型::矩形

原点::0.1,0.1
x坐标::x
y坐标::y

可选::NO

画图:...
选中区域:...
HTML:...

+[创建输入](可选,画图)



## end
#26, 1487:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


def drawArrow(qp,pt1,pt2):
    angle=30
    l=30
    D=0
    d=10
    
    lineWidth=2
    
    edgeColor=[0,0,0]
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush())
    
    r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
    if r!=0:
        theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
    dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
    dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]
    
    pt10=[0,0]
    pt20=[0,0]
    pt10[0]=pt1[0]
    pt10[1]=pt1[1]
    pt20[0]=pt2[0]
    pt20[1]=pt2[1]
    
    
    path2=QPainterPath()
    path2.moveTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
    path2.lineTo(pt20[0],pt20[1])
    path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])
    
    qp.drawPath(path2)
    
    
    qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])
    
    qp.setBrush(QBrush())
    qp.setPen(QPen())


pt=起点
size=尺寸
orig=[pt[0]+size[0]*原点[0],pt[1]+size[1]*原点[1]]

qp.setFont(QFont("Decorative",15))

pt1=[pt[0],orig[1]]
pt2=[pt[0]+size[0],orig[1]]
qp.drawText(pt2[0],pt2[1],100,30,Qt.AlignLeft|Qt.AlignVCenter,x坐标)
drawArrow(qp,pt1,pt2)

pt1=[orig[0],pt[1]]
pt2=[orig[0],pt[1]+size[1]]
qp.drawText(pt2[0],pt2[1]-30,100,30,Qt.AlignLeft|Qt.AlignVCenter,y坐标)
drawArrow(qp,pt1,pt2)


qp.drawText(orig[0],orig[1],30,30,Qt.AlignHCenter|Qt.AlignVCenter,'O')
qp.setFont(QFont())


## end
#32, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#33, 1487:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


def drawArrow(qp,pt1,pt2):
    angle=30
    l=30
    D=0
    d=10
    
    lineWidth=2
    
    edgeColor=[0,0,0]
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush())
    
    r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
    if r!=0:
        theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
    dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
    dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]
    
    pt10=[0,0]
    pt20=[0,0]
    pt10[0]=pt1[0]
    pt10[1]=pt1[1]
    pt20[0]=pt2[0]
    pt20[1]=pt2[1]
    
    
    path2=QPainterPath()
    path2.moveTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
    path2.lineTo(pt20[0],pt20[1])
    path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])
    
    qp.drawPath(path2)
    
    
    qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])
    
    qp.setBrush(QBrush())
    qp.setPen(QPen())


pt=起点
size=尺寸
orig=[pt[0]+size[0]*原点[0],pt[1]+size[1]*原点[1]]

qp.setFont(QFont("Decorative",15))

pt1=[pt[0],orig[1]]
pt2=[pt[0]+size[0],orig[1]]
qp.drawText(pt2[0],pt2[1],100,30,Qt.AlignLeft|Qt.AlignVCenter,x坐标)
drawArrow(qp,pt1,pt2)

pt1=[orig[0],pt[1]]
pt2=[orig[0],pt[1]+size[1]]
qp.drawText(pt2[0],pt2[1]-30,100,30,Qt.AlignLeft|Qt.AlignVCenter,y坐标)
drawArrow(qp,pt1,pt2)


qp.drawText(orig[0],orig[1],30,30,Qt.AlignHCenter|Qt.AlignVCenter,'O')
qp.setFont(QFont())


## end
#34, 263:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


if 可选=='NO':
    state=False



## end
#37, 14:
+[返回目录]
+[内容]

## end
#38, 655:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#41, 14:
+[返回目录]
+[内容]

## end
#42, 137:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100
坐标范围::-1,1-1,1
x坐标::x
y坐标::y
可选::NO

## end
#49, 22:
-98.03125, 60.41015625
## end
#50, 22:
378.0625, -234.8203125
## end
#51, 2:
矩形
## end
#52, 7:
0.1,0.1
## end
#53, 1:
x
## end
#54, 1:
y
## end
#55, 2:
NO
## end
#57, 105:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...

## end
#67, 1161:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

angle=30
l=30
D=0
d=10


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush())

r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
if r!=0:
    theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]

pt10=[0,0]
pt20=[0,0]
pt10[0]=pt1[0]
pt10[1]=pt1[1]
pt20[0]=pt2[0]
pt20[1]=pt2[1]

#path1=QPainterPath()
#path1.moveTo(pt10[0],pt10[1])
#path1.moveTo(pt10[0]+dp21[0],pt10[1]+dp21[1])
#path1.lineTo(pt10[0],pt10[1])
#path1.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1])

path2=QPainterPath()
#path2.moveTo(pt20[0],pt20[1])
path2.moveTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
path2.lineTo(pt20[0],pt20[1])
path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])

#qp.drawPath(path1)
qp.drawPath(path2)


qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])

qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#73, 1161:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

angle=30
l=30
D=0
d=10


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush())

r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
if r!=0:
    theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]

pt10=[0,0]
pt20=[0,0]
pt10[0]=pt1[0]
pt10[1]=pt1[1]
pt20[0]=pt2[0]
pt20[1]=pt2[1]

#path1=QPainterPath()
#path1.moveTo(pt10[0],pt10[1])
#path1.moveTo(pt10[0]+dp21[0],pt10[1]+dp21[1])
#path1.lineTo(pt10[0],pt10[1])
#path1.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1])

path2=QPainterPath()
#path2.moveTo(pt20[0],pt20[1])
path2.moveTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
path2.lineTo(pt20[0],pt20[1])
path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])

#qp.drawPath(path1)
qp.drawPath(path2)


qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])

qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#74, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#75, 2:
直线
## end
#76, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#80, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#83, 14:
+[返回目录]
+[内容]

## end
#84, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#86, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#87, 950:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var pt1=[%起点];
var pt2=[%终点];


//arrows
var angle=30/180*Math.PI;
var l=20;
var d=10;

r=Math.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2);
if (r!=0) {
    theta=Math.sign(pt1[1]-pt2[1])*Math.acos((pt2[0]-pt1[0])/r);
}

dp21=[l*Math.cos(theta-angle/2),-l*Math.sin(theta-angle/2)];
dp22=[l*Math.cos(theta+angle/2),-l*Math.sin(theta+angle/2)];

pt10=[0,0];
pt20=[0,0];
pt10[0]=pt1[0];
pt10[1]=pt1[1];
pt20[0]=pt2[0];
pt20[1]=pt2[1];


ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
ctx.fillStyle='rgb(0,0,0,0)';


ctx.beginPath();


//ctx.moveTo(pt10[0]+dp21[0],pt10[1]+dp21[1]);
//ctx.lineTo(pt10[0],pt10[1]);
//ctx.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1]);

ctx.moveTo(pt20[0]-dp21[0],pt20[1]-dp21[1]);
ctx.lineTo(pt20[0],pt20[1]);
ctx.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1]);


ctx.moveTo(pt10[0],pt10[1]);
ctx.lineTo(pt20[0],pt20[1]);

ctx.stroke()
ctx.fill()



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#89, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#95, 37:
-84.21912590512505, 46.94574834912501
## end
#96, 37:
316.21912590512505, -142.945748349125
## end
#97, 5:
0,0,0
## end
#98, 8:
DashLine
## end
#99, 1:
1
## end
#100, 148:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...



## end
#114, 855:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#120, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#121, 855:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#122, 231:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


## end
#125, 14:
+[返回目录]
+[内容]

## end
#126, 655:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#129, 14:
+[返回目录]
+[内容]

## end
#130, 101:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100

## end
#139, 11:
-9.5, -31.0
## end
#140, 10:
47.0, 54.0
## end
#141, 2:
矩形
## end
#143, 2:
10
## end
#144, 8:
DashLine
## end
#145, 1:
2
## end
#146, 4:
None
## end
#147, 5:
0,0,0
## end
#148, 148:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...



## end
#162, 855:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#168, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#169, 855:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#170, 231:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


## end
#173, 14:
+[返回目录]
+[内容]

## end
#174, 655:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#177, 14:
+[返回目录]
+[内容]

## end
#178, 101:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100

## end
#187, 27:
66.493, -122.19200000000001
## end
#188, 12:
108.0, 123.0
## end
#189, 2:
矩形
## end
#191, 2:
10
## end
#192, 8:
DashLine
## end
#193, 1:
2
## end
#194, 11:
255,255,255
## end
#195, 5:
0,0,0
## end
#196, 129:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#207, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#213, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#214, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#215, 2:
直线
## end
#216, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#220, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#223, 14:
+[返回目录]
+[内容]

## end
#224, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#226, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#227, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#229, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#235, 11:
-59.0, 35.0
## end
#236, 12:
63.0, -122.0
## end
#237, 5:
0,0,0
## end
#238, 8:
DashLine
## end
#239, 1:
1
## end
#240, 129:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#251, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#257, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#258, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#259, 2:
直线
## end
#260, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#264, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#267, 14:
+[返回目录]
+[内容]

## end
#268, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#270, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#271, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#273, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#279, 11:
-61.0, 37.0
## end
#280, 13:
173.0, -121.0
## end
#281, 5:
0,0,0
## end
#282, 8:
DashLine
## end
#283, 1:
1
## end
#284, 129:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#295, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#301, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#302, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#303, 2:
直线
## end
#304, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#308, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#311, 14:
+[返回目录]
+[内容]

## end
#312, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#314, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#315, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#317, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#323, 11:
-59.0, 37.0
## end
#324, 9:
64.0, 0.0
## end
#325, 5:
0,0,0
## end
#326, 8:
DashLine
## end
#327, 1:
1
## end
#328, 129:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#339, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#345, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#346, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#347, 2:
直线
## end
#348, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#352, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#355, 14:
+[返回目录]
+[内容]

## end
#356, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#358, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#359, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#361, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#367, 11:
-64.0, 36.0
## end
#368, 10:
174.0, 2.0
## end
#369, 5:
0,0,0
## end
#370, 8:
DashLine
## end
#371, 1:
1
## end
#372, 129:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#383, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#389, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#390, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#391, 2:
直线
## end
#392, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#396, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#399, 14:
+[返回目录]
+[内容]

## end
#400, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#402, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#403, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#405, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#411, 11:
-62.0, 36.0
## end
#412, 12:
116.0, -48.0
## end
#413, 5:
0,0,0
## end
#414, 8:
DashLine
## end
#415, 1:
1
## end
#416, 18:
0.8910000000000001
## end
#418, 8:
958, 476
## end
#420, 12:
100.0, -50.0
## end
#423, 3:
425
## end
#425, 3:
443
## end
#428, 16:
文档\S应用\网页画板.ftxt
## end
#430, 397:
<!--
+[返回目录](,平面空间位置)
+[H函数](,平面空间位置)
+[新建阅读窗口](,平面空间位置)
-->

确定相机位置的问题可以等价于确定相片上的平面空间位置的问题. <br>
而确定平面的空间位置只需要确定平面的方向. 因为平面距离只是决定了平面的比例. <br>
而比较重要的一个问题是, 给定平面和平面原点后, 如何确定平面上任意一点到原点的坐标? <br>
也不难, 就是计算空间中平面和直线的交点. 然后求投影坐标即可. <br>
<br>
呃... 给定灭点就给定了直线方向. 给两个灭点就确定了灭线, 也就给定了平面的方向. 所以直接等价于过两点求直线方程的问题... <br>
如果是给定x轴的灭点和投影, 给定y轴的投影不给灭点, 那么可以用y轴投影和x轴垂直平面的灭线交点确定y轴的灭点. <br>




<!--
+[H函数](,平面空间位置)
-->
## end
#433, 178:
%{
+[M函数](,直线灭点和垂直平面灭线)
%}

a=0;
b=1;
c=2;

x=linspace(-10,10,100);
y=-a/b*x-c/b;

hold off
plot(a/c,b/c,'*',x,y)
hold on
plot([-10,10],[0,0],'k',[0,0],[-10,10],'k')
axis equal


## end
#435, 3:
437
## end
#437, 3:
439
## end
#440, 3949:
<!--
+[H函数](,相机投影)
-->

<b><u>Coordinates of points on a plane</u></b><br>
If the origin, \(\vec{r}_0\), \(\hat{x}\) and \(\hat{y}\) are, 
$$
\vec{r}_0=(x_0,y_0,z_0),\ 
\hat{x}=(u_1,u_2,u_3),\ 
\hat{y}=(v_1,v_2,v_3)
$$
Then the coordinates are, 
$$
\vec{r}=\vec{r}_0+a\ \hat{x}+b\ \hat{y}
$$
Or,
$$
\begin{cases}
x=x_0+a\ u_1+b\ v_1
\\
y=y_0+a\ u_2+b\ v_2
\\
z=z_0+a\ u_3+b\ v_3
\end{cases}
$$
<br><br>
<b><u>Projection on a camera</u></b><br>
The parameters for camera are: the pointing (\(\alpha, \beta, \gamma\)), the position (\(r_1=(x_1, y_1, z_1)\)) and the photo distance (\(D\)). <br>
The projection algorithm is very simple by two steps: <br>
<br>
1.Calculate the local coordinate of the objects. <br>
The axis for the local frame is, 
$$
\begin{cases}
\mathbf{X}=
(-sin\gamma sin\alpha cos\beta + cos\gamma cos\alpha,
sin\gamma cos\alpha cos\beta + cos\gamma sin\alpha,
sin\gamma sin\beta)
\\
\mathbf{Y}=
(-cos\gamma sin\alpha cos\beta - sin\gamma cos\alpha,
cos\gamma cos\alpha cos\beta - sin\gamma sin\alpha,
cos\gamma sin\beta)
\\
\mathbf{Z}=(sin\alpha sin\beta,-cos\alpha sin\beta,cos\beta)
\end{cases}
$$

The coordinate of points will be transformed,
$$
x_1=(\vec{r}-\vec{r}_1)\cdot \mathbf{X}
=(\vec{r}_0-\vec{r}_1+a\ \hat{x}+b\ \hat{y})\cdot \mathbf{X}
\\
=(\Delta\vec{r}\cdot \mathbf{X})+a\ (\hat{x}\cdot \mathbf{X})
+b\ (\hat{y}\cdot \mathbf{X})
$$
And others,
$$
\begin{cases}
x_1=(\Delta\vec{r}\cdot \mathbf{X})+a\ (\hat{x}\cdot \mathbf{X})
+b\ (\hat{y}\cdot \mathbf{X})
\\
y_1=(\Delta\vec{r}\cdot \mathbf{Y})+a\ (\hat{x}\cdot \mathbf{Y})
+b\ (\hat{y}\cdot \mathbf{Y})
\\
z_1=(\Delta\vec{r}\cdot \mathbf{Z})+a\ (\hat{x}\cdot \mathbf{Z})
+b\ (\hat{y}\cdot \mathbf{Z})
\\
\end{cases}
$$


<!--
+[H函数](,平面投影)
-->



<br>
2.Project points onto the photo. <br>
$$
\begin{cases}
x_2
=D \frac{(\Delta\vec{r}\cdot \mathbf{X})+a\ (\hat{x}\cdot \mathbf{X})
+b\ (\hat{y}\cdot \mathbf{X})}
{(\Delta\vec{r}\cdot \mathbf{Z})+a\ (\hat{x}\cdot \mathbf{Z})
+b\ (\hat{y}\cdot \mathbf{Z})}
\\
y_2=D \frac{(\Delta\vec{r}\cdot \mathbf{Y})+a\ (\hat{x}\cdot \mathbf{Y})
+b\ (\hat{y}\cdot \mathbf{Y})}
{(\Delta\vec{r}\cdot \mathbf{Z})+a\ (\hat{x}\cdot \mathbf{Z})
+b\ (\hat{y}\cdot \mathbf{Z})}
\end{cases}
$$

$$
\Rightarrow
\begin{cases}
x_2[
{(\Delta\vec{r}\cdot \mathbf{Z})+a\ (\hat{x}\cdot \mathbf{Z})
+b\ (\hat{y}\cdot \mathbf{Z})}
]
=D[
(\Delta\vec{r}\cdot \mathbf{X})+a\ (\hat{x}\cdot \mathbf{X})
+b\ (\hat{y}\cdot \mathbf{X})]

\\
y_2[
(\Delta\vec{r}\cdot \mathbf{Z})+a\ (\hat{x}\cdot \mathbf{Z})
+b\ (\hat{y}\cdot \mathbf{Z})]
=D[
(\Delta\vec{r}\cdot \mathbf{Y})+a\ (\hat{x}\cdot \mathbf{Y})
+b\ (\hat{y}\cdot \mathbf{Y})]
\end{cases}
$$

$$
\Rightarrow
\begin{cases}

a[x_2 (\hat{x}\cdot \mathbf{Z})-D (\hat{x}\cdot \mathbf{X})]
+b[x_2 (\hat{y}\cdot \mathbf{Z})-D (\hat{y}\cdot \mathbf{X})]
=D(\Delta\vec{r}\cdot \mathbf{X})-x_2(\Delta\vec{r}\cdot \mathbf{Z})

\\

a[y_2 (\hat{x}\cdot \mathbf{Z})-D (\hat{x}\cdot \mathbf{Y})]
+b[y_2 (\hat{y}\cdot \mathbf{Z})-D (\hat{y}\cdot \mathbf{Y})]
=D(\Delta\vec{r}\cdot \mathbf{Y})-y_2(\Delta\vec{r}\cdot \mathbf{Z})

\end{cases}
$$

Or, equivalently we will have, 
$$
\left(
\begin{matrix}
A & B
\\
C & D
\end{matrix}
\right)

\left(
\begin{matrix}
a
\\
b
\end{matrix}
\right)
=

\left(
\begin{matrix}
V_x
\\
V_y
\end{matrix}
\right)
$$
$$
\left(
\begin{matrix}
a
\\
b
\end{matrix}
\right)
=
\frac{1}{AD-BC}
\left(
\begin{matrix}
D & -B
\\
-C & A
\end{matrix}
\right)

\left(
\begin{matrix}
V_x
\\
V_y
\end{matrix}
\right)
$$
<!--
+[H函数](,平面投影)
-->

With equations, 
$$
\begin{cases}
A=x_2 (\hat{x}\cdot \mathbf{Z})-D (\hat{x}\cdot \mathbf{X})
\\
B=x_2 (\hat{y}\cdot \mathbf{Z})-D (\hat{y}\cdot \mathbf{X})
\\
C=y_2 (\hat{x}\cdot \mathbf{Z})-D (\hat{x}\cdot \mathbf{Y})
\\
D=y_2 (\hat{y}\cdot \mathbf{Z})-D (\hat{y}\cdot \mathbf{Y})
\\
V_x=D(\Delta\vec{r}\cdot \mathbf{X})-x_2(\Delta\vec{r}\cdot \mathbf{Z})
\\
V_y=D(\Delta\vec{r}\cdot \mathbf{Y})-y_2(\Delta\vec{r}\cdot \mathbf{Z})
\end{cases}
$$


## end
#442, 3:
509
## end
#445, 2096:
<!--
+[H函数](,投影逆向)

+[新建阅读窗口](,平面约束推导)
球面约束(html):...
-->

<b><u>Projection inverse</u></b><br>
There isn't any general projection inverse transformation, because we will lose information when we are projecting a 3D location onto a 2D plane. But with certain restrictions, it's possible to make a inverse transformation. <br>
Here I want to talk about two cases:<br>
1.A point restricted on a given plane; <br>
2.A point restricted on a given straight line. <br>
<br><br>


<b><u>Plane restriction</u></b><br>
Let's assume a plane passing through a point \(\vec{r}_0=(x_0,y_0,z_0)\), and facing to the direction \(\mathbf{\Theta}=(\alpha,\beta,\gamma)\). Then all points on the plane will obey the following equation,
%平面约束
<br>
If projection of the point on the camera is,
%给定坐标
Then the equation becomes,
%平面约束推导
The result is,
%三维坐标
<br><br>

<b><u>Line restriction</u></b><br>
If the line passing through \(\vec{r}_0=(x_0,y_0,z_0)\), and the direction is \(\vec{k}=(k_x,k_y,k_z)\), the restrictions are, 
%线性约束
If projection of the point on the camera is,
%给定坐标
Then the equation becomes,
%线性约束推导
We can use either \(p_1\) or \(q_1\) to get the coordinates.<br>
By given \(p_1\),
%线性约束推导_p
The result is,
%线性约束推导结果_p
For \(q_1\), it's simply,
%线性约束推导结果_q
<br><br>


<b><u>Coordinate transforms</u></b><br>
To use the above results, we should transform the plane restriction and line restriction into the camera local frame.<br>
If the Euler angles of the camera are \((\alpha,\beta,\gamma)\) and the location is \(\vec{r}_0=(x_c,y_c,z_c)\), then the frame units are,
%相机坐标系

Then the transform from the local frame to the global frame is,
%局域坐标变换

The plane restriction can be written in this way,
%平面约束_矢量形式
%平面约束_矢量变换

As a result, the restriction coefficients in the local frame are, 
%平面约束_坐标变换

<br><br>
And then, the line restriction can be written in this way,
%线性约束_矢量形式
%线性约束_矢量变换

As a result, the restriction coefficients in the local frame are, 
%线性约束_坐标变换






<!--
+[H函数](,投影逆向)
直线约束(html):...
+[H函数](,直线约束)

测试函数(M函数):...
在选择区域中, 将'测试函数'的"pt1\(1\)"替换为"x0"
+[新建阅读窗口](,测试函数)
-->
## end
#448, 16:
文档\数学问题\空间角.ftxt
## end
#450, 123:
a\ (x-x_0)+b\ (y-y_0)+c\ (z-z_0)=0
\\
\begin{cases}
a=sin\alpha sin\beta
\\
b=-cos\alpha sin\beta
\\
c=cos\beta
\end{cases}
## end
#453, 53:
\begin{cases}
p_1=x_1/z_1
\\
q_1=y_1/z_1
\end{cases}

## end
#456, 199:

a\ (x_1-x_0)+b\ (y_1-y_0)+c\ (z_1-z_0)
\\
=a\ (p_1 z_1-x_0)+b\ (q_1 z_1-y_0)+c\ (z_1-z_0)
\\
=a\ p_1 z_1- a\ x_0+b\ q_1 z_1- b\ y_0+c\ z_1-c\ z_0
\\
=(a\ p_1+b\ q_1+c)\ z_1
-(a\ x_0+b\ y_0+c\ z_0)=0
## end
#459, 110:
\begin{cases}
z_1 = \frac{a\ x_0+b\ y_0+c\ z_0}{a\ p_1+b\ q_1+c}
\\
x_1 = p_1 z_1
\\
y_1 = q_1 z_1
\end{cases}
## end
#462, 70:
\begin{cases}
x=k_x\ t+x_0
\\
y=k_y\ t+y_0
\\
z=k_z\ t+z_0
\end{cases}
## end
#465, 97:
\begin{cases}
p_1\ z_1=k_x\ t_1+x_0
\\
q_1\ z_1=k_y\ t_1+y_0
\\
t_1=(z_1-z_0)/k_z
\end{cases}
\\

## end
#468, 409:
k_z\ p_1\ z_1=k_x\ (z_1-z_0)+k_z\ x_0
\\
=k_x\ z_1- k_x\ z_0+k_z\ x_0
\\\Rightarrow
(k_z\ p_1-k_x)\ z_1
=k_z\ x_0 - k_x\ z_0
\\\Rightarrow
z_1
=\frac{k_z\ x_0 - k_x\ z_0}
{k_z\ p_1-k_x}

\\\Rightarrow
t_1
=(z_1-z_0)/k_z
=\frac{k_z\ x_0 - k_x\ z_0}
{(k_z\ p_1-k_x)k_z} - z_0/k_z
\\
=\frac{k_z\ x_0 - k_x\ z_0 - (k_z\ p_1-k_x)z_0}
{(k_z\ p_1-k_x)k_z} 

\\\Rightarrow
t_1
=\frac{x_0 - p_1 z_0}
{k_z\ p_1-k_x} 



## end
#471, 156:
\begin{cases}
z_1
=\frac{k_z\ x_0 - k_x\ z_0}
{k_z\ p_1-k_x}
\\
t_1
=\frac{x_0 - p_1 z_0}
{k_z\ p_1-k_x}
\\
x_1=k_x\ t_1+x_0
\\
y_1=k_y\ t_1+y_0
\end{cases}
## end
#474, 156:
\begin{cases}
z_1
=\frac{k_z\ y_0 - k_y\ z_0}
{k_z\ q_1-k_y}
\\
t_1
=\frac{y_0 - q_1 z_0}
{k_z\ q_1-k_y}
\\
x_1=k_x\ t_1+x_0
\\
y_1=k_y\ t_1+y_0
\end{cases}
## end
#477, 17:
文档\数学问题\三维旋转.ftxt
## end
#479, 368:
\begin{cases}
\mathbf{X}=
(-sin\gamma sin\alpha cos\beta + cos\gamma cos\alpha,
sin\gamma cos\alpha cos\beta + cos\gamma sin\alpha,
sin\gamma sin\beta)
\\
\mathbf{Y}=
(-cos\gamma sin\alpha cos\beta - sin\gamma cos\alpha,
cos\gamma cos\alpha cos\beta - sin\gamma sin\alpha,
cos\gamma sin\beta)
\\
\mathbf{Z}=(sin\alpha sin\beta,-cos\alpha sin\beta,cos\beta)
\end{cases}
## end
#482, 288:
\begin{pmatrix}
x
\\
y
\\
z
\end{pmatrix}
=(\mathbf{X},\mathbf{Y},\mathbf{Z})
\begin{pmatrix}
x'
\\
y'
\\
z'
\end{pmatrix}
+
\begin{pmatrix}
x_c
\\
y_c
\\
z_c
\end{pmatrix}
=\hat{\mathbf{T}}
\begin{pmatrix}
x'
\\
y'
\\
z'
\end{pmatrix}
+
\begin{pmatrix}
x_c
\\
y_c
\\
z_c
\end{pmatrix}



## end
#485, 118:
(a,b,c) \left[
\begin{pmatrix}
x
\\
y
\\
z
\end{pmatrix}

-

\begin{pmatrix}
x_0
\\
y_0
\\
z_0
\end{pmatrix}
\right]=0
## end
#488, 341:
(a,b,c) \left[
\hat{\mathbf{T}}
\begin{pmatrix}
x'
\\
y'
\\
z'
\end{pmatrix}
+
\begin{pmatrix}
x_c - x_0
\\
y_c - y_0
\\
z_c - z_0
\end{pmatrix}
\right]=0
\\


(a,b,c) 
\hat{\mathbf{T}}
\left[
\begin{pmatrix}
x'
\\
y'
\\
z'
\end{pmatrix}
-

\hat{\mathbf{T}}^{-1}
\begin{pmatrix}
x_0 - x_c
\\
y_0 - y_c
\\
z_0 - z_c
\end{pmatrix}
\right]
=0


## end
#491, 260:
\begin{pmatrix}
a'
\\
b'
\\
c'
\end{pmatrix}
=
\hat{\mathbf{T}}^{-1}
\begin{pmatrix}
a
\\
b
\\
c
\end{pmatrix}
,\ 

\begin{pmatrix}
x'_0
\\
y'_0
\\
z'_0
\end{pmatrix}

=

\hat{\mathbf{T}}^{-1}
\begin{pmatrix}
x_0 - x_c
\\
y_0 - y_c
\\
z_0 - z_c
\end{pmatrix}


## end
#494, 146:
\begin{pmatrix}
x
\\
y
\\
z
\end{pmatrix}

=
\begin{pmatrix}
k_x
\\
k_y
\\
k_z
\end{pmatrix}
t

+

\begin{pmatrix}
x_0
\\
y_0
\\
z_0
\end{pmatrix}
## end
#497, 433:
\hat{\mathbf{T}}
\begin{pmatrix}
x'
\\
y'
\\
z'
\end{pmatrix}
+
\begin{pmatrix}
x_c
\\
y_c
\\
z_c
\end{pmatrix}

=
\begin{pmatrix}
k_x
\\
k_y
\\
k_z
\end{pmatrix}
t

+

\begin{pmatrix}
x_0
\\
y_0
\\
z_0
\end{pmatrix}



\\

\begin{pmatrix}
x'
\\
y'
\\
z'
\end{pmatrix}
=

\hat{\mathbf{T}}^{-1}
\begin{pmatrix}
k_x
\\
k_y
\\
k_z
\end{pmatrix}
t

+

\hat{\mathbf{T}}^{-1}
\begin{pmatrix}
x_0-x_c
\\
y_0-y_c
\\
z_0-z_c
\end{pmatrix}




## end
#500, 272:
\begin{pmatrix}
k_x'
\\
k_y'
\\
k_z'
\end{pmatrix}
=
\hat{\mathbf{T}}^{-1}
\begin{pmatrix}
k_x
\\
k_y
\\
k_z
\end{pmatrix}
,\ 

\begin{pmatrix}
x'_0
\\
y'_0
\\
z'_0
\end{pmatrix}

=

\hat{\mathbf{T}}^{-1}
\begin{pmatrix}
x_0 - x_c
\\
y_0 - y_c
\\
z_0 - z_c
\end{pmatrix}


## end
#502, 3:
507
## end
#505, 427:
%{
+[M函数](,测试函数)

GetPointOnPlane(M函数):...
getPointOnLine(M函数):...
在选择区域中, 将'getPointOnLine'的"pt1\(3\)"替换为"z0"
在 照片测量.ftxt 的+[二维坐标转三维坐标] 中被使用
%}

% x=[ptA(1),ptB(1),ptC(1),ptD(1)];
% y=[ptA(2),ptB(2),ptC(2),ptD(2)];
addpath('Matlab\space');

center=pt+siz/2;
x=x0-center(1);
y=y0-center(2);
[Eulers,r0,S]=camera_from_photo(x,y,1);

abc=[0,0,1];
pt0=[0,0,0];
[X,Y,Z]=GetPointOnPlane(x,y,pt0,abc,Eulers,r0,S)


%{
+[M函数](,M代码)
%}
## end
#507, 3:
517
## end
#510, 696:
%{
地址::Matlab\space\getPointOnLine.m
+[保存M函数](,getPointOnLine)

保存:...
测试:...
%}


function [X,Y,Z]=getPointOnLine(x,y,pt1,k1,pt0,Eulers0,S)

[Xu,Yu,Zu]=Euler_frame(Eulers0(1),Eulers0(2),Eulers0(3));
T=[Xu',Yu',Zu'];
k=k1*T;
Dp=pt1-pt0;
x0=sum(Dp.*Xu);
y0=sum(Dp.*Yu);
z0=sum(Dp.*Zu);

p=x/S;
q=y/S;

p0=k(1)/k(3);
q0=k(2)/k(3);
kp=x0-z0*k(1)/k(3);
kq=y0-z0*k(2)/k(3);
k_n=sqrt(kp.^2+kq.^2);

p1=p0+((p-p0)*kp+(q-q0)*kq)*kp/k_n^2;
% p1=p;
% q1=q;

t1=(x0-p1*z0)./(k(3)*p1-k(1));
% t1=(y0-q1*z0)./(k(3)*q1-k(2));
x1=k(1)*t1+x0;
y1=k(2)*t1+y0;
z1=k(3)*t1+z0;


X=Xu(1)*x1+Yu(1)*y1+Zu(1)*z1;
Y=Xu(2)*x1+Yu(2)*y1+Zu(2)*z1;
Z=Xu(3)*x1+Yu(3)*y1+Zu(3)*z1;


X=X+pt0(1);
Y=Y+pt0(2);
Z=Z+pt0(3);


end


 
## end
#513, 668:
%{
地址::Matlab\space\GetPointOnPlane.m
+[保存M函数](,GetPointOnPlane)

保存:...
%}


function [X,Y,Z]=GetPointOnPlane(x,y,pt1,Eulers1,pt0,Eulers0,S)
% center=pt+siz/2;
% x=x0-center(1);
% y=y0-center(2);
% [Eulers,r0,S]=camera_from_photo(x,y,1);


% abc=[0,0,1];
% pt0=[0,0,0];


[Xu,Yu,Zu]=Euler_frame(Eulers0(1),Eulers0(2),Eulers0(3));
T=[Xu',Yu',Zu'];

[~,~,abc]=Euler_frame(Eulers1(1),Eulers1(2),Eulers1(3));
abc1=abc*T;
pt01=(pt1-pt0)*T;
p1=x/S;
q1=y/S;


Z1=sum(abc1.*pt01)./(abc1(1)*p1+abc1(2)*q1+abc1(3));
X1=p1.*Z1;
Y1=q1.*Z1;


X=Xu(1)*X1+Yu(1)*Y1+Zu(1)*Z1;
Y=Xu(2)*X1+Yu(2)*Y1+Zu(2)*Z1;
Z=Xu(3)*X1+Yu(3)*Y1+Zu(3)*Z1;


X=X+pt0(1);
Y=Y+pt0(2);
Z=Z+pt0(3);


end


 
## end
#516, 29:
Matlab\space\getPointOnLine.m
## end
#517, 3:
642
## end
#520, 1350:
<!--
+[H函数](,正投影)
-->

<h2>Euler angles</h2>
Assume \((\alpha,\beta,\gamma)\) are Euler angles of a local coordinate. Three axes of the frame are,
%[1].
Projection on the xy-plane is,
%[2].

Then the angle \(\theta_xz\) is,
%[3].
%[4].
%[5].
By a similar calculation, we have,
%[6].

It's easy to prove that,
%[7].
Then,
%[8].
%[9].

Then, we will have, 
%[10].
%[11].
%[11.B].

And,
%[12].
%[13].
%[13.B].
%[14].

Eq.(11.B) adds eq.(14),
%[15].
%[16].
%[17].


<!--
[17].:
将"\eqs{\vec{x_0}=\vec{-sin(\gamma)*sin(\alpha)*cos(\beta)+cos(\gamma)*cos(\alpha),sin(\gamma)*cos(\alpha)*cos(\beta)+cos(\gamma)*sin(\alpha)};
\vec{y_0}=\vec{-cos(\gamma)*sin(\alpha)*cos(\beta)-sin(\gamma)*cos(\alpha),cos(\gamma)*cos(\alpha)*cos(\beta)-sin(\gamma)*sin(\alpha)};
\vec{z_0}=\vec{sin(\alpha)*sin(\beta),-cos(\alpha)*sin(\beta)}}"记作为式(2)

将"\eqs{[\vec{x_0}]=\sqrt{1-sin(\gamma)^2*sin(\beta)^2};
[\vec{y_0}]=\sqrt{1-cos(\gamma)^2*sin(\beta)^2};
[\vec{z_0}]=sin(\beta)}"记作为式(7)

将"\eqs{A*(1-sin(\gamma)^2*sin(\beta)^2)=sin(\gamma)^2*cos(\beta)^2;
B*(1-cos(\gamma)^2*sin(\beta)^2)=cos(\gamma)^2*cos(\beta)^2}"记作为式(9)

将"(A+B-1)=(A*sin(\gamma)^2+B*cos(\gamma)^2-1)*sin(\beta)^2"记作为式(11.B)

将"A*B=(B*sin(\gamma)^2+A*cos(\gamma)^2-A*B)*cos(\beta)^2"记作为式(14)

将"\frac{A*B}{(B-A)*sin(\gamma)^2+A(1-B)}-\frac{A+B-1}{(B-A)*sin(\gamma)^2+(1-B)}=1"记作为式(17)


+[H函数](,正投影)
-->
## end
#523, 515:
\begin{cases}
\vec{X}=\begin{pmatrix}
-sin(\gamma)\ sin(\alpha)\ cos(\beta)+cos(\gamma)\ cos(\alpha),&sin(\gamma)\ cos(\alpha)\ cos(\beta)+cos(\gamma)\ sin(\alpha),&sin(\gamma)\ sin(\beta)
\end{pmatrix}

\\ \vec{Y}=\begin{pmatrix}
-cos(\gamma)\ sin(\alpha)\ cos(\beta)-sin(\gamma)\ cos(\alpha),&cos(\gamma)\ cos(\alpha)\ cos(\beta)-sin(\gamma)\ sin(\alpha),&cos(\gamma)\ sin(\beta)
\end{pmatrix}

\\ \vec{Z}=\begin{pmatrix}
sin(\alpha)\ sin(\beta),&-cos(\alpha)\ sin(\beta),&cos(\beta)
\end{pmatrix}


\end{cases}


## end
#524, 391:
\eqs{\vec{X}=\vec{-sin(\gamma)*sin(\alpha)*cos(\beta)+cos(\gamma)*cos(\alpha),sin(\gamma)*cos(\alpha)*cos(\beta)+cos(\gamma)*sin(\alpha),sin(\gamma)*sin(\beta)};
\vec{Y}=\vec{-cos(\gamma)*sin(\alpha)*cos(\beta)-sin(\gamma)*cos(\alpha),cos(\gamma)*cos(\alpha)*cos(\beta)-sin(\gamma)*sin(\alpha),cos(\gamma)*sin(\beta)};
\vec{Z}=\vec{sin(\alpha)*sin(\beta),-cos(\alpha)*sin(\beta),cos(\beta)}}
## end
#528, 459:
\begin{cases}
\vec{x_0}=\begin{pmatrix}
-sin(\gamma)\ sin(\alpha)\ cos(\beta)+cos(\gamma)\ cos(\alpha),&sin(\gamma)\ cos(\alpha)\ cos(\beta)+cos(\gamma)\ sin(\alpha)
\end{pmatrix}

\\ \vec{y_0}=\begin{pmatrix}
-cos(\gamma)\ sin(\alpha)\ cos(\beta)-sin(\gamma)\ cos(\alpha),&cos(\gamma)\ cos(\alpha)\ cos(\beta)-sin(\gamma)\ sin(\alpha)
\end{pmatrix}

\\ \vec{z_0}=\begin{pmatrix}
sin(\alpha)\ sin(\beta),&-cos(\alpha)\ sin(\beta)
\end{pmatrix}


\end{cases}


## end
#529, 340:
\eqs{\vec{x_0}=\vec{-sin(\gamma)*sin(\alpha)*cos(\beta)+cos(\gamma)*cos(\alpha),sin(\gamma)*cos(\alpha)*cos(\beta)+cos(\gamma)*sin(\alpha)};
\vec{y_0}=\vec{-cos(\gamma)*sin(\alpha)*cos(\beta)-sin(\gamma)*cos(\alpha),cos(\gamma)*cos(\alpha)*cos(\beta)-sin(\gamma)*sin(\alpha)};
\vec{z_0}=\vec{sin(\alpha)*sin(\beta),-cos(\alpha)*sin(\beta)}}
## end
#533, 252:
\vec{x_0}\cdot \vec{z_0}=\left(-sin(\gamma)\ sin(\alpha)\ cos(\beta)+cos(\gamma)\ cos(\alpha)\right)\ \left(sin(\alpha)\ sin(\beta)\right)+\left(sin(\gamma)\ cos(\alpha)\ cos(\beta)+cos(\gamma)\ sin(\alpha)\right)\ \left(-cos(\alpha)\ sin(\beta)\right)
## end
#534, 198:
\vec{x_0}\cdot \vec{z_0}=(-sin(\gamma)*sin(\alpha)*cos(\beta)+cos(\gamma)*cos(\alpha))*(sin(\alpha)*sin(\beta))+(sin(\gamma)*cos(\alpha)*cos(\beta)+cos(\gamma)*sin(\alpha))*(-cos(\alpha)*sin(\beta))
## end
#538, 257:
\vec{x_0}\cdot \vec{z_0}=\left(-sin(\gamma)\ sin(\alpha)^{2}\ cos(\beta)\ sin(\beta)+cos(\gamma)\ cos(\alpha)\ sin(\alpha)\ sin(\beta)\right)-\left(sin(\gamma)\ cos(\alpha)^{2}\ cos(\beta)\ sin(\beta)+cos(\gamma)\ sin(\alpha)\ cos(\alpha)\ sin(\beta)\right)
## end
#540, 94:
cos(\theta_{xz})\ \left|\vec{x_0}\right|\ \left|\vec{z_0}\right|=-sin(\gamma)\ sin(2\ \beta)/2
## end
#541, 219:
\vec{x_0}\cdot \vec{z_0}=(-sin(\gamma)*sin(\alpha)^2*cos(\beta)*sin(\beta)+cos(\gamma)*cos(\alpha)*sin(\alpha)*sin(\beta))-(sin(\gamma)*cos(\alpha)^2*cos(\beta)*sin(\beta)+cos(\gamma)*sin(\alpha)*cos(\alpha)*sin(\beta))
## end
#544, 66:
cos(\theta_xz)*[\vec{x_0}]*[\vec{z_0}]=-sin(\gamma)*sin(2*\beta)/2
## end
#548, 94:
cos(\theta_{yz})\ \left|\vec{y_0}\right|\ \left|\vec{z_0}\right|=-cos(\gamma)\ sin(2\ \beta)/2
## end
#549, 66:
cos(\theta_yz)*[\vec{y_0}]*[\vec{z_0}]=-cos(\gamma)*sin(2*\beta)/2
## end
#553, 193:
\begin{cases}
\left|\vec{x_0}\right|=\sqrt{1-sin(\gamma)^{2}\ sin(\beta)^{2}}\\ \left|\vec{y_0}\right|=\sqrt{1-cos(\gamma)^{2}\ sin(\beta)^{2}}\\ \left|\vec{z_0}\right|=sin(\beta)
\end{cases}


## end
#554, 126:
\eqs{[\vec{x_0}]=\sqrt{1-sin(\gamma)^2*sin(\beta)^2};
[\vec{y_0}]=\sqrt{1-cos(\gamma)^2*sin(\beta)^2};
[\vec{z_0}]=sin(\beta)}
## end
#558, 211:
\begin{cases}
cos(\theta_{xz})=\frac{-sin(\gamma)\ cos(\beta)}{\sqrt{1-sin(\gamma)^{2}\ sin(\beta)^{2}}}\\ cos(\theta_{yz})=\frac{-cos(\gamma)\ cos(\beta)}{\sqrt{1-cos(\gamma)^{2}\ sin(\beta)^{2}}}
\end{cases}


## end
#559, 172:
\eqs{cos(\theta_xz)=\frac{-sin(\gamma)*cos(\beta)}{\sqrt{1-sin(\gamma)^2*sin(\beta)^2}};
cos(\theta_yz)=\frac{-cos(\gamma)*cos(\beta)}{\sqrt{1-cos(\gamma)^2*sin(\beta)^2}}}
## end
#563, 193:
\begin{cases}
A\ \left(1-sin(\gamma)^{2}\ sin(\beta)^{2}\right)=sin(\gamma)^{2}\ cos(\beta)^{2}\\ B\ \left(1-cos(\gamma)^{2}\ sin(\beta)^{2}\right)=cos(\gamma)^{2}\ cos(\beta)^{2}
\end{cases}


## end
#564, 126:
\eqs{A*(1-sin(\gamma)^2*sin(\beta)^2)=sin(\gamma)^2*cos(\beta)^2;
B*(1-cos(\gamma)^2*sin(\beta)^2)=cos(\gamma)^2*cos(\beta)^2}
## end
#568, 116:
A\ \left(1-sin(\gamma)^{2}\ sin(\beta)^{2}\right)+B\ \left(1-cos(\gamma)^{2}\ sin(\beta)^{2}\right)=1-sin(\beta)^{2}
## end
#570, 100:
\left(A+B\right)-\left(A\ sin(\gamma)^{2}+B\ cos(\gamma)^{2}\right)\ sin(\beta)^{2}=1-sin(\beta)^{2}
## end
#572, 84:
1+cos(\beta)^{2}=sin(\gamma)^{2}\ cos(\beta)^{2}/A+cos(\gamma)^{2}\ cos(\beta)^{2}/B
## end
#574, 81:
1+cos(\beta)^{2}=\left(sin(\gamma)^{2}/A+cos(\gamma)^{2}/B\right)\ cos(\beta)^{2}
## end
#575, 80:
A*(1-sin(\gamma)^2*sin(\beta)^2)+B*(1-cos(\gamma)^2*sin(\beta)^2)=1-sin(\beta)^2
## end
#578, 67:
(A+B)-(A*sin(\gamma)^2+B*cos(\gamma)^2)*sin(\beta)^2=1-sin(\beta)^2
## end
#581, 72:
1+cos(\beta)^2=sin(\gamma)^2*cos(\beta)^2/A+cos(\gamma)^2*cos(\beta)^2/B
## end
#584, 61:
1+cos(\beta)^2=(sin(\gamma)^2/A+cos(\gamma)^2/B)*cos(\beta)^2
## end
#588, 68:
1=\left(sin(\gamma)^{2}/A+cos(\gamma)^{2}/B-1\right)\ cos(\beta)^{2}
## end
#590, 87:
\left(A+B-1\right)=\left(A\ sin(\gamma)^{2}+B\ cos(\gamma)^{2}-1\right)\ sin(\beta)^{2}
## end
#591, 50:
1=(sin(\gamma)^2/A+cos(\gamma)^2/B-1)*cos(\beta)^2
## end
#594, 56:
(A+B-1)=(A*sin(\gamma)^2+B*cos(\gamma)^2-1)*sin(\beta)^2
## end
#598, 76:
A\ B=\left(B\ sin(\gamma)^{2}+A\ cos(\gamma)^{2}-A\ B\right)\ cos(\beta)^{2}
## end
#599, 54:
A*B=(B*sin(\gamma)^2+A*cos(\gamma)^2-A*B)*cos(\beta)^2
## end
#603, 111:
\frac{A\ B}{B\ sin(\gamma)^{2}+A\ cos(\gamma)^{2}-A\ B}+\frac{A+B-1}{A\ sin(\gamma)^{2}+B\ cos(\gamma)^{2}-1}=1
## end
#604, 97:
\frac{A*B}{B*sin(\gamma)^2+A*cos(\gamma)^2-A*B}+\frac{A+B-1}{A*sin(\gamma)^2+B*cos(\gamma)^2-1}=1
## end
#608, 107:
\frac{A\ B}{\left(B-A\right)\ sin(\gamma)^{2}+A-A\ B}+\frac{A+B-1}{\left(A-B\right)\ sin(\gamma)^{2}+B-1}=1
## end
#609, 77:
\frac{A*B}{(B-A)*sin(\gamma)^2+A-A*B}+\frac{A+B-1}{(A-B)*sin(\gamma)^2+B-1}=1
## end
#613, 120:
\frac{A\ B}{\left(B-A\right)\ sin(\gamma)^{2}+A(1-B)}-\frac{A+B-1}{\left(B-A\right)\ sin(\gamma)^{2}+\left(1-B\right)}=1
## end
#614, 80:
\frac{A*B}{(B-A)*sin(\gamma)^2+A(1-B)}-\frac{A+B-1}{(B-A)*sin(\gamma)^2+(1-B)}=1
## end
#618, 1115:
<!--
+[H函数](,球面约束)
-->

<h2>Coordinates on a sphere</h2>
Coordinates on a sphere having radius of \(R\) and a center at \(x_0,y_0\) are,
%[1].
%[2].
%[3].

Then coordinates, \((p,q)\), projected on the xy-plane are,
%[4].
%[5].
%[6].
%[7].

The frame can be rotated to a position where \(x_0=0\). Then,
%[8].
You can make \(\phi=0\) or \(\phi=\pi\) to determine the lineout of the whole shape, 
%[9].
Notice that, if \(\theta\) is fixed and \(\phi\) is free, then all points are on a circle. Radius and centers of those circles are, 
%[10].
%[11].

%[12].
Then the maximum radius is,
%[13].
As a result,
%[14].
%[15].
%[16].
%[17].

Then to check whether this maximum circle includes all circles. The top point on circles when \(x_0=0\) is, 
%[18].
Then,
%[19].
%[20].
%[21].
%[22].
Then,
%[23].
where,
%[24].
%[25].

As a result,
%[26].
%[27].
%[28].

As a result, it's NOT a circle unless \(y_0=0\). 

<!--
[28].:
式(18)转换为"表达式"
将"\theta=\theta_1+\theta_2"记作为式(23)
将"sin(\theta)=\frac{\sqrt{z_0^2+y_0^2-R^2}*z_0-R*y_0}{z_0^2+y_0^2}"记作为式(28)
将式(11)记作为式(16)

将"r=r_0"代入到式(15)
更新式(15)

验证公式(M函数):...
+[H函数](,球面约束)
-->
## end
#621, 33:
x=R\ sin(\theta)\ cos(\phi)+x_{0}
## end
#623, 33:
y=R\ sin(\theta)\ sin(\phi)+y_{0}
## end
#625, 22:
z=R\ cos(\theta)+z_{0}
## end
#627, 5:
p=x/z
## end
#629, 5:
q=y/z
## end
#630, 29:
x=R*sin(\theta)*cos(\phi)+x_0
## end
#633, 29:
y=R*sin(\theta)*sin(\phi)+y_0
## end
#636, 19:
z=R*cos(\theta)+z_0
## end
#640, 60:
p=\frac{sin(\theta)\ cos(\phi)+x_{0}/R}{cos(\theta)+z_{0}/R}
## end
#642, 60:
q=\frac{sin(\theta)\ sin(\phi)+y_{0}/R}{cos(\theta)+z_{0}/R}
## end
#643, 5:
p=x/z
## end
#646, 5:
q=y/z
## end
#649, 55:
p=\frac{sin(\theta)*cos(\phi)+x_0/R}{cos(\theta)+z_0/R}
## end
#652, 27:
R*sin(\theta)*cos(\phi)+x_0
## end
#654, 1:
x
## end
#656, 55:
q=\frac{sin(\theta)*sin(\phi)+y_0/R}{cos(\theta)+z_0/R}
## end
#659, 17:
R*cos(\theta)+z_0
## end
#661, 1:
z
## end
#663, 3:
x/z
## end
#665, 1:
p
## end
#667, 27:
R*sin(\theta)*sin(\phi)+y_0
## end
#669, 1:
y
## end
#672, 52:
p=\frac{sin(\theta)\ cos(\phi)}{cos(\theta)+z_{0}/R}
## end
#674, 41:
p=\frac{sin(\theta)}{cos(\theta)+z_{0}/R}
## end
#676, 41:
r=\frac{sin(\theta)}{cos(\theta)+z_{0}/R}
## end
#677, 49:
p=\frac{sin(\theta)*cos(\phi)}{cos(\theta)+z_0/R}
## end
#681, 39:
p=\frac{sin(\theta)}{cos(\theta)+z_0/R}
## end
#687, 41:
p_{c}=\frac{x_{0}/R}{cos(\theta)+z_{0}/R}
## end
#689, 41:
q_{c}=\frac{y_{0}/R}{cos(\theta)+z_{0}/R}
## end
#691, 125:
\frac{dr}{d\theta}=\frac{sin(\theta)^{2}+cos(\theta)\ \left(cos(\theta)+z_{0}/R\right)}{\left(cos(\theta)+z_{0}/R\right)^{2}}
## end
#692, 39:
r=\frac{sin(\theta)}{cos(\theta)+z_0/R}
## end
#695, 35:
p_c=\frac{x_0/R}{cos(\theta)+z_0/R}
## end
#698, 35:
q_c=\frac{y_0/R}{cos(\theta)+z_0/R}
## end
#701, 90:
\d{r}_{\theta}=\frac{sin(\theta)^2+cos(\theta)*(cos(\theta)+z_0/R)}{(cos(\theta)+z_0/R)^2}
## end
#705, 24:
cos(\theta_{0})=-R/z_{0}
## end
#707, 38:
r_{0}=\frac{R}{\sqrt{z_{0}^{2}-R^{2}}}
## end
#709, 42:
p_{0}=\frac{x_{0}\ z_{0}}{z_{0}^{2}-R^{2}}
## end
#710, 20:
cos(\theta_0)=-R/z_0
## end
#713, 30:
r_0=\frac{R}{\sqrt{z_0^2-R^2}}
## end
#717, 42:
q_{0}=\frac{y_{0}\ z_{0}}{z_{0}^{2}-R^{2}}
## end
#718, 29:
p_0=\frac{x_0*z_0}{z_0^2-R^2}
## end
#721, 29:
q_0=\frac{y_0*z_0}{z_0^2-R^2}
## end
#725, 55:
r+q_{c}=\frac{sin(\theta)+y_{0}/R}{cos(\theta)+z_{0}/R}
## end
#727, 93:
\left(cos(\theta)+z_{0}/R\right)\ cos(\theta)+\left(sin(\theta)+y_{0}/R\right)\ sin(\theta)=0
## end
#729, 40:
z_{0}\ cos(\theta)+y_{0}\ sin(\theta)=-R
## end
#730, 49:
r+q_c=\frac{sin(\theta)+y_0/R}{cos(\theta)+z_0/R}
## end
#733, 65:
(cos(\theta)+z_0/R)*cos(\theta)+(sin(\theta)+y_0/R)*sin(\theta)=0
## end
#736, 34:
z_0*cos(\theta)+y_0*sin(\theta)=-R
## end
#740, 121:
z_{0}\ cos(\theta)/\sqrt{z_{0}^{2}+y_{0}^{2}}+y_{0}\ sin(\theta)/\sqrt{z_{0}^{2}+y_{0}^{2}}=-R/\sqrt{z_{0}^{2}+y_{0}^{2}}
## end
#742, 73:
cos(\theta)\ cos(\theta_{1})+sin(\theta)\ sin(\theta_{1})=cos(\theta_{2})
## end
#743, 91:
z_0*cos(\theta)/\sqrt{z_0^2+y_0^2}+y_0*sin(\theta)/\sqrt{z_0^2+y_0^2}=-R/\sqrt{z_0^2+y_0^2}
## end
#746, 65:
cos(\theta)*cos(\theta_1)+sin(\theta)*sin(\theta_1)=cos(\theta_2)
## end
#750, 28:
\theta=\theta_{1}+\theta_{2}
## end
#751, 24:
\theta=\theta_1+\theta_2
## end
#755, 48:
cos(\theta_{1})=z_{0}/\sqrt{z_{0}^{2}+y_{0}^{2}}
## end
#757, 45:
cos(\theta_{2})=-R/\sqrt{z_{0}^{2}+y_{0}^{2}}
## end
#758, 36:
cos(\theta_1)=z_0/\sqrt{z_0^2+y_0^2}
## end
#761, 35:
cos(\theta_2)=-R/\sqrt{z_0^2+y_0^2}
## end
#765, 77:
sin(\theta)=sin(\theta_{1})\ cos(\theta_{2})+sin(\theta_{2})\ cos(\theta_{1})
## end
#767, 127:
sin(\theta)=-R\ y_{0}/\left(z_{0}^{2}+y_{0}^{2}\right)+\sqrt{z_{0}^{2}+y_{0}^{2}-R^{2}}\ z_{0}/\left(z_{0}^{2}+y_{0}^{2}\right)
## end
#768, 67:
sin(\theta)=sin(\theta_1)*cos(\theta_2)+sin(\theta_2)*cos(\theta_1)
## end
#771, 73:
sin(\theta)=-R*y_0/(z_0^2+y_0^2)+\sqrt{z_0^2+y_0^2-R^2}*z_0/(z_0^2+y_0^2)
## end
#775, 88:
sin(\theta)=\frac{\sqrt{z_{0}^{2}+y_{0}^{2}-R^{2}}\ z_{0}-R\ y_{0}}{z_{0}^{2}+y_{0}^{2}}
## end
#776, 64:
sin(\theta)=\frac{\sqrt{z_0^2+y_0^2-R^2}*z_0-R*y_0}{z_0^2+y_0^2}
## end
#780, 282:
%{
+[M函数](,验证公式)
%}

theta=linspace(0,180,10);
phi=linspace(0,360,200);
x_0=0;
y_0=10;
z_0=10;

[Theta,Phi]=meshgrid(theta,phi);
R=1;

X=R*sind(Theta).*cosd(Phi)+x_0;
Y=R*sind(Theta).*sind(Phi)+y_0;
Z=R*cosd(Theta)+z_0;

x=X./Z;
y=Y./Z;
plot(x,y,'r')
axis equal

%{
+[M函数](,验证公式)
%}
## end
#783, 30:
Matlab\space\GetPointOnPlane.m
## end
#792, 597:
%{
地址::Matlab\space\GetPointOnPlane.m
+[保存M函数](,GetPointOnPlane)

保存:...
%}


function [X,Y,Z]=GetPointOnPlane(x,y,pt0,abc,Eulers,r0,S)
% center=pt+siz/2;
% x=x0-center(1);
% y=y0-center(2);
% [Eulers,r0,S]=camera_from_photo(x,y,1);


% abc=[0,0,1];
% pt0=[0,0,0];


[Xu,Yu,Zu]=Euler_frame(Eulers(1),Eulers(2),Eulers(3));
T=[Xu',Yu',Zu'];
abc1=abc*T;
pt01=(pt0-r0)*T;
p1=x/S;
q1=y/S;


Z1=sum(abc1.*pt01)./(abc1(1)*p1+abc1(2)*q1+abc1(3));
X1=p1.*Z1;
Y1=q1.*Z1;


X=Xu(1)*X1+Yu(1)*Y1+Zu(1)*Z1;
Y=Xu(2)*X1+Yu(2)*Y1+Zu(2)*Z1;
Z=Xu(3)*X1+Yu(3)*Y1+Zu(3)*Z1;


X=X+r0(1);
Y=Y+r0(2);
Z=Z+r0(3);


end


 
## end
#794, 531:
%{
地址::Matlab\space\getPointOnLine.m
+[保存M函数](,getPointOnLine)

保存:...
%}


function [X,Y,Z]=getPointOnLine(x,y,pt0,k0,Eulers,r0,S)

[Xu,Yu,Zu]=Euler_frame(Eulers(1),Eulers(2),Eulers(3));
T=[Xu',Yu',Zu'];
k01=k0*T;
pt01=(pt0-r0)*T;
p1=x/S;
q1=y/S;


z1=(k01(3)*pt01(1)-k01(1)*pt01(3))./(k01(3)*p1-k01(1));
t1=(pt01(1)-p1*pt01(3))./(k01(3)*p1-k01(1));
x1=k01(1)*t1+pt01(1);
y1=k01(2)*t1+pt01(2);


X=Xu(1)*x1+Yu(1)*y1+Zu(1)*z1;
Y=Xu(2)*x1+Yu(2)*y1+Zu(2)*z1;
Z=Xu(3)*x1+Yu(3)*y1+Zu(3)*z1;


X=X+r0(1);
Y=Y+r0(2);
Z=Z+r0(3);


end


 
## end
#796, 641:
<!--
+[H函数](,直线约束)
-->

<h2>Line restriction</h2>
If points are on a line which passing through \((x_0,y_0,z_0)\) along the direction of \((k_x,k_y,k_z)\), then
%[1].
%[2].
%[3].
Then the coordinate \((p,q)\) on the projection plane is,
%[4].
%[5].
%[6].
And,
%[7].
which means that \((p,q)\) are on a straight line, 
%[8].
%[9].
As a result, the length of the projection line isn't a linear function of the length of the 3D line. It's still recommanded to solve the 3D coordinate first. <br>
We have,
%[10].
%[11].
%[12].

<!--
[12].:
式(10)转换为"表达式"
将"t=\frac{x_0-z_0*p}{p*k_z-k_x}"记作为式(12)
将式(3)代入到式(4)

交换式(10)的两边
更新式(10)
+[H函数](,直线约束)
-->
## end
#799, 16:
x=t\ k_{x}+x_{0}
## end
#801, 16:
y=t\ k_{y}+y_{0}
## end
#803, 16:
z=t\ k_{z}+z_{0}
## end
#804, 11:
x=t*k_x+x_0
## end
#808, 11:
y=t*k_y+y_0
## end
#812, 11:
z=t*k_z+z_0
## end
#817, 39:
p=\frac{t\ k_{x}+x_{0}}{t\ k_{z}+z_{0}}
## end
#819, 90:
p=\frac{\left(t\ k_{z}+z_{0}\right)\ k_{x}/k_{z}-z_{0}\ k_{x}/k_{z}+x_{0}}{t\ k_{z}+z_{0}}
## end
#821, 69:
p=\frac{k_{x}}{k_{z}}+\frac{x_{0}-z_{0}\ k_{x}/k_{z}}{t\ k_{z}+z_{0}}
## end
#822, 29:
p=\frac{t*k_x+x_0}{t*k_z+z_0}
## end
#826, 9:
t*k_x+x_0
## end
#828, 1:
x
## end
#832, 9:
t*k_z+z_0
## end
#834, 1:
z
## end
#838, 55:
p=\frac{(t*k_z+z_0)*k_x/k_z-z_0*k_x/k_z+x_0}{t*k_z+z_0}
## end
#842, 51:
p=\frac{k_x}{k_z}+\frac{x_0-z_0*k_x/k_z}{t*k_z+z_0}
## end
#847, 69:
q=\frac{k_{y}}{k_{z}}+\frac{y_{0}-z_{0}\ k_{y}/k_{z}}{t\ k_{z}+z_{0}}
## end
#848, 51:
q=\frac{k_y}{k_z}+\frac{y_0-z_0*k_y/k_z}{t*k_z+z_0}
## end
#853, 93:
\frac{p-k_{x}/k_{z}}{x_{0}-z_{0}\ k_{x}/k_{z}}=\frac{q-k_{y}/k_{z}}{y_{0}-z_{0}\ k_{y}/k_{z}}
## end
#854, 67:
\frac{p-k_x/k_z}{x_0-z_0*k_x/k_z}=\frac{q-k_y/k_z}{y_0-z_0*k_y/k_z}
## end
#859, 97:
\frac{p\ k_{z}-k_{x}}{x_{0}\ k_{z}-z_{0}\ k_{x}}=\frac{q\ k_{z}-k_{y}}{y_{0}\ k_{z}-z_{0}\ k_{y}}
## end
#860, 67:
\frac{p*k_z-k_x}{x_0*k_z-z_0*k_x}=\frac{q*k_z-k_y}{y_0*k_z-z_0*k_y}
## end
#865, 71:
\frac{t\ k_{z}+z_{0}}{x_{0}-z_{0}\ k_{x}/k_{z}}=\frac{1}{p-k_{x}/k_{z}}
## end
#867, 63:
t\ k_{z}+z_{0}=\frac{x_{0}\ k_{z}-z_{0}\ k_{x}}{p\ k_{z}-k_{x}}
## end
#869, 39:
t=\frac{x_{0}-z_{0}\ p}{p\ k_{z}-k_{x}}
## end
#870, 53:
\frac{t*k_z+z_0}{x_0-z_0*k_x/k_z}=\frac{1}{p-k_x/k_z}
## end
#874, 43:
t*k_z+z_0=\frac{x_0*k_z-z_0*k_x}{p*k_z-k_x}
## end
#878, 29:
t=\frac{x_0-z_0*p}{p*k_z-k_x}
## end
#887, 739:
%{
+[M函数](,测试)
%}

x=870.912;
y=-1020.1;
pt1=[-0.3965, 0.3895, 0];
k1=[0,0,1];
pt0=[-2.4228   -6.6836    1.5707];
Eulers0=[-33.5658   66.7196    0.6476];
S=2839;

[Xu,Yu,Zu]=Euler_frame(Eulers0(1),Eulers0(2),Eulers0(3));
T=[Xu',Yu',Zu'];
k=k1*T;
Dp=pt1-pt0;
x0=sum(Dp.*Xu);
y0=sum(Dp.*Yu);
z0=sum(Dp.*Zu);

p=x/S;
q=y/S;

p0=k(1)/k(3);
q0=k(2)/k(3);
kp=x0-z0*k(1)/k(3);
kq=y0-z0*k(2)/k(3);
k_n=sqrt(kp.^2+kq.^2);

% p1=p0+((p-p0)*kp+(q-q0)*kq)*kp/k_n^2;
p1=p;
q1=q;

% t1=(x0-p1*z0)./(k(3)*p1-k(1));
t1=(y0-q1*z0)./(k(3)*q1-k(2));
x1=k(1)*t1+x0;
y1=k(2)*t1+y0;
z1=k(3)*t1+z0;
pt0,[x0,y0,z0]
t1,[x1,y1,z1]

X=Xu(1)*x1+Yu(1)*y1+Zu(1)*z1;
Y=Xu(2)*x1+Yu(2)*y1+Zu(2)*z1;
Z=Xu(3)*x1+Yu(3)*y1+Zu(3)*z1;


X=X+pt0(1);
Y=Y+pt0(2);
Z=Z+pt0(3);




 
## end
### 结束