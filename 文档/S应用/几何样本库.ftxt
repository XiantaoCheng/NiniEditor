### 节点
地址, [标题], 的, 几何样本库, 目录, 的, 的, 样本库, 的, 节点数目统计, 20210326, 的, 的, 画图, 的, 数学概念场景, 的, 坐标系, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 选中区域, 的, 的, 输出, HTML, 的, 的, 输出, 输入, 的, 的, 起点, 尺寸, 类型, 的, 原点, 的, 的, x坐标, 的, y坐标, 的, 的, 的, A线, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线型, 线粗细, 的, B线, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线型, 线粗细, 的, 交点, 的, 数值, 的, 类型, 的, 数学公式, 的, 两直线交点, 的, 网页画板, 的, 画图, P代码, 的, 输出, 的, 输入, pt0, 等于, pt22, 等于, pt21, 等于, pt12, 等于, pt11, 等于, 的, 的, 的, 的, 的, 的, 的, 角度, 的, 数值, 的, 类型, 的, P代码, 输出, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, angle, 等于, pt22, 等于, pt21, 等于, pt12, 等于, pt11, 等于, 的, 的, 的, 的, 的, 的, 夹角, 的, 画图, 的, 输入, 比例, 的, 尺寸, 的, 原点, 的, 坐标系, 的, 标记, 的, 的, 标记, 的, 的, 垂线, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线型, 线粗细, 的, P代码, 的, 输出, 的, 输入, pt01, 等于, pt12, 是, pt11, 是, pt02, 是, 的, 的, 的, 的, pt11, 是, 的, 20210328, 的, 的, 函数曲线, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 选中区域, 的, 的, 输出, HTML, 的, 的, 输出, 输入, 的, 的, 的, 的, 的, 的, 起点, 尺寸, 类型, 线型, 线粗细, 面颜色, 线颜色, 的, 中心位置, 的, 分辨率, 的, 函数, 的, 的, 的, 的, 可选, 的, 的, 可选, 的, 的, 几何动词, 的, 描述, 的, 词典, 的, 动词释义, 的, 主语, 的, 宾语, 的, 谓语, 20210329, 的, 20210331, 的, 的, 创建函数曲线, 的, 创建坐标系, 20210401, 的, 的, 内容, 的, 测试, 的, 编号, 的, 删除编号, 的, 的, 的, 创建交点, 的, 创建角度, 的, 创建垂线, 20210406, 的, 20210407, 的, 20210410, 的, 标记, 的, 输入, 等于, pt0, 等于, pt22, 等于, pt21, 等于, pt12, 等于, pt11, 的, 的, 的, 的, 的, 输出, 的, 的, P代码, 的, 作用代码, 的, 的, 画图, 类型, 数值, 的, 的, 的, 的, 的, 的, 交点, 的, 交点1, 标记, 的, 输入, 等于, pt0, 等于, pt22, 等于, pt21, 等于, pt12, 等于, pt11, 的, 的, 的, 的, 的, 输出, 的, 的, P代码, 的, 作用代码, 的, 的, 画图, 类型, 数值, 等于, 等于, 等于, 等于, 等于, 20210411, 的, 20210413, 的, 20210414, 的, 20210416, 的, 20210418, 的, 20210419, 的, 20210423, 的, 20210425, 的, 的, HTML, 的, 的, 验证, M函数, 的, 中心, 的, 半径, 的, 起始角度, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, HTML, 的, 的, 的, 的, 的, 的, 的, 的, 20210427, 的, 的, 新窗口, 的, 新窗口, 20210504, 的, 20210518, 的, 20210519, 的, 20210526, 的, 20210528, 的, 20210529, 的, 20210530, 的, 20210531, 的, 20210601, 的, 20210603, 的, 20210604, 的, 20210706, 的, 20210816, 的, 20210818, 的, 20210904, 的, 
### 关联
#, #, 3#0, #, #, 4#3, 3#7, #, 4#9, #, #, 9#10, 3#13, #, 3#15, #, 15#17, #, 17#24, 17#32, 17#36, 17#43, 17#44, 17#45, #, 24#40, 24#29, 24#30, 24#31, #, #, #, #, 32#35, 32#40, #, #, 36#39, 36#40, #, #, 40#44, 40#43, #, #, #, 17#47, #, 40#47, 17#50, #, 17#52, #, 40#50, 40#52, 15#56, #, 56#94, 56#95, 56#66, 56#74, 56#75, 56#96, 56#97, 56#98, 56#86, #, 66#88, 66#71, 66#72, 66#73, #, #, #, #, #, 75#79, 75#82, 75#83, #, 79#94, 79#95, #, #, 83#85, #, #, 86#88, #, 88#94, 88#95, 88#96, 88#97, 88#98, #, #, #, #, #, 15#100, #, 100#138, 100#139, 100#110, 100#118, 100#119, 100#140, 100#141, 100#142, 100#130, #, 110#132, 110#115, 110#116, 110#117, #, #, #, #, #, 119#123, 119#126, 119#127, #, 123#138, 123#139, #, #, 127#129, #, #, 130#132, #, 132#138, 132#139, 132#140, 132#141, 132#142, #, #, #, #, #, 15#144, 56#100, 144#146, #, 144#148, #, 3#150, #, 150#152, #, 3#154, #, 144#156, #, #, 157#159, #, 157#161, #, #, 162#146, #, 164#139, #, 166#138, #, 168#95, #, 170#94, 159#170, 159#168, 159#166, 159#164, 159#162, 144#157, 15#179, 56#100, 179#181, #, 179#183, #, 179#185, #, #, 185#188, #, 179#199, 179#200, 179#201, 179#202, 179#203, 179#204, 179#205, 179#206, 179#207, 179#208, #, 199#181, #, 201#139, #, 203#138, #, 205#95, #, 207#94, 186#207, 186#205, 186#203, 186#201, 186#199, 150#215, #, 179#217, #, 217#219, #, #, 226#220, #, 226#222, #, 226#224, 15#, 179#228, #, 219#228, 144#231, #, 161#231, 15#234, 56#, 234#272, 234#273, 234#244, 234#252, 234#253, 234#274, 234#275, 234#276, 234#264, #, 244#266, 244#249, 244#250, 244#251, #, #, #, #, #, 253#257, 253#260, 253#261, #, 257#272, 257#273, #, #, 261#263, #, #, 264#266, #, 266#272, 266#273, 266#274, 266#275, 266#276, #, #, #, #, #, 234#278, #, 278#280, #, 278#282, #, #, 283#272, #, 95#285, #, 94#287, #, 273#289, 282#289, 282#287, 282#285, 280#283, #, 94#295, 266#295, #, 9#298, 15#301, #, 301#312, 301#320, 301#324, 301#335, 301#336, 301#337, 301#338, 301#339, 301#340, 301#341, #, 312#328, 312#317, 312#318, 312#319, #, #, #, #, 320#323, 320#328, #, #, 324#327, 324#328, #, #, 328#340, 328#341, 328#338, 328#339, 328#336, 328#335, #, #, #, #, #, #, #, 301#343, #, 301#345, #, 301#347, #, 328#343, 328#345, 328#347, 301#352, #, 328#352, 17#355, #, 40#355, 3#358, #, 358#360, #, 360#362, #, 362#364, #, 362#366, #, 362#368, #, 362#370, #, #, 9#371, #, 9#373, 358#376, #, 358#378, #, #, 9#379, 370#382, #, 382#384, #, 364#386, #, 364#388, #, 358#386, 358#388, 358#392, #, 358#394, #, 358#396, #, #, 9#397, #, 9#399, #, 9#401, #, 405#403, #, 407#431, #, 409#139, #, 411#138, #, 413#273, #, 415#272, #, 421#407, 421#409, 421#411, 421#413, 421#415, #, 424#405, 424#421, #, 426#424, #, 429#405, 429#421, #, #, #, 438#403, 438#426, 438#424, 438#429, 438#430, 438#431, #, 15#440, 234#100, #, 443#441, #, 445#469, #, 447#139, #, 449#138, #, 451#273, #, 453#272, #, 459#445, 459#447, 459#449, 459#451, 459#453, #, 462#443, 462#459, #, 464#462, #, 467#443, 467#459, #, #, #, #, #139, #138, #273, #272, #, 9#475, #, 9#477, #, 9#479, #, 9#481, #, 9#483, #, 9#485, #, 9#487, #, 9#489, 179#492, #, 492#219, 215#495, #, 495#, 179#498, #, 179#500, #, 179#502, #, 186#498, 186#502, 185#186, 219#498, 219#500, 219#502, 219#181, 156#161, 161#146, 144#513, #, 513#161, 188#502, 188#498, 188#199, 188#201, 188#203, 188#205, 188#207, #, 9#522, 3#525, #, 3#527, #, #, 9#528, #, 9#530, #, 9#532, #, 9#534, #, 9#536, #, 9#538, #, 9#540, #, 9#542, #, 9#544, #, 9#546, #, 9#548, #, 9#550, #, 9#552, #, 9#554, #, 9#556, 
### 内容
#0, 17:
文档\S应用\几何样本库.ftxt
## end
#1, 5:
几何样本库
## end
#3, 594:
+[返回目录](,几何样本库)
地址::文档\S应用\几何样本库.ftxt
+[导出结构](,几何样本库)
+[新建阅读窗口](,几何样本库)

几何动词:...
+[设置动词](,几何动词)

画图::文档\S应用\画图工具.ftxt
+[打开文件](+新窗口,画图)
样本库::文档\S应用\画图样本库.ftxt
+[打开文件](+新窗口,样本库)
网页画板::文档\S应用\网页画板.ftxt
+[打开文件](+新窗口,网页画板)

那么现在先把一些数学概念画出来吧. 比如说, 夹角, 交点, 垂直方向, 距离, 坐标系, 圆锥曲线, 三角函数, 切线之类的. 

数学概念场景:...
+[画板](+数学概念,数学概念场景)
的(数学概念场景,坐标系)->的(几何动词,创建坐标系)->+[生成动词](坐标系,创建坐标系)
的(数学概念场景,函数曲线)->的(几何动词,创建函数曲线)->+[生成动词](函数曲线,创建函数曲线)
的(数学概念场景,交点)->的(几何动词,创建交点)->+[描述](交点,创建交点);
的(数学概念场景,角度)->的(几何动词,创建角度)->+[描述](角度,创建角度);
的(数学概念场景,垂线)->的(几何动词,创建垂线)->+[描述](垂线,创建垂线);

数学公式:...


是([动词库],动词)->+[打开文件](+新窗口,动词)

## end
#4, 34:
几何样本库:...
创建于 20210326

节点数目统计::


## end
#7, 17:
文档\S应用\画图样本库.ftxt
## end
#10, 3:
317
## end
#13, 16:
文档\S应用\画图工具.ftxt
## end
#15, 512:
+[返回目录](,数学概念场景)
+[输出PPT]"文档\输出\20210526\test4.pptx"(数学概念场景,)

坐标系:...
函数曲线:...
A线:...
B线:...

+交点1(垂线,B线)
交点1:...
+[删除结构](,交点1)
+[创建交点](,交点1)

交点:...
角度:...
垂线:...
垂线(A线,)


+[选择结构](+内部结构,垂线)->+内部结构(,垂线)...
->+号码集(+内部结构,)->+[编号](垂线,+号码集)...
->+[设置结构](,+号码集)...
->+[删除编号](,+号码集)->+[del](,+内部结构)

数学概念场景=>的(数学概念场景,内部结构)=>+[del](,内部结构)

->+[描述](垂线,+[显示])->+谓语(+[描述],)->+[del](,+谓语)...
->+[del](,+内部结构)

+[描述](交点,+[显示])
->+动词释义(+[描述],)->+[del](,+动词释义)

+[创建矩形](,函数曲线)


+垂线(A线,)
+角度(A线,B线)
+交点(A线,B线)
+[创建直线](,B线)


## end
#17, 141:
+[返回目录](,坐标系)
+[设置结构](,坐标系)

起点::-200,100
尺寸::100,100
类型::矩形

原点::0.1,0.1
x坐标::x
y坐标::y

可选::YES

画图:...
选中区域:...
HTML:...

+[创建输入](可选,画图)



## end
#24, 1487:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


def drawArrow(qp,pt1,pt2):
    angle=30
    l=30
    D=0
    d=10
    
    lineWidth=2
    
    edgeColor=[0,0,0]
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush())
    
    r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
    if r!=0:
        theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
    dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
    dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]
    
    pt10=[0,0]
    pt20=[0,0]
    pt10[0]=pt1[0]
    pt10[1]=pt1[1]
    pt20[0]=pt2[0]
    pt20[1]=pt2[1]
    
    
    path2=QPainterPath()
    path2.moveTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
    path2.lineTo(pt20[0],pt20[1])
    path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])
    
    qp.drawPath(path2)
    
    
    qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])
    
    qp.setBrush(QBrush())
    qp.setPen(QPen())


pt=起点
size=尺寸
orig=[pt[0]+size[0]*原点[0],pt[1]+size[1]*原点[1]]

qp.setFont(QFont("Decorative",15))

pt1=[pt[0],orig[1]]
pt2=[pt[0]+size[0],orig[1]]
qp.drawText(pt2[0],pt2[1],100,30,Qt.AlignLeft|Qt.AlignVCenter,x坐标)
drawArrow(qp,pt1,pt2)

pt1=[orig[0],pt[1]]
pt2=[orig[0],pt[1]+size[1]]
qp.drawText(pt2[0],pt2[1]-30,100,30,Qt.AlignLeft|Qt.AlignVCenter,y坐标)
drawArrow(qp,pt1,pt2)


qp.drawText(orig[0],orig[1],30,30,Qt.AlignHCenter|Qt.AlignVCenter,'O')
qp.setFont(QFont())


## end
#30, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#31, 1487:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


def drawArrow(qp,pt1,pt2):
    angle=30
    l=30
    D=0
    d=10
    
    lineWidth=2
    
    edgeColor=[0,0,0]
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush())
    
    r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
    if r!=0:
        theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
    dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
    dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]
    
    pt10=[0,0]
    pt20=[0,0]
    pt10[0]=pt1[0]
    pt10[1]=pt1[1]
    pt20[0]=pt2[0]
    pt20[1]=pt2[1]
    
    
    path2=QPainterPath()
    path2.moveTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
    path2.lineTo(pt20[0],pt20[1])
    path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])
    
    qp.drawPath(path2)
    
    
    qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])
    
    qp.setBrush(QBrush())
    qp.setPen(QPen())


pt=起点
size=尺寸
orig=[pt[0]+size[0]*原点[0],pt[1]+size[1]*原点[1]]

qp.setFont(QFont("Decorative",15))

pt1=[pt[0],orig[1]]
pt2=[pt[0]+size[0],orig[1]]
qp.drawText(pt2[0],pt2[1],100,30,Qt.AlignLeft|Qt.AlignVCenter,x坐标)
drawArrow(qp,pt1,pt2)

pt1=[orig[0],pt[1]]
pt2=[orig[0],pt[1]+size[1]]
qp.drawText(pt2[0],pt2[1]-30,100,30,Qt.AlignLeft|Qt.AlignVCenter,y坐标)
drawArrow(qp,pt1,pt2)


qp.drawText(orig[0],orig[1],30,30,Qt.AlignHCenter|Qt.AlignVCenter,'O')
qp.setFont(QFont())


## end
#32, 263:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


if 可选=='NO':
    state=False



## end
#35, 14:
+[返回目录]
+[内容]

## end
#36, 1637:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


function drawArrow(pt1,pt2,ctx) {
    //arrows
    var angle=30/180*Math.PI;
    var l=20;
    var d=10;
    
    r=Math.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2);
    if (r!=0) {
        theta=Math.sign(pt1[1]-pt2[1])*Math.acos((pt2[0]-pt1[0])/r);
    }
    
    dp21=[l*Math.cos(theta-angle/2),-l*Math.sin(theta-angle/2)];
    dp22=[l*Math.cos(theta+angle/2),-l*Math.sin(theta+angle/2)];
    
    pt10=[0,0];
    pt20=[0,0];
    pt10[0]=pt1[0];
    pt10[1]=pt1[1];
    pt20[0]=pt2[0];
    pt20[1]=pt2[1];
    
    
    ctx.strokeStyle='rgb(0,0,0)';
    ctx.lineWidth=2;
    ctx.fillStyle='rgb(0,0,0,0)';
    
    
    ctx.beginPath();
    
    
    //ctx.moveTo(pt10[0]+dp21[0],pt10[1]+dp21[1]);
    //ctx.lineTo(pt10[0],pt10[1]);
    //ctx.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1]);
    
    ctx.moveTo(pt20[0]-dp21[0],pt20[1]-dp21[1]);
    ctx.lineTo(pt20[0],pt20[1]);
    ctx.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1]);
    
    
    ctx.moveTo(pt10[0],pt10[1]);
    ctx.lineTo(pt20[0],pt20[1]);
    
    ctx.stroke()
    ctx.fill()
}


var pt=[%起点]
var size=[%尺寸]
var ratio=[%原点]
var orig=[pt[0]+size[0]*ratio[0],pt[1]+size[1]*ratio[1]]

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='left'
ctx.textBaseline='top'
ctx.font=30+'px serif'

pt1=[pt[0],orig[1]]
pt2=[pt[0]+size[0],orig[1]]
drawArrow(pt1,pt2,ctx)
ctx.fillStyle='rgba(0,0,0,1)';
ctx.fillText('%x坐标',pt2[0],pt2[1])

pt1=[orig[0],pt[1]]
pt2=[orig[0],pt[1]+size[1]]
drawArrow(pt1,pt2,ctx)
ctx.fillStyle='rgba(0,0,0,1)';
ctx.fillText('%y坐标',pt2[0],pt2[1])

ctx.fillText('O',orig[0],orig[1])


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#39, 14:
+[返回目录]
+[内容]

## end
#40, 137:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100
坐标范围::-1,1-1,1
x坐标::x
y坐标::y
可选::NO

## end
#43, 38:
-755.4231026946367, 170.14572456813949
## end
#44, 20:
534.125, -311.640625
## end
#45, 2:
矩形
## end
#47, 7:
0.1,0.1
## end
#50, 1:
x
## end
#52, 1:
y
## end
#56, 129:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#66, 1161:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

angle=30
l=30
D=0
d=10


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush())

r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
if r!=0:
    theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]

pt10=[0,0]
pt20=[0,0]
pt10[0]=pt1[0]
pt10[1]=pt1[1]
pt20[0]=pt2[0]
pt20[1]=pt2[1]

#path1=QPainterPath()
#path1.moveTo(pt10[0],pt10[1])
#path1.moveTo(pt10[0]+dp21[0],pt10[1]+dp21[1])
#path1.lineTo(pt10[0],pt10[1])
#path1.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1])

path2=QPainterPath()
#path2.moveTo(pt20[0],pt20[1])
path2.moveTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
path2.lineTo(pt20[0],pt20[1])
path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])

#qp.drawPath(path1)
qp.drawPath(path2)


qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])

qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#72, 1161:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

angle=30
l=30
D=0
d=10


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush())

r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
if r!=0:
    theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]

pt10=[0,0]
pt20=[0,0]
pt10[0]=pt1[0]
pt10[1]=pt1[1]
pt20[0]=pt2[0]
pt20[1]=pt2[1]

#path1=QPainterPath()
#path1.moveTo(pt10[0],pt10[1])
#path1.moveTo(pt10[0]+dp21[0],pt10[1]+dp21[1])
#path1.lineTo(pt10[0],pt10[1])
#path1.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1])

path2=QPainterPath()
#path2.moveTo(pt20[0],pt20[1])
path2.moveTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
path2.lineTo(pt20[0],pt20[1])
path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])

#qp.drawPath(path1)
qp.drawPath(path2)


qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])

qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#73, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#74, 2:
直线
## end
#75, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#79, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#82, 14:
+[返回目录]
+[内容]

## end
#83, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#85, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#86, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#88, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#94, 38:
-380.7181509706786, 105.48021205723182
## end
#95, 38:
-144.95601336847886, 16.64392319481219
## end
#96, 5:
0,0,0
## end
#97, 8:
DashLine
## end
#98, 1:
1
## end
#100, 129:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#110, 1161:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

angle=30
l=30
D=0
d=10


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush())

r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
if r!=0:
    theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]

pt10=[0,0]
pt20=[0,0]
pt10[0]=pt1[0]
pt10[1]=pt1[1]
pt20[0]=pt2[0]
pt20[1]=pt2[1]

#path1=QPainterPath()
#path1.moveTo(pt10[0],pt10[1])
#path1.moveTo(pt10[0]+dp21[0],pt10[1]+dp21[1])
#path1.lineTo(pt10[0],pt10[1])
#path1.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1])

path2=QPainterPath()
#path2.moveTo(pt20[0],pt20[1])
path2.moveTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
path2.lineTo(pt20[0],pt20[1])
path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])

#qp.drawPath(path1)
qp.drawPath(path2)


qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])

qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#116, 1161:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

angle=30
l=30
D=0
d=10


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush())

r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
if r!=0:
    theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]

pt10=[0,0]
pt20=[0,0]
pt10[0]=pt1[0]
pt10[1]=pt1[1]
pt20[0]=pt2[0]
pt20[1]=pt2[1]

#path1=QPainterPath()
#path1.moveTo(pt10[0],pt10[1])
#path1.moveTo(pt10[0]+dp21[0],pt10[1]+dp21[1])
#path1.lineTo(pt10[0],pt10[1])
#path1.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1])

path2=QPainterPath()
#path2.moveTo(pt20[0],pt20[1])
path2.moveTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
path2.lineTo(pt20[0],pt20[1])
path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])

#qp.drawPath(path1)
qp.drawPath(path2)


qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])

qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#117, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#118, 2:
直线
## end
#119, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#123, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#126, 14:
+[返回目录]
+[内容]

## end
#127, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#129, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#130, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#132, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#138, 38:
-293.74573559902734, 73.08672908507212
## end
#139, 40:
-349.49362322251244, -24.973959670919836
## end
#140, 5:
0,0,0
## end
#141, 8:
DashLine
## end
#142, 1:
1
## end
#144, 92:
+[返回目录](,交点)
+[设置结构](,交点)

数值::0,0
类型::交点

标记::%数值

画图:...
HTML:...
P代码:...
+[P函数](,P代码)




## end
#146, 38:
-235.9917834513436, 111.72494131125373
## end
#148, 2:
交点
## end
#150, 34:
+[返回目录](,数学公式)

两直线交点:...
夹角:...


## end
#152, 718:
<!--
+[H函数](,两直线交点)
-->

考虑两端点式直线方程. 直线\(l\)的端点为\(\vec{p}_1\)和\(\vec{p}_2\), 那么, 直线方程为,
$$
\frac{x-x_1}{y-y_1}=\frac{x_2-x_1}{y_2-y_1}\equiv \frac{\Delta x}{\Delta y}
$$
$$
\Rightarrow
x \Delta y-y \Delta x=x_1 \Delta y- y_1 \Delta x \equiv D
$$$$
D=x_1 (y_2-y_1) - y_1 (x_2-x_1)=x_1 y_2-y_1 x_2
$$
所以, 两条直线, \(l\)和\(l'\) 的交点为, 
$$
\begin{cases}
x \Delta y-y \Delta x= D
\\
x \Delta y'-y \Delta x'= D'
\end{cases}
$$
其中, \(x\)是, 
$$
x(\Delta y/\Delta x - \Delta y'/\Delta x')=(D/\Delta x - D'/\Delta x')
\\\Rightarrow
x=\frac{D \Delta x' - D' \Delta x}{\Delta y \Delta x' - \Delta y' \Delta x}
$$
以及, \(y\)是,
$$
y=\frac{D \Delta y' - D' \Delta y}{\Delta y \Delta x' - \Delta y' \Delta x}
$$




<!--
+[H函数](,两直线交点)
-->
## end
#154, 16:
文档\S应用\网页画板.ftxt
## end
#156, 548:
"""
+[返回目录](,画图)

输入:...
+[设置结构](,输入)

"""

r=5
pt0=数值


qp.setPen(QPen(QColor(0,0,0),1,Qt.DashLine))
qp.setBrush(QBrush(QColor(255,255,255)))

qp.setPen(QPen(QColor(0,0,0)))
qp.setBrush(QBrush(QColor(255,255,255)))
qp.drawEllipse(pt0[0]-r,pt0[1]-r,2*r,2*r)
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",10))

if 标记=='%数值':
    qp.drawText(pt0[0],pt0[1],200,30,Qt.AlignLeft|Qt.AlignVCenter,"(%.2f,%.2f)"%(pt0[0],pt0[1]))
else:
    qp.drawText(pt0[0],pt0[1],100,30,Qt.AlignLeft|Qt.AlignVCenter,str(标记))

qp.setFont(QFont())
## end
#157, 287:
"""
+[返回目录](,P代码)
输出:
+[设置结构](,输出)

+[P函数](,P代码)

"""

Dx1=pt11[0]-pt12[0]
Dy1=pt11[1]-pt12[1]

Dx2=pt21[0]-pt22[0]
Dy2=pt21[1]-pt22[1]

D1=pt11[0]*Dy1-pt11[1]*Dx1
D2=pt21[0]*Dy2-pt21[1]*Dx2

L=Dy1*Dx2-Dy2*Dx1
if L==0:
    pt0="None"
else:
    pt0=[(D1*Dx2-D2*Dx1)/L, (D1*Dy2-D2*Dy1)/L]

## end
#159, 48:
+[返回目录]
+[内容]
pt11::
pt12::
pt21::
pt22::
pt0::

## end
#161, 65:
+[返回目录]
+[内容]
标记::%数值
数值::-278.9469569315004, -66.11900461360207

## end
#162, 38:
-235.9917834513436, 111.72494131125373
## end
#164, 12:
-323.0, 68.0
## end
#166, 13:
-520.0, -31.0
## end
#168, 12:
-130.0, 99.0
## end
#170, 39:
-477.98325000000017, 140.77745000000004
## end
#179, 111:
+[返回目录](,角度)

数值::
中心::
半径::20
起始角度::
类型::角度

标记::%数值

画图:...
HTML:...
P代码:...
+[P函数](,P代码)



+[创建输入](标记,画图)


## end
#181, 18:
-98.97175426444828
## end
#183, 2:
角度
## end
#185, 940:
"""
+[返回目录](,P代码)

+[P函数](,P代码)

输出:...
+[设置结构](,输出)

"""

Dx1=pt11[0]-pt12[0]
Dy1=pt11[1]-pt12[1]

Dx2=pt21[0]-pt22[0]
Dy2=pt21[1]-pt22[1]

D1=pt11[0]*Dy1-pt11[1]*Dx1
D2=pt21[0]*Dy2-pt21[1]*Dx2

L=Dy1*Dx2-Dy2*Dx1
if L==0:
    pt0="None"
else:
    pt0=[(D1*Dx2-D2*Dx1)/L, (D1*Dy2-D2*Dy1)/L]
    if np.sqrt((pt0[0]-pt11[0])**2+(pt0[1]-pt11[1])**2) < np.sqrt((pt0[0]-pt12[0])**2+(pt0[1]-pt12[1])**2):
        Dx1=-Dx1
        Dy1=-Dy1
    
    if np.sqrt((pt0[0]-pt21[0])**2+(pt0[1]-pt21[1])**2) < np.sqrt((pt0[0]-pt22[0])**2+(pt0[1]-pt22[1])**2):
        Dx2=-Dx2
        Dy2=-Dy2

    sign=np.sign(Dx1*Dy2-Dx2*Dy1)
    Dtheta=np.arccos((Dx1*Dx2+Dy1*Dy2)/np.sqrt((Dx1**2+Dy1**2)*(Dx2**2+Dy2**2)))
    angle=np.rad2deg(Dtheta)*sign

    theta0=np.arccos(Dx1/np.sqrt(Dx1**2+Dy1**2))
    angle0=np.rad2deg(theta0)*np.sign(Dy1)

    print(Dy1/np.sqrt(Dx1**2+Dy1**2),theta0,angle0)

    中心=pt0
    起始角度=angle0


"""
+[P函数](,P代码)
+[设置结构](,输出)

"""
## end
#186, 62:
+[返回目录]
+[内容]
pt11::
pt12::
pt21::
pt22::
angle::
中心::
起始角度::

## end
#188, 14:
+[返回目录]
+[内容]

## end
#199, 18:
-98.97175426444828
## end
#201, 40:
-349.49362322251244, -24.973959670919836
## end
#203, 38:
-293.74573559902734, 73.08672908507212
## end
#205, 38:
-144.95601336847886, 16.64392319481219
## end
#207, 38:
-380.7181509706786, 105.48021205723182
## end
#215, 1060:
<!--
+[H函数](,夹角)
-->

同样是两端点式直线方程, 直线\(l\)经过端点\((x_1,y_1)\)和端点\((x_2,y_2)\). 直线\(l'\)经过端点\((x'_1,y'_1)\)和端点\((x'_2,y'_2)\).
<br>
这两条直线的夹角是, 
$$
cos(\theta)=\frac{\vec{l}'\cdot \vec{l}}{\|\vec{l}'\| \|\vec{l}\|}
=\frac{\Delta x \Delta x' + \Delta y \Delta y'}
{\sqrt{(\Delta x^2+\Delta y^2)(\Delta x'^2+\Delta y'^2)}}
$$
而夹角的方向是,
$$
sin(\theta)=\frac{\vec{l}'\times \vec{l}}{\|\vec{l}'\| \|\vec{l}\|}
=\frac{\Delta x' \Delta y - \Delta y' \Delta x}
{\sqrt{(\Delta x'^2+\Delta y'^2)(\Delta x^2+\Delta y^2)}}
$$
我们需要根据交点相对直线的位置来选择绘制夹角的区间. 假设\(\vec{r}_1\)是距离交点比较近的点, 而\(\vec{r}_2\)是距离交点比较远的点. 那么, 初始角度应该是, 
$$
cos(\theta_0)=\frac{\Delta x}{\sqrt{\Delta x^2+\Delta y^2}}
$$
$$
sin(\theta_0)=\frac{\Delta y}{\sqrt{\Delta x^2+\Delta y^2}}
$$
另外, 交点坐标的计算公式是, 
$$
\begin{cases}
x_0=\frac{D \Delta x' - D' \Delta x}{\Delta y \Delta x' - \Delta y' \Delta x}
\\
y_0=\frac{D \Delta y' - D' \Delta y}{\Delta y \Delta x' - \Delta y' \Delta x}
\end{cases}
\\
D
\equiv x_1 \Delta y- y_1 \Delta x
, 
D'
\equiv x'_1 \Delta y'- y'_1 \Delta x'
$$

<!--
+[H函数](,夹角)

验证(M函数):...
-->
## end
#217, 562:
"""
+[返回目录](,画图)

输入:...
+[设置结构](,输入)

"""

pt0=中心
r=半径[0]
angle0=-起始角度[0]
Dangle=-数值[0]

dx=r*np.cos(np.deg2rad(angle0+Dangle)/2)
dy=r*np.sin(np.deg2rad(angle0+Dangle)/2)


qp.setPen(QPen(QColor(0,0,0)))
qp.setBrush(QBrush(QColor(255,255,255)))

qp.drawArc(pt0[0]-r,pt0[1]-r,2*r,2*r,angle0*16,Dangle*16)

qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",10))


if 标记=='%数值':
    qp.drawText(pt0[0]+dx,pt0[1]+dy,"%.2f"%(Dangle))
else:
    qp.drawText(pt0[0]+dx,pt0[1]+dy,str(标记))

qp.drawPoint(pt0[0]+dx,pt0[1]+dy)

qp.setFont(QFont())




## end
#219, 121:
+[返回目录]
+[内容]
标记::%数值
中心::-338.8789230341691, -3.8202594274802757
半径::10
起始角度::136.10929165904932
数值::62.220685781962224

## end
#220, 1:
1
## end
#222, 8:
958, 476
## end
#224, 11:
-300.0, 0.0
## end
#228, 3:
%数值
## end
#231, 3:
%数值
## end
#234, 128:
+[返回目录](,垂线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...

P代码:...
+[P函数](,P代码)


## end
#244, 1097:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

d=10

lineWidth=线粗细[0]
lineType=线型

Dx=pt2[0]-pt1[0]
Dy=pt2[1]-pt1[1]

Dx1=pt11[0]-pt1[0]
Dy1=pt11[1]-pt1[1]

sign=np.sign(Dy)
theta1=-sign*np.arccos(Dx/np.sqrt(Dx**2+Dy**2))
angle1=np.rad2deg(theta1)
theta2=np.deg2rad(angle1+90)

dp1=[d*np.cos(theta1),-d*np.sin(theta1)]
dp2=[d*np.cos(theta2),-d*np.sin(theta2)]

sign2=np.sign(Dx1*dp2[0]+Dy1*dp2[1])
dp2=[sign2*dp2[0],sign2*dp2[1]]


pt01=[pt1[0]+dp1[0],pt1[1]+dp1[1]]
pt02=[pt01[0]+dp2[0],pt01[1]+dp2[1]]
pt03=[pt02[0]-dp1[0],pt02[1]-dp1[1]]

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
qp.drawLine(pt01[0],pt01[1],pt02[0],pt02[1])
qp.drawLine(pt02[0],pt02[1],pt03[0],pt03[1])


qp.setPen(QPen())




## end
#250, 1097:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

d=10

lineWidth=线粗细[0]
lineType=线型

Dx=pt2[0]-pt1[0]
Dy=pt2[1]-pt1[1]

Dx1=pt11[0]-pt1[0]
Dy1=pt11[1]-pt1[1]

sign=np.sign(Dy)
theta1=-sign*np.arccos(Dx/np.sqrt(Dx**2+Dy**2))
angle1=np.rad2deg(theta1)
theta2=np.deg2rad(angle1+90)

dp1=[d*np.cos(theta1),-d*np.sin(theta1)]
dp2=[d*np.cos(theta2),-d*np.sin(theta2)]

sign2=np.sign(Dx1*dp2[0]+Dy1*dp2[1])
dp2=[sign2*dp2[0],sign2*dp2[1]]


pt01=[pt1[0]+dp1[0],pt1[1]+dp1[1]]
pt02=[pt01[0]+dp2[0],pt01[1]+dp2[1]]
pt03=[pt02[0]-dp1[0],pt02[1]-dp1[1]]

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
qp.drawLine(pt01[0],pt01[1],pt02[0],pt02[1])
qp.drawLine(pt02[0],pt02[1],pt03[0],pt03[1])


qp.setPen(QPen())




## end
#251, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#252, 2:
直线
## end
#253, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#257, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#260, 14:
+[返回目录]
+[内容]

## end
#261, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#263, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#264, 274:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/

## end
#266, 65:
线颜色::0,0,0
线型::DashLine
线粗细::2
pt11::

pt11->是(_,pt11)->+[显示](,_)
## end
#272, 37:
-216.1938903355853, 43.48669226943532
## end
#273, 37:
-266.827256913543, -90.88892034651421
## end
#274, 5:
0,0,0
## end
#275, 8:
DashLine
## end
#276, 1:
1
## end
#278, 363:
"""
+[返回目录](,P代码)
+[P函数](,P代码)

输入:...
输出:...
+[设置结构](,输入)

"""


Dx1=pt12[0]-pt11[0]
Dy1=pt12[1]-pt11[1]

Dxr=pt12[0]-pt02[0]
Dyr=pt12[1]-pt02[1]

sign=np.sign(Dy1)
theta1=np.arccos(Dx1/np.sqrt(Dx1**2+Dy1**2))
angle1=-np.rad2deg(theta1)*sign

theta=np.deg2rad(angle1+90)

dx=np.cos(theta)
dy=-np.sin(theta)
DL=Dxr*dx+Dyr*dy

pt01=[pt02[0]+DL*dx,pt02[1]+DL*dy]



## end
#280, 21:
+[返回目录]
+[内容]
pt01::

## end
#282, 35:
+[返回目录]
+[内容]
pt02::
pt11::
pt12::

## end
#283, 37:
-216.1938903355853, 43.48669226943532
## end
#285, 38:
-144.95601336847886, 16.64392319481219
## end
#287, 38:
-380.7181509706786, 105.48021205723182
## end
#289, 37:
-266.827256913543, -90.88892034651421
## end
#295, 38:
-380.7181509706786, 105.48021205723182
## end
#298, 3:
390
## end
#301, 189:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形

中心位置::0,100
分辨率::0.1
函数::y=x**2/10
可选::YES

面颜色::None
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

+[创建输入](可选,画图)



## end
#312, 921:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸

lineWidth=线粗细[0]
lineType=线型

dx=分辨率[0]
orig=中心位置

Nx=np.abs(size[0])
x=np.linspace(-Nx*dx/2,Nx*dx/2,Nx)+orig[0]
y=0*x
exec(函数)

x_p=x/dx+pt[0]+size[0]/2
y_p=-y/dx+pt[1]+size[1]/2+orig[1]


path=QPainterPath()
move=True
for i in range(len(x_p)):
    if (y_p[i]-pt[1])*(y_p[i]-pt[1]-size[1])>0:
        if 面颜色=='None':
            move=True
        continue
    if move:
        path.moveTo(x_p[i],y_p[i])
        move=False
    else:
        path.lineTo(x_p[i],y_p[i])

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawPath(path)

qp.setBrush(QBrush())
qp.setPen(QPen())







## end
#318, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#319, 921:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸

lineWidth=线粗细[0]
lineType=线型

dx=分辨率[0]
orig=中心位置

Nx=np.abs(size[0])
x=np.linspace(-Nx*dx/2,Nx*dx/2,Nx)+orig[0]
y=0*x
exec(函数)

x_p=x/dx+pt[0]+size[0]/2
y_p=-y/dx+pt[1]+size[1]/2+orig[1]


path=QPainterPath()
move=True
for i in range(len(x_p)):
    if (y_p[i]-pt[1])*(y_p[i]-pt[1]-size[1])>0:
        if 面颜色=='None':
            move=True
        continue
    if move:
        path.moveTo(x_p[i],y_p[i])
        move=False
    else:
        path.lineTo(x_p[i],y_p[i])

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawPath(path)

qp.setBrush(QBrush())
qp.setPen(QPen())







## end
#320, 261:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False

if 可选=='NO':
    state=False


## end
#323, 14:
+[返回目录]
+[内容]

## end
#324, 655:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#327, 14:
+[返回目录]
+[内容]

## end
#328, 143:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100
中心位置::0,-10
分辨率::0.1
函数::y=x**2/10
可选::NO

## end
#335, 38:
-296.8622180664064, -116.4401539062501
## end
#336, 37:
-387.2225638671876, 291.8855078125002
## end
#337, 2:
矩形
## end
#338, 8:
DashLine
## end
#339, 1:
2
## end
#340, 4:
None
## end
#341, 5:
0,0,0
## end
#343, 5:
0,100
## end
#345, 3:
0.1
## end
#347, 9:
y=x**2/10
## end
#352, 3:
YES
## end
#355, 3:
YES
## end
#358, 104:
+[返回目录](,几何动词)

创建函数曲线:...
创建坐标系:...

创建交点:...
创建角度:...
创建垂线:...



描述:...
编号:...
删除编号:...


+[del](,编号)
## end
#360, 340:
"""
+[返回目录](,描述)

词典:...

"""

+描述(_场景,_文本)->+[del](,+描述)...
->的(描述,词典):
    ->[]{[]->的(词典,_段落)->_段落:
	->_标签(_场景,)->[eq](_标签,_段落)->+[做](_场景,_文本)->+[code](+[做],_段落),
	->[eq](_场景,_段落)->+[做](_场景,_文本)->+[code](+[做],_段落),
	->_类型(+描述,)->[eq](_类型,_段落)->+[做](_场景,_文本)->+[code](+[做],_段落)
    },

    ->的(词典,动词释义)->+[做](_场景,_文本)->+[code](+[做],动词释义)


## end
#362, 47:
+[返回目录](,词典)

动词释义:...
主语:...
宾语:...

谓语:...



## end
#364, 1359:
"""
+[返回目录](,动词释义)

编号:...
删除编号:...

"""

+动词释义(_动词,_词条)->+[del](,+动词释义)...
->的(动词释义,编号)->的(动词释义,删除编号)...

->+[临时文本]"\"\"\"
+[返回目录](,%[标题])

\"\"\"

+%[标题](,_%[谓语名称])->+[del](,+%[标题])...
->_%[谓语名称](%[主语名称],%[宾语名称])...

%[主语内容]

%[宾语内容]

->%[谓语内容]

"...

->+[标题]#0(_词条,)...

->_动词(_主语,_宾语)...
->+[主语名称]->+[主语内容]->[]{
	[]:->_主语(,)...
	->+[临时文本]#1(,)...
	->+[标题]#1(_主语,)->+[修改内容]"_"(+[标题]#1,+[主语名称])...
	->+[描述](_主语,+[临时文本]#1)->+主语(+[描述],)->+[del](,+主语)...
	->+[修改内容]"->%s..."(+[临时文本]#1,+[主语内容])...,

	->[]
}...
->+[宾语名称]->+[宾语内容]{
	[]:->_宾语(,)...
	->+[临时文本]#2(,)...
	->+[标题]#2(_宾语,)->+[修改内容]"_"(+[标题]#2,+[宾语名称])...
	->+[描述](_宾语,+[临时文本]#2)->+宾语(+[描述],)->+[del](,+宾语)...
	->+[修改内容]"->%s..."(+[临时文本]#2,+[宾语内容]),

	->[]
}...
->+[标题]#1(_动词,)->+[修改内容](+[标题]#1,+[谓语名称])...
->+内部结构(,_动词)->[]{
    []=>的(_动词,_内部)->_内部=>+的(+内部结构,的)->+[选择结构](+内部结构,_内部)
}...

->+号码集(+内部结构,)->+[做](_动词,+号码集)->+[code](+[做],编号)...
->+[描述](_动词,+[谓语内容])->+谓语(+[描述],)...
->+[del](,+谓语)->+[del](,+内部结构)...
->+[做](,+号码集)->+[code](+[做],删除编号)...

->+[模板文本](+[临时文本],_词条)...
->+[.](+[模板文本],+[标题]#0)...
->+[.](+[模板文本],+[主语名称])->+[.](+[模板文本],+[主语名称])...
->+[.](+[模板文本],+[主语内容])->+[.](+[模板文本],+[主语内容])...

->+[.](+[模板文本],+[宾语名称])->+[.](+[模板文本],+[宾语名称])...
->+[.](+[模板文本],+[宾语内容])->+[.](+[模板文本],+[宾语内容])...

->+[.](+[模板文本],+[谓语名称])->+[.](+[模板文本],+[谓语名称])...
->+[.](+[模板文本],+[谓语内容])->+[.](+[模板文本],+[谓语内容])

## end
#366, 428:
"""
+[返回目录](,主语)

"""

+主语(_结构,_文本)->+[del](,+主语)...
->+[临时文本]#0"_%[标题]%[定语]"...
->+[标题]#0(_结构,)...
->+[定语]->[]{
	[]=>的(_结构,_性质)=>+[标题]#1(_性质,)->+[修改内容](+[标题]#1,+[性质])...
	->+[临时文本]"->的(_%[标题],%[性质]#主语)"...
	->+[模板文本](+[临时文本],+[临时文本])...
	->+[.](+[模板文本],+[标题]#0)->+[.](+[模板文本],+[性质])...
	->+[增加内容](+[临时文本],+[定语])
}...

->+[模板文本](+[临时文本]#0,+[临时文本]#0)...
->+[.](+[模板文本],+[标题]#0)->+[.](+[模板文本],+[定语])...
->+[修改内容](+[临时文本]#0,_文本)



## end
#368, 428:
"""
+[返回目录](,宾语)

"""

+宾语(_结构,_文本)->+[del](,+宾语)...
->+[临时文本]#0"_%[标题]%[定语]"...
->+[标题]#0(_结构,)...
->+[定语]->[]{
	[]=>的(_结构,_性质)=>+[标题]#1(_性质,)->+[修改内容](+[标题]#1,+[性质])...
	->+[临时文本]"->的(_%[标题],%[性质]#宾语)"...
	->+[模板文本](+[临时文本],+[临时文本])...
	->+[.](+[模板文本],+[标题]#0)->+[.](+[模板文本],+[性质])...
	->+[增加内容](+[临时文本],+[定语])
}...

->+[模板文本](+[临时文本]#0,+[临时文本]#0)...
->+[.](+[模板文本],+[标题]#0)->+[.](+[模板文本],+[定语])...
->+[修改内容](+[临时文本]#0,_文本)



## end
#370, 1623:
"""
+[返回目录](,谓语)

内容:...

"""

+谓语(_谓语,_文本)->+[del](,+谓语)...
->内部结构(,_谓语)...
->的(谓语,内容)...

->+[临时文本]"+[修改内容]%[内容1](,_%[标题])...

%[内部结构]%[执行P代码]
"...
->+[标题]#0(_谓语,)...
->+[做](_谓语,+[内容1]#0)->+[code](+[做],内容)...

->[]{
    []=>的(内部结构,输入)->输入->的(输入,_变量)->是(,_变量)=>+的(内部结构,是)
}...

->+[内部结构]{
	[]=>的(内部结构,_节点)->_节点(_节点1,_节点2)...

	=>+[临时文本]#1"->+%[标题]%[内容](%[节点1],%[节点2])"...

	->+[标题](_节点,)...
	->[]{[]:->号码(,_节点)->+[增加内容]"#"(号码,+[标题]),->[]}...
	->+[做](_节点,+[内容])->+[code](+[做],内容)...
	->+[节点1]{
		[]:->_节点1->[]{
			[]:->[is](_谓语,_节点1)->+[标题]#0(_节点1,)...
			->+[修改内容]"_"(+[标题]#0,+[节点1]),

			->的(内部结构,_节点1)->+[标题]#1(_节点1,)...
			->[]{[]:->号码(,_节点1)->+[增加内容]"#"(号码,+[标题]#1),->[]}...
			->+[修改内容]"+"(+[标题]#1,+[节点1]),

			->+[标题]#2(_节点1,)...
			->[]{[]:->号码(,_节点1)->+[增加内容]"#"(号码,+[标题]#2),->[]}...
			->+[修改内容](+[标题]#2,+[节点1])
		},
		->[]
	}...
	->+[节点2]{
		[]:->_节点2->[]{
			[]:->[is](_谓语,_节点2)->+[标题]#0(_节点2,)...
			->+[修改内容]"_"(+[标题]#0,+[节点2]),

			->的(内部结构,_节点2)->+[标题]#1(_节点2,)...
			->[]{[]:->号码(,_节点2)->+[增加内容]"#"(号码,+[标题]#1),->[]}...
			->+[修改内容]"+"(+[标题]#1,+[节点2]),

			->+[标题]#2(_节点2,)...
			->[]{[]:->号码(,_节点2)->+[增加内容]"#"(号码,+[标题]#2),->[]}...
			->+[修改内容](+[标题]#2,+[节点2])
		},
		->[]
	}...

	->+[模板文本](+[临时文本]#1,+[临时文本]#1)...
	->+[.](+[模板文本],+[标题])->+[.](+[模板文本],+[内容])...
	->+[.](+[模板文本],+[节点1])->+[.](+[模板文本],+[节点2])...
	->+[增加内容](+[临时文本]#1,+[内部结构])
}...

->+[执行P代码]{
	[]:->的(内部结构,P代码)->P代码->号码(,P代码)->+[修改内容]"->+[P函数](,+P代码#%s)"(号码,+[执行P代码]),
	->[]
}...

->+[模板文本](+[临时文本],+[临时文本])...
->+[.](+[模板文本],+[标题]#0)->+[.](+[模板文本],+[内容1]#0)...
->+[.](+[模板文本],+[内部结构])->+[.](+[模板文本],+[执行P代码])...

->+[修改内容](+[临时文本],_文本)



## end
#371, 3:
392
## end
#373, 3:
398
## end
#376, 6674:
"""
+[返回目录](,创建函数曲线)

"""


+创建函数曲线#0(,_函数曲线#56)->+[del]#1(,+创建函数曲线#0)...


...............................................
->+[临时文本]#2"+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形

中心位置::0,100
分辨率::0.1
函数::y=x**2/10
可选::YES

面颜色::None
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

+[创建输入](可选,画图)


"(,)...
...............................................


->+[修改内容]#3(+[临时文本]#2,_函数曲线#56)->+可选#4"YES"(,)...


...............................................
->+函数#5"y=x**2/10"(,)...
...............................................


->+分辨率#6"0.1"(,)...


...............................................
->+中心位置#7"0,100"(,)...
...............................................





...............................................
->+线颜色#8"0,0,0"(,)...
...............................................


->+面颜色#9"None"(,)->+线粗细#10"2"(,)...


...............................................
->+线型#11"DashLine"(,)...
...............................................


->+类型#12"矩形"(,)...


...............................................
->+尺寸#13"-387.2225638671876, 291.8855078125002"(,)...
...............................................





...............................................
->+起点#14"-296.8622180664064, -116.4401539062501"(,)...
...............................................


->+的#15(+输入#25,+可选#4)->+的#16(+输入#25,+函数#5)->+的#17(+输入#25,+分辨率#6)->+的#18(+输入#25,+中心位置#7)->+的#19(+输入#25,+起点#14)->+的#20(+输入#25,+尺寸#13)->+的#21(+输入#25,+线粗细#10)->+的#22(+输入#25,+线型#11)->+的#23(+输入#25,+线颜色#8)->+的#24(+输入#25,+面颜色#9)...


...............................................
->+输入#25"+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100
中心位置::0,-10
分辨率::0.1
函数::y=x**2/10
可选::NO
"(,)...
...............................................





...............................................
->+输出#26"+[返回目录]
+[内容]
"(,)...
...............................................


->+的#27(+HTML#29,+输入#25)->+的#28(+HTML#29,+输出#26)...


...............................................
->+HTML#29"/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/"(,)...
...............................................





...............................................
->+输出#30"+[返回目录]
+[内容]
"(,)...
...............................................


->+的#31(+选中区域#33,+输入#25)->+的#32(+选中区域#33,+输出#30)...


...............................................
->+选中区域#33"\"\"\"
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

\"\"\"

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False

if 可选=='NO':
    state=False

"(,)...
...............................................





...............................................
->+图形#34"\"\"\"
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

\"\"\"


pt=起点
size=尺寸

lineWidth=线粗细[0]
lineType=线型

dx=分辨率[0]
orig=中心位置

Nx=np.abs(size[0])
x=np.linspace(-Nx*dx/2,Nx*dx/2,Nx)+orig[0]
y=0*x
exec(函数)

x_p=x/dx+pt[0]+size[0]/2
y_p=-y/dx+pt[1]+size[1]/2+orig[1]


path=QPainterPath()
move=True
for i in range(len(x_p)):
    if (y_p[i]-pt[1])*(y_p[i]-pt[1]-size[1])>0:
        if 面颜色=='None':
            move=True
        continue
    if move:
        path.moveTo(x_p[i],y_p[i])
        move=False
    else:
        path.lineTo(x_p[i],y_p[i])

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawPath(path)

qp.setBrush(QBrush())
qp.setPen(QPen())






"(,)...
...............................................





...............................................
->+选中框#35"\"\"\"
+[返回目录](,选中框)

\"\"\"


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
"(,)...
...............................................


->+输出#36(,)->+的#37(+画图#41,+图形#34)->+的#38(+画图#41,+选中框#35)->+的#39(+画图#41,+输出#36)->+的#40(+画图#41,+输入#25)...


...............................................
->+画图#41"\"\"\"
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

\"\"\"


pt=起点
size=尺寸

lineWidth=线粗细[0]
lineType=线型

dx=分辨率[0]
orig=中心位置

Nx=np.abs(size[0])
x=np.linspace(-Nx*dx/2,Nx*dx/2,Nx)+orig[0]
y=0*x
exec(函数)

x_p=x/dx+pt[0]+size[0]/2
y_p=-y/dx+pt[1]+size[1]/2+orig[1]


path=QPainterPath()
move=True
for i in range(len(x_p)):
    if (y_p[i]-pt[1])*(y_p[i]-pt[1]-size[1])>0:
        if 面颜色=='None':
            move=True
        continue
    if move:
        path.moveTo(x_p[i],y_p[i])
        move=False
    else:
        path.lineTo(x_p[i],y_p[i])

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawPath(path)

qp.setBrush(QBrush())
qp.setPen(QPen())






"(,)...
...............................................


->+的#42(_函数曲线#56,+可选#4)->+的#43(_函数曲线#56,+函数#5)->+的#44(_函数曲线#56,+分辨率#6)->+的#45(_函数曲线#56,+中心位置#7)->+的#46(_函数曲线#56,+线颜色#8)->+的#47(_函数曲线#56,+面颜色#9)->+的#48(_函数曲线#56,+线粗细#10)->+的#49(_函数曲线#56,+线型#11)->+的#50(_函数曲线#56,+类型#12)->+的#51(_函数曲线#56,+尺寸#13)->+的#52(_函数曲线#56,+起点#14)->+的#53(_函数曲线#56,+HTML#29)->+的#54(_函数曲线#56,+选中区域#33)->+的#55(_函数曲线#56,+画图#41)->_函数曲线#56(,)
## end
#378, 8113:
"""
+[返回目录](,创建坐标系)

"""


+创建坐标系#0(,_坐标系#44)->+[del]#1(,+创建坐标系#0)...


...............................................
->+[临时文本]#2"+[返回目录](,坐标系)
+[设置结构](,坐标系)

起点::-200,100
尺寸::100,100
类型::矩形

原点::0.1,0.1
x坐标::x
y坐标::y

可选::YES

画图:...
选中区域:...
HTML:...

+[创建输入](可选,画图)


"(,)...
...............................................


->+[修改内容]#3(+[临时文本]#2,_坐标系#44)->+可选#4"YES"(,)->+y坐标#5"y"(,)->+x坐标#6"x"(,)...


...............................................
->+原点#7"0.1,0.1"(,)...
...............................................


->+类型#8"矩形"(,)...


...............................................
->+尺寸#9"534.125, -311.640625"(,)...
...............................................





...............................................
->+起点#10"-755.4231026946367, 170.14572456813949"(,)...
...............................................


->+的#11(+输入#17,+可选#4)->+的#12(+输入#17,+y坐标#5)->+的#13(+输入#17,+x坐标#6)->+的#14(+输入#17,+原点#7)->+的#15(+输入#17,+起点#10)->+的#16(+输入#17,+尺寸#9)...


...............................................
->+输入#17"+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100
坐标范围::-1,1-1,1
x坐标::x
y坐标::y
可选::NO
"(,)...
...............................................





...............................................
->+输出#18"+[返回目录]
+[内容]
"(,)...
...............................................


->+的#19(+HTML#21,+输入#17)->+的#20(+HTML#21,+输出#18)...


...............................................
->+HTML#21"/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


function drawArrow(pt1,pt2,ctx) {
    //arrows
    var angle=30/180*Math.PI;
    var l=20;
    var d=10;
    
    r=Math.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2);
    if (r!=0) {
        theta=Math.sign(pt1[1]-pt2[1])*Math.acos((pt2[0]-pt1[0])/r);
    }
    
    dp21=[l*Math.cos(theta-angle/2),-l*Math.sin(theta-angle/2)];
    dp22=[l*Math.cos(theta+angle/2),-l*Math.sin(theta+angle/2)];
    
    pt10=[0,0];
    pt20=[0,0];
    pt10[0]=pt1[0];
    pt10[1]=pt1[1];
    pt20[0]=pt2[0];
    pt20[1]=pt2[1];
    
    
    ctx.strokeStyle='rgb(0,0,0)';
    ctx.lineWidth=2;
    ctx.fillStyle='rgb(0,0,0,0)';
    
    
    ctx.beginPath();
    
    
    //ctx.moveTo(pt10[0]+dp21[0],pt10[1]+dp21[1]);
    //ctx.lineTo(pt10[0],pt10[1]);
    //ctx.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1]);
    
    ctx.moveTo(pt20[0]-dp21[0],pt20[1]-dp21[1]);
    ctx.lineTo(pt20[0],pt20[1]);
    ctx.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1]);
    
    
    ctx.moveTo(pt10[0],pt10[1]);
    ctx.lineTo(pt20[0],pt20[1]);
    
    ctx.stroke()
    ctx.fill()
}


var pt=[%起点]
var size=[%尺寸]
var ratio=[%原点]
var orig=[pt[0]+size[0]*ratio[0],pt[1]+size[1]*ratio[1]]

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='left'
ctx.textBaseline='top'
ctx.font=30+'px serif'

pt1=[pt[0],orig[1]]
pt2=[pt[0]+size[0],orig[1]]
drawArrow(pt1,pt2,ctx)
ctx.fillStyle='rgba(0,0,0,1)';
ctx.fillText('%x坐标',pt2[0],pt2[1])

pt1=[orig[0],pt[1]]
pt2=[orig[0],pt[1]+size[1]]
drawArrow(pt1,pt2,ctx)
ctx.fillStyle='rgba(0,0,0,1)';
ctx.fillText('%y坐标',pt2[0],pt2[1])

ctx.fillText('O',orig[0],orig[1])


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/"(,)...
...............................................





...............................................
->+输出#22"+[返回目录]
+[内容]
"(,)...
...............................................


->+的#23(+选中区域#25,+输入#17)->+的#24(+选中区域#25,+输出#22)...


...............................................
->+选中区域#25"\"\"\"
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

\"\"\"

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


if 可选=='NO':
    state=False


"(,)...
...............................................





...............................................
->+图形#26"\"\"\"
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

\"\"\"


def drawArrow(qp,pt1,pt2):
    angle=30
    l=30
    D=0
    d=10
    
    lineWidth=2
    
    edgeColor=[0,0,0]
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush())
    
    r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
    if r!=0:
        theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
    dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
    dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]
    
    pt10=[0,0]
    pt20=[0,0]
    pt10[0]=pt1[0]
    pt10[1]=pt1[1]
    pt20[0]=pt2[0]
    pt20[1]=pt2[1]
    
    
    path2=QPainterPath()
    path2.moveTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
    path2.lineTo(pt20[0],pt20[1])
    path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])
    
    qp.drawPath(path2)
    
    
    qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])
    
    qp.setBrush(QBrush())
    qp.setPen(QPen())


pt=起点
size=尺寸
orig=[pt[0]+size[0]*原点[0],pt[1]+size[1]*原点[1]]

qp.setFont(QFont(\"Decorative\",15))

pt1=[pt[0],orig[1]]
pt2=[pt[0]+size[0],orig[1]]
qp.drawText(pt2[0],pt2[1],100,30,Qt.AlignLeft|Qt.AlignVCenter,x坐标)
drawArrow(qp,pt1,pt2)

pt1=[orig[0],pt[1]]
pt2=[orig[0],pt[1]+size[1]]
qp.drawText(pt2[0],pt2[1]-30,100,30,Qt.AlignLeft|Qt.AlignVCenter,y坐标)
drawArrow(qp,pt1,pt2)


qp.drawText(orig[0],orig[1],30,30,Qt.AlignHCenter|Qt.AlignVCenter,'O')
qp.setFont(QFont())

"(,)...
...............................................





...............................................
->+选中框#27"\"\"\"
+[返回目录](,选中框)

\"\"\"


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
"(,)...
...............................................


->+输出#28(,)->+的#29(+画图#33,+图形#26)->+的#30(+画图#33,+选中框#27)->+的#31(+画图#33,+输出#28)->+的#32(+画图#33,+输入#17)...


...............................................
->+画图#33"\"\"\"
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

\"\"\"


def drawArrow(qp,pt1,pt2):
    angle=30
    l=30
    D=0
    d=10
    
    lineWidth=2
    
    edgeColor=[0,0,0]
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush())
    
    r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
    if r!=0:
        theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
    dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
    dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]
    
    pt10=[0,0]
    pt20=[0,0]
    pt10[0]=pt1[0]
    pt10[1]=pt1[1]
    pt20[0]=pt2[0]
    pt20[1]=pt2[1]
    
    
    path2=QPainterPath()
    path2.moveTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
    path2.lineTo(pt20[0],pt20[1])
    path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])
    
    qp.drawPath(path2)
    
    
    qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])
    
    qp.setBrush(QBrush())
    qp.setPen(QPen())


pt=起点
size=尺寸
orig=[pt[0]+size[0]*原点[0],pt[1]+size[1]*原点[1]]

qp.setFont(QFont(\"Decorative\",15))

pt1=[pt[0],orig[1]]
pt2=[pt[0]+size[0],orig[1]]
qp.drawText(pt2[0],pt2[1],100,30,Qt.AlignLeft|Qt.AlignVCenter,x坐标)
drawArrow(qp,pt1,pt2)

pt1=[orig[0],pt[1]]
pt2=[orig[0],pt[1]+size[1]]
qp.drawText(pt2[0],pt2[1]-30,100,30,Qt.AlignLeft|Qt.AlignVCenter,y坐标)
drawArrow(qp,pt1,pt2)


qp.drawText(orig[0],orig[1],30,30,Qt.AlignHCenter|Qt.AlignVCenter,'O')
qp.setFont(QFont())

"(,)...
...............................................


->+的#34(_坐标系#44,+可选#4)->+的#35(_坐标系#44,+y坐标#5)->+的#36(_坐标系#44,+x坐标#6)->+的#37(_坐标系#44,+原点#7)->+的#38(_坐标系#44,+类型#8)->+的#39(_坐标系#44,+尺寸#9)->+的#40(_坐标系#44,+起点#10)->+的#41(_坐标系#44,+HTML#21)->+的#42(_坐标系#44,+选中区域#25)->+的#43(_坐标系#44,+画图#33)->_坐标系#44(,)
## end
#379, 3:
404
## end
#382, 249:
"""
+[返回目录](,内容)

测试:...

+[做](测试,+[显示])->+[code](+[做],内容)->+[显示]

"""

+内容(_节点,_输出)->+[del](,+内容)...
->+[python]"
text=str(text)
if text==\"\":
    ans=\"\"
else:
    ans='\"'+text.replace('\"','\\\"')+'\"'
"(Python,_输出)->+[.]"text"(+[python],_节点)

## end
#384, 69:
"""
+[P函数](,测试)

"""


text=''
a=text.replace('"','\\"')
print(a)




## end
#386, 385:
"""
+[返回目录](,编号)


"""

+编号(_动词,号码集)->+[del](,+编号)...
->号码集(内部结构,)->内部结构(,)->[]{
    +[python]"n=0"(Python,)=>的(内部结构,_节点)->_节点=>+号码(,_节点)->+的(号码集,+号码)->+[python]"n=n+1
ans=n"(Python,+号码)
}...

->_动词(_主语,_宾语)...
->[]{
    []:->_主语=>的(_主语,_性质)->_性质=>+号码"主语"(,_性质)->+的(号码集,+号码),
    ->+[显示]"没有主语"
}...
->[]{
    []:->_宾语=>的(_宾语,_性质)->_性质=>+号码"宾语"(,_性质)->+的(号码集,+号码),
    ->+[显示]"没有宾语"
}


## end
#388, 119:
"""
+[返回目录](,删除编号)

"""

+删除编号(,号码集)->+[del](,+删除编号)...
->+[del](,号码集)...
=>的(号码集,_号码)->_号码=>+[del](,_号码)->+[del](,的)


## end
#392, 2801:
"""
+[返回目录](,创建交点)

"""

+创建交点(,_交点)->+[del](,+创建交点)...
->_交点(_A线,_B线)...

->_A线->的(_A线,HTML#主语)->的(_A线,线粗细#主语)->的(_A线,线型#主语)->的(_A线,线颜色#主语)->的(_A线,选中区域#主语)->的(_A线,类型#主语)->的(_A线,画图#主语)->的(_A线,终点#主语)->的(_A线,起点#主语)...

->_B线->的(_B线,HTML#宾语)->的(_B线,线粗细#宾语)->的(_B线,线型#宾语)->的(_B线,线颜色#宾语)->的(_B线,选中区域#宾语)->的(_B线,类型#宾语)->的(_B线,画图#宾语)->的(_B线,终点#宾语)->的(_B线,起点#宾语)...

->+[修改内容]"+[返回目录](,交点)
+[设置结构](,交点)

数值::0,0
类型::交点

标记::%数值

画图:...
HTML:...
P代码:...
+[P函数](,P代码)



"(,_交点)...

->+类型#1"交点"(,)->+画图#2"\"\"\"
+[返回目录](,画图)

输入:...
+[设置结构](,输入)

\"\"\"

r=5
pt0=数值


qp.setPen(QPen(QColor(0,0,0),1,Qt.DashLine))
qp.setBrush(QBrush(QColor(255,255,255)))

qp.setPen(QPen(QColor(0,0,0)))
qp.setBrush(QBrush(QColor(255,255,255)))
qp.drawEllipse(pt0[0]-r,pt0[1]-r,2*r,2*r)
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont(\"Decorative\",10))

if 标记=='%数值':
    qp.drawText(pt0[0],pt0[1],200,30,Qt.AlignLeft|Qt.AlignVCenter,\"(%.2f,%.2f)\"%(pt0[0],pt0[1]))
else:
    qp.drawText(pt0[0],pt0[1],100,30,Qt.AlignLeft|Qt.AlignVCenter,str(标记))

qp.setFont(QFont())"(,)->+的#3(+画图#2,+输入#25)->+P代码#4"\"\"\"
+[返回目录](,P代码)
输出:
+[设置结构](,输出)

+[P函数](,P代码)

\"\"\"

Dx1=pt11[0]-pt12[0]
Dy1=pt11[1]-pt12[1]

Dx2=pt21[0]-pt22[0]
Dy2=pt21[1]-pt22[1]

D1=pt11[0]*Dy1-pt11[1]*Dx1
D2=pt21[0]*Dy2-pt21[1]*Dx2

L=Dy1*Dx2-Dy2*Dx1
if L==0:
    pt0=\"None\"
else:
    pt0=[(D1*Dx2-D2*Dx1)/L, (D1*Dy2-D2*Dy1)/L]
"(,)->+的#5(+P代码#4,+输出#7)->+的#6(+P代码#4,+输入#25)->+输出#7"+[返回目录]
+[内容]
pt11::
pt12::
pt21::
pt22::
pt0::
"(,)->+的#8(+输出#7,+pt11#13)->+的#9(+输出#7,+pt12#15)->+的#10(+输出#7,+pt21#17)->+的#11(+输出#7,+pt22#19)->+的#12(+输出#7,+pt0#21)->+pt11#13"[-477.98325000000017, 140.77745000000004]"(,)->+等于#14(+pt11#13,起点#主语)->+pt12#15"[-130.0, 99.0]"(,)->+等于#16(+pt12#15,终点#主语)->+pt21#17"[-520.0, -31.0]"(,)->+等于#18(+pt21#17,起点#宾语)->+pt22#19"[-323.0, 68.0]"(,)->+等于#20(+pt22#19,终点#宾语)->+pt0#21"[-235.9917834513436, 111.72494131125373]"(,)->+等于#22(+pt0#21,+数值#29)->+HTML#23"/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var pt0=[%数值]
var text='%标记'

ctx.beginPath();
ctx.arc(%数值,5,0,2*Math.PI);

ctx.fillStyle='rgba(255,255,255,0)';
ctx.fill();

ctx.strokeStyle='rgba(0,0,0)';
ctx.stroke();

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='left';
ctx.textBaseline='top';
ctx.font=8*2+'px serif';

if (text[0]==='%') {
    ctx.fillText(`(${pt0[0].toFixed(2)}), ${pt0[1].toFixed(2)})`,pt0[0],pt0[1]+5);
} else {
    ctx.fillText(text,pt0[0]+dx,pt0[1]+dy);
}



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/"(,)->+的#24(+HTML#23,+输入#25)->+输入#25"+[返回目录]
+[内容]
标记::%数值
数值::-278.9469569315004, -66.11900461360207
"(,)->+的#26(+输入#25,+标记#28)->+的#27(+输入#25,+数值#29)->+标记#28"%数值"(,)->+数值#29"[-235.9917834513436, 111.72494131125373]"(,)->+的#30(_交点,+HTML#23)->+的#31(_交点,+标记#28)->+的#32(_交点,+P代码#4)->+的#33(_交点,+画图#2)->+的#34(_交点,+类型#1)->+的#35(_交点,+数值#29)->+[P函数](,+P代码#4)



## end
#394, 4538:
"""
+[返回目录](,创建角度)

"""

+创建角度(,_角度)->+[del](,+创建角度)...
->_角度(_A线,_B线)...

->_A线->的(_A线,HTML#主语)->的(_A线,线粗细#主语)->的(_A线,线型#主语)->的(_A线,线颜色#主语)->的(_A线,选中区域#主语)->的(_A线,类型#主语)->的(_A线,画图#主语)->的(_A线,终点#主语)->的(_A线,起点#主语)...

->_B线->的(_B线,HTML#宾语)->的(_B线,线粗细#宾语)->的(_B线,线型#宾语)->的(_B线,线颜色#宾语)->的(_B线,选中区域#宾语)->的(_B线,类型#宾语)->的(_B线,画图#宾语)->的(_B线,终点#宾语)->的(_B线,起点#宾语)...

->+[修改内容]"+[返回目录](,角度)

数值::
中心::
半径::20
起始角度::
类型::角度

标记::%数值

画图:...
HTML:...
P代码:...
+[P函数](,P代码)



+[创建输入](标记,画图)

"(,_角度)...

->+类型#1"角度"(,)->+P代码#2"\"\"\"
+[返回目录](,P代码)

+[P函数](,P代码)

输出:...
+[设置结构](,输出)

\"\"\"

Dx1=pt11[0]-pt12[0]
Dy1=pt11[1]-pt12[1]

Dx2=pt21[0]-pt22[0]
Dy2=pt21[1]-pt22[1]

D1=pt11[0]*Dy1-pt11[1]*Dx1
D2=pt21[0]*Dy2-pt21[1]*Dx2

L=Dy1*Dx2-Dy2*Dx1
if L==0:
    pt0=\"None\"
else:
    pt0=[(D1*Dx2-D2*Dx1)/L, (D1*Dy2-D2*Dy1)/L]
    if np.sqrt((pt0[0]-pt11[0])**2+(pt0[1]-pt11[1])**2) < np.sqrt((pt0[0]-pt12[0])**2+(pt0[1]-pt12[1])**2):
        Dx1=-Dx1
        Dy1=-Dy1
    
    if np.sqrt((pt0[0]-pt21[0])**2+(pt0[1]-pt21[1])**2) < np.sqrt((pt0[0]-pt22[0])**2+(pt0[1]-pt22[1])**2):
        Dx2=-Dx2
        Dy2=-Dy2

    sign=np.sign(Dx1*Dy2-Dx2*Dy1)
    Dtheta=np.arccos((Dx1*Dx2+Dy1*Dy2)/np.sqrt((Dx1**2+Dy1**2)*(Dx2**2+Dy2**2)))
    angle=np.rad2deg(Dtheta)*sign

    theta0=np.arccos(Dx1/np.sqrt(Dx1**2+Dy1**2))
    angle0=np.rad2deg(theta0)*np.sign(Dy1)

    print(Dy1/np.sqrt(Dx1**2+Dy1**2),theta0,angle0)

    中心=pt0
    起始角度=angle0


\"\"\"
+[P函数](,P代码)
+[设置结构](,输出)

\"\"\""(,)->+的#3(+P代码#2,+输入#5)->+的#4(+P代码#2,+输出#13)->+输入#5"+[返回目录]
+[内容]
"(,)->+的#6(+输入#5,+起始角度#45)->+的#7(+输入#5,+中心#43)->+的#8(+输入#5,+angle#21)->+的#9(+输入#5,+pt22#23)->+的#10(+输入#5,+pt21#25)->+的#11(+输入#5,+pt12#27)->+的#12(+输入#5,+pt11#29)->+输出#13"+[返回目录]
+[内容]
pt11::
pt12::
pt21::
pt22::
angle::
中心::
起始角度::
"(,)->+的#14(+输出#13,+pt11#29)->+的#15(+输出#13,+pt12#27)->+的#16(+输出#13,+pt21#25)->+的#17(+输出#13,+pt22#23)->+的#18(+输出#13,+angle#21)->+的#19(+输出#13,+中心#43)->+的#20(+输出#13,+起始角度#45)->+angle#21"[-98.97175426444828]"(,)->+等于#22(+angle#21,+数值#42)->+pt22#23"[-349.49362322251244, -24.973959670919836]"(,)->+等于#24(+pt22#23,终点#宾语)->+pt21#25"[-293.74573559902734, 73.08672908507212]"(,)->+等于#26(+pt21#25,起点#宾语)->+pt12#27"[-144.95601336847886, 16.64392319481219]"(,)->+等于#28(+pt12#27,终点#主语)->+pt11#29"[-380.7181509706786, 105.48021205723182]"(,)->+等于#30(+pt11#29,起点#主语)->+画图#31"\"\"\"
+[返回目录](,画图)

输入:...
+[设置结构](,输入)

\"\"\"

pt0=中心
r=半径[0]
angle0=-起始角度[0]
Dangle=-数值[0]

dx=r*np.cos(np.deg2rad(angle0+Dangle)/2)
dy=r*np.sin(np.deg2rad(angle0+Dangle)/2)


qp.setPen(QPen(QColor(0,0,0)))
qp.setBrush(QBrush(QColor(255,255,255)))

qp.drawArc(pt0[0]-r,pt0[1]-r,2*r,2*r,angle0*16,Dangle*16)

qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont(\"Decorative\",10))


if 标记=='%数值':
    qp.drawText(pt0[0]+dx,pt0[1]+dy,\"%.2f\"%(Dangle))
else:
    qp.drawText(pt0[0]+dx,pt0[1]+dy,str(标记))

qp.drawPoint(pt0[0]+dx,pt0[1]+dy)

qp.setFont(QFont())



"(,)->+的#32(+画图#31,+输入#35)->+HTML#33"/*
+[返回目录](,HTML)

+[新建阅读窗口](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var pt0=[%中心];
var r=%半径;
var Dangle=%数值;
var angle0=%起始角度;
var text=\"%标记\";

dx=1.5*r*Math.cos((angle0+Dangle)/180*Math.PI/2);
dy=1.5*r*Math.sin((angle0+Dangle)/180*Math.PI/2);


ctx.beginPath();
if(Dangle>0) {
    ctx.arc(pt0[0],pt0[1],r,angle0/180*Math.PI,(angle0+Dangle)/180*Math.PI);
} else {
    ctx.arc(pt0[0],pt0[1],r,(angle0+Dangle)/180*Math.PI,angle0/180*Math.PI);
}

ctx.strokeStyle='rgba(0,0,0)';
ctx.stroke();

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center';
ctx.textBaseline='middle';
ctx.font=8*2+'px serif';

if (text[0]==='%') {
    ctx.fillText(`${-Dangle.toFixed(2)}`,pt0[0]+dx,pt0[1]+dy);
} else {
    ctx.fillText(text,pt0[0]+dx,pt0[1]+dy);
}


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
"(,)->+的#34(+HTML#33,+输入#35)->+输入#35"+[返回目录]
+[内容]
标记::%数值
中心::-338.8789230341691, -3.8202594274802757
半径::10
起始角度::136.10929165904932
数值::62.220685781962224
"(,)->+的#36(+输入#35,+标记#41)->+的#37(+输入#35,+中心#43)->+的#38(+输入#35,+半径#44)->+的#39(+输入#35,+起始角度#45)->+的#40(+输入#35,+数值#42)->+标记#41"%数值"(,)->+数值#42"[-98.97175426444828]"(,)->+中心#43"[-293.9227808686684, 72.77530596534346]"(,)->+半径#44"[20.0]"(,)->+起始角度#45"[-20.646646488466594]"(,)->+的#46(_角度,+起始角度#45)->+的#47(_角度,+半径#44)->+的#48(_角度,+中心#43)->+的#49(_角度,+HTML#33)->+的#50(_角度,+标记#41)->+的#51(_角度,+画图#31)->+的#52(_角度,+等于#30)->+的#53(_角度,+pt11#29)->+的#54(_角度,+等于#28)->+的#55(_角度,+pt12#27)->+的#56(_角度,+等于#26)->+的#57(_角度,+pt21#25)->+的#58(_角度,+等于#24)->+的#59(_角度,+pt22#23)->+的#60(_角度,+等于#22)->+的#61(_角度,+angle#21)->+的#62(_角度,+P代码#2)->+的#63(_角度,+类型#1)->+的#64(_角度,+数值#42)->+[P函数](,+P代码#2)



## end
#396, 6490:
"""
+[返回目录](,创建垂线)

"""

+创建垂线(,_垂线)->+[del](,+创建垂线)...
->_垂线(_A线,)...

->_A线->的(_A线,HTML#主语)->的(_A线,线粗细#主语)->的(_A线,线型#主语)->的(_A线,线颜色#主语)->的(_A线,选中区域#主语)->的(_A线,类型#主语)->的(_A线,画图#主语)->的(_A线,终点#主语)->的(_A线,起点#主语)...



->+[修改内容]"+[返回目录](,垂线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...

P代码:...
+[P函数](,P代码)

"(,_垂线)...

->+是(起点#主语,+pt11#36)->+是(终点#主语,+pt12#50)->+是(起点#主语,+pt11#49)->+是#32(+终点#31,+pt02#48)->+画图#1"\"\"\"
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

\"\"\"
pt1=起点
pt2=终点

d=10

lineWidth=线粗细[0]
lineType=线型

Dx=pt2[0]-pt1[0]
Dy=pt2[1]-pt1[1]

Dx1=pt11[0]-pt1[0]
Dy1=pt11[1]-pt1[1]

sign=np.sign(Dy)
theta1=-sign*np.arccos(Dx/np.sqrt(Dx**2+Dy**2))
angle1=np.rad2deg(theta1)
theta2=np.deg2rad(angle1+90)

dp1=[d*np.cos(theta1),-d*np.sin(theta1)]
dp2=[d*np.cos(theta2),-d*np.sin(theta2)]

sign2=np.sign(Dx1*dp2[0]+Dy1*dp2[1])
dp2=[sign2*dp2[0],sign2*dp2[1]]


pt01=[pt1[0]+dp1[0],pt1[1]+dp1[1]]
pt02=[pt01[0]+dp2[0],pt01[1]+dp2[1]]
pt03=[pt02[0]-dp1[0],pt02[1]-dp1[1]]

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType==\"DashLine\":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
qp.drawLine(pt01[0],pt01[1],pt02[0],pt02[1])
qp.drawLine(pt02[0],pt02[1],pt03[0],pt03[1])


qp.setPen(QPen())



"(,)->+的#2(+画图#1,+输入#23)->+的#3(+画图#1,+输出#6)->+的#4(+画图#1,+图形#7)->+的#5(+画图#1,+选中框#8)->+输出#6(,)->+图形#7"\"\"\"
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

\"\"\"
pt1=起点
pt2=终点

d=10

lineWidth=线粗细[0]
lineType=线型

Dx=pt2[0]-pt1[0]
Dy=pt2[1]-pt1[1]

Dx1=pt11[0]-pt1[0]
Dy1=pt11[1]-pt1[1]

sign=np.sign(Dy)
theta1=-sign*np.arccos(Dx/np.sqrt(Dx**2+Dy**2))
angle1=np.rad2deg(theta1)
theta2=np.deg2rad(angle1+90)

dp1=[d*np.cos(theta1),-d*np.sin(theta1)]
dp2=[d*np.cos(theta2),-d*np.sin(theta2)]

sign2=np.sign(Dx1*dp2[0]+Dy1*dp2[1])
dp2=[sign2*dp2[0],sign2*dp2[1]]


pt01=[pt1[0]+dp1[0],pt1[1]+dp1[1]]
pt02=[pt01[0]+dp2[0],pt01[1]+dp2[1]]
pt03=[pt02[0]-dp1[0],pt02[1]-dp1[1]]

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType==\"DashLine\":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
qp.drawLine(pt01[0],pt01[1],pt02[0],pt02[1])
qp.drawLine(pt02[0],pt02[1],pt03[0],pt03[1])


qp.setPen(QPen())



"(,)->+选中框#8"\"\"\"
+[返回目录](,选中框)

\"\"\"
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))"(,)->+类型#9"直线"(,)->+选中区域#10"\"\"\"
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

\"\"\"

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False
"(,)->+的#11(+选中区域#10,+输入#14)->+的#12(+选中区域#10,+输出#17)->+的#13(+选中区域#10,+点线公式#18)->+输入#14"+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0
"(,)->+的#15(+输入#14,+起点#30)->+的#16(+输入#14,+终点#31)->+输出#17"+[返回目录]
+[内容]
"(,)->+点线公式#18"<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type=\"text/javascript\" src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"></script>
  </head>
  <body>
    <p><mathjax style=\"font-size:1.5em\">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>
"(,)->+的#19(+点线公式#18,+LaTeX数学记号#20)->+LaTeX数学记号#20"https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols"(,)->+HTML#21"/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
"(,)->+的#22(+HTML#21,+输入#23)->+输入#23"线颜色::0,0,0
线型::DashLine
线粗细::2
pt11::

pt11->是(_,pt11)->+[显示](,_)"(,)->+的#24(+输入#23,+起点#30)->+的#25(+输入#23,+终点#31)->+的#26(+输入#23,+线颜色#33)->+的#27(+输入#23,+线型#34)->+的#28(+输入#23,+线粗细#35)->+的#29(+输入#23,+pt11#36)->+起点#30"[-216.1938903355853, 43.48669226943532]"(,)->+终点#31"[-266.827256913543, -90.88892034651421]"(,)->+是#32(+终点#31,+pt02#48)->+线颜色#33"[0.0, 0.0, 0.0]"(,)->+线型#34"DashLine"(,)->+线粗细#35"[1.0]"(,)->+pt11#36"[-380.7181509706786, 105.48021205723182]"(,)->+P代码#37"\"\"\"
+[返回目录](,P代码)
+[P函数](,P代码)

输入:...
输出:...
+[设置结构](,输入)

\"\"\"


Dx1=pt12[0]-pt11[0]
Dy1=pt12[1]-pt11[1]

Dxr=pt12[0]-pt02[0]
Dyr=pt12[1]-pt02[1]

sign=np.sign(Dy1)
theta1=np.arccos(Dx1/np.sqrt(Dx1**2+Dy1**2))
angle1=-np.rad2deg(theta1)*sign

theta=np.deg2rad(angle1+90)

dx=np.cos(theta)
dy=-np.sin(theta)
DL=Dxr*dx+Dyr*dy

pt01=[pt02[0]+DL*dx,pt02[1]+DL*dy]


"(,)->+的#38(+P代码#37,+输出#40)->+的#39(+P代码#37,+输入#44)->+输出#40"+[返回目录]
+[内容]
pt01::
"(,)->+的#41(+输出#40,+pt01#42)->+pt01#42"[-216.1938903355853, 43.48669226943532]"(,)->+等于#43(+pt01#42,+起点#30)->+输入#44"+[返回目录]
+[内容]
pt02::
pt11::
pt12::
"(,)->+的#45(+输入#44,+pt02#48)->+的#46(+输入#44,+pt11#49)->+的#47(+输入#44,+pt12#50)->+pt02#48"[-266.827256913543, -90.88892034651421]"(,)->+pt11#49"[-380.7181509706786, 105.48021205723182]"(,)->+pt12#50"[-144.95601336847886, 16.64392319481219]"(,)->+的#51(_垂线,+P代码#37)->+的#52(_垂线,+HTML#21)->+的#53(_垂线,+线粗细#35)->+的#54(_垂线,+线型#34)->+的#55(_垂线,+线颜色#33)->+的#56(_垂线,+选中区域#10)->+的#57(_垂线,+类型#9)->+的#58(_垂线,+画图#1)->+的#59(_垂线,+终点#31)->+的#60(_垂线,+起点#30)->+[P函数](,+P代码#37)



## end
#397, 3:
406
## end
#399, 3:
417
## end
#401, 3:
497
## end
#403, 3:
%数值
## end
#405, 22:
+[返回目录]
+[内容]
标记::%数值

## end
#407, 40:
[-278.9469569315004, -66.11900461360207]
## end
#409, 41:
[-535.6326999999999, -146.51770000000005]
## end
#411, 41:
[-187.63270000000045, -37.51770000000005]
## end
#413, 42:
[-216.00015000000013, -131.55165000000005]
## end
#415, 41:
[-477.98325000000017, 140.77745000000004]
## end
#421, 48:
+[返回目录]
+[内容]
pt11::
pt12::
pt21::
pt22::
pt0::

## end
#424, 287:
"""
+[返回目录](,P代码)
输出:
+[设置结构](,输出)

+[P函数](,P代码)

"""

Dx1=pt11[0]-pt12[0]
Dy1=pt11[1]-pt12[1]

Dx2=pt21[0]-pt22[0]
Dy2=pt21[1]-pt22[1]

D1=pt11[0]*Dy1-pt11[1]*Dx1
D2=pt21[0]*Dy2-pt21[1]*Dx2

L=Dy1*Dx2-Dy2*Dx1
if L==0:
    pt0="None"
else:
    pt0=[(D1*Dx2-D2*Dx1)/L, (D1*Dy2-D2*Dy1)/L]

## end
#426, 26:
+[返回目录](,作用代码)

P代码:...



## end
#429, 615:
"""
+[返回目录](,画图)

输入:...

"""

r=5


qp.setPen(QPen(QColor(0,0,0),1,Qt.DashLine))
qp.setBrush(QBrush(QColor(255,255,255)))

qp.drawLine(pt0[0],pt0[1],pt11[0],pt11[1])
qp.drawLine(pt0[0],pt0[1],pt21[0],pt21[1])

qp.setPen(QPen(QColor(0,0,0)))
qp.setBrush(QBrush(QColor(255,255,255)))
qp.drawEllipse(pt0[0]-r,pt0[1]-r,2*r,2*r)
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",10))

if 标记=='%数值':
    qp.drawText(pt0[0],pt0[1],200,30,Qt.AlignLeft|Qt.AlignVCenter,"(%.2f,%.2f)"%(pt0[0],pt0[1]))
else:
    qp.drawText(pt0[0],pt0[1],100,30,Qt.AlignLeft|Qt.AlignVCenter,str(标记))

qp.setFont(QFont())
## end
#430, 2:
交点
## end
#431, 40:
[-278.9469569315004, -66.11900461360207]
## end
#438, 90:
+[返回目录](,交点)
+[设置结构](,交点)

数值::0,0
类型::交点

标记::%数值

画图:...
P代码:...
作用代码:...
+[P函数](,P代码)


## end
#440, 90:
+[返回目录](,交点)
+[设置结构](,交点)

数值::0,0
类型::交点

标记::%数值

画图:...
P代码:...
作用代码:...
+[P函数](,P代码)


## end
#441, 3:
%数值
## end
#443, 22:
+[返回目录]
+[内容]
标记::%数值

## end
#445, 40:
[-278.9469569315004, -66.11900461360207]
## end
#447, 41:
[-535.6326999999999, -146.51770000000005]
## end
#449, 41:
[-187.63270000000045, -37.51770000000005]
## end
#451, 42:
[-216.00015000000013, -131.55165000000005]
## end
#453, 41:
[-477.98325000000017, 140.77745000000004]
## end
#459, 48:
+[返回目录]
+[内容]
pt11::
pt12::
pt21::
pt22::
pt0::

## end
#462, 287:
"""
+[返回目录](,P代码)
输出:
+[设置结构](,输出)

+[P函数](,P代码)

"""

Dx1=pt11[0]-pt12[0]
Dy1=pt11[1]-pt12[1]

Dx2=pt21[0]-pt22[0]
Dy2=pt21[1]-pt22[1]

D1=pt11[0]*Dy1-pt11[1]*Dx1
D2=pt21[0]*Dy2-pt21[1]*Dx2

L=Dy1*Dx2-Dy2*Dx1
if L==0:
    pt0="None"
else:
    pt0=[(D1*Dx2-D2*Dx1)/L, (D1*Dy2-D2*Dy1)/L]

## end
#464, 26:
+[返回目录](,作用代码)

P代码:...



## end
#467, 615:
"""
+[返回目录](,画图)

输入:...

"""

r=5


qp.setPen(QPen(QColor(0,0,0),1,Qt.DashLine))
qp.setBrush(QBrush(QColor(255,255,255)))

qp.drawLine(pt0[0],pt0[1],pt11[0],pt11[1])
qp.drawLine(pt0[0],pt0[1],pt21[0],pt21[1])

qp.setPen(QPen(QColor(0,0,0)))
qp.setBrush(QBrush(QColor(255,255,255)))
qp.drawEllipse(pt0[0]-r,pt0[1]-r,2*r,2*r)
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",10))

if 标记=='%数值':
    qp.drawText(pt0[0],pt0[1],200,30,Qt.AlignLeft|Qt.AlignVCenter,"(%.2f,%.2f)"%(pt0[0],pt0[1]))
else:
    qp.drawText(pt0[0],pt0[1],100,30,Qt.AlignLeft|Qt.AlignVCenter,str(标记))

qp.setFont(QFont())
## end
#468, 2:
交点
## end
#469, 40:
[-278.9469569315004, -66.11900461360207]
## end
#475, 3:
493
## end
#477, 3:
486
## end
#479, 3:
491
## end
#481, 3:
490
## end
#483, 3:
501
## end
#485, 3:
497
## end
#487, 3:
496
## end
#489, 3:
522
## end
#492, 775:
/*
+[返回目录](,HTML)

+[新建阅读窗口](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var pt0=[%中心];
var r=%半径;
var Dangle=%数值;
var angle0=%起始角度;
var text="%标记";

dx=1.5*r*Math.cos((angle0+Dangle)/180*Math.PI/2);
dy=1.5*r*Math.sin((angle0+Dangle)/180*Math.PI/2);


ctx.beginPath();
if(Dangle>0) {
    ctx.arc(pt0[0],pt0[1],r,angle0/180*Math.PI,(angle0+Dangle)/180*Math.PI);
} else {
    ctx.arc(pt0[0],pt0[1],r,(angle0+Dangle)/180*Math.PI,angle0/180*Math.PI);
}

ctx.strokeStyle='rgba(0,0,0)';
ctx.stroke();

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center';
ctx.textBaseline='middle';
ctx.font=8*2+'px serif';

if (text[0]==='%') {
    ctx.fillText(`${-Dangle.toFixed(2)}`,pt0[0]+dx,pt0[1]+dy);
} else {
    ctx.fillText(text,pt0[0]+dx,pt0[1]+dy);
}


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/

## end
#495, 986:
%{
+[返回目录](,验证)

+[M函数](,验证)
%}

r=1;

r2=[30,10];
r1=[14,15];
r3=[11,10];
r4=[18,18];

Dx21=r2(1)-r1(1);
Dy21=r2(2)-r1(2);
Dx43=r4(1)-r3(1);
Dy43=r4(2)-r3(2);

D21=r1(1)*Dy21-r1(2)*Dx21;
D43=r3(1)*Dy43-r3(2)*Dx43;

x0=(D21*Dx43-D43*Dx21)/(Dy21*Dx43-Dy43*Dx21);
y0=(D21*Dy43-D43*Dy21)/(Dy21*Dx43-Dy43*Dx21);

if sqrt((x0-r1(1))^2+(y0-r1(2))^2)>sqrt((x0-r2(1))^2+(y0-r2(2))^2)
    Dx1=-Dx21;
    Dy1=-Dy21;
else
    Dx1=Dx21;
    Dy1=Dy21;
end

if sqrt((x0-r3(1))^2+(y0-r3(2))^2)>sqrt((x0-r4(1))^2+(y0-r4(2))^2)
    Dx2=-Dx43;
    Dy2=-Dy43;
else
    Dx2=Dx43;
    Dy2=Dy43;
end

theta0=acosd(Dx1/sqrt(Dx1^2+Dy1^2));
theta0=sign(Dy1)*theta0
Dtheta=acosd((Dx1*Dx2+Dy1*Dy2)/sqrt((Dx1^2+Dy1^2)*(Dx2^2+Dy2^2)));
Dtheta=sign(Dx1*Dy2-Dy1*Dx2)*Dtheta

lines_x=[r1(1),r2(1);r3(1),r4(1)]';
lines_y=[r1(2),r2(2);r3(2),r4(2)]';

theta=linspace(theta0,theta0+Dtheta,100);
arc_x=x0+r*cosd(theta);
arc_y=y0+r*sind(theta);

clf
plot(lines_x,lines_y,x0,y0,'r*',arc_x,arc_y)
axis equal

%{
+[M函数](,验证)
%}
## end
#498, 37:
-293.9227808686684, 72.77530596534346
## end
#500, 2:
20
## end
#502, 19:
-20.646646488466594
## end
#513, 521:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var pt0=[%数值]
var text='%标记'

ctx.beginPath();
ctx.arc(%数值,5,0,2*Math.PI);

ctx.fillStyle='rgba(255,255,255,0)';
ctx.fill();

ctx.strokeStyle='rgba(0,0,0)';
ctx.stroke();

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='left';
ctx.textBaseline='top';
ctx.font=8*2+'px serif';

if (text[0]==='%') {
    ctx.fillText(`(${pt0[0].toFixed(2)}), ${pt0[1].toFixed(2)})`,pt0[0],pt0[1]+5);
} else {
    ctx.fillText(text,pt0[0]+dx,pt0[1]+dy);
}



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#522, 3:
528
## end
#528, 3:
530
## end
#530, 3:
532
## end
#532, 3:
534
## end
#534, 3:
539
## end
#536, 3:
541
## end
#538, 3:
540
## end
#540, 3:
542
## end
#542, 3:
544
## end
#544, 3:
546
## end
#546, 3:
548
## end
#548, 3:
550
## end
#550, 3:
552
## end
#552, 3:
554
## end
#554, 3:
556
## end
#556, 3:
558
## end
### 结束