### 节点
地址, 的, 波包, 目录, 的, 的, 节点数目统计, 20210413, 的, 的, 二阶色散, 的, 公式推导, html, 的, 几何画板, 的, 场景, 的, 坐标系, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 选中区域, 的, 的, 输出, HTML, 的, 的, 输出, 输入, 的, 的, 的, 的, 的, 的, 起点, 尺寸, 类型, 原点, x坐标, y坐标, 可选, 比例, 的, 尺寸, 的, 原点, 的, 坐标系, 的, 透镜, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 选中区域, 的, 的, 输出, HTML, 的, 的, 输出, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 起点, 尺寸, 类型, 文字, 字体, 线型, 线粗细, 面颜色, 线颜色, 的, 光线, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线型, 线粗细, 的, 出射光谱, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 选中区域, 的, 的, 输出, HTML, 的, 的, 输出, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 起点, 尺寸, 类型, 线型, 线粗细, 面颜色, 线颜色, 中心位置, 分辨率, 函数, 可选, 的, 坐标系1, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 选中区域, 的, 的, 输出, HTML, 的, 的, 输出, 输入, 的, 的, 的, 的, 的, 的, 起点, 尺寸, 类型, 原点, x坐标, y坐标, 可选, 的, 入射光谱, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 选中区域, 的, 的, 输出, HTML, 的, 的, 输出, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 起点, 尺寸, 类型, 线型, 线粗细, 面颜色, 线颜色, 中心位置, 分辨率, 函数, 可选, 矩形, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 选中区域, 的, 的, 输出, HTML, 的, 的, 输出, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 起点, 尺寸, 类型, 文字, 字体, 线型, 线粗细, 面颜色, 线颜色, 20210414, 的, 的, 参考, 的, 群速度, 的, 光学数据, 的, TOPAS系统, html, 的, 光栅色散, html, 的, 光栅对, 的, 光栅1, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 比例, 的, 尺寸, 的, 原点, 的, 坐标系, 的, 光栅2, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 入射光线, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线型, 线粗细, 的, 内部光线1, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线型, 线粗细, 的, 出射光线1, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线型, 线粗细, 的, 内部光线2, 的, 出射光线2, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线型, 线粗细, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线型, 线粗细, 的, 法线1, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线型, 线粗细, 的, theta, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 标记, 等于, angle, 等于, pt22, 等于, pt21, 等于, pt12, 等于, pt11, 的, 的, 的, 的, 的, 输出, 的, 输入, 的, 的, 画图, 输入, 的, 的, P代码, 类型, 数值, 的, beta, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 标记, 等于, angle, 等于, pt22, 等于, pt21, 等于, pt12, 等于, pt11, 的, 的, 的, 的, 的, 输出, 的, 输入, 的, 的, 画图, 输入, 的, 的, P代码, 类型, 数值, 的, 间距, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线型, 线粗细, 文字, 位移距离, 矩形, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 选中区域, 的, 的, 输出, HTML, 的, 的, 输出, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 起点, 尺寸, 类型, 文字, 字体, 线型, 线粗细, 面颜色, 线颜色, 的, 水平距离, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线型, 线粗细, 的, 标记水平距离, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线型, 线粗细, 文字, 位移距离, 的, 参考, 的, 参考2, 的, 计算TOPAS波包展宽, M函数, 的, 测量角度, 的, 光栅图片, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 的, 的, 选中框, 图形, 选中区域, 的, 的, 输出, HTML, 的, 的, 输出, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 起点, 尺寸, 类型, 文字, 字体, 线型, 线粗细, 面颜色, 线颜色, 地址, 的, 入射光线, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线型, 线粗细, 比例, 的, 尺寸, 的, 原点, 的, 坐标系, 的, 光栅方向, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线型, 线粗细, 的, 角度, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 标记, 等于, angle, 等于, pt22, 等于, pt21, 等于, pt12, 等于, pt11, 的, 的, 的, 的, 的, 输出, 的, 输入, 的, 的, 画图, 输入, 的, 的, P代码, 类型, 数值, 的, TOPAS图片, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 的, 的, 选中框, 图形, 选中区域, 的, 的, 输出, HTML, 的, 的, 输出, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 起点, 尺寸, 类型, 文字, 字体, 线型, 线粗细, 面颜色, 线颜色, 地址, 的, 光线2, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线型, 线粗细, 的, plate1方向, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线型, 线粗细, 的, plate2方向, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线型, 线粗细, 的, 角度1, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 标记, 等于, angle, 等于, pt22, 等于, pt21, 等于, pt12, 等于, pt11, 的, 的, 的, 的, 的, 输出, 的, 输入, 的, 的, 画图, 输入, 的, 的, P代码, 类型, 数值, 的, 角度2, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 标记, 等于, angle, 等于, pt22, 等于, pt21, 等于, pt12, 等于, pt11, 的, 的, 的, 的, 的, 输出, 的, 输入, 的, 的, 画图, 输入, 的, 的, P代码, 类型, 数值, 的, 光斑形状与光强, M函数, 的, 计算光强, M函数, 的, 高斯光束, 的, 激光光强, 的, 画板, 20210415, 的, 的, lens厚度, 20210419, 的, 20210425, 的, 20210602, 的, 20210614, 的, 20210722, 的, 的, 公式验证, M函数, TOPAS系统, 的, 记忆, TOPAS系统, 20220407, 的, 的, 推导结果, html, 的, [1]., 的, [2]., 的, [3]., 的, [4]., 的, [5]., 的, [6]., 表达式, 的, 公式, 表达式, 的, 公式, 的, 表达式, 的, 公式, 的, 表达式, 的, 公式, b, 的, a, 的, 的, 的, 的, [7]., 表达式, 的, 公式, 的, 表达式, 的, 公式, 的, 表达式, 的, 公式, 的, [8]., 的, [9]., 表达式, 的, 公式, 的, 的, 起点, 的, 表达式, 的, 公式, 的, 的, 验证公式, M函数, 括号, 的, 括号, 的, 的, [10]., 表达式, 的, 公式, 的, [11]., 表达式, 的, 公式, 新结构, 新结构, 起点, 的, 括号, 的, 的, 起点, 的, 的, b, 的, a, 的, 的, 的, 括号, 的, b, 的, a, 的, 的, 的, 括号, 的, 的, 括号, 的, 括号, 的, b, 的, a, 的, 的, 的, 括号, 的, 的, 括号, 的, 括号, 的, 的, 保存, 的, 波包表达式, 的, 设置光谱, 的, 波包对比, 
### 关联
#, 2#0, #, #, 3#2, 3#6, #, #, 6#7, 2#10, #, 10#12, #, 12#, 2#15, #, 12#17, #, 17#19, #, 19#30, 19#38, 19#42, 19#53, 19#54, 19#55, 19#56, 19#57, 19#58, 19#59, #, 30#46, 30#35, 30#36, 30#37, #, #, #, #, 38#41, 38#46, #, #, 42#45, 42#46, #, #, 46#54, 46#53, 46#56, 46#57, 46#58, 46#59, #, #, #, #, #, #, #, #, 66#60, #, 66#62, #, 66#64, 17#, 17#68, #, 68#81, 68#89, 68#93, 68#106, 68#107, 68#108, 68#109, 68#110, 68#111, 68#112, 68#113, 68#114, #, 81#97, 81#86, 81#87, 81#88, #, #, #, #, 89#92, 89#97, #, #, 93#96, 93#97, #, #, 97#113, 97#114, 97#111, 97#112, 97#109, 97#110, 97#107, 97#106, #, #, #, #, #, #, #, #, #, 17#116, #, 116#154, 116#155, 116#126, 116#134, 116#135, 116#156, 116#157, 116#158, 116#146, #, 126#148, 126#131, 126#132, 126#133, #, #, #, #, #, 135#139, 135#142, 135#143, #, 139#154, 139#155, #, #, 143#145, #, #, 146#148, #, 148#154, 148#155, 148#156, 148#157, 148#158, #, #, #, #, #, 17#160, #, 160#175, 160#183, 160#187, 160#202, 160#203, 160#204, 160#205, 160#206, 160#207, 160#208, 160#209, 160#210, 160#211, 160#212, #, 175#191, 175#180, 175#181, 175#182, #, #, #, #, 183#186, 183#191, #, #, 187#190, 187#191, #, #, 191#207, 191#208, 191#205, 191#206, 191#203, 191#202, 191#209, 191#210, 191#211, 191#212, #, #, #, #, #, #, #, #, #, #, #, 17#214, #, 214#225, 214#233, 214#237, 214#248, 214#249, 214#250, 214#251, 214#252, 214#253, 214#254, #, 225#241, 225#230, 225#231, 225#232, #, #, #, #, 233#236, 233#241, #, #, 237#240, 237#241, #, #, 241#249, 241#248, 241#251, 241#252, 241#253, 241#254, #, #, #, #, #, #, #, 17#256, #, 256#271, 256#279, 256#283, 256#298, 256#299, 256#300, 256#301, 256#302, 256#303, 256#304, 256#305, 256#306, 256#307, 256#308, #, 271#287, 271#276, 271#277, 271#278, #, #, #, #, 279#282, 279#287, #, #, 283#286, 283#287, #, #, 287#303, 287#304, 287#301, 287#302, 287#299, 287#298, 287#305, 287#306, 287#307, 287#308, #, #, #, #, #, #, #, #, #, #, #, #, 17#309, 309#323, 309#331, 309#335, 309#348, 309#349, 309#350, 309#351, 309#352, 309#353, 309#354, 309#355, 309#356, #, 323#339, 323#328, 323#329, 323#330, #, #, #, #, 331#334, 331#339, #, #, 335#338, 335#339, #, #, 339#355, 339#356, 339#353, 339#354, 339#351, 339#352, 339#349, 339#348, #, #, #, #, #, #, #, #, #, #, 6#357, 12#360, #, 10#362, #, 10#364, #, 10#366, #, 366#, 10#369, #, 369#, 369#372, #, 372#374, #, 374#416, 374#417, 374#418, 374#388, 374#396, 374#419, 374#397, 374#420, 374#421, 374#422, 374#423, 374#424, 374#404, #, 388#406, 388#393, 388#394, 388#395, #, #, #, #, #, 397#400, 397#401, #, #, 401#417, 401#418, #, 404#406, #, 406#416, 406#417, 406#418, 406#419, 406#420, 406#421, 406#422, 406#423, 406#424, #, #, #, #, #, #, #, #, #, #, 431#425, #, 431#427, #, 431#429, 372#, 372#433, #, 433#475, 433#476, 433#477, 433#447, 433#455, 433#478, 433#456, 433#479, 433#480, 433#481, 433#482, 433#483, 433#463, #, 447#465, 447#452, 447#453, 447#454, #, #, #, #, #, 456#459, 456#460, #, #, 460#476, 460#477, #, 463#465, #, 465#475, 465#476, 465#477, 465#478, 465#479, 465#480, 465#481, 465#482, 465#483, #, #, #, #, #, #, #, #, #, 372#485, #, 485#523, 485#524, 485#495, 485#503, 485#504, 485#525, 485#526, 485#527, 485#515, #, 495#517, 495#500, 495#501, 495#502, #, #, #, #, #, 504#508, 504#511, 504#512, #, 508#523, 508#524, #, #, 512#514, #, #, 515#517, #, 517#523, 517#524, 517#525, 517#526, 517#527, #, #, #, #, #, 372#529, #, 529#567, 529#568, 529#539, 529#547, 529#548, 529#569, 529#570, 529#571, 529#559, #, 539#561, 539#544, 539#545, 539#546, #, #, #, #, #, 548#552, 548#555, 548#556, #, 552#567, 552#568, #, #, 556#558, #, #, 559#561, #, 561#567, 561#568, 561#569, 561#570, 561#571, #, #, #, #, #, 372#573, #, 573#611, 573#612, 573#583, 573#591, 573#592, 573#613, 573#614, 573#615, 573#603, #, 583#605, 583#588, 583#589, 583#590, #, #, #, #, #, 592#596, 592#599, 592#600, #, 596#611, 596#612, #, #, 600#602, #, #, 603#605, #, 605#611, 605#612, 605#613, 605#614, 605#615, #, #, #, #, #, 372#617, #, 372#619, #, 617#657, 617#658, 617#629, 617#637, 617#638, 617#659, 617#660, 617#661, 617#649, #, 629#651, 629#634, 629#635, 629#636, #, #, #, #, #, 638#642, 638#645, 638#646, #, 642#657, 642#658, #, #, 646#648, #, #, 649#651, #, 651#657, 651#658, 651#659, 651#660, 651#661, #, #, #, #, #, 619#699, 619#700, 619#671, 619#679, 619#680, 619#701, 619#702, 619#703, 619#691, #, 671#693, 671#676, 671#677, 671#678, #, #, #, #, #, 680#684, 680#687, 680#688, #, 684#699, 684#700, #, #, 688#690, #, #, 691#693, #, 693#699, 693#700, 693#701, 693#702, 693#703, #, #, #, #, #, 372#705, #, 705#743, 705#744, 705#715, 705#723, 705#724, 705#745, 705#746, 705#747, 705#735, #, 715#737, 715#720, 715#721, 715#722, #, #, #, #, #, 724#728, 724#731, 724#732, #, 728#743, 728#744, #, #, 732#734, #, #, 735#737, #, 737#743, 737#744, 737#745, 737#746, 737#747, #, #, #, #, #, 372#749, 485#705, 749#792, 749#791, 749#790, 749#767, 749#766, 749#769, 749#768, 749#771, 749#770, 749#773, 749#772, 749#775, 749#774, 749#786, 749#765, #, 767#792, #, 769#744, #, 771#743, #, 773#524, #, 775#523, #, 781#767, 781#769, 781#771, 781#773, 781#775, #, 783#765, #, 786#781, 786#783, #, #, 790#787, 790#781, #, #, #, 372#794, 529#705, 794#837, 794#836, 794#835, 794#812, 794#811, 794#814, 794#813, 794#816, 794#815, 794#818, 794#817, 794#820, 794#819, 794#831, 794#810, #, 812#837, #, 814#744, #, 816#743, #, 818#568, #, 820#567, #, 826#812, 826#814, 826#816, 826#818, 826#820, #, 828#810, #, 831#826, 831#828, #, #, 835#832, 835#826, #, #, #, 372#839, #, 839#881, 839#882, 839#851, 839#859, 839#860, 839#883, 839#884, 839#885, 839#886, 839#887, 839#871, #, 851#873, 851#856, 851#857, 851#858, #, #, #, #, #, 860#864, 860#867, 860#868, #, 864#881, 864#882, #, #, 868#870, #, #, 871#873, #, 873#881, 873#882, 873#883, 873#884, 873#885, 873#886, 873#887, #, #, #, #, #, #, #, #, 372#888, 888#902, 888#910, 888#914, 888#927, 888#928, 888#929, 888#930, 888#931, 888#932, 888#933, 888#934, 888#935, #, 902#918, 902#907, 902#908, 902#909, #, #, #, #, 910#913, 910#918, #, #, 914#917, 914#918, #, #, 918#934, 918#935, 918#932, 918#933, 918#930, 918#931, 918#928, 918#927, #, #, #, #, #, #, #, #, #, 372#937, #, 937#975, 937#976, 937#947, 937#955, 937#956, 937#977, 937#978, 937#979, 937#967, #, 947#969, 947#952, 947#953, 947#954, #, #, #, #, #, 956#960, 956#963, 956#964, #, 960#975, 960#976, #, #, 964#966, #, #, 967#969, #, 969#975, 969#976, 969#977, 969#978, 969#979, #, #, #, #, #, 372#981, #, 981#1023, 981#1024, 981#993, 981#1001, 981#1002, 981#1025, 981#1026, 981#1027, 981#1028, 981#1029, 981#1013, #, 993#1015, 993#998, 993#999, 993#1000, #, #, #, #, #, 1002#1006, 1002#1009, 1002#1010, #, 1006#1023, 1006#1024, #, #, 1010#1012, #, #, 1013#1015, #, 1015#1023, 1015#1024, 1015#1025, 1015#1026, 1015#1027, 1015#1028, 1015#1029, #, #, #, #, #, #, #, 369#1031, #, 369#1033, #, 366#1035, #, 1035#, 366#1038, #, 1038#1040, #, 1040#1054, 1040#1064, 1040#1068, 1040#1082, 1040#1083, 1040#1084, 1040#1085, 1040#1086, 1040#1087, 1040#1088, 1040#1089, 1040#1090, 1040#1091, #, 1054#1072, 1054#1059, 1054#1062, 1054#1063, #, 1059#1082, 1059#1083, #, #, #, 1064#1067, 1064#1072, #, #, 1068#1071, 1068#1072, #, #, 1072#1089, 1072#1090, 1072#1087, 1072#1088, 1072#1085, 1072#1086, 1072#1083, 1072#1082, 1072#1091, #, #, #, #, #, #, #, #, #, #, 1038#1093, #, 1093#1131, 1093#1132, 1093#1103, 1093#1111, 1093#1112, 1093#1133, 1093#1134, 1093#1135, 1093#1123, #, 1103#1125, 1103#1108, 1103#1109, 1103#1110, #, #, #, #, #, 1112#1116, 1112#1119, 1112#1120, #, 1116#1131, 1116#1132, #, #, 1120#1122, #, #, 1123#1125, #, 1125#1131, 1125#1132, 1125#1133, 1125#1134, 1125#1135, #, #, #, #, #, #, 1142#1136, #, 1142#1138, #, 1142#1140, 1038#, 1038#1144, #, 1144#1182, 1144#1183, 1144#1154, 1144#1162, 1144#1163, 1144#1184, 1144#1185, 1144#1186, 1144#1174, #, 1154#1176, 1154#1159, 1154#1160, 1154#1161, #, #, #, #, #, 1163#1167, 1163#1170, 1163#1171, #, 1167#1182, 1167#1183, #, #, 1171#1173, #, #, 1174#1176, #, 1176#1182, 1176#1183, 1176#1184, 1176#1185, 1176#1186, #, #, #, #, #, 1038#1188, 1093#1144, 1188#1231, 1188#1230, 1188#1229, 1188#1206, 1188#1205, 1188#1208, 1188#1207, 1188#1210, 1188#1209, 1188#1212, 1188#1211, 1188#1214, 1188#1213, 1188#1225, 1188#1204, #, 1206#1231, #, 1208#1183, #, 1210#1182, #, 1212#1132, #, 1214#1131, #, 1220#1206, 1220#1208, 1220#1210, 1220#1212, 1220#1214, #, 1222#1204, #, 1225#1220, 1225#1222, #, #, 1229#1226, 1229#1220, #, #, #, 1038#1233, #, 1233#1247, 1233#1257, 1233#1261, 1233#1275, 1233#1276, 1233#1277, 1233#1278, 1233#1279, 1233#1280, 1233#1281, 1233#1282, 1233#1283, 1233#1284, #, 1247#1265, 1247#1252, 1247#1255, 1247#1256, #, 1252#1275, 1252#1276, #, #, #, 1257#1260, 1257#1265, #, #, 1261#1264, 1261#1265, #, #, 1265#1282, 1265#1283, 1265#1280, 1265#1281, 1265#1278, 1265#1279, 1265#1276, 1265#1275, 1265#1284, #, #, #, #, #, #, #, #, #, #, 1038#1286, #, 1286#1324, 1286#1325, 1286#1296, 1286#1304, 1286#1305, 1286#1326, 1286#1327, 1286#1328, 1286#1316, #, 1296#1318, 1296#1301, 1296#1302, 1296#1303, #, #, #, #, #, 1305#1309, 1305#1312, 1305#1313, #, 1309#1324, 1309#1325, #, #, 1313#1315, #, #, 1316#1318, #, 1318#1324, 1318#1325, 1318#1326, 1318#1327, 1318#1328, #, #, #, #, #, 1038#1330, #, 1330#1368, 1330#1369, 1330#1340, 1330#1348, 1330#1349, 1330#1370, 1330#1371, 1330#1372, 1330#1360, #, 1340#1362, 1340#1345, 1340#1346, 1340#1347, #, #, #, #, #, 1349#1353, 1349#1356, 1349#1357, #, 1353#1368, 1353#1369, #, #, 1357#1359, #, #, 1360#1362, #, 1362#1368, 1362#1369, 1362#1370, 1362#1371, 1362#1372, #, #, #, #, #, 1038#1374, #, 1374#1412, 1374#1413, 1374#1384, 1374#1392, 1374#1393, 1374#1414, 1374#1415, 1374#1416, 1374#1404, #, 1384#1406, 1384#1389, 1384#1390, 1384#1391, #, #, #, #, #, 1393#1397, 1393#1400, 1393#1401, #, 1397#1412, 1397#1413, #, #, 1401#1403, #, #, 1404#1406, #, 1406#1412, 1406#1413, 1406#1414, 1406#1415, 1406#1416, #, #, #, #, #, 1038#1418, 1286#1330, 1418#1461, 1418#1460, 1418#1459, 1418#1436, 1418#1435, 1418#1438, 1418#1437, 1418#1440, 1418#1439, 1418#1442, 1418#1441, 1418#1444, 1418#1443, 1418#1455, 1418#1434, #, 1436#1461, #, 1438#1369, #, 1440#1368, #, 1442#1325, #, 1444#1324, #, 1450#1436, 1450#1438, 1450#1440, 1450#1442, 1450#1444, #, 1452#1434, #, 1455#1450, 1455#1452, #, #, 1459#1456, 1459#1450, #, #, #, 1038#1463, 1286#1374, 1463#1506, 1463#1505, 1463#1504, 1463#1481, 1463#1480, 1463#1483, 1463#1482, 1463#1485, 1463#1484, 1463#1487, 1463#1486, 1463#1489, 1463#1488, 1463#1500, 1463#1479, #, 1481#1506, #, 1483#1413, #, 1485#1412, #, 1487#1325, #, 1489#1324, #, 1495#1481, 1495#1483, 1495#1485, 1495#1487, 1495#1489, #, 1497#1479, #, 1500#1495, 1500#1497, #, #, 1504#1501, 1504#1495, #, #, #, 366#1508, #, 1508#, 366#1511, #, 1511#, 1511#1514, #, 1511#1516, #, 369#1518, 372#, #, 6#1519, 366#1522, #, #, 6#1523, #, 6#1525, #, 6#1527, #, 6#1529, #, 6#1531, 12#1534, #, 1534#, #366, 1538#1536, 3#, #, #, 6#1540, 10#1543, #, 1543#, 1543#1546, #, 1543#1548, #, 1543#1550, #, 1543#1552, #, 1543#1554, #, 1543#1556, #, #, 1546#1557, 1546#, #, 1548#1560, 1548#, 1560#del, #, 1550#1564, 1550#, 1564#del, #, 1552#1568, 1552#, #, 1560#1571, #, 1560#1573, 1573#del, 1571#del, 1543#1578, #, #, 1554#1579, 1554#, 1579#del, #, 1556#1583, 1556#, 1583#del, #, 1578#1587, 1578#, 1543#1591, #, 1543#1593, #, #, 1591#1594, 1591#, 1557#del, 1568#del, #, 1594#1599, #, 1593#1601, 1593#, 1601#del, 1543#1606, #, 1606#, #, 1564#1608, #, 1568#1610, 1543#1613, #, #, 1613#1614, 1613#, 1543#1618, #, #, 1618#1619, 1618#, #, #, #1626, 1619#1624, #, 1619#1626, 1619#del, #, 1587#1629, 1614#del, #, 1587#1632, #, 1587#1634, 1634#del, 1632#del, #, 1614#1638, #, 1594#1640, #, 1594#1642, 1642#del, 1640#del, #, 1614#1646, 1614#del, #, 1614#1649, #, 1614#1651, #, 1601#1653, #, 1601#1655, 1655#del, 1653#del, #, 1614#1659, 1614#del, #, 1614#1662, #, 1614#1664, 1606#1667, #, 1606#1669, #, 1606#1671, #, 1606#1673, #, 
### 内容
#0, 15:
文档\物理问题\波包.ftxt
## end
#2, 156:
+[返回目录](,波包)
地址::文档\物理问题\波包.ftxt

几何画板::文档\S应用\几何样本库.ftxt
+[打开文件](+新窗口,几何画板)

将"文档\物理问题\光栅压缩器.ftxt"记作光栅压缩器
Nini, 打开光栅压缩器的色散曲线(节点)
Nini, 导入网页画板的库

二阶色散:...


## end
#3, 46:
波包:...
创建于 20210413

节点数目统计::
+[设置结构](,节点数目统计)
## end
#7, 3:
360
## end
#10, 306:
+[返回目录](,二阶色散)

群速度::文档\物理问题\群速度.ftxt
+[打开文件](+新窗口,群速度)
光学数据::https://refractiveindex.info
+[打开网页](,光学数据)



公式推导(html):...
推导结果(html):...
+[新建阅读窗口](,公式推导)
+[新建阅读窗口](,公式推导)

光栅色散(html):...
+[复制结构](,光栅色散)
(有一些问题没能解决)
(基本解决了, 见光栅原理.ftxt)


TOPAS系统(html):Fused silica, ZnSe, air, grating...
+[H函数](,公式推导)





## end
#12, 3729:
<!--
+[H函数](,公式推导)
参考::https://en.wikipedia.org/wiki/Group_velocity_dispersion#Derivation
+[打开网页](,参考)

场景(画板):...
场景->画板(场景,)->+[del](,画板)
+[画板](+波包场景,场景)

+[H函数](,公式推导)
-->

Assuming the spectrum of a pulse is,
$$
S(\omega)=A exp\left(-\frac{(\omega-\omega_0)^2}{\delta \omega^2}\right)
\equiv 
A exp\left(-\frac{\Delta \omega^2}{\delta \omega^2}\right)
$$
After the pulse passing through a plate with dispersion relation \(n(\omega)\), then it will have a phase, 
$$
f(\omega)=exp\left(i k D\right)
=exp\left(i k(\omega)D\right)
$$
The thickness of the plate is \(D\).<br>
We can Taylor expend the dispersion relation, 
$$
k(\omega)=k(\omega_0)
+\frac{\partial k}{\partial \omega}\Delta \omega
+\frac{1}{2}\frac{\partial^2 k}{\partial \omega^2}\Delta \omega^2
+...
$$
Take only the first two terms, then we have, 
$$
f(\omega)
\approx
exp\left[i
\left( 
k_0
+\frac{\partial k}{\partial \omega}\Delta \omega
+\frac{1}{2}\frac{\partial^2 k}{\partial \omega^2}\Delta \omega^2
\right)
D\right]
$$

As a result, the pulse spectrum looks like, 
$$
S'(\omega)=f(\omega)S(\omega)
=A
exp\left[i
\left( 
k_0
+\frac{\partial k}{\partial \omega}\Delta \omega
+\frac{1}{2}\frac{\partial^2 k}{\partial \omega^2}\Delta \omega^2
\right)
D\right]
exp\left(-\frac{\Delta \omega^2}{\delta \omega^2}\right)
\\
=A
exp\left[i
\left( 
k_0
+\frac{\partial k}{\partial \omega}\Delta \omega
\right)
D\right]
exp\left[
\left(
\frac{i}{2}\frac{\partial^2 k}{\partial \omega^2} D
-\frac{1}{\delta \omega^2}\right)\Delta \omega^2
\right]
$$
Then we can discuss about the Fourier transform of exponential function. <br>
<br>




<b><u>Fourier Transform</u></b><br>
The function is, 
$$
F(\omega)=exp(i a \omega) exp\left[(i b -c)\omega^2\right]
$$
Then the transform is, 
$$
f(t)=\int d\omega\ F(\omega)e^{-i\omega t}
=\int d\omega\ 
exp(i a \omega) exp\left[(i b -c)\omega^2\right]
e^{-i\omega t}
\\
=\int d\omega\ 
exp\left[i (a-t) \omega \right] exp\left[(i b -c)\omega^2\right]
$$
Because,
$$
i(a-t)\omega + (ib-c)\omega^2
=(ib-c)\left[\omega^2 + \frac{i(a-t)}{ib-c}\omega\right]
\\
=(ib-c)\left[
\omega^2 + \frac{i(a-t)}{ib-c}\omega
-\frac{(a-t)^2}{4(ib-c)^2}
+\frac{(a-t)^2}{4(ib-c)^2}
\right]
\\
=(ib-c)\left[
\omega + \frac{i(a-t)}{2(ib-c)}
\right]^2
+\frac{(a-t)^2}{4(ib-c)}
\\
=(ib-c)\left[
\omega + \frac{i(a-t)}{2(ib-c)}
\right]^2
-(ib+c)\frac{(a-t)^2}{4(b^2+c^2)}
$$
Then the transformed function is,
$$
f(t)=
exp\left[-(ib+c)\frac{(a-t)^2}{4(b^2+c^2)}
\right]
\int d\omega\ 
exp\left[(ib-c)\left[
\omega + \frac{i(a-t)}{2(ib-c)}
\right]^2 \right] 
\\
=\sqrt{\frac{2\pi}{ib-c}}
exp
\left[-(ib+c)\frac{(a-t)^2}{4(b^2+c^2)}
\right]
$$



<br>
<b><u>Pulse duration</u></b><br>
The pulse duration can be directly got from the above formula,
$$
\delta t=2\sqrt{\frac{b^2+c^2}{c}}
$$
Since we have,
$$
b=\frac{D}{2}\frac{\partial^2 k}{\partial \omega^2}
,\ 
c=\frac{1}{\delta \omega^2}
$$
Then,
$$
\delta t
=2\sqrt{\frac{b^2+c^2}{c}}
=2\sqrt{
\left(\frac{D}{2}\frac{\partial^2 k}{\partial \omega^2}\right)^2\delta \omega^2
+\frac{1}{\delta \omega^2}}
\\
=\sqrt{
\left(D \frac{\partial^2 k}{\partial \omega^2} \delta \omega \right)^2
+\frac{4}{\delta \omega^2}}
$$
If the pulse with no chirp had a pulse duration \(\delta \tau\), then, 
$$
\delta \tau=\frac{2}{\delta \omega}
$$
$$
\delta t
=\sqrt{
\left[D \frac{\partial^2 k}{\partial \omega^2} \left(\frac{2}{\delta \tau}\right) \right]^2
+\delta \tau^2}
$$

in which \(\delta\tau\) and \(\delta\omega\) are defined as,
$$
S(\omega)=A exp\left[-\frac{(\omega-\omega_0)^2}{\delta \omega^2}\right]
$$$$
f(t)=B
exp
\left[-\frac{(t-t_0)^2}{\delta\tau}
\right]
$$
And we have,
$$
\lambda=\frac{2\pi c}{\omega}, 
\delta\lambda=-\frac{\lambda}{\omega}\delta\omega
$$

<!--
+[H函数](,公式推导)

公式验证(M函数):...
-->

## end
#15, 17:
文档\S应用\几何样本库.ftxt
## end
#17, 131:
+[返回目录](,场景)

透镜:...
光线:...
坐标系:...
+[创建坐标系](,坐标系)
出射光谱:...
+[创建函数曲线](,出射光谱)

坐标系1:...
+[创建坐标系](,坐标系1)
入射光谱:...
+[创建函数曲线](,入射光谱)



## end
#19, 139:
+[返回目录](,坐标系)
+[设置结构](,坐标系)

起点::-200,100
尺寸::100,100
类型::矩形

原点::0,0.5
x坐标::w
y坐标::I

可选::YES

画图:...
选中区域:...
HTML:...

+[创建输入](可选,画图)



## end
#30, 1487:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


def drawArrow(qp,pt1,pt2):
    angle=30
    l=30
    D=0
    d=10
    
    lineWidth=2
    
    edgeColor=[0,0,0]
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush())
    
    r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
    if r!=0:
        theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
    dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
    dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]
    
    pt10=[0,0]
    pt20=[0,0]
    pt10[0]=pt1[0]
    pt10[1]=pt1[1]
    pt20[0]=pt2[0]
    pt20[1]=pt2[1]
    
    
    path2=QPainterPath()
    path2.moveTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
    path2.lineTo(pt20[0],pt20[1])
    path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])
    
    qp.drawPath(path2)
    
    
    qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])
    
    qp.setBrush(QBrush())
    qp.setPen(QPen())


pt=起点
size=尺寸
orig=[pt[0]+size[0]*原点[0],pt[1]+size[1]*原点[1]]

qp.setFont(QFont("Decorative",15))

pt1=[pt[0],orig[1]]
pt2=[pt[0]+size[0],orig[1]]
qp.drawText(pt2[0],pt2[1],100,30,Qt.AlignLeft|Qt.AlignVCenter,x坐标)
drawArrow(qp,pt1,pt2)

pt1=[orig[0],pt[1]]
pt2=[orig[0],pt[1]+size[1]]
qp.drawText(pt2[0],pt2[1]-30,100,30,Qt.AlignLeft|Qt.AlignVCenter,y坐标)
drawArrow(qp,pt1,pt2)


qp.drawText(orig[0],orig[1],30,30,Qt.AlignHCenter|Qt.AlignVCenter,'O')
qp.setFont(QFont())


## end
#36, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#37, 1487:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


def drawArrow(qp,pt1,pt2):
    angle=30
    l=30
    D=0
    d=10
    
    lineWidth=2
    
    edgeColor=[0,0,0]
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush())
    
    r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
    if r!=0:
        theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
    dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
    dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]
    
    pt10=[0,0]
    pt20=[0,0]
    pt10[0]=pt1[0]
    pt10[1]=pt1[1]
    pt20[0]=pt2[0]
    pt20[1]=pt2[1]
    
    
    path2=QPainterPath()
    path2.moveTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
    path2.lineTo(pt20[0],pt20[1])
    path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])
    
    qp.drawPath(path2)
    
    
    qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])
    
    qp.setBrush(QBrush())
    qp.setPen(QPen())


pt=起点
size=尺寸
orig=[pt[0]+size[0]*原点[0],pt[1]+size[1]*原点[1]]

qp.setFont(QFont("Decorative",15))

pt1=[pt[0],orig[1]]
pt2=[pt[0]+size[0],orig[1]]
qp.drawText(pt2[0],pt2[1],100,30,Qt.AlignLeft|Qt.AlignVCenter,x坐标)
drawArrow(qp,pt1,pt2)

pt1=[orig[0],pt[1]]
pt2=[orig[0],pt[1]+size[1]]
qp.drawText(pt2[0],pt2[1]-30,100,30,Qt.AlignLeft|Qt.AlignVCenter,y坐标)
drawArrow(qp,pt1,pt2)


qp.drawText(orig[0],orig[1],30,30,Qt.AlignHCenter|Qt.AlignVCenter,'O')
qp.setFont(QFont())


## end
#38, 263:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


if 可选=='NO':
    state=False



## end
#41, 14:
+[返回目录]
+[内容]

## end
#42, 655:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#45, 14:
+[返回目录]
+[内容]

## end
#46, 137:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100
坐标范围::-1,1-1,1
x坐标::x
y坐标::y
可选::NO

## end
#53, 39:
11.572112163170416, -17.481784428982564
## end
#54, 39:
118.85577567365917, -137.03643114203487
## end
#55, 2:
矩形
## end
#56, 5:
0,0.5
## end
#57, 1:
w
## end
#58, 1:
I
## end
#59, 2:
NO
## end
#60, 1:
1
## end
#62, 8:
958, 476
## end
#64, 11:
-100.0, 0.0
## end
#68, 148:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...



## end
#81, 855:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#87, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#88, 855:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#89, 231:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


## end
#92, 14:
+[返回目录]
+[内容]

## end
#93, 655:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#96, 14:
+[返回目录]
+[内容]

## end
#97, 101:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100

## end
#106, 14:
-160.0, -135.0
## end
#107, 12:
162.0, 288.0
## end
#108, 2:
矩形
## end
#110, 2:
10
## end
#111, 8:
DashLine
## end
#112, 1:
2
## end
#113, 11:
255,255,255
## end
#114, 5:
0,0,0
## end
#116, 105:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...

## end
#126, 1161:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

angle=30
l=30
D=0
d=10


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush())

r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
if r!=0:
    theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]

pt10=[0,0]
pt20=[0,0]
pt10[0]=pt1[0]
pt10[1]=pt1[1]
pt20[0]=pt2[0]
pt20[1]=pt2[1]

#path1=QPainterPath()
#path1.moveTo(pt10[0],pt10[1])
#path1.moveTo(pt10[0]+dp21[0],pt10[1]+dp21[1])
#path1.lineTo(pt10[0],pt10[1])
#path1.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1])

path2=QPainterPath()
#path2.moveTo(pt20[0],pt20[1])
path2.moveTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
path2.lineTo(pt20[0],pt20[1])
path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])

#qp.drawPath(path1)
qp.drawPath(path2)


qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])

qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#132, 1161:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

angle=30
l=30
D=0
d=10


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush())

r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
if r!=0:
    theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]

pt10=[0,0]
pt20=[0,0]
pt10[0]=pt1[0]
pt10[1]=pt1[1]
pt20[0]=pt2[0]
pt20[1]=pt2[1]

#path1=QPainterPath()
#path1.moveTo(pt10[0],pt10[1])
#path1.moveTo(pt10[0]+dp21[0],pt10[1]+dp21[1])
#path1.lineTo(pt10[0],pt10[1])
#path1.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1])

path2=QPainterPath()
#path2.moveTo(pt20[0],pt20[1])
path2.moveTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
path2.lineTo(pt20[0],pt20[1])
path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])

#qp.drawPath(path1)
qp.drawPath(path2)


qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])

qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#133, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#134, 2:
直线
## end
#135, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#139, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#142, 14:
+[返回目录]
+[内容]

## end
#143, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#145, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#146, 950:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var pt1=[%起点];
var pt2=[%终点];


//arrows
var angle=30/180*Math.PI;
var l=20;
var d=10;

r=Math.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2);
if (r!=0) {
    theta=Math.sign(pt1[1]-pt2[1])*Math.acos((pt2[0]-pt1[0])/r);
}

dp21=[l*Math.cos(theta-angle/2),-l*Math.sin(theta-angle/2)];
dp22=[l*Math.cos(theta+angle/2),-l*Math.sin(theta+angle/2)];

pt10=[0,0];
pt20=[0,0];
pt10[0]=pt1[0];
pt10[1]=pt1[1];
pt20[0]=pt2[0];
pt20[1]=pt2[1];


ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
ctx.fillStyle='rgb(0,0,0,0)';


ctx.beginPath();


//ctx.moveTo(pt10[0]+dp21[0],pt10[1]+dp21[1]);
//ctx.lineTo(pt10[0],pt10[1]);
//ctx.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1]);

ctx.moveTo(pt20[0]-dp21[0],pt20[1]-dp21[1]);
ctx.lineTo(pt20[0],pt20[1]);
ctx.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1]);


ctx.moveTo(pt10[0],pt10[1]);
ctx.lineTo(pt20[0],pt20[1]);

ctx.stroke()
ctx.fill()



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#148, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#154, 11:
-458.0, 2.0
## end
#155, 10:
324.0, 2.0
## end
#156, 5:
0,0,0
## end
#157, 8:
DashLine
## end
#158, 1:
2
## end
#160, 207:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形

中心位置::0,0
分辨率::0.05
函数::y=3*np.exp(-x**2)*np.cos(x*4)
可选::NO

面颜色::None
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

+[创建输入](可选,画图)



## end
#175, 921:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸

lineWidth=线粗细[0]
lineType=线型

dx=分辨率[0]
orig=中心位置

Nx=np.abs(size[0])
x=np.linspace(-Nx*dx/2,Nx*dx/2,Nx)+orig[0]
y=0*x
exec(函数)

x_p=x/dx+pt[0]+size[0]/2
y_p=-y/dx+pt[1]+size[1]/2+orig[1]


path=QPainterPath()
move=True
for i in range(len(x_p)):
    if (y_p[i]-pt[1])*(y_p[i]-pt[1]-size[1])>0:
        if 面颜色=='None':
            move=True
        continue
    if move:
        path.moveTo(x_p[i],y_p[i])
        move=False
    else:
        path.lineTo(x_p[i],y_p[i])

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawPath(path)

qp.setBrush(QBrush())
qp.setPen(QPen())







## end
#181, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#182, 921:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸

lineWidth=线粗细[0]
lineType=线型

dx=分辨率[0]
orig=中心位置

Nx=np.abs(size[0])
x=np.linspace(-Nx*dx/2,Nx*dx/2,Nx)+orig[0]
y=0*x
exec(函数)

x_p=x/dx+pt[0]+size[0]/2
y_p=-y/dx+pt[1]+size[1]/2+orig[1]


path=QPainterPath()
move=True
for i in range(len(x_p)):
    if (y_p[i]-pt[1])*(y_p[i]-pt[1]-size[1])>0:
        if 面颜色=='None':
            move=True
        continue
    if move:
        path.moveTo(x_p[i],y_p[i])
        move=False
    else:
        path.lineTo(x_p[i],y_p[i])

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawPath(path)

qp.setBrush(QBrush())
qp.setPen(QPen())







## end
#183, 261:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False

if 可选=='NO':
    state=False


## end
#186, 14:
+[返回目录]
+[内容]

## end
#187, 655:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#190, 14:
+[返回目录]
+[内容]

## end
#191, 143:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100
中心位置::0,-10
分辨率::0.1
函数::y=x**2/10
可选::NO

## end
#202, 39:
125.90282048339847, -152.74642211914062
## end
#203, 39:
-121.80564096679694, 133.49284423828126
## end
#204, 2:
矩形
## end
#205, 8:
DashLine
## end
#206, 1:
2
## end
#207, 4:
None
## end
#208, 5:
0,0,0
## end
#209, 3:
0,0
## end
#210, 4:
0.05
## end
#211, 29:
y=3*np.exp(-x**2)*np.cos(x*4)
## end
#212, 2:
NO
## end
#214, 138:
+[返回目录](,坐标系)
+[设置结构](,坐标系)

起点::-200,100
尺寸::100,100
类型::矩形

原点::0,0.5
x坐标::w
y坐标::I

可选::NO

画图:...
选中区域:...
HTML:...

+[创建输入](可选,画图)



## end
#225, 1487:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


def drawArrow(qp,pt1,pt2):
    angle=30
    l=30
    D=0
    d=10
    
    lineWidth=2
    
    edgeColor=[0,0,0]
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush())
    
    r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
    if r!=0:
        theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
    dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
    dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]
    
    pt10=[0,0]
    pt20=[0,0]
    pt10[0]=pt1[0]
    pt10[1]=pt1[1]
    pt20[0]=pt2[0]
    pt20[1]=pt2[1]
    
    
    path2=QPainterPath()
    path2.moveTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
    path2.lineTo(pt20[0],pt20[1])
    path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])
    
    qp.drawPath(path2)
    
    
    qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])
    
    qp.setBrush(QBrush())
    qp.setPen(QPen())


pt=起点
size=尺寸
orig=[pt[0]+size[0]*原点[0],pt[1]+size[1]*原点[1]]

qp.setFont(QFont("Decorative",15))

pt1=[pt[0],orig[1]]
pt2=[pt[0]+size[0],orig[1]]
qp.drawText(pt2[0],pt2[1],100,30,Qt.AlignLeft|Qt.AlignVCenter,x坐标)
drawArrow(qp,pt1,pt2)

pt1=[orig[0],pt[1]]
pt2=[orig[0],pt[1]+size[1]]
qp.drawText(pt2[0],pt2[1]-30,100,30,Qt.AlignLeft|Qt.AlignVCenter,y坐标)
drawArrow(qp,pt1,pt2)


qp.drawText(orig[0],orig[1],30,30,Qt.AlignHCenter|Qt.AlignVCenter,'O')
qp.setFont(QFont())


## end
#231, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#232, 1487:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


def drawArrow(qp,pt1,pt2):
    angle=30
    l=30
    D=0
    d=10
    
    lineWidth=2
    
    edgeColor=[0,0,0]
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush())
    
    r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
    if r!=0:
        theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
    dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
    dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]
    
    pt10=[0,0]
    pt20=[0,0]
    pt10[0]=pt1[0]
    pt10[1]=pt1[1]
    pt20[0]=pt2[0]
    pt20[1]=pt2[1]
    
    
    path2=QPainterPath()
    path2.moveTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
    path2.lineTo(pt20[0],pt20[1])
    path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])
    
    qp.drawPath(path2)
    
    
    qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])
    
    qp.setBrush(QBrush())
    qp.setPen(QPen())


pt=起点
size=尺寸
orig=[pt[0]+size[0]*原点[0],pt[1]+size[1]*原点[1]]

qp.setFont(QFont("Decorative",15))

pt1=[pt[0],orig[1]]
pt2=[pt[0]+size[0],orig[1]]
qp.drawText(pt2[0],pt2[1],100,30,Qt.AlignLeft|Qt.AlignVCenter,x坐标)
drawArrow(qp,pt1,pt2)

pt1=[orig[0],pt[1]]
pt2=[orig[0],pt[1]+size[1]]
qp.drawText(pt2[0],pt2[1]-30,100,30,Qt.AlignLeft|Qt.AlignVCenter,y坐标)
drawArrow(qp,pt1,pt2)


qp.drawText(orig[0],orig[1],30,30,Qt.AlignHCenter|Qt.AlignVCenter,'O')
qp.setFont(QFont())


## end
#233, 263:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


if 可选=='NO':
    state=False



## end
#236, 14:
+[返回目录]
+[内容]

## end
#237, 655:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#240, 14:
+[返回目录]
+[内容]

## end
#241, 137:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100
坐标范围::-1,1-1,1
x坐标::x
y坐标::y
可选::NO

## end
#248, 24:
-289.53125, -16.58984375
## end
#249, 22:
113.0625, -134.8203125
## end
#250, 2:
矩形
## end
#251, 5:
0,0.5
## end
#252, 1:
w
## end
#253, 1:
I
## end
#254, 2:
NO
## end
#256, 197:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形


中心位置::0,0
分辨率::0.05
函数::y=3*np.exp(-x**2)
可选::YES

面颜色::None
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

+[创建输入](可选,画图)



## end
#271, 921:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸

lineWidth=线粗细[0]
lineType=线型

dx=分辨率[0]
orig=中心位置

Nx=np.abs(size[0])
x=np.linspace(-Nx*dx/2,Nx*dx/2,Nx)+orig[0]
y=0*x
exec(函数)

x_p=x/dx+pt[0]+size[0]/2
y_p=-y/dx+pt[1]+size[1]/2+orig[1]


path=QPainterPath()
move=True
for i in range(len(x_p)):
    if (y_p[i]-pt[1])*(y_p[i]-pt[1]-size[1])>0:
        if 面颜色=='None':
            move=True
        continue
    if move:
        path.moveTo(x_p[i],y_p[i])
        move=False
    else:
        path.lineTo(x_p[i],y_p[i])

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawPath(path)

qp.setBrush(QBrush())
qp.setPen(QPen())







## end
#277, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#278, 921:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸

lineWidth=线粗细[0]
lineType=线型

dx=分辨率[0]
orig=中心位置

Nx=np.abs(size[0])
x=np.linspace(-Nx*dx/2,Nx*dx/2,Nx)+orig[0]
y=0*x
exec(函数)

x_p=x/dx+pt[0]+size[0]/2
y_p=-y/dx+pt[1]+size[1]/2+orig[1]


path=QPainterPath()
move=True
for i in range(len(x_p)):
    if (y_p[i]-pt[1])*(y_p[i]-pt[1]-size[1])>0:
        if 面颜色=='None':
            move=True
        continue
    if move:
        path.moveTo(x_p[i],y_p[i])
        move=False
    else:
        path.lineTo(x_p[i],y_p[i])

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawPath(path)

qp.setBrush(QBrush())
qp.setPen(QPen())







## end
#279, 261:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False

if 可选=='NO':
    state=False


## end
#282, 14:
+[返回目录]
+[内容]

## end
#283, 655:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#286, 14:
+[返回目录]
+[内容]

## end
#287, 143:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100
中心位置::0,-10
分辨率::0.1
函数::y=x**2/10
可选::NO

## end
#298, 39:
-184.1943590332031, -169.97137695312506
## end
#299, 38:
-107.61128193359377, 171.9427539062501
## end
#300, 2:
矩形
## end
#301, 8:
DashLine
## end
#302, 1:
2
## end
#303, 4:
None
## end
#304, 5:
0,0,0
## end
#305, 3:
0,0
## end
#306, 4:
0.05
## end
#307, 17:
y=3*np.exp(-x**2)
## end
#308, 3:
YES
## end
#309, 148:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...



## end
#323, 855:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#329, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#330, 855:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#331, 231:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


## end
#334, 14:
+[返回目录]
+[内容]

## end
#335, 655:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#338, 14:
+[返回目录]
+[内容]

## end
#339, 101:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100

## end
#348, 13:
-113.5, 156.5
## end
#349, 10:
57.0, 55.0
## end
#350, 2:
矩形
## end
#351, 1:
D
## end
#352, 2:
20
## end
#353, 8:
DashLine
## end
#354, 1:
2
## end
#355, 4:
None
## end
#356, 4:
None
## end
#357, 4:
1533
## end
#360, 66:
https://en.wikipedia.org/wiki/Group_velocity_dispersion#Derivation
## end
#362, 16:
文档\物理问题\群速度.ftxt
## end
#364, 28:
https://refractiveindex.info
## end
#366, 1058:
<!--
+[返回目录](,TOPAS系统)
lens厚度::https://mail.google.com/mail/u/0/#inbox/FMfcgxwKjBPvFRQjrHNNbrwwfVCMdjWN
+[打开](,lens厚度)

记住TOPAS系统(节点)

+[H函数](,TOPAS系统)
-->
We need to calculate GVD for 
<a href="http://toolbox.lightcon.com/tools/gratingpair/">grating pair</a>, 
fused silica, 
air and 
BK-7.
<br>
The GDD for grating pair is, 
$$
GDD(\lambda)=-\frac{\lambda^3 D}{\pi c^2 d^2}
\left[
1-\left(
\frac{\lambda}{d}-sin\theta
\right)^2
\right]^{-\frac{3}{2}}
$$
The GVD for different materials are,
$$
BK7,\ \lambda=706.5 nm,\ n=1.5129,\ GVD=54.281 fs^2/mm
\\
Fused\ silica,\ \lambda=706.5 nm,\ n=1.4551,\ GVD=44.308 fs^2/mm
\\
Air,\ \lambda=706.5 nm,\ n=1.00027575,\ GVD=0.025003 fs^2/mm

$$

The pulse duration is,
$$
\delta t
=\sqrt{
\left[D\cdot GVD\cdot \left(\frac{2}{\delta \tau}\right) \right]^2
+\delta \tau^2}
$$
Or,
$$
\delta t
=\sqrt{
\left[GDD\cdot \left(\frac{2}{\delta \tau}\right) \right]^2
+\delta \tau^2}
$$

<!--
计算TOPAS波包展宽(M函数):...
计算光强(M函数):...
+[H函数](,TOPAS系统)

测量角度(画板):...
测量角度->画板(测量角度,)->+[del](,画板)
+[画板](+测量,测量角度)

光斑形状与光强(M函数):...
-->
## end
#369, 1859:
<!--
+[返回目录](,光栅色散)
光栅对:...
+画板(光栅对,)
画板(光栅对,)->+[del](,画板)
+[画板](+光栅画板,光栅对)
+[H函数](,光栅色散)
-->
%光栅对
<br>
<b><u>Grating GVD</u></b><br>
Consider a grating compressor with two gratings. The grating constant for both of them is \(d\). The distance between them is \(D\). Assuming \(\theta\) is the angle between the incoming beam and the normal line of the grating and \(\beta\) is the diffraction angle.<br>
Then, 
$$
sin(\beta)+sin(\theta)=\frac{\lambda}{d}
$$
The total length of the light path is,
$$
l=l_1-l_2
\\
l_1=D/cos(\beta)
\\
l_2=D\ tan(\beta) sin(\theta)
$$
Then, 
$$
l
=D\left(\frac{1-sin(\beta)sin(\theta)}{cos(\beta)}\right)
=D\left(\frac{1-(\frac{\lambda}{d}-sin(\theta))sin(\theta)}{cos(\beta)}\right)
\\
=D\left(\frac{1+sin(\theta)^2-\frac{\lambda}{d}sin(\theta)}{cos(\beta)}\right)
$$
There is a phase correction term in Treacy's paper. I still don't understand that term. <br>
We can calculate the \(d\beta/d\lambda\) and \(dl/d\lambda\),
$$
cos(\beta)d\beta=\frac{d\lambda}{d}
\\
\Rightarrow
\frac{d\beta}{d\lambda}=\frac{1}{cos(\beta)d}
$$$$
\frac{dl}{d\lambda}
=D\left(
-\frac{sin(\theta)}{cos(\beta)d}
+\frac{1+sin(\theta)^2-\frac{\lambda}{d}sin(\theta)}{cos(\beta)^2}sin(\beta)
\frac{d\beta}{d\lambda}
\right)
\\
=D\left(
-1
+\frac{1+sin(\theta)^2-\frac{\lambda}{d}sin(\theta)}{cos(\beta)^2}
\right)\frac{sin(\theta)}{cos(\beta)d}
\\
=\left(
\frac{2sin(\theta)-\frac{\lambda}{d}}{cos(\beta)}
\right)\frac{sin(\theta)^2D}{cos(\beta)^2d}
$$
<br>
There are some problems.... <br>
I'm using the formula from Optics Toolbox directly then, 
$$
GDD(\lambda)=-\frac{\lambda^3 D}{\pi c^2 d^2}
\left[
1-\left(
\frac{\lambda}{d}-sin\theta
\right)^2
\right]^{-\frac{3}{2}}
$$

<!--
+[H函数](,光栅色散)

参考::file:///C:/Users/cheng/Desktop/paper/gratingTreacy(69).pdf#page=2
+[打开网页](,参考)
参考2::http://toolbox.lightcon.com/tools/gratingpair
+[打开网页](,参考2)
-->
## end
#372, 186:
+[返回目录](,光栅对)


光栅1:...
光栅2:...
入射光线:
内部光线1:
出射光线1:
内部光线2:
出射光线2:
法线1:...
theta:...
beta:...
水平距离:...
标记水平距离:...

间距:
+[创建长度](,标记水平距离)
+beta(内部光线1,法线1)->+[创建角度](,+beta)
+[创建直线](,水平距离)



## end
#374, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#388, 804:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


x0=pt[0]
y0=pt[1]
M=qp.transform()
M.translate(x0,y0)
M.rotate(-angle+90)
M.translate(-x0,-y0)

M0=qp.transform()
qp.setTransform(M)

qp.drawRect(x0-r,y0,2*r,d)

qp.setTransform(M0)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(x0-area,y0+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#394, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#395, 804:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


x0=pt[0]
y0=pt[1]
M=qp.transform()
M.translate(x0,y0)
M.rotate(-angle+90)
M.translate(-x0,-y0)

M0=qp.transform()
qp.setTransform(M)

qp.drawRect(x0-r,y0,2*r,d)

qp.setTransform(M0)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(x0-area,y0+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#396, 2:
圆形
## end
#397, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#400, 14:
+[返回目录]
+[内容]

## end
#401, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#404, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#406, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#416, 2:
10
## end
#417, 11:
17.0, -40.0
## end
#418, 18:
48.373546489791295
## end
#419, 3:
120
## end
#420, 11:
255,255,255
## end
#421, 5:
0,0,0
## end
#422, 8:
DashLine
## end
#423, 1:
2
## end
#424, 9:
Grating A
## end
#425, 18:
0.8996976313569565
## end
#427, 8:
460, 307
## end
#429, 11:
0.0, -100.0
## end
#433, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#447, 804:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


x0=pt[0]
y0=pt[1]
M=qp.transform()
M.translate(x0,y0)
M.rotate(-angle+90)
M.translate(-x0,-y0)

M0=qp.transform()
qp.setTransform(M)

qp.drawRect(x0-r,y0,2*r,d)

qp.setTransform(M0)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(x0-area,y0+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#453, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#454, 804:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


x0=pt[0]
y0=pt[1]
M=qp.transform()
M.translate(x0,y0)
M.rotate(-angle+90)
M.translate(-x0,-y0)

M0=qp.transform()
qp.setTransform(M)

qp.drawRect(x0-r,y0,2*r,d)

qp.setTransform(M0)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(x0-area,y0+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#455, 2:
圆形
## end
#456, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#459, 14:
+[返回目录]
+[内容]

## end
#460, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#463, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#465, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#475, 2:
10
## end
#476, 13:
-13.0, -140.0
## end
#477, 18:
48.373546489791295
## end
#478, 3:
-60
## end
#479, 11:
255,255,255
## end
#480, 5:
0,0,0
## end
#481, 8:
DashLine
## end
#482, 1:
2
## end
#483, 9:
Grating B
## end
#485, 144:
+[返回目录](,直线)
+[设置结构](,入射光线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#495, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#501, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#502, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#503, 2:
直线
## end
#504, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#508, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#511, 14:
+[返回目录]
+[内容]

## end
#512, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#514, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#515, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#517, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#523, 38:
-463.9490300000001, -34.05676999999999
## end
#524, 10:
9.5, -34.5
## end
#525, 5:
0,0,0
## end
#526, 8:
DashLine
## end
#527, 1:
1
## end
#529, 129:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#539, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#545, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#546, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#547, 2:
直线
## end
#548, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#552, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#555, 14:
+[返回目录]
+[内容]

## end
#556, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#558, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#559, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#561, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#567, 39:
-29.06394388401367, -131.12721744944702
## end
#568, 37:
7.351082000000034, -34.05676999999999
## end
#569, 7:
255,0,0
## end
#570, 8:
DashLine
## end
#571, 1:
1
## end
#573, 129:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#583, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#589, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#590, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#591, 2:
直线
## end
#592, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#596, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#599, 14:
+[返回目录]
+[内容]

## end
#600, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#602, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#603, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#605, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#611, 13:
240.0, -131.0
## end
#612, 13:
-27.0, -131.0
## end
#613, 7:
255,0,0
## end
#614, 8:
DashLine
## end
#615, 1:
1
## end
#617, 129:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#619, 129:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#629, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#635, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#636, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#637, 2:
直线
## end
#638, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#642, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#645, 14:
+[返回目录]
+[内容]

## end
#646, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#648, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#649, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#651, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#657, 10:
7.0, -34.0
## end
#658, 12:
-1.0, -147.0
## end
#659, 7:
0,0,255
## end
#660, 8:
DashLine
## end
#661, 1:
1
## end
#671, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#677, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#678, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#679, 2:
直线
## end
#680, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#684, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#687, 14:
+[返回目录]
+[内容]

## end
#688, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#690, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#691, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#693, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#699, 13:
244.0, -148.0
## end
#700, 6:
0,-148
## end
#701, 7:
0,0,255
## end
#702, 8:
DashLine
## end
#703, 1:
1
## end
#705, 129:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#715, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#721, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#722, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#723, 2:
直线
## end
#724, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#728, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#731, 14:
+[返回目录]
+[内容]

## end
#732, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#734, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#735, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#737, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#743, 39:
-44.73013599999998, -122.80741700000003
## end
#744, 38:
5.482750000000095, -36.123484999999995
## end
#745, 5:
0,0,0
## end
#746, 8:
DashLine
## end
#747, 1:
1
## end
#749, 83:
+[返回目录](,角度)

数值::
类型::角度

标记::theta

画图:...
P代码:...
+[P函数](,P代码)

+[创建输入](标记,画图)


## end
#765, 5:
theta
## end
#767, 18:
59.121995914375375
## end
#769, 38:
5.482750000000095, -36.123484999999995
## end
#771, 39:
-47.06308999999996, -123.81125000000003
## end
#773, 10:
9.5, -34.5
## end
#775, 38:
-463.9490300000001, -34.05676999999999
## end
#781, 50:
+[返回目录]
+[内容]
pt11::
pt12::
pt21::
pt22::
angle::

## end
#783, 22:
+[返回目录]
+[内容]
标记::%数值

## end
#786, 867:
"""
+[返回目录](,画图)

输出:...
+[设置结构](,输出)

"""

r=20

Dx1=pt11[0]-pt12[0]
Dy1=pt11[1]-pt12[1]

Dx2=pt21[0]-pt22[0]
Dy2=pt21[1]-pt22[1]

dangle=angle[0]

D1=pt11[0]*Dy1-pt11[1]*Dx1
D2=pt21[0]*Dy2-pt21[1]*Dx2

L=Dy1*Dx2-Dy2*Dx1
if L==0:
    pt0=None
else:
    pt0=[(D1*Dx2-D2*Dx1)/L, (D1*Dy2-D2*Dy1)/L]

sign=np.sign(Dy1)
theta1=-sign*np.arccos(Dx1/np.sqrt(Dx1**2+Dy1**2))
angle1=np.rad2deg(theta1)


qp.setPen(QPen(QColor(0,0,0)))
qp.setBrush(QBrush(QColor(255,255,255)))

qp.drawArc(pt0[0]-r,pt0[1]-r,2*r,2*r,angle1*16,-dangle*16)

qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",10))

dx=r*np.cos(theta1-np.deg2rad(dangle)/2)
dy=-r*np.sin(theta1-np.deg2rad(dangle)/2)

if 标记=='%数值':
    qp.drawText(pt0[0]+dx,pt0[1]+dy,"%.2f"%(dangle))
else:
    qp.drawText(pt0[0]+dx,pt0[1]+dy,str(标记))

qp.drawPoint(pt0[0]+dx,pt0[1]+dy)

qp.setFont(QFont())




## end
#787, 14:
+[返回目录]
+[内容]

## end
#790, 612:
"""
+[返回目录](,P代码)

+[P函数](,P代码)

输出:...
+[设置结构](,输出)

"""

Dx1=pt11[0]-pt12[0]
Dy1=pt11[1]-pt12[1]

Dx2=pt21[0]-pt22[0]
Dy2=pt21[1]-pt22[1]

D1=pt11[0]*Dy1-pt11[1]*Dx1
D2=pt21[0]*Dy2-pt21[1]*Dx2

L=Dy1*Dx2-Dy2*Dx1
if L==0:
    pt0="None"
else:
    pt0=[(D1*Dx2-D2*Dx1)/L, (D1*Dy2-D2*Dy1)/L]
    if np.abs(pt0[0]-pt11[0])>np.abs(pt0[0]-pt12[0]):
        Dx1=-Dx1
        Dy1=-Dy1
    
    if np.abs(pt0[0]-pt21[0])>np.abs(pt0[0]-pt22[0]):
        Dx2=-Dx2
        Dy2=-Dy2


sign=np.sign(Dx1*Dy2-Dx2*Dy1)
theta=np.arccos((Dx1*Dx2+Dy1*Dy2)/np.sqrt((Dx1**2+Dy1**2)*(Dx2**2+Dy2**2)))
angle=np.rad2deg(theta)*sign




## end
#791, 2:
角度
## end
#792, 18:
59.121995914375375
## end
#794, 82:
+[返回目录](,角度)

数值::
类型::角度

标记::beta

画图:...
P代码:...
+[P函数](,P代码)

+[创建输入](标记,画图)


## end
#810, 4:
beta
## end
#812, 17:
-9.72894161148977
## end
#814, 38:
5.482750000000095, -36.123484999999995
## end
#816, 39:
-44.73013599999998, -122.80741700000003
## end
#818, 37:
7.351082000000034, -34.05676999999999
## end
#820, 40:
-29.318346999999974, -132.90479600000003
## end
#826, 50:
+[返回目录]
+[内容]
pt11::
pt12::
pt21::
pt22::
angle::

## end
#828, 22:
+[返回目录]
+[内容]
标记::%数值

## end
#831, 867:
"""
+[返回目录](,画图)

输出:...
+[设置结构](,输出)

"""

r=20

Dx1=pt11[0]-pt12[0]
Dy1=pt11[1]-pt12[1]

Dx2=pt21[0]-pt22[0]
Dy2=pt21[1]-pt22[1]

dangle=angle[0]

D1=pt11[0]*Dy1-pt11[1]*Dx1
D2=pt21[0]*Dy2-pt21[1]*Dx2

L=Dy1*Dx2-Dy2*Dx1
if L==0:
    pt0=None
else:
    pt0=[(D1*Dx2-D2*Dx1)/L, (D1*Dy2-D2*Dy1)/L]

sign=np.sign(Dy1)
theta1=-sign*np.arccos(Dx1/np.sqrt(Dx1**2+Dy1**2))
angle1=np.rad2deg(theta1)


qp.setPen(QPen(QColor(0,0,0)))
qp.setBrush(QBrush(QColor(255,255,255)))

qp.drawArc(pt0[0]-r,pt0[1]-r,2*r,2*r,angle1*16,-dangle*16)

qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",10))

dx=r*np.cos(theta1-np.deg2rad(dangle)/2)
dy=-r*np.sin(theta1-np.deg2rad(dangle)/2)

if 标记=='%数值':
    qp.drawText(pt0[0]+dx,pt0[1]+dy,"%.2f"%(dangle))
else:
    qp.drawText(pt0[0]+dx,pt0[1]+dy,str(标记))

qp.drawPoint(pt0[0]+dx,pt0[1]+dy)

qp.setFont(QFont())




## end
#832, 14:
+[返回目录]
+[内容]

## end
#835, 612:
"""
+[返回目录](,P代码)

+[P函数](,P代码)

输出:...
+[设置结构](,输出)

"""

Dx1=pt11[0]-pt12[0]
Dy1=pt11[1]-pt12[1]

Dx2=pt21[0]-pt22[0]
Dy2=pt21[1]-pt22[1]

D1=pt11[0]*Dy1-pt11[1]*Dx1
D2=pt21[0]*Dy2-pt21[1]*Dx2

L=Dy1*Dx2-Dy2*Dx1
if L==0:
    pt0="None"
else:
    pt0=[(D1*Dx2-D2*Dx1)/L, (D1*Dy2-D2*Dy1)/L]
    if np.abs(pt0[0]-pt11[0])>np.abs(pt0[0]-pt12[0]):
        Dx1=-Dx1
        Dy1=-Dy1
    
    if np.abs(pt0[0]-pt21[0])>np.abs(pt0[0]-pt22[0]):
        Dx2=-Dx2
        Dy2=-Dy2


sign=np.sign(Dx1*Dy2-Dx2*Dy1)
theta=np.arccos((Dx1*Dx2+Dy1*Dy2)/np.sqrt((Dx1**2+Dy1**2)*(Dx2**2+Dy2**2)))
angle=np.rad2deg(theta)*sign




## end
#836, 2:
角度
## end
#837, 17:
-9.72894161148977
## end
#839, 125:
+[返回目录](,长度)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1
文字::10 cm
位移距离::20

画图:...
选中区域:...
HTML:...


## end
#851, 1610:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

angle=30
l=20
D=位移距离[0]
d=10
text=文字


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush(QColor(edgeColor[0],edgeColor[1],edgeColor[2])))

r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
if r!=0:
    theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]

Dx=D*np.cos(np.deg2rad(theta-90))
Dy=-D*np.sin(np.deg2rad(theta-90))
pt10=[0,0]
pt20=[0,0]
pt10[0]=pt1[0]+Dx
pt10[1]=pt1[1]+Dy
pt20[0]=pt2[0]+Dx
pt20[1]=pt2[1]+Dy

path1=QPainterPath()
path1.moveTo(pt10[0],pt10[1])
path1.lineTo(pt10[0]+dp21[0],pt10[1]+dp21[1])
path1.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1])
path1.lineTo(pt10[0],pt10[1])

path2=QPainterPath()
path2.moveTo(pt20[0],pt20[1])
path2.lineTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])
path2.lineTo(pt20[0],pt20[1])

qp.drawPath(path1)
qp.drawPath(path2)
qp.drawLine(pt1[0],pt1[1],pt10[0],pt10[1])
qp.drawLine(pt2[0],pt2[1],pt20[0],pt20[1])


dx=d*np.cos(np.deg2rad(theta-90))
dy=-d*np.sin(np.deg2rad(theta-90))
pt0=[0,0]
pt0[0]=(pt10[0]+pt20[0])/2+dx
pt0[1]=(pt10[1]+pt20[1])/2+dy

L=300
H=100
qp.drawText(pt0[0]-L/2,pt0[1]-H/2,L,H,Qt.AlignHCenter|Qt.AlignVCenter,text)

qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])

qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#857, 1610:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

angle=30
l=20
D=位移距离[0]
d=10
text=文字


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush(QColor(edgeColor[0],edgeColor[1],edgeColor[2])))

r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
if r!=0:
    theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]

Dx=D*np.cos(np.deg2rad(theta-90))
Dy=-D*np.sin(np.deg2rad(theta-90))
pt10=[0,0]
pt20=[0,0]
pt10[0]=pt1[0]+Dx
pt10[1]=pt1[1]+Dy
pt20[0]=pt2[0]+Dx
pt20[1]=pt2[1]+Dy

path1=QPainterPath()
path1.moveTo(pt10[0],pt10[1])
path1.lineTo(pt10[0]+dp21[0],pt10[1]+dp21[1])
path1.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1])
path1.lineTo(pt10[0],pt10[1])

path2=QPainterPath()
path2.moveTo(pt20[0],pt20[1])
path2.lineTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])
path2.lineTo(pt20[0],pt20[1])

qp.drawPath(path1)
qp.drawPath(path2)
qp.drawLine(pt1[0],pt1[1],pt10[0],pt10[1])
qp.drawLine(pt2[0],pt2[1],pt20[0],pt20[1])


dx=d*np.cos(np.deg2rad(theta-90))
dy=-d*np.sin(np.deg2rad(theta-90))
pt0=[0,0]
pt0[0]=(pt10[0]+pt20[0])/2+dx
pt0[1]=(pt10[1]+pt20[1])/2+dy

L=300
H=100
qp.drawText(pt0[0]-L/2,pt0[1]-H/2,L,H,Qt.AlignHCenter|Qt.AlignVCenter,text)

qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])

qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#858, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#859, 2:
直线
## end
#860, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#864, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#867, 14:
+[返回目录]
+[内容]

## end
#868, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#870, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#871, 1487:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var pt1=[%起点];
var pt2=[%终点];


//arrows
var angle=30/180*Math.PI;
var l=20;
var D=%位移距离;
var d=10;

r=Math.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2);
if (r!=0) {
    theta=Math.sign(pt1[1]-pt2[1])*Math.acos((pt2[0]-pt1[0])/r);
}

dp21=[l*Math.cos(theta-angle/2),-l*Math.sin(theta-angle/2)];
dp22=[l*Math.cos(theta+angle/2),-l*Math.sin(theta+angle/2)];

Dx=D*Math.cos(theta-90/180*Math.PI);
Dy=-D*Math.sin(theta-90/180*Math.PI);
pt10=[0,0];
pt20=[0,0];
pt10[0]=pt1[0]+Dx;
pt10[1]=pt1[1]+Dy;
pt20[0]=pt2[0]+Dx;
pt20[1]=pt2[1]+Dy;


ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();


ctx.moveTo(pt10[0],pt10[1]);
ctx.lineTo(pt10[0]+dp21[0],pt10[1]+dp21[1]);
ctx.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1]);
ctx.lineTo(pt10[0],pt10[1]);

ctx.moveTo(pt20[0],pt20[1]);
ctx.lineTo(pt20[0]-dp21[0],pt20[1]-dp21[1]);
ctx.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1]);
ctx.lineTo(pt20[0],pt20[1]);

ctx.moveTo(pt1[0],pt1[1]);
ctx.lineTo(pt10[0],pt10[1]);
ctx.moveTo(pt2[0],pt2[1]);
ctx.lineTo(pt20[0],pt20[1]);

ctx.moveTo(pt10[0],pt10[1]);
ctx.lineTo(pt20[0],pt20[1]);

ctx.stroke()
ctx.fill()


// text
dx=d*Math.cos(theta-90/180*Math.PI)
dy=-d*Math.sin(theta-90/180*Math.PI)
pt0=[0,0]
pt0[0]=(pt10[0]+pt20[0])/2+dx
pt0[1]=(pt10[1]+pt20[1])/2+dy


ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
L=300
H=100
ctx.fillText('%文字',pt0[0],pt0[1]);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#873, 50:
线颜色::0,0,0
线型::DashLine
线粗细::2
文字::10 cm
位移距离::20

## end
#881, 37:
9.009738751968428, -152.1073579834598
## end
#882, 37:
61.88526633696034, -65.13094666611808
## end
#883, 5:
0,0,0
## end
#884, 8:
DashLine
## end
#885, 1:
1
## end
#886, 1:
D
## end
#887, 3:
-80
## end
#888, 148:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...



## end
#902, 855:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#908, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#909, 855:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#910, 231:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


## end
#913, 14:
+[返回目录]
+[内容]

## end
#914, 655:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#917, 14:
+[返回目录]
+[内容]

## end
#918, 101:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100

## end
#927, 40:
-2.9574080317545715, -127.69909289407087
## end
#928, 38:
45.501511843215226, 43.702116580501304
## end
#929, 2:
矩形
## end
#930, 3:
l_1
## end
#931, 2:
10
## end
#932, 8:
DashLine
## end
#933, 1:
2
## end
#934, 4:
None
## end
#935, 4:
None
## end
#937, 129:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#947, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#953, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#954, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#955, 2:
直线
## end
#956, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#960, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#963, 14:
+[返回目录]
+[内容]

## end
#964, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#966, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#967, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#969, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#975, 24:
0.0, -120.24319670553152
## end
#976, 38:
-46.10634974150391, -120.6033260550735
## end
#977, 5:
0,0,0
## end
#978, 8:
DashLine
## end
#979, 1:
1
## end
#981, 123:
+[返回目录](,长度)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1
文字::l_2
位移距离::20

画图:...
选中区域:...
HTML:...


## end
#993, 1610:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

angle=30
l=20
D=位移距离[0]
d=10
text=文字


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush(QColor(edgeColor[0],edgeColor[1],edgeColor[2])))

r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
if r!=0:
    theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]

Dx=D*np.cos(np.deg2rad(theta-90))
Dy=-D*np.sin(np.deg2rad(theta-90))
pt10=[0,0]
pt20=[0,0]
pt10[0]=pt1[0]+Dx
pt10[1]=pt1[1]+Dy
pt20[0]=pt2[0]+Dx
pt20[1]=pt2[1]+Dy

path1=QPainterPath()
path1.moveTo(pt10[0],pt10[1])
path1.lineTo(pt10[0]+dp21[0],pt10[1]+dp21[1])
path1.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1])
path1.lineTo(pt10[0],pt10[1])

path2=QPainterPath()
path2.moveTo(pt20[0],pt20[1])
path2.lineTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])
path2.lineTo(pt20[0],pt20[1])

qp.drawPath(path1)
qp.drawPath(path2)
qp.drawLine(pt1[0],pt1[1],pt10[0],pt10[1])
qp.drawLine(pt2[0],pt2[1],pt20[0],pt20[1])


dx=d*np.cos(np.deg2rad(theta-90))
dy=-d*np.sin(np.deg2rad(theta-90))
pt0=[0,0]
pt0[0]=(pt10[0]+pt20[0])/2+dx
pt0[1]=(pt10[1]+pt20[1])/2+dy

L=300
H=100
qp.drawText(pt0[0]-L/2,pt0[1]-H/2,L,H,Qt.AlignHCenter|Qt.AlignVCenter,text)

qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])

qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#999, 1610:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

angle=30
l=20
D=位移距离[0]
d=10
text=文字


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush(QColor(edgeColor[0],edgeColor[1],edgeColor[2])))

r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
if r!=0:
    theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]

Dx=D*np.cos(np.deg2rad(theta-90))
Dy=-D*np.sin(np.deg2rad(theta-90))
pt10=[0,0]
pt20=[0,0]
pt10[0]=pt1[0]+Dx
pt10[1]=pt1[1]+Dy
pt20[0]=pt2[0]+Dx
pt20[1]=pt2[1]+Dy

path1=QPainterPath()
path1.moveTo(pt10[0],pt10[1])
path1.lineTo(pt10[0]+dp21[0],pt10[1]+dp21[1])
path1.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1])
path1.lineTo(pt10[0],pt10[1])

path2=QPainterPath()
path2.moveTo(pt20[0],pt20[1])
path2.lineTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])
path2.lineTo(pt20[0],pt20[1])

qp.drawPath(path1)
qp.drawPath(path2)
qp.drawLine(pt1[0],pt1[1],pt10[0],pt10[1])
qp.drawLine(pt2[0],pt2[1],pt20[0],pt20[1])


dx=d*np.cos(np.deg2rad(theta-90))
dy=-d*np.sin(np.deg2rad(theta-90))
pt0=[0,0]
pt0[0]=(pt10[0]+pt20[0])/2+dx
pt0[1]=(pt10[1]+pt20[1])/2+dy

L=300
H=100
qp.drawText(pt0[0]-L/2,pt0[1]-H/2,L,H,Qt.AlignHCenter|Qt.AlignVCenter,text)

qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])

qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#1000, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1001, 2:
直线
## end
#1002, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#1006, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#1009, 14:
+[返回目录]
+[内容]

## end
#1010, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1012, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1013, 1487:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var pt1=[%起点];
var pt2=[%终点];


//arrows
var angle=30/180*Math.PI;
var l=20;
var D=%位移距离;
var d=10;

r=Math.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2);
if (r!=0) {
    theta=Math.sign(pt1[1]-pt2[1])*Math.acos((pt2[0]-pt1[0])/r);
}

dp21=[l*Math.cos(theta-angle/2),-l*Math.sin(theta-angle/2)];
dp22=[l*Math.cos(theta+angle/2),-l*Math.sin(theta+angle/2)];

Dx=D*Math.cos(theta-90/180*Math.PI);
Dy=-D*Math.sin(theta-90/180*Math.PI);
pt10=[0,0];
pt20=[0,0];
pt10[0]=pt1[0]+Dx;
pt10[1]=pt1[1]+Dy;
pt20[0]=pt2[0]+Dx;
pt20[1]=pt2[1]+Dy;


ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();


ctx.moveTo(pt10[0],pt10[1]);
ctx.lineTo(pt10[0]+dp21[0],pt10[1]+dp21[1]);
ctx.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1]);
ctx.lineTo(pt10[0],pt10[1]);

ctx.moveTo(pt20[0],pt20[1]);
ctx.lineTo(pt20[0]-dp21[0],pt20[1]-dp21[1]);
ctx.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1]);
ctx.lineTo(pt20[0],pt20[1]);

ctx.moveTo(pt1[0],pt1[1]);
ctx.lineTo(pt10[0],pt10[1]);
ctx.moveTo(pt2[0],pt2[1]);
ctx.lineTo(pt20[0],pt20[1]);

ctx.moveTo(pt10[0],pt10[1]);
ctx.lineTo(pt20[0],pt20[1]);

ctx.stroke()
ctx.fill()


// text
dx=d*Math.cos(theta-90/180*Math.PI)
dy=-d*Math.sin(theta-90/180*Math.PI)
pt0=[0,0]
pt0[0]=(pt10[0]+pt20[0])/2+dx
pt0[1]=(pt10[1]+pt20[1])/2+dy


ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
L=300
H=100
ctx.fillText('%文字',pt0[0],pt0[1]);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1015, 50:
线颜色::0,0,0
线型::DashLine
线粗细::2
文字::10 cm
位移距离::20

## end
#1023, 39:
-44.98488156784782, -122.55922224361282
## end
#1024, 40:
-1.7993952627139151, -122.55922224361282
## end
#1025, 5:
0,0,0
## end
#1026, 8:
DashLine
## end
#1027, 1:
1
## end
#1028, 3:
l_2
## end
#1029, 4:
-100
## end
#1031, 65:
file:///C:/Users/cheng/Desktop/paper/gratingTreacy(69).pdf#page=2
## end
#1033, 45:
http://toolbox.lightcon.com/tools/gratingpair
## end
#1035, 1100:
%{
+[M函数](,计算TOPAS波包展宽)
%}

physics_constant;
theta=51.82;
% theta=linspace(40,50,100);
% lm=706.5e-9;
lm=790e-9;
% lm=linspace(759e-9,760e-9,100);
D0=0.18;
dD=-0.35e-3;
% D=D1;
D=linspace(D0-dD*1.5,D0+dD/2,100);
N=1480;
dtau=23e-15;

d=1e-3/N;
GDD_grating0=-lm.^3*D0/pi/c^2/d^2.*(1-(lm/d-sind(theta)).^2).^(-3/2);
GDD_grating=-lm.^3*D/pi/c^2/d^2.*(1-(lm/d-sind(theta)).^2).^(-3/2);


GVD_air=0.025003/1e-3*1e-30;
L_air=[
76+35+12+38+52+32+17+23+6+23+10+12;
76+35+12+38+52+32+17+12+18+18+42+11+9+11+4;
76+35+51+47+42+67+71+74+9+49+3+4;
]*1e-2;

%L_air
%d_fs

GVD_fs=44.308/1e-3*1e-30;
d_fs=[
1+3/sind(45)+1.5+1+2/sind(22)+2/sind(22)+1.5+1.5;
1+1.5;
0]*1e-3;

GVD_bk=54.281/1e-3*1e-30;

GDD_m=L_air*GVD_air+d_fs*GVD_fs;
dGDD=GDD_grating-GDD_grating0;
GDD=GDD_grating-GDD_grating0+GDD_m;
dt=sqrt((GDD*2/dtau).^2+dtau^2);
mean(GDD(1,:))

plot(D/1e-3,dt/1e-15);
legend('TOPAS 1st','TOPAS 2nd','Booster')
xlabel('Grating pair distance [mm]')
ylabel('Pulse duration [fs]')

(GDD_m-GDD_m(1))./GVD_fs/1e-3

2.6*GVD_fs/GVD_air/1e3+2.85+0.6
1*GVD_fs/GVD_air/1e3+2.85+0.6
L_air(3)
%{
clf
+[M函数](,计算TOPAS波包展宽)
%}
## end
#1038, 256:
+[返回目录](,测量角度)

光栅图片:...
+[创建图片](,光栅图片)
入射光线:...
光栅方向:...
+[创建直线](,光栅方向)
+角度(入射光线,光栅方向)
角度:141.82
+[设置结构](,角度2)



TOPAS图片:...
+[创建图片](,TOPAS图片)
光线2:...
plate1方向:...
plate2方向:...
+[创建直线](,plate2方向)
+角度2(光线2,plate2方向)->+[创建角度](,+角度2)
角度1:-25.78
角度2:-155.46

## end
#1040, 224:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10
地址::C:\Users\cheng\Dropbox\iFAST_log\resources\20210414\0.jpg

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

+[创建输入](地址,画图)

## end
#1054, 841:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""


from PyQt5.QtGui import QPixmap



pt=起点
size=尺寸
size_F=字体[0]
pic_file=地址

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


#qp.drawRect(pt[0],pt[1],size[0],size[1])

pixmap=QPixmap(pic_file)
size[1]=pixmap.height()/pixmap.width()*size[0]
qp.drawPixmap(pt[0],pt[1],size[0],size[1],pixmap)
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())


尺寸=size







## end
#1059, 85:
起点::281.49455475000013, -84.73663301562507
尺寸::397.9895365000002, 241.94621603125017

## end
#1062, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#1063, 841:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""


from PyQt5.QtGui import QPixmap



pt=起点
size=尺寸
size_F=字体[0]
pic_file=地址

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


#qp.drawRect(pt[0],pt[1],size[0],size[1])

pixmap=QPixmap(pic_file)
size[1]=pixmap.height()/pixmap.width()*size[0]
qp.drawPixmap(pt[0],pt[1],size[0],size[1],pixmap)
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())


尺寸=size







## end
#1064, 231:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


## end
#1067, 14:
+[返回目录]
+[内容]

## end
#1068, 1178:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];
var img1=new Image();
var img=new Image();

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(%起点,%尺寸);
}

/*
if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}*/


/*
var img2 = new Image(),
        f = document.getElementById("uploadimage").files[0],
        url = window.URL || window.webkitURL,
        //src = url.createObjectURL(f);
        src=f;

    img2.src = src;
    img2.onload = function() {
        ctx.drawImage(img2, 0, 0);
        url.revokeObjectURL(src);
    }
*/



img1.onload=function() {
    ctx.drawImage(img1,%起点,%尺寸);
}
img1.src='https://img.moegirl.org.cn/common/thumb/8/86/Aj353_19.jpg/800px-Aj353_19.jpg'




//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1071, 14:
+[返回目录]
+[内容]

## end
#1072, 115:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100
地址::test1.png

## end
#1082, 39:
-1000.0584811498907, -585.1283684174182
## end
#1083, 35:
985.0030791757813, 738.752309381836
## end
#1084, 2:
矩形
## end
#1086, 2:
10
## end
#1087, 8:
DashLine
## end
#1088, 1:
2
## end
#1089, 11:
255,255,255
## end
#1090, 5:
0,0,0
## end
#1091, 57:
C:\Users\cheng\Dropbox\iFAST_log\resources\20210414\0.jpg
## end
#1093, 129:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#1103, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1109, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1110, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1111, 2:
直线
## end
#1112, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#1116, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#1119, 14:
+[返回目录]
+[内容]

## end
#1120, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1122, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1123, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1125, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#1131, 39:
-341.5029305270932, -227.02458446716267
## end
#1132, 38:
-347.4965171878334, -559.3356671015345
## end
#1133, 7:
255,0,0
## end
#1134, 8:
DashLine
## end
#1135, 1:
2
## end
#1136, 1:
1
## end
#1138, 8:
958, 476
## end
#1140, 14:
-300.0, -300.0
## end
#1144, 131:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::255,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#1154, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1160, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1161, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1162, 2:
直线
## end
#1163, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#1167, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#1170, 14:
+[返回目录]
+[内容]

## end
#1171, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1173, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1174, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1176, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#1182, 39:
-392.2524534977414, -276.09178922696003
## end
#1183, 37:
-560.558840004919, -53.91162946865302
## end
#1184, 7:
255,0,0
## end
#1185, 8:
DashLine
## end
#1186, 1:
2
## end
#1188, 81:
+[返回目录](,角度)

数值::
类型::角度

标记::%数值

画图:...
P代码:...
+[P函数](,P代码)

+[创建输入](标记,画图)


## end
#1204, 3:
%数值
## end
#1206, 19:
-141.82198700987882
## end
#1208, 37:
-560.558840004919, -53.91162946865302
## end
#1210, 39:
-392.2524534977414, -276.09178922696003
## end
#1212, 38:
-347.4965171878334, -559.3356671015345
## end
#1214, 39:
-341.5029305270932, -227.02458446716267
## end
#1220, 50:
+[返回目录]
+[内容]
pt11::
pt12::
pt21::
pt22::
angle::

## end
#1222, 22:
+[返回目录]
+[内容]
标记::%数值

## end
#1225, 871:
"""
+[返回目录](,画图)

输出:...
+[设置结构](,输出)

"""

r=20

Dx1=pt11[0]-pt12[0]
Dy1=pt11[1]-pt12[1]

Dx2=pt21[0]-pt22[0]
Dy2=pt21[1]-pt22[1]

dangle=angle[0]

D1=pt11[0]*Dy1-pt11[1]*Dx1
D2=pt21[0]*Dy2-pt21[1]*Dx2

L=Dy1*Dx2-Dy2*Dx1
if L==0:
    pt0=None
else:
    pt0=[(D1*Dx2-D2*Dx1)/L, (D1*Dy2-D2*Dy1)/L]

sign=np.sign(Dy1)
theta1=-sign*np.arccos(Dx1/np.sqrt(Dx1**2+Dy1**2))
angle1=np.rad2deg(theta1)


qp.setPen(QPen(QColor(255,0,0),2))
qp.setBrush(QBrush(QColor(255,255,255)))

qp.drawArc(pt0[0]-r,pt0[1]-r,2*r,2*r,angle1*16,-dangle*16)

qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",10))

dx=r*np.cos(theta1-np.deg2rad(dangle)/2)
dy=-r*np.sin(theta1-np.deg2rad(dangle)/2)

if 标记=='%数值':
    qp.drawText(pt0[0]+dx,pt0[1]+dy,"%.2f"%(dangle))
else:
    qp.drawText(pt0[0]+dx,pt0[1]+dy,str(标记))

qp.drawPoint(pt0[0]+dx,pt0[1]+dy)

qp.setFont(QFont())




## end
#1226, 14:
+[返回目录]
+[内容]

## end
#1229, 612:
"""
+[返回目录](,P代码)

+[P函数](,P代码)

输出:...
+[设置结构](,输出)

"""

Dx1=pt11[0]-pt12[0]
Dy1=pt11[1]-pt12[1]

Dx2=pt21[0]-pt22[0]
Dy2=pt21[1]-pt22[1]

D1=pt11[0]*Dy1-pt11[1]*Dx1
D2=pt21[0]*Dy2-pt21[1]*Dx2

L=Dy1*Dx2-Dy2*Dx1
if L==0:
    pt0="None"
else:
    pt0=[(D1*Dx2-D2*Dx1)/L, (D1*Dy2-D2*Dy1)/L]
    if np.abs(pt0[0]-pt11[0])>np.abs(pt0[0]-pt12[0]):
        Dx1=-Dx1
        Dy1=-Dy1
    
    if np.abs(pt0[0]-pt21[0])>np.abs(pt0[0]-pt22[0]):
        Dx2=-Dx2
        Dy2=-Dy2


sign=np.sign(Dx1*Dy2-Dx2*Dy1)
theta=np.arccos((Dx1*Dx2+Dy1*Dy2)/np.sqrt((Dx1**2+Dy1**2)*(Dx2**2+Dy2**2)))
angle=np.rad2deg(theta)*sign




## end
#1230, 2:
角度
## end
#1231, 19:
-141.82198700987882
## end
#1233, 224:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10
地址::C:\Users\cheng\Dropbox\iFAST_log\resources\20210414\1.jpg

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

+[创建输入](地址,画图)

## end
#1247, 1518:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""


from PyQt5.QtGui import QPixmap



pt=起点
size=尺寸
size_F=字体[0]
pic_file=地址

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


#qp.drawRect(pt[0],pt[1],size[0],size[1])

pixmap=QPixmap(pic_file)
size[1]=pixmap.height()/pixmap.width()*size[0]
qp.drawPixmap(pt[0],pt[1],size[0],size[1],pixmap)
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())


尺寸=size






"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#1252, 85:
起点::281.49455475000013, -84.73663301562507
尺寸::397.9895365000002, 241.94621603125017

## end
#1255, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#1256, 841:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""


from PyQt5.QtGui import QPixmap



pt=起点
size=尺寸
size_F=字体[0]
pic_file=地址

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


#qp.drawRect(pt[0],pt[1],size[0],size[1])

pixmap=QPixmap(pic_file)
size[1]=pixmap.height()/pixmap.width()*size[0]
qp.drawPixmap(pt[0],pt[1],size[0],size[1],pixmap)
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())


尺寸=size







## end
#1257, 231:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


## end
#1260, 14:
+[返回目录]
+[内容]

## end
#1261, 1178:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];
var img1=new Image();
var img=new Image();

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(%起点,%尺寸);
}

/*
if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}*/


/*
var img2 = new Image(),
        f = document.getElementById("uploadimage").files[0],
        url = window.URL || window.webkitURL,
        //src = url.createObjectURL(f);
        src=f;

    img2.src = src;
    img2.onload = function() {
        ctx.drawImage(img2, 0, 0);
        url.revokeObjectURL(src);
    }
*/



img1.onload=function() {
    ctx.drawImage(img1,%起点,%尺寸);
}
img1.src='https://img.moegirl.org.cn/common/thumb/8/86/Aj353_19.jpg/800px-Aj353_19.jpg'




//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1264, 14:
+[返回目录]
+[内容]

## end
#1265, 115:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100
地址::test1.png

## end
#1275, 38:
184.74873052201468, -602.6981624266084
## end
#1276, 38:
1361.2464414466408, 1020.9348310849806
## end
#1277, 2:
矩形
## end
#1279, 2:
10
## end
#1280, 8:
DashLine
## end
#1281, 1:
2
## end
#1282, 11:
255,255,255
## end
#1283, 5:
0,0,0
## end
#1284, 57:
C:\Users\cheng\Dropbox\iFAST_log\resources\20210414\1.jpg
## end
#1286, 129:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#1296, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1302, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1303, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1304, 2:
直线
## end
#1305, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#1309, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#1312, 14:
+[返回目录]
+[内容]

## end
#1313, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1315, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1316, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1318, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#1324, 38:
1265.2868233991737, -47.38268352614071
## end
#1325, 38:
215.45817985615207, -54.15257574273784
## end
#1326, 7:
255,0,0
## end
#1327, 8:
DashLine
## end
#1328, 1:
2
## end
#1330, 129:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#1340, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1346, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1347, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1348, 2:
直线
## end
#1349, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#1353, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#1356, 14:
+[返回目录]
+[内容]

## end
#1357, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1359, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1360, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1362, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#1368, 36:
891.005867286745, -68.20821523592187
## end
#1369, 38:
789.4991476296797, -19.993186209831805
## end
#1370, 7:
255,0,0
## end
#1371, 8:
DashLine
## end
#1372, 1:
2
## end
#1374, 129:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#1384, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1390, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1391, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1392, 2:
直线
## end
#1393, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#1397, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#1400, 14:
+[返回目录]
+[内容]

## end
#1401, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1403, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1404, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1406, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#1412, 39:
1036.4857083155491, -12.760931855918301
## end
#1413, 36:
922.9252314019612, -65.4961198532043
## end
#1414, 7:
255,0,0
## end
#1415, 8:
DashLine
## end
#1416, 1:
2
## end
#1418, 78:
+[返回目录](,角度)

数值::
类型::角度

标记::

画图:...
P代码:...
+[P函数](,P代码)

+[创建输入](标记,画图)


## end
#1436, 19:
-25.776883508943826
## end
#1438, 38:
789.4991476296797, -19.993186209831805
## end
#1440, 36:
891.005867286745, -68.20821523592187
## end
#1442, 38:
215.45817985615207, -54.15257574273784
## end
#1444, 38:
1265.2868233991737, -47.38268352614071
## end
#1450, 50:
+[返回目录]
+[内容]
pt11::
pt12::
pt21::
pt22::
angle::

## end
#1452, 22:
+[返回目录]
+[内容]
标记::%数值

## end
#1455, 867:
"""
+[返回目录](,画图)

输出:...
+[设置结构](,输出)

"""

r=20

Dx1=pt11[0]-pt12[0]
Dy1=pt11[1]-pt12[1]

Dx2=pt21[0]-pt22[0]
Dy2=pt21[1]-pt22[1]

dangle=angle[0]

D1=pt11[0]*Dy1-pt11[1]*Dx1
D2=pt21[0]*Dy2-pt21[1]*Dx2

L=Dy1*Dx2-Dy2*Dx1
if L==0:
    pt0=None
else:
    pt0=[(D1*Dx2-D2*Dx1)/L, (D1*Dy2-D2*Dy1)/L]

sign=np.sign(Dy1)
theta1=-sign*np.arccos(Dx1/np.sqrt(Dx1**2+Dy1**2))
angle1=np.rad2deg(theta1)


qp.setPen(QPen(QColor(0,0,0)))
qp.setBrush(QBrush(QColor(255,255,255)))

qp.drawArc(pt0[0]-r,pt0[1]-r,2*r,2*r,angle1*16,-dangle*16)

qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",10))

dx=r*np.cos(theta1-np.deg2rad(dangle)/2)
dy=-r*np.sin(theta1-np.deg2rad(dangle)/2)

if 标记=='%数值':
    qp.drawText(pt0[0]+dx,pt0[1]+dy,"%.2f"%(dangle))
else:
    qp.drawText(pt0[0]+dx,pt0[1]+dy,str(标记))

qp.drawPoint(pt0[0]+dx,pt0[1]+dy)

qp.setFont(QFont())




## end
#1456, 14:
+[返回目录]
+[内容]

## end
#1459, 612:
"""
+[返回目录](,P代码)

+[P函数](,P代码)

输出:...
+[设置结构](,输出)

"""

Dx1=pt11[0]-pt12[0]
Dy1=pt11[1]-pt12[1]

Dx2=pt21[0]-pt22[0]
Dy2=pt21[1]-pt22[1]

D1=pt11[0]*Dy1-pt11[1]*Dx1
D2=pt21[0]*Dy2-pt21[1]*Dx2

L=Dy1*Dx2-Dy2*Dx1
if L==0:
    pt0="None"
else:
    pt0=[(D1*Dx2-D2*Dx1)/L, (D1*Dy2-D2*Dy1)/L]
    if np.abs(pt0[0]-pt11[0])>np.abs(pt0[0]-pt12[0]):
        Dx1=-Dx1
        Dy1=-Dy1
    
    if np.abs(pt0[0]-pt21[0])>np.abs(pt0[0]-pt22[0]):
        Dx2=-Dx2
        Dy2=-Dy2


sign=np.sign(Dx1*Dy2-Dx2*Dy1)
theta=np.arccos((Dx1*Dx2+Dy1*Dy2)/np.sqrt((Dx1**2+Dy1**2)*(Dx2**2+Dy2**2)))
angle=np.rad2deg(theta)*sign




## end
#1460, 2:
角度
## end
#1461, 19:
-25.776883508943826
## end
#1463, 78:
+[返回目录](,角度)

数值::
类型::角度

标记::

画图:...
P代码:...
+[P函数](,P代码)

+[创建输入](标记,画图)


## end
#1481, 17:
-155.460268729022
## end
#1483, 36:
922.9252314019612, -65.4961198532043
## end
#1485, 39:
1036.4857083155491, -12.760931855918301
## end
#1487, 38:
215.45817985615207, -54.15257574273784
## end
#1489, 38:
1265.2868233991737, -47.38268352614071
## end
#1495, 50:
+[返回目录]
+[内容]
pt11::
pt12::
pt21::
pt22::
angle::

## end
#1497, 22:
+[返回目录]
+[内容]
标记::%数值

## end
#1500, 867:
"""
+[返回目录](,画图)

输出:...
+[设置结构](,输出)

"""

r=20

Dx1=pt11[0]-pt12[0]
Dy1=pt11[1]-pt12[1]

Dx2=pt21[0]-pt22[0]
Dy2=pt21[1]-pt22[1]

dangle=angle[0]

D1=pt11[0]*Dy1-pt11[1]*Dx1
D2=pt21[0]*Dy2-pt21[1]*Dx2

L=Dy1*Dx2-Dy2*Dx1
if L==0:
    pt0=None
else:
    pt0=[(D1*Dx2-D2*Dx1)/L, (D1*Dy2-D2*Dy1)/L]

sign=np.sign(Dy1)
theta1=-sign*np.arccos(Dx1/np.sqrt(Dx1**2+Dy1**2))
angle1=np.rad2deg(theta1)


qp.setPen(QPen(QColor(0,0,0)))
qp.setBrush(QBrush(QColor(255,255,255)))

qp.drawArc(pt0[0]-r,pt0[1]-r,2*r,2*r,angle1*16,-dangle*16)

qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",10))

dx=r*np.cos(theta1-np.deg2rad(dangle)/2)
dy=-r*np.sin(theta1-np.deg2rad(dangle)/2)

if 标记=='%数值':
    qp.drawText(pt0[0]+dx,pt0[1]+dy,"%.2f"%(dangle))
else:
    qp.drawText(pt0[0]+dx,pt0[1]+dy,str(标记))

qp.drawPoint(pt0[0]+dx,pt0[1]+dy)

qp.setFont(QFont())




## end
#1501, 14:
+[返回目录]
+[内容]

## end
#1504, 612:
"""
+[返回目录](,P代码)

+[P函数](,P代码)

输出:...
+[设置结构](,输出)

"""

Dx1=pt11[0]-pt12[0]
Dy1=pt11[1]-pt12[1]

Dx2=pt21[0]-pt22[0]
Dy2=pt21[1]-pt22[1]

D1=pt11[0]*Dy1-pt11[1]*Dx1
D2=pt21[0]*Dy2-pt21[1]*Dx2

L=Dy1*Dx2-Dy2*Dx1
if L==0:
    pt0="None"
else:
    pt0=[(D1*Dx2-D2*Dx1)/L, (D1*Dy2-D2*Dy1)/L]
    if np.abs(pt0[0]-pt11[0])>np.abs(pt0[0]-pt12[0]):
        Dx1=-Dx1
        Dy1=-Dy1
    
    if np.abs(pt0[0]-pt21[0])>np.abs(pt0[0]-pt22[0]):
        Dx2=-Dx2
        Dy2=-Dy2


sign=np.sign(Dx1*Dy2-Dx2*Dy1)
theta=np.arccos((Dx1*Dx2+Dy1*Dy2)/np.sqrt((Dx1**2+Dy1**2)*(Dx2**2+Dy2**2)))
angle=np.rad2deg(theta)*sign




## end
#1505, 2:
角度
## end
#1506, 17:
-155.460268729022
## end
#1508, 800:
%{
+[返回目录](,光斑形状与光强)

+[M函数](,光斑形状与光强)
%}

file_name='C:\Users\cheng\Dropbox\iFAST_log\resources\20210405\0.raw';


data=readtable(file_name,'FileType','text');
data=data{:,:};

x=(1:1200)*5.5e-3;
y=(1:1600)*5.5e-3;

x1=4.29;
y1=linspace(1,2,1000);
In1=interp2(x,y,data,x1,y1);

x2=linspace(3.8,4.8,1000);
y2=1.5;
In2=interp2(x,y,data,x2,y2);

clf;
subplot(1,2,1)
hold on
surf(x,y,data/max(max(data)));
plot3(x1*ones(size(y)),y,2*ones(size(y)),'r');
plot3(x,y2*ones(size(x)),2*ones(size(x)),'r');
shading interp
view([0,90])
axis equal
axis([3.5,5,0.8,2])
xlabel('x [mm]')
ylabel('y [mm]')

subplot(2,2,2)
plot(x2,In2)
xlabel('x [mm]')
ylabel('Intensity [a.b.u.]')
axis([min(x2),max(x2),0,max(In2)])

subplot(2,2,4)
plot(y1,In1)
xlabel('y [mm]')
ylabel('Intensity [a.b.u.]')



%{
+[M函数](,光斑形状与光强)
%}
## end
#1511, 1515:
%{
+[返回目录](,计算光强)
高斯光束::文档\物理问题\高斯光束.ftxt
+[打开文件](+新窗口,高斯光束)
激光光强::文档\物理问题\激光a0.ftxt
+[打开文件](+新窗口,激光光强)


+[M函数](,计算光强)
%}

physics_constant;
theta=51.82;
lm=790e-9;
D0=0.18;
dD=-0.35e-3;
D=linspace(D0-dD*1.5,D0+dD/2,100);
%D=D0;
N=1480;
dtau=23e-15;

Energy=30e-3;
eff=[0.80,0.95,0.95]';
w0=[0.4e-3,3e-3,20e-3]';

E=[Energy*eff(1)*(1-eff(2))*(1-eff(3));
Energy*eff(2)*(1-eff(3));
Energy*eff(3)
];

d=1e-3/N;
GDD_grating0=-lm.^3*D0/pi/c^2/d^2.*(1-(lm/d-sind(theta)).^2).^(-3/2);
GDD_grating=-lm.^3*D/pi/c^2/d^2.*(1-(lm/d-sind(theta)).^2).^(-3/2);


GVD_air=0.025003/1e-3*1e-30;
L_air=[
76+35+12+38+52+32+17+23+6+23+10+12;
76+35+12+38+52+32+17+12+18+18+42+11+9+11+4;
76+35+51+47+42+67+71+74+9+49+3+4;
]*1e-2;

%{
32+18+24+4+24+18+13+76+35
+51+47+42+67+71+74+9+49+3+4

+12+38+52+32+17
+23+6+23+10+12

+12+18+18+42+11+9+11+4
%}


GVD_fs=44.308/1e-3*1e-30;
d_fs=[
1+3/sind(45)+1.5+1+2/sind(22)+2/sind(22)+1.5+1.5;
1+1.5;
0]*1e-3;

GVD_bk=54.281/1e-3*1e-30;

GDD_m=L_air*GVD_air+d_fs*GVD_fs;
dGDD=GDD_grating-GDD_grating0;
GDD=GDD_grating-GDD_grating0+GDD_m;
dt=sqrt((GDD*2/dtau).^2+dtau^2);


I0=2*E/sqrt(pi)/pi./w0.^2./dt;

clf
subplot(1,2,1)
plot(D/1e-3,dt/1e-15);
legend('TOPAS 1st','TOPAS 2nd','Booster')
xlabel('Grating pair distance [mm]')
ylabel('Pulse duration [fs]')

subplot(1,2,2)
plot(D/1e-3,I0/1e4);
set(gca,'YScale','log')
legend('TOPAS 1st','TOPAS 2nd','Booster','Location','northwest');
xlabel('Grating pair distance [mm]')
ylabel('Peak Intensity [W/cm^2]')

%I0(3)/1e4
%E(3)
%dt(3)

%{
+[M函数](,计算光强)
%}
## end
#1514, 17:
文档\物理问题\高斯光束.ftxt
## end
#1516, 17:
文档\物理问题\激光a0.ftxt
## end
#1519, 4:
1523
## end
#1522, 72:
https://mail.google.com/mail/u/0/#inbox/FMfcgxwKjBPvFRQjrHNNbrwwfVCMdjWN
## end
#1523, 4:
1528
## end
#1525, 4:
1527
## end
#1527, 4:
1529
## end
#1529, 4:
1531
## end
#1531, 4:
1536
## end
#1534, 740:
%{
+[M函数](,公式验证)
%}

physics_constant;

D=0.67;
theta=47.28;
G=1480;
d=1e-3/G;

lm_0=800e-9;
dtau=65e-15/2;

dw=2/dtau;
n=-1;

w_0=2*pi*c./lm_0;
w=linspace(0,w_0+20*dw,350);
lm=2*pi*c./w;

t0=200e-15;

S=exp(-(w-w_0).^2/dw^2).*exp(-1i*t0*w);
[t,f]=ifft_k(w,S);

f_abs=abs(f);
f_max=max(f_abs);
Df=f_abs(f_abs>f_max/exp(1));
Dt=t(f_abs>f_max/exp(1));

t01=t(f_abs==f_max);
dtau1=(max(Dt)-min(Dt))/2;


subplot(1,2,1)
plot(lm/1e-9,abs(S));
xlabel('\lambda [nm]')
axis([700,900,-0.05,1])

subplot(1,2,2)
plot(t/1e-15,abs(f),Dt/1e-15,Df,'o');
xlabel('t [fs]')
axis([0,400,-0.05,max(abs(f))])

disp(sprintf('dtau=%.2f fs',dtau/1e-15));
disp(sprintf('dtau1=%.2f fs',dtau1/1e-15));
disp(sprintf('dtau/dtau1=%.2f',dtau/dtau1));

%{
+[M函数](,公式验证)
%}
## end
#1540, 4:
1549
## end
#1543, 618:
<!--
+[H函数](,推导结果)
-->

<h2>Spectrum of a dispersive pulse</h2>
The spectrum of a Gaussian pulse,
%[1].
If we add a dispersive phase to the pulse,
%[2].
The spectrum is,
%[3].
%[4].

<h2>Fourier transform</h2>
If the spectrum is,
%[5].
Then,
%[6].
Coefficients in eqn.[6]., 
%[7].
%[8].
%[9].

The finial output is,
%[10].


<!--
[11].:
式(7)转换为"表达式"
式(10)转换为"Matlab"
将"a=\p{\omega}{k}*D"记作为式(7)

将式(6)记作为式(10)
将式(7)代入到式(10)
将式(8)代入到式(10)
将式(9)代入到式(10)


将"c^2=0"记作为式(11)
将式(9)代入到式(11)

更新式(10)
验证公式(M函数):...
将'验证公式'的"omega"替换为"w"
将'验证公式'的"delta"替换为"d"

的([10].,表达式)->+[显示星图]"1"(,表达式)
+[新建阅读窗口](,验证公式)
+[H函数](,推导结果)
-->
## end
#1546, 107:
S \left( \omega \right)=A\ exp \left( -\frac{\left(\omega-\omega_{0}\right)^{2}}{\delta \omega^{2}} \right)
## end
#1548, 190:
\phi \left( \omega \right)=\frac{\partial k}{\partial \omega}\ \left(\omega-\omega_{0}\right)\ D+\frac{1}{2}\ \frac{\partial^{2}k}{\partial \omega^{2}}\ \left(\omega-\omega_{0}\right)^{2}\ D
## end
#1550, 97:
F \left( \omega \right)=exp \left( i\ \phi \left( \omega \right) \right)\ S \left( \omega \right)
## end
#1552, 307:
F \left( \omega \right)=A\ exp \left( i\ \left(\frac{\partial k}{\partial \omega}\ \left(\omega-\omega_{0}\right)\ D+\frac{1}{2}\ \frac{\partial^{2}k}{\partial \omega^{2}}\ \left(\omega-\omega_{0}\right)^{2}\ D\right) \right)\ exp \left( -\frac{\left(\omega-\omega_{0}\right)^{2}}{\delta \omega^{2}} \right)
## end
#1554, 155:
F \left( \omega \right)=exp \left( i\ a\ \left(\omega-\omega_{0}\right) \right)\ exp \left( \left(i\ b-c\right)\ \left(\omega-\omega_{0}\right)^{2} \right)
## end
#1556, 184:
f \left( t \right)=\sqrt{\frac{2\ \pi}{i\ b-c}}\ exp \left( -\left(i\ b+c\right)\ \frac{\left(a-t\right)^{2}}{4\ \left(b^{2}+c^{2}\right)} \right)\ exp \left( -i\ \omega_{0}\ t \right)
## end
#1557, 63:
S(\omega)=A*exp(-\frac{(\omega-\omega_0)^{2}}{\delta \omega^2})
## end
#1560, 101:
\phi(\omega)=\p{\omega}{k}*(\omega-\omega_0)*D+\frac{1}{2}*\p{\omega,\omega}{k}*(\omega-\omega_0)^2*D
## end
#1564, 39:
F(\omega)=exp(i*\phi(\omega))*S(\omega)
## end
#1568, 165:
F(\omega)=A*exp(i*(\p{\omega}{k}*(\omega-\omega_0)*D+\frac{1}{2}*\p{\omega,\omega}{k}*(\omega-\omega_0)^{2}*D))*exp(-\frac{(\omega-\omega_0)^{2}}{\delta \omega^{2}})
## end
#1571, 88:
\p{\omega}{k}*(\omega-\omega_0)*D+\frac{1}{2}*\p{\omega,\omega}{k}*(\omega-\omega_0)^2*D
## end
#1573, 12:
\phi(\omega)
## end
#1578, 39:
a=\frac{\partial k}{\partial \omega}\ D
## end
#1579, 69:
F(\omega)=exp(i*a*(\omega-\omega_0))*exp((i*b-c)*(\omega-\omega_0)^2)
## end
#1583, 92:
f(t)=\sqrt{\frac{2*\pi}{i*b-c}}*exp(-(i*b+c)*\frac{(a-t)^2}{4*(b^2+c^2)})*exp(-i*\omega_0*t)
## end
#1587, 17:
a=\p{\omega}{k}*D
## end
#1591, 59:
b=\frac{1}{2}\ \frac{\partial^{2}k}{\partial \omega^{2}}\ D
## end
#1593, 29:
c=\frac{1}{\delta \omega^{2}}
## end
#1594, 36:
b=\frac{1}{2}*\p{\omega,\omega}{k}*D
## end
#1601, 27:
c=\frac{1}{\delta \omega^2}
## end
#1606, 843:
%{
+[M函数](,验证公式)

波包表达式:...
设置光谱:...
波包对比:...
+[新建阅读窗口](,波包表达式)
figure
保存:...
%}

physics_constant;

lm_0=832e-9;
d_tau=10e-15;

w_0=2*pi*c/lm_0;
d_w=2/d_tau;

A=1;
D=1;
% d2k_dw=1e-25;
d2k_dw=100e-30;
dk_dw=0;

%{
+[M函数](,验证公式)
%}

S=@(w)A.*exp(-((w-w_0).^(2))./(d_w.^(2)));
phi=@(w)dk_dw.*(w-w_0).*D+(1)./(2).*d2k_dw.*(w-w_0).^(2).*D;
F=@(w)exp(1i.*phi(w)).*S(w);

f=@(t)sqrt((2.*pi)./(1i.*(1)./(2).*d2k_dw.*D-(1)./(d_w.^(2)))).*exp(-(1i.*(1)./(2).*d2k_dw.*D+(1)./(d_w.^(2))).*((dk_dw.*D-t).^(2))./(4.*(((1)./(2).*d2k_dw.*D).^(2)+((1)./(d_w.^(2))).^(2)))).*exp(-1i.*w_0.*t);


N=4000;
DW=1/d_tau*1500;
dw=DW/N;
wx=(1:N)*dw;

[ts,ft0]=fft_x(wx,F(wx));
ft=ft0/max(abs(ft0));
ft_1=f(ts);
ft_1=ft_1/max(abs(ft_1));

x=ts*c/1e-6;

% plot(ts,ft,ts,abs(ft))
plot(x,imag(ft),x,ft_1,x,abs(ft),x,abs(ft_1),'--','lineWidth',2)


%{
clf
+[M函数](,验证公式)
%}
## end
#1608, 1:
)
## end
#1610, 1:
)
## end
#1613, 492:
f \left( t \right)=\sqrt{\frac{2\ \pi}{i\ \frac{1}{2}\ \frac{\partial^{2}k}{\partial \omega^{2}}\ D-\frac{1}{\delta \omega^{2}}}}\ exp \left( -\left(i\ \frac{1}{2}\ \frac{\partial^{2}k}{\partial \omega^{2}}\ D+\frac{1}{\delta \omega^{2}}\right)\ \frac{\left(\frac{\partial k}{\partial \omega}\ D-t\right)^{2}}{4\ \left(\left(\frac{1}{2}\ \frac{\partial^{2}k}{\partial \omega^{2}}\ D\right)^{2}+\left(\frac{1}{\delta \omega^{2}}\right)^{2}\right)} \right)\ exp \left( -i\ \omega_{0}\ t \right)
## end
#1614, 293:
f(t)=\sqrt{\frac{2*\pi}{i*\frac{1}{2}*\p{\omega,\omega}{k}*D-\frac{1}{\delta \omega^{2}}}}*exp(-(i*\frac{1}{2}*\p{\omega,\omega}{k}*D+\frac{1}{\delta \omega^{2}})*\frac{(\p{\omega}{k}*D-t)^{2}}{4*((\frac{1}{2}*\p{\omega,\omega}{k}*D)^{2}+(\frac{1}{\delta \omega^{2}})^{2})})*exp(-i*\omega_0*t)
## end
#1618, 46:
\left(\frac{1}{\delta \omega^{2}}\right)^{2}=0
## end
#1619, 35:
(\frac{1}{\delta \omega^{2}})^{2}=0
## end
#1626, 1:
)
## end
#1632, 15:
\p{\omega}{k}*D
## end
#1634, 1:
a
## end
#1638, 1:
)
## end
#1640, 34:
\frac{1}{2}*\p{\omega,\omega}{k}*D
## end
#1642, 1:
b
## end
#1646, 1:
)
## end
#1649, 1:
)
## end
#1651, 1:
)
## end
#1653, 25:
\frac{1}{\delta \omega^2}
## end
#1655, 1:
c
## end
#1659, 1:
)
## end
#1662, 1:
)
## end
#1664, 1:
)
## end
#1667, 641:
%{
+[M函数](,验证公式)

保存:...
%}

physics_constant;

lm_0=800e-9;
d_tau=5e-15;

w_0=2*pi*c/lm_0;
d_w=2/d_tau;

A=1;
D=1e-3;
d2k_dw=1e-30;
dk_dw=0;

S=@(w)A.*exp(-((w-w_0).^(2))./(d_w.^(2)));
phi=@(w)dk_dw.*(w-w_0).*D+(1)./(2).*d2k_dw.*(w-w_0).^(2).*D;
F=@(w)exp(1i.*phi(w)).*S(w);

f=@(t)sqrt((2.*pi)./(1i.*(1)./(2).*d2k_dw.*D-(1)./(d_w.^(2)))).*exp(-(1i.*(1)./(2).*d2k_dw.*D+(1)./(d_w.^(2))).*((dk_dw.*D-t).^(2))./(4.*(((1)./(2).*d2k_dw.*D).^(2)+((1)./(d_w.^(2))).^(2)))).*exp(-1i.*w_0.*t);

lm=linspace(200,1000,200)*1e-9;
wx=2*pi*c./lm;

ts=linspace(-1,1,4000)*120e-15;

% plot(lm/1e-9,S(wx))
plot(ts,f(ts),ts,abs(f(ts)))


%{
+[M函数](,验证公式)
%}
## end
#1669, 714:
%{
+[M函数](,波包表达式)

波包表达式:...

保存:...
%}

physics_constant;

lm_0=800e-9;
d_tau=35e-15;

w_0=2*pi*c/lm_0;
d_w=2/d_tau;

A=1;
D=1e-3;
d2k_dw=1e-25;
dk_dw=0;

%{
+[M函数](,验证公式)
%}

S=@(w)A.*exp(-((w-w_0).^(2))./(d_w.^(2)));
phi=@(w)dk_dw.*(w-w_0).*D+(1)./(2).*d2k_dw.*(w-w_0).^(2).*D;
F=@(w)exp(1i.*phi(w)).*S(w);

f=@(t)sqrt((2.*pi)./(1i.*(1)./(2).*d2k_dw.*D-(1)./(d_w.^(2)))).*exp(-(1i.*(1)./(2).*d2k_dw.*D+(1)./(d_w.^(2))).*((dk_dw.*D-t).^(2))./(4.*(((1)./(2).*d2k_dw.*D).^(2)+((1)./(d_w.^(2))).^(2)))).*exp(-1i.*w_0.*t);

lm=linspace(200,1000,200)*1e-9;
wx=2*pi*c./lm;

ts=linspace(-1,1,4000)*300e-15;

figure(2)
% plot(lm/1e-9,S(wx))
plot(ts,f(ts),-ts,-f(ts),ts,abs(f(ts)),-ts,-abs(-f(ts)))


%{
+[M函数](,波包表达式)
%}
## end
#1671, 732:
%{
+[M函数](,验证公式)

波包表达式:...
设置光谱:
+[新建阅读窗口](,波包表达式)

保存:...
%}

physics_constant;

lm_0=800e-9;
d_tau=35e-15;

w_0=2*pi*c/lm_0;
d_w=2/d_tau;

A=1;
D=1e-3;
d2k_dw=1e-25;
dk_dw=0;

%{
+[M函数](,验证公式)
%}

S=@(w)A.*exp(-((w-w_0).^(2))./(d_w.^(2)));
phi=@(w)dk_dw.*(w-w_0).*D+(1)./(2).*d2k_dw.*(w-w_0).^(2).*D;
F=@(w)exp(1i.*phi(w)).*S(w);

f=@(t)sqrt((2.*pi)./(1i.*(1)./(2).*d2k_dw.*D-(1)./(d_w.^(2)))).*exp(-(1i.*(1)./(2).*d2k_dw.*D+(1)./(d_w.^(2))).*((dk_dw.*D-t).^(2))./(4.*(((1)./(2).*d2k_dw.*D).^(2)+((1)./(d_w.^(2))).^(2)))).*exp(-1i.*w_0.*t);

% lm=linspace(200,1000,2000)*1e-9;
% wx=2*pi*c./lm;

N=4000;
DW=1/d_tau*1500;
dw=DW/N;
wx=(1:N)*dw;

[ts,ft]=fft_x(wx,F(wx));
% plot(wx,F(wx))
plot(ts,ft,ts,abs(ft))


%{
+[M函数](,验证公式)
%}
## end
#1673, 803:
%{
+[M函数](,验证公式)

波包表达式:...
设置光谱:...
+[新建阅读窗口](,波包表达式)

保存:...
%}

physics_constant;

lm_0=800e-9;
d_tau=10e-15;

w_0=2*pi*c/lm_0;
d_w=2/d_tau;

A=1;
D=1e-3;
d2k_dw=1e-25;
dk_dw=0;

%{
+[M函数](,验证公式)
%}

S=@(w)A.*exp(-((w-w_0).^(2))./(d_w.^(2)));
phi=@(w)dk_dw.*(w-w_0).*D+(1)./(2).*d2k_dw.*(w-w_0).^(2).*D;
F=@(w)exp(1i.*phi(w)).*S(w);

f=@(t)sqrt((2.*pi)./(1i.*(1)./(2).*d2k_dw.*D-(1)./(d_w.^(2)))).*exp(-(1i.*(1)./(2).*d2k_dw.*D+(1)./(d_w.^(2))).*((dk_dw.*D-t).^(2))./(4.*(((1)./(2).*d2k_dw.*D).^(2)+((1)./(d_w.^(2))).^(2)))).*exp(-1i.*w_0.*t);


N=4000;
DW=1/d_tau*1500;
dw=DW/N;
wx=(1:N)*dw;

[ts,ft0]=fft_x(wx,F(wx));
ft=ft0/max(abs(ft0));
ft_1=f(ts);
ft_1=ft_1/max(abs(ft_1));

% plot(ts,ft,ts,abs(ft))
plot(ts,imag(ft),ts,ft_1,ts,abs(ft),ts,abs(ft_1),'--','lineWidth',2)


%{
clf
+[M函数](,验证公式)
%}
## end
### 结束