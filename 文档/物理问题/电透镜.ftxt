### 节点
地址, 的, 电透镜, 目录, 的, 的, 节点数目统计, 的, 正文, html, 的, 验证公式, M函数, 的, 笔记, 的, calculation_all, 的, 保存, 的, 测试tm_traj, 的, tm_traj, M函数, 的, 地址, tm_traj, 的, 记忆, tm_traj, 的, [1]., 手, 表达式, 的, 公式, 的, [2]., 的, [3]., 表达式, 的, 公式, 的, 参考, 打开网页, 表达式, 的, 公式, 的, RK4轨迹, M函数, 的, 磁场轨迹, 的, 笔记, 的, 电子排斥, 的, AL电场, 的, 基础1, 的, 基础2, 打开网页, 打开网页, 打开网页, 的, physics_constant, M函数, 的, 地址, physics_constant, 的, physics_constant, 的, addpath, M函数, 的, 地址, 的, 加速电场, 的, 透镜电场_函数, 的, 透镜电场_插值, 的, 工具库, 的, 电透镜场景转代码, 的, 召唤规则, 的, 降临规则, 库, P代码1, P代码, 的, 的, 描述结构, 的, 的, 设置变量, 的, M模板, M代码, 的, 的, 整理代码, 的, 的, 单体代码, 的, 库, 的, 描述结构, 的, 样本, 的, 设置电子源, 的, 设置观测平面, 在, 的, M模板, 的, M代码, 召唤规则, 的, 电透镜场景转代码, M代码, M模板, 的, 的, 设置透镜, 的, 的, 原始例子, 的, lens_matrix, M函数, 的, 地址, 的, 测试, lens_matrix, 的, lens_matrix, 的, lenses_traj, M函数, 的, 测试, 的, 地址, lenses_traj, 的, lenses_traj, 的, 简化透镜, M函数, 的, 保存, 的, SI单位轨迹, 的, 对比轨迹_zz, 的, 插值与矩阵方法对比, 的, 函数与矩阵方法对比, 的, 多条轨迹, 的, RK4问题, 的, 测试ODE, 的, Stiff问题, 节点数目统计, Stiff问题, 的, field_2D_interp, M函数, 的, 地址, field_2D_interp, 的, field_2D_interp, 打开网页, 打开网页, 打开网页, 打开网页, 打开网页, 打开网页, 打开网页, 打开网页, 打开网页, 的, 近似轨迹, html, 的, [1]., 表达式, 的, 公式, 的, [2]., 的, [3]., 表达式, 的, 公式, r, 的, 表达式, 的, 公式, 2, 2, 的, 的, 的, [4]., 的, [5]., 的, [6]., 表达式, 的, 公式, 的, 参考, 打开网页, 表达式, 的, 公式, 整理等式, b, a, 手, 新结构, 新结构, 新结构, 新结构, 新结构, 新结构, 新结构, 新结构, 旧结构, 新结构, 旧结构, 新结构, 旧结构, 新结构, 旧结构, 新结构, 旧结构, 新结构, 旧结构, 新结构, 新结构, 新结构, 新结构, 新结构, 新结构, 新结构, 新结构, 新结构, 新结构, 手, 表达式, 的, 公式, 的, [7]., 的, [8]., 的, [9]., 的, [10]., 表达式, 的, 公式, 表达式, 的, 公式, 打开网页, 打开网页, 的, [11]., 表达式, 的, 公式, v_z, v_z, 2, 的, 的, 的, 表达式, 的, 公式, r, 的, 表达式, 的, 公式, 的, [12]., 的, [13]., 表达式, 的, 公式, 表达式, 的, 公式, 的, [14]., 的, [15]., 的, [16]., 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, 的, [17]., 的, [18]., 表达式, 的, 公式, 表达式, 的, 公式, 的, [19]., 的, [20]., 的, [21]., 表达式, 的, 公式, 表达式, 的, 公式, 的, [22]., 的, [23]., 表达式, 的, 公式, m_e, 的, 表达式, 的, 公式, 的, [24]., 的, [25]., 表达式, 的, 公式, b, 的, a, 的, 手, 表达式, 的, 公式, b, 的, a, 的, 的, 验证公式, M函数, 的, 测试场, 的, [1]., 手, 表达式, 的, 公式, 的, [2]., 的, [3]., 的, [4]., 表达式, 的, 公式, 表达式, 的, 公式, z, 的, 表达式, 的, 公式, 手, 的, [5]., 的, [6]., 表达式, 的, 公式, 表达式, 的, 公式, 的, [7]., 的, [8]., 的, [9]., 表达式, 的, 公式, 的, [10]., 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, 的, [11]., 表达式, 的, 公式, 新结构, 新结构, 的, 测试电势, 的, 连续场轨迹, 的, 轨迹对比1, 的, 轨迹对比2, 的, [4]., 的, [5]., 的, [6]., 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, 的, [7]., 的, [8]., 表达式, 的, 公式, 表达式, 的, 公式, 的, test_u_1, M函数, 的, 地址, test_u_1, 的, test_u_1, 在, 在, 在, 在, 在, 在, 在, 在, 在, 在, 在, 的, 验证矩阵, 的, 问题具现, 的, 问题解决, 的, 保存, 的, [12]., 的, [13]., 的, [14]., 表达式, 的, 公式, 表达式, 的, 公式, 的, [15]., 表达式, 的, 公式, 表达式, 的, 公式, 的, test_traj_mat, M函数, 的, 地址, test_traj_mat, 的, test_traj_mat, 的, 测试, 的, 差分法对比, 的, ODE对比, 的, 测试误差, M函数, 的, 记录时间, 的, 初步误差测试, 的, 保存, 的, 横向误差测试, 的, 纵向误差测试, 的, 近似电场, html, 的, [1]., 的, [2]., 的, [3]., 的, [4]., 手, 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, 的, 验证公式, M函数, 的, [5]., 的, [6]., 的, [7]., 的, [8]., 的, [9]., 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, 的, [10]., 的, [11]., 的, [12]., 的, [13]., 的, [14]., 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, 手, 表达式, 的, 公式, 表达式, 的, 公式, 的, [15]., 的, [16]., 的, [17]., 的, [18]., 表达式, 的, 公式, b, 的, a, 的, b, 的, a, 的, b, 的, a, 的, 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, 的, 保存, 的, [19]., 的, [20]., 的, [21]., 的, [22]., 的, [23]., 的, [24]., 手, 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, 的, [25]., 的, [26]., 的, [27]., 表达式, 的, 公式, 到, 的, 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, 的, [28]., 的, [29]., 的, [30]., 的, [31]., 的, [32]., 表达式, 的, 公式, 表达式, 的, 公式, b, 的, a, 的, 表达式, 的, 公式, 表达式, 的, 公式, 的, 等效电势, 的, 画电场, P函数, 的, 的, 
### 关联
#, 2#0, #, #, 3#2, 3#6, #, 2#8, #, 8#, 8#11, #, 11#, 11#14, #, 11#16, #, 11#18, #, 11#20, #, 11#22, #, 22#, 22#25, #, #22, 28#26, 3#, #, 8#31, #, #8, #, 31#33, 31#, 8#37, #, 8#39, #, #, 37#40, 37#, 8#44, #, #44, #, 39#46, 39#, 8#50, #, 50#, 50#53, #, 2#55, #, 55#57, #, 55#59, #, 55#61, #, 55#63, #, #61, #63, #59, 50#68, #, 68#, 68#71, #, #68, 28#72, #, 50#76, #, 76#, 76#79, #, 50#81, #, 50#83, #, 50#85, #, 2#87, #, 87#89, #, 89#91, #, 89#93, #, #, #, #, 99#95, 99#96, #, 102#94, 102#99, #, 93#102, #, #, 108#104, 108#105, #, 93#108, 93#111, #, 111#113, #, 111#115, #, 108#117, #, 113#119, #, 113#121, #, #, 119#124, #, 119#126, #, #, 129#127, #, #, #, 134#130, 134#131, #, 113#134, 11#137, #, 11#139, #, 139#, 139#142, #, 139#144, #, #139, 28#145, #, 11#149, #, 149#, 149#152, #, 149#154, #, #149, 28#155, #, 11#159, #, #, 50#162, #, 50#164, #, 11#166, #, 50#168, #, 50#170, #, 11#172, #, 50#174, #, 50#176, #, 176#178, #, #, #, 176#182, #, 182#, 182#185, #, #182, 28#186, #, #63, #63, #63, #63, #63, #63, #61, #59, #57, 2#199, #, 199#, 199#202, #, #, 202#203, 202#, 199#207, #, 199#209, #, #, 207#210, 207#, #, 210#213, #, 209#215, 209#, #, #, 215#219, 215#218, 199#223, #, 199#225, #, 199#227, #, #, 223#228, 223#, 199#232, #, #232, #, 225#234, 225#, 225#, #, #, #199, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #199, #, 227#271, 227#, 199#275, #, 199#277, #, 199#279, #, 199#281, #, #, 275#282, 275#, #, 277#285, 277#, #232, #232, 199#291, #, #, 279#292, 279#, #, #, #, 292#295, 292#296, 292#297, #, 281#301, 281#, #, 301#304, #, 291#306, 291#, 199#310, #, 199#312, #, #, 310#313, 310#, #, 312#316, 312#, 199#320, #, 199#322, #, 199#324, #, #, 320#325, 320#, #, 322#328, 322#, #, 324#331, 324#, 199#335, #, 199#337, #, #, 335#338, 335#, #, 337#341, 337#, 199#345, #, 199#347, #, 199#349, #, #, 345#350, 345#, #, 347#353, 347#, 199#357, #, 199#359, #, #, 349#360, 349#, #, 360#363, #, 357#365, 357#, 199#369, #, 199#371, #, #, 359#372, 359#, #, 215#375, #, 215#377, #199, #, 369#380, 369#, #, 228#383, #, 228#385, 199#388, #, 388#, 199#391, #, 391#393, #, #391, #, 393#395, 393#, 391#399, #, 391#401, #, 391#403, #, #, 399#404, 399#, #, 401#407, 401#, #, 407#410, #, 403#412, 403#, #391, 391#417, #, 391#419, #, #, 417#420, 417#, #, 419#423, 419#, 391#427, #, 391#429, #, 391#431, #, #, 427#432, 427#, 391#436, #, #, 429#437, 429#, #, 431#440, 431#, #, 436#443, 436#, 391#447, #, #, 447#448, 447#, #, #, 388#454, #, 388#456, #, 388#458, #, 388#460, #, 8#462, #, 8#464, #, 8#466, #, #, 462#467, 462#, #, 464#470, 464#, #, 466#473, 466#, 8#477, #, 8#479, #, #, 477#480, 477#, #, 479#483, 479#, 388#487, #, 487#, 487#490, #, #487, 28#491, #, #, #, #, #, #, #, #, #, #, #, #, 388#506, #, 388#508, #, 388#510, #, 388#512, #, 391#514, #, 391#516, #, 391#518, #, #, 514#519, 514#, #, 516#522, 516#, 391#526, #, #, 518#527, 518#, #, 526#530, 526#, 388#534, #, 534#, 534#537, #, #534, 28#538, #, 534#542, #, 388#544, #, 388#546, #, 199#548, #, 548#, 548#551, #, 548#553, #, 548#555, #, 548#557, #, 548#559, #, 2#561, #, 561#, 561#564, #, 561#566, #, 561#568, #, 561#570, #, #561, #, 564#572, 564#, #, 566#575, 566#, #, 568#578, 568#, 561#582, #, 582#, 561#585, #, 561#587, #, 561#589, #, 561#591, #, 561#593, #, #, 570#594, 570#, #, 585#597, 585#, #, 587#600, 587#, #, 589#603, 589#, #, 591#606, 591#, #, 593#609, 593#, 561#613, #, 561#615, #, 561#617, #, 561#619, #, 561#621, #, #, 613#622, 613#, #, 615#625, 615#, #, 617#628, 617#, #561, #, 619#632, 619#, #, 621#635, 621#, 561#639, #, 561#641, #, 561#643, #, 561#645, #, #, 639#646, 639#, #, 603#649, #, 603#651, #, 600#653, #, 600#655, #, 632#657, #, 632#659, #, 641#661, 641#, #, 643#664, 643#, #, 645#667, 645#, 582#671, #, 561#673, #, 561#675, #, 561#677, #, 561#679, #, 561#681, #, 561#683, #, #561, #, 673#685, 673#, #, 675#688, 675#, #, 677#691, 677#, #, 679#694, 679#, #, 681#697, 681#, 561#701, #, 561#703, #, 561#705, #, #, 683#706, 683#, #, 561#709, #, 701#711, 701#, #, 703#714, 703#, #, 705#717, 705#, 561#721, #, 561#723, #, 561#725, #, 561#727, #, 561#729, #, #, 721#730, 721#, #, 723#733, 723#, #, 730#736, #, 730#738, #, 725#740, 725#, #, 727#743, 727#, 582#747, #, 561#749, #, 749#, 578#del, 664#del, 
### 内容
#0, 16:
文档\物理问题\电透镜.ftxt
## end
#2, 235:
+[返回目录](,电透镜)
地址::文档\物理问题\电透镜.ftxt
+[打开]"文档\物理问题\电透镜"
+[打开]"Matlab\SEM"

工具库:...
+[新建阅读窗口](,工具库)

Nini, 打开静电场(文件)
Nini, 打开龙格库塔方法(文件)


笔记:...
正文(html):...
近似轨迹(html):...
近似电场(html):...
+[新建阅读窗口](,近似电场)
+[新建阅读窗口](,近似轨迹)
+[新建阅读窗口](,正文)


## end
#3, 47:
电透镜:...
创建于 20230110

节点数目统计::
+[设置结构](,节点数目统计)
## end
#8, 473:
<!--
+[H函数](,正文)

参考::file:///C:/Users/cheng/Desktop/paper/SEM/Jan20.pdf
+[打开网页](,参考)
-->

%[1].
%[2].
%[3].

<h2>Propagation matrix</h2>
If there are multiple \(\mathbf{R_i}\), then,
%[4].
%[5].
%[6].

If \(d\rightarrow 0\), then,
%[7].
%[8].


<!--
[8].:
式(1)转换为"表达式"
将"\mat{R_1}*\mat{T_1}*\mat{R_2}*\mat{T_2}~\mat{1,\frac{d+d}{\sqrt{V_0}};-\frac{E_1-E_3}{4*\sqrt{V_0}},1}"记作为式(8)


验证公式(M函数):...
RK4轨迹(M函数):...
+[新建阅读窗口](,RK4轨迹)
+[新建阅读窗口](,验证公式)

+[修改天使]
+[H函数](,正文)
-->
## end
#11, 500:
%{
+[M函数](,验证公式)
运行指令"nautilus Matlab/SEM"

笔记:...
calculation_all:...
测试tm_traj:...
tm_traj(M函数):...
lens_matrix(M函数):...
lenses_traj(M函数):...
+[新建阅读窗口](,lens_matrix)
+[新建阅读窗口](,lenses_traj)
+[新建阅读窗口](,测试tm_traj)

原始例子:...
简化透镜:...
对比轨迹_zz:...
多条轨迹:...
保存:...
%}

addpath('Matlab/SEM')

U0=8000;

D=10e-2*ones(1,3);
U=4000*ones(1,3);
Z=[1,2,2.5];

r0=linspace(-1,1,10)*1e-3;
z0=zeros(size(r0));
an0=zeros(size(r0));

[zs,rs]=lenses_traj(z0,r0,an0,U0,D,U,Z);
plot(zs,rs,'-o')

%{
clf
+[M函数](,验证公式)
%}
## end
#14, 100:
lens{2}
V_all
intgnd是宽度变化. 由fcoulomb_interaction计算得到
auto_focus里面有循环. 好像只调用了tm_traj
所以tm_traj里面计算了轨迹
## end
#16, 3375:
%{
+[M函数](,calculation_all)

笔记:...
calculation_all:...
%}

addpath('Matlab\SEM')
clc;
clear all;
close all;

%% define geometry 

% einzel lens
V0 = 8000;
V1 = 4400;%3.987707230110555e3;    %1.614044233312194e4;
V2 = 1700;%3.574309348644629e3;    %1.809231935002980e4;
V_landing = 8000;

lens{1}.volts = [V0, V0, V1, V1, V0, V0];
lens{1}.pos_rel = [-5.5, -3.5, -1.5, 1.5, 3.5, 5.5]*1e-3;         %[-5, -3, -1, 1, 3, 5] % [-10, -7, -3, 3, 7, 10]
lens{1}.pos_abs = 0;

lens{2}.volts = [V0, V0, V2, V2, V0, V0];
lens{2}.pos_rel = [-5.5, -3.5, -1.5, 1.5, 3.5, 5.5]*1e-3;
lens{2}.pos_abs = 85e-3;

pos_source = -350e-3;
pos_cross = [18, 95]*1e-3;  % [12, 95]
pos_screen = pos_cross(end);

flag_auto_focus = 1;
variable_volts_ind = [4,5; 10,11];

flag_coulomb = 1;

scale_x_units = 1e3;        % convert [m] to [mm] for x axis in plots only

V_list = V0;
x_list = pos_source;
electrode_pos = [];
for i = 1:length(lens)
    V_list = [V_list, lens{i}.volts];
    x_list = [x_list, lens{i}.pos_rel+lens{i}.pos_abs];
    electrode_pos = [electrode_pos; reshape(lens{i}.pos_rel,[2,3])'+lens{i}.pos_abs];
end
V_list = [V_list, V_landing];
x_list = [x_list, pos_screen];

x_all = linspace(min(x_list),max(x_list),20000);    % x_all: list of corresponding positions
V_all = interp1(x_list, V_list, x_all, 'Linear');   % V_all: list of voltages

% % cathode lens
% V_all = [linspace(1,8000,40),8000*ones(1,10)];
% x_all = linspace(0,100,length(V_all));
% electrode_ind = [1,2; 40,41];

%% auto focus
if flag_auto_focus == 1
    [V_list, V_all] = auto_focus(x_list, V_list, x_all, variable_volts_ind, pos_cross);
end

%% calculate trajectory
[r_alpha, angle_alpha] = tm_traj(x_all, V_all, [0;1*sqrt(V_all(1))]);

[r_gamma, angle_gamma] = tm_traj(x_all, V_all, [1;0]);  % [pos; angle*sqrt(V)]

mm = angle_alpha(end);      % mm = ai/ao; angular magnification
mag = r_gamma(end);   
display(['angular mag = ', num2str(mm)]);
display(['mag = ', num2str(mag)]);

fig_num = 1;
plot_all(x_all, V_all, electrode_pos, pos_cross, r_alpha, r_gamma, fig_num);

%% calculate coulomb_interaction

if flag_coulomb == 1
    Br = 2e7;           % brightness [A/m2/sr/V]
    alpha = 2e-3;       % source half angle [rad]
    ds = 1e-6;          % source diameter [m]
    PE0 = 8000;         % beam energy [V]
    
    I_factor = ones(size(x_all));       % no aperture for now
    r_factor = ones(size(x_all))*alpha;
    
    I_all = Br*pi/4*ds^2*pi*alpha^2*PE0*I_factor;   % ~1uA/1um^2
    r_s = sqrt((r_alpha.*r_factor).^2+(ds/2*r_gamma).^2);
    
    intgnd = fcoulomb_interaction(r_alpha, r_s, V_all, I_all, mm);
    
    %% plot coulomb interaction

    figure(2);
    subplot(2,1,1);
    plot(x_all*scale_x_units,cumsum(intgnd.*[x_all(2)-x_all(1),diff(x_all)])*1e9, 'LineWidth',1.5);
    xlabel('pos [mm]');
    ylabel('fw50 blur [nm]');
    
    subplot(2,1,2);
    plot(x_all*scale_x_units,intgnd*1e9, 'LineWidth',1.5);
    xlabel('pos [mm]');
    ylabel('differtial fw50 blur [nm/m]');
    
    figure(3);
    hold on;
    plot(x_all*scale_x_units, r_alpha.*r_factor*1e6, 'LineWidth',1.5,'Color','r');
    plot(x_all*scale_x_units, ds/2*r_gamma*1e9, 'LineWidth',1.5,'Color','g');
    plot(x_all*scale_x_units, r_s*1e6, 'LineWidth',1.5,'Color','b','LineStyle','-.');
    legend('r_{alpha}','1000*r_{gamma}','r_{tot}','Location','southwest');
    xlabel('pos [mm]');
    ylabel('r_s [um]');
end
    



## end
#18, 1554:
%{
+[M函数](,验证公式)

笔记:...
calculation_all:...
%}

addpath('Matlab\SEM')
clc;
clear all;
close all;

%% define geometry 

% einzel lens
V0 = 8000;
V1 = 4400;%3.987707230110555e3;    %1.614044233312194e4;
V2 = 1700;%3.574309348644629e3;    %1.809231935002980e4;
V_landing = 8000;

lens{1}.volts = [V0, V0, V1, V1, V0, V0];
lens{1}.pos_rel = [-5.5, -3.5, -1.5, 1.5, 3.5, 5.5]*1e-3;         %[-5, -3, -1, 1, 3, 5] % [-10, -7, -3, 3, 7, 10]
lens{1}.pos_abs = 0;

lens{2}.volts = [V0, V0, V2, V2, V0, V0];
lens{2}.pos_rel = [-5.5, -3.5, -1.5, 1.5, 3.5, 5.5]*1e-3;
lens{2}.pos_abs = 85e-3;

pos_source = -350e-3;
pos_cross = [18, 95]*1e-3;  % [12, 95]
pos_screen = pos_cross(end);

flag_auto_focus = 1;
variable_volts_ind = [4,5; 10,11];

flag_coulomb = 1;

scale_x_units = 1e3;        % convert [m] to [mm] for x axis in plots only

V_list = V0;
x_list = pos_source;
electrode_pos = [];
for i = 1:length(lens)
    V_list = [V_list, lens{i}.volts];
    x_list = [x_list, lens{i}.pos_rel+lens{i}.pos_abs];
    electrode_pos = [electrode_pos; reshape(lens{i}.pos_rel,[2,3])'+lens{i}.pos_abs];
end
V_list = [V_list, V_landing];
x_list = [x_list, pos_screen];

x_all = linspace(min(x_list),max(x_list),20000);    % x_all: list of corresponding positions
V_all = interp1(x_list, V_list, x_all, 'Linear');   % V_all: list of voltages


%% calculate trajectory
[r_alpha, angle_alpha] = tm_traj(x_all, V_all, [0;1*sqrt(V_all(1))]);
[r_gamma, angle_gamma] = tm_traj(x_all, V_all, [1;0]);  % [pos; angle*sqrt(V)]


%{
plot(x_list,V_list)
plot(x_all,V_all)
+[M函数](,验证公式)
%}
## end
#20, 823:
%{他

笔记:...
calculation_all:...
+[新建阅读窗口](,calculation_all)

保存:...
%}

addpath('Matlab\SEM')
clc;
clear all;
close all;

%% define geometry 
x_list=[-0.35 -0.0055 -0.0035 -0.0015 0.0015 0.0035 0.0055 0.0795 0.0815 0.0835 0.0865 0.0885 0.0905 0.095];
V_list=[8000 8000 8000 4400 4400 8000 8000 8000 8000 1700 1700 8000 8000 8000];


x_all = linspace(min(x_list),max(x_list),20000);
V_all = interp1(x_list, V_list, x_all, 'Linear');


%% calculate trajectory
[r_alpha, angle_alpha] = tm_traj(x_all, V_all, [0;1*sqrt(V_all(1))]);
[r_gamma, angle_gamma] = tm_traj(x_all, V_all, [1;0]);

plot([x_all,fliplr(x_all)],[r_alpha,-fliplr(r_alpha)],...
[x_all,fliplr(x_all)],[r_gamma,-fliplr(r_gamma)])



%{
size(x_list)
clipboard('copy',V_list)

plot(x_list,V_list)
plot(x_all,V_all,x_all,r_gamma/max(r_gamma)*2000)
+[M函数](,验证公式)
%}
## end
#22, 905:
%{
地址::Matlab\SEM\tm_traj.m
+[保存M函数](,tm_traj)
%}


% transfer matrix method: calculate trajectory (position, voltage, initial
% position and angle)
function [r_all, angle_all] = tm_traj(x_all, V_all, vec0)
    %% transfer matrix calculation
    E_all = zeros(length(x_all),2);
    for i = 1:length(x_all)-1
        E_all(i+1) = (V_all(i+1)-V_all(i))/(x_all(i+1)-x_all(i));
    end
    
    Ua = zeros([2,2,length(x_all)-1]);
    Ub = zeros([2,2,length(x_all)-1]);
    
    for i = 1:length(x_all)-1
        Ua(:,:,i) = tm_dflt(E_all(i),E_all(i+1),V_all(i));
        Ub(:,:,i) = tm_drift(V_all(i),V_all(i+1),x_all(i+1)-x_all(i));
    end
    
    %% vector calculation
    vec = zeros(2,length(x_all));
    vec(:,1) = vec0; % [pos; angle*sqrt(V)]
    for i = 1:length(x_all)-1
        vec(:,i+1) = Ub(:,:,i)*Ua(:,:,i)*vec(:,i);
    end
    
    r_all = vec(1,:);
    angle_all = vec(2,:)./sqrt(V_all);
end
## end
#25, 20:
Matlab\SEM\tm_traj.m
## end
#31, 89:
\mathbf{T}=\begin{pmatrix}
1&\frac{2\ d}{\sqrt{V_{1}}+\sqrt{V_{2}}}\\ 0&1
\end{pmatrix}


## end
#33, 53:
\mat{T}=\mat{1,\frac{2*d}{\sqrt{V_1}+\sqrt{V_2}};0,1}
## end
#37, 87:
\mathbf{R}=\begin{pmatrix}
1&0\\ -\frac{E_{1}-E_{2}}{4\ \sqrt{V_{0}}}&1
\end{pmatrix}


## end
#39, 253:
\begin{cases}
r_{s}=\sqrt{\left(r\ \alpha\right)^{2}+\left(ds/2\ r_{0}\right)^{2}}\\ \chi=c_{x}\ I\ r_{s}/\sqrt{V}\\ Int=-\frac{c_{a}}{mm\ \sqrt{V\ _{end}}}\ \frac{\left|r\right|\ I^{2}}{V^{3/2}}\ \left(\chi^{8/7}+\chi^{-6/7}\right)^{-7/6}
\end{cases}


## end
#40, 49:
\mat{R}=\mat{1,0;-\frac{E_1-E_2}{4*\sqrt{V_0}},1}
## end
#44, 50:
file:///C:/Users/cheng/Desktop/paper/SEM/Jan20.pdf
## end
#46, 158:
\eqs{r_s=\sqrt{(r*\alpha)^2+(ds/2*r_0)^2};
\chi=c_x*I*r_s/\sqrt{V};
Int=-\frac{c_a}{mm*\sqrt{V[end]}}*\frac{[r]*I^2}{V^{3/2}}*(\chi^{8/7}+\chi^{-6/7})^{-7/6}}
## end
#50, 2645:
%{
+[M函数](,RK4轨迹)

磁场轨迹:...
physics_constant(M函数):...
addpath(M函数):...

加速电场:...
透镜电场_函数:...
透镜电场_插值:...
SI单位轨迹:...
插值与矩阵方法对比:...
函数与矩阵方法对比:...
(运行时间超过半个小时, 但是结果和插值方法差不多. 误差应该不是来自于插值)
RK4问题:...
+[新建阅读窗口](,透镜电场_函数)

测试ODE:...

保存:...
%}

physics_constant;
addpath('Matlab\Physics');
addpath('Matlab/Physics');
addpath('Matlab/SEM');

N=1;
Ni=800;
Ue=3000;
U0=-2000;

%{
+[M函数](,RK4轨迹)
%}

Dy0=1e-4;
y=linspace(-1,1,N)*Dy0;
% y=Dy0;
x=zeros(size(y));
z=zeros(size(y));

gamma=(me*c^2+Ue*e)/me/c^2;
vx0=sqrt(1-(1/gamma)^2)*c;
vx=vx0*ones(1,N);
vy=zeros(size(vx));
vz=zeros(size(vx));

% px=Ue*e/c*ones(1,N);
% py=(rand(1,N)-0.5)*0;
% pz=(rand(1,N)-0.5)*0;

dt=200e-12;
t=0;

%{
+[M函数](,RK4轨迹)
%}

% Einzel_lens_phi_3D field
B_z=@(x,y)zeros(size(x));
E_x=@(x,y)zeros(size(x));
E_y=@(x,y)zeros(size(x));

H=1;
R=2;
R0=0.1;

pt0=[2.5,0,0];
Eulers0=[90,90,0];

U=@(X,Y,Z)Einzel_lens_phi_3D(X,Y,Z,pt0,Eulers0,U0,H,R0,R);

dx=1e-5;
E_x0=@(X,Y)(U(X+dx,Y,0*X)-U(X-dx,Y,0*X))/2/dx;
E_y0=@(X,Y)(U(X,Y+dx,0*X)-U(X,Y-dx,0*X))/2/dx;
% Ez=(U(X,Y,Z)-U(X,Y,Z-dx))/dx;

% x0=linspace(0,8,100);
x0=linspace(-1,1,200)*H+pt0(1);
y0=linspace(-1,1,100)*2*Dy0;
[X0,Y0]=meshgrid(x0,y0);
Ex=E_x0(X0,Y0);
Ey=E_y0(X0,Y0);

E_x=@(x,y)interp2(X0,Y0,Ex,x,y);
E_y=@(x,y)interp2(X0,Y0,Ey,x,y);


%{
+[M函数](,RK4轨迹)
%}

% matrix trajectory
U0m=Ue;
Um=[U0+Ue,Ue];
Dm=[H,H];
Zm=[pt0(1)-H/2,5];

z0=x;
r0=y;
an0=zeros(size(z0));

[zms,rms]=lenses_traj(z0,r0,an0,U0m,Dm,Um,Zm);

% motion
xs=zeros(Ni,N);
ys=zeros(Ni,N);


%{
+[M函数](,RK4轨迹)
%}

xs(1,:)=x;
ys(1,:)=y;
for i=2:Ni
if x(1)<pt0(1)-H*0.9 || x(1)>pt0(1)+H*0.9
% [x,y,px,py]=EM_re_motion_RK4(x,y,px,py,dt,t,e,me,B_z,E_x,E_y);
% [x,y,vx,vy]=EM_motion_RK4(x,y,vx,vy,dt,t,e,me,B_z,B_z,B_z);
% [x,y,vx,vy]=EM_motion_BEM(x,y,vx,vy,dt,t,e,me,B_z,B_z,B_z);
[x,y,vx,vy]=EM_motion_CM(x,y,vx,vy,dt,t,e,me,B_z,B_z,B_z);
else
% [x,y,px,py]=EM_re_motion_RK4(x,y,px,py,dt,t,e,me,B_z,E_x,E_y);
% [x,y,vx,vy]=EM_motion_RK4(x,y,vx,vy,dt,t,e,me,B_z,E_x,E_y);
% [x,y,vx,vy]=EM_motion_BEM(x,y,vx,vy,dt,t,e,me,B_z,E_x,E_y);
[x,y,vx,vy]=EM_motion_CM(x,y,vx,vy,dt,t,e,me,B_z,E_x,E_y);
end

Dx=x-x';
Dy=y-y';
R=sqrt(Dx.^2+Dy.^2);
Fx=1./R.^2.*Dx;
Fy=1./R.^2.*Dy;
Fx(R==0)=0;
Fy(R==0)=0;

xs(i,:)=x;
ys(i,:)=y;
end



% x0=linspace(0,8,100);
% y0=linspace(-1,1,100);
[X0,Y0]=meshgrid(x0,y0);
u0=abs(U(X0,Y0,0*X0));


clf
hold on
image(x0,y0,u0/max(max(u0))*255)
plot(xs,ys,'b-o',zms,rms,'r--o')
colormap('gray')
axis([pt0(1)-H,pt0(1)+H,-2*Dy0,2*Dy0])



%{
max(y0)
plot(zms,rms)
clf
plot(u0)

Nini, 打开龙格库塔方法的EM_re_motion_RK4(节点)
Nini, 打开龙格库塔方法的EM_motion_RK4(节点)
Nini, 打开龙格库塔方法(文件)
运行指令"nautilus Matlab/Physics"
运行指令"tree Matlab/Physics"
+[M函数](,RK4轨迹)
%}
## end
#53, 587:
%{
+[M函数](,RK4轨迹)
%}

physics_constant;
addpath('Matlab\Physics');

N=10;
Ni=100;
q=1;
m=1;

x=rand(1,N);
y=rand(1,N);
z=rand(1,N);
px=rand(1,N)+200;
py=rand(1,N);
pz=rand(1,N);
dt=0.1;
t=0;

B_z=@(x,y)ones(size(x));
E_x=@(x,y)zeros(size(x));
E_y=@(x,y)zeros(size(x));

xs=zeros(Ni,N);
ys=zeros(Ni,N);

for i=1:Ni
[x,y,px,py]=EM_re_motion_RK4(x,y,px,py,dt,t,q,m,B_z,E_x,E_y);

Dx=x-x';
Dy=y-y';
R=sqrt(Dx.^2+Dy.^2);
Fx=1./R.^2.*Dx;
Fy=1./R.^2.*Dy;
Fx(R==0)=0;
Fy(R==0)=0;

px=px+sum(Fx)*dt;
py=py+sum(Fy)*dt;

xs(i,:)=x;
ys(i,:)=y;
end

plot(xs,ys)
axis equal



%{
clf
+[M函数](,RK4轨迹)
%}
## end
#55, 293:

电子排斥::file:////media/xiantao/Elements/paper/SEM/Jan20.pdf
AL电场::file:///media/xiantao/Elements/paper/SEM/sise09.pdf
基础1::file:///media/xiantao/Elements/paper/SEM/ELens.pdf
基础2::file:///media/xiantao/Elements/paper/SEM/EMF_Lens.PDF

+[打开网页](,基础2)
+[打开网页](,基础1)
+[打开网页](,AL电场)
+[打开网页](,电子排斥)



## end
#57, 51:
file:////media/xiantao/Elements/paper/SEM/Jan20.pdf
## end
#59, 51:
file:///media/xiantao/Elements/paper/SEM/sise09.pdf
## end
#61, 50:
file:///media/xiantao/Elements/paper/SEM/ELens.pdf
## end
#63, 53:
file:///media/xiantao/Elements/paper/SEM/EMF_Lens.PDF
## end
#68, 393:
%{
地址::/home/xiantao/Documents/MATLAB/physics_constant.m
+[保存M函数](,physics_constant)
%}

e=1.602176634e-19;
G=6.67430e-11;
h=6.62607015e-34;
c=299792458;
epsilon0=8.8541878128e-12;
epsilon_0=8.8541878128e-12;
mu_0=1.25663706212e-6;

me=9.1093837015e-31;
m_e=9.1093837015e-31;
mp=1.67262192369e-27;
m_p=1.67262192369e-27;

kB=1.380649e-23;
k_B=1.380649e-23;

alpha=e^2/2/epsilon_0/h/c;


%{

%}
## end
#71, 49:
/home/xiantao/Documents/MATLAB/physics_constant.m
## end
#76, 113:
%{
地址::/home/xiantao/Documents/MATLAB/addpath.m
+[保存M函数](,addpath)
%}

function addpath(address)

addpath

end

🐵
## end
#79, 40:
/home/xiantao/Documents/MATLAB/addpath.m
## end
#81, 1152:
%{
+[M函数](,RK4轨迹)

磁场轨迹:...
physics_constant(M函数):...
addpath(M函数):...

加速电场:
%}

physics_constant;
addpath('Matlab\Physics');
addpath('Matlab/Physics');

N=10;
Ni=100;
q=1;
m=1;

x=rand(1,N)*0;
y=rand(1,N);
z=rand(1,N);
px=rand(1,N)+200;
py=rand(1,N);
pz=rand(1,N);
dt=0.1;
t=0;

B_z=@(x,y)zeros(size(x));
E_x=@(x,y)zeros(size(x));
E_y=@(x,y)zeros(size(x));

x_11=1000;
x_12=1100;
E_1=-150;

x_21=1200;
x_22=1300;
E_2=200;

x_31=1400;
x_32=1500;
E_3=-200;

x_41=1600;
x_42=1700;
E_4=200;

%{
+[M函数](,RK4轨迹)
%}

E_x=@(x,y)(sign(x-x_11)+1)/2.*(sign(x_12-x)+1)/2*E_1...
+(sign(x-x_21)+1)/2.*(sign(x_22-x)+1)/2*E_2...
+(sign(x-x_31)+1)/2.*(sign(x_32-x)+1)/2*E_3...
+(sign(x-x_41)+1)/2.*(sign(x_42-x)+1)/2*E_4;

xs=zeros(Ni,N);
ys=zeros(Ni,N);

for i=1:Ni
[x,y,px,py]=EM_re_motion_RK4(x,y,px,py,dt,t,q,m,B_z,E_x,E_y);

Dx=x-x';
Dy=y-y';
R=sqrt(Dx.^2+Dy.^2);
Fx=1./R.^2.*Dx;
Fy=1./R.^2.*Dy;
Fx(R==0)=0;
Fy(R==0)=0;

px=px+sum(Fx)*dt;
py=py+sum(Fy)*dt;

xs(i,:)=x;
ys(i,:)=y;
end

x0=linspace(0,2000,100);

subplot(2,1,1)
plot(xs,ys)
axis equal
axis([0,2000,-150,150])

subplot(2,1,2)
plot(x0,E_x(x0,x0*0))
axis([0,2000,-200,200])



%{
clf
+[M函数](,RK4轨迹)
%}
## end
#83, 1311:
%{
+[M函数](,透镜电场_函数)

磁场轨迹:...
physics_constant(M函数):...
addpath(M函数):...

加速电场:...
透镜电场_函数:...
%}

physics_constant;
addpath('Matlab\Physics');
addpath('Matlab/Physics');

N=1000;
Ni=30;
q=1;
m=1;

x=rand(1,N)*0;
y=(rand(1,N)-0.5)*0.1;
z=(rand(1,N)-0.5)*0.1;
px=rand(1,N)+200;
py=(rand(1,N)-0.5)*0;
pz=(rand(1,N)-0.5)*0;
dt=0.001;
t=0;

B_z=@(x,y)zeros(size(x));
E_x=@(x,y)zeros(size(x));
E_y=@(x,y)zeros(size(x));

% Einzel_lens_phi_3D
U0=8000;
U1=0;
H=1;
R=2;
R0=0.1;

pt0=[2,0,0];
Eulers0=[90,90,0];

U=@(X,Y,Z)Einzel_lens_phi_3D(X,Y,Z,pt0,Eulers0,U0,H,R0,R);

dx=1e-5;
E_x=@(X,Y)(U(X,Y,0*X)-U(X-dx,Y,0*X))/dx;
E_y=@(X,Y)(U(X,Y,0*X)-U(X,Y-dx,0*X))/dx;
% Ez=(U(X,Y,Z)-U(X,Y,Z-dx))/dx;


xs=zeros(Ni,N);
ys=zeros(Ni,N);

xs(1,:)=x;
ys(1,:)=y;
for i=2:Ni
[x,y,px,py]=EM_re_motion_RK4(x,y,px,py,dt,t,q,m,B_z,E_x,E_y);

Dx=x-x';
Dy=y-y';
R=sqrt(Dx.^2+Dy.^2);
Fx=1./R.^2.*Dx;
Fy=1./R.^2.*Dy;
Fx(R==0)=0;
Fy(R==0)=0;

%px=px+sum(Fx)*dt;
%py=py+sum(Fy)*dt;

xs(i,:)=x;
ys(i,:)=y;
end

x0=linspace(0,8,100);
y0=linspace(-1,1,100);
[Y,X]=meshgrid(y0,x0);

subplot(2,1,1)
plot(xs,ys,'-o')
%axis equal
%axis([0,8,-2,2])

subplot(2,1,2)
surf(X,Y,E_y(X,Y))
axis([0,8,-2,2])
shading interp
view([0,90])
axis equal


U([0,0],[10,0],[0,0])
%{
clf
size(Y*0)
Einzel_lens_phi_3D(X,Y,X*0,pt0,Eulers0,U0,H,R0,R);
+[M函数](,RK4轨迹)
%}
## end
#85, 1437:
%{
+[M函数](,透镜电场_插值)

磁场轨迹:...
physics_constant(M函数):...
addpath(M函数):...

加速电场:...
透镜电场_函数:...
透镜电场_插值:...
%}

physics_constant;
addpath('Matlab\Physics');
addpath('Matlab/Physics');

N=1000;
Ni=30;
q=1;
m=1;

x=rand(1,N)*0;
y=(rand(1,N)-0.5)*0.1;
z=(rand(1,N)-0.5)*0.1;
px=rand(1,N)+200;
py=(rand(1,N)-0.5)*0;
pz=(rand(1,N)-0.5)*0;
dt=0.001;
t=0;

B_z=@(x,y)zeros(size(x));
E_x=@(x,y)zeros(size(x));
E_y=@(x,y)zeros(size(x));

% Einzel_lens_phi_3D
U0=8000;
U1=0;
H=1;
R=2;
R0=0.1;

pt0=[2,0,0];
Eulers0=[90,90,0];

U=@(X,Y,Z)Einzel_lens_phi_3D(X,Y,Z,pt0,Eulers0,U0,H,R0,R);

dx=1e-5;
E_x0=@(X,Y)(U(X+dx,Y,0*X)-U(X-dx,Y,0*X))/2/dx;
E_y0=@(X,Y)(U(X,Y+dx,0*X)-U(X,Y-dx,0*X))/2/dx;
% Ez=(U(X,Y,Z)-U(X,Y,Z-dx))/dx;

x0=linspace(0,8,100);
y0=linspace(-1,1,100);
[X0,Y0]=meshgrid(x0,y0);
Ex=E_x0(X0,Y0);
Ey=E_y0(X0,Y0);

E_x=@(x,y)interp2(X0,Y0,Ex,x,y);
E_y=@(x,y)interp2(X0,Y0,Ey,x,y);

xs=zeros(Ni,N);
ys=zeros(Ni,N);


xs(1,:)=x;
ys(1,:)=y;
for i=2:Ni
[x,y,px,py]=EM_re_motion_RK4(x,y,px,py,dt,t,q,m,B_z,E_x,E_y);

Dx=x-x';
Dy=y-y';
R=sqrt(Dx.^2+Dy.^2);
Fx=1./R.^2.*Dx;
Fy=1./R.^2.*Dy;
Fx(R==0)=0;
Fy(R==0)=0;

%px=px+sum(Fx)*dt;
%py=py+sum(Fy)*dt;

xs(i,:)=x;
ys(i,:)=y;
end


subplot(2,1,1)
plot(xs,ys,'-o')
%axis equal
%axis([0,8,-2,2])

subplot(2,1,2)
surf(X,Y,E_y(X,Y))
axis([0,8,-2,2])
shading interp
view([0,90])
axis equal


U([0,0],[10,0],[0,0])
%{
clf
size(Y*0)
Einzel_lens_phi_3D(X,Y,X*0,pt0,Eulers0,U0,H,R0,R);
+[M函数](,RK4轨迹)
%}
## end
#87, 50:


电透镜场景转代码:...
+[新建阅读窗口](,电透镜场景转代码)
封印'电透镜场景转代码'


## end
#89, 22:


召唤规则:...
降临规则:...



## end
#91, 189:
"""


"""

+召唤规则(_媒介,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_凭依)...

->[==]"电透镜场景转代码"(,召唤星辰)...

->+整理代码(_媒介,_凭依)->+的(操作,+整理代码)...
->+单体代码(_媒介,_凭依)->+的(操作,+单体代码)...
->+设置变量(_媒介,_凭依)->+的(操作,+设置变量)



## end
#93, 42:
+[粘贴](,降临规则)

设置变量:...
单体代码:...
整理代码:...


## end
#95, 61:
"""


"""

is_var[1]+=1
ans='obj_%d'%(is_var[1])
state=True


## end
#96, 59:
"""


"""
is_var[0]+=1
ans='bg_%d'%(is_var[0])
state=True


## end
#99, 394:
"""
P代码:...
P代码1:...

"""

+描述结构(,_场景)->+操作(+描述结构,)...
->的(描述结构,P代码)->的(描述结构,P代码1)...

->[python]"
is_var=[0,0]
state=True
"(Python,)...
->[]{
    []=>的(_场景,_物体)->_物体->在(_物体,空间点)...
    =>+变量名(,_物体)->+的(+操作,+变量名)...
    ->[]{
        []:->[]{的(_物体,速度)->速度}...
            ->+[code]([python]#1,P代码1)->[python]#1(Python,+变量名),
        ->+[code]([python]#0,P代码)->[python]#0(Python,+变量名)
    }
}



## end
#102, 305:
"""
描述结构:...
库:...

"""

+设置变量(_场景,_代码)->+[del](,+设置变量)...
->的(设置变量,描述结构)->的(设置变量,库)...

->[]{
    []:->的(_代码,命名空间)->命名空间,->+的(_代码,+命名空间)
}->的(_代码,命名空间)...

->+[code]([想],描述结构)->[想](,_场景)...

->操作([想],)...
->[]{
    []=>的(操作,_操作)->_操作(,_物体)->_物体(,)...
    =>+的(命名空间,+变量)->+变量(,_物体)->[m_text](_操作,+变量)
}



## end
#104, 1022:
%{
+[M函数](,%[标题])
%}

physics_constant;
addpath('Matlab/Physics');
addpath('Matlab/SEM');

N=100;
Ni=30;
q=1;
m=1;

%设置电子源

dt=0.0003;
t=0;

B_z=@(x,y)zeros(size(x));
U=@(x,y,z)zeros(size(x));

% Einzel_lens_phi_3D
%设置透镜


dx=1e-6;
E_x0=@(X,Z)(U(X+dx,0*X,Z)-U(X-dx,0*X,Z))/2/dx;
E_z0=@(X,Z)(U(X,0*X,Z+dx)-U(X,0*X,Z-dx))/2/dx;

x0=linspace(-0.3,0.3,300);
z0=linspace(-0.1,2,300);
[X0,Z0]=meshgrid(x0,z0);
Ex=E_x0(X0,Z0);
Ez=E_z0(X0,Z0);

E_x=@(x,z)interp2(X0,Z0,Ex,x,z);
E_z=@(x,z)interp2(X0,Z0,Ez,x,z);

xs=zeros(Ni,N);
zs=zeros(Ni,N);


xs(1,:)=x;
zs(1,:)=z;
pxs(1,:)=px;
pzs(1,:)=pz;

for i=2:Ni
[x,z,px,pz]=EM_re_motion_RK4(x,z,px,pz,dt,t,q,m,B_z,E_x,E_z);

xs(i,:)=x;
zs(i,:)=z;
pxs(i,:)=px;
pzs(i,:)=pz;
end



subplot(2,1,1)
plot(zs,xs,'-o')
%axis equal
%axis([0,8,-2,2])

subplot(2,1,2)
surf(X0,Z0,U(X0,0*Z0,Z0))
% surf(X0,Z0,Ex)
view([90,90])
shading interp
axis equal
axis([-0.3,0.3,0,2])


figure
subplot(1,2,1)
hist(px./pz/1e-3)
xlabel('[mrad]')
subplot(1,2,2)
hist(x/1e-3)
xlabel('[mm]')


%{
+[M函数](,%[标题])
%}
## end
#105, 74:
%{

%}


pt_x=get(gca,'Xlim');
pt_y=get(gca,'Ylim');
axis_=[pt_x,pt_y];



## end
#108, 378:
"""
Nini, 打开PPT(文件)
M代码:...
M模板:...

样本:...

"""

+整理代码(,_代码)->+[del](,+整理代码)...
->的(整理代码,M模板)->的(整理代码,M代码)...

->的(_代码,代码结构)...

->+[matlab](Matlab,)->+[code](+[matlab],M代码)...

->+[标题](_代码,)...
->+[模板文本](M模板,_代码)->+[.](+[模板文本],+[标题])...
->[]{
    []=>的(代码结构,_模块)->_模块=>+[.](+[模板文本],_模块)
}...
->+[o]"axis_"(+[matlab],+[临时文本])->+[.]"axis_"(+[模板文本],+[临时文本])...

->+[删除结构](,_代码)


## end
#111, 463:
"""
描述结构:...
库:...
+[新建阅读窗口](,描述结构)

"""

+单体代码(_场景,_代码)->+[del](,+单体代码)...
->的(单体代码,描述结构)->的(单体代码,库)...

->[]{
    []:->的(_代码,代码结构)->代码结构,
    ->+的(_代码,+代码结构)...
        ->+的(+代码结构,+设置电子源)->+的(+代码结构,+设置透镜)...
        ->+的(+代码结构,+设置观测平面)
}...

->+[code]([想],描述结构)->[想](,_场景)...

->操作([想],)...
->[]{
    []=>的(操作,_操作)->_操作(,_物体)->_物体(,)...
    =>[说](,_操作)...
        ->的(库,_条目)->_条目->[eq](_条目,_操作)...
        ->+[做](_物体,_代码)->+[code](+[做],_条目)->+[.](+[做],_场景)
}



## end
#113, 143:

+[del](,设置电子源)
设置电子源:...
设置透镜:...
设置观测平面:...
将条目"设置透镜"复制为条目"设置电子源"

将'设置透镜'的"运动物体"替换为"设置透镜"
在选择区域中, 将'设置透镜'的"内径"替换为"电压"
+[新建阅读窗口](,设置透镜)






## end
#115, 328:
"""


"""

+描述结构(,_场景)->+操作(+描述结构,)...

->[]{
    []=>的(_场景,_物体)->_物体(,)...
    =>[]:
        ->[]{的(_物体,半径)->半径}...
            ->+设置透镜(,_物体)->+的(+操作,+设置透镜),
        ->[]{的(_物体,能量)->能量}...
            ->+设置电子源(,_物体)->+的(+操作,+设置电子源),
        ->[]{的(_物体,宽度)->宽度}...
            ->+设置观测平面(,_物体)->+的(+操作,+设置观测平面),
        ->[]
}



## end
#117, 1865:
%{
+[M函数](,样本)
%}

physics_constant;
addpath('Matlab/Physics');
addpath('Matlab/SEM');

N=100;
Ni=30;
q=1;
m=1;

y=(rand(1,N)-0.5)*0.01;
x=(rand(1,N)-0.5)*0.01;
z=rand(1,N)*0;
pz=rand(1,N)+200;
py=(rand(1,N)-0.5)*0;
px=(rand(1,N)-0.5)*0;

dt=0.0003;
t=0;

B_z=@(x,y)zeros(size(x));
U=@(x,y,z)zeros(size(x));

% Einzel_lens_phi_3D
u_bg_1=8000;
H_bg_1=0.1;
R_bg_1=0.3;
R0_bg_1=0.02;
pt_bg_1=[0.0, 0.0, 0.5];
Eulers_bg_1=[0,0,0];

U_bg_1=@(X,Y,Z)Einzel_lens_phi_3D(X,Y,Z,pt_bg_1,Eulers_bg_1,u_bg_1,H_bg_1,R0_bg_1,R_bg_1);
U=@(X,Y,Z)U(X,Y,Z)+U_bg_1(X,Y,Z);

u_bg_2=8000;
H_bg_2=1.1;
R_bg_2=0.3;
R0_bg_2=0.06;
pt_bg_2=[0.0, 0.0, 1.0];
Eulers_bg_2=[0,0,0];

U_bg_2=@(X,Y,Z)Einzel_lens_phi_3D(X,Y,Z,pt_bg_2,Eulers_bg_2,u_bg_2,H_bg_2,R0_bg_2,R_bg_2);
U=@(X,Y,Z)U(X,Y,Z)+U_bg_2(X,Y,Z);

u_bg_3=8000;
H_bg_3=0.1;
R_bg_3=0.3;
R0_bg_3=0.02;
pt_bg_3=[0.0, 0.0, 1.5];
Eulers_bg_3=[0,0,0];

U_bg_3=@(X,Y,Z)Einzel_lens_phi_3D(X,Y,Z,pt_bg_3,Eulers_bg_3,u_bg_3,H_bg_3,R0_bg_3,R_bg_3);
U=@(X,Y,Z)U(X,Y,Z)+U_bg_3(X,Y,Z);



dx=1e-6;
E_x0=@(X,Z)(U(X+dx,0*X,Z)-U(X-dx,0*X,Z))/2/dx;
E_z0=@(X,Z)(U(X,0*X,Z+dx)-U(X,0*X,Z-dx))/2/dx;

x0=linspace(-0.3,0.3,300);
z0=linspace(-0.1,2,300);
[X0,Z0]=meshgrid(x0,z0);
Ex=E_x0(X0,Z0);
Ez=E_z0(X0,Z0);

E_x=@(x,z)interp2(X0,Z0,Ex,x,z);
E_z=@(x,z)interp2(X0,Z0,Ez,x,z);

xs=zeros(Ni,N);
zs=zeros(Ni,N);


xs(1,:)=x;
zs(1,:)=z;
pxs(1,:)=px;
pzs(1,:)=pz;

for i=2:Ni
[x,z,px,pz]=EM_re_motion_RK4(x,z,px,pz,dt,t,q,m,B_z,E_x,E_z);

xs(i,:)=x;
zs(i,:)=z;
pxs(i,:)=px;
pzs(i,:)=pz;
end



subplot(2,1,1)
plot(zs,xs,'-o')
%axis equal
%axis([0,8,-2,2])

subplot(2,1,2)
surf(X0,Z0,U(X0,0*Z0,Z0))
% surf(X0,Z0,Ex)
view([90,90])
shading interp
axis equal
axis([-0.3,0.3,0,2])


figure
subplot(1,2,1)
hist(px./pz/1e-3)
xlabel('[mrad]')
subplot(1,2,2)
hist(x/1e-3)
xlabel('[mm]')


%{
clf
size(Y*0)
Einzel_lens_phi_3D(X,Y,X*0,pt0,Eulers0,U0,H,R0,R);
+[M函数](,样本)
%}
## end
#119, 745:
"""
M代码:...
M模板:...
+[新建阅读窗口](,测试代码)

"""

+设置电子源(_物体,_代码)->+[del](,+设置电子源)...
->的(设置电子源,M代码)->的(设置电子源,M模板)...

->.(+设置电子源,_场景)...

->的(_代码,命名空间)->的(命名空间,变量)->变量(,_物体)...
->的(_代码,代码结构)->的(代码结构,设置电子源#0)...

->[]{
    []:->在(_物体,空间点)->空间点, ->+在(_物体,+空间点)->+空间点"0,0,0"
}...
->[]{
    []:->朝向(_物体,方向)->方向, ->+朝向(_物体,+方向)->+方向"0,0,0"
}...
->[]{
    []:->的(_物体,能量)->能量, ->+的(_物体,+能量)->+能量"0"
}...
->[]{
    []:->的(_物体,尺寸)->尺寸, ->+的(_物体,+尺寸)->+尺寸"0"
}...
->[]{
    []:->的(_物体,发散度)->发散度, ->+的(_物体,+发散度)->+发散度"0"
}...

->的(_物体,发散度)->的(_物体,能量)->的(_物体,尺寸)...
->在(_物体,空间点)->朝向(_物体,方向)...

->+[模板文本](M模板,+[增加内容2]#1)->+[增加内容2]#1(,设置电子源#0)...
->+[.](+[模板文本],变量)->+[.](+[模板文本],空间点)->+[.](+[模板文本],方向)...
->+[.](+[模板文本],能量)->+[.](+[模板文本],发散度)->+[.](+[模板文本],尺寸)



## end
#124, 183:
pt_%变量=[%空间点];
y=(rand(1,N)-0.5)*%尺寸+pt_%变量(2);
x=(rand(1,N)-0.5)*%尺寸+pt_%变量(1);
z=rand(1,N)*0+pt_%变量(3);
pz=200*ones(1,N);
py=(rand(1,N)-0.5)*%发散度.*pz;
px=(rand(1,N)-0.5)*%发散度.*pz;


## end
#127, 189:
"""


"""

+召唤规则(_媒介,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_凭依)...

->[==]"电透镜场景转代码"(,召唤星辰)...

->+整理代码(_媒介,_凭依)->+的(操作,+整理代码)...
->+单体代码(_媒介,_凭依)->+的(操作,+单体代码)...
->+设置变量(_媒介,_凭依)->+的(操作,+设置变量)



## end
#129, 8098:
电透镜场景转代码#0"

召唤规则:...
降临规则:...


"(,)
的#1""(电透镜场景转代码#0,召唤规则#2)
召唤规则#2"\"\"\"


\"\"\"

+召唤规则(_媒介,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_凭依)...

->[==]\"电透镜场景转代码\"(,召唤星辰)...

->+整理代码(_媒介,_凭依)->+的(操作,+整理代码)...
->+单体代码(_媒介,_凭依)->+的(操作,+单体代码)...
->+设置变量(_媒介,_凭依)->+的(操作,+设置变量)


"(,)
的#3""(电透镜场景转代码#0,降临规则#4)
降临规则#4"+[粘贴](,降临规则)

设置变量:...
单体代码:...
整理代码:...
"(,)
的#5""(降临规则#4,设置变量#6)
设置变量#6"\"\"\"
描述结构:...
库:...

\"\"\"

+设置变量(_场景,_代码)->+[del](,+设置变量)...
->的(设置变量,描述结构)->的(设置变量,库)...

->[]{
    []:->的(_代码,命名空间)->命名空间,->+的(_代码,+命名空间)
}->的(_代码,命名空间)...

->+[code]([想],描述结构)->[想](,_场景)...

->操作([想],)...
->[]{
    []=>的(操作,_操作)->_操作(,_物体)->_物体(,)...
    =>+的(命名空间,+变量)->+变量(,_物体)->[m_text](_操作,+变量)
}


"(,)
的#7""(设置变量#6,库#8)
库#8""(,)
的#9""(设置变量#6,描述结构#10)
描述结构#10"\"\"\"
P代码:...
P代码1:...

\"\"\"

+描述结构(,_场景)->+操作(+描述结构,)...
->的(描述结构,P代码)->的(描述结构,P代码1)...

->[python]\"
is_var=[0,0]
state=True
\"(Python,)...
->[]{
    []=>的(_场景,_物体)->_物体->在(_物体,空间点)...
    =>+变量名(,_物体)->+的(+操作,+变量名)...
    ->[]{
        []:->[]{的(_物体,速度)->速度}...
            ->+[code]([python]#1,P代码1)->[python]#1(Python,+变量名),
        ->+[code]([python]#0,P代码)->[python]#0(Python,+变量名)
    }
}


"(,)
的#11""(描述结构#10,P代码1#12)
P代码1#12"\"\"\"


\"\"\"

is_var[1]+=1
ans='obj_%d'%(is_var[1])
state=True

"(,)
的#13""(描述结构#10,P代码#14)
P代码#14"\"\"\"


\"\"\"
is_var[0]+=1
ans='bg_%d'%(is_var[0])
state=True

"(,)
的#15""(降临规则#4,整理代码#16)
整理代码#16"\"\"\"
Nini, 打开PPT(文件)
M代码:...
M模板:...

样本:...

\"\"\"

+整理代码(,_代码)->+[del](,+整理代码)...
->的(整理代码,M模板)->的(整理代码,M代码)...

->的(_代码,代码结构)...

->+[matlab](Matlab,)->+[code](+[matlab],M代码)...

->+[标题](_代码,)...
->+[模板文本](M模板,_代码)->+[.](+[模板文本],+[标题])...
->[]{
    []=>的(代码结构,_模块)->_模块=>+[.](+[模板文本],_模块)
}...
->+[o]\"axis_\"(+[matlab],+[临时文本])->+[.]\"axis_\"(+[模板文本],+[临时文本])...

->+[删除结构](,_代码)

"(,)
的#17""(整理代码#16,M模板#18)
M模板#18"%{
+[M函数](,%[标题])
%}

physics_constant;
addpath('Matlab/Physics');
addpath('Matlab/SEM');

N=100;
Ni=30;
q=1;
m=1;

y=(rand(1,N)-0.5)*0.01;
x=(rand(1,N)-0.5)*0.01;
z=rand(1,N)*0;
pz=rand(1,N)+200;
py=(rand(1,N)-0.5)*0;
px=(rand(1,N)-0.5)*0;

dt=0.0003;
t=0;

B_z=@(x,y)zeros(size(x));
U=@(x,y,z)zeros(size(x));

% Einzel_lens_phi_3D
%设置透镜


dx=1e-6;
E_x0=@(X,Z)(U(X+dx,0*X,Z)-U(X-dx,0*X,Z))/2/dx;
E_z0=@(X,Z)(U(X,0*X,Z+dx)-U(X,0*X,Z-dx))/2/dx;

x0=linspace(-0.3,0.3,300);
z0=linspace(-0.1,2,300);
[X0,Z0]=meshgrid(x0,z0);
Ex=E_x0(X0,Z0);
Ez=E_z0(X0,Z0);

E_x=@(x,z)interp2(X0,Z0,Ex,x,z);
E_z=@(x,z)interp2(X0,Z0,Ez,x,z);

xs=zeros(Ni,N);
zs=zeros(Ni,N);


xs(1,:)=x;
zs(1,:)=z;
pxs(1,:)=px;
pzs(1,:)=pz;

for i=2:Ni
[x,z,px,pz]=EM_re_motion_RK4(x,z,px,pz,dt,t,q,m,B_z,E_x,E_z);

xs(i,:)=x;
zs(i,:)=z;
pxs(i,:)=px;
pzs(i,:)=pz;
end



subplot(2,1,1)
plot(zs,xs,'-o')
%axis equal
%axis([0,8,-2,2])

subplot(2,1,2)
surf(X0,Z0,U(X0,0*Z0,Z0))
% surf(X0,Z0,Ex)
view([90,90])
shading interp
axis equal
axis([-0.3,0.3,0,2])


figure
subplot(1,2,1)
hist(px./pz/1e-3)
xlabel('[mrad]')
subplot(1,2,2)
hist(x/1e-3)
xlabel('[mm]')


%{
+[M函数](,%[标题])
%}"(,)
的#19""(整理代码#16,M代码#20)
M代码#20"%{

%}


pt_x=get(gca,'Xlim');
pt_y=get(gca,'Ylim');
axis_=[pt_x,pt_y];


"(,)
的#21""(整理代码#16,样本#22)
样本#22"%{
+[M函数](,样本)
%}

physics_constant;
addpath('Matlab/Physics');
addpath('Matlab/SEM');

N=100;
Ni=30;
q=1;
m=1;

y=(rand(1,N)-0.5)*0.01;
x=(rand(1,N)-0.5)*0.01;
z=rand(1,N)*0;
pz=rand(1,N)+200;
py=(rand(1,N)-0.5)*0;
px=(rand(1,N)-0.5)*0;

dt=0.0003;
t=0;

B_z=@(x,y)zeros(size(x));
U=@(x,y,z)zeros(size(x));

% Einzel_lens_phi_3D
u_bg_1=8000;
H_bg_1=0.1;
R_bg_1=0.3;
R0_bg_1=0.02;
pt_bg_1=[0.0, 0.0, 0.5];
Eulers_bg_1=[0,0,0];

U_bg_1=@(X,Y,Z)Einzel_lens_phi_3D(X,Y,Z,pt_bg_1,Eulers_bg_1,u_bg_1,H_bg_1,R0_bg_1,R_bg_1);
U=@(X,Y,Z)U(X,Y,Z)+U_bg_1(X,Y,Z);

u_bg_2=8000;
H_bg_2=1.1;
R_bg_2=0.3;
R0_bg_2=0.06;
pt_bg_2=[0.0, 0.0, 1.0];
Eulers_bg_2=[0,0,0];

U_bg_2=@(X,Y,Z)Einzel_lens_phi_3D(X,Y,Z,pt_bg_2,Eulers_bg_2,u_bg_2,H_bg_2,R0_bg_2,R_bg_2);
U=@(X,Y,Z)U(X,Y,Z)+U_bg_2(X,Y,Z);

u_bg_3=8000;
H_bg_3=0.1;
R_bg_3=0.3;
R0_bg_3=0.02;
pt_bg_3=[0.0, 0.0, 1.5];
Eulers_bg_3=[0,0,0];

U_bg_3=@(X,Y,Z)Einzel_lens_phi_3D(X,Y,Z,pt_bg_3,Eulers_bg_3,u_bg_3,H_bg_3,R0_bg_3,R_bg_3);
U=@(X,Y,Z)U(X,Y,Z)+U_bg_3(X,Y,Z);



dx=1e-6;
E_x0=@(X,Z)(U(X+dx,0*X,Z)-U(X-dx,0*X,Z))/2/dx;
E_z0=@(X,Z)(U(X,0*X,Z+dx)-U(X,0*X,Z-dx))/2/dx;

x0=linspace(-0.3,0.3,300);
z0=linspace(-0.1,2,300);
[X0,Z0]=meshgrid(x0,z0);
Ex=E_x0(X0,Z0);
Ez=E_z0(X0,Z0);

E_x=@(x,z)interp2(X0,Z0,Ex,x,z);
E_z=@(x,z)interp2(X0,Z0,Ez,x,z);

xs=zeros(Ni,N);
zs=zeros(Ni,N);


xs(1,:)=x;
zs(1,:)=z;
pxs(1,:)=px;
pzs(1,:)=pz;

for i=2:Ni
[x,z,px,pz]=EM_re_motion_RK4(x,z,px,pz,dt,t,q,m,B_z,E_x,E_z);

xs(i,:)=x;
zs(i,:)=z;
pxs(i,:)=px;
pzs(i,:)=pz;
end



subplot(2,1,1)
plot(zs,xs,'-o')
%axis equal
%axis([0,8,-2,2])

subplot(2,1,2)
surf(X0,Z0,U(X0,0*Z0,Z0))
% surf(X0,Z0,Ex)
view([90,90])
shading interp
axis equal
axis([-0.3,0.3,0,2])


figure
subplot(1,2,1)
hist(px./pz/1e-3)
xlabel('[mrad]')
subplot(1,2,2)
hist(x/1e-3)
xlabel('[mm]')


%{
clf
size(Y*0)
Einzel_lens_phi_3D(X,Y,X*0,pt0,Eulers0,U0,H,R0,R);
+[M函数](,样本)
%}"(,)
的#23""(降临规则#4,单体代码#24)
单体代码#24"\"\"\"
描述结构:...
库:...
+[新建阅读窗口](,描述结构)

\"\"\"

+单体代码(_场景,_代码)->+[del](,+单体代码)...
->的(单体代码,描述结构)->的(单体代码,库)...

->[]{
    []:->的(_代码,代码结构)->代码结构,
    ->+的(_代码,+代码结构)...
        ->+的(+代码结构,+设置电子源)->+的(+代码结构,+设置透镜)...
        ->+的(+代码结构,+设置观测平面)
}...

->+[code]([想],描述结构)->[想](,_场景)...

->操作([想],)...
->[]{
    []=>的(操作,_操作)->_操作(,_物体)->_物体(,)...
    =>[说](,_操作)...
        ->的(库,_条目)->_条目->[eq](_条目,_操作)...
        ->+[做](_物体,_代码)->+[code](+[做],_条目)->+[.](+[做],_场景)
}


"(,)
的#25""(单体代码#24,库#26)
库#26"
+[del](,设置电子源)
设置电子源:...
设置透镜:...
设置观测平面:...
将条目\"设置透镜\"复制为条目\"设置电子源\"

将'设置透镜'的\"运动物体\"替换为\"设置透镜\"
在选择区域中, 将'设置透镜'的\"内径\"替换为\"电压\"
+[新建阅读窗口](,设置透镜)





"(,)
的#27""(库#26,设置电子源#28)
设置电子源#28"\"\"\"
M代码:...
M模板:...
+[新建阅读窗口](,测试代码)

\"\"\"

+设置电子源(_物体,_代码)->+[del](,+设置电子源)...
->的(设置电子源,M代码)->的(设置电子源,M模板)...

->.(+设置电子源,_场景)...

->的(_代码,命名空间)->的(命名空间,变量)->变量(,_物体)...
->的(_代码,代码结构)->的(代码结构,设置电子源#0)...

->[]{
    []:->在(_物体,空间点)->空间点, ->+在(_物体,+空间点)->+空间点\"0,0,0\"
}...
->[]{
    []:->朝向(_物体,方向)->方向, ->+朝向(_物体,+方向)->+方向\"0,0,0\"
}...
->[]{
    []:->的(_物体,能量)->能量, ->+的(_物体,+能量)->+能量\"0\"
}...
->[]{
    []:->的(_物体,尺寸)->尺寸, ->+的(_物体,+尺寸)->+尺寸\"0\"
}...
->[]{
    []:->的(_物体,发散度)->发散度, ->+的(_物体,+发散度)->+发散度\"0\"
}...

->的(_物体,发散度)->的(_物体,能量)->的(_物体,尺寸)...
->在(_物体,空间点)->朝向(_物体,方向)...

->+[模板文本](M模板,+[增加内容2]#1)->+[增加内容2]#1(,设置电子源#0)...
->+[.](+[模板文本],变量)->+[.](+[模板文本],空间点)->+[.](+[模板文本],方向)...
->+[.](+[模板文本],能量)->+[.](+[模板文本],发散度)->+[.](+[模板文本],尺寸)


"(,)
的#29""(设置电子源#28,M模板#30)
M模板#30"y=(rand(1,N)-0.5)*%尺寸;
x=(rand(1,N)-0.5)*%尺寸;
z=rand(1,N)*0;
pz=200*ones(1,N);
py=(rand(1,N)-0.5)*%发散度.*pz;
px=(rand(1,N)-0.5)*%发散度.*pz;

"(,)
的#31""(设置电子源#28,M代码#32)
M代码#32""(,)
的#33""(库#26,设置观测平面#34)
设置观测平面#34""(,)
的#35""(库#26,设置透镜#36)
设置透镜#36"\"\"\"
M代码:...
M模板:...
+[新建阅读窗口](,测试代码)

\"\"\"

+设置透镜(_物体,_代码)->+[del](,+设置透镜)...
->的(设置透镜,M代码)->的(设置透镜,M模板)...

->.(+设置透镜,_场景)...

->的(_代码,命名空间)->的(命名空间,变量)->变量(,_物体)...
->的(_代码,代码结构)->的(代码结构,设置透镜#0)...

->[]{
    []:->在(_物体,空间点)->空间点, ->+在(_物体,+空间点)->+空间点\"0,0,0\"
}...
->[]{
    []:->朝向(_物体,方向)->方向, ->+朝向(_物体,+方向)->+方向\"0,0,0\"
}...
->[]{
    []:->的(_物体,内径)->内径, ->+的(_物体,+内径)->+内径\"0\"
}...
->[]{
    []:->的(_物体,电压)->电压, ->+的(_物体,+电压)->+电压\"0\"
}...

->的(_物体,半径)->的(_物体,高度)->的(_物体,内径)->的(_物体,电压)...
->在(_物体,空间点)->朝向(_物体,方向)...

->+[模板文本](M模板,+[增加内容2]#1)->+[增加内容2]#1(,设置透镜#0)...
->+[.](+[模板文本],变量)->+[.](+[模板文本],空间点)->+[.](+[模板文本],方向)...
->+[.](+[模板文本],半径)->+[.](+[模板文本],高度)->+[.](+[模板文本],内径)...
->+[.](+[模板文本],电压)


"(,)
的#37""(设置透镜#36,M代码#38)
M代码#38""(,)
的#39""(设置透镜#36,M模板#40)
M模板#40"u_%变量=%电压;
H_%变量=%高度;
R_%变量=%半径;
R0_%变量=%内径;
pt_%变量=[%空间点];
Eulers_%变量=[%方向];

U_%变量=@(X,Y,Z)Einzel_lens_phi_3D(X,Y,Z,pt_%变量,Eulers_%变量,u_%变量,H_%变量,R0_%变量,R_%变量);
U=@(X,Y,Z)U(X,Y,Z)+U_%变量(X,Y,Z);

"(,)
的#41""(单体代码#24,描述结构#42)
描述结构#42"\"\"\"


\"\"\"

+描述结构(,_场景)->+操作(+描述结构,)...

->[]{
    []=>的(_场景,_物体)->_物体(,)...
    =>[]:
        ->[]{的(_物体,半径)->半径}...
            ->+设置透镜(,_物体)->+的(+操作,+设置透镜),
        ->[]{的(_物体,能量)->能量}...
            ->+设置电子源(,_物体)->+的(+操作,+设置电子源),
        ->[]{的(_物体,宽度)->宽度}...
            ->+设置观测平面(,_物体)->+的(+操作,+设置观测平面),
        ->[]
}


"(,)

## end
#131, 197:
u_%变量=%电压;
H_%变量=%高度;
R_%变量=%半径;
R0_%变量=%内径;
pt_%变量=[%空间点];
Eulers_%变量=[%方向];

U_%变量=@(X,Y,Z)Einzel_lens_phi_3D(X,Y,Z,pt_%变量,Eulers_%变量,u_%变量,H_%变量,R0_%变量,R_%变量);
U=@(X,Y,Z)U(X,Y,Z)+U_%变量(X,Y,Z);


## end
#134, 708:
"""
M代码:...
M模板:...
+[新建阅读窗口](,测试代码)

"""

+设置透镜(_物体,_代码)->+[del](,+设置透镜)...
->的(设置透镜,M代码)->的(设置透镜,M模板)...

->.(+设置透镜,_场景)...

->的(_代码,命名空间)->的(命名空间,变量)->变量(,_物体)...
->的(_代码,代码结构)->的(代码结构,设置透镜#0)...

->[]{
    []:->在(_物体,空间点)->空间点, ->+在(_物体,+空间点)->+空间点"0,0,0"
}...
->[]{
    []:->朝向(_物体,方向)->方向, ->+朝向(_物体,+方向)->+方向"0,0,0"
}...
->[]{
    []:->的(_物体,内径)->内径, ->+的(_物体,+内径)->+内径"0"
}...
->[]{
    []:->的(_物体,电压)->电压, ->+的(_物体,+电压)->+电压"0"
}...

->的(_物体,半径)->的(_物体,高度)->的(_物体,内径)->的(_物体,电压)...
->在(_物体,空间点)->朝向(_物体,方向)...

->+[模板文本](M模板,+[增加内容2]#1)->+[增加内容2]#1(,设置透镜#0)...
->+[.](+[模板文本],变量)->+[.](+[模板文本],空间点)->+[.](+[模板文本],方向)...
->+[.](+[模板文本],半径)->+[.](+[模板文本],高度)->+[.](+[模板文本],内径)...
->+[.](+[模板文本],电压)



## end
#137, 885:
%{
+[M函数](,原始例子)
运行指令"nautilus Matlab/SEM"

笔记:...
calculation_all:...
测试tm_traj:...
tm_traj(M函数):...
+[新建阅读窗口](,calculation_all)

原始例子:...
保存:...
%}

addpath('Matlab/SEM')
clc;
clear all;
close all;

%% define geometry 
x_list=[-0.35 -0.0055 -0.0035 -0.0015 0.0015 0.0035 0.0055 0.0795 0.0815 0.0835 0.0865 0.0885 0.0905 0.095];
V_list=[8000 8000 8000 4400 4400 8000 8000 8000 8000 1700 1700 8000 8000 8000];


x_all = linspace(min(x_list),max(x_list),20000);
V_all = interp1(x_list, V_list, x_all, 'Linear');


%% calculate trajectory
[r_alpha, angle_alpha] = tm_traj(x_all, V_all, [0;1*sqrt(V_all(1))]);
[r_gamma, angle_gamma] = tm_traj(x_all, V_all, [1;0]);

plot([x_all,fliplr(x_all)],[r_alpha,-fliplr(r_alpha)],...
[x_all,fliplr(x_all)],[r_gamma,-fliplr(r_gamma)])



%{
[0;1*sqrt(V_all(1))]

plot(x_list,V_list)
plot(x_all,V_all,x_all,r_gamma/max(r_gamma)*2000)
+[M函数](,验证公式)
%}
## end
#139, 583:
%{
地址::Matlab/SEM/lens_matrix.m
+[保存M函数](,lens_matrix)
测试:...
%}

function [L,L1,L2,T1,T2]=lens_matrix(D,U,U0)
% D=10e-2;
% U=4000;
% U0=8000;

N=10000;
E1=-(U-U0)/(D/2);
E2=-(U0-U)/(D/2);

Re=@(E_1,E_2,V_0)[1,0;-(E_1-E_2)./(4.*sqrt(V_0)),1];
Ts=@(V_1,V_2,d)[1,(2.*d)./(sqrt(V_1)+sqrt(V_2));0,1];

R1=Re(0,E1,U0);
R2=Re(E1,E2,U);
R3=Re(E2,0,U0);

d=D/2/(N-1);
Ux=linspace(U0,U,N);
T1=eye(2);
for i=1:N-1
    T1=Ts(Ux(i),Ux(i+1),d)*T1;
end

Ux=linspace(U,U0,N);
T2=eye(2);
for i=1:N-1
    T2=Ts(Ux(i),Ux(i+1),d)*T2;
end

L1=R1;
L2=R2*T1*R1;
L=R3*T2*R2*T1*R1;

end

%{
+[M函数](,验证公式)
%}
## end
#142, 24:
Matlab/SEM/lens_matrix.m
## end
#144, 667:
%{
+[M函数](,验证公式)
运行指令"nautilus Matlab/SEM"

笔记:...
calculation_all:...
测试tm_traj:...
tm_traj(M函数):...
lens_matrix(M函数):...
+[新建阅读窗口](,lens_matrix)

原始例子:...
保存:...
%}

addpath('Matlab/SEM')

D=10e-2;
U=4000;
U0=8000;

r0=1e-3;
an0=0;
N=1000;

E1=(U-U0)/(D/2);
E2=(U0-U)/(D/2);

Re=@(E_1,E_2,V_0)[1,0;-(E_1-E_2)./(4.*sqrt(V_0)),1];
Ts=@(V_1,V_2,d)[1,(2.*d)./(sqrt(V_1)+sqrt(V_2));0,1];

R1=Re(0,E1,U0);
R2=Re(E1,E2,U);
R3=Re(E2,0,U0);

d=D/2/(N-1);
Ux=linspace(U0,U,N);
T1=eye(2);
for i=1:N-1
    T1=Ts(Ux(i),Ux(i+1),d)*T1;
end

Ux=linspace(U,U0,N);
T2=eye(2);
for i=1:N-1
    T2=Ts(Ux(i),Ux(i+1),d)*T2;
end

L=R3*T2*R2*T1*R1;
L1=R1;
L2=R2*T1*R1;


%{
+[M函数](,验证公式)
%}
## end
#149, 537:
%{
地址::Matlab/SEM/lenses_traj.m
+[保存M函数](,lenses_traj)
测试:...
zs0
%}

function [zs,rs]=lenses_traj(z0,r0,an0,U0,D,U,Z)

Ts=@(V_1,V_2,d)[1,d;0,1];

zs=[z0];
rs=[r0];

z=z0;
r=r0;
an=an0;

for i=1:length(Z)
[L,L1,L2]=lens_matrix(D(i),U(i),U0);

r1=r+(Z(i)-z).*an;

zs=[zs;Z(i)*ones(size(z))];
rs=[rs;r1];
z=Z(i)*ones(size(z));
r=r1;

r2=L2(1,1)*r+L2(1,2)*an*sqrt(U0);
r3=L(1,1)*r+L(1,2)*an*sqrt(U0);
an3=(L(2,1)*r+L(2,2)*an*sqrt(U0))/sqrt(U0);

zs=[zs;z+D(i)/2;z+D(i)];
rs=[rs;r2;r3];
z=z+D(i);
r=r3;
an=an3;

end

end

%{
+[M函数](,验证公式)
%}
## end
#152, 624:
%{
+[M函数](,测试)

测试:...
%}

addpath('Matlab/SEM')

U0=8000;

D=10e-2*ones(1,3);
U=4000*ones(1,3);
Z=[1,2,3];

Ts=@(V_1,V_2,d)[1,d;0,1];

r0=linspace(-1e-3,1e-3,100);
z0=zeros(size(r0));
an0=zeros(size(r0));

zs=[z0];
rs=[r0];

z=z0;
r=r0;
an=an0;

%{
+[M函数](,测试)
%}

for i=1:length(Z)
[L,L1,L2]=lens_matrix(D(i),U(i),U0);
r1=r+(Z(i)-z).*an;

zs=[zs;Z(i)*ones(size(z))];
rs=[rs;r1];
z=Z(i)*ones(size(z));
r=r1;


r2=L2(1,1)*r+L2(1,2)*an*sqrt(U0);
r3=L(1,1)*r+L(1,2)*an*sqrt(U0);
an3=(L(2,1)*r+L(2,2)*an*sqrt(U0))/sqrt(U0);

zs=[zs;z+D(i)/2;z+D(i)];
rs=[rs;r2;r3];
z=z+D(i);
r=r3;
an=an3;

end

plot(zs,rs)

%{
+[M函数](,验证公式)
%}
## end
#154, 24:
Matlab/SEM/lenses_traj.m
## end
#159, 402:
%{
+[M函数](,验证公式)
运行指令"nautilus Matlab/SEM"

笔记:...
calculation_all:...
测试tm_traj:...
tm_traj(M函数):...
lens_matrix(M函数):...
lenses_traj(M函数):...
+[新建阅读窗口](,lens_matrix)
+[新建阅读窗口](,测试tm_traj)

原始例子:...
简化透镜:...
保存:...
%}

addpath('Matlab/SEM')

U0=8000;

D=10e-2*ones(1,3);
U=4000*ones(1,3);
Z=[1,2,2.5];

z0=0;
r0=1e-3;
an0=1e-3;
[zs,rs]=lenses_traj(z0,r0,an0,U0,D,U,Z);
plot(zs,rs)

%{
+[M函数](,验证公式)
%}
## end
#162, 2634:
%{
+[M函数](,RK4轨迹)

磁场轨迹:...
physics_constant(M函数):...
addpath(M函数):...

加速电场:...
透镜电场_函数:...
透镜电场_插值:...
SI单位轨迹:...
插值与矩阵方法对比:...
函数与矩阵方法对比:...
(运行时间超过半个小时, 但是结果和插值方法差不多. 误差应该不是来自于插值)
RK4问题:...
+[新建阅读窗口](,透镜电场_函数)

保存:...
%}

physics_constant;
addpath('Matlab\Physics');
addpath('Matlab/Physics');
addpath('Matlab/SEM');

N=1;
Ni=800;
Ue=3000;
U0=-2000;

%{
+[M函数](,RK4轨迹)
%}

Dy0=1e-4;
y=linspace(-1,1,N)*Dy0;
% y=Dy0;
x=zeros(size(y));
z=zeros(size(y));

gamma=(me*c^2+Ue*e)/me/c^2;
vx0=sqrt(1-(1/gamma)^2)*c;
vx=vx0*ones(1,N);
vy=zeros(size(vx));
vz=zeros(size(vx));

% px=Ue*e/c*ones(1,N);
% py=(rand(1,N)-0.5)*0;
% pz=(rand(1,N)-0.5)*0;

dt=200e-12;
t=0;

%{
+[M函数](,RK4轨迹)
%}

% Einzel_lens_phi_3D field
B_z=@(x,y)zeros(size(x));
E_x=@(x,y)zeros(size(x));
E_y=@(x,y)zeros(size(x));

H=1;
R=2;
R0=0.1;

pt0=[2.5,0,0];
Eulers0=[90,90,0];

U=@(X,Y,Z)Einzel_lens_phi_3D(X,Y,Z,pt0,Eulers0,U0,H,R0,R);

dx=1e-5;
E_x0=@(X,Y)(U(X+dx,Y,0*X)-U(X-dx,Y,0*X))/2/dx;
E_y0=@(X,Y)(U(X,Y+dx,0*X)-U(X,Y-dx,0*X))/2/dx;
% Ez=(U(X,Y,Z)-U(X,Y,Z-dx))/dx;

% x0=linspace(0,8,100);
x0=linspace(-1,1,200)*H+pt0(1);
y0=linspace(-1,1,100)*2*Dy0;
[X0,Y0]=meshgrid(x0,y0);
Ex=E_x0(X0,Y0);
Ey=E_y0(X0,Y0);

E_x=@(x,y)interp2(X0,Y0,Ex,x,y);
E_y=@(x,y)interp2(X0,Y0,Ey,x,y);


%{
+[M函数](,RK4轨迹)
%}

% matrix trajectory
U0m=Ue;
Um=[U0+Ue,Ue];
Dm=[H,H];
Zm=[pt0(1)-H/2,5];

z0=x;
r0=y;
an0=zeros(size(z0));

[zms,rms]=lenses_traj(z0,r0,an0,U0m,Dm,Um,Zm);

% motion
xs=zeros(Ni,N);
ys=zeros(Ni,N);


%{
+[M函数](,RK4轨迹)
%}

xs(1,:)=x;
ys(1,:)=y;
for i=2:Ni
if x(1)<pt0(1)-H*0.9 || x(1)>pt0(1)+H*0.9
% [x,y,px,py]=EM_re_motion_RK4(x,y,px,py,dt,t,e,me,B_z,E_x,E_y);
% [x,y,vx,vy]=EM_motion_RK4(x,y,vx,vy,dt,t,e,me,B_z,B_z,B_z);
% [x,y,vx,vy]=EM_motion_BEM(x,y,vx,vy,dt,t,e,me,B_z,B_z,B_z);
[x,y,vx,vy]=EM_motion_CM(x,y,vx,vy,dt,t,e,me,B_z,B_z,B_z);
else
% [x,y,px,py]=EM_re_motion_RK4(x,y,px,py,dt,t,e,me,B_z,E_x,E_y);
% [x,y,vx,vy]=EM_motion_RK4(x,y,vx,vy,dt,t,e,me,B_z,E_x,E_y);
% [x,y,vx,vy]=EM_motion_BEM(x,y,vx,vy,dt,t,e,me,B_z,E_x,E_y);
[x,y,vx,vy]=EM_motion_CM(x,y,vx,vy,dt,t,e,me,B_z,E_x,E_y);
end

Dx=x-x';
Dy=y-y';
R=sqrt(Dx.^2+Dy.^2);
Fx=1./R.^2.*Dx;
Fy=1./R.^2.*Dy;
Fx(R==0)=0;
Fy(R==0)=0;

xs(i,:)=x;
ys(i,:)=y;
end



% x0=linspace(0,8,100);
% y0=linspace(-1,1,100);
[X0,Y0]=meshgrid(x0,y0);
u0=abs(U(X0,Y0,0*X0));


clf
hold on
image(x0,y0,u0/max(max(u0))*255)
plot(xs,ys,'b-o',zms,rms,'r--o')
colormap('gray')
axis([pt0(1)-H,pt0(1)+H,-2*Dy0,2*Dy0])



%{
max(y0)
plot(zms,rms)
clf
plot(u0)

Nini, 打开龙格库塔方法的EM_re_motion_RK4(节点)
Nini, 打开龙格库塔方法的EM_motion_RK4(节点)
Nini, 打开龙格库塔方法(文件)
运行指令"nautilus Matlab/Physics"
运行指令"tree Matlab/Physics"
+[M函数](,RK4轨迹)
%}
## end
#164, 1461:
%{
+[M函数](,RK4轨迹)

磁场轨迹:...
physics_constant(M函数):...
addpath(M函数):...

加速电场:...
透镜电场_函数:...
透镜电场_插值:...

保存:...
%}

physics_constant;
addpath('Matlab\Physics');
addpath('Matlab/Physics');
addpath('Matlab/SEM');

N=100;
Ni=30;
q=e;
m=me;
Ue=2000;

x=rand(1,N)*0;
y=(rand(1,N)-0.5)*0.1;
z=(rand(1,N)-0.5)*0.1;
px=Ue*e/c*ones(1,N);
py=(rand(1,N)-0.5)*0;
pz=(rand(1,N)-0.5)*0;
dt=100e-9;
t=0;

%{
+[M函数](,RK4轨迹)
%}

B_z=@(x,y)zeros(size(x));
E_x=@(x,y)zeros(size(x));
E_y=@(x,y)zeros(size(x));

% Einzel_lens_phi_3D field
U0=8000;
U1=0;
H=1;
R=2;
R0=0.1;

pt0=[2,0,0];
Eulers0=[90,90,0];

U=@(X,Y,Z)Einzel_lens_phi_3D(X,Y,Z,pt0,Eulers0,U0,H,R0,R);

dx=1e-5;
E_x0=@(X,Y)(U(X+dx,Y,0*X)-U(X-dx,Y,0*X))/2/dx;
E_y0=@(X,Y)(U(X,Y+dx,0*X)-U(X,Y-dx,0*X))/2/dx;
% Ez=(U(X,Y,Z)-U(X,Y,Z-dx))/dx;

x0=linspace(0,8,100);
y0=linspace(-1,1,100);
[X0,Y0]=meshgrid(x0,y0);
Ex=E_x0(X0,Y0);
Ey=E_y0(X0,Y0);

E_x=@(x,y)interp2(X0,Y0,Ex,x,y);
E_y=@(x,y)interp2(X0,Y0,Ey,x,y);


% motion
xs=zeros(Ni,N);
ys=zeros(Ni,N);


xs(1,:)=x;
ys(1,:)=y;
for i=2:Ni
[x,y,px,py]=EM_re_motion_RK4(x,y,px,py,dt,t,q,m,B_z,E_x,E_y);

Dx=x-x';
Dy=y-y';
R=sqrt(Dx.^2+Dy.^2);
Fx=1./R.^2.*Dx;
Fy=1./R.^2.*Dy;
Fx(R==0)=0;
Fy(R==0)=0;

xs(i,:)=x;
ys(i,:)=y;
end


subplot(2,1,1)
plot(xs,ys,'-o')
%axis equal
%axis([0,8,-2,2])

subplot(2,1,2)
surf(X0,Y0,E_y(X0,Y0))
axis([0,8,-2,2])
shading interp
view([0,90])
axis equal


%{
clf
size(Y*0)
Einzel_lens_phi_3D(X,Y,X*0,pt0,Eulers0,U0,H,R0,R);
+[M函数](,SI单位轨迹)
%}
## end
#166, 777:
%{
+[M函数](,验证公式)
运行指令"nautilus Matlab/SEM"

笔记:...
calculation_all:...
测试tm_traj:...
tm_traj(M函数):...
lens_matrix(M函数):...
lenses_traj(M函数):...
+[新建阅读窗口](,lens_matrix)
+[新建阅读窗口](,lenses_traj)
+[新建阅读窗口](,测试tm_traj)

原始例子:...
简化透镜:...
保存:...
%}

addpath('Matlab/SEM')

U0=8000;

D=[10e-2,10e-2,10e-2];
U=[1,1,1]*(10000);
Z=[1,2,2.5];

%{
+[M函数](,对比轨迹_zz)
%}

r0=1e-3;
z0=zeros(size(r0));
an0=zeros(size(r0));

z_list=[z0];
V_list=[U0];
for i=1:length(Z)
z_list=[z_list,Z(i),Z(i)+D(i)/2,Z(i)+D(i)];
V_list=[V_list,U0,U(i),U0];
end

zs0 = linspace(min(z_list),max(z_list),20000);
V_all = interp1(z_list, V_list,zs0, 'Linear');

[rs0, ans0] = tm_traj(zs0,V_all,[r0;an0*sqrt(V_all(1))]);

[zs,rs]=lenses_traj(z0,r0,an0,U0,D,U,Z);
plot(zs,rs,'-o',zs0,rs0,'--')

%{
+[M函数](,对比轨迹_zz)
%}
## end
#168, 2025:
%{
+[M函数](,RK4轨迹)

磁场轨迹:...
physics_constant(M函数):...
addpath(M函数):...

加速电场:...
透镜电场_函数:...
透镜电场_插值:...
SI单位轨迹:...
插值与矩阵方法对比:...
+[新建阅读窗口](,SI单位轨迹)

保存:...
%}

physics_constant;
addpath('Matlab\Physics');
addpath('Matlab/Physics');
addpath('Matlab/SEM');

N=10;
Ni=300;
Ue=3000;
U0=-2000;
%{
+[M函数](,RK4轨迹)
%}

x=0*ones(1,N);
y=linspace(-1,1,N)*5e-2;
z=zeros(size(x));

gamma=(me*c^2+Ue*e)/me/c^2;
vx0=sqrt(1-(1/gamma)^2)*c;
vx=vx0*ones(1,N);
vy=zeros(size(vx));
vz=zeros(size(vx));

% px=Ue*e/c*ones(1,N);
% py=(rand(1,N)-0.5)*0;
% pz=(rand(1,N)-0.5)*0;

dt=1e-9;
t=0;

%{
+[M函数](,RK4轨迹)
%}

% Einzel_lens_phi_3D field
B_z=@(x,y)zeros(size(x));
E_x=@(x,y)zeros(size(x));
E_y=@(x,y)zeros(size(x));

H=1;
R=2;
R0=0.1;

pt0=[2.5,0,0];
Eulers0=[90,90,0];

U=@(X,Y,Z)Einzel_lens_phi_3D(X,Y,Z,pt0,Eulers0,U0,H,R0,R);

dx=1e-5;
E_x0=@(X,Y)(U(X+dx,Y,0*X)-U(X-dx,Y,0*X))/2/dx;
E_y0=@(X,Y)(U(X,Y+dx,0*X)-U(X,Y-dx,0*X))/2/dx;
% Ez=(U(X,Y,Z)-U(X,Y,Z-dx))/dx;

x0=linspace(0,8,100);
y0=linspace(-1,1,100);
[X0,Y0]=meshgrid(x0,y0);
Ex=E_x0(X0,Y0);
Ey=E_y0(X0,Y0);

E_x=@(x,y)interp2(X0,Y0,Ex,x,y);
E_y=@(x,y)interp2(X0,Y0,Ey,x,y);


%{
+[M函数](,RK4轨迹)
%}

% matrix trajectory
U0m=Ue;
Um=[U0+Ue,Ue];
Dm=[H,H];
Zm=[pt0(1)-H/2,5];

z0=x;
r0=y;
an0=zeros(size(z0));

[zms,rms]=lenses_traj(z0,r0,an0,U0m,Dm,Um,Zm);

% motion
xs=zeros(Ni,N);
ys=zeros(Ni,N);


xs(1,:)=x;
ys(1,:)=y;
for i=2:Ni
% [x,y,px,py]=EM_re_motion_RK4(x,y,px,py,dt,t,e,me,B_z,E_x,E_y);
[x,y,vx,vy]=EM_motion_RK4(x,y,vx,vy,dt,t,e,me,B_z,E_x,E_y);

Dx=x-x';
Dy=y-y';
R=sqrt(Dx.^2+Dy.^2);
Fx=1./R.^2.*Dx;
Fy=1./R.^2.*Dy;
Fx(R==0)=0;
Fy(R==0)=0;

xs(i,:)=x;
ys(i,:)=y;
end



x0=linspace(0,8,100);
y0=linspace(-1,1,100);
[X0,Y0]=meshgrid(x0,y0);
u0=abs(U(X0,Y0,0*X0));

clf
hold on
image(x0,y0,u0/max(max(u0))*255)
plot(xs,ys,'b-o',zms,rms,'r--o')
colormap('gray')
axis([pt0(1)-H,pt0(1)+H,-0.2,0.2])



%{
plot(zms,rms)
clf
plot(u0)

Nini, 打开龙格库塔方法的EM_re_motion_RK4(节点)
Nini, 打开龙格库塔方法的EM_motion_RK4(节点)
运行指令"nautilus Matlab/Physics"
运行指令"tree Matlab/Physics"
+[M函数](,RK4轨迹)
%}
## end
#170, 1868:
%{
+[M函数](,RK4轨迹)

磁场轨迹:...
physics_constant(M函数):...
addpath(M函数):...

加速电场:...
透镜电场_函数:...
透镜电场_插值:...
SI单位轨迹:...
插值与矩阵方法对比:...
函数与矩阵方法对比:...
+[新建阅读窗口](,透镜电场_函数)

保存:...
%}

physics_constant;
addpath('Matlab\Physics');
addpath('Matlab/Physics');
addpath('Matlab/SEM');

N=10;
Ni=300;
Ue=3000;
U0=-2000;
%{
+[M函数](,RK4轨迹)
%}

x=0*ones(1,N);
y=linspace(-1,1,N)*5e-2;
z=zeros(size(x));

gamma=(me*c^2+Ue*e)/me/c^2;
vx0=sqrt(1-(1/gamma)^2)*c;
vx=vx0*ones(1,N);
vy=zeros(size(vx));
vz=zeros(size(vx));

% px=Ue*e/c*ones(1,N);
% py=(rand(1,N)-0.5)*0;
% pz=(rand(1,N)-0.5)*0;

dt=1e-9;
t=0;

%{
+[M函数](,RK4轨迹)
%}

% Einzel_lens_phi_3D field
B_z=@(x,y)zeros(size(x));
E_x=@(x,y)zeros(size(x));
E_y=@(x,y)zeros(size(x));

H=1;
R=2;
R0=0.1;

pt0=[2.5,0,0];
Eulers0=[90,90,0];

U=@(X,Y,Z)Einzel_lens_phi_3D(X,Y,Z,pt0,Eulers0,U0,H,R0,R);

dx=1e-5;
E_x=@(X,Y)(U(X+dx,Y,0*X)-U(X-dx,Y,0*X))/2/dx;
E_y=@(X,Y)(U(X,Y+dx,0*X)-U(X,Y-dx,0*X))/2/dx;
% Ez=(U(X,Y,Z)-U(X,Y,Z-dx))/dx;


%{
+[M函数](,RK4轨迹)
%}

% matrix trajectory
U0m=Ue;
Um=[U0+Ue,Ue];
Dm=[H,H];
Zm=[pt0(1)-H/2,5];

z0=x;
r0=y;
an0=zeros(size(z0));

[zms,rms]=lenses_traj(z0,r0,an0,U0m,Dm,Um,Zm);

% motion
xs=zeros(Ni,N);
ys=zeros(Ni,N);


xs(1,:)=x;
ys(1,:)=y;
for i=2:Ni
% [x,y,px,py]=EM_re_motion_RK4(x,y,px,py,dt,t,e,me,B_z,E_x,E_y);
[x,y,vx,vy]=EM_motion_RK4(x,y,vx,vy,dt,t,e,me,B_z,E_x,E_y);

Dx=x-x';
Dy=y-y';
R=sqrt(Dx.^2+Dy.^2);
Fx=1./R.^2.*Dx;
Fy=1./R.^2.*Dy;
Fx(R==0)=0;
Fy(R==0)=0;

xs(i,:)=x;
ys(i,:)=y;
end



x0=linspace(0,8,100);
y0=linspace(-1,1,100);
[X0,Y0]=meshgrid(x0,y0);
u0=abs(U(X0,Y0,0*X0));

clf
hold on
image(x0,y0,u0/max(max(u0))*255)
plot(xs,ys,'b-o',zms,rms,'r--o')
colormap('gray')
axis([pt0(1)-H,pt0(1)+H,-0.2,0.2])



%{
plot(zms,rms)
clf
plot(u0)

Nini, 打开龙格库塔方法的EM_re_motion_RK4(节点)
Nini, 打开龙格库塔方法的EM_motion_RK4(节点)
运行指令"nautilus Matlab/Physics"
运行指令"tree Matlab/Physics"
+[M函数](,RK4轨迹)
%}
## end
#172, 506:
%{
+[M函数](,验证公式)
运行指令"nautilus Matlab/SEM"

笔记:...
calculation_all:...
测试tm_traj:...
tm_traj(M函数):...
lens_matrix(M函数):...
lenses_traj(M函数):...
+[新建阅读窗口](,lens_matrix)
+[新建阅读窗口](,lenses_traj)
+[新建阅读窗口](,测试tm_traj)

原始例子:...
简化透镜:...
对比轨迹_zz:...
多条轨迹
保存:...
%}

addpath('Matlab/SEM')

U0=8000;

D=10e-2*ones(1,3);
U=4000*ones(1,3);
Z=[1,2,2.5];

r0=linspace(-1,1,100)*1e-3;
z0=zeros(size(r0));
an0=zeros(size(r0));

[zs,rs]=lenses_traj(z0,r0,an0,U0,D,U,Z);
plot(zs,rs,'-o',zs0,rs0,'--')

%{
+[M函数](,验证公式)
%}
## end
#174, 2360:
%{
+[M函数](,RK4轨迹)

磁场轨迹:...
physics_constant(M函数):...
addpath(M函数):...

加速电场:...
透镜电场_函数:...
透镜电场_插值:...
SI单位轨迹:...
插值与矩阵方法对比:...
函数与矩阵方法对比:...
(运行时间超过半个小时, 但是结果和插值方法差不多. 误差应该不是来自于插值)
+[新建阅读窗口](,透镜电场_函数)

保存:...
%}

physics_constant;
addpath('Matlab\Physics');
addpath('Matlab/Physics');
addpath('Matlab/SEM');

N=10;
Ni=800;
Ue=3000;
U0=-2000;

%{
+[M函数](,RK4轨迹)
%}

Dy0=1e-4;
y=linspace(-1,1,N)*Dy0;
% y=Dy0;
x=zeros(size(y));
z=zeros(size(y));

gamma=(me*c^2+Ue*e)/me/c^2;
vx0=sqrt(1-(1/gamma)^2)*c;
vx=vx0*ones(1,N);
vy=zeros(size(vx));
vz=zeros(size(vx));

% px=Ue*e/c*ones(1,N);
% py=(rand(1,N)-0.5)*0;
% pz=(rand(1,N)-0.5)*0;

dt=200e-12;
t=0;

%{
+[M函数](,RK4轨迹)
%}

% Einzel_lens_phi_3D field
B_z=@(x,y)zeros(size(x));
E_x=@(x,y)zeros(size(x));
E_y=@(x,y)zeros(size(x));

H=1;
R=2;
R0=0.1;

pt0=[2.5,0,0];
Eulers0=[90,90,0];

U=@(X,Y,Z)Einzel_lens_phi_3D(X,Y,Z,pt0,Eulers0,U0,H,R0,R);

dx=1e-5;
E_x0=@(X,Y)(U(X+dx,Y,0*X)-U(X-dx,Y,0*X))/2/dx;
E_y0=@(X,Y)(U(X,Y+dx,0*X)-U(X,Y-dx,0*X))/2/dx;
% Ez=(U(X,Y,Z)-U(X,Y,Z-dx))/dx;

% x0=linspace(0,8,100);
x0=linspace(-1,1,200)*H+pt0(1);
y0=linspace(-1,1,100)*2*Dy0;
[X0,Y0]=meshgrid(x0,y0);
Ex=E_x0(X0,Y0);
Ey=E_y0(X0,Y0);

E_x=@(x,y)interp2(X0,Y0,Ex,x,y);
E_y=@(x,y)interp2(X0,Y0,Ey,x,y);


%{
+[M函数](,RK4轨迹)
%}

% matrix trajectory
U0m=Ue;
Um=[U0+Ue,Ue];
Dm=[H,H];
Zm=[pt0(1)-H/2,5];

z0=x;
r0=y;
an0=zeros(size(z0));

[zms,rms]=lenses_traj(z0,r0,an0,U0m,Dm,Um,Zm);

% motion
xs=zeros(Ni,N);
ys=zeros(Ni,N);


%{
+[M函数](,RK4轨迹)
%}

xs(1,:)=x;
ys(1,:)=y;
for i=2:Ni
if x(1)<pt0(1)-H*0.9 || x(1)>pt0(1)+H*0.9
% [x,y,px,py]=EM_re_motion_RK4(x,y,px,py,dt,t,e,me,B_z,E_x,E_y);
[x,y,vx,vy]=EM_motion_RK4(x,y,vx,vy,dt,t,e,me,B_z,B_z,B_z);
else
% [x,y,px,py]=EM_re_motion_RK4(x,y,px,py,dt,t,e,me,B_z,E_x,E_y);
[x,y,vx,vy]=EM_motion_RK4(x,y,vx,vy,dt,t,e,me,B_z,E_x,E_y);
end

Dx=x-x';
Dy=y-y';
R=sqrt(Dx.^2+Dy.^2);
Fx=1./R.^2.*Dx;
Fy=1./R.^2.*Dy;
Fx(R==0)=0;
Fy(R==0)=0;

xs(i,:)=x;
ys(i,:)=y;
end



% x0=linspace(0,8,100);
% y0=linspace(-1,1,100);
[X0,Y0]=meshgrid(x0,y0);
u0=abs(U(X0,Y0,0*X0));


clf
hold on
image(x0,y0,u0/max(max(u0))*255)
plot(xs,ys,'b-o',zms,rms,'r--o')
colormap('gray')
axis([pt0(1)-H,pt0(1)+H,-2*Dy0,2*Dy0])



%{
max(y0)
plot(zms,rms)
clf
plot(u0)

Nini, 打开龙格库塔方法的EM_re_motion_RK4(节点)
Nini, 打开龙格库塔方法的EM_motion_RK4(节点)
运行指令"nautilus Matlab/Physics"
运行指令"tree Matlab/Physics"
+[M函数](,RK4轨迹)
%}
## end
#176, 2021:
%{
+[M函数](,测试ODE)
Nini, 打开Stiff问题(文件)

Nini, 打开静电场的Einzel_lens_phi_3D(节点)
field_2D_interp(M函数):...
+[新建阅读窗口](,field_2D_interp)
%}


physics_constant;
addpath('Matlab\Physics');
addpath('Matlab/Physics');
addpath('Matlab/SEM');

N=1;
Ni=800;
Ue=3000;
U0=-2500;

%{
+[M函数](,测试ODE)
%}

Dy0=1e-4;
y=linspace(-1,1,N)*Dy0;
% y=Dy0;
x=zeros(size(y));
z=zeros(size(y));

gamma=(me*c^2+Ue*e)/me/c^2;
vx0=sqrt(1-(1/gamma)^2)*c;
vx=vx0*ones(1,N);
vy=zeros(size(vx));
vz=zeros(size(vx));

% px=Ue*e/c*ones(1,N);
% py=(rand(1,N)-0.5)*0;
% pz=(rand(1,N)-0.5)*0;

dt=200e-12;

%{
+[M函数](,RK4轨迹)
%}

% Einzel_lens_phi_3D field
B_z=@(x,y)zeros(size(x));
E_x=@(x,y)zeros(size(x));
E_y=@(x,y)zeros(size(x));

H=1;
R=2;
R0=0.1;

pt0=[2.5,0,0];
Eulers0=[90,90,0];

U=@(X,Y,Z)Einzel_lens_phi_3D(X,Y,Z,pt0,Eulers0,U0,H,R0,R);

dx=1e-5;
E_x0=@(X,Y)(U(X+dx,Y,0*X)-U(X-dx,Y,0*X))/2/dx;
E_y0=@(X,Y)(U(X,Y+dx,0*X)-U(X,Y-dx,0*X))/2/dx;
% Ez=(U(X,Y,Z)-U(X,Y,Z-dx))/dx;

% x0=linspace(0,8,100);
x0=linspace(-1,1,200)*H+pt0(1);
y0=linspace(-1,1,100)*2*Dy0;
[X0,Y0]=meshgrid(x0,y0);
Ex=E_x0(X0,Y0);
Ey=E_y0(X0,Y0);

% E_x=@(x,y)interp2(X0,Y0,Ex,x,y);
% E_y=@(x,y)interp2(X0,Y0,Ey,x,y);
x_min=pt0(1)-H*0.9;
x_max=pt0(1)+H*0.9;
y_min=-2*Dy0;
y_max=2*Dy0;
E_x=@(x,y)field_2D_interp(X0,Y0,Ex,x,y,x_min,x_max,y_min,y_max);
E_y=@(x,y)field_2D_interp(X0,Y0,Ey,x,y,x_min,x_max,y_min,y_max);

%{
+[M函数](,测试ODE)
%}

% matrix trajectory
U0m=Ue;
Um=[U0+Ue,Ue];
Dm=[H,H];
Zm=[pt0(1)-H/2,5];

z0=x;
r0=y;
an0=zeros(size(z0));

[zms,rms]=lenses_traj(z0,r0,an0,U0m,Dm,Um,Zm);

% motion
xs=zeros(Ni,N);
ys=zeros(Ni,N);


%{
+[M函数](,测试ODE)
%}

t=(0:Ni-1)*dt;
[xs1,ys1,vx,vy]=EM_motion_ODEs(x,y,vx,vy,t,e,me,B_z,E_x,E_y,'ode45');
[xs2,ys2,vx,vy]=EM_motion_ODEs(x,y,vx,vy,t,e,me,B_z,E_x,E_y,'ode15s');


% x0=linspace(0,8,100);
% y0=linspace(-1,1,100);
[X0,Y0]=meshgrid(x0,y0);
u0=abs(U(X0,Y0,0*X0));


clf
hold on
image(x0,y0,u0/max(max(u0))*255)
plot(xs1,ys1,'b-',xs2,ys2,'g--',zms,rms,'r--o')
colormap('gray')
axis([pt0(1)-H,pt0(1)+H,-2*Dy0,2*Dy0])


%{
+[M函数](,测试ODE)
%}
## end
#178, 20:
文档/数学问题/Stiff问题.ftxt
## end
#180, 20:
文档/数学问题/Stiff问题.ftxt
## end
#182, 212:
%{
地址::Matlab/SEM/field_2D_interp.m
+[保存M函数](,field_2D_interp)
%}

function u=field_2D_interp(X0,Y0,field,x,y,x_min,x_max,y_min,y_max)

u=interp2(X0,Y0,field,x,y);
u(x<x_min | x>x_max | y<y_min | y>y_max)=0;

end
## end
#185, 28:
Matlab/SEM/field_2D_interp.m
## end
#199, 894:
<!--
+[H函数](,近似轨迹)
参考::file:///media/xiantao/Elements/paper/SEM/EMF_Lens.PDF#page=13
+[打开网页](,参考)
-->

<h2>E-field near the symmetrical axis</h2>
The electric field is,
%[1].
%[2].
%[3].
%[4].

The change in \(v_r\) is,
%[5].
%[6].
%[7].
If we assume that \(r\) and \(v_z\) don't change during the integral time, then, 
%[8].
Re-write this eq.[8]. by an electron orientation instead of \(v_r\),
%[9].
%[10].
%[11].
As a result, if we assume that \(\Theta=\theta\ \sqrt{V_0}\),
%[12].
%[13].

The change of \(r\) is,
%[14].
%[15].
%[16].
%[17].
%[18].

<h2>Dynamic equations</h2>
If the potential along the center axis is \(u(r,z)=u(z)\), then,
%[19].
%[20].
The \(v_z\) can be calculated from eq.[20]., because
%[21].
%[22].

Eq.[19]. is,
%[23].
%[24].


<!--
式(18)转换为"表达式"

测试场:...
+[新建阅读窗口](,测试场)
+[H函数](,测试场)

验证公式(M函数):...
测试误差(M函数):...
+[新建阅读窗口](,测试误差)
+[新建阅读窗口](,验证公式)
+[H函数](,近似轨迹)


-->
## end
#202, 124:
\frac{1}{r}\ \frac{\partial}{\partial r}\left(r\ \frac{\partial u}{\partial r}\right)+\frac{\partial^{2}u}{\partial z^{2}}=0
## end
#203, 42:
\frac{1}{r}*\p{r}{r*\p{r}{u}}+\p{z,z}{u}=0
## end
#207, 113:
\frac{\partial}{\partial r}\left(r\ \frac{\partial u}{\partial r}\right)=-\frac{\partial^{2}u}{\partial z^{2}}\ r
## end
#209, 72:
\frac{\partial u}{\partial r}=-\frac{\partial^{2}u}{\partial z^{2}}\ r/2
## end
#210, 31:
\p{r}{r*\p{r}{u}}=-\p{z,z}{u}*r
## end
#213, 1:
r
## end
#215, 24:
\p{r}{u}=-\p{z,z}{u}*r/2
## end
#223, 45:
E_{r}=-\frac{\partial E_{z}}{\partial z}\ r/2
## end
#225, 26:
dv_{r}=-e\ E_{r}\ dt/m_{e}
## end
#227, 45:
v_{r}=-\int_{}^{}{dz\ }{e\ E_{r}/v_{z}/m_{e}}
## end
#228, 19:
E_r=-\p{z}{E_z}*r/2
## end
#232, 61:
file:///media/xiantao/Elements/paper/SEM/EMF_Lens.PDF#page=13
## end
#234, 24:
\d{v_r}=-e*E_r*\d{t}/m_e
## end
#237, 147:
"""
P代码:...

"""
+整理等式(,等式)->+[del](,整理等式)...
->的(整理等式,P代码)...

->+[python](Python,)->+[code](+[python],P代码)...
    ->+[.]"text_eqn"(+[python],等式)

## end
#238, 11:
1/v_z*\d{z}
## end
#239, 5:
\d{t}
## end
#249, 2:
乘式
## end
#251, 2:
乘式
## end
#253, 2:
乘式
## end
#255, 2:
乘式
## end
#257, 2:
乘式
## end
#259, 2:
乘式
## end
#271, 33:
v_r=-\int_{}^{}{z}{e*E_r/v_z/m_e}
## end
#275, 78:
v_{r}=-\int_{}^{}{dz\ }{e\ \frac{\partial E_{z}}{\partial z}\ r/2/v_{z}/m_{e}}
## end
#277, 60:
v_{r2}=v_{r1}-e\ \left(E_{z2}-E_{z1}\right)\ r/2/v_{z}/m_{e}
## end
#279, 76:
v_{r2}/v_{z}=v_{r1}/v_{z}-e\ \left(E_{z2}-E_{z1}\right)\ r/2/v_{z}^{2}/m_{e}
## end
#281, 72:
\theta_{2}=\theta_{1}-e\ \left(E_{z2}-E_{z1}\right)/2/v_{z}^{2}/m_{e}\ r
## end
#282, 44:
v_r=-\int_{}^{}{z}{e*\p{z}{E_z}*r/2/v_z/m_e}
## end
#285, 35:
v_r2=v_r1-e*(E_z2-E_z1)*r/2/v_z/m_e
## end
#291, 55:
\theta_{2}=\theta_{1}-\frac{E_{z2}-E_{z1}}{4\ V_{0}}\ r
## end
#292, 47:
v_r2/v_z=v_r1/v_z-e*(E_z2-E_z1)*r/2/v_z^{2}/m_e
## end
#295, 3:
v_z
## end
#296, 3:
v_z
## end
#301, 47:
\theta_2=\theta_1-e*(E_z2-E_z1)/2/v_z^{2}/m_e*r
## end
#304, 1:
r
## end
#306, 43:
\theta_2=\theta_1-\frac{E_z2-E_z1}{4*V_0}*r
## end
#310, 90:
\theta_{2}\ \sqrt{V_{2}}=\theta_{1}\ \sqrt{V_{1}}-\frac{E_{z2}-E_{z1}}{4\ \sqrt{V_{0}}}\ r
## end
#312, 62:
\Theta_{2}=\Theta_{1}-\frac{E_{z2}-E_{z1}}{4\ \sqrt{V_{0}}}\ r
## end
#313, 72:
\theta_2*\sqrt{V_2}=\theta_1*\sqrt{V_1}-\frac{E_z2-E_z1}{4*\sqrt{V_0}}*r
## end
#316, 50:
\Theta_2=\Theta_1-\frac{E_z2-E_z1}{4*\sqrt{V_0}}*r
## end
#320, 21:
r_{2}=r_{1}+v_{r}\ dt
## end
#322, 56:
r_{2}=r_{1}+v_{r}\times 2\ dz/\left(v_{z2}+v_{z1}\right)
## end
#324, 53:
r_{2}=r_{1}+\frac{2\ d}{v_{z2}+v_{z1}}\ v_{z}\ \theta
## end
#325, 17:
r_2=r_1+v_r*\d{t}
## end
#328, 31:
r_2=r_1+v_r*2*\d{z}/(v_z2+v_z1)
## end
#331, 40:
r_2=r_1+\frac{2*d}{v_z2+v_z1}*v_z*\theta
## end
#335, 68:
r_{2}=r_{1}+\frac{2\ d}{\sqrt{V_{2}}+\sqrt{V_{1}}}\ \sqrt{V}\ \theta
## end
#337, 58:
r_{2}=r_{1}+\frac{2\ d}{\sqrt{V_{2}}+\sqrt{V_{1}}}\ \Theta
## end
#338, 57:
r_2=r_1+\frac{2*d}{\sqrt{V_2}+\sqrt{V_1}}*\sqrt{V}*\theta
## end
#341, 48:
r_2=r_1+\frac{2*d}{\sqrt{V_2}+\sqrt{V_1}}*\Theta
## end
#345, 34:
m_{e}\ \frac{dv_{r}}{dt}=-e\ E_{r}
## end
#347, 34:
m_{e}\ \frac{dv_{z}}{dt}=-e\ E_{z}
## end
#349, 33:
\frac{dv_{z}}{dt}=-e\ E_{z}/m_{e}
## end
#350, 22:
m_e*\d{v_r}_{t}=-e*E_r
## end
#353, 22:
m_e*\d{v_z}_{t}=-e*E_z
## end
#357, 64:
\frac{d^{2}z}{dt^{2}}=-e\ \frac{\partial u(z)}{\partial z}/m_{e}
## end
#359, 50:
m_{e}\ \frac{dv_{r}}{dt}=e\ \frac{dE_{z}}{dz}\ r/2
## end
#360, 22:
\d{v_z}_{t}=-e*E_z/m_e
## end
#363, 3:
m_e
## end
#365, 30:
\d{z}_{t,t}=-e*\p{z}{u(z)}/m_e
## end
#369, 19:
\frac{dr}{dt}=v_{r}
## end
#372, 33:
m_e*\d{v_r}_{t}=e*\d{E_z}_{z}*r/2
## end
#375, 15:
-\p{z,z}{u}*r/2
## end
#377, 8:
\p{r}{u}
## end
#380, 13:
\d{r}_{t}=v_r
## end
#383, 15:
-\p{z}{E_z}*r/2
## end
#385, 3:
E_r
## end
#388, 1779:
%{
+[M函数](,验证公式)

运行指令"nautilus Matlab/SEM"
test_u_1(M函数):...
test_traj_mat(M函数):...
+[新建阅读窗口](,test_u_1)
在选择区域中, 将'test_u_1'的"-inf"替换为"inf"
在选择区域中, 将'test_u_1'的"u_1=="替换为"abs(u_1)=="

测试电势:...
连续场轨迹:...
轨迹对比1:...
轨迹对比2:...
验证矩阵:...
问题具现:...
问题解决:...
(是因为在电子沿z方向加速的过程中, 其发射角其实也在发生变化. 这种变化是用\sqrt{V}来实现的. 矩阵输入和输出的\sqrt{V}应该是不一样的)
+[新建阅读窗口](,问题解决)

差分法对比:...
ODE对比:...

保存:...
%}

physics_constant;
addpath('Matlab/Physics');
addpath('Matlab/SEM');

U_1=-8000;
DU=7000;

D=100;
d_0=5;
% d_0=10;
d_1=d_0;
%{
+[M函数](,验证公式)
%}

E_0=DU/D;
U_0=U_1+DU;
u_1=@(z)test_u_1(z,d_1,d_0,D,E_0,U_1);
E_z=@(z,r)-(E_0/2*tanh((z+D)/d_1)+E_0/2*tanh((z-D)/d_1)-E_0*tanh(z/d_0));
E_r=@(z,r)E_0./2.*((1)./(cosh((z+D)./d_1).^(2).*d_1)+(1)./(cosh((z-D)./d_1).^(2).*d_1)-(2)./(cosh(z./d_0).^(2).*d_0)).*r/2;
B=@(z,r)zeros(size(r));

N=3000;
zs0=linspace(-2*D,2*D,N);
r0=1;
theta0=0;

dt=2e-9;
v_z=sqrt(-2*e*U_1/m_e);
v_r=v_z*theta0;
r=r0;
z=zs0(1);

rs2=r;
zs2=z;
t=(0:4100)*dt;

[zs1,rs1]=EM_motion_ODEs(z,r,v_z,v_r,t,e,me,B,E_z,E_r,'ode45');

for i=1:length(t)
% [z,r,p_z,p_r]=EM_re_motion_RK4(z,r,v_z*me,v_r*me,dt,t(i),e,me,B,E_z,E_r);
% v_z=p_z/me;
% v_r=p_r/me;

% [z,r,v_z,v_r]=EM_motion_RK4(z,r,v_z,v_r,dt,t(i),e,me,B,E_z,E_r);
% [z,r,v_z,v_r]=EM_motion_BEM(z,r,v_z,v_r,dt,t(i),e,me,B,E_z,E_r);
[z,r,v_z,v_r]=EM_motion_CM(z,r,v_z,v_r,dt,t(i),e,me,B,E_z,E_r);

zs2(end+1)=z;
rs2(end+1)=r;
end

[zs0,rs0,ts0]=test_traj_mat(zs0,u_1,r0,theta0);


subplot(2,1,1)
plot(zs1,rs1,'.',zs2,rs2,'r--',zs0,rs0)
axis([min(zs0),max(zs0),min(rs0),max(rs0)])
xlabel('x [m]')
ylabel('y [m]')
legend('ODE45','relativistic RK4','Matrix')

subplot(2,1,2)
plot(zs0,u_1(zs0))
xlabel('x [m]')
ylabel('U [V]')
axis([min(zs0),max(zs0),min(u_1(zs0)),max(u_1(zs0))])

% plot(zs2,rs2,'.')


%{
plot(zs,E_z(zs))
+[M函数](,验证公式)
%}
## end
#391, 678:
<!--
+[H函数](,测试场)
-->

<h2>Test field</h2>
If \(E_z\) is,
%[1].
Then, 
%[2].
%[3].
%[4].
By making \(t=cosh(z/d_0)\), we have, 
%[5].
%[6].
When \(z\rightarrow +\infty\), we have,
%[7].

<h2>Test lens field</h2>
If there are three parallel planes having separations of \(D\), and the potential of the center plane is \(U_0\), then we have,
%[8].

We have,
%[9].
And when \(z\rightarrow +\infty\), we have,
%[10].
%[11].

Then the \(E_z\) is,
%[12].
%[13].

And \(E_r\) is,
%[14].
%[15].

<!--
[15].:
式(1)转换为"表达式"
将"\d{E_z}_{z}=E_0/2*(\frac{1}{cosh((z+D)/d_1)^2*d_1}+\frac{1}{cosh((z-D)/d_1)^2*d_1}-\frac{2}{cosh(z/d_0)^2*d_0})"记作为式(15)
将式(14)记作为式(15)



更新式(11)
+[H函数](,测试场)
-->
## end
#393, 26:
E_{z}=E_{0}\ tanh(z/d_{0})
## end
#395, 19:
E_z=E_0*tanh(z/d_0)
## end
#399, 36:
E_{z}=-\frac{\partial u}{\partial z}
## end
#401, 41:
u=-\int_{}^{}{dz\ }{E_{0}\ tanh(z/d_{0})}
## end
#403, 55:
u=-\int_{}^{}{dz\ }{E_{0}\ sinh(z/d_{0})/cosh(z/d_{0})}
## end
#404, 13:
E_z=-\p{z}{u}
## end
#407, 33:
u=-\int_{}^{}{z}{E_0*tanh(z/d_0)}
## end
#410, 1:
z
## end
#412, 45:
u=-\int_{}^{}{z}{E_0*sinh(z/d_0)/cosh(z/d_0)}
## end
#417, 46:
u=-\int_{}^{}{dt\ }{d_{0}\ E_{0}\ \frac{1}{t}}
## end
#419, 40:
u=-d_{0}\ E_{0}\ ln(cosh(z/d_{0}))+u_{0}
## end
#420, 37:
u=-\int_{}^{}{t}{d_0*E_0*\frac{1}{t}}
## end
#423, 30:
u=-d_0*E_0*ln(cosh(z/d_0))+u_0
## end
#427, 51:
u\approx -d_{0}\ E_{0}\ z+d_{0}\ E_{0}\ ln(2)+u_{0}
## end
#429, 140:
u(z)=d_{1}\ E_{0}/2\ ln(cosh(\left(z+D\right)/d_{1}))+d_{1}\ E_{0}/2\ ln(cosh(\left(z-D\right)/d_{1}))-d_{0}\ E_{0}\ ln(cosh(z/d_{0}))+u_{0}
## end
#431, 13:
E_{0}=U_{0}/D
## end
#432, 30:
u~-d_0*E_0*z+d_0*E_0*ln(2)+u_0
## end
#436, 49:
u(z)=ln(2)\ E_{0}\ \left(d_{0}-d_{1}\right)+u_{0}
## end
#437, 92:
u(z)=d_1*E_0/2*ln(cosh((z+D)/d_1))+d_1*E_0/2*ln(cosh((z-D)/d_1))-d_0*E_0*ln(cosh(z/d_0))+u_0
## end
#440, 9:
E_0=U_0/D
## end
#443, 28:
u(z)=ln(2)*E_0*(d_0-d_1)+u_0
## end
#447, 45:
u_{0}=-ln(2)\ E_{0}\ \left(d_{0}-d_{1}\right)
## end
#448, 24:
u_0=-ln(2)*E_0*(d_0-d_1)
## end
#454, 316:
%{
+[修改天使]
+[M函数](,测试电势)
%}

U_0=100;
D=100;
d_0=0.5;
d_1=0.5;

E_0=U_0/D;
u_0=-log(2)*E_0*(d_0-d_1);

u=@(z)-d_0*E_0*log(cosh(z/d_0))+u_0;
u_1=@(z)d_1*E_0/2*log(cosh((z+D)/d_1))+d_1*E_0/2*log(cosh((z-D)/d_1))-d_0*E_0*log(cosh(z/d_0))+u_0;

z=linspace(-3*D,3*D,1000);
plot(z,u_1(z));



%{
交换式(2)的两边
+[M函数](,验证公式)
%}
## end
#456, 802:
%{
+[M函数](,验证公式)

测试电势:...
%}

addpath('Matlab/SEM')

U_1=-8000;
DU=-4000;

D=100;
d_0=5;
d_1=50;

E_0=DU/D;
u_0=-log(2)*E_0*(d_0-d_1);

u_1=@(z)d_1*E_0/2*log(cosh((z+D)/d_1))+d_1*E_0/2*log(cosh((z-D)/d_1))-d_0*E_0*log(cosh(z/d_0))+u_0+U_1;

Re=@(E_1,E_2,En_0)[1,0;-(E_1-E_2)./(4.*sqrt(En_0)),1];
Ts=@(En_1,En_2,d)[1,(2.*d)./(sqrt(En_1)+sqrt(En_2));0,1];

z=linspace(-3*D,3*D,1000);
d=6*D/(1000-1);

r=100;
theta=0;
rs=[];

for i=2:length(z)-2
En_1=(0-u_1(z(i)));
En_2=(0-u_1(z(i+1)));
En_0=(En_1+En_2)/2;

E_1=(u_1(z(i+1))-u_1(z(i-1)))/2*d;
E_2=(u_1(z(i+2))-u_1(z(i)))/2*d;

R1=Re(E_1,E_2,En_0);
T1=Ts(En_1,En_2,d);
T=R1*T1;

r_1=r*T(1,1)+theta*T(1,2)*sqrt(En_0);
theta_1=(r*T(2,1)+theta*T(2,2)*sqrt(En_0))/sqrt(En_0);
r=r_1;
theta=theta_1;
rs(end+1)=r;
end

plot(z(2:end-2),rs);


%{
+[M函数](,验证公式)
%}
## end
#458, 1011:
%{
+[M函数](,验证公式)

测试电势:...
连续场轨迹:...
轨迹对比1:...
%}

addpath('Matlab/SEM')

U_1=-8000;
DU=4000;

D=100;
d_0=1;
d_1=1;
%{
U_0
U_1
+[M函数](,验证公式)
%}

E_0=DU/D;
u_0=-log(2)*E_0*(d_0-d_1);
U_0=U_1+DU;

u_1=@(z)d_1*E_0/2*log(cosh((z+D)/d_1))+d_1*E_0/2*log(cosh((z-D)/d_1))-d_0*E_0*log(cosh(z/d_0))+u_0+U_1;

Re=@(E_1,E_2,En_0)[1,0;-(E_1-E_2)./(4.*sqrt(En_0)),1];
Ts=@(En_1,En_2,d)[1,(2.*d)./(sqrt(En_1)+sqrt(En_2));0,1];

z=linspace(-3*D,3*D,1000);
d=6*D/(1000-1);

r0=100;

r=r0;
theta=0;
rs=[];

for i=2:length(z)-2
En_1=(0-u_1(z(i)));
En_2=(0-u_1(z(i+1)));
En_0=(En_1+En_2)/2;

E_1=(u_1(z(i+1))-u_1(z(i-1)))/2/d;
E_2=(u_1(z(i+2))-u_1(z(i)))/2/d;

R1=Re(E_1,E_2,En_0);
T1=Ts(En_1,En_2,d);
T=R1*T1;

r_1=r*T(1,1)+theta*T(1,2)*sqrt(En_0);
theta_1=(r*T(2,1)+theta*T(2,2)*sqrt(En_0))/sqrt(En_0);
r=r_1;
theta=theta_1;
rs(end+1)=r;
end


% simple
D0=2*D;
U0=abs(U_1);
U1=abs(U_0);
Z=1/2*(max(z)-min(z));
[zs0,rs0]=lenses_traj(0,r0,0,U0,D0,U1,Z);
zs0=zs0-Z(1)-D;

plot(z(2:end-2),rs,zs0,rs0,'-o');


%{
clf
+[M函数](,验证公式)
%}
## end
#460, 1430:
%{
+[M函数](,验证公式)

测试电势:...
连续场轨迹:...
轨迹对比1:...
轨迹对比2:...
%}

addpath('Matlab/SEM')

U_1=-8000;
DU=4000;

D=100;
d_0=1.5;
d_1=d_0;
%{
+[M函数](,验证公式)
%}

E_0=DU/D;
u_0=-log(2)*E_0*(d_0-d_1);
U_0=U_1+DU;

u_1=@(z)d_1*E_0/2*log(cosh((z+D)/d_1))+d_1*E_0/2*log(cosh((z-D)/d_1))-d_0*E_0*log(cosh(z/d_0))+u_0+U_1;

Re=@(E_1,E_2,En_0)[1,0;-(E_1-E_2)./(4.*sqrt(En_0)),1];
Ts=@(En_1,En_2,d)[1,(2.*d)./(sqrt(En_1)+sqrt(En_2));0,1];

%{
+[M函数](,验证公式)
%}
N=5000;
z=linspace(-3*D,3*D,N);
d=(max(z)-min(z))/(N-1);

r0=100;
theta0=0;

r=r0;
theta=0;
rs=[];

E_max=max((u_1(z(2:end))-u_1(z(1:end-1)))/2*d);
E_max=max((u_1(z(2:end))-u_1(z(1:end-1))))/d;

T0=eye(2);
for i=2:length(z)-2
En_1=(0-u_1(z(i)));
En_2=(0-u_1(z(i+1)));
En_0=(En_1+En_2)/2;

E_1=(u_1(z(i+1))-u_1(z(i-1)))/2/d;
E_2=(u_1(z(i+2))-u_1(z(i)))/2/d;

R1=Re(E_1,E_2,En_0);
T1=Ts(En_1,En_2,d);
T=R1*T1;
T0=T0*T;

r_1=r*T(1,1)+theta*T(1,2)*sqrt(En_0);
theta_1=(r*T(2,1)+theta*T(2,2)*sqrt(En_0))/sqrt(En_0);
r=r_1;
theta=theta_1;
rs(end+1)=r;
end
zs=z(2:end-2);

%{
U_0
+[M函数](,验证公式)
%}
% simple
D0=2*D;
U0=abs(U_1);
U1=abs(U_0);
[L,L1,L2]=lens_matrix(D0,U1,U0);
zs0=[z(1),-D,0,D,z(end)];
rs0=zeros(1,5);
rs0(1)=r0;
rs0(2)=r0+(zs0(2)-zs0(1))*theta0;
rs0(3)=L2(1,1)*rs0(2)+L2(1,2)*theta0*sqrt(U0);
rs0(4)=L(1,1)*rs0(2)+L(1,2)*theta0*sqrt(U0);
theta4=(L(2,1)*rs0(2)+L(2,2)*theta0*sqrt(U0))/sqrt(U0);
rs0(5)=rs0(4)+(zs0(5)-zs0(4))*theta4;

plot(zs,rs,zs0,rs0,'-o');


%{
T0
+[M函数](,验证公式)
%}
## end
#462, 309:
\mathbf{R}=\mathbf{R_{2}}\ \mathbf{R_{1}}=\begin{pmatrix}
1&0\\ -\frac{E_{2}-E_{3}}{4\ \sqrt{V_{0}}}&1
\end{pmatrix}

\ \begin{pmatrix}
1&0\\ -\frac{E_{1}-E_{2}}{4\ \sqrt{V_{0}}}&1
\end{pmatrix}

=\begin{pmatrix}
1&0\\ -\frac{E_{1}-E_{2}}{4\ \sqrt{V_{0}}}-\frac{E_{2}-E_{3}}{4\ \sqrt{V_{0}}}&1
\end{pmatrix}


## end
#464, 374:
\mathbf{R_{1}}\ \mathbf{T_{1}}=\begin{pmatrix}
1&0\\ -\frac{E_{1}-E_{2}}{4\ \sqrt{V_{0}}}&1
\end{pmatrix}

\ \begin{pmatrix}
1&\frac{2\ d}{\sqrt{V_{1}}+\sqrt{V_{2}}}\\ 0&1
\end{pmatrix}

=\begin{pmatrix}
1&\frac{2\ d}{\sqrt{V_{1}}+\sqrt{V_{2}}}\\ -\frac{E_{1}-E_{2}}{4\ \sqrt{V_{0}}}&1-\frac{E_{1}-E_{2}}{2\ \sqrt{V_{0}}}\ \frac{d}{\sqrt{V_{1}}+\sqrt{V_{2}}}
\end{pmatrix}


## end
#466, 361:
\mathbf{R_{1}}\ \mathbf{T_{1}}\approx \begin{pmatrix}
1&\frac{2\ d}{\sqrt{V_{1}}+\sqrt{V_{2}}}\\ -\frac{E_{1}-E_{2}}{4\ \sqrt{V_{0}}}&1-\frac{E_{1}-E_{2}}{4\ V_{0}}\ d
\end{pmatrix}

\approx \begin{pmatrix}
1&\frac{2\ d}{\sqrt{V_{1}}+\sqrt{V_{2}}}\\ -\frac{E_{1}-E_{2}}{4\ \sqrt{V_{0}}}&1-\frac{\partial^{2}V}{\partial z^{2}}\ \frac{d^{2}}{4\ V}
\end{pmatrix}


## end
#467, 182:
\mat{R}=\mat{R_2}*\mat{R_1}=\mat{1,0;-\frac{E_2-E_3}{4*\sqrt{V_0}},1}*\mat{1,0;-\frac{E_1-E_2}{4*\sqrt{V_0}},1}=\mat{1,0;-\frac{E_1-E_2}{4*\sqrt{V_0}}-\frac{E_2-E_3}{4*\sqrt{V_0}},1}
## end
#470, 242:
\mat{R_1}*\mat{T_1}=\mat{1,0;-\frac{E_1-E_2}{4*\sqrt{V_0}},1}*\mat{1,\frac{2*d}{\sqrt{V_1}+\sqrt{V_2}};0,1}=\mat{1,\frac{2*d}{\sqrt{V_1}+\sqrt{V_2}};-\frac{E_1-E_2}{4*\sqrt{V_0}},1-\frac{E_1-E_2}{2*\sqrt{V_0}}*\frac{d}{\sqrt{V_1}+\sqrt{V_2}}}
## end
#473, 218:
\mat{R_1}*\mat{T_1}~\mat{1,\frac{2*d}{\sqrt{V_1}+\sqrt{V_2}};-\frac{E_1-E_2}{4*\sqrt{V_0}},1-\frac{E_1-E_2}{4*V_0}*d}~\mat{1,\frac{2*d}{\sqrt{V_1}+\sqrt{V_2}};-\frac{E_1-E_2}{4*\sqrt{V_0}},1-\p{z,z}{V}*\frac{d^2}{4*V}}
## end
#477, 151:
\mathbf{R_{1}}\ \mathbf{T_{1}}\approx \begin{pmatrix}
1&\frac{2\ d}{\sqrt{V_{1}}+\sqrt{V_{2}}}\\ -\frac{E_{1}-E_{2}}{4\ \sqrt{V_{0}}}&1
\end{pmatrix}


## end
#479, 169:
\mathbf{R_{1}}\ \mathbf{T_{1}}\ \mathbf{R_{2}}\ \mathbf{T_{2}}\approx \begin{pmatrix}
1&\frac{d+d}{\sqrt{V_{0}}}\\ -\frac{E_{1}-E_{3}}{4\ \sqrt{V_{0}}}&1
\end{pmatrix}


## end
#480, 93:
\mat{R_1}*\mat{T_1}~\mat{1,\frac{2*d}{\sqrt{V_1}+\sqrt{V_2}};-\frac{E_1-E_2}{4*\sqrt{V_0}},1}
## end
#483, 102:
\mat{R_1}*\mat{T_1}*\mat{R_2}*\mat{T_2}~\mat{1,\frac{d+d}{\sqrt{V_0}};-\frac{E_1-E_3}{4*\sqrt{V_0}},1}
## end
#487, 737:
%{
地址::Matlab/SEM/test_u_1.m
+[保存M函数](,test_u_1)
%}

function [u,u_1,u_2,u_3,u_0]=test_u_1(z,d_1,d_0,D,E_0,U_1)

u_1=d_1*E_0/2*log(cosh((z+D)/d_1));
i1=find(abs(u_1)==inf & (z+D)>0);
i2=find(abs(u_1)==inf & (z+D)<0);
u_1(i1)=E_0/2*(z(i1)+D)-d_1*E_0/2*log(2);
u_1(i2)=-E_0/2*(z(i2)+D)-d_1*E_0/2*log(2);

u_2=d_1*E_0/2*log(cosh((z-D)/d_1));
i1=find(abs(u_2)==inf & (z-D)>0);
i2=find(abs(u_2)==inf & (z-D)<0);
u_2(i1)=E_0/2*(z(i1)-D)-d_1*E_0/2*log(2);
u_2(i2)=-E_0/2*(z(i2)-D)-d_1*E_0/2*log(2);

u_3=d_0*E_0*log(cosh(z/d_0));
i1=find(abs(u_3)==inf & z>0);
i2=find(abs(u_3)==inf & z<0);
u_3(i1)=E_0*z(i1)-d_0*E_0*log(2);
u_3(i2)=-E_0*z(i2)-d_0*E_0*log(2);

u_0=-log(2)*E_0*(d_0-d_1);

u=u_1+u_2-u_3+u_0+U_1;


end


%{
+[保存M函数](,test_u_1)
%}
## end
#490, 21:
Matlab/SEM/test_u_1.m
## end
#506, 1378:
%{
+[M函数](,验证矩阵)

运行指令"nautilus Matlab/SEM"
test_u_1(M函数):...
+[新建阅读窗口](,test_u_1)
在选择区域中, 将'test_u_1'的"-inf"替换为"inf"
在选择区域中, 将'test_u_1'的"u_1=="替换为"abs(u_1)=="

测试电势:...
连续场轨迹:...
轨迹对比1:...
轨迹对比2:...
%}

addpath('Matlab/SEM')

U_1=-8000;
DU=4000;

D=100;
d_0=0.001;
d_1=d_0;
%{
+[M函数](,验证公式)
%}

E_0=DU/D;
% u_0=-log(2)*E_0*(d_0-d_1);
U_0=U_1+DU;

% u_1=@(z)d_1*E_0/2*log(cosh((z+D)/d_1))+d_1*E_0/2*log(cosh((z-D)/d_1))-d_0*E_0*log(cosh(z/d_0))+u_0+U_1;
u_1=@(z)test_u_1(z,d_1,d_0,D,E_0,U_1);

Re=@(E_1,E_2,En_0)[1,0;-(E_1-E_2)./(4.*sqrt(En_0)),1];
Ts=@(En_1,En_2,d)[1,(2.*d)./(sqrt(En_1)+sqrt(En_2));0,1];

%{
+[M函数](,验证公式)
%}
N=5000;
% z=linspace(-3*D,3*D,N);
z=linspace(-200,-50,N);
d=(max(z)-min(z))/(N-1);

r0=100;
theta0=0;

r=r0;
theta=0;
rs=[];

E_max=max((u_1(z(2:end))-u_1(z(1:end-1)))/2/d);
E_max=max((u_1(z(2:end))-u_1(z(1:end-1))))/d;

T0=eye(2);
for i=2:length(z)-2
En_1=(0-u_1(z(i)));
En_2=(0-u_1(z(i+1)));
En_0=(En_1+En_2)/2;

E_1=(u_1(z(i+1))-u_1(z(i-1)))/2/d;
E_2=(u_1(z(i+2))-u_1(z(i)))/2/d;

R1=Re(E_1,E_2,En_0);
T1=Ts(En_1,En_2,d);
T=R1*T1;
T0=T0*T;

r_1=r*T(1,1)+theta*T(1,2)*sqrt(En_0);
theta_1=(r*T(2,1)+theta*T(2,2)*sqrt(En_0))/sqrt(En_0);
r=r_1;
theta=theta_1;
rs(end+1)=r;
end
zs=z(2:end-2);


T0(2,1)*4*sqrt(-U_1)
plot(z,u_1(z))
%{
[u,u1,u2,u3,u0]=test_u_1(z,d_1,d_0,D,E_0,U_1);
plot(z,u1,z,u2,z,u3)
i=find(abs(u2)==inf & (z-D)<0)


+[M函数](,验证公式)
%}
## end
#508, 2175:
%{
+[M函数](,验证公式)

运行指令"nautilus Matlab/SEM"
test_u_1(M函数):...
+[新建阅读窗口](,test_u_1)
在选择区域中, 将'test_u_1'的"-inf"替换为"inf"
在选择区域中, 将'test_u_1'的"u_1=="替换为"abs(u_1)=="

测试电势:...
连续场轨迹:...
轨迹对比1:...
轨迹对比2:...
验证矩阵:...

%}

addpath('Matlab/SEM')

U_1=-8000;
DU=4000;

D=100;
d_0=1e-6;
% d_0=2;
d_1=d_0;
%{
+[M函数](,验证公式)
%}

E_0=DU/D;
% u_0=-log(2)*E_0*(d_0-d_1);
U_0=U_1+DU;

% u_1=@(z)d_1*E_0/2*log(cosh((z+D)/d_1))+d_1*E_0/2*log(cosh((z-D)/d_1))-d_0*E_0*log(cosh(z/d_0))+u_0+U_1;
u_1=@(z)test_u_1(z,d_1,d_0,D,E_0,U_1);

Re=@(E_1,E_2,En_0)[1,0;-(E_1-E_2)./(4.*sqrt(En_0)),1];
Ts=@(En_1,En_2,d)[1,(2.*d)./(sqrt(En_1)+sqrt(En_2));0,1];

%{
+[M函数](,验证公式)
%}
N=5000;
z=linspace(-3*D,3*D,N);
% z=linspace(-200,-50,N);
d=(max(z)-min(z))/(N-1);

r0=100;
theta0=0;

r=r0;
theta=0;
rs=[];
ts=[];

T0=eye(2);
for i=2:length(z)-2
En_1=(0-u_1(z(i)));
En_2=(0-u_1(z(i+1)));
En_0=(En_1+En_2)/2;

E_1=(u_1(z(i+1))-u_1(z(i-1)))/2/d;
E_2=(u_1(z(i+2))-u_1(z(i)))/2/d;

R1=Re(E_1,E_2,En_0);
T1=Ts(En_1,En_2,d);
T=R1*T1;

%{
+[M函数](,验证公式)
%}
if z(i)<-100-0.5
    T0=T0*T;
end
r_1=r*T(1,1)+theta*T(1,2)*sqrt(En_0);
theta_1=(r*T(2,1)+theta*T(2,2)*sqrt(En_0))/sqrt(En_0);
r=r_1;
theta=theta_1;

rs(end+1)=r;
ts(end+1)=theta;
end
zs=z(2:end-2);


% simple
D0=2*D;
U0=abs(U_1);
U1=abs(U_0);
[L,L1,L2]=lens_matrix(D0,U1,U0);
zs0=[z(1),-D,0,D,z(end)];
rs0=zeros(1,5);
ts0=zeros(1,5);

rs0(1)=r0;
rs0(2)=r0+(zs0(2)-zs0(1))*theta0;
rs0(3)=L2(1,1)*rs0(2)+L2(1,2)*theta0*sqrt(U0);
rs0(4)=L(1,1)*rs0(2)+L(1,2)*theta0*sqrt(U0);
theta4=(L(2,1)*rs0(2)+L(2,2)*theta0*sqrt(U0))/sqrt(U0);
rs0(5)=rs0(4)+(zs0(5)-zs0(4))*theta4;

ts0(1)=theta0;
ts0(2)=L1(2,1)*rs0(2)/sqrt(U0)+L1(2,2)*theta0;
ts0(3)=(L2(2,1)*rs0(2)+L2(2,2)*theta0*sqrt(U0))/sqrt(U1);
ts0(4)=(L(2,1)*rs0(2)+L(2,2)*theta0*sqrt(U0))/sqrt(U0);
ts0(5)=theta4;


Dz=max(zs(zs>-80 & zs<-10))-min(zs(zs>-80 & zs<-10));
Dr=max(rs(zs>-80 & zs<-10))-min(rs(zs>-80 & zs<-10));
Dr/Dz

Dz0=zs0(3)-zs0(2);
Dr0=rs0(3)-rs0(2);
Dr0/Dz0


subplot(1,2,1)
plot(zs,rs,zs0,rs0,'-o');
subplot(1,2,2)
plot(zs,ts,'.-',zs0,ts0,'o');
max(ts)

% L1(2,1)*4*sqrt(-U_1)
% T0(2,1)*4*sqrt(-U_1)
% L1,T0
%{
[u,u1,u2,u3,u0]=test_u_1(z,d_1,d_0,D,E_0,U_1);
plot(z,u1,z,u2,z,u3)

+[M函数](,验证公式)
%}
## end
#510, 1776:
%{
+[M函数](,问题解决)
%}

addpath('Matlab/SEM')

U_1=-8000;
DU=1000;

D=100;
% d_0=1e-6;
d_0=0.1;
d_1=d_0;
%{
+[M函数](,问题解决)
%}

E_0=DU/D;
% u_0=-log(2)*E_0*(d_0-d_1);
U_0=U_1+DU;

% u_1=@(z)d_1*E_0/2*log(cosh((z+D)/d_1))+d_1*E_0/2*log(cosh((z-D)/d_1))-d_0*E_0*log(cosh(z/d_0))+u_0+U_1;
u_1=@(z)test_u_1(z,d_1,d_0,D,E_0,U_1);

Re=@(E_1,E_2,En_0)[1,0;-(E_1-E_2)./(4.*sqrt(En_0)),1];
Ts=@(En_1,En_2,d)[1,(2.*d)./(sqrt(En_1)+sqrt(En_2));0,1];

%{
+[M函数](,问题解决)
%}
N=5000;
z=linspace(-3*D,3*D,N);
% z=linspace(-200,-50,N);
d=(max(z)-min(z))/(N-1);

r0=1;
theta0=0;

r=r0;
theta_sqrtV=0;
rs=[];
ts=[];

T0=eye(2);
for i=2:length(z)-2
En_1=(0-u_1(z(i)));
En_2=(0-u_1(z(i+1)));
En_0=(En_1+En_2)/2;

E_1=(u_1(z(i+1))-u_1(z(i-1)))/2/d;
E_2=(u_1(z(i+2))-u_1(z(i)))/2/d;

R1=Re(E_1,E_2,En_0);
T1=Ts(En_1,En_2,d);
T=R1*T1;

%{
+[M函数](,验证公式)
%}
if z(i)<-100-0.5
    T0=T0*T;
end
r_1=r*T(1,1)+theta_sqrtV*T(1,2);
theta_sV1=r*T(2,1)+theta_sqrtV*T(2,2);
r=r_1;
theta_sqrtV=theta_sV1;

rs(end+1)=r;
ts(end+1)=theta_sqrtV/sqrt(En_0);
end
zs=z(2:end-2);

% simple
D0=2*D;
U0=abs(U_1);
U1=abs(U_0);
[L,L1,L2,T1_0,T2_0]=lens_matrix(D0,U1,U0);
zs0=[z(1),-D,0,D,z(end)];
rs0=zeros(1,5);
ts0=zeros(1,5);

rs0(1)=r0;
rs0(2)=r0+(zs0(2)-zs0(1))*theta0;
rs0(3)=L2(1,1)*rs0(2)+L2(1,2)*theta0*sqrt(U0);
rs0(4)=L(1,1)*rs0(2)+L(1,2)*theta0*sqrt(U0);
theta4=(L(2,1)*rs0(2)+L(2,2)*theta0*sqrt(U0))/sqrt(U0);
rs0(5)=rs0(4)+(zs0(5)-zs0(4))*theta4;

ts0(1)=theta0;
ts0(2)=L1(2,1)*rs0(2)/sqrt(U0)+L1(2,2)*theta0;
ts0(3)=(L2(2,1)*rs0(2)+L2(2,2)*theta0*sqrt(U0))/sqrt(U1);
ts0(4)=(L(2,1)*rs0(2)+L(2,2)*theta0*sqrt(U0))/sqrt(U0);
ts0(5)=theta4;


subplot(1,2,1)
plot(zs,rs,zs0,rs0,'-o');
subplot(1,2,2)
plot(zs,ts,'.-',zs0,ts0,'o');

%{
[u,u1,u2,u3,u0]=test_u_1(z,d_1,d_0,D,E_0,U_1);
plot(z,u1,z,u2,z,u3)


+[M函数](,验证公式)
%}
## end
#512, 2297:
%{
+[M函数](,验证公式)

运行指令"nautilus Matlab/SEM"
test_u_1(M函数):...
+[新建阅读窗口](,test_u_1)
在选择区域中, 将'test_u_1'的"-inf"替换为"inf"
在选择区域中, 将'test_u_1'的"u_1=="替换为"abs(u_1)=="

测试电势:...
连续场轨迹:...
轨迹对比1:...
轨迹对比2:...
验证矩阵:...
问题具现:...
问题解决:...
(是因为在电子沿z方向加速的过程中, 其发射角其实也在发生变化. 这种变化是用\sqrt{V}来实现的. 矩阵输入和输出的\sqrt{V}应该是不一样的)

%}

addpath('Matlab/SEM')

U_1=-8000;
DU=4000;

D=100;
d_0=1e-6;
% d_0=2;
d_1=d_0;
%{
+[M函数](,验证公式)
%}

E_0=DU/D;
% u_0=-log(2)*E_0*(d_0-d_1);
U_0=U_1+DU;

% u_1=@(z)d_1*E_0/2*log(cosh((z+D)/d_1))+d_1*E_0/2*log(cosh((z-D)/d_1))-d_0*E_0*log(cosh(z/d_0))+u_0+U_1;
u_1=@(z)test_u_1(z,d_1,d_0,D,E_0,U_1);

Re=@(E_1,E_2,En_0)[1,0;-(E_1-E_2)./(4.*sqrt(En_0)),1];
Ts=@(En_1,En_2,d)[1,(2.*d)./(sqrt(En_1)+sqrt(En_2));0,1];

%{
+[M函数](,验证公式)
%}
N=5000;
z=linspace(-3*D,3*D,N);
% z=linspace(-200,-50,N);
d=(max(z)-min(z))/(N-1);

r0=100;
theta0=0;

r=r0;
theta=0;
rs=[];
ts=[];

T0=eye(2);
for i=2:length(z)-2
En_1=(0-u_1(z(i)));
En_2=(0-u_1(z(i+1)));
En_0=(En_1+En_2)/2;

E_1=(u_1(z(i+1))-u_1(z(i-1)))/2/d;
E_2=(u_1(z(i+2))-u_1(z(i)))/2/d;

R1=Re(E_1,E_2,En_0);
T1=Ts(En_1,En_2,d);
T=R1*T1;

%{
+[M函数](,验证公式)
%}
if z(i)<-100-0.5
    T0=T0*T;
end
r_1=r*T(1,1)+theta*T(1,2)*sqrt(En_0);
theta_1=(r*T(2,1)+theta*T(2,2)*sqrt(En_1))/sqrt(En_2);
r=r_1;
theta=theta_1;

rs(end+1)=r;
ts(end+1)=theta;
end
zs=z(2:end-2);

T1_0,L1
T1_0*L1
% simple
D0=2*D;
U0=abs(U_1);
U1=abs(U_0);
[L,L1,L2,T1_0,T2_0]=lens_matrix(D0,U1,U0);
zs0=[z(1),-D,0,D,z(end)];
rs0=zeros(1,5);
ts0=zeros(1,5);

rs0(1)=r0;
rs0(2)=r0+(zs0(2)-zs0(1))*theta0;
rs0(3)=L2(1,1)*rs0(2)+L2(1,2)*theta0*sqrt(U0);
rs0(4)=L(1,1)*rs0(2)+L(1,2)*theta0*sqrt(U0);
theta4=(L(2,1)*rs0(2)+L(2,2)*theta0*sqrt(U0))/sqrt(U0);
rs0(5)=rs0(4)+(zs0(5)-zs0(4))*theta4;

ts0(1)=theta0;
ts0(2)=L1(2,1)*rs0(2)/sqrt(U0)+L1(2,2)*theta0;
ts0(3)=(L2(2,1)*rs0(2)+L2(2,2)*theta0*sqrt(U0))/sqrt(U1);
ts0(4)=(L(2,1)*rs0(2)+L(2,2)*theta0*sqrt(U0))/sqrt(U0);
ts0(5)=theta4;


Dz=max(zs(zs>-80 & zs<-10))-min(zs(zs>-80 & zs<-10));
Dr=max(rs(zs>-80 & zs<-10))-min(rs(zs>-80 & zs<-10));
Dr/Dz

Dz0=zs0(3)-zs0(2);
Dr0=rs0(3)-rs0(2);
Dr0/Dz0


subplot(1,2,1)
plot(zs,rs,zs0,rs0,'-o');
subplot(1,2,2)
plot(zs,ts,'.-',zs0,ts0,'o');
max(ts)

% L1(2,1)*4*sqrt(-U_1)
% T0(2,1)*4*sqrt(-U_1)
% L1,T0
%{
[u,u1,u2,u3,u0]=test_u_1(z,d_1,d_0,D,E_0,U_1);
plot(z,u1,z,u2,z,u3)


+[M函数](,验证公式)
%}
## end
#514, 22:
E_{z}=\frac{du(z)}{dz}
## end
#516, 102:
E_{z}=E_{0}/2\ tanh(\left(z+D\right)/d_{1})+E_{0}/2\ tanh(\left(z-D\right)/d_{1})-E_{0}\ tanh(z/d_{0})
## end
#518, 28:
E_{r}=\frac{dE_{z}}{dz}\ r/2
## end
#519, 16:
E_z=\d{u(z)}_{z}
## end
#522, 63:
E_z=E_0/2*tanh((z+D)/d_1)+E_0/2*tanh((z-D)/d_1)-E_0*tanh(z/d_0)
## end
#526, 174:
\frac{dE_{z}}{dz}=E_{0}/2\ \left(\frac{1}{cosh(\left(z+D\right)/d_{1})^{2}\ d_{1}}+\frac{1}{cosh(\left(z-D\right)/d_{1})^{2}\ d_{1}}-\frac{2}{cosh(z/d_{0})^{2}\ d_{0}}\right)
## end
#527, 19:
E_r=\d{E_z}_{z}*r/2
## end
#530, 111:
\d{E_z}_{z}=E_0/2*(\frac{1}{cosh((z+D)/d_1)^2*d_1}+\frac{1}{cosh((z-D)/d_1)^2*d_1}-\frac{2}{cosh(z/d_0)^2*d_0})
## end
#534, 767:
%{
地址::Matlab/SEM/test_traj_mat.m
+[保存M函数](,test_traj_mat)

测试:...
+[新建阅读窗口](,测试)
%}

function [zs,rs,ts]=test_traj_mat(z,u_1,r0,theta0)

Re=@(E_1,E_2,En_0)[1,0;-(E_1-E_2)./(4.*sqrt(En_0)),1];
Ts=@(En_1,En_2,d)[1,(2.*d)./(sqrt(En_1)+sqrt(En_2));0,1];

% r0=1;
% theta0=0;

d=(max(z)-min(z))/(length(z)-1);

r=r0;
theta_sqrtV=0;
rs=[];
ts=[];

T0=eye(2);
for i=2:length(z)-2
En_1=(0-u_1(z(i)));
En_2=(0-u_1(z(i+1)));
En_0=(En_1+En_2)/2;

E_1=(u_1(z(i+1))-u_1(z(i-1)))/2/d;
E_2=(u_1(z(i+2))-u_1(z(i)))/2/d;

R1=Re(E_1,E_2,En_0);
T1=Ts(En_1,En_2,d);
T=R1*T1;

T0=T0*T;

r_1=r*T(1,1)+theta_sqrtV*T(1,2);
theta_sV1=r*T(2,1)+theta_sqrtV*T(2,2);
r=r_1;
theta_sqrtV=theta_sV1;

rs(end+1)=r;
ts(end+1)=theta_sqrtV/sqrt(En_0);
end
zs=z(2:end-2);

end

%{
+[保存M函数](,test_u_1)
%}
## end
#537, 26:
Matlab/SEM/test_traj_mat.m
## end
#542, 1135:
%{
+[M函数](,测试)
%}

addpath('Matlab/SEM')

U_1=-8000;
DU=1000;

D=100;
% d_0=1e-6;
d_0=1;
d_1=d_0;

E_0=DU/D;
% u_0=-log(2)*E_0*(d_0-d_1);
U_0=U_1+DU;

% u_1=@(z)d_1*E_0/2*log(cosh((z+D)/d_1))+d_1*E_0/2*log(cosh((z-D)/d_1))-d_0*E_0*log(cosh(z/d_0))+u_0+U_1;
u_1=@(z)test_u_1(z,d_1,d_0,D,E_0,U_1);


N=5000;
z=linspace(-3*D,3*D,N);
r0=1;
theta0=0;

[zs,rs,ts]=test_traj_mat(z,u_1,r0,theta0);

% simple
D0=2*D;
U0=abs(U_1);
U1=abs(U_0);
[L,L1,L2,T1_0,T2_0]=lens_matrix(D0,U1,U0);
zs0=[z(1),-D,0,D,z(end)];
rs0=zeros(1,5);
ts0=zeros(1,5);

rs0(1)=r0;
rs0(2)=r0+(zs0(2)-zs0(1))*theta0;
rs0(3)=L2(1,1)*rs0(2)+L2(1,2)*theta0*sqrt(U0);
rs0(4)=L(1,1)*rs0(2)+L(1,2)*theta0*sqrt(U0);
theta4=(L(2,1)*rs0(2)+L(2,2)*theta0*sqrt(U0))/sqrt(U0);
rs0(5)=rs0(4)+(zs0(5)-zs0(4))*theta4;

ts0(1)=theta0;
ts0(2)=L1(2,1)*rs0(2)/sqrt(U0)+L1(2,2)*theta0;
ts0(3)=(L2(2,1)*rs0(2)+L2(2,2)*theta0*sqrt(U0))/sqrt(U1);
ts0(4)=(L(2,1)*rs0(2)+L(2,2)*theta0*sqrt(U0))/sqrt(U0);
ts0(5)=theta4;


subplot(1,2,1)
plot(zs,rs,zs0,rs0,'-o');
subplot(1,2,2)
plot(zs,ts,'.-',zs0,ts0,'o');

%{
[u,u1,u2,u3,u0]=test_u_1(z,d_1,d_0,D,E_0,U_1);
plot(z,u1,z,u2,z,u3)


+[M函数](,测试)
%}
## end
#544, 1361:
%{
+[M函数](,验证公式)

运行指令"nautilus Matlab/SEM"
test_u_1(M函数):...
test_traj_mat(M函数):...
+[新建阅读窗口](,test_u_1)
在选择区域中, 将'test_u_1'的"-inf"替换为"inf"
在选择区域中, 将'test_u_1'的"u_1=="替换为"abs(u_1)=="

测试电势:...
连续场轨迹:...
轨迹对比1:...
轨迹对比2:...
验证矩阵:...
问题具现:...
问题解决:...
(是因为在电子沿z方向加速的过程中, 其发射角其实也在发生变化. 这种变化是用\sqrt{V}来实现的. 矩阵输入和输出的\sqrt{V}应该是不一样的)
+[新建阅读窗口](,问题解决)

差分法对比:...

保存:...
%}

physics_constant;
addpath('Matlab/SEM')

U_1=-8000;
DU=4000;

D=100;
d_0=10;
% d_0=10;
d_1=d_0;
%{
+[M函数](,验证公式)
%}

E_0=DU/D;
U_0=U_1+DU;
u_1=@(z)test_u_1(z,d_1,d_0,D,E_0,U_1);
E_z=@(z)E_0/2*tanh((z+D)/d_1)+E_0/2*tanh((z-D)/d_1)-E_0*tanh(z/d_0);
E_r=@(r,z)-E_0./2.*((1)./(cosh((z+D)./d_1).^(2).*d_1)+(1)./(cosh((z-D)./d_1).^(2).*d_1)-(2)./(cosh(z./d_0).^(2).*d_0)).*r/2;

N=3000;
zs0=linspace(-2*D,2*D,N);
r0=1;
theta0=0;

dt=0.2e-9;
v_z=sqrt(-2*e*U_1/m_e);
v_r=v_z*theta0;
r=r0;
z=zs0(1);

rs=r;
zs=z;

for i=1:50000
a_r=-e*E_r(r,z)/m_e;
a_z=-e*E_z(z)/m_e;
v_r=v_r+a_r*dt;
v_z=v_z+a_z*dt;

r=r+v_r*dt;
z=z+v_z*dt;

rs(end+1)=r;
zs(end+1)=z;

if z>zs0(end)
    break;
end
end

[zs0,rs0,ts0]=test_traj_mat(zs0,u_1,r0,theta0);

subplot(2,1,1)
plot(zs,rs,'.',zs0,rs0)
axis([min(zs),max(zs),min(rs),max(rs)])
xlabel('x [m]')
ylabel('y [m]')

subplot(2,1,2)
plot(zs,u_1(zs))
xlabel('x [m]')
ylabel('U [V]')
axis([min(zs),max(zs),min(u_1(zs)),max(u_1(zs))])


%{

plot(zs,E_z(zs))
+[M函数](,验证公式)
%}
## end
#546, 1555:
%{
+[M函数](,验证公式)

运行指令"nautilus Matlab/SEM"
test_u_1(M函数):...
test_traj_mat(M函数):...
+[新建阅读窗口](,test_u_1)
在选择区域中, 将'test_u_1'的"-inf"替换为"inf"
在选择区域中, 将'test_u_1'的"u_1=="替换为"abs(u_1)=="

测试电势:...
连续场轨迹:...
轨迹对比1:...
轨迹对比2:...
验证矩阵:...
问题具现:...
问题解决:...
(是因为在电子沿z方向加速的过程中, 其发射角其实也在发生变化. 这种变化是用\sqrt{V}来实现的. 矩阵输入和输出的\sqrt{V}应该是不一样的)
+[新建阅读窗口](,问题解决)

差分法对比:...
ODE对比:...

保存:...
%}

physics_constant;
addpath('Matlab/Physics');
addpath('Matlab/SEM');

U_1=-8000;
DU=4000;

D=100;
d_0=10;
% d_0=10;
d_1=d_0;
%{
+[M函数](,验证公式)
%}

E_0=DU/D;
U_0=U_1+DU;
u_1=@(z)test_u_1(z,d_1,d_0,D,E_0,U_1);
E_z=@(z,r)-(E_0/2*tanh((z+D)/d_1)+E_0/2*tanh((z-D)/d_1)-E_0*tanh(z/d_0));
E_r=@(z,r)E_0./2.*((1)./(cosh((z+D)./d_1).^(2).*d_1)+(1)./(cosh((z-D)./d_1).^(2).*d_1)-(2)./(cosh(z./d_0).^(2).*d_0)).*r/2;
B=@(z,r)zeros(size(r));

N=3000;
zs0=linspace(-2*D,2*D,N);
r0=1;
theta0=0;

dt=2e-9;
v_z=sqrt(-2*e*U_1/m_e);
v_r=v_z*theta0;
r=r0;
z=zs0(1);

rs2=r;
zs2=z;
t=(0:4100)*dt;

[zs1,rs1]=EM_motion_ODEs(z,r,v_z,v_r,t,e,me,B,E_z,E_r,'ode45');

for i=1:length(t)
[z,r,p_z,p_r]=EM_re_motion_RK4(z,r,v_z*me,v_r*me,dt,t(i),e,me,B,E_z,E_r);

zs2(end+1)=z;
rs2(end+1)=r;
v_z=p_z/me;
v_r=p_r/me;
end

[zs0,rs0,ts0]=test_traj_mat(zs0,u_1,r0,theta0);


subplot(2,1,1)
plot(zs1,rs1,'.',zs2,rs2,'--',zs0,rs0)
axis([min(zs0),max(zs0),min(rs0),max(rs0)])
xlabel('x [m]')
ylabel('y [m]')
legend('ODE45','RK4','Matrix')

subplot(2,1,2)
plot(zs,u_1(zs))
xlabel('x [m]')
ylabel('U [V]')
axis([min(zs),max(zs),min(u_1(zs)),max(u_1(zs))])

% plot(zs2,rs2,'.')


%{
plot(zs,E_z(zs))
+[M函数](,验证公式)
%}
## end
#548, 1275:
%{
+[M函数](,测试误差)

记录时间:...
初步误差测试:...
横向误差测试:...
纵向误差测试:...
+[新建阅读窗口](,初步误差测试)

保存:...
%}

physics_constant;
addpath('Matlab/Physics');
addpath('Matlab/SEM');

U_1=-8000;
DU=3500;

D=10e-2;
d_0=1e-2;
theta0=0;


%{
+[M函数](,测试误差)
%}

r0=1e-3*linspace(-1,1,2000);
z_0=-20e-2*ones(size(r0));

d_1=d_0;

E_0=DU/D;
U_0=U_1+DU;
u_1=@(z)test_u_1(z,d_1,d_0,D,E_0,U_1);
E_z=@(z,r)-(E_0/2*tanh((z+D)/d_1)+E_0/2*tanh((z-D)/d_1)-E_0*tanh(z/d_0));
E_r=@(z,r)E_0./2.*((1)./(cosh((z+D)./d_1).^(2).*d_1)+(1)./(cosh((z-D)./d_1).^(2).*d_1)-(2)./(cosh(z./d_0).^(2).*d_0)).*r/2;
B=@(z,r)zeros(size(r));


%{
+[M函数](,测试误差)
%}

dt0=100e-12;
N=80;

v_z=sqrt(-2*e*U_1/m_e);
v_r=v_z*theta0;
r=r0;
z=z_0;

rs1=r;
zs1=z;
dt=dt0;
t=(0:N)*dt;

tic
for i=1:length(t)
[z,r,v_z,v_r]=EM_motion_RK4(z,r,v_z,v_r,dt,t(i),e,me,B,E_z,E_r);

zs1(end+1,:)=z;
rs1(end+1,:)=r;
end
run_time=toc;

r_sc=0;
z_sc=z+(r_sc-r)./v_r.*v_z;
zs1(end+1,:)=z_sc;
rs1(end+1,:)=r_sc*ones(size(z));


subplot(2,1,1)
plot(zs1/1e-3,rs1/1e-3,'.-')
% axis([min(zs1),max(zs1),min(rs1),max(rs1)]/1e-3)
xlabel('x [mm]')
ylabel('y [mm]')

subplot(2,1,2)
plot(zs2/1e-3,u_1(zs2))
xlabel('x [mm]')
ylabel('U [V]')

disp(sprintf('Run time: %.2f ms',run_time/1e-3))
disp(sprintf('sigma_z=%.2e nm',std(zs1(end,:))/1e-9));


%{
clf
+[M函数](,测试误差)
%}
## end
#551, 1395:
%{
+[M函数](,测试误差)
%}

physics_constant;
addpath('Matlab/Physics');
addpath('Matlab/SEM');

U_1=-8000;
DU=1000;

D=10e-2;
d_0=1e-2;
r0=1;
theta0=0;

z_0=-20e-2;
z_sc=1;

d_1=d_0;

E_0=DU/D;
U_0=U_1+DU;
u_1=@(z)test_u_1(z,d_1,d_0,D,E_0,U_1);
E_z=@(z,r)-(E_0/2*tanh((z+D)/d_1)+E_0/2*tanh((z-D)/d_1)-E_0*tanh(z/d_0));
E_r=@(z,r)E_0./2.*((1)./(cosh((z+D)./d_1).^(2).*d_1)+(1)./(cosh((z-D)./d_1).^(2).*d_1)-(2)./(cosh(z./d_0).^(2).*d_0)).*r/2;
B=@(z,r)zeros(size(r));


%{
+[M函数](,测试误差)
%}

dt=10e-12;
N=800;
v_z=sqrt(-2*e*U_1/m_e);

v_r=v_z*theta0;
r=r0;
z=z_0;

rs2=r;
zs2=z;
t=(0:N)*dt;

% [zs1,rs1]=EM_motion_ODEs(z,r,v_z,v_r,t,e,me,B,E_z,E_r,'ode45');

tic
for i=1:length(t)
% [z,r,p_z,p_r]=EM_re_motion_RK4(z,r,v_z*me,v_r*me,dt,t(i),e,me,B,E_z,E_r);
% v_z=p_z/me;
% v_r=p_r/me;

[z,r,v_z,v_r]=EM_motion_RK4(z,r,v_z,v_r,dt,t(i),e,me,B,E_z,E_r);
% [z,r,v_z,v_r]=EM_motion_BEM(z,r,v_z,v_r,dt,t(i),e,me,B,E_z,E_r);
% [z,r,v_z,v_r]=EM_motion_CM(z,r,v_z,v_r,dt,t(i),e,me,B,E_z,E_r);

zs2(end+1)=z;
rs2(end+1)=r;
end

r_sc=r+(z_sc-z)/v_z*v_r;
zs2(end+1)=z_sc;
rs2(end+1)=r_sc;
run_time=toc;

subplot(2,1,1)
plot(zs2/1e-3,rs2/1e-3,'.-')
axis([min(zs2),max(zs2),min(rs2),max(rs2)]/1e-3)
xlabel('x [mm]')
ylabel('y [mm]')

subplot(2,1,2)
plot(zs2/1e-3,u_1(zs2))
xlabel('x [mm]')
ylabel('U [V]')

disp(sprintf('Run time: %.2f ms',run_time/1e-3))
disp(sprintf('r=%.2f nm',r_sc/1e-9))

%{
clf
+[M函数](,测试误差)
%}
## end
#553, 2076:
%{
+[M函数](,初步误差测试)

记录时间:...
初步误差测试:...
%}

physics_constant;
addpath('Matlab/Physics');
addpath('Matlab/SEM');

U_1=-8000;
DU=1000;

D=10e-2;
d_0=1e-2;
r0=1e-3;
theta0=0;

z_0=-20e-2;
z_sc=1;

d_1=d_0;

E_0=DU/D;
U_0=U_1+DU;
u_1=@(z)test_u_1(z,d_1,d_0,D,E_0,U_1);
E_z=@(z,r)-(E_0/2*tanh((z+D)/d_1)+E_0/2*tanh((z-D)/d_1)-E_0*tanh(z/d_0));
E_r=@(z,r)E_0./2.*((1)./(cosh((z+D)./d_1).^(2).*d_1)+(1)./(cosh((z-D)./d_1).^(2).*d_1)-(2)./(cosh(z./d_0).^(2).*d_0)).*r/2;
B=@(z,r)zeros(size(r));


%{
1.81/30
+[M函数](,初步误差测试)
%}

dt0=100e-12;
N=80;

v_z=sqrt(-2*e*U_1/m_e);
v_r=v_z*theta0;
r=r0;
z=z_0;

rs1=r;
zs1=z;
dt=dt0;
t=(0:N)*dt;

% [zs1,rs1]=EM_motion_ODEs(z,r,v_z,v_r,t,e,me,B,E_z,E_r,'ode45');

tic
for i=1:length(t)
% [z,r,p_z,p_r]=EM_re_motion_RK4(z,r,v_z*me,v_r*me,dt,t(i),e,me,B,E_z,E_r);
% v_z=p_z/me;
% v_r=p_r/me;

[z,r,v_z,v_r]=EM_motion_RK4(z,r,v_z,v_r,dt,t(i),e,me,B,E_z,E_r);
% [z,r,v_z,v_r]=EM_motion_BEM(z,r,v_z,v_r,dt,t(i),e,me,B,E_z,E_r);
% [z,r,v_z,v_r]=EM_motion_CM(z,r,v_z,v_r,dt,t(i),e,me,B,E_z,E_r);

zs1(end+1)=z;
rs1(end+1)=r;
end

r_sc=r+(z_sc-z)/v_z*v_r;
zs1(end+1)=z_sc;
rs1(end+1)=r_sc;
run_time=toc;

% error

v_z=sqrt(-2*e*U_1/m_e);
v_r=v_z*theta0;
r=r0;
z=z_0;

rs2=r;
zs2=z;
dt=dt0/2;
t=(0:N*2)*dt;

% [zs1,rs1]=EM_motion_ODEs(z,r,v_z,v_r,t,e,me,B,E_z,E_r,'ode45');

for i=1:length(t)
% [z,r,p_z,p_r]=EM_re_motion_RK4(z,r,v_z*me,v_r*me,dt,t(i),e,me,B,E_z,E_r);
% v_z=p_z/me;
% v_r=p_r/me;

[z,r,v_z,v_r]=EM_motion_RK4(z,r,v_z,v_r,dt,t(i),e,me,B,E_z,E_r);
% [z,r,v_z,v_r]=EM_motion_BEM(z,r,v_z,v_r,dt,t(i),e,me,B,E_z,E_r);
% [z,r,v_z,v_r]=EM_motion_CM(z,r,v_z,v_r,dt,t(i),e,me,B,E_z,E_r);

zs2(end+1)=z;
rs2(end+1)=r;
end

r_sc=r+(z_sc-z)/v_z*v_r;
zs2(end+1)=z_sc;
rs2(end+1)=r_sc;



subplot(2,1,1)
plot(zs1/1e-3,rs1/1e-3,'.-',zs2/1e-3,rs2/1e-3,'.-')
axis([min(zs2),max(zs2),min(rs2),max(rs2)]/1e-3)
xlabel('x [mm]')
ylabel('y [mm]')

subplot(2,1,2)
plot(zs2/1e-3,u_1(zs2))
xlabel('x [mm]')
ylabel('U [V]')

disp(sprintf('Run time: %.2f ms',run_time/1e-3))
disp(sprintf('Error of r: %.2e nm',(rs1(end)-rs2(end))/1e-9))

%{
clf
+[M函数](,初步误差测试)
%}
## end
#555, 1029:
%{
+[M函数](,测试误差)

记录时间:...
初步误差测试:...

保存:...
%}

physics_constant;
addpath('Matlab/Physics');
addpath('Matlab/SEM');

U_1=-8000;
DU=3500;

D=10e-2;
d_0=1e-2;
theta0=0;
r0=1e-3;

z_0=-20e-2;
r_sc=0;

d_1=d_0;

E_0=DU/D;
U_0=U_1+DU;
u_1=@(z)test_u_1(z,d_1,d_0,D,E_0,U_1);
E_z=@(z,r)-(E_0/2*tanh((z+D)/d_1)+E_0/2*tanh((z-D)/d_1)-E_0*tanh(z/d_0));
E_r=@(z,r)E_0./2.*((1)./(cosh((z+D)./d_1).^(2).*d_1)+(1)./(cosh((z-D)./d_1).^(2).*d_1)-(2)./(cosh(z./d_0).^(2).*d_0)).*r/2;
B=@(z,r)zeros(size(r));


%{
+[M函数](,测试误差)
%}

dt0=10e-12;
N=800;

v_z=sqrt(-2*e*U_1/m_e);
v_r=v_z*theta0;
r=r0;
z=z_0;

rs1=r;
zs1=z;
dt=dt0;
t=(0:N)*dt;


for i=1:length(t)
[z,r,v_z,v_r]=EM_motion_RK4(z,r,v_z,v_r,dt,t(i),e,me,B,E_z,E_r);

zs1(end+1)=z;
rs1(end+1)=r;
end

z_sc=z+(r_sc-r)/v_r*v_z;
zs1(end+1)=z_sc;
rs1(end+1)=r_sc;


subplot(2,1,1)
plot(zs1/1e-3,rs1/1e-3,'.-')
axis([min(zs1),max(zs1),min(rs1),max(rs1)]/1e-3)
xlabel('x [mm]')
ylabel('y [mm]')

subplot(2,1,2)
plot(zs2/1e-3,u_1(zs2))
xlabel('x [mm]')
ylabel('U [V]')


%{
clf
+[M函数](,测试误差)
%}
## end
#557, 1283:
%{
+[M函数](,横向误差测试)

记录时间:...
初步误差测试:...
+[新建阅读窗口](,初步误差测试)

保存:...
%}

physics_constant;
addpath('Matlab/Physics');
addpath('Matlab/SEM');

U_1=-8000;
DU=3500;

D=10e-2;
d_0=1e-2;
theta0=0;

r0=1e-3*linspace(-1,1,6);
z_0=-20e-2*ones(size(r0));

d_1=d_0;

E_0=DU/D;
U_0=U_1+DU;
u_1=@(z)test_u_1(z,d_1,d_0,D,E_0,U_1);
E_z=@(z,r)-(E_0/2*tanh((z+D)/d_1)+E_0/2*tanh((z-D)/d_1)-E_0*tanh(z/d_0));
E_r=@(z,r)E_0./2.*((1)./(cosh((z+D)./d_1).^(2).*d_1)+(1)./(cosh((z-D)./d_1).^(2).*d_1)-(2)./(cosh(z./d_0).^(2).*d_0)).*r/2;
B=@(z,r)zeros(size(r));


%{
+[M函数](,测试误差)
%}

dt0=10e-12;
N=800;

v_z=sqrt(-2*e*U_1/m_e);
v_r=v_z*theta0;
r=r0;
z=z_0;

rs1=r;
zs1=z;
dt=dt0;
t=(0:N)*dt;

tic
for i=1:length(t)
[z,r,v_z,v_r]=EM_motion_RK4(z,r,v_z,v_r,dt,t(i),e,me,B,E_z,E_r);

zs1(end+1,:)=z;
rs1(end+1,:)=r;
end
run_time=toc;

%{
+[M函数](,横向误差测试)
%}

r_sc0=0;
z_sc0=z(1)+(r_sc0-r(1))./v_r(1).*v_z(1);
zs1(end+1,:)=z_sc0*ones(size(z));
rs1(end+1,:)=r+(z_sc0-z)./v_z.*v_r;


subplot(2,1,1)
plot(zs1/1e-3,rs1/1e-3,'.-')
% axis([min(zs1),max(zs1),min(rs1),max(rs1)]/1e-3)
xlabel('x [mm]')
ylabel('y [mm]')

subplot(2,1,2)
plot(zs2/1e-3,u_1(zs2))
xlabel('x [mm]')
ylabel('U [V]')

disp(sprintf('Run time: %.2f ms',run_time/1e-3))
disp(sprintf('sigma=%.2e nm',std(rs1(end,:))/1e-9));

%{
clf
+[M函数](,测试误差)
%}
## end
#559, 1250:
%{
+[M函数](,测试误差)

记录时间:...
初步误差测试:...
横向误差测试:...
纵向误差测试:...
+[新建阅读窗口](,初步误差测试)

保存:...
%}

physics_constant;
addpath('Matlab/Physics');
addpath('Matlab/SEM');

U_1=-8000;
DU=3500;

D=10e-2;
d_0=1e-2;
theta0=0;

r0=1e-3*linspace(-1,1,6);
z_0=-20e-2*ones(size(r0));

d_1=d_0;

E_0=DU/D;
U_0=U_1+DU;
u_1=@(z)test_u_1(z,d_1,d_0,D,E_0,U_1);
E_z=@(z,r)-(E_0/2*tanh((z+D)/d_1)+E_0/2*tanh((z-D)/d_1)-E_0*tanh(z/d_0));
E_r=@(z,r)E_0./2.*((1)./(cosh((z+D)./d_1).^(2).*d_1)+(1)./(cosh((z-D)./d_1).^(2).*d_1)-(2)./(cosh(z./d_0).^(2).*d_0)).*r/2;
B=@(z,r)zeros(size(r));


%{
+[M函数](,测试误差)
%}

dt0=100e-12;
N=80;

v_z=sqrt(-2*e*U_1/m_e);
v_r=v_z*theta0;
r=r0;
z=z_0;

rs1=r;
zs1=z;
dt=dt0;
t=(0:N)*dt;

tic
for i=1:length(t)
[z,r,v_z,v_r]=EM_motion_RK4(z,r,v_z,v_r,dt,t(i),e,me,B,E_z,E_r);

zs1(end+1,:)=z;
rs1(end+1,:)=r;
end
run_time=toc;

r_sc=0;
z_sc=z+(r_sc-r)./v_r.*v_z;
zs1(end+1,:)=z_sc;
rs1(end+1,:)=r_sc*ones(size(z));


subplot(2,1,1)
plot(zs1/1e-3,rs1/1e-3,'.-')
% axis([min(zs1),max(zs1),min(rs1),max(rs1)]/1e-3)
xlabel('x [mm]')
ylabel('y [mm]')

subplot(2,1,2)
plot(zs2/1e-3,u_1(zs2))
xlabel('x [mm]')
ylabel('U [V]')

disp(sprintf('Run time: %.2f ms',run_time/1e-3))
disp(sprintf('sigma_z=%.2e nm',std(zs1(end,:))/1e-9));


%{
clf
+[M函数](,测试误差)
%}
## end
#561, 866:
<!--
+[H函数](,近似电场)
-->

<h2>Approximation field</h2>
%[1].
%[2].

The Laplace's equation with cylindrical symmetry is,
%[3].

Then we have,
%[4].
%[5].
%[6].

And, 
%[7].
%[8].
%[9].

%[10].
%[11].
%[12].
%[13].

Finally,
%[14].
%[15].
%[16].
%[17].

Not good, it's a nonlinear equation. <br>

Let's try a simple function,
%[18].


<h2>Electric field</h2>
The electric field is,
%[19].
%[20].

Then, \(E_z\) is, 
%[21].
%[22].
%[23].
(Corrected the sign problem)<br><br>

And \(E_r\) is, 
%[24].
%[25].
%[26].

(Notice that, there is an error in eqn.[19] and eqn.[20])<br><br>

And we have,
%[27].
%[28].
%[29].
%[30].
%[31].
%[32].




<!--
[32].:
式(17)转换为"表达式"
将"u=-E_0/a(r)*ln(cosh(z*a(r)))-E_0*ln(2)/a(r)+u_0"记作为式(1)
将式(2)记作为式(23)
将式(28)代入到式(29)



的([1].,表达式)->+[显示星图](,表达式)

更新式(29)
验证公式(M函数):...
画电场(P函数):...
+[新建阅读窗口](,画电场)
+[新建阅读窗口](,验证公式)
+[H函数](,近似电场)
-->
## end
#564, 137:
u=-E_{0}/a \left( r \right) ln \left( cosh \left( z a \left( r \right) \right) \right)-E_{0} ln \left( 2 \right)/a \left( r \right)+u_{0}
## end
#566, 52:
E_{z}=E_{0} tanh \left( z a \left( r \right) \right)
## end
#568, 122:
\frac{1}{r} \frac{\partial}{\partial r}\left(r \frac{\partial u}{\partial r}\right)+\frac{\partial^{2}u}{\partial z^{2}}=0
## end
#570, 23:
f_{z}=\frac{dE_{z}}{dz}
## end
#572, 47:
u=-E_0/a(r)*ln(cosh(z*a(r)))-E_0*ln(2)/a(r)+u_0
## end
#575, 20:
E_z=E_0*tanh(z*a(r))
## end
#578, 42:
\frac{1}{r}*\p{r}{r*\p{r}{u}}+\p{z,z}{u}=0
## end
#582, 565:
%{
+[M函数](,验证公式)

等效电势:...

保存:...
%}


u_0=0;
E_0=1;
R=1e-3;
D=10e-3
z=linspace(-D,D,80);
r=linspace(-D,D,10);

dR=0.1*R;

a=@(r)1./sqrt(R.^(2)-r.^(2)).*double(R-dR>abs(r))+1/dR.*double(R-dR<=abs(r));
u=@(z,r)-E_0./a(r).*log(cosh(z.*a(r)))-E_0.*log(2)./a(r)+u_0;
E_z=@(z,r) E_0.*tanh(z.*a(r));
E_r=@(z,r) (u(z,r)-u_0+E_z(z,r).*z).*r.*a(r).^(2);


[Z,R]=meshgrid(z,r);
U=u(Z,R);
A=a(R);
Er=E_r(Z,R);
Ez=E_z(Z,R);
E0=sqrt(Er.^2+Ez.^2);
Er=Er./E0;
Ez=Ez./E0;

% surf(Z,R,real(U))
% contourf(Z,R,U,30)
quiver(Z,R,Ez,Er)
axis equal



%{
U
double(20<0)
+[M函数](,验证公式)
%}
## end
#585, 112:
f_{z}=E_{0} \frac{1}{cosh \left( z a \left( r \right) \right)^{2}} \frac{d}{dz}\left(z a \left( r \right)\right)
## end
#587, 85:
f_{z}=E_{0} \frac{1}{cosh \left( z a \left( r \right) \right)^{2}} a \left( r \right)
## end
#589, 58:
f_{r}=\frac{1}{r} \frac{d}{dr}\left(r \frac{du}{dr}\right)
## end
#591, 201:
f_{r}=\frac{1}{r} \frac{d}{dr}\left(r \frac{d}{dr}\left(-E_{0}/a \left( r \right) ln \left( cosh \left( z a \left( r \right) \right) \right)-A ln \left( 2 \right)/a \left( r \right)+u_{0}\right)\right)
## end
#593, 318:
f_{r}=\frac{1}{r} \frac{d}{dr}\left(r \left(E_{0} a' \left( r \right)/a \left( r \right)^{2} ln \left( cosh \left( z a \left( r \right) \right) \right)-E_{0} tanh \left( z a \left( r \right) \right) z a' \left( r \right)/a \left( r \right)+A ln \left( 2 \right) a' \left( r \right)/a \left( r \right)^{2}\right)\right)
## end
#594, 15:
f_z=\d{E_z}_{z}
## end
#597, 49:
f_z=E_0*\frac{1}{cosh(z*a(r))^{2}}*\d{z*a(r)}_{z}
## end
#600, 39:
f_z=E_0*\frac{1}{cosh(z*a(r))^{2}}*a(r)
## end
#603, 35:
f_r=\frac{1}{r}*\d{r*\d{u}_{r}}_{r}
## end
#606, 77:
f_r=\frac{1}{r}*\d{r*\d{-E_0/a(r)*ln(cosh(z*a(r)))-A*ln(2)/a(r)+u_0}_{r}}_{r}
## end
#609, 112:
f_r=\frac{1}{r}*\d{r*(E_0*a'(r)/a(r)^2*ln(cosh(z*a(r)))-E_0*tanh(z*a(r))*z*a'(r)/a(r)+A*ln(2)*a'(r)/a(r)^2)}_{r}
## end
#613, 383:
f_{r}=\frac{1}{r} \left(A ln \left( 2 \right) a' \left( r \right)/a \left( r \right)^{2}+\frac{d}{dr}\left(E_{0} ln \left( cosh \left( z a \left( r \right) \right) \right) a' \left( r \right)/a \left( r \right)^{2}-E_{0} tanh \left( z a \left( r \right) \right) z a' \left( r \right)/a \left( r \right)+A ln \left( 2 \right) a' \left( r \right)/a \left( r \right)^{2}\right) r\right)
## end
#615, 407:
f_{r}=\frac{1}{r} \left(A ln \left( 2 \right) a' \left( r \right)/a \left( r \right)^{2}+E_{0} \frac{dln \left( cosh \left( z a \left( r \right) \right) \right)}{dr} a' \left( r \right)/a \left( r \right)^{2}-E_{0} \frac{dtanh \left( z a \left( r \right) \right)}{dr} z a' \left( r \right)/a \left( r \right)+A ln \left( 2 \right) \frac{d}{dr}\left(a' \left( r \right)/a \left( r \right)^{2}\right) r\right)
## end
#617, 187:
f_{r}=\frac{1}{r} \left(A ln \left( 2 \right) a' \left( r \right)/a \left( r \right)^{2}+A ln \left( 2 \right) \frac{d}{dr}\left(a' \left( r \right)/a \left( r \right)^{2}\right) r\right)
## end
#619, 233:
f_{r}=\frac{1}{r} \left(E_{0} ln \left( 2 \right) a' \left( r \right)/a \left( r \right)^{2}+E_{0} ln \left( 2 \right) \left(a'' \left( r \right)/a \left( r \right)^{2}-2 a' \left( r \right)^{2}/a \left( r \right)^{3}\right) r\right)
## end
#621, 13:
f_{r}+f_{z}=0
## end
#622, 139:
f_r=\frac{1}{r}*(A*ln(2)*a'(r)/a(r)^{2}+\d{E_0*ln(cosh(z*a(r)))*a'(r)/a(r)^{2}-E_0*tanh(z*a(r))*z*a'(r)/a(r)+A*ln(2)*a'(r)/a(r)^{2}}_{r}*r)
## end
#625, 155:
f_r=\frac{1}{r}*(A*ln(2)*a'(r)/a(r)^{2}+E_0*\d{ln(cosh(z*a(r)))}_{r}*a'(r)/a(r)^{2}-E_0*\d{tanh(z*a(r))}_{r}*z*a'(r)/a(r)+A*ln(2)*\d{a'(r)/a(r)^{2}}_{r}*r)
## end
#628, 73:
f_r=\frac{1}{r}*(A*ln(2)*a'(r)/a(r)^{2}+A*ln(2)*\d{a'(r)/a(r)^{2}}_{r}*r)
## end
#632, 91:
f_r=\frac{1}{r}*(E_0*ln(2)*a'(r)/a(r)^{2}+E_0*ln(2)*(a''(r)/a(r)^{2}-2*a'(r)^2/a(r)^{3})*r)
## end
#635, 9:
f_r+f_z=0
## end
#639, 236:
\frac{1}{r} \left(ln \left( 2 \right) a' \left( r \right)/a \left( r \right)^{2}+ln \left( 2 \right) \left(a'' \left( r \right)/a \left( r \right)^{2}-2 a' \left( r \right)^{2}/a \left( r \right)^{3}\right) r\right)+a \left( r \right)=0
## end
#641, 191:
a' \left( r \right)/a \left( r \right)^{2}+r \left(a'' \left( r \right)/a \left( r \right)^{2}-2 a' \left( r \right)^{2}/a \left( r \right)^{3}+a \left( r \right)/ln \left( 2 \right)\right)=0
## end
#643, 145:
a' \left( r \right)+r \left(a'' \left( r \right)-2 a' \left( r \right)^{2}/a \left( r \right)+a \left( r \right)^{3}/ln \left( 2 \right)\right)=0
## end
#645, 89:
a \left( r \right)=\begin{cases}
1/\sqrt{R^{2}-r^{2}}, & r< R\\ 0, & r\ge R
\end{cases}


## end
#646, 88:
\frac{1}{r}*(ln(2)*a'(r)/a(r)^{2}+ln(2)*(a''(r)/a(r)^{2}-2*a'(r)^{2}/a(r)^{3})*r)+a(r)=0
## end
#649, 31:
\frac{1}{r}*\d{r*\d{u}_{r}}_{r}
## end
#651, 3:
f_r
## end
#653, 35:
E_0*\frac{1}{cosh(z*a(r))^{2}}*a(r)
## end
#655, 3:
f_z
## end
#657, 87:
\frac{1}{r}*(E_0*ln(2)*a'(r)/a(r)^{2}+E_0*ln(2)*(a''(r)/a(r)^{2}-2*a'(r)^2/a(r)^{3})*r)
## end
#659, 3:
f_r
## end
#661, 68:
a'(r)/a(r)^{2}+r*(a''(r)/a(r)^{2}-2*a'(r)^{2}/a(r)^{3}+a(r)/ln(2))=0
## end
#664, 48:
a'(r)+r*(a''(r)-2*a'(r)^{2}/a(r)+a(r)^3/ln(2))=0
## end
#667, 39:
a(r)=\eqs{1/\sqrt{R^2-r^2},r<R;
0,r>=R}
## end
#671, 202:
%{
+[M函数](,验证公式)

保存:...
%}


u_0=0;
A=1;
z=linspace(-20,20,1000);
a=linspace(2e-1,2,10);

clf
for i=1:length(a)
u=-A/a(i).*log(cosh(z.*a(i)))-A/a(i)*log(2);

hold on
plot(z,u)
end


%{
+[M函数](,验证公式)
%}
## end
#673, 19:
E_{z}=\frac{du}{dz}
## end
#675, 19:
E_{r}=\frac{du}{dr}
## end
#677, 166:
E_{z}=\frac{d}{dz}\left(-E_{0}/a \left( r \right) ln \left( cosh \left( z a \left( r \right) \right) \right)-E_{0} ln \left( 2 \right)/a \left( r \right)+u_{0}\right)
## end
#679, 185:
E_{z}=-E_{0}/a \left( r \right) \frac{1}{cosh \left( z a \left( r \right) \right)} sinh \left( z a \left( r \right) \right) a \left( r \right)-0 ln \left( 2 \right)/a \left( r \right)+0
## end
#681, 52:
E_{z}=E_{0} tanh \left( z a \left( r \right) \right)
## end
#683, 166:
E_{r}=\frac{d}{dr}\left(-E_{0}/a \left( r \right) ln \left( cosh \left( z a \left( r \right) \right) \right)-E_{0} ln \left( 2 \right)/a \left( r \right)+u_{0}\right)
## end
#685, 13:
E_z=\d{u}_{z}
## end
#688, 13:
E_r=\d{u}_{r}
## end
#691, 57:
E_z=\d{-E_0/a(r)*ln(cosh(z*a(r)))-E_0*ln(2)/a(r)+u_0}_{z}
## end
#694, 69:
E_z=-E_0/a(r)*\frac{1}{cosh(z*a(r))}*sinh(z*a(r))*a(r)-0*ln(2)/a(r)+0
## end
#697, 20:
E_z=E_0*tanh(z*a(r))
## end
#701, 270:
E_{r}=E_{0}/a \left( r \right)^{2} a' \left( r \right) ln \left( cosh \left( z a \left( r \right) \right) \right)-E_{0} tanh \left( z a \left( r \right) \right) z a' \left( r \right)/a \left( r \right)+E_{0} ln \left( 2 \right) a' \left( r \right)/a \left( r \right)^{2}
## end
#703, 153:
E_{r}=\left(u_{0}-u\right) a' \left( r \right)/a \left( r \right)-E_{0} tanh \left( z a \left( r \right) \right) z a' \left( r \right)/a \left( r \right)
## end
#705, 102:
a' \left( r \right)=\begin{cases}
r/\left(R^{2}-r^{2}\right)^{3/2}, & r< R\\ 0, & r\ge R
\end{cases}


## end
#706, 57:
E_r=\d{-E_0/a(r)*ln(cosh(z*a(r)))-E_0*ln(2)/a(r)+u_0}_{r}
## end
#711, 90:
E_r=E_0/a(r)^2*a'(r)*ln(cosh(z*a(r)))-E_0*tanh(z*a(r))*z*a'(r)/a(r)+E_0*ln(2)*a'(r)/a(r)^2
## end
#714, 52:
E_r=(u_0-u)*a'(r)/a(r)-E_0*tanh(z*a(r))*z*a'(r)/a(r)
## end
#717, 53:
a'(r)=\eqs{r/(R^{2}-r^{2})^{3/2},   r<R;
0,   r\ge R}
## end
#721, 44:
a' \left( r \right)=r a \left( r \right)^{3}
## end
#723, 125:
E_{r}=\left(u-u_{0}\right) r a \left( r \right)^{2}+E_{0} tanh \left( z a \left( r \right) \right) z r a \left( r \right)^{2}
## end
#725, 59:
E_{r}=\left(u-u_{0}+E_{z} z\right) r a \left( r \right)^{2}
## end
#727, 52:
E_{z}=E_{0} tanh \left( z a \left( r \right) \right)
## end
#730, 14:
a'(r)=r*a(r)^3
## end
#733, 52:
E_r=(u-u_0)*r*a(r)^{2}+E_0*tanh(z*a(r))*z*r*a(r)^{2}
## end
#736, 8:
r*a(r)^3
## end
#738, 5:
a'(r)
## end
#740, 28:
E_r=(u-u_0+E_z*z)*r*a(r)^{2}
## end
#743, 20:
E_z=E_0*tanh(z*a(r))
## end
#747, 396:
%{
+[M函数](,验证公式)

等效电势:...

保存:...
%}


u_0=0;
E_0=1;
R=1e-3;
D=10e-3
z=linspace(-D,D,200);
r=linspace(-D,D,100);

dR=0.1*R;

a=@(r)1./sqrt(R.^(2)-r.^(2)).*double(R-dR>abs(r))+1/dR.*double(R-dR<=abs(r));
u=@(z,r)-E_0./a(r).*log(cosh(z.*a(r)))-E_0.*log(2)./a(r)+u_0;

[Z,R]=meshgrid(z,r);
U=u(Z,R);
A=a(R);

% surf(Z,R,real(U))
contourf(Z,R,real(U),30)
axis equal

%{
double(20<0)
+[M函数](,验证公式)
%}
## end
#749, 599:
"""
+[P函数](,画电场)
print(np.heaviside(10,1))

"""

import numpy as np
import matplotlib.pyplot as plt

E_0=1
u_0=1
R=3.e-3
dR=0.1*R

w=5.e-3

r, z = np.mgrid[-w:w:100j, -w:w:100j]

a=lambda r: np.sqrt(1/(R**2-r**2)*np.heaviside(R-dR>np.abs(r),0.)) \
    +1/dR*np.heaviside(R-dR<=np.abs(r),0.)

u=lambda z,r: -E_0/a(r)*np.log(np.cosh(z*a(r)))-E_0*np.log(2)/a(r)+u_0
E_z=lambda z,r: E_0*np.tanh(z*a(r))
E_r=lambda z,r: (u(z,r)-u_0+E_z(z,r)*z)*r*a(r)**2

plt.figure()
ax=plt.gca()
ax.streamplot(z, r, E_z(z,r), E_r(z,r), density=[0.5, 1])
ax.axis('equal')
plt.show()


"""
print(r[r<R])
+[P函数](,画电场)

"""
## end
### 结束