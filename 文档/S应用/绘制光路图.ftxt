### 节点
地址, 外部样本库, 光路, mouseMove, 的, 旋转, mouseMove, 的, 缩放, mouseMove, 的, 移动, 的, 的, 的, 动作, 按键, 画选中框, 去掉选中框, 的, 的, 的, 动词, 线粗细, 线型, 线颜色, 面颜色, 半径, 中心, 的, 的, 输入, 输出, 的, 的, 选中区域, 角度, 类型, 图形, 选中框, 输出, 厚度, 的, 的, 的, 的, 的, 的, 的, 的, 输入, 的, 的, 的, 的, 画图, 反射, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 透镜, mouseMove, 的, 旋转, mouseMove, 的, 缩放, mouseMove, 的, 移动, 的, 的, 的, 动作, 按键, 画选中框, 去掉选中框, 的, 的, 的, 动词, 线粗细, 线型, 线颜色, 面颜色, 半径, 中心, 的, 的, 输入, 输出, 的, 的, 选中区域, 角度, 类型, 图形, 选中框, 输出, 厚度, 的, 的, 的, 的, 的, 的, 的, 的, 输入, 的, 的, 的, 的, 画图, 在光路上, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 反射镜, mouseMove, 的, 移动终点, mouseMove, 的, 移动起点, mouseMove, mouseMove, 的, 移动, 的, 的, 的, 的, 动作, 按键, 画选中框, 去掉选中框, 的, 的, 的, 动词, 线粗细, 线型, 线颜色, LaTeX数学记号, 的, 点线公式, 输出, 终点, 起点, 的, 的, 输入, 的, 的, 的, 选中区域, 类型, 选中框, 图形, 输出, 的, 的, 的, 的, 的, 输入, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 光线, mouseMove, 的, 移动终点, mouseMove, 的, 移动起点, mouseMove, mouseMove, 的, 移动, 的, 的, 的, 的, 动作, 按键, 画选中框, 去掉选中框, 的, 的, 的, 动词, 线粗细, 线型, 线颜色, LaTeX数学记号, 的, 点线公式, 输出, 是, 是, 终点, 起点, 的, 的, 输入, 的, 的, 的, 选中区域, 类型, 选中框, 图形, 输出, 的, 的, 的, 的, 的, 输入, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 光线, mouseMove, 的, 移动终点, mouseMove, 的, 移动起点, mouseMove, mouseMove, 的, 移动, 的, 的, 的, 的, 动作, 按键, 画选中框, 去掉选中框, 的, 的, 的, 动词, 线粗细, 线型, 线颜色, LaTeX数学记号, 的, 点线公式, 输出, 是, 是, 是, 终点, 是, 是, 起点, 的, 的, 输入, 的, 的, 的, 选中区域, 类型, 选中框, 图形, 输出, 的, 的, 的, 的, 的, 输入, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 光线, pt1, pt0, 的, 的, 输入, 的, 的, 输出, 的, 的, P代码, 关系说明, 的, 的, 的, 的, 的, 的, 关系说明, pt2, pt1, pt0, 的, 的, 的, 输入, 的, 的, 输出, 的, 的, P代码, 的, 的, 的, 的, 的, 的, 的, 的, 的, 规则, 3, 2, 1, 0, 起点, 终点, 的, 的, 的, 的, 的, 的, 的, 的, 的, 主光路, 的, 的, 的, 的, 的, 的, 的, 测试场景, Q, mouseRelease, mouseMove, mousePress, 的, 的, 的, 的, 光路图动作, 画图工具, 厚度, mouseMove, 的, 旋转, mouseMove, 的, 缩放, mouseMove, 的, 移动, 的, 的, 的, 动作, 按键, 画选中框, 去掉选中框, 的, 的, 的, 动词, 线粗细, 线型, 线颜色, 面颜色, 半径, 中心, 的, 的, 输入, 输出, 的, 的, 选中区域, 角度, 类型, 图形, 选中框, 输出, 的, 的, 的, 的, 的, 的, 的, 的, 输入, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 镜子, 主光路, 起点, 终点, 线颜色, 线型, 线粗细, 文字, 位移距离, 的, 的, 的, 的, 的, 的, 的, 输入, 输出, 图形, 选中框, 的, 的, 的, 的, 画图, 类型, 的, 的, 输入, 输出, LaTeX数学记号, 的, 点线公式, 的, 的, 的, 选中区域, 去掉选中框, 画选中框, 按键, 的, 的, 的, 动词, mouseMove, 的, 移动, mouseMove, mouseMove, 的, 移动起点, mouseMove, 的, 移动终点, 的, 的, 的, 的, 动作, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 长度, mouseMove, 的, 旋转, mouseMove, 的, 缩放, mouseMove, 的, 移动, 的, 的, 的, 动作, 按键, 画选中框, 去掉选中框, 的, 的, 的, 动词, 线粗细, 线型, 线颜色, 面颜色, 半径, 中心, 的, 的, 输入, 输出, 的, 的, 选中区域, 角度, 类型, 图形, 选中框, 输出, 厚度, 的, 的, 的, 的, 的, 的, 的, 的, 输入, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 测试图形, 的, 的, 的, 的, 样本库, 例子, 的, 增加光路, 显示光路, 删除光路, 按键动作, 的, 的, 作用按键, 测试, 的, 的, 的, 创建光路, 创建长度, 标记距离, 的, 的, 的, 的, 的, 的, 光路图动词, iFAST, 的, 的, 的, 的, 的, 的, 的, 的, 的, 光路图工具, 目录, 的, 比例, 的, 尺寸, 的, 原点, 的, 坐标系, 是, 是, 是, 的, FOPA设计, 的, 节点数目统计, 20210420, 的, 的, 放置反射镜, 的, 系列动作, S代码, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 测试, 测试, 测试, 测试, 测试, 测试, 测试, 测试, 测试, 测试, 测试, 测试, 测试, 测试, 测试, 测试, 测试, 测试, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 等于, 的, 示例, 20210422, 的, 的, TOPAS光路, 的, 系列命名, 的, 操作序列, S代码, 的, 示例, 的, 光路图名词, 例子, 的, 后面, 的, 紧接着, 的, 的, 选择, 的, 操作序列, S代码, 20210423, 的, 的, 撤销, 的, 操作序列, S代码, 的, 计算, 的, 操作序列, S代码, 20210518, 的, 20210519, 的, 的, 条, 20210520, 的, 的, 最后, 的, 插入, 的, 操作序列, S代码, 的, 示例, 比例, 的, 尺寸, 的, 原点, 的, 坐标系, 20210602, 的, 20210611, 的, 20210612, 的, 20210613, 的, 20210617, 的, S代码, 20210619, 的, 20210620, 的, 20210621, 的, 20210622, 的, 相对, 的, 20210624, 的, 20210625, 的, 20210710, 的, 反射步骤, 分光步骤, 入射步骤, 这些事情, 的, 的, 的, 的, S代码, 操作序列, 的, 逻辑结构转光路, 的, 的, 三维光栅, 的, 三维柱面镜, 的, 三维透镜, 的, 三维反射镜, 的, 透镜焦距, 的, 反射代码, 的, M代码, 20210712, 的, 透射步骤, 反射步骤, 分光步骤, 入射步骤, 这些事情, 的, 的, 的, 的, 的, S代码, 操作序列, 的, 逻辑结构转光线显示, 的, M代码, 的, 反射, 的, 透射步骤, 反射步骤, 分光步骤, 入射步骤, 这些事情, 的, 的, 的, 的, 的, S代码, 操作序列, 的, 逻辑结构转光线追踪, 的, 20210713, 的, 的, M代码, 的, Blender, 的, Blender, 的, M代码, 的, M代码, 的, Blender, 20210716, 的, 20210721, 的, S代码, S代码, 操作序列, 的, 场景结构转路线结构, 的, 20210722, 的, 的, 追踪整体模板, 的, 元件反射, 的, 元件画图, 20210728, 的, 20210729, 的, 物体, 的, 的, 反射, 的, 输入, 的, 场景模板, 20210730, 的, 的, 输出步骤, 三维场景, 三维整体模板, 透射步骤, 反射步骤, 分光步骤, 入射步骤, 这些事情, 的, 的, 的, 的, 的, 的, 的, S代码, 操作序列, 的, 逻辑结构转3D场景, 的, 的, 保存, 的, 显示框架, 20210731, 的, 的, 方向, 的, 自动调整镜子方向, 20210816, 的, 的, 自动命名, 的, 设置位置, 的, 对齐X, 的, 对齐Y, 的, 测试结构, 的, 查看代码, 20210817, 的, 20210819, 的, 20210823, 的, 的, 模板集合, 的, 14通光路, 的, 经过元件, 20210824, 的, 的, Stretch光路, 20210826, 的, 的, 第一级放大, 的, 旧版本, 的, 反射步骤, 的, 经过步骤, 的, 显示路线, 的, 位置, 的, 第二级放大, 20210827, 的, 20210903, 的, 20210904, 的, 20210909, 的, 20210915, 的, 20210921, 的, 20210922, 的, 20211012, 的, 20211022, 的, 20211026, 的, 20211027, 的, 20211028, 的, 20211029, 的, 的, 起点, 的, 终点, 20211030, 的, 20211126, 的, 
### 关联
#, #, #, #, 5#3, #, #, 8#6, #, #, 11#9, #, 15#5, 15#8, 15#11, #, #, #, #, 22#16, 22#17, 22#18, #, #, #, #, #, #, #, 31#27, 31#28, #, #, 35#31, 35#32, #, #, #, #, #, #, #, 50#23, 50#24, 50#25, 50#26, 50#36, 50#27, 50#28, 50#41, #, 55#38, 55#39, 55#40, 55#50, #, 72#347, 72#15, 72#22, 72#17, 72#18, 72#23, 72#24, 72#25, 72#26, 72#35, 72#36, 72#37, 72#55, 72#27, 72#28, 72#41, #, #, 75#73, #, #, 78#76, #, #, 81#79, #, 85#75, 85#78, 85#81, #, #, #, #, 92#86, 92#87, 92#88, #, #, #, #, #, #, #, 101#97, 101#98, #, #, 105#101, 105#102, #, #, #, #, #, #, #, 120#93, 120#94, 120#95, 120#96, 120#106, 120#97, 120#98, 120#111, #, 125#108, 125#109, 125#110, 125#120, #, 142#347, 142#85, 142#92, 142#87, 142#88, 142#93, 142#94, 142#95, 142#96, 142#105, 142#106, 142#107, 142#125, 142#97, 142#98, 142#111, #, #, 145#143, #, #, 148#146, #, #, #, 152#150, #, 157#145, 157#148, 157#149, 157#152, #, #, #, #, 164#158, 164#159, 164#160, #, #, #, #, #, 170#168, #, #, #, #, 176#172, 176#173, #, 180#170, 180#171, 180#176, #, #, #, #, #, 190#165, 190#166, 190#167, 190#172, 190#173, #, 195#182, 195#183, 195#184, 195#190, #, 208#157, 208#164, 208#159, 208#160, 208#165, 208#166, 208#167, 208#180, 208#181, 208#195, 208#172, 208#173, 390#, #, 211#209, #, #, 214#212, #, #, #, 218#216, #, 223#211, 223#214, 223#215, 223#218, #, #, #, #, 230#224, 230#225, 230#226, #, #, #, #, #, 236#234, #, #, 240#367, 240#173, #, #, 244#240, 244#241, #, 248#236, 248#237, 248#244, #, #, #, #, #, 258#231, 258#232, 258#233, 258#240, 258#241, #, 263#250, 263#251, 263#252, 263#258, #, 276#223, 276#230, 276#225, 276#226, 276#231, 276#232, 276#233, 276#248, 276#249, 276#263, 276#240, 276#241, 391#390, #, 279#277, #, #, 282#280, #, #, #, 286#284, #, 291#279, 291#282, 291#283, 291#286, #, #, #, #, 298#292, 298#293, 298#294, #, #, #, #, #, 304#302, #, #, 309#348, 309#369, 309#241, #, 312#349, 312#368, #, 315#309, 315#312, #, 319#304, 319#305, 319#315, #, #, #, #, #, 329#299, 329#300, 329#301, 329#309, 329#312, #, 334#321, 334#322, 334#323, 334#329, #, 347#291, 347#298, 347#293, 347#294, 347#299, 347#300, 347#301, 347#319, 347#320, 347#334, 347#309, 347#312, 392#391, #, #, 352#348, 352#349, #, 355#106, 355#98, #, 358#352, 358#355, #, #, 126#358, 126#359, 126#106, 126#98, 126#348, 126#349, #, #, #, #, 373#367, 373#368, 373#369, #, 376#28, 376#36, #, 379#373, 379#376, #, 56#36, 56#28, 56#366, 56#367, 56#368, 56#369, 56#379, 389#126, 389#56, #, #, #, #, #, #393, #390, 405#390, 405#208, 405#391, 405#276, 405#392, 405#347, 405#393, 405#394, 405#395, #, 413#72, 413#142, 413#208, 413#276, 413#347, 413#389, 413#405, #, #, #, #, #, 422#414, 422#415, 422#416, 422#417, #, #, #, #, 427#425, #, #, 430#428, #, #, 433#431, #, 437#427, 437#430, 437#433, #, #, #, #, 444#438, 444#439, 444#440, #, #, #, #, #, #, #, 453#449, 453#450, #, #, 457#453, 457#454, #, #, #, #, #, #, 471#424, 471#445, 471#446, 471#447, 471#448, 471#458, 471#449, 471#450, #, 476#460, 476#461, 476#462, 476#471, #, 492#424, 492#437, 492#444, 492#439, 492#440, 492#445, 492#446, 492#447, 492#448, 492#457, 492#458, 492#459, 492#476, 492#449, 492#450, #, #, #, #, #, #, #, #, #, 508#494, 508#495, 508#496, 508#497, 508#498, 508#499, 508#500, #, #, #, #, 516#508, 516#509, 516#510, 516#511, #, #, 520#494, 520#495, #, #, #, 524#522, #, 528#520, 528#521, 528#524, #, #, #, #, 535#529, 535#530, 535#531, #, #, 538#536, #, #, #, 542#540, #, #, 545#543, #, 550#538, 550#539, 550#542, 550#545, #, 565#494, 565#495, 565#516, 565#517, 565#528, 565#496, 565#497, 565#498, 565#529, 565#530, 565#535, 565#550, 565#499, 565#500, #, #, 568#566, #, #, 571#569, #, #, 574#572, #, 578#568, 578#571, 578#574, #, #, #, #, 585#579, 585#580, 585#581, #, #, #, #, #, #, #, 594#590, 594#591, #, #, 598#594, 598#595, #, #, #, #, #, #, #, 613#586, 613#587, 613#588, 613#589, 613#599, 613#590, 613#591, 613#604, #, 618#601, 618#602, 618#603, 618#613, #, 634#578, 634#585, 634#580, 634#581, 634#586, 634#587, 634#588, 634#589, 634#598, 634#599, 634#600, 634#618, 634#590, 634#591, 634#604, #, 639#492, 639#493, 639#565, 639#634, #, #, 642#640, #, #, #, #, 648#414, 648#417, #, #, 653#645, 653#648, 653#649, #, #, #, 662#642, 662#643, 662#644, 662#653, 662#654, 662#655, #, #, 673#0, 673#1, 673#2, 673#413, 673#422, 673#423, 673#639, 673#662, 673#663, #, #, 674#673, #, 682#676, #, 682#678, #, 682#680, 413#, #, #, #, 673#687, #, 674#689, #, #, 689#690, 662#693, #, 693#695, #, 695#, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, 695#783, 695#784, 695#785, 695#786, 695#787, 695#788, 695#789, 695#790, 695#791, 695#792, 695#793, 695#794, 695#795, 695#796, 695#797, 695#798, 695#799, 695#800, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, 693#1006, #, #, 689#1007, 673#1010, #, 662#1012, #, 1012#1014, #, 1014#, 1014#1017, #, 673#1019, #, #, 1022#1020, #, 1019#1022, #, 1019#1024, 662#1027, #, 1027#1029, #, 1029#, #, 689#1031, 662#1034, #, 1034#1036, #, 1036#, 662#1039, #, 1039#1041, #, 1041#, #, 689#1043, #, 689#1045, 1019#1048, #, #, 689#1049, 1019#1052, #, 662#1054, #, 1054#1056, #, 1056#, 1054#1059, #, #, 1066#1060, #, 1066#1062, #, 1066#1064, 639#, #, 689#1067, #, 689#1069, #, 689#1071, #, 689#1073, #, 689#1075, #, #, 689#1078, #, 689#1080, #, 689#1082, #, 689#1084, #, 662#1086, #, 689#1088, #, 689#1090, #, 689#1092, #, #, #, #, 1103#1094, 1103#1095, 1103#1096, 1103#1097, 1103#, #, 1105#1103, #, 662#1105, 662#1108, #, 662#1110, #, 662#1112, #, 662#1114, #, 1110#1116, #, 662#1118, #, 1118#1120, #, #, 689#1121, #, #, #, #, #, 1134#1123, 1134#1124, 1134#1125, 1134#1126, 1134#1127, 1134#, #, 1136#1134, #, 662#1136, #, 1140#1138, #, 662#1140, #, #, #, #, #, 1153#1142, 1153#1143, 1153#1144, 1153#1145, 1153#1146, 1153#, #, 1155#1153, #, 662#1155, #, 689#1157, 1108#1160, #, 1108#1162, #, 1110#1164, #, 1110#1166, #, 1114#1168, #, 1114#1170, #, #, 689#1171, #, 689#1173, #, 1177#, #, 1179#1177, #, 662#1179, #, 689#1181, 1153#1184, #, 1153#1186, #, 1153#1188, #, #, 689#1189, #, 689#1191, #, 1019#1193, 1019#1196, #, 1019#1198, #, 673#1200, #, #, 689#1201, 1103#1204, #, #, #, #, #, #, #, #, 1220#1205, 1220#1206, 1220#1207, 1220#1208, 1220#1209, 1220#1210, 1220#1211, 1220#, #, 1222#1220, #, 662#1222, 1177#1225, #, 1177#1227, #, #, 689#1228, 1019#1231, #, 662#1233, #, #, 689#1234, 662#1237, #, 662#1239, #, 662#1241, #, 662#1243, #, 1200#1245, #, 1179#1247, #, #, 689#1248, #, 689#1250, #, 689#1252, 673#1255, #, 1255#1257, #, 662#1259, #, #, 689#1260, 1255#1263, #, #, 689#1264, 1255#1267, #, 1177#1269, #, 1177#1271, #, 1177#1273, #, 662#1275, #, 1019#1277, #, 1255#1279, #, #, 689#1280, #, 689#1282, #, 689#1284, #, 689#1286, #, 689#1288, #, 689#1290, #, 689#1292, #, 689#1294, #, 689#1296, #, 689#1298, #, 689#1300, #, 689#1302, #, 689#1304, 1019#1307, #, 1019#1309, #, #, 689#1310, #, 689#1312, 
### 内容
#0, 17:
文档\S应用\绘制光路图.ftxt
## end
#1, 17:
文档\S应用\画图样本库.ftxt
## end
#3, 401:
"""
+[返回目录](,mouseMove)
+[复制](,mouseMove)

"""
+mouseMove(_画板,)->+[del](,+mouseMove)...
->的(_画板,m_select)->的(m_select,_物体)->的(_物体,类型)->类型"圆形"...
->的(_物体,中心)->的(_物体,角度)->的(_画板,m_mouse)...
->+[python]"
dx=pt[0]-m[0]
dy=pt[1]-m[1]
r=np.sqrt(dx**2+dy**2)
theta=np.sign(dy)*np.arccos(-dx/r)
angle=np.rad2deg(theta)

"(Python,)->+[.]"m"(+[python],m_mouse)->+[o]"pt"(+[python],中心)->+[o]"angle"(+[python],角度)

## end
#5, 46:
+[返回目录](,旋转)

mouseMove:...
+[del](,mouseMove)
## end
#6, 338:
"""
+[返回目录](,mouseMove)
+[复制](,mouseMove)

"""
+mouseMove(_画板,)->+[del](,+mouseMove)...
->的(_画板,m_select)->的(m_select,_物体)->的(_物体,类型)->类型"圆形"...
->的(_物体,中心)->的(_物体,半径)->的(_画板,m_mouse)...
->+[python]"
dx=pt[0]-m[0]
dy=pt[1]-m[1]
r=np.sqrt(dx**2+dy**2)

"(Python,)->+[.]"m"(+[python],m_mouse)->+[o]"pt"(+[python],中心)->+[o]"r"(+[python],半径)

## end
#8, 46:
+[返回目录](,缩放)

mouseMove:...
+[del](,mouseMove)
## end
#9, 258:
"""
+[返回目录](,mouseMove)
+[复制](,mouseMove)

"""
+mouseMove(_画板,)->+[del](,+mouseMove)...
->的(_画板,m_select)->的(m_select,_物体)->的(_物体,类型)->类型"圆形"...
->的(_物体,中心)->的(_画板,m_mouse)...
->+[python]"
pt=m

"(Python,)->+[.]"m"(+[python],m_mouse)->+[o]"pt"(+[python],中心)

## end
#11, 46:
+[返回目录](,移动)

mouseMove:...
+[del](,mouseMove)
## end
#15, 61:
+[返回目录](,动作)

移动:...
缩放:...
旋转:...

+[粘贴](,旋转)
+[修改内容](移动,旋转)
## end
#16, 986:
"""
+[返回目录](,按键)
+[修改标题]"按键"(,设置按键)

"""

+按键(,_物体)->在(+按键,_鼠标位置)->+[del](,+按键)...
->的(_物体,类型)->类型"圆形"...
->的(_物体,中心)->的(_物体,半径)->的(_物体,角度)...
->+[.]"pm"([python],_鼠标位置)->+[.]"pt"([python],中心)->+[.]"r"([python],半径)...
->+[.]"angle"([python],角度)->+按键位置->[python]"
pt=pt
r=r[0]
pm=pm
angle=angle[0]
theta=np.deg2rad(angle)
R=6

X=[pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1]-r*np.sin(theta),pt[1]]

got=False
for i in range(len(X)):
    d=np.sqrt((X[i]-pm[0])**2+(Y[i]-pm[1])**2)
    if d<=R:
        got=True
        break

if got==False:
    ans='里面'
elif i==0:
    ans='角度点'
else:
    ans='半径点'

state=True
"(Python,+按键位置)...
->是([动作库],动作#0)->和(动作#0,画图动作)->的(画图动作,mouseMove#0)...
->的(_物体,动作)...
->[]{
	[==]"里面"(,+按键位置)->的(动作,移动)->的(移动,mouseMove)...
	->+[修改内容](mouseMove,mouseMove#0)
}:->[],->>[]{
	[==]"角度点"(,+按键位置)->的(动作,旋转)->的(旋转,mouseMove)...
	->+[修改内容](mouseMove,mouseMove#0)
}:->[],->>[]{
	[==]"半径点"(,+按键位置)->的(动作,缩放)->的(缩放,mouseMove)...
	->+[修改内容](mouseMove,mouseMove#0)
}:->[],->>[]
## end
#17, 125:
"""
+[返回目录](,画选中框)

"""

+画选中框(,_物体)->+[del](,+画选中框)...
->的(_物体,画图)->的(画图,图形)->的(画图,选中框)...
->+[修改内容](图形,画图)->+[增加内容](选中框,画图)
## end
#18, 96:
"""
+[返回目录](,去掉选中框)

"""

+去掉选中框(,_物体)->+[del](,+去掉选中框)...
->的(_物体,画图)->的(画图,图形)->+[修改内容](图形,画图)
## end
#22, 40:
+[返回目录](,动词)


画选中框:...
去掉选中框:...
按键:...
## end
#23, 1:
2
## end
#24, 8:
DashLine
## end
#25, 5:
0,0,0
## end
#26, 11:
255,255,255
## end
#27, 18:
48.373546489791295
## end
#28, 10:
-5.0, 94.0
## end
#31, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#32, 14:
+[返回目录]
+[内容]

## end
#35, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#36, 18:
105.62974572806075
## end
#37, 2:
圆形
## end
#38, 660:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


x0=pt[0]
y0=pt[1]
M=qp.transform()
M.translate(x0,y0)
M.rotate(-angle+90)
M.translate(-x0,-y0)

M0=qp.transform()
qp.setTransform(M)

qp.drawRect(x0-r,y0,2*r,d)

qp.setTransform(M0)
qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#39, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#41, 2:
10
## end
#50, 73:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10

## end
#55, 660:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


x0=pt[0]
y0=pt[1]
M=qp.transform()
M.translate(x0,y0)
M.rotate(-angle+90)
M.translate(-x0,-y0)

M0=qp.transform()
qp.setTransform(M)

qp.drawRect(x0-r,y0,2*r,d)

qp.setTransform(M0)
qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#56, 207:
+[返回目录](,反射)

中心::0,0
角度::0
pt0::
pt1::
pt2::

关系说明:...

[]=>中心=>+[显示](,中心)
中心"0,0"->+[del](,中心)



P代码:...
+[创建函数](,P代码)
+[创建输入](pt0,P代码)->+[创建输入](pt1,P代码)->+[创建输入](pt2,P代码)
+[创建输出](中心,P代码)->+[创建输出](角度,P代码)
## end
#72, 273:
+[返回目录](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...

动词:...
动作:...
的(动词,画选中框)->+[做](,圆形)->+[code](+[做],画选中框)

+[创建输入](厚度,画图)
+[创建输入](面颜色,画图)->+[创建输入](线颜色,画图)...
->+[创建输入](线型,画图)->+[创建输入](线粗细,画图)

+[粘贴](,圆形)
## end
#73, 401:
"""
+[返回目录](,mouseMove)
+[复制](,mouseMove)

"""
+mouseMove(_画板,)->+[del](,+mouseMove)...
->的(_画板,m_select)->的(m_select,_物体)->的(_物体,类型)->类型"圆形"...
->的(_物体,中心)->的(_物体,角度)->的(_画板,m_mouse)...
->+[python]"
dx=pt[0]-m[0]
dy=pt[1]-m[1]
r=np.sqrt(dx**2+dy**2)
theta=np.sign(dy)*np.arccos(-dx/r)
angle=np.rad2deg(theta)

"(Python,)->+[.]"m"(+[python],m_mouse)->+[o]"pt"(+[python],中心)->+[o]"angle"(+[python],角度)

## end
#75, 46:
+[返回目录](,旋转)

mouseMove:...
+[del](,mouseMove)
## end
#76, 338:
"""
+[返回目录](,mouseMove)
+[复制](,mouseMove)

"""
+mouseMove(_画板,)->+[del](,+mouseMove)...
->的(_画板,m_select)->的(m_select,_物体)->的(_物体,类型)->类型"圆形"...
->的(_物体,中心)->的(_物体,半径)->的(_画板,m_mouse)...
->+[python]"
dx=pt[0]-m[0]
dy=pt[1]-m[1]
r=np.sqrt(dx**2+dy**2)

"(Python,)->+[.]"m"(+[python],m_mouse)->+[o]"pt"(+[python],中心)->+[o]"r"(+[python],半径)

## end
#78, 46:
+[返回目录](,缩放)

mouseMove:...
+[del](,mouseMove)
## end
#79, 258:
"""
+[返回目录](,mouseMove)
+[复制](,mouseMove)

"""
+mouseMove(_画板,)->+[del](,+mouseMove)...
->的(_画板,m_select)->的(m_select,_物体)->的(_物体,类型)->类型"圆形"...
->的(_物体,中心)->的(_画板,m_mouse)...
->+[python]"
pt=m

"(Python,)->+[.]"m"(+[python],m_mouse)->+[o]"pt"(+[python],中心)

## end
#81, 46:
+[返回目录](,移动)

mouseMove:...
+[del](,mouseMove)
## end
#85, 61:
+[返回目录](,动作)

移动:...
缩放:...
旋转:...

+[粘贴](,旋转)
+[修改内容](移动,旋转)
## end
#86, 986:
"""
+[返回目录](,按键)
+[修改标题]"按键"(,设置按键)

"""

+按键(,_物体)->在(+按键,_鼠标位置)->+[del](,+按键)...
->的(_物体,类型)->类型"圆形"...
->的(_物体,中心)->的(_物体,半径)->的(_物体,角度)...
->+[.]"pm"([python],_鼠标位置)->+[.]"pt"([python],中心)->+[.]"r"([python],半径)...
->+[.]"angle"([python],角度)->+按键位置->[python]"
pt=pt
r=r[0]
pm=pm
angle=angle[0]
theta=np.deg2rad(angle)
R=6

X=[pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1]-r*np.sin(theta),pt[1]]

got=False
for i in range(len(X)):
    d=np.sqrt((X[i]-pm[0])**2+(Y[i]-pm[1])**2)
    if d<=R:
        got=True
        break

if got==False:
    ans='里面'
elif i==0:
    ans='角度点'
else:
    ans='半径点'

state=True
"(Python,+按键位置)...
->是([动作库],动作#0)->和(动作#0,画图动作)->的(画图动作,mouseMove#0)...
->的(_物体,动作)...
->[]{
	[==]"里面"(,+按键位置)->的(动作,移动)->的(移动,mouseMove)...
	->+[修改内容](mouseMove,mouseMove#0)
}:->[],->>[]{
	[==]"角度点"(,+按键位置)->的(动作,旋转)->的(旋转,mouseMove)...
	->+[修改内容](mouseMove,mouseMove#0)
}:->[],->>[]{
	[==]"半径点"(,+按键位置)->的(动作,缩放)->的(缩放,mouseMove)...
	->+[修改内容](mouseMove,mouseMove#0)
}:->[],->>[]
## end
#87, 125:
"""
+[返回目录](,画选中框)

"""

+画选中框(,_物体)->+[del](,+画选中框)...
->的(_物体,画图)->的(画图,图形)->的(画图,选中框)...
->+[修改内容](图形,画图)->+[增加内容](选中框,画图)
## end
#88, 96:
"""
+[返回目录](,去掉选中框)

"""

+去掉选中框(,_物体)->+[del](,+去掉选中框)...
->的(_物体,画图)->的(画图,图形)->+[修改内容](图形,画图)
## end
#92, 40:
+[返回目录](,动词)


画选中框:...
去掉选中框:...
按键:...
## end
#93, 1:
2
## end
#94, 8:
DashLine
## end
#95, 5:
0,0,0
## end
#96, 11:
255,255,255
## end
#97, 18:
48.373546489791295
## end
#98, 9:
37.5, 7.0
## end
#101, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#102, 14:
+[返回目录]
+[内容]

## end
#105, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#106, 18:
63.964225033123356
## end
#107, 2:
圆形
## end
#108, 660:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


x0=pt[0]
y0=pt[1]
M=qp.transform()
M.translate(x0,y0)
M.rotate(-angle+90)
M.translate(-x0,-y0)

M0=qp.transform()
qp.setTransform(M)

qp.drawRect(x0-r,y0,2*r,d)

qp.setTransform(M0)
qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#109, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#111, 2:
10
## end
#120, 73:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10

## end
#125, 660:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


x0=pt[0]
y0=pt[1]
M=qp.transform()
M.translate(x0,y0)
M.rotate(-angle+90)
M.translate(-x0,-y0)

M0=qp.transform()
qp.setTransform(M)

qp.drawRect(x0-r,y0,2*r,d)

qp.setTransform(M0)
qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#126, 139:
+[返回目录](,在光路上)

中心::
角度::
pt0::
pt1::

关系说明:...

P代码:...
+[创建函数](,P代码)
+[创建输入](pt0,P代码)->+[创建输入](pt1,P代码)
+[创建输出](中心,P代码)->+[创建输出](角度,P代码)

## end
#142, 273:
+[返回目录](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...

动词:...
动作:...
的(动词,画选中框)->+[做](,圆形)->+[code](+[做],画选中框)

+[创建输入](厚度,画图)
+[创建输入](面颜色,画图)->+[创建输入](线颜色,画图)...
->+[创建输入](线型,画图)->+[创建输入](线粗细,画图)

+[粘贴](,圆形)
## end
#143, 259:
"""
+[返回目录](,mouseMove)
+[复制](,mouseMove)

"""
+mouseMove(_画板,)->+[del](,+mouseMove)...
->的(_画板,m_select)->的(m_select,_物体)->的(_物体,类型)->类型"直线"...
->的(_物体,终点)->的(_画板,m_mouse)...
->+[python]"
pt2=m

"(Python,)->+[.]"m"(+[python],m_mouse)->+[o]"pt2"(+[python],终点)
## end
#145, 29:
+[返回目录](,移动终点)

mouseMove:...
## end
#146, 259:
"""
+[返回目录](,mouseMove)
+[复制](,mouseMove)

"""
+mouseMove(_画板,)->+[del](,+mouseMove)...
->的(_画板,m_select)->的(m_select,_物体)->的(_物体,类型)->类型"直线"...
->的(_物体,起点)->的(_画板,m_mouse)...
->+[python]"
pt1=m

"(Python,)->+[.]"m"(+[python],m_mouse)->+[o]"pt1"(+[python],起点)
## end
#148, 29:
+[返回目录](,移动起点)

mouseMove:...
## end
#149, 239:
"""
+[返回目录](,mouseMove)

"""
+mouseMove(_画板,)->+[del](,+mouseMove)...
->的(_画板,m_select)->的(m_select,_物体)->的(_物体,类型)->类型"矩形"...
->的(_物体,起点)->的(_画板,m_mouse)...
->+[python]"
pt=m
"(Python,)->+[.]"m"(+[python],m_mouse)->+[o]"pt"(+[python],起点)

## end
#150, 376:
"""
+[返回目录](,mouseMove)
+[复制](,mouseMove)

"""
+mouseMove(_画板,)->+[del](,+mouseMove)...
->的(_画板,m_select)->的(m_select,_物体)->的(_物体,类型)->类型"直线"...
->的(_物体,起点)->的(_物体,终点)->的(_画板,m_mouse)...
->+[python]"
dx=pt2[0]-pt1[0]
dy=pt2[1]-pt1[1]
pt1=[m[0]-dx/2,m[1]-dy/2]
pt2=[m[0]+dx/2,m[1]+dy/2]

"(Python,)->+[.]"m"(+[python],m_mouse)->+[o]"pt1"(+[python],起点)->+[o]"pt2"(+[python],终点)

## end
#152, 46:
+[返回目录](,移动)

mouseMove:...
+[del](,mouseMove)
## end
#157, 72:
+[返回目录](,动作)

移动:...
移动起点:...
移动终点:...

+[粘贴](,移动终点)
+[修改内容](移动,移动终点)



## end
#158, 941:
"""
+[返回目录](,按键)
+[修改标题]"按键"(,设置按键)

"""

+按键(,_物体)->在(+按键,_鼠标位置)->+[del](,+按键)...
->的(_物体,类型)->类型"直线"...
->的(_物体,起点)->的(_物体,终点)->的(_物体,线粗细)...
->+[.]"pm"([python],_鼠标位置)->+[.]"pt0"([python],起点)->+[.]"pt1"([python],终点)...
->+[.]"width"([python],线粗细)->+按键位置->[python]"
pt=pt0
pt1=pt1
pm=pm
width=width[0]
R=6

X=[pt[0],pt1[0]]
Y=[pt[1],pt1[1]]

got=False
for i in range(len(X)):
    d=np.sqrt((X[i]-pm[0])**2+(Y[i]-pm[1])**2)
    if d<=R:
        got=True
        break

if got==False:
    ans='里面'
elif i==0:
    ans='起点'
else:
    ans='终点'

state=True
"(Python,+按键位置)...
->是([动作库],动作#0)->和(动作#0,画图动作)->的(画图动作,mouseMove#0)...
->的(_物体,动作)...
->[]{
	[==]"里面"(,+按键位置)->的(动作,移动)->的(移动,mouseMove)...
	->+[修改内容](mouseMove,mouseMove#0)
}:->[],->>[]{
	[==]"起点"(,+按键位置)->的(动作,移动起点)->的(移动起点,mouseMove)...
	->+[修改内容](mouseMove,mouseMove#0)
}:->[],->>[]{
	[==]"终点"(,+按键位置)->的(动作,移动终点)->的(移动终点,mouseMove)...
	->+[修改内容](mouseMove,mouseMove#0)
}:->[],->>[]
## end
#159, 125:
"""
+[返回目录](,画选中框)

"""

+画选中框(,_物体)->+[del](,+画选中框)...
->的(_物体,画图)->的(画图,图形)->的(画图,选中框)...
->+[修改内容](图形,画图)->+[增加内容](选中框,画图)
## end
#160, 96:
"""
+[返回目录](,去掉选中框)

"""

+去掉选中框(,_物体)->+[del](,+去掉选中框)...
->的(_物体,画图)->的(画图,图形)->+[修改内容](图形,画图)
## end
#164, 40:
+[返回目录](,动词)


画选中框:...
去掉选中框:...
按键:...
## end
#165, 1:
1
## end
#166, 8:
DashLine
## end
#167, 5:
0,0,0
## end
#168, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#170, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#171, 14:
+[返回目录]
+[内容]

## end
#172, 12:
-294.0, 72.0
## end
#173, 13:
-195.0, -28.0
## end
#176, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#180, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#181, 2:
直线
## end
#182, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#183, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#190, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#195, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#208, 220:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...

动词:...
动作:...
的(动词,去掉选中框)->+[做](,直线)->+[code](+[做],去掉选中框)

+[创建输入](线颜色,画图)...
->+[创建输入](线型,画图)->+[创建输入](线粗细,画图)

+[粘贴](,直线)
## end
#209, 259:
"""
+[返回目录](,mouseMove)
+[复制](,mouseMove)

"""
+mouseMove(_画板,)->+[del](,+mouseMove)...
->的(_画板,m_select)->的(m_select,_物体)->的(_物体,类型)->类型"直线"...
->的(_物体,终点)->的(_画板,m_mouse)...
->+[python]"
pt2=m

"(Python,)->+[.]"m"(+[python],m_mouse)->+[o]"pt2"(+[python],终点)
## end
#211, 29:
+[返回目录](,移动终点)

mouseMove:...
## end
#212, 259:
"""
+[返回目录](,mouseMove)
+[复制](,mouseMove)

"""
+mouseMove(_画板,)->+[del](,+mouseMove)...
->的(_画板,m_select)->的(m_select,_物体)->的(_物体,类型)->类型"直线"...
->的(_物体,起点)->的(_画板,m_mouse)...
->+[python]"
pt1=m

"(Python,)->+[.]"m"(+[python],m_mouse)->+[o]"pt1"(+[python],起点)
## end
#214, 29:
+[返回目录](,移动起点)

mouseMove:...
## end
#215, 239:
"""
+[返回目录](,mouseMove)

"""
+mouseMove(_画板,)->+[del](,+mouseMove)...
->的(_画板,m_select)->的(m_select,_物体)->的(_物体,类型)->类型"矩形"...
->的(_物体,起点)->的(_画板,m_mouse)...
->+[python]"
pt=m
"(Python,)->+[.]"m"(+[python],m_mouse)->+[o]"pt"(+[python],起点)

## end
#216, 376:
"""
+[返回目录](,mouseMove)
+[复制](,mouseMove)

"""
+mouseMove(_画板,)->+[del](,+mouseMove)...
->的(_画板,m_select)->的(m_select,_物体)->的(_物体,类型)->类型"直线"...
->的(_物体,起点)->的(_物体,终点)->的(_画板,m_mouse)...
->+[python]"
dx=pt2[0]-pt1[0]
dy=pt2[1]-pt1[1]
pt1=[m[0]-dx/2,m[1]-dy/2]
pt2=[m[0]+dx/2,m[1]+dy/2]

"(Python,)->+[.]"m"(+[python],m_mouse)->+[o]"pt1"(+[python],起点)->+[o]"pt2"(+[python],终点)

## end
#218, 46:
+[返回目录](,移动)

mouseMove:...
+[del](,mouseMove)
## end
#223, 72:
+[返回目录](,动作)

移动:...
移动起点:...
移动终点:...

+[粘贴](,移动终点)
+[修改内容](移动,移动终点)



## end
#224, 941:
"""
+[返回目录](,按键)
+[修改标题]"按键"(,设置按键)

"""

+按键(,_物体)->在(+按键,_鼠标位置)->+[del](,+按键)...
->的(_物体,类型)->类型"直线"...
->的(_物体,起点)->的(_物体,终点)->的(_物体,线粗细)...
->+[.]"pm"([python],_鼠标位置)->+[.]"pt0"([python],起点)->+[.]"pt1"([python],终点)...
->+[.]"width"([python],线粗细)->+按键位置->[python]"
pt=pt0
pt1=pt1
pm=pm
width=width[0]
R=6

X=[pt[0],pt1[0]]
Y=[pt[1],pt1[1]]

got=False
for i in range(len(X)):
    d=np.sqrt((X[i]-pm[0])**2+(Y[i]-pm[1])**2)
    if d<=R:
        got=True
        break

if got==False:
    ans='里面'
elif i==0:
    ans='起点'
else:
    ans='终点'

state=True
"(Python,+按键位置)...
->是([动作库],动作#0)->和(动作#0,画图动作)->的(画图动作,mouseMove#0)...
->的(_物体,动作)...
->[]{
	[==]"里面"(,+按键位置)->的(动作,移动)->的(移动,mouseMove)...
	->+[修改内容](mouseMove,mouseMove#0)
}:->[],->>[]{
	[==]"起点"(,+按键位置)->的(动作,移动起点)->的(移动起点,mouseMove)...
	->+[修改内容](mouseMove,mouseMove#0)
}:->[],->>[]{
	[==]"终点"(,+按键位置)->的(动作,移动终点)->的(移动终点,mouseMove)...
	->+[修改内容](mouseMove,mouseMove#0)
}:->[],->>[]
## end
#225, 125:
"""
+[返回目录](,画选中框)

"""

+画选中框(,_物体)->+[del](,+画选中框)...
->的(_物体,画图)->的(画图,图形)->的(画图,选中框)...
->+[修改内容](图形,画图)->+[增加内容](选中框,画图)
## end
#226, 96:
"""
+[返回目录](,去掉选中框)

"""

+去掉选中框(,_物体)->+[del](,+去掉选中框)...
->的(_物体,画图)->的(画图,图形)->+[修改内容](图形,画图)
## end
#230, 40:
+[返回目录](,动词)


画选中框:...
去掉选中框:...
按键:...
## end
#231, 1:
1
## end
#232, 8:
DashLine
## end
#233, 5:
0,0,0
## end
#234, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#236, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#237, 14:
+[返回目录]
+[内容]

## end
#240, 13:
-195.0, -28.0
## end
#241, 10:
-5.0, 94.0
## end
#244, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#248, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#249, 2:
直线
## end
#250, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#251, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#258, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#263, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#276, 220:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...

动词:...
动作:...
的(动词,去掉选中框)->+[做](,直线)->+[code](+[做],去掉选中框)

+[创建输入](线颜色,画图)...
->+[创建输入](线型,画图)->+[创建输入](线粗细,画图)

+[粘贴](,直线)
## end
#277, 259:
"""
+[返回目录](,mouseMove)
+[复制](,mouseMove)

"""
+mouseMove(_画板,)->+[del](,+mouseMove)...
->的(_画板,m_select)->的(m_select,_物体)->的(_物体,类型)->类型"直线"...
->的(_物体,终点)->的(_画板,m_mouse)...
->+[python]"
pt2=m

"(Python,)->+[.]"m"(+[python],m_mouse)->+[o]"pt2"(+[python],终点)
## end
#279, 29:
+[返回目录](,移动终点)

mouseMove:...
## end
#280, 259:
"""
+[返回目录](,mouseMove)
+[复制](,mouseMove)

"""
+mouseMove(_画板,)->+[del](,+mouseMove)...
->的(_画板,m_select)->的(m_select,_物体)->的(_物体,类型)->类型"直线"...
->的(_物体,起点)->的(_画板,m_mouse)...
->+[python]"
pt1=m

"(Python,)->+[.]"m"(+[python],m_mouse)->+[o]"pt1"(+[python],起点)
## end
#282, 29:
+[返回目录](,移动起点)

mouseMove:...
## end
#283, 239:
"""
+[返回目录](,mouseMove)

"""
+mouseMove(_画板,)->+[del](,+mouseMove)...
->的(_画板,m_select)->的(m_select,_物体)->的(_物体,类型)->类型"矩形"...
->的(_物体,起点)->的(_画板,m_mouse)...
->+[python]"
pt=m
"(Python,)->+[.]"m"(+[python],m_mouse)->+[o]"pt"(+[python],起点)

## end
#284, 376:
"""
+[返回目录](,mouseMove)
+[复制](,mouseMove)

"""
+mouseMove(_画板,)->+[del](,+mouseMove)...
->的(_画板,m_select)->的(m_select,_物体)->的(_物体,类型)->类型"直线"...
->的(_物体,起点)->的(_物体,终点)->的(_画板,m_mouse)...
->+[python]"
dx=pt2[0]-pt1[0]
dy=pt2[1]-pt1[1]
pt1=[m[0]-dx/2,m[1]-dy/2]
pt2=[m[0]+dx/2,m[1]+dy/2]

"(Python,)->+[.]"m"(+[python],m_mouse)->+[o]"pt1"(+[python],起点)->+[o]"pt2"(+[python],终点)

## end
#286, 46:
+[返回目录](,移动)

mouseMove:...
+[del](,mouseMove)
## end
#291, 72:
+[返回目录](,动作)

移动:...
移动起点:...
移动终点:...

+[粘贴](,移动终点)
+[修改内容](移动,移动终点)



## end
#292, 941:
"""
+[返回目录](,按键)
+[修改标题]"按键"(,设置按键)

"""

+按键(,_物体)->在(+按键,_鼠标位置)->+[del](,+按键)...
->的(_物体,类型)->类型"直线"...
->的(_物体,起点)->的(_物体,终点)->的(_物体,线粗细)...
->+[.]"pm"([python],_鼠标位置)->+[.]"pt0"([python],起点)->+[.]"pt1"([python],终点)...
->+[.]"width"([python],线粗细)->+按键位置->[python]"
pt=pt0
pt1=pt1
pm=pm
width=width[0]
R=6

X=[pt[0],pt1[0]]
Y=[pt[1],pt1[1]]

got=False
for i in range(len(X)):
    d=np.sqrt((X[i]-pm[0])**2+(Y[i]-pm[1])**2)
    if d<=R:
        got=True
        break

if got==False:
    ans='里面'
elif i==0:
    ans='起点'
else:
    ans='终点'

state=True
"(Python,+按键位置)...
->是([动作库],动作#0)->和(动作#0,画图动作)->的(画图动作,mouseMove#0)...
->的(_物体,动作)...
->[]{
	[==]"里面"(,+按键位置)->的(动作,移动)->的(移动,mouseMove)...
	->+[修改内容](mouseMove,mouseMove#0)
}:->[],->>[]{
	[==]"起点"(,+按键位置)->的(动作,移动起点)->的(移动起点,mouseMove)...
	->+[修改内容](mouseMove,mouseMove#0)
}:->[],->>[]{
	[==]"终点"(,+按键位置)->的(动作,移动终点)->的(移动终点,mouseMove)...
	->+[修改内容](mouseMove,mouseMove#0)
}:->[],->>[]
## end
#293, 125:
"""
+[返回目录](,画选中框)

"""

+画选中框(,_物体)->+[del](,+画选中框)...
->的(_物体,画图)->的(画图,图形)->的(画图,选中框)...
->+[修改内容](图形,画图)->+[增加内容](选中框,画图)
## end
#294, 96:
"""
+[返回目录](,去掉选中框)

"""

+去掉选中框(,_物体)->+[del](,+去掉选中框)...
->的(_物体,画图)->的(画图,图形)->+[修改内容](图形,画图)
## end
#298, 40:
+[返回目录](,动词)


画选中框:...
去掉选中框:...
按键:...
## end
#299, 1:
1
## end
#300, 8:
DashLine
## end
#301, 5:
0,0,0
## end
#302, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#304, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#305, 14:
+[返回目录]
+[内容]

## end
#309, 10:
-5.0, 94.0
## end
#312, 11:
80.0, -80.0
## end
#315, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#319, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#320, 2:
直线
## end
#321, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#322, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#329, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#334, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#347, 220:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...

动词:...
动作:...
的(动词,去掉选中框)->+[做](,直线)->+[code](+[做],去掉选中框)

+[创建输入](线颜色,画图)...
->+[创建输入](线型,画图)->+[创建输入](线粗细,画图)

+[粘贴](,直线)
## end
#348, 10:
-5.0, 94.0
## end
#349, 11:
80.0, -80.0
## end
#352, 31:
+[返回目录](,输入)
+[内容]
pt0::
pt1::

## end
#355, 59:
+[返回目录](,输出)
+[内容]
中心::263.0, -51.0
角度::149.21585347367358

## end
#358, 231:
"""
+[返回目录](,P代码)

输入:...
输出:...

+[P函数](,P代码)

"""

中心[0]=(pt0[0]+pt1[0])/2
中心[1]=(pt0[1]+pt1[1])/2

dx01=pt0[0]-pt1[0]
dy01=pt0[1]-pt1[1]
r01=np.sqrt(dx01**2+dy01**2)
angle=-np.rad2deg(np.arccos(dx01/r01)*np.sign(dy01))

角度=angle
## end
#359, 156:
+[返回目录](,关系说明)

在光路上(_镜子,_光线)->_镜子->_光线(,)...
->的(_镜子,中心)->的(_镜子,角度)...
->的(_光线,起点)->的(_光线,终点)...
->+[有](在光路上,中心)->+[有](在光路上,角度)...
->+是(起点,pt0)->+是(终点,pt1)
## end
#366, 180:
在光路上(_透镜,_光线)->_透镜->_光线(,_A)->_光线2(_A,)...
->的(_透镜,中心)->的(_透镜,角度)...
->的(_光线,终点)->的(_光线,起点)...
->的(_光线2,终点#2)...
->+是(终点,pt0)->+是(起点,pt1)->+是(终点#2,pt2)...
->+是(pt,中心)->+是(angle,角度)
## end
#367, 13:
-195.0, -28.0
## end
#368, 11:
80.0, -80.0
## end
#369, 10:
-5.0, 94.0
## end
#373, 37:
+[返回目录](,输入)
+[内容]
pt0::
pt1::
pt2::

## end
#376, 41:
+[返回目录](,输出)
+[内容]
角度::0
中心::-88.0, 54.0

## end
#379, 383:
"""
+[返回目录](,P代码)
输入:...
输出:...
+[P函数](,P代码)

"""

dx01=pt0[0]-pt1[0]
dy01=pt0[1]-pt1[1]
r01=np.sqrt(dx01**2+dy01**2)

dx02=pt0[0]-pt2[0]
dy02=pt0[1]-pt2[1]
r02=np.sqrt(dx02**2+dy02**2)

中心=pt0

angle1=-np.rad2deg(np.arccos(dx01/r01)*np.sign(dy01))
angle2=-np.rad2deg(np.arccos(dx02/r02)*np.sign(dy02))
dangle=angle2-angle1
角度=(angle1+angle2)/2
if dangle<180:
    角度+=180

print(中心)

## end
#389, 66:
+[返回目录](,规则)

在光路上:...
+[修改标题]"反射"(,反射1)
反射:...
+[修改标题]"在光路上"(,反射)
## end
#413, 216:
+[返回目录](,测试场景)
+[设置结构](,测试场景)

规则:...
光线(1,2)->1->2->+在光路上(透镜,光线)->+[有](规则,+在光路上)
光线(1,)->1->+反射(反射镜,光线)->+[有](规则,+反射)
规则=>的(规则,_规律)->的(_规律,P代码)=>+[P函数](,P代码)

主光路::
+[创建光路](,主光路)
+[删除光路](,主光路)

反射镜:
透镜:
+[创建镜子](,透镜)
## end
#414, 125:
"""
+[返回目录](,Q)

"""

+Q(_画板,)->+[del](,+Q)->的(_画板,m_scene)...
->Q->的(_动作,Q)->的(_动作,mousePress)->创建(mousePress,)->+[del](,创建)
## end
#415, 31:
"""
+[返回目录](,mouseRelease)

"""
## end
#416, 233:
"""
+[返回目录](,mouseMove)

"""

+mouseMove(_画板,)->+[del](,+mouseMove)...
->的(_画板,m_mouse)...
->mouseMove->的(_动作,mouseMove)->的(_动作,mousePress)->创建(mousePress,_光路)...
->的(_光路,终点#0)->终点#0(,_终点)->光线(_终点,)...
->的(光线,终点)->+[修改内容](m_mouse,终点)
## end
#417, 740:
"""
+[返回目录](,mousePress)
+[修改标题]"m"(,mousePress)
+[修改标题]"mousePress"(,m)
mousePress->创建(mousePress,)->+[del](,创建)

"""

+mousePress(_画板,)->+[del](,+mousePress)...
->的(_画板,m_mouse)->的(_画板,m_scene)->m_scene(,_场景)...
->创建(mousePress,_光路)...
->的(_光路,终点)->终点(,_终点)...
->的(_光路,起点)->起点(,_起点)...

->+的(_场景,+光线)->+光线(+新点,)->+[右连](终点,+新点)...
->+的(_光路,+新点)->+的(_光路,+光线)...
->+[标题](_终点,)->+[python]"
ans=int(n[0]+1)
"(Python,+[修改标题])->+[.]"n"(+[python],+[标题])->+[修改标题](,+新点)...


->+[创建直线](,+光线)->[]{
	光线(_终点,_){[]=>_}...
	->+[右连](光线,+新点)->+[做]"
+做(_光线1,_光线2)->+[del](,+做)...
->的(_光线1,终点)->的(_光线2,起点)->+是(终点,起点)
"(光线,+光线)
}:->[],

->>+[做]"
+做(m_mouse,_光线)->+[del](,+做)...
->的(_光线,起点)->的(_光线,终点)->+[修改内容](m_mouse,起点)->+[修改内容](m_mouse,终点)
"(m_mouse,+光线)

## end
#422, 71:
+[返回目录](,光路图动作)

mousePress:...
mouseMove:...
mouseRelease:...

Q:...


## end
#423, 16:
文档\S应用\画图工具.ftxt
## end
#424, 2:
10
## end
#425, 401:
"""
+[返回目录](,mouseMove)
+[复制](,mouseMove)

"""
+mouseMove(_画板,)->+[del](,+mouseMove)...
->的(_画板,m_select)->的(m_select,_物体)->的(_物体,类型)->类型"圆形"...
->的(_物体,中心)->的(_物体,角度)->的(_画板,m_mouse)...
->+[python]"
dx=pt[0]-m[0]
dy=pt[1]-m[1]
r=np.sqrt(dx**2+dy**2)
theta=np.sign(dy)*np.arccos(-dx/r)
angle=np.rad2deg(theta)

"(Python,)->+[.]"m"(+[python],m_mouse)->+[o]"pt"(+[python],中心)->+[o]"angle"(+[python],角度)

## end
#427, 46:
+[返回目录](,旋转)

mouseMove:...
+[del](,mouseMove)
## end
#428, 338:
"""
+[返回目录](,mouseMove)
+[复制](,mouseMove)

"""
+mouseMove(_画板,)->+[del](,+mouseMove)...
->的(_画板,m_select)->的(m_select,_物体)->的(_物体,类型)->类型"圆形"...
->的(_物体,中心)->的(_物体,半径)->的(_画板,m_mouse)...
->+[python]"
dx=pt[0]-m[0]
dy=pt[1]-m[1]
r=np.sqrt(dx**2+dy**2)

"(Python,)->+[.]"m"(+[python],m_mouse)->+[o]"pt"(+[python],中心)->+[o]"r"(+[python],半径)

## end
#430, 46:
+[返回目录](,缩放)

mouseMove:...
+[del](,mouseMove)
## end
#431, 258:
"""
+[返回目录](,mouseMove)
+[复制](,mouseMove)

"""
+mouseMove(_画板,)->+[del](,+mouseMove)...
->的(_画板,m_select)->的(m_select,_物体)->的(_物体,类型)->类型"圆形"...
->的(_物体,中心)->的(_画板,m_mouse)...
->+[python]"
pt=m

"(Python,)->+[.]"m"(+[python],m_mouse)->+[o]"pt"(+[python],中心)

## end
#433, 46:
+[返回目录](,移动)

mouseMove:...
+[del](,mouseMove)
## end
#437, 61:
+[返回目录](,动作)

移动:...
缩放:...
旋转:...

+[粘贴](,旋转)
+[修改内容](移动,旋转)
## end
#438, 986:
"""
+[返回目录](,按键)
+[修改标题]"按键"(,设置按键)

"""

+按键(,_物体)->在(+按键,_鼠标位置)->+[del](,+按键)...
->的(_物体,类型)->类型"圆形"...
->的(_物体,中心)->的(_物体,半径)->的(_物体,角度)...
->+[.]"pm"([python],_鼠标位置)->+[.]"pt"([python],中心)->+[.]"r"([python],半径)...
->+[.]"angle"([python],角度)->+按键位置->[python]"
pt=pt
r=r[0]
pm=pm
angle=angle[0]
theta=np.deg2rad(angle)
R=6

X=[pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1]-r*np.sin(theta),pt[1]]

got=False
for i in range(len(X)):
    d=np.sqrt((X[i]-pm[0])**2+(Y[i]-pm[1])**2)
    if d<=R:
        got=True
        break

if got==False:
    ans='里面'
elif i==0:
    ans='角度点'
else:
    ans='半径点'

state=True
"(Python,+按键位置)...
->是([动作库],动作#0)->和(动作#0,画图动作)->的(画图动作,mouseMove#0)...
->的(_物体,动作)...
->[]{
	[==]"里面"(,+按键位置)->的(动作,移动)->的(移动,mouseMove)...
	->+[修改内容](mouseMove,mouseMove#0)
}:->[],->>[]{
	[==]"角度点"(,+按键位置)->的(动作,旋转)->的(旋转,mouseMove)...
	->+[修改内容](mouseMove,mouseMove#0)
}:->[],->>[]{
	[==]"半径点"(,+按键位置)->的(动作,缩放)->的(缩放,mouseMove)...
	->+[修改内容](mouseMove,mouseMove#0)
}:->[],->>[]
## end
#439, 125:
"""
+[返回目录](,画选中框)

"""

+画选中框(,_物体)->+[del](,+画选中框)...
->的(_物体,画图)->的(画图,图形)->的(画图,选中框)...
->+[修改内容](图形,画图)->+[增加内容](选中框,画图)
## end
#440, 96:
"""
+[返回目录](,去掉选中框)

"""

+去掉选中框(,_物体)->+[del](,+去掉选中框)...
->的(_物体,画图)->的(画图,图形)->+[修改内容](图形,画图)
## end
#444, 40:
+[返回目录](,动词)


画选中框:...
去掉选中框:...
按键:...
## end
#445, 1:
2
## end
#446, 8:
DashLine
## end
#447, 5:
0,0,0
## end
#448, 11:
255,255,255
## end
#449, 18:
48.373546489791295
## end
#450, 12:
-37.0, -39.0
## end
#453, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#454, 14:
+[返回目录]
+[内容]

## end
#457, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#458, 19:
-48.990913098429786
## end
#459, 2:
圆形
## end
#460, 660:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


x0=pt[0]
y0=pt[1]
M=qp.transform()
M.translate(x0,y0)
M.rotate(-angle+90)
M.translate(-x0,-y0)

M0=qp.transform()
qp.setTransform(M)

qp.drawRect(x0-r,y0,2*r,d)

qp.setTransform(M0)
qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#461, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#471, 73:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10

## end
#476, 1153:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


x0=pt[0]
y0=pt[1]
M=qp.transform()
M.translate(x0,y0)
M.rotate(-angle+90)
M.translate(-x0,-y0)

M0=qp.transform()
qp.setTransform(M)

qp.drawRect(x0-r,y0,2*r,d)

qp.setTransform(M0)
qp.setBrush(QBrush())
qp.setPen(QPen())


"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#492, 273:
+[返回目录](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...

动词:...
动作:...
的(动词,画选中框)->+[做](,圆形)->+[code](+[做],画选中框)

+[创建输入](厚度,画图)
+[创建输入](面颜色,画图)->+[创建输入](线颜色,画图)...
->+[创建输入](线型,画图)->+[创建输入](线粗细,画图)

+[粘贴](,圆形)
## end
#494, 11:
-98.5, 83.5
## end
#495, 11:
270.5, 38.5
## end
#496, 5:
0,0,0
## end
#497, 8:
DashLine
## end
#498, 1:
1
## end
#499, 5:
20 cm
## end
#500, 2:
30
## end
#508, 50:
线颜色::0,0,0
线型::DashLine
线粗细::2
文字::10 cm
位移距离::20

## end
#510, 1600:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

angle=30
l=20
D=位移距离[0]
d=10
text=文字


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush(QColor(edgeColor[0],edgeColor[1],edgeColor[2])))

r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
if r!=0:
    theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]

Dx=D*np.cos(np.deg2rad(theta-90))
Dy=-D*np.sin(np.deg2rad(theta-90))
pt10=[0,0]
pt20=[0,0]
pt10[0]=pt1[0]+Dx
pt10[1]=pt1[1]+Dy
pt20[0]=pt2[0]+Dx
pt20[1]=pt2[1]+Dy

path1=QPainterPath()
path1.moveTo(pt10[0],pt10[1])
path1.lineTo(pt10[0]+dp21[0],pt10[1]+dp21[1])
path1.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1])
path1.lineTo(pt10[0],pt10[1])

path2=QPainterPath()
path2.moveTo(pt20[0],pt20[1])
path2.lineTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])
path2.lineTo(pt20[0],pt20[1])

qp.drawPath(path1)
qp.drawPath(path2)
qp.drawLine(pt1[0],pt1[1],pt10[0],pt10[1])
qp.drawLine(pt2[0],pt2[1],pt20[0],pt20[1])


dx=d*np.cos(np.deg2rad(theta-90))
dy=-d*np.sin(np.deg2rad(theta-90))
pt0=[0,0]
pt0[0]=(pt10[0]+pt20[0])/2+dx
pt0[1]=(pt10[1]+pt20[1])/2+dy
qp.drawText(pt0[0]-50,pt0[1]-50,100,100,Qt.AlignHCenter|Qt.AlignVCenter,text)


qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])

qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#511, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#516, 1600:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

angle=30
l=20
D=位移距离[0]
d=10
text=文字


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush(QColor(edgeColor[0],edgeColor[1],edgeColor[2])))

r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
if r!=0:
    theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]

Dx=D*np.cos(np.deg2rad(theta-90))
Dy=-D*np.sin(np.deg2rad(theta-90))
pt10=[0,0]
pt20=[0,0]
pt10[0]=pt1[0]+Dx
pt10[1]=pt1[1]+Dy
pt20[0]=pt2[0]+Dx
pt20[1]=pt2[1]+Dy

path1=QPainterPath()
path1.moveTo(pt10[0],pt10[1])
path1.lineTo(pt10[0]+dp21[0],pt10[1]+dp21[1])
path1.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1])
path1.lineTo(pt10[0],pt10[1])

path2=QPainterPath()
path2.moveTo(pt20[0],pt20[1])
path2.lineTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])
path2.lineTo(pt20[0],pt20[1])

qp.drawPath(path1)
qp.drawPath(path2)
qp.drawLine(pt1[0],pt1[1],pt10[0],pt10[1])
qp.drawLine(pt2[0],pt2[1],pt20[0],pt20[1])


dx=d*np.cos(np.deg2rad(theta-90))
dy=-d*np.sin(np.deg2rad(theta-90))
pt0=[0,0]
pt0[0]=(pt10[0]+pt20[0])/2+dx
pt0[1]=(pt10[1]+pt20[1])/2+dy
qp.drawText(pt0[0]-50,pt0[1]-50,100,100,Qt.AlignHCenter|Qt.AlignVCenter,text)


qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])

qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#517, 2:
直线
## end
#520, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#521, 14:
+[返回目录]
+[内容]

## end
#522, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#524, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#528, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#529, 96:
"""
+[返回目录](,去掉选中框)

"""

+去掉选中框(,_物体)->+[del](,+去掉选中框)...
->的(_物体,画图)->的(画图,图形)->+[修改内容](图形,画图)
## end
#530, 125:
"""
+[返回目录](,画选中框)

"""

+画选中框(,_物体)->+[del](,+画选中框)...
->的(_物体,画图)->的(画图,图形)->的(画图,选中框)...
->+[修改内容](图形,画图)->+[增加内容](选中框,画图)
## end
#531, 941:
"""
+[返回目录](,按键)
+[修改标题]"按键"(,设置按键)

"""

+按键(,_物体)->在(+按键,_鼠标位置)->+[del](,+按键)...
->的(_物体,类型)->类型"直线"...
->的(_物体,起点)->的(_物体,终点)->的(_物体,线粗细)...
->+[.]"pm"([python],_鼠标位置)->+[.]"pt0"([python],起点)->+[.]"pt1"([python],终点)...
->+[.]"width"([python],线粗细)->+按键位置->[python]"
pt=pt0
pt1=pt1
pm=pm
width=width[0]
R=6

X=[pt[0],pt1[0]]
Y=[pt[1],pt1[1]]

got=False
for i in range(len(X)):
    d=np.sqrt((X[i]-pm[0])**2+(Y[i]-pm[1])**2)
    if d<=R:
        got=True
        break

if got==False:
    ans='里面'
elif i==0:
    ans='起点'
else:
    ans='终点'

state=True
"(Python,+按键位置)...
->是([动作库],动作#0)->和(动作#0,画图动作)->的(画图动作,mouseMove#0)...
->的(_物体,动作)...
->[]{
	[==]"里面"(,+按键位置)->的(动作,移动)->的(移动,mouseMove)...
	->+[修改内容](mouseMove,mouseMove#0)
}:->[],->>[]{
	[==]"起点"(,+按键位置)->的(动作,移动起点)->的(移动起点,mouseMove)...
	->+[修改内容](mouseMove,mouseMove#0)
}:->[],->>[]{
	[==]"终点"(,+按键位置)->的(动作,移动终点)->的(移动终点,mouseMove)...
	->+[修改内容](mouseMove,mouseMove#0)
}:->[],->>[]
## end
#535, 40:
+[返回目录](,动词)


画选中框:...
去掉选中框:...
按键:...
## end
#536, 376:
"""
+[返回目录](,mouseMove)
+[复制](,mouseMove)

"""
+mouseMove(_画板,)->+[del](,+mouseMove)...
->的(_画板,m_select)->的(m_select,_物体)->的(_物体,类型)->类型"直线"...
->的(_物体,起点)->的(_物体,终点)->的(_画板,m_mouse)...
->+[python]"
dx=pt2[0]-pt1[0]
dy=pt2[1]-pt1[1]
pt1=[m[0]-dx/2,m[1]-dy/2]
pt2=[m[0]+dx/2,m[1]+dy/2]

"(Python,)->+[.]"m"(+[python],m_mouse)->+[o]"pt1"(+[python],起点)->+[o]"pt2"(+[python],终点)

## end
#538, 46:
+[返回目录](,移动)

mouseMove:...
+[del](,mouseMove)
## end
#539, 239:
"""
+[返回目录](,mouseMove)

"""
+mouseMove(_画板,)->+[del](,+mouseMove)...
->的(_画板,m_select)->的(m_select,_物体)->的(_物体,类型)->类型"矩形"...
->的(_物体,起点)->的(_画板,m_mouse)...
->+[python]"
pt=m
"(Python,)->+[.]"m"(+[python],m_mouse)->+[o]"pt"(+[python],起点)

## end
#540, 259:
"""
+[返回目录](,mouseMove)
+[复制](,mouseMove)

"""
+mouseMove(_画板,)->+[del](,+mouseMove)...
->的(_画板,m_select)->的(m_select,_物体)->的(_物体,类型)->类型"直线"...
->的(_物体,起点)->的(_画板,m_mouse)...
->+[python]"
pt1=m

"(Python,)->+[.]"m"(+[python],m_mouse)->+[o]"pt1"(+[python],起点)
## end
#542, 29:
+[返回目录](,移动起点)

mouseMove:...
## end
#543, 259:
"""
+[返回目录](,mouseMove)
+[复制](,mouseMove)

"""
+mouseMove(_画板,)->+[del](,+mouseMove)...
->的(_画板,m_select)->的(m_select,_物体)->的(_物体,类型)->类型"直线"...
->的(_物体,终点)->的(_画板,m_mouse)...
->+[python]"
pt2=m

"(Python,)->+[.]"m"(+[python],m_mouse)->+[o]"pt2"(+[python],终点)
## end
#545, 29:
+[返回目录](,移动终点)

mouseMove:...
## end
#550, 72:
+[返回目录](,动作)

移动:...
移动起点:...
移动终点:...

+[粘贴](,移动终点)
+[修改内容](移动,移动终点)



## end
#565, 272:
+[返回目录](,长度)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1
文字::10 cm
位移距离::20

画图:...
选中区域:...

动词:...
动作:...
的(动词,去掉选中框)->+[做](,直线)->+[code](+[做],去掉选中框)

+[创建输入](线颜色,画图)...
->+[创建输入](线型,画图)->+[创建输入](线粗细,画图)
+[创建输入](文字,画图)->+[创建输入](位移距离,画图)

+[粘贴](,直线)
## end
#566, 401:
"""
+[返回目录](,mouseMove)
+[复制](,mouseMove)

"""
+mouseMove(_画板,)->+[del](,+mouseMove)...
->的(_画板,m_select)->的(m_select,_物体)->的(_物体,类型)->类型"圆形"...
->的(_物体,中心)->的(_物体,角度)->的(_画板,m_mouse)...
->+[python]"
dx=pt[0]-m[0]
dy=pt[1]-m[1]
r=np.sqrt(dx**2+dy**2)
theta=np.sign(dy)*np.arccos(-dx/r)
angle=np.rad2deg(theta)

"(Python,)->+[.]"m"(+[python],m_mouse)->+[o]"pt"(+[python],中心)->+[o]"angle"(+[python],角度)

## end
#568, 46:
+[返回目录](,旋转)

mouseMove:...
+[del](,mouseMove)
## end
#569, 338:
"""
+[返回目录](,mouseMove)
+[复制](,mouseMove)

"""
+mouseMove(_画板,)->+[del](,+mouseMove)...
->的(_画板,m_select)->的(m_select,_物体)->的(_物体,类型)->类型"圆形"...
->的(_物体,中心)->的(_物体,半径)->的(_画板,m_mouse)...
->+[python]"
dx=pt[0]-m[0]
dy=pt[1]-m[1]
r=np.sqrt(dx**2+dy**2)

"(Python,)->+[.]"m"(+[python],m_mouse)->+[o]"pt"(+[python],中心)->+[o]"r"(+[python],半径)

## end
#571, 46:
+[返回目录](,缩放)

mouseMove:...
+[del](,mouseMove)
## end
#572, 258:
"""
+[返回目录](,mouseMove)
+[复制](,mouseMove)

"""
+mouseMove(_画板,)->+[del](,+mouseMove)...
->的(_画板,m_select)->的(m_select,_物体)->的(_物体,类型)->类型"圆形"...
->的(_物体,中心)->的(_画板,m_mouse)...
->+[python]"
pt=m

"(Python,)->+[.]"m"(+[python],m_mouse)->+[o]"pt"(+[python],中心)

## end
#574, 46:
+[返回目录](,移动)

mouseMove:...
+[del](,mouseMove)
## end
#578, 61:
+[返回目录](,动作)

移动:...
缩放:...
旋转:...

+[粘贴](,旋转)
+[修改内容](移动,旋转)
## end
#579, 986:
"""
+[返回目录](,按键)
+[修改标题]"按键"(,设置按键)

"""

+按键(,_物体)->在(+按键,_鼠标位置)->+[del](,+按键)...
->的(_物体,类型)->类型"圆形"...
->的(_物体,中心)->的(_物体,半径)->的(_物体,角度)...
->+[.]"pm"([python],_鼠标位置)->+[.]"pt"([python],中心)->+[.]"r"([python],半径)...
->+[.]"angle"([python],角度)->+按键位置->[python]"
pt=pt
r=r[0]
pm=pm
angle=angle[0]
theta=np.deg2rad(angle)
R=6

X=[pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1]-r*np.sin(theta),pt[1]]

got=False
for i in range(len(X)):
    d=np.sqrt((X[i]-pm[0])**2+(Y[i]-pm[1])**2)
    if d<=R:
        got=True
        break

if got==False:
    ans='里面'
elif i==0:
    ans='角度点'
else:
    ans='半径点'

state=True
"(Python,+按键位置)...
->是([动作库],动作#0)->和(动作#0,画图动作)->的(画图动作,mouseMove#0)...
->的(_物体,动作)...
->[]{
	[==]"里面"(,+按键位置)->的(动作,移动)->的(移动,mouseMove)...
	->+[修改内容](mouseMove,mouseMove#0)
}:->[],->>[]{
	[==]"角度点"(,+按键位置)->的(动作,旋转)->的(旋转,mouseMove)...
	->+[修改内容](mouseMove,mouseMove#0)
}:->[],->>[]{
	[==]"半径点"(,+按键位置)->的(动作,缩放)->的(缩放,mouseMove)...
	->+[修改内容](mouseMove,mouseMove#0)
}:->[],->>[]
## end
#580, 125:
"""
+[返回目录](,画选中框)

"""

+画选中框(,_物体)->+[del](,+画选中框)...
->的(_物体,画图)->的(画图,图形)->的(画图,选中框)...
->+[修改内容](图形,画图)->+[增加内容](选中框,画图)
## end
#581, 96:
"""
+[返回目录](,去掉选中框)

"""

+去掉选中框(,_物体)->+[del](,+去掉选中框)...
->的(_物体,画图)->的(画图,图形)->+[修改内容](图形,画图)
## end
#585, 40:
+[返回目录](,动词)


画选中框:...
去掉选中框:...
按键:...
## end
#586, 1:
2
## end
#587, 8:
DashLine
## end
#588, 5:
0,0,0
## end
#589, 11:
255,255,255
## end
#590, 18:
48.373546489791295
## end
#591, 11:
-339.0, 0.0
## end
#594, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#595, 14:
+[返回目录]
+[内容]

## end
#598, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#599, 19:
-117.32389130134653
## end
#600, 2:
圆形
## end
#601, 660:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


x0=pt[0]
y0=pt[1]
M=qp.transform()
M.translate(x0,y0)
M.rotate(-angle+90)
M.translate(-x0,-y0)

M0=qp.transform()
qp.setTransform(M)

qp.drawRect(x0-r,y0,2*r,d)

qp.setTransform(M0)
qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#602, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#604, 2:
10
## end
#613, 73:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10

## end
#618, 660:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


x0=pt[0]
y0=pt[1]
M=qp.transform()
M.translate(x0,y0)
M.rotate(-angle+90)
M.translate(-x0,-y0)

M0=qp.transform()
qp.setTransform(M)

qp.drawRect(x0-r,y0,2*r,d)

qp.setTransform(M0)
qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#634, 273:
+[返回目录](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...

动词:...
动作:...
的(动词,画选中框)->+[做](,圆形)->+[code](+[做],画选中框)

+[创建输入](厚度,画图)
+[创建输入](面颜色,画图)->+[创建输入](线颜色,画图)...
->+[创建输入](线型,画图)->+[创建输入](线粗细,画图)

+[粘贴](,圆形)
## end
#639, 99:
+[返回目录](,样本库)
+[设置结构](,样本库)

长度:...
镜子:...
+[创建圆形](,镜子)
主光路::
+[复制结构](,镜子)

测试图形:...
+[创建镜子](,测试图形)
## end
#640, 54:
+[增加光路](_光路,_光线)->+[在](+[增加光路],_点)
or
+[增加光路](_光路,_光线)
## end
#642, 588:
"""
+[返回目录](,增加光路)
例子::+[增加光路](_光路,_光线)->+[在](+[增加光路],_点)
or
+[增加光路](_光路,_光线)

"""

+增加光路(_光路,光线)->在(+增加光路,_点)->的(光线,起点)...
->+[del](,+增加光路)...
->的(_光路,_点)->_点{[]=>的(_点,类型)->类型"直线"}...
->+[左连](光线,_点)->+[右连](光线,+i)->+[有](_光路,光线)->+[有](_光路,+i)...
->[]{
	的(_光路,光线#0)->光线#0(,_点)->的(光线#0,终点)->+是(终点,起点)
}:->[],->>[];


+增加光路(_光路,光线)->的(光线,起点)...
->+[del](,+增加光路)...
->的(_光路,_点)->_点&{
	[]=>的(_点,类型)->类型"直线",
	[]=>的(_光路,光线#1)->光线#1(_点,),
	的(_光路,光线#2)->光线#2(,_点)
}...
->+[左连](光线,_点)->+[右连](光线,+i)->+[有](_光路,光线)->+[有](_光路,+i)...
->[]{
	的(_光路,光线#0)->光线#0(,_点)->的(光线#0,终点)->+是(终点,起点)
}:->[],->>[];


## end
#643, 899:
"""
+[返回目录](,显示光路)

"""

+显示光路(matlab,_主光路)->+[del](,+显示光路)...
->+[matlab]"pt0=[nan,nan];hold on; axis equal;"(Matlab,)->_主光路(,)...
->[]{
    []=>经过(_主光路,_元件)->_元件->在(_元件,空间点)...
    =>+[标题](_元件,)->+[matlab]"plot([pt0(1),pt(1)],[pt0(2),pt(2)],'b-'); pt0=pt; text(pt0(1),pt0(2),name)"(Matlab,)...
    ->+[.]"pt"(+[matlab],空间点)->+[s]"name"(+[matlab],+[标题])
}...
->[]{
    []:->的(_主光路,输入)->在(输入,空间点#1)...
        ->+[matlab]"plot([pt0(1),pt(1)],[pt0(2),pt(2)],'b-');pt0=pt;text(pt0(1),pt0(2),name)"(Matlab,)...
        ->+[.]"pt"(+[matlab],空间点#1),
        ->分出来(,_主光路)->从(分出来,经过)->经过(,_元件)->在(_元件,空间点#2)...
        ->+[matlab]"plot([pt0(1),pt(1)],[pt0(2),pt(2)],'b-');pt0=pt;text(pt0(1),pt0(2),name)"(Matlab,)...
        ->+[.]"pt"(+[matlab],空间点#2),
        ->[]
};

+显示光路(,_光路)->+[del](,+显示光路)...
->+[临时文本](,)...
->[]{
	[]=>的(_光路,_A)=>+[显示关联](_A,+[增加内容])->+[增加内容](,+[临时文本])
}->+[修改内容](+[临时文本],+[显示]);

## end
#644, 113:
"""
+[返回目录](,删除光路)

"""

+删除光路(,_光路)->+[del](,+删除光路)...
->+[删除结构](,_光路)...
->[]{创建(,_光路)->+[del](,创建)}:->[],->>[]
## end
#645, 16:
+[返回目录](,按键动作)


## end
#648, 56:
+[返回目录](,作用按键)

mousePress:...
+[显示](,mousePress)
Q:...

## end
#653, 260:
"""
+[返回目录](,创建光路)

作用按键:...
按键动作:...
测试::
+[创建光路](,测试)

"""

+创建光路(,_光路)->+[del](,+创建光路)...
->的(创建光路,作用按键)->的(作用按键,mousePress)...
->[]{
	[]{创建(mousePress,)->+[右连](创建,_光路)}:->[],->>+创建(mousePress,_光路)
}->+的(_光路,+0)->+的(_光路,+起点)->+起点(,+0)->+的(_光路,+终点)->+终点(,+0)
## end
#654, 12199:
"""
+[返回目录](,创建长度)

"""


+创建长度#0(,_长度#61)->+[del]#1(,+创建长度#0)...


...............................................
->+[临时文本]#2"+[返回目录](,长度)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1
文字::10 cm
位移距离::20

画图:...
选中区域:...

动词:...
动作:...
的(动词,去掉选中框)->+[做](,直线)->+[code](+[做],去掉选中框)

+[创建输入](线颜色,画图)...
->+[创建输入](线型,画图)->+[创建输入](线粗细,画图)
+[创建输入](文字,画图)->+[创建输入](位移距离,画图)

+[粘贴](,直线)"(,)...
...............................................


->+[修改内容]#3(+[临时文本]#2,_长度#61)->+位移距离#4"30"(,)...


...............................................
->+文字#5"20 cm"(,)...
...............................................





...............................................
->+mouseMove#6"\"\"\"
+[返回目录](,mouseMove)
+[复制](,mouseMove)

\"\"\"
+mouseMove(_画板,)->+[del](,+mouseMove)...
->的(_画板,m_select)->的(m_select,_物体)->的(_物体,类型)->类型\"直线\"...
->的(_物体,终点)->的(_画板,m_mouse)...
->+[python]\"
pt2=m

\"(Python,)->+[.]\"m\"(+[python],m_mouse)->+[o]\"pt2\"(+[python],终点)"(,)...
...............................................





...............................................
->+移动终点#7"+[返回目录](,移动终点)

mouseMove:..."(,)...
...............................................


->+的#8(+移动终点#7,+mouseMove#6)...


...............................................
->+mouseMove#9"\"\"\"
+[返回目录](,mouseMove)
+[复制](,mouseMove)

\"\"\"
+mouseMove(_画板,)->+[del](,+mouseMove)...
->的(_画板,m_select)->的(m_select,_物体)->的(_物体,类型)->类型\"直线\"...
->的(_物体,起点)->的(_画板,m_mouse)...
->+[python]\"
pt1=m

\"(Python,)->+[.]\"m\"(+[python],m_mouse)->+[o]\"pt1\"(+[python],起点)"(,)...
...............................................





...............................................
->+移动起点#10"+[返回目录](,移动起点)

mouseMove:..."(,)...
...............................................


->+的#11(+移动起点#10,+mouseMove#9)...


...............................................
->+mouseMove#12"\"\"\"
+[返回目录](,mouseMove)

\"\"\"
+mouseMove(_画板,)->+[del](,+mouseMove)...
->的(_画板,m_select)->的(m_select,_物体)->的(_物体,类型)->类型\"矩形\"...
->的(_物体,起点)->的(_画板,m_mouse)...
->+[python]\"
pt=m
\"(Python,)->+[.]\"m\"(+[python],m_mouse)->+[o]\"pt\"(+[python],起点)
"(,)...
...............................................





...............................................
->+mouseMove#13"\"\"\"
+[返回目录](,mouseMove)
+[复制](,mouseMove)

\"\"\"
+mouseMove(_画板,)->+[del](,+mouseMove)...
->的(_画板,m_select)->的(m_select,_物体)->的(_物体,类型)->类型\"直线\"...
->的(_物体,起点)->的(_物体,终点)->的(_画板,m_mouse)...
->+[python]\"
dx=pt2[0]-pt1[0]
dy=pt2[1]-pt1[1]
pt1=[m[0]-dx/2,m[1]-dy/2]
pt2=[m[0]+dx/2,m[1]+dy/2]

\"(Python,)->+[.]\"m\"(+[python],m_mouse)->+[o]\"pt1\"(+[python],起点)->+[o]\"pt2\"(+[python],终点)
"(,)...
...............................................





...............................................
->+移动#14"+[返回目录](,移动)

mouseMove:...
+[del](,mouseMove)"(,)...
...............................................


->+的#15(+移动#14,+mouseMove#13)...


...............................................
->+动作#16"+[返回目录](,动作)

移动:...
移动起点:...
移动终点:...

+[粘贴](,移动终点)
+[修改内容](移动,移动终点)


"(,)...
...............................................


->+的#17(+动作#16,+移动终点#7)->+的#18(+动作#16,+移动起点#10)->+的#19(+动作#16,+mouseMove#12)->+的#20(+动作#16,+移动#14)...


...............................................
->+按键#21"\"\"\"
+[返回目录](,按键)
+[修改标题]\"按键\"(,设置按键)

\"\"\"

+按键(,_物体)->在(+按键,_鼠标位置)->+[del](,+按键)...
->的(_物体,类型)->类型\"直线\"...
->的(_物体,起点)->的(_物体,终点)->的(_物体,线粗细)...
->+[.]\"pm\"([python],_鼠标位置)->+[.]\"pt0\"([python],起点)->+[.]\"pt1\"([python],终点)...
->+[.]\"width\"([python],线粗细)->+按键位置->[python]\"
pt=pt0
pt1=pt1
pm=pm
width=width[0]
R=6

X=[pt[0],pt1[0]]
Y=[pt[1],pt1[1]]

got=False
for i in range(len(X)):
    d=np.sqrt((X[i]-pm[0])**2+(Y[i]-pm[1])**2)
    if d<=R:
        got=True
        break

if got==False:
    ans='里面'
elif i==0:
    ans='起点'
else:
    ans='终点'

state=True
\"(Python,+按键位置)...
->是([动作库],动作#0)->和(动作#0,画图动作)->的(画图动作,mouseMove#0)...
->的(_物体,动作)...
->[]{
	[==]\"里面\"(,+按键位置)->的(动作,移动)->的(移动,mouseMove)...
	->+[修改内容](mouseMove,mouseMove#0)
}:->[],->>[]{
	[==]\"起点\"(,+按键位置)->的(动作,移动起点)->的(移动起点,mouseMove)...
	->+[修改内容](mouseMove,mouseMove#0)
}:->[],->>[]{
	[==]\"终点\"(,+按键位置)->的(动作,移动终点)->的(移动终点,mouseMove)...
	->+[修改内容](mouseMove,mouseMove#0)
}:->[],->>[]"(,)...
...............................................





...............................................
->+画选中框#22"\"\"\"
+[返回目录](,画选中框)

\"\"\"

+画选中框(,_物体)->+[del](,+画选中框)...
->的(_物体,画图)->的(画图,图形)->的(画图,选中框)...
->+[修改内容](图形,画图)->+[增加内容](选中框,画图)"(,)...
...............................................





...............................................
->+去掉选中框#23"\"\"\"
+[返回目录](,去掉选中框)

\"\"\"

+去掉选中框(,_物体)->+[del](,+去掉选中框)...
->的(_物体,画图)->的(画图,图形)->+[修改内容](图形,画图)"(,)...
...............................................





...............................................
->+动词#24"+[返回目录](,动词)


画选中框:...
去掉选中框:...
按键:..."(,)...
...............................................


->+的#25(+动词#24,+按键#21)->+的#26(+动词#24,+画选中框#22)->+的#27(+动词#24,+去掉选中框#23)->+线粗细#28"1"(,)...


...............................................
->+线型#29"DashLine"(,)...
...............................................





...............................................
->+线颜色#30"0,0,0"(,)...
...............................................





...............................................
->+LaTeX数学记号#31"https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols"(,)...
...............................................





...............................................
->+点线公式#32"<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type=\"text/javascript\" src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"></script>
  </head>
  <body>
    <p><mathjax style=\"font-size:1.5em\">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>
"(,)...
...............................................


->+的#33(+点线公式#32,+LaTeX数学记号#31)...


...............................................
->+输出#34"+[返回目录]
+[内容]
"(,)...
...............................................





...............................................
->+终点#35"270.5, 38.5"(,)...
...............................................





...............................................
->+起点#36"-98.5, 83.5"(,)...
...............................................





...............................................
->+输入#37"+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0
"(,)...
...............................................


->+的#38(+输入#37,+终点#35)->+的#39(+输入#37,+起点#36)...


...............................................
->+选中区域#40"\"\"\"
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

\"\"\"

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False
"(,)...
...............................................


->+的#41(+选中区域#40,+点线公式#32)->+的#42(+选中区域#40,+输出#34)->+的#43(+选中区域#40,+输入#37)->+类型#44"直线"(,)...


...............................................
->+选中框#45"\"\"\"
+[返回目录](,选中框)

\"\"\"
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))"(,)...
...............................................





...............................................
->+图形#46"\"\"\"
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

\"\"\"
pt1=起点
pt2=终点

angle=30
l=20
D=位移距离[0]
d=10
text=文字


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush(QColor(edgeColor[0],edgeColor[1],edgeColor[2])))

r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
if r!=0:
    theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]

Dx=D*np.cos(np.deg2rad(theta-90))
Dy=-D*np.sin(np.deg2rad(theta-90))
pt10=[0,0]
pt20=[0,0]
pt10[0]=pt1[0]+Dx
pt10[1]=pt1[1]+Dy
pt20[0]=pt2[0]+Dx
pt20[1]=pt2[1]+Dy

path1=QPainterPath()
path1.moveTo(pt10[0],pt10[1])
path1.lineTo(pt10[0]+dp21[0],pt10[1]+dp21[1])
path1.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1])
path1.lineTo(pt10[0],pt10[1])

path2=QPainterPath()
path2.moveTo(pt20[0],pt20[1])
path2.lineTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])
path2.lineTo(pt20[0],pt20[1])

qp.drawPath(path1)
qp.drawPath(path2)
qp.drawLine(pt1[0],pt1[1],pt10[0],pt10[1])
qp.drawLine(pt2[0],pt2[1],pt20[0],pt20[1])


dx=d*np.cos(np.deg2rad(theta-90))
dy=-d*np.sin(np.deg2rad(theta-90))
pt0=[0,0]
pt0[0]=(pt10[0]+pt20[0])/2+dx
pt0[1]=(pt10[1]+pt20[1])/2+dy
qp.drawText(pt0[0]-50,pt0[1]-50,100,100,Qt.AlignHCenter|Qt.AlignVCenter,text)


qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])

qp.setBrush(QBrush())
qp.setPen(QPen())


"(,)...
...............................................


->+输出#47(,)...


...............................................
->+输入#48"线颜色::0,0,0
线型::DashLine
线粗细::2
文字::10 cm
位移距离::20
"(,)...
...............................................


->+的#49(+输入#48,+位移距离#4)->+的#50(+输入#48,+文字#5)->+的#51(+输入#48,+线粗细#28)->+的#52(+输入#48,+线型#29)->+的#53(+输入#48,+线颜色#30)->+的#54(+输入#48,+终点#35)->+的#55(+输入#48,+起点#36)...


...............................................
->+画图#56"\"\"\"
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

\"\"\"
pt1=起点
pt2=终点

angle=30
l=20
D=位移距离[0]
d=10
text=文字


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush(QColor(edgeColor[0],edgeColor[1],edgeColor[2])))

r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
if r!=0:
    theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]

Dx=D*np.cos(np.deg2rad(theta-90))
Dy=-D*np.sin(np.deg2rad(theta-90))
pt10=[0,0]
pt20=[0,0]
pt10[0]=pt1[0]+Dx
pt10[1]=pt1[1]+Dy
pt20[0]=pt2[0]+Dx
pt20[1]=pt2[1]+Dy

path1=QPainterPath()
path1.moveTo(pt10[0],pt10[1])
path1.lineTo(pt10[0]+dp21[0],pt10[1]+dp21[1])
path1.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1])
path1.lineTo(pt10[0],pt10[1])

path2=QPainterPath()
path2.moveTo(pt20[0],pt20[1])
path2.lineTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])
path2.lineTo(pt20[0],pt20[1])

qp.drawPath(path1)
qp.drawPath(path2)
qp.drawLine(pt1[0],pt1[1],pt10[0],pt10[1])
qp.drawLine(pt2[0],pt2[1],pt20[0],pt20[1])


dx=d*np.cos(np.deg2rad(theta-90))
dy=-d*np.sin(np.deg2rad(theta-90))
pt0=[0,0]
pt0[0]=(pt10[0]+pt20[0])/2+dx
pt0[1]=(pt10[1]+pt20[1])/2+dy
qp.drawText(pt0[0]-50,pt0[1]-50,100,100,Qt.AlignHCenter|Qt.AlignVCenter,text)


qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])

qp.setBrush(QBrush())
qp.setPen(QPen())


"(,)...
...............................................


->+的#57(+画图#56,+选中框#45)->+的#58(+画图#56,+图形#46)->+的#59(+画图#56,+输出#47)->+的#60(+画图#56,+输入#48)->_长度#61(,)->+的#62(_长度#61,+位移距离#4)->+的#63(_长度#61,+文字#5)->+的#64(_长度#61,+动作#16)->+的#65(_长度#61,+动词#24)->+的#66(_长度#61,+画选中框#22)->+的#67(_长度#61,+去掉选中框#23)->+的#68(_长度#61,+线粗细#28)->+的#69(_长度#61,+线型#29)->+的#70(_长度#61,+线颜色#30)->+的#71(_长度#61,+选中区域#40)->+的#72(_长度#61,+类型#44)->+的#73(_长度#61,+画图#56)->+的#74(_长度#61,+终点#35)->+的#75(_长度#61,+起点#36)
## end
#655, 314:
"""
+[返回目录](,标记距离)


"""

+标记距离(,_长度)->+[del](,+标记距离)...
->_长度(_矩形1,_矩形2)->_矩形1->_矩形2(,)...
->的(_矩形1,类型#1)->类型#1"矩形"->的(_矩形2,类型#2)->类型#2"矩形"...
->+[创建长度](,_长度)...
->+[做]"
+做(,_长度)->_长度(_矩形1,_矩形2)->_矩形1->_矩形2->+[del](,+做)...
->的(_矩形1,起点#1)->的(_长度,起点)->+是(起点#1,起点)...
->的(_矩形2,起点#2)->的(_长度,终点)->+是(起点#2,终点)
"(,_长度)


## end
#662, 524:
+[返回目录](,光路图动词)

创建长度:...
标记距离:...
创建光路:...
删除光路:...
显示光路:...
显示路线:...

+[粘贴](,光路图动词)
逻辑结构转光路:...
逻辑结构转光线显示:...
逻辑结构转光线追踪:...
逻辑结构转3D场景:...
场景结构转路线结构:...
+[复制结构](,逻辑结构转3D场景)->+[粘贴](,光路图动词)
+[修改标题]"场景结构转路线结构"(,逻辑结构转3D场景)

自动调整镜子方向:...

三维光栅:...
+[新建阅读窗口](,三维光栅)
三维柱面镜:...
三维反射镜:...
三维透镜:...

反射:...
反射代码:...
+[修改标题]"反射代码"(,反射)
+[复制结构](,反射)->+[粘贴](,光路图动词)

相对:...
对齐X:...
对齐Y:...
+[复制结构](,相对)

自动命名:...
设置位置:...
经过元件:...



(不更新光路的终点信息)
增加光路:...

放置反射镜:...
系列命名:...
选择:...
撤销:...
计算:...

插入:...


是([动词库],动词)->+[打开文件](+新窗口,动词)
## end
#663, 12:
文档\iFAST.txt
## end
#673, 714:
+[返回目录](,光路图工具)
地址::文档\S应用\绘制光路图.ftxt

画图工具::文档\S应用\画图工具.ftxt
+[打开文件](+新窗口,画图工具)
外部样本库::文档\S应用\画图样本库.ftxt
+[打开文件](+新窗口,外部样本库)

先做一个标记长度的工具. 用直线做. 

光路图动词:...
光路图动作:...
光路图名词:...
+[设置动词](,光路图动词)
+[设置动作](,光路图动作)
+[设置名词](,光路图名词)
的(光路图动词,创建光路)->的(光路图动作,Q)->的(创建光路,作用按键)...
->+[有](作用按键,Q)

场景模板:...
模板集合:...


(创建光路,mousePress)->+[del](,作用按键)

样本库:...
+[画板](+光路图样本,样本库)
的(样本库,长度)->的(光路图动词,创建长度)->+[生成动词](长度,创建长度)

测试场景:...
+[画板](+光路图,测试场景)
光路::
+[创建光路](,光路)
+[删除光路](,光路)
+[显示光路](,光路)


FOPA设计::文档\设计文档\FOPA设计_光路设计1.ftxt
+[打开文件](+新窗口,FOPA设计)
TOPAS光路::文档\设计文档\TOPAS光路.ftxt
+[打开文件](+新窗口,TOPAS光路)


然后是画光线. 
我希望是按一个点画一条线的那种. 但是, 希望可以自动给每一个点命名. 
自动命名的问题也不大, 那么主要是连续画线有问题. 
好了, 下午了. 


iFAST::文档\iFAST.txt
+[打开文件](+新窗口,iFAST)
## end
#674, 104:
光路图工具:...
创建于 20210415

节点数目统计::
+[设置结构](,节点数目统计)


目录->的(_日记,目录)->的#2(目录,节点数目统计)...
->+[置顶](_日记,的#2)



## end
#676, 1:
1
## end
#678, 8:
958, 476
## end
#680, 8:
0.0, 0.0
## end
#687, 25:
文档\设计文档\FOPA设计_光路设计1.ftxt
## end
#690, 4:
1007
## end
#693, 435:
"""
+[返回目录](,放置反射镜)

示例::在 光路图 中的 Booster_pump上, 放置反射镜. 
+[放置反射镜]->+[在](+[放置反射镜],光路图)->+[中](+[在],Booster_pump)...
->+[收集](+[放置反射镜],测试)

系列动作(S代码):...

"""

+放置反射镜->+[del](,+放置反射镜)...
->在(+放置反射镜,_场景)->中(在,_光路)...
->的(放置反射镜,系列动作)...
->[当前编辑器](_场景,)->是([当前编辑器],_编辑器)...
->+[修改内容](系列动作,+[系列动作])...
->+[S函数](_编辑器,+[系列动作])->+[范围](+[S函数],+[系列动作])...
->+[光路](+[系列动作],_光路)->+[场景](+[系列动作],_场景):
    ->收集(+放置反射镜,_组)->+[收集](+[系列动作],_组),
    ->[]


## end
#695, 383:
"""
+[返回目录](,系列动作)

"""

系列动作->光路(系列动作,_光路)->场景(系列动作,_场景)...
=>的(_光路,光线)->光线(_i,_j){_i->_j->光线#2(_j,)}...
=>+的(_场景,+镜子)->+[创建镜子](,+镜子)...
->+的(_场景,+反射)->+反射(+镜子,光线)->+[创建反射](,+反射); 

[]=>镜子(,)...
=>的(镜子,半径)->+[修改内容]"5"(,半径)...
->的(镜子,厚度)->+[修改内容]"5"(,厚度);

[]=>反射(,)...
=>的(反射,P代码)->+[P函数](,P代码);

收集(系列动作,_组)->_组&:
    ->+的(_组,+元件)=>镜子=>+的(+元件,镜子),
    ->+的(_组,+规律)=>反射=>+的(+规律,反射)

## end
#783, 4:
2233
## end
#784, 4:
2233
## end
#785, 4:
2233
## end
#786, 4:
2233
## end
#787, 4:
2233
## end
#788, 4:
2233
## end
#789, 4:
2233
## end
#790, 4:
2233
## end
#791, 4:
2233
## end
#792, 4:
2233
## end
#793, 4:
2233
## end
#794, 4:
2233
## end
#795, 4:
2233
## end
#796, 4:
2233
## end
#797, 4:
2233
## end
#798, 4:
2233
## end
#799, 4:
2233
## end
#800, 4:
2233
## end
#1006, 109:
在 光路图 中的 Booster_pump上, 放置反射镜. 
+[放置反射镜]->+[在](+[放置反射镜],光路图)->+[中](+[在],Booster_pump)...
->+[收集](+[放置反射镜],测试)
## end
#1007, 4:
1043
## end
#1010, 20:
文档\设计文档\TOPAS光路.ftxt
## end
#1012, 321:
"""
+[返回目录](,系列命名)

操作序列(S代码):...

"""

+系列命名->+[del](,+系列命名)...
->按照(+系列命名,_系列)->对(+系列命名,_元件组)...
->的(系列命名,操作序列)...
->[当前编辑器](_元件组,)->是([当前编辑器],_编辑器)...
->+[修改内容](操作序列,+[操作序列])...
->+[S函数](_编辑器,+[操作序列])->+[范围](+[S函数],+[操作序列])...
->+[系列](+[操作序列],_系列)->+[元件组](+[操作序列],_元件组):
    ->从(按照,_序号)->+[序号](+[操作序列],_序号),
    ->[]


## end
#1014, 558:
"""
+[返回目录](,操作序列)

示例::对所有(TOPAS_2nd_元件), 按照(+[系列]"M")从(+[序号]"1")做(+[系列命名]). 
的(TOPAS_2nd_元件,元件)...
->+[系列命名]->+[按照](+[系列命名],+[系列])->+[系列]"M"->+[对](+[系列命名],元件)...
->+[从](+[按照],+[序号])->+[序号]"30"


"""

系列(操作序列,_系列)->元件组(操作序列,_元件组)...
->Python->[]{
    []:->序号(操作序列,_序号)->+[python]"i=int(n[0])-1"(Python,)->+[.]"n"(+[python],_序号),
    ->+[python]"i=0"(Python,)
}=>的(_元件组,_)->的(_,名字)...

=>+[名字]->[m_text](_系列,+[名字])...
->+[python]"i+=1
ans=str(i)"(Python,+[增加内容])->+[增加内容](,+[名字])...
->+[修改内容](+[名字],名字)...
->+[修改内容](+[名字],+[修改标题])->+[修改标题](,_)->+[显示](,名字)



## end
#1017, 170:
对所有(TOPAS_2nd_元件), 按照(+[系列]"M")从(+[序号]"1")做(+[系列命名]). 
的(TOPAS_2nd_元件,元件)...
->+[系列命名]->+[按照](+[系列命名],+[系列])->+[系列]"M"->+[对](+[系列命名],元件)...
->+[从](+[按照],+[序号])->+[序号]"30"
## end
#1019, 174:
+[返回目录](,光路图名词)
+[设置结构](,光路图名词)
+[粘贴](,光路图名词)

物体:...
后面:...
紧接着:...

条:...
最后:...

输入:...
(需要解决删除引用链节的问题)
反射:...

方向:...
位置:...
起点:...
终点:...


是([名词库],名词)->+[打开文件](+新窗口,名词)
## end
#1020, 34:
反射(M8,光线)->[后面](光线,)->的([后面],光线#0)
## end
#1022, 162:
"""
+[返回目录](,后面)
例子::反射(M8,光线)->[后面](光线,)->的([后面],光线#0)

"""

+后面(光线,)->[紧接着](光线,)->的([紧接着],光线#1):
	->+的(+后面,光线#1),
	->[后面](光线#1,)->的([后面],光线#2)->+的(+后面,光线#2);



## end
#1024, 88:
"""
+[返回目录](,紧接着)

"""

+紧接着(光线,)->的(光线,终点)->是(终点,起点#1)->的(光线#1,起点#1)...
->+的(+紧接着,光线#1)
## end
#1027, 302:
"""
+[返回目录](,选择)

操作序列(S代码):...

"""

+选择(,光线)->+[del](,+选择)...
->从(+选择,_元件1)->到(从,_元件2)->的(+选择,_选中组)...
->的(选择,操作序列)...
->[当前编辑器](_元件1,)->是([当前编辑器],_编辑器)...
->+[修改内容](操作序列,+[操作序列])...
->+[S函数](_编辑器,+[操作序列])->+[范围](+[S函数],+[操作序列])...
->+[从](+[操作序列],_元件1)->+[到](+[操作序列],_元件2)...
->+[保存到](+[操作序列],_选中组)


## end
#1029, 242:
"""


"""

从(操作序列,_元件1)->到(操作序列,_元件2)->保存到(操作序列,_组)...
->反射(_元件1,光线#0)->反射(_元件2,光线#1)->[后面](光线#0,)->的([后面],光线#1)...
->+的(_组,光线#0)=>的(_组,光线)->紧接着(光线,)->的(紧接着,光线#2)...
=>+的(_组,光线#2);

保存到(操作序列,_组)...
->_组=>的(_组,光线)->的(光线,线粗细)=>+[修改内容]"4"(,线粗细)

## end
#1031, 4:
1055
## end
#1034, 242:
"""
+[返回目录](,撤销)

操作序列(S代码):...

"""

+撤销(,选择)->+[del](,+撤销)...
->选择(,光线)->的(选择,_选中组)...
->的(撤销,操作序列)...
->[当前编辑器](_选中组,)->是([当前编辑器],_编辑器)...
->+[修改内容](操作序列,+[操作序列])...
->+[S函数](_编辑器,+[操作序列])->+[范围](+[S函数],+[操作序列])...
->+[组](+[操作序列],_选中组)




## end
#1036, 95:
"""
+[返回目录](,操作序列)

"""

组(操作序列,_组)...
=>的#0(_组,光线)->的(光线,线粗细)=>+[修改内容]"1"(,线粗细)->+[del](,的#0)

## end
#1039, 266:
"""
+[返回目录](,计算)

操作序列(S代码):...

"""

+计算(,总长度)->+[del](,+计算)...
->总长度(_选中组,)->到(+计算,_光程)...
->的(计算,操作序列)...
->[当前编辑器](_选中组,)->是([当前编辑器],_编辑器)...
->+[修改内容](操作序列,+[操作序列])...
->+[S函数](_编辑器,+[操作序列])->+[范围](+[S函数],+[操作序列])...
->+[组](+[操作序列],_选中组)->+[结果](+[操作序列],_光程)




## end
#1041, 293:
"""
+[返回目录](,操作序列)

"""

组(操作序列,_选中组)->结果(操作序列,_光程)...
->+[python]"L=0"(Python,)->[]{
	[]=>的(_选中组,光线)->光线->的(光线,起点)->的(光线,终点)...
	=>+[python]"L+=np.sqrt((pt0[0]-pt1[0])**2+(pt0[1]-pt1[1])**2)/10"(Python,)...
	->+[.]"pt0"(+[python],起点)->+[.]"pt1"(+[python],终点)
}->+[python]"ans=L"(Python,_光程)


## end
#1043, 4:
1045
## end
#1045, 4:
1057
## end
#1048, 414:
"""
+[返回目录](,条)


"""

+条(_光路,_序号)->[]{
    []:->_序号->+[.]"N"([python]#2,_序号)->[python]#2"state=True"(Python#2,),
    ->+[.]"N"([python]#1,+条)->[python]#1"state=True"(Python#1,)
}->[python]"n=0
#print('???',N,n)
state=True"(Python,)...

=>的(_光路,光线)...

=>[python]"
n+=1
#print('???',N,n)
state=True
"(Python,):
    ->[python]"state=n<N[0]"(Python,), 
    ->[python]"state=(n==N[0])"(Python,)->+的(+条,光线),
    ->[]


## end
#1049, 4:
1080
## end
#1052, 152:
"""
+[返回目录](,最后)
+[修改标题]"最后"(,最后一条)

"""

+最后(_光路,)...

=>的(_光路,光线)=>+mark(+最后,光线)...
->[]{[]->的(_光路,光线#1)=>mark(,光线#1)}:
    ->[],
    ->>+的(+最后,光线)



## end
#1054, 399:
"""
+[返回目录](,插入)

示例::黄光的头部插入光路的第1条光线, 尾部插入光路的第4条光线. 
+[插入](黄光,光路)->+[头部]"1"(+[插入],)->+[尾部]"4"(+[插入],)

操作序列(S代码):...

"""

+插入(_光路1,_光路0)->+[del](,+插入)...
->头部(+插入,)->尾部(+插入,)...
->的(插入,操作序列)...
->[当前编辑器](_光路1,)->是([当前编辑器],_编辑器)...
->+[修改内容](操作序列,+[操作序列])...
->+[S函数](_编辑器,+[操作序列])->+[范围](+[S函数],+[操作序列])...
->+[光路1](+[操作序列],_光路1)->+[光路0](+[操作序列],_光路0)...
->+[头部](+[操作序列],头部)->+[尾部](+[操作序列],尾部)




## end
#1056, 731:
"""
+[返回目录](,操作序列)
+[新建阅读窗口](,操作序列)
->[条]"1"(_光路1,)->的([条],光线#0)->[条]"1"(_光路2,)->的([条],光线#1)...
->的(光线#0,终点)->的(光线#1,起点)->+是(终点,起点);

光路1(操作序列,_光路1)->光路2(操作序列,_光路2)...
->尾部(操作序列,_尾部)...
->[条]"4"(_光路1,)->的([条],光线#0)->[最后](_光路2,)->的([最后],光线#1)...
->的(光线#0,终点)->的(光线#1,终点#1)->+是(终点,终点#1);

->[条](_光路0,_头部)->的([条],光线#0)->+[显示](,光线#0)

"""

光路1(操作序列,_光路1)->光路0(操作序列,_光路0)...
->头部(操作序列,_头部)...
->[条](_光路0,_头部)->的([条],光线#0)->[条]"1"(_光路1,)->的([条],光线#1)...
->的(光线#0,终点)->的(光线#1,起点):
    ->是(,起点)->+[del](,是)->+是(终点,起点),
    ->+是(终点,起点);


光路1(操作序列,_光路1)->光路0(操作序列,_光路0)...
->尾部(操作序列,_尾部)...
->[条](_光路0,_尾部)->的([条],光线#0)->[最后](_光路1,)->的([最后],光线#1)...
->的(光线#0,终点)->的(光线#1,终点#1):
    ->是(,终点#1)->+[del](,是)->+是(终点,终点#1),
    ->+是(终点,终点#1);



## end
#1059, 80:
黄光的头部插入光路的第1条光线, 尾部插入光路的第4条光线. 
+[插入](黄光,光路)->+[头部]"1"(+[插入],)->+[尾部]"4"(+[插入],)
## end
#1060, 1:
1
## end
#1062, 8:
600, 400
## end
#1064, 11:
-100.0, 0.0
## end
#1067, 4:
1069
## end
#1069, 4:
1077
## end
#1071, 4:
1073
## end
#1073, 4:
1075
## end
#1075, 4:
1096
## end
#1078, 4:
1098
## end
#1080, 4:
1100
## end
#1082, 4:
1096
## end
#1084, 4:
1104
## end
#1086, 452:
"""
+[返回目录](,相对)

"""

+相对(_M1,_M2)...
->[物体](_M1,)->在([物体],_位置1)...
->[物体](_M2,)->在([物体],_位置2)...
->+[修改内容](_位置1,_位置2)->Matlab:

->沿着(+相对,)->+[matlab]"pt2=pt1+v*t,v,t,pt1"(Matlab,)...
->+[.]"pt1"(+[matlab],_位置1)->+[.]"v"(+[matlab],沿着)->+[.]"t"(+[matlab],+相对)...
->+[o]"pt2"(+[matlab],_位置2)...
->+[del](,+相对),

->+[matlab]"pt2=pt1+dr;"(Matlab,)...
->+[.]"pt1"(+[matlab],_位置1)->+[.]"dr"(+[matlab],+相对)...
->+[o]"pt2"(+[matlab],_位置2)...
->+[del](,+相对)



## end
#1088, 4:
1108
## end
#1090, 4:
1104
## end
#1092, 4:
1145
## end
#1094, 582:

_光线->光线1(_光线,)->+[创建光线](,_光线);
_光线->光线1(_光线,)->的(_光线,直径)->+[修改内容]"5"(,直径)...
->的(_光线,焦点)->+[修改内容]"100"(,焦点);

+[python]"pt=[0,0]"(Python,);

空间点->位置(空间点,)...
->+[python]"ans=[pt[0]*20,-pt[1]*20]"(Python,+画板位置)->+[.]"pt"(+[python],空间点);

_光线->光线1(_光线,)->画板位置:
    ->输入->的(_光线,起点)->+[修改内容](画板位置,起点),
    ->的(_光线,终点)->+[修改内容](画板位置,终点);
画板位置:
    ->_光线->分光光线(_光线,)->的(_光线,起点#1)->+[修改内容](画板位置,起点#1),
    ->_光路->光路1(_光路,)->新(_光路,光线)->的(光线,起点)->+[修改内容](画板位置,起点);

_光路->光路1(_光路,)->新(_光路,光线#2)->+[del](,新);
_光路->光路1(_光路,):
    ->输入,->_光线->光线1(_光线,)->+新(_光路,_光线)->+的(_光路,_光线);

+[del](,画板位置)
## end
#1095, 247:

_光线->分光光线(_光线,)->+[创建光线](,_光线);
_光线->分光光线(_光线,)->的(_光线,直径)->+[修改内容]"5"(,直径)...
->的(_光线,焦点)->+[修改内容]"100"(,焦点);
_分光镜->分光镜(_分光镜,)->_光线->分光光线(_光线,)...
->的(_分光镜,中心)->的(光线,起点)->+[修改内容](中心,起点);
_光路->光路1(_光路,)->_光线->分光光线(_光线,)->+的(_光路,_光线)->+新(_光路,_光线);
## end
#1096, 290:

_光线->入射光线(_光线,)->+[创建光线](,_光线);
_光线->入射光线(_光线,)->的(_光线,直径)->+[修改内容]"5"(,直径)...
->的(_光线,焦点)->+[修改内容]"100"(,焦点);
_光路->光路1(_光路,)->_光线->入射光线(_光线,)->+的(_光路,_光线)->+新(_光路,_光线);
_光线->入射光线(_光线,)->输入->在(输入,空间点)->的(_光线,起点)...
->+[python]"ans=[pt[0]*20,-pt[1]*20]"(Python,起点)->+[.]"pt"(+[python],空间点);
## end
#1097, 344:

镜子(临时文本,_镜子)->的(_镜子,名字)->+[标题](_镜子,)->+[修改内容](+[标题],名字)...
->的(_镜子,半径)->+[修改内容]"10"(,半径)->的(_镜子,厚度)->+[修改内容]"4"(,厚度);
镜子(临时文本,_镜子)->位置(临时文本,空间点)->的(_镜子,中心)...
->+[python]"ans=[pt[0]*20,-pt[1]*20]"(Python,中心)->+[.]"pt"(+[python],空间点);
镜子(临时文本,_镜子)->朝着(临时文本,方向)->的(_镜子,角度)...
->+[python]"ans=eulers[0]-90"(Python,角度)->+[.]"eulers"(+[python],方向);
## end
#1103, 2678:
"""
+[返回目录](,操作序列)
+[显示动词结构](,操作序列)

"""

_光路->光路(_光路,)...
->+光线光路->+元件=>的(_光路,_节点):
    ->经过(,_节点)=>+[有](+元件,_节点),
    ->经过(_节点,)=>+[有](+光线光路,_节点);


_画板->画板(_画板,)...
->光线光路=>的(光线光路,_光路)=>+的(_画板,+光路)->+[修改标题](_光路,+光路)...
->[]{
    的(_光路,输出)->输出(,_元件)...
    ->+光线->+的(_画板,+光线)->+[S函数](,反射步骤)...
    ->+[的](+[S函数],+光路)->+[光路1](+光路,)...
    ->+[的](+[S函数],+光线)->+[光线1](+光线,):
        ->_元件->在(_元件,空间点)->+[的](+[S函数],空间点)->+[位置](空间点,),
        ->在(输出,空间点#0)->+[的](+[S函数],空间点#0)->+[位置](空间点#0,)
}...

->[]{[]=>经过(_光路,_元件)->_元件(,)...
    ->[]{[]&:=>输入(,_元件)->的(_光路,输入),=>输出(,_元件)->的(_光路,输出)}...
    ->[]{[]:->反射(_元件,_光路),->反射(经过,)}...
    =>在(_元件,空间点)->+光线->+的(_画板,+光线)...
    ->+[S函数](,反射步骤)...
    ->+[的](+[S函数],+光路)->+[光路1](+光路,)...
    ->+[的](+[S函数],空间点)->+[位置](空间点,)...
    ->+[的](+[S函数],+光线)->+[光线1](+光线,)
}...

->[]{
    反射步骤:->分出来(,_光路)->从(分出来,经过)->经过(,_元件1)->在(_元件1,空间点#1)...
    ->+光线->+的(_画板,+光线)...
    ->+[S函数](,反射步骤)->+[的](+[S函数],+光路)->+[光路1](+光路,)...
    ->+[的](+[S函数],空间点#1)->+[位置](空间点#1,)...
    ->+[的](+[S函数],+光线)->+[分光光线](+光线,),

    ->的(_光路,输入)->输入(,_元件)->+[S函数](,反射步骤)...
    ->+[的](+[S函数],输入)...
    ->+[的](+[S函数],+光路)->+[光路1](+光路,):
        ->_元件->在(_元件,空间点)->+[的](+[S函数],空间点)->+[位置](空间点,),
        ->在(输入,空间点#0)->+[的](+[S函数],空间点#0)->+[位置](空间点#0,)
}


_画板->画板(_画板,)...
->元件=>的(元件,_元件)...
=>+的(_画板,+元件)->+[标题](_元件,)->+[修改内容](+[标题],+[修改标题])...
->+[修改标题](,+元件)->+[创建镜子](,+元件)->+是(_元件,+元件)...
->+[修改内容](这些事情,+[临时文本])...
->[当前编辑器](_画板,)->是([当前编辑器],_编辑器)...
->+[S函数](_编辑器,+[临时文本])->+[范围](+[S函数],+[临时文本])->+[镜子](+[临时文本],+元件)...
->[]{[]:->在(_元件,空间点)->+[位置](+[临时文本],空间点),->[]}:
    ->朝着(_元件,方向)->+朝着(+[临时文本],方向)->+[del](,+朝着),
    ->[];




+[del](,光线光路)->+[del](,元件);



"""
这些事情::
镜子(临时文本,_镜子)->的(_镜子,名字)->+[标题](_镜子,)->+[修改内容](+[标题],名字)...
->的(_镜子,半径)->+[修改内容]"10"(,半径)->的(_镜子,厚度)->+[修改内容]"4"(,厚度);
镜子(临时文本,_镜子)->位置(临时文本,空间点)->的(_镜子,中心)...
->+[python]"ans=[pt[0]*20,-pt[1]*20]"(Python,中心)->+[.]"pt"(+[python],空间点);
镜子(临时文本,_镜子)->朝着(临时文本,方向)->的(_镜子,角度)...
->+[python]"ans=eulers[0]-90"(Python,角度)->+[.]"eulers"(+[python],方向);


入射步骤::
_光线->入射光线(_光线,)->+[创建光线](,_光线);
_光线->入射光线(_光线,)->的(_光线,直径)->+[修改内容]"5"(,直径)...
->的(_光线,焦点)->+[修改内容]"100"(,焦点);
_光路->光路1(_光路,)->_光线->入射光线(_光线,)->+的(_光路,_光线)->+新(_光路,_光线);
_光线->入射光线(_光线,)->输入->在(输入,空间点)->的(_光线,起点)...
->+[python]"ans=[pt[0]*20,-pt[1]*20]"(Python,起点)->+[.]"pt"(+[python],空间点);



分光步骤::
_光线->分光光线(_光线,)->+[创建光线](,_光线);
_光线->分光光线(_光线,)->的(_光线,直径)->+[修改内容]"5"(,直径)...
->的(_光线,焦点)->+[修改内容]"100"(,焦点);
_分光镜->分光镜(_分光镜,)->_光线->分光光线(_光线,)...
->的(_分光镜,中心)->的(光线,起点)->+[修改内容](中心,起点);
_光路->光路1(_光路,)->_光线->分光光线(_光线,)->+的(_光路,_光线)->+新(_光路,_光线);


反射步骤:...
+[新建阅读窗口](,反射步骤)

透射步骤::

输出步骤:...

+[设置结构](,操作序列)
+[新建阅读窗口](,反射步骤)

"""





## end
#1105, 193:
"""
+[返回目录](,逻辑结构转光路)

操作序列(S代码):...


"""

+逻辑结构转光路(_光路,_画板)->+[del](,+逻辑结构转光路)...
->的(逻辑结构转光路,操作序列)...
->+[S函数](_光路,操作序列)->+[的](+[S函数],_光路)->+[光路](_光路,)...
->+[的](+[S函数],_画板)->+[画板](_画板,)




## end
#1108, 794:
"""
+[返回目录](,三维光栅)

M代码::
model_rectangle_mirror(%宽,%高,%厚度,[%方向],[%空间点]);

Blender::
M=mirror_rect_prototype('%[标题]',%高,%宽,%厚度)
angles=np.deg2rad(np.array((%方向)))
M.rotation_euler=(angles[1],angles[2],angles[0])
M.location=(%空间点)


"""

+三维光栅(_元件,_类型)->+[del](,+三维光栅)...
->的(_类型,厚度)->的(_类型,宽)->的(_类型,高)...
->在(_元件,空间点)->朝着(_元件,方向)...

->+[临时文本]->+[标题](_元件,)->[]{
    三维光栅:
        ->Blender#0(+三维光栅,)->的(三维光栅,Blender)->+[修改内容](Blender,+[临时文本]),
        ->的(三维光栅,M代码)->+[修改内容](M代码,+[临时文本])
}...


->+[模板文本](+[临时文本],+[临时文本])...
->+[.](+[模板文本],厚度)->+[.](+[模板文本],高)->+[.](+[模板文本],宽)...
->+[.](+[模板文本],空间点)->+[.](+[模板文本],方向):

    ->Blender(+三维光栅,)->+[.](+[模板文本],+[标题])...
    ->+[修改内容](+[临时文本],Blender),
    
    ->输出M代码(+三维光栅,_代码)->+[修改内容](+[临时文本],_代码),

    ->+[显示](,+[临时文本])->+[M函数](,+[临时文本])



## end
#1110, 906:
"""
+[返回目录](,三维柱面镜)
透镜焦距::文档\物理问题\透镜焦距.ftxt
+[打开文件](+新窗口,透镜焦距)


M代码::
model_para_cylindrical_mirror(1/4/%焦距,%宽,%厚度,%高,[%方向],[%空间点]);

Blender::
M=cylindrical_mirror_prototype('%[标题]',%宽,%厚度,%焦距,%高)
angles=np.deg2rad(np.array((%方向)))
M.rotation_euler=(angles[1],angles[2],angles[0])
M.location=(%空间点)


"""

+三维柱面镜(_元件,_类型)->+[del](,+三维柱面镜)...
->的(_类型,厚度)->的(_类型,宽)->的(_类型,高)->的(_类型,焦距)...
->在(_元件,空间点)->朝着(_元件,方向)...

->+[临时文本]->+[标题](_元件,)->[]{
    三维柱面镜:
        ->Blender#0(+三维柱面镜,)->的(三维柱面镜,Blender)->+[修改内容](Blender,+[临时文本]),
        ->的(三维柱面镜,M代码)->+[修改内容](M代码,+[临时文本])
}...

->+[模板文本](+[临时文本],+[临时文本])...
->+[.](+[模板文本],焦距)...
->+[.](+[模板文本],厚度)->+[.](+[模板文本],高)->+[.](+[模板文本],宽)...
->+[.](+[模板文本],空间点)->+[.](+[模板文本],方向):

    ->Blender(+三维柱面镜,)->+[.](+[模板文本],+[标题])...
    ->+[修改内容](+[临时文本],Blender),
    
    ->输出M代码(+三维柱面镜,_代码)->+[修改内容](+[临时文本],_代码),

    ->+[显示](,+[临时文本])->+[M函数](,+[临时文本])




## end
#1114, 768:
"""
+[返回目录](,三维反射镜)

M代码::
model_round_mirror(%直径/2,%厚度,[%方向],[%空间点]);

Blender::
M=mirror_prototype('%[标题]',%直径/2,%厚度)
angles=np.deg2rad(np.array((%方向)))
M.rotation_euler=(angles[1],angles[2],angles[0])
M.location=(%空间点)


"""

+三维反射镜(_元件,_类型)->+[del](,+三维反射镜)...
->的(_类型,直径)->的(_类型,厚度)...
->在(_元件,空间点)->朝着(_元件,方向)...

->+[临时文本]->+[标题](_元件,)->[]{
    三维反射镜:
        ->Blender#0(+三维反射镜,)->的(三维反射镜,Blender)->+[修改内容](Blender,+[临时文本]),
        ->的(三维反射镜,M代码)->+[修改内容](M代码,+[临时文本])
}...

->+[模板文本](+[临时文本],+[临时文本])...
->+[.](+[模板文本],直径)->+[.](+[模板文本],厚度)...
->+[.](+[模板文本],空间点)->+[.](+[模板文本],方向):

    ->Blender(+三维反射镜,)->+[.](+[模板文本],+[标题])...
    ->+[修改内容](+[临时文本],Blender),
    
    ->输出M代码(+三维反射镜,_代码)->+[修改内容](+[临时文本],_代码),

    ->+[显示](,+[临时文本])->+[M函数](,+[临时文本])



## end
#1116, 17:
文档\物理问题\透镜焦距.ftxt
## end
#1118, 1469:
"""
+[返回目录](,反射代码)

M代码:...
+[新建阅读窗口](,M代码)


"""

+反射代码(_元件,_代码)->+[del](,+反射代码)...
->的(反射代码,M代码)->+[修改内容](M代码,+[临时文本])...
->+[模板文本](+[临时文本],+[临时文本])...

->是(_元件,_形状)->在(_元件,_空间点)->朝着(_元件,_方向)...
->+[标题](_元件,)...

->[]{
    []:
    ->[is](_形状,光栅)->光栅->+元件"[%位置],[%方向]"...
    ->+[修改内容](_空间点,+位置#1)->+[修改内容](_方向,+方向#1)...
    ->+[模板文本]#1(+[临时文本],+[临时文本])...
    ->+[.](+[模板文本]#1,+[标题])...
    ->+[.](+[模板文本]#1,+位置#1)->+[del](,+位置#1)...
    ->+[.](+[模板文本]#1,+方向#1)->+[del](,+方向#1)...
    ->+[.](+[模板文本],+元件)->+[del](,+元件)...
    ->+[.](+[模板文本],+函数#1)->+函数#1"Reflection_plane_3D"->+[del](,+函数#1),
    
    
    ->[is](_形状,柱面镜)->柱面镜->的(_形状,焦距)->焦距(,)...
    ->+元件"1/4/%焦距,[%位置],[%方向]"...
    ->+[修改内容](_空间点,+位置#2)->+[修改内容](_方向,+方向#2)...
    ->+[模板文本]#2(+[临时文本],+[临时文本])...
    ->+[.](+[模板文本]#2,+[标题])...
    ->+[.](+[模板文本]#2,焦距)...
    ->+[.](+[模板文本]#2,+位置#2)->+[del](,+位置#2)...
    ->+[.](+[模板文本]#2,+方向#2)->+[del](,+方向#2)...
    ->+[.](+[模板文本],+元件)->+[del](,+元件)...
    ->+[.](+[模板文本],+函数#2)->+函数#2"Reflection_parabola_3D"->+[del](,+函数#2),
    
    
    ->[is](_形状,反射镜)->+元件"[%位置],[%方向]"...
    ->+[修改内容](_空间点,+位置#3)->+[修改内容](_方向,+方向#3)...
    ->+[模板文本]#3(+[临时文本],+[临时文本])...
    ->+[.](+[模板文本]#3,+[标题])...
    ->+[.](+[模板文本]#3,+位置#3)->+[del](,+位置#3)...
    ->+[.](+[模板文本]#3,+方向#3)->+[del](,+方向#3)...
    ->+[.](+[模板文本],+元件)->+[del](,+元件)...
    ->+[.](+[模板文本],+函数#3)->+函数#3"Reflection_plane_3D"->+[del](,+函数#3)
}->+[显示](,+[临时文本])...

->+[增加内容](+[临时文本],_代码)



"""



"""
## end
#1120, 108:

% %[标题]
[x,y,z,k_x,k_y,k_z]=%函数(x,y,z,k_x,k_y,k_z,%元件);
x_ray=[x_ray;x];
y_ray=[y_ray;y];
z_ray=[z_ray;z];

## end
#1121, 4:
1178
## end
#1124, 270:

_光线->光线(_光线,)->_镜子->元件(_镜子,):
    ->是(_镜子,光栅)->+光栅(光栅,_镜子)->+[反射](+光栅,_光线)->+[为](+[反射],_光线)->+[del](,+光栅),
    ->是(_镜子,柱面镜)->+柱面镜(柱面镜,_镜子)->+[反射](+柱面镜,_光线)->+[为](+[反射],_光线)->+[del](,+柱面镜),
    ->是(_镜子,反射镜)->+反射镜(反射镜,_镜子)->+[反射](+反射镜,_光线)->+[为](+[反射],_光线)->+[del](,+反射镜)
## end
#1127, 168:

_元件->元件(_元件,)->在(_元件,空间点)->朝着(_元件,方向)...
->是(_元件,_类型):
    ->[is](_类型,光栅)->+[三维光栅](_元件,光栅),
    ->[is](_类型,晶体)->+[三维光栅](_元件,晶体),
    ->[is](_类型,柱面镜)->+[三维柱面镜](_元件,柱面镜)
## end
#1134, 1674:
"""
+[返回目录](,操作序列)
+[新建阅读窗口](,操作序列)

TOPAS里面所有被经过的节点都是元件. 所有经过了什么的节点都是光路. 


每一个元件创建一面镜子. 每创建一面镜子就做一遍下面的事情: 
1.镜子的名字设为元件的标题;
2.如果元件到达了一个空间点, 镜子的中心就设在空间点的位置乘以10的位置; 
3.镜子的半径为5, 厚度为1; 


对每一段光路都创建一个光路节点. 每经过一个元件都做如下的事情:
如果光路被一面分光镜分光, 就创建一条新光线和一个出发点, 然后做一遍下面的事情:
1.分光镜的中心是这条光线的起点;  
2.分光镜相对穿透的光线反射这条光线. 
如果光路被一面镜子反射, 就创建一条新光线和一个转折点, 然后做一遍下面的事情: 
1.上一个转折点发出的光线, 终点是光线的起点; 
2.镜子的中心设置为上一条光线的终点; 
3.镜子反射光线. 
如果光路穿透一面镜子, 标记上当前光线穿透了这个元件. 

"""

_光路->光路(_光路,)...
->+光线光路->+元件=>的(_光路,_节点):
    ->经过(,_节点)=>+[有](+元件,_节点),
    ->经过(_节点,)=>+[有](+光线光路,_节点);

+[matlab]"clf;hold on;axis equal;addpath('Matlab\space');addpath('Matlab\optics');"(Matlab,)

元件=>的(元件,_元件)...
=>+[S函数](,这些事情)->+的(+[S函数],_元件)->+[del](,+的)->+[元件](_元件,);

+新光线(+位置,+方向)->+位置"-10,-2,0"->+方向"1,0,0";

光线光路=>的(光线光路,_光路)=>[]{
    []:->分出来(,_光路)->从(分出来,_元件)...
    ->+[S函数](,分光步骤)->+[的](+[S函数],_光路)->+[光路](_光路,)...
    ->+[的](+[S函数],_元件)->+[分光镜](_元件,),

    ->+[S函数](,入射步骤)->+[的](+[S函数],_光路)->+[光路](_光路,)
}...
=>经过(_光路,_元件)->_元件:
    ->反射(_元件,_光路)=>+[S函数](,反射步骤)...
    ->+[的](+[S函数],新光线)->+[光线](新光线,)...
    ->+[的](+[S函数],_元件)->+[元件](_元件,);

+[del](,光线光路)->+[del](,元件);

新光线(位置,方向)=>[那](_,)=>+[del](,_);



"""
这些事情::
_元件->元件(_元件,)->在(_元件,空间点)->朝着(_元件,方向)...
->是(_元件,_类型):
    ->[is](_类型,光栅)->+[三维光栅](_元件,光栅),
    ->[is](_类型,晶体)->+[三维光栅](_元件,晶体),
    ->[is](_类型,柱面镜)->+[三维柱面镜](_元件,柱面镜)


入射步骤::


分光步骤::


反射步骤::
_光线->光线(_光线,)->_镜子->元件(_镜子,):
    ->是(_镜子,光栅)->+光栅(光栅,_镜子)->+[反射](+光栅,_光线)->+[为](+[反射],_光线)->+[del](,+光栅),
    ->是(_镜子,柱面镜)->+柱面镜(柱面镜,_镜子)->+[反射](+柱面镜,_光线)->+[为](+[反射],_光线)->+[del](,+柱面镜),
    ->是(_镜子,反射镜)->+反射镜(反射镜,_镜子)->+[反射](+反射镜,_光线)->+[为](+[反射],_光线)->+[del](,+反射镜)




透射步骤::

+[设置结构](,操作序列)

"""





## end
#1136, 213:
"""
+[返回目录](,逻辑结构转光线显示)

操作序列(S代码):...


"""

+逻辑结构转光线显示(_光路,_代码)->+[del](,+逻辑结构转光线显示)...
->的(逻辑结构转光线显示,操作序列)...
->+[S函数](_光路,操作序列)->+[的](+[S函数],_光路)->+[光路](_光路,)...
->+[的](+[S函数],_代码)->+代码(_代码,)->+[del](,+代码)




## end
#1138, 125:

[x,y,z,kx,ky,kz]=%反射函数(%输入位置,%输入方向,%元件);
p0=[%输入位置];
p1=[x,y,z];
k1=[kx,ky,kz];
plot3([p0(1),x],[p0(2),y],[p0(3),z],'ro-');

## end
#1140, 1797:
"""
+[返回目录](,反射)

M代码::
[x,y,z,kx,ky,kz]=%反射函数(%输入位置,%输入方向,%元件);
p0=[%输入位置];
p1=[x,y,z];
k1=[kx,ky,kz];
plot3([p0(1),x],[p0(2),y],[p0(3),z],'ro-');




"""

+反射(_元件,_入射光线)->+[del](,+反射)...
->的(反射,M代码)->+[修改内容](M代码,+[临时文本])...
->_入射光线(_位置1,_出射方向1)->_位置1->_出射方向1(,)...
->为(+反射,_出射光线)->_出射光线(_位置2,_出射方向2)->_位置2->_出射方向2(,)...
->+[修改内容](_位置1,+输入位置)->+[修改内容](_出射方向1,+输入方向)...
->+[模板文本](+[临时文本],+[临时文本])...
->+[.](+[模板文本],+输入位置)->+[del](,+输入位置)...
->+[.](+[模板文本],+输入方向)->+[del](,+输入方向)...

->_元件(_形状,_L)->_形状->_L->在(_L,_空间点)->朝着(_L,_方向)...

->[]{
    []:
    ->[is](_元件,光栅)->光栅->+元件"[%位置],[%方向]"...
    ->+[修改内容](_空间点,+位置#1)->+[修改内容](_方向,+方向#1)...
    ->+[模板文本]#1(+[临时文本],+[临时文本])...
    ->+[.](+[模板文本]#1,+位置#1)->+[del](,+位置#1)...
    ->+[.](+[模板文本]#1,+方向#1)->+[del](,+方向#1)...
    ->+[.](+[模板文本],+元件)->+[del](,+元件)...
    ->+[.](+[模板文本],+反射函数#1)->+反射函数#1"Reflection_plane_3D"->+[del](,+反射函数#1),
    
    
    ->[is](_元件,柱面镜)->柱面镜->的(_形状,焦距)->焦距(,)...
    ->+元件"1/4/%焦距,[%位置],[%方向]"...
    ->+[修改内容](_空间点,+位置#2)->+[修改内容](_方向,+方向#2)...
    ->+[模板文本]#2(+[临时文本],+[临时文本])...
    ->+[.](+[模板文本]#2,焦距)...
    ->+[.](+[模板文本]#2,+位置#2)->+[del](,+位置#2)...
    ->+[.](+[模板文本]#2,+方向#2)->+[del](,+方向#2)...
    ->+[.](+[模板文本],+元件)->+[del](,+元件)...
    ->+[.](+[模板文本],+反射函数#2)->+反射函数#2"Reflection_parabola_3D"->+[del](,+反射函数#2),
    
    
    ->[is](_元件,反射镜)->+元件"[%位置],[%方向]"...
    ->+[修改内容](_空间点,+位置#3)->+[修改内容](_方向,+方向#3)...
    ->+[模板文本]#3(+[临时文本],+[临时文本])...
    ->+[.](+[模板文本]#3,+位置#3)->+[del](,+位置#3)...
    ->+[.](+[模板文本]#3,+方向#3)->+[del](,+方向#3)...
    ->+[.](+[模板文本],+元件)->+[del](,+元件)...
    ->+[.](+[模板文本],+反射函数#3)->+反射函数#3"Reflection_plane_3D"->+[del](,+反射函数#3)
}->+[显示](,+[临时文本])...

->+[matlab](Matlab,)->+[code](+[matlab],+[临时文本])...
->+[o]"p1"(+[matlab],_位置2)->+[o]"k1"(+[matlab],_出射方向2)



"""



"""
## end
#1143, 225:

_代码->代码(_代码,)->_镜子->元件(_镜子,):
    ->是(_镜子,光栅)->+光栅(光栅,_镜子)->+[反射代码](+光栅,_代码)->+[del](,+光栅),
    ->是(_镜子,柱面镜)->+柱面镜(柱面镜,_镜子)->+[反射代码](+柱面镜,_代码)->+[del](,+柱面镜),
    ->是(_镜子,反射镜)->+反射镜(反射镜,_镜子)->+[反射代码](+反射镜,_代码)->+[del](,+反射镜)
## end
#1146, 323:

_元件->元件(_元件,)->元件画图(,)...
->在(_元件,空间点)->朝着(_元件,方向)...
->是(_元件,_类型):
    ->[is](_类型,光栅)->+[三维光栅](_元件,光栅)->+[输出M代码](+[三维光栅],+[增加内容]#1)->+[增加内容]#1(,元件画图),
    ->[is](_类型,晶体)->+[三维光栅](_元件,晶体)->+[输出M代码](+[三维光栅],+[增加内容]#2)->+[增加内容]#2(,元件画图),
    ->[is](_类型,柱面镜)->+[三维柱面镜](_元件,柱面镜)->+[输出M代码](+[三维柱面镜],+[增加内容]#3)->+[增加内容]#3(,元件画图)
## end
#1153, 1185:
"""
+[返回目录](,操作序列)
+[新建阅读窗口](,操作序列)

1.准备一个代码框架, 往里面填充入口信息, 出口信息, 反射信息和所有经过的元件信息; 
2.收集光路的输入和输出; 
3.对经过的每一个光学元件, 按顺序增加一段反射代码; 
4.对每一个元件生成一段画图函数. 

"""

[]=>_=>+[标题](_,)->+[显示](,+[标题])

_光路->光路(_光路,)...
->+光线光路->+元件=>的(_光路,_节点):
    ->经过(,_节点)=>+[有](+元件,_节点),
    ->经过(_节点,)=>+[有](+光线光路,_节点);


元件=>的(元件,_元件)...
=>+[S函数](,这些事情)->+的(+[S函数],_元件)->+[del](,+的)->+[元件](_元件,)...
->+的(+[S函数],元件画图)->+[del](,+的);


_代码->代码(_代码,)...
->光线光路=>的(光线光路,_光路):
    =>的(_光路,输出)->输出,
    =>的(_光路,输入)->输入;


元件反射(,)...
->+[临时文本]->光线光路=>的(光线光路,_光路)=>[]{
    []=>经过(_光路,_元件)->_元件(,)...
    =>+[反射代码](_元件,+[增加内容])->+[增加内容](,+[临时文本])
}->+[修改内容](+[临时文本],元件反射);

_代码->代码(_代码,)...
->+[模板文本](追踪整体模板,_代码)->+[.](+[模板文本],元件反射)...
->+[.](+[模板文本],元件画图)->+[显示](,元件画图);

+[del](,光线光路)->+[del](,元件)=>新节点=>+[del](,新节点);


"""
元件反射::
元件画图::
追踪整体模板:...
+[新建阅读窗口](,追踪整体模板)

这些事情::
_元件->元件(_元件,)->元件画图(,)...
->在(_元件,空间点)->朝着(_元件,方向)...
->是(_元件,_类型):
    ->[is](_类型,光栅)->+[三维光栅](_元件,光栅)->+[输出M代码](+[三维光栅],+[增加内容]#1)->+[增加内容]#1(,元件画图),
    ->[is](_类型,晶体)->+[三维光栅](_元件,晶体)->+[输出M代码](+[三维光栅],+[增加内容]#2)->+[增加内容]#2(,元件画图),
    ->[is](_类型,柱面镜)->+[三维柱面镜](_元件,柱面镜)->+[输出M代码](+[三维柱面镜],+[增加内容]#3)->+[增加内容]#3(,元件画图)


+[设置结构](,操作序列)

"""
## end
#1155, 310:
"""
+[返回目录](,逻辑结构转光线追踪)

操作序列(S代码):...
+[新建阅读窗口](,操作序列)

"""

+逻辑结构转光线追踪(_光路,_代码)->+[del](,+逻辑结构转光线追踪)...
->的(逻辑结构转光线追踪,操作序列)...
->+[S函数](_光路,操作序列)->+[的](+[S函数],_光路)->+[光路](_光路,)...
->+[的](+[S函数],+输出)->+代码(+输出,)->+[del](,+代码)...

->+[标题](_代码,)->+[模板文本](+输出,_代码)...
->+[.](+[模板文本],+[标题])...

->+[del](,+输出)





## end
#1157, 4:
1193
## end
#1160, 48:

model_rectangle_mirror(%宽,%高,%厚度,[%方向],[%空间点]);
## end
#1162, 146:

M=mirror_rect_prototype('%[标题]',%高,%宽,%厚度)
angles=np.deg2rad(np.array((%方向)))
M.rotation_euler=(angles[1],angles[2],angles[0])
M.location=(%空间点)

## end
#1164, 156:

M=cylindrical_mirror_prototype('%[标题]',%宽,%厚度,%焦距,%高)
angles=np.deg2rad(np.array((%方向)))
M.rotation_euler=(angles[1],angles[2],angles[0])
M.location=(%空间点)
## end
#1166, 63:

model_para_cylindrical_mirror(1/4/%焦距,%宽,%厚度,%高,[%方向],[%空间点]);
## end
#1168, 44:

model_round_mirror(%直径/2,%厚度,[%方向],[%空间点]);
## end
#1170, 141:

M=mirror_prototype('%[标题]',%直径/2,%厚度)
angles=np.deg2rad(np.array((%方向)))
M.rotation_euler=(angles[1],angles[2],angles[0])
M.location=(%空间点)

## end
#1171, 4:
1187
## end
#1173, 4:
1207
## end
#1177, 1640:
"""
+[返回目录](,操作序列)
+[新建阅读窗口](,操作序列)

的(_结构,光线)
"""


_光路->光路(_光路,)...
->+光线光路->+元件=>的(_光路,_节点):
    ->经过(,_节点)=>+[有](+元件,_节点),
    ->经过(_节点,)=>+[有](+光线光路,_节点);

的(_结构,光线)

_结构->路线(_结构,)...
->光线光路=>的(光线光路,_光路)=>+的(_结构,+光路)->+[修改标题](_光路,+光路)...
->[]{
    的(_光路,输出)...
    ->+光线->+的(_结构,+光线)->+[S函数](,反射步骤)...
    ->+[的](+[S函数],+光路)->+[光路1](+光路,)...
    ->+[的](+[S函数],_结构)->+[路线](_结构,)...
    ->+[的](+[S函数],+光线)->+[光线1](+光线,)...
    ->+[的](+[S函数],输出)->+输出(输出,)->+[del](,+输出)
}...

->[]{[]=>经过(_光路,_元件)->_元件(,)...
    ->[]{[]&:=>输入(,_元件)->的(_光路,输入),=>输出(,_元件)->的(_光路,输出)}...
    =>[]{[]:->反射(_元件,_光路),->反射(经过,)}:
        ->+光线->+的(_结构,+光线)...
        ->+[S函数](,反射步骤)...
        ->+[的](+[S函数],+光路)->+[光路1](+光路,)...
        ->+[的](+[S函数],经过)->+[元件](经过,)...
        ->+[的](+[S函数],_结构)->+[路线](_结构,)...
        ->+[的](+[S函数],+光线)->+[光线1](+光线,),

        ->>+[S函数](,经过步骤)...
        ->+[的](+[S函数],+光路)->+[光路1](+光路,)...
        ->+[的](+[S函数],经过)->+[元件](经过,)...
        ->+[的](+[S函数],_结构)->+[路线](_结构,)
}...

->[]{
    反射步骤:->分出来(,_光路)->从(分出来,)...
    ->+[S函数](,反射步骤)->+[的](+[S函数],+光路)->+[光路1](+光路,)...
    ->+[的](+[S函数],_结构)->+[路线](_结构,)...
    ->+[的](+[S函数],从)->+[分光位置](从,),

    ->的(_光路,输入)->+[S函数](,反射步骤)...
    ->+[的](+[S函数],输入)->+输入(输入,)->+[del](,+输入)...
    ->+[的](+[S函数],+光路)->+[光路1](+光路,)...
    ->+[的](+[S函数],_结构)->+[路线](_结构,)
}->+[del](,+光路)=>旧(+光路,)=>+[del](,+旧)




光线光路->的(光线光路,_光路)->分出来(,_光路)->从(分出来,经过)->是(_穿过,经过)->_穿过(光线#0,)...
->是(起点,从)->起点(光线#1,)->+[左连](光线#1,光线#0);





+[del](,光线光路)->+[del](,元件)=>新节点=>+[del](,新节点);


"""
显示框架:...
保存:...
+[新建阅读窗口](,保存)
旧版本:...
反射步骤:...
经过步骤:...
+[新建阅读窗口](,反射步骤)


+[删除结构](,操作序列)
+[设置结构](,操作序列)

"""
## end
#1179, 388:
"""
+[返回目录](,场景结构转路线结构)
+[新建阅读窗口](,场景结构转路线结构)
操作序列(S代码):...
+[新建阅读窗口](,操作序列)

查看代码:..
+[显示动词结构](,操作序列)

"""

+场景结构转路线结构(_光路,_路线结构)->+[del](,+场景结构转路线结构)...
->的(场景结构转路线结构,操作序列)...
->+[S函数](_光路,操作序列)...
->+[的](+[S函数],_光路)->+光路(_光路,)->+[del](,+光路)...
->+[的](+[S函数],+路线结构)->+路线(+路线结构,)->+[del](,+路线)...
->+[做]"
+做(_A,_B)->+[del](,+做)=>的(_A,_)=>+的(_B,_)
"(+路线结构,_路线结构)...

->+[del](,+路线结构)





## end
#1181, 4:
1206
## end
#1184, 733:
%{
+[M函数](,%[标题])
%}

addpath('Matlab\space')
addpath('Matlab\optics')

% beam
physics_constant;
lm=800e-9;
w0=0.005e-3;
A0=1;
n=1;

xs=20;
xf=25;

Dz=1;
Dtheta=0.0001;
N=100;

k=2*pi/lm;

x1=xs*ones(1,N);
x2=xf*ones(1,N);

theta=random('Uniform',180-Dtheta/2,180,1,N);
phi=random('Uniform',0,360,1,N);
y1=random('Uniform',-Dz/2,Dz/2,1,N);
z1=random('Uniform',-Dz/2,Dz/2,1,N);

k1_y=sind(theta).*cosd(phi);
k1_z=sind(theta).*sind(phi);
k1_x=cosd(theta);

x=x1;
y=y1;
z=z1;
k_x=k1_x;
k_y=k1_y;
k_z=k1_z;
x_ray=x;
y_ray=y;
z_ray=z;
%元件反射


% drawing
Dx=x2-x;
y2=y+k_y./k_x.*Dx;
z2=z+k_z./k_x.*Dx;
x_ray=[x_ray;x2];
y_ray=[y_ray;y2];
z_ray=[z_ray;z2];


clf
hold on
%元件画图
plot3(x_ray,y_ray,z_ray,'ro-')
axis equal


%{
+[M函数](,%[标题])
%}
## end
#1189, 4:
1205
## end
#1191, 4:
1220
## end
#1193, 64:
"""
+[返回目录](,物体)

"""

+物体(_M,)->在(_M,_空间点)->_空间点->+在(+物体,_空间点)

## end
#1196, 124:
"""
+[返回目录](,反射)

"""

+反射(经过,)->经过(_光路,_元件)->_光路->_元件:
    ->反射(经过,)->[说](,反射)->[]{[]=>[is](反射,+反射)},
    ->反射(_元件,_光路)




## end
#1198, 113:
"""
+[返回目录](,输入)

"""

+输入(_光路,)->_光路:
    ->的(_光路,输入)->+是(+输入,输入),
    ->分出来(,_光路)->从(分出来,_元件)->+是(+输入,_元件)





## end
#1200, 5366:
+[返回目录](,实验场景)
+[复制结构](,实验场景)
+[新建阅读窗口](,实验场景)
+[显示星图](,实验场景)

后面

有一束探测光和一束参考光. 
+探测光->+参考光

探测光经过M1, M2, L1, M3, P1, L2, M4, M5, Gas, S1, M6, M7, S1, L3, Camera
+M1->+M2->+L1->+M3->+P1->+L2->+M4->+M5->+Gas->+S1->+M6->+M7->S1->+L3->+Camera(,)...
=>[那](_,)=>+经过(探测光,_)

输出(,Camera)
Camera是探测光的输出
+的(探测光,+输出)->+输出(,Camera)
探测光的输入在空间点"-30,-5,0"上. 
+的(探测光,+输入)->+在(+输入,+空间点)->+的(位置,+空间点)->+空间点"-30,-5,0"

在S1上, 从探测光分出来了参考光, 然后经过了M8, S1, L3, Camera
+分出来(探测光,参考光)->+从(+分出来,S1)
M8->S1->L3->Camera=>[那](_,)=>+经过(参考光,_)

这里修改一下, 分光以后要从某一次经过上面分光, 而不是从元件上面分光. 
S1上没有反射的那一次经过分出来了参考光
经过(探测光,S1)->[]{[]=>反射(经过,)}->从(,S1)->+[右连](从,经过)


L1->反射(L1,探测光)
经过(探测光,L1)->[反射](经过,)
[]=>_P1->反射(_P1,)=>+[显示](,反射)
[]=>经过->反射(经过,)=>+[显示](,反射)

Camera也是参考光的输出
+的(参考光,输出)



位置::
位置=>的(位置,空间点)->在(,空间点)=>+[del](,在)->+[del](,空间点)
所有被光线经过的东西都是元件, 都有空间位置
实验场景=>的(实验场景,_元件)->[]{经过(,_元件)}=>+的(位置,+空间点)->+在(_元件,+空间点)
在(Camera,空间点)->+[del](,在)->+[del](,空间点)


位置::
+[设置结构](,位置)
探测光的元件
在(M1,空间点)->+[修改内容]"-20,-5,0"(,空间点)
+[相对]"0,-5,0"(M1,M2)
+[相对]"15,0,0"(M2,L1)
+[相对]"20,0,0"(M2,M3)
+[相对]"0,5,0"(M3,P1)
+[相对]"0,30,0"(M3,L2)
+[相对]"0,40,0"(M3,M4)
+[相对]"0,0,30"(M4,M5)
+[相对]"0,-20,0"(M5,Gas)
+[相对]"0,-30,0"(M5,S1)
+[相对]"0,-4,0"(S1,M6)
+[相对]"0.1,0,0"(M6,M7)
+[相对]"-10,0,0"(S1,L3)
+[相对]"-20,0,0"(S1,Camera)

参考光的镜子
+[相对]"5,0,0"(S1,M8)

显示探测光和参考光光路
+[matlab]"clf"(Matlab,)...
->+[显示光路](+[matlab],探测光)->+[显示光路](+[matlab],参考光)


探测光=>经过(探测光,_){[]=>_}=>+[右连](经过,S1)
从(分出来,)->+[右连](从,S1)
所有经过了镜子的光线都被那面镜子反射. 
[]=>经过(_光线,_re)->_re"M"=>+反射(_re,_光线)

探测光第二次经过S1的时候被S1反射. 
[python]"n=0
state=True"(Python,)...
->探测光=>经过(探测光,S1)=>[python]"n=n+1
state=True"(Python,):->[python]"state=(n==2)
print(n)"(Python,)->+反射(经过,),
->[]
第一次也反射好了(事实上, 第一个经过是第二次的经过)... 
反射(经过,)->+[del](,反射)
经过(探测光,S1)->+反射(经过,)
(在分光镜上的反射有个问题. 分光镜有的时候反射有的时候不反射... )

的(探测光,输入)->在(输入,空间点)
参考光是探测光从S1那里分出来的. 
分出来(探测光,参考光)->从(分出来,S1)

[输入](探测光,)->是([输入],_元件)->+[显示](,_元件)


所有的元件都需要朝着某一个方向. 
[]=>朝着(,方向)=>+[del](,方向)->+[del](,朝着)
实验场景=>的(实验场景,_元件)->[]{经过(,_元件)}=>+朝着(_元件,+方向)



对于光路中经过的每一个元件, 
如果元件反射了光线, 那么就产生一个新的光线. 
新光线左连上一个光线. 上一个光线终点是这个元件, 这个光线起点是这个元件. 
如果元件没有反射光线, 那么光线就经过这个元件. 

探测光->[]{
[]=>经过(探测光,_元件)->_元件=>[]:
    ->[]{[]:->反射(_元件,探测光),->反射(经过,),->输出(,_元件)}->+[显示]"反射: "(,_元件),
    ->+[显示]"经过: "(,_元件)
}

探测光->[]{
[]=>经过(探测光,_元件)->_元件=>[]:
    ->[]{[]:->反射(_元件,探测光),->反射(经过,),->输出(,_元件)}->+的(探测光,+光线)->+终点(+光线,_元件)->+是(+终点,经过)...
    ->[]{
        []:->的(探测光,光线)->光线->[]{[]&:=>旧(光线,),=>[is](光线,+光线)}->+[左连](光线,+光线)->+[旧](光线,)->+起点(光线,_元件)->+是(+起点,经过),
        ->[]
    },
    ->的(探测光,光线#2)->光线#2->[]{[]=>旧(光线#2,)}->+穿过(光线#2,_元件)->+是(+穿过,经过)
}:
->的(探测光,输入)->的(探测光,光线#3)->光线#3->[]{[]=>旧(光线#3,)}->+起点(光线#3,输入)...
->+[显示](,+起点)


参考光->[]{
[]=>经过(参考光,_元件)=>[]:
    ->[]{[]:->反射(_元件,参考光),->反射(经过,),->输出(,_元件)}->+的(参考光,+光线)->+终点(+光线,_元件)->+是(+终点,经过)...
    ->[]{
        []:->的(参考光,光线)->光线->[]{[]&:=>旧(光线,),=>[is](光线,+光线)}->+[左连](光线,+光线)->+[旧](光线,)->+起点(光线,_元件)->+是(+起点,经过),
        ->[]
    },
    ->的(参考光,光线#2)->光线#2->[]{[]=>旧(光线#2,)}->+穿过(光线#2,_元件)->+是(+穿过,经过)
}:
->分出来(探测光,参考光)->从(分出来,经过)->经过(探测光,_分光镜)...
->的(参考光,光线#3)->光线#3->[]{[]=>旧(光线#3,)}->+起点(光线#3,_分光镜)->+是(+起点,从)...
->+[显示](,+起点)

所有从某条光线分出来的光线, 都应该接到主光线上. 
[]=>从(,经过)=>是(_穿过,经过)->_穿过(光线#0,)...
->是(起点,从)->起点(光线#1,)->+[左连](光线#1,光线#0)


+[显示](,什么玩意)
+[del](,什么玩意)
什么玩意(起点,)->[当前文件](什么玩意,)->是([当前文件],_文件)...
->+[显示](,_文件)=>的(_文件,起点)
[幽灵](什么玩意,起点)
[]=>什么玩意=>+[显示](,什么玩意)
[]=>什么玩意=>+[del](,什么玩意)
这里面是有幽灵节点呀... 不是幽灵节点... 



是([名词库],名词)->+[打开文件](+新窗口,名词)

[]=>穿过(光线,)->是(穿过,)=>+[del](,是)
[]=>起点(光线,)->是(起点,)=>+[del](,是)
[]=>终点(光线,)->是(终点,)=>+[del](,是)
[]=>穿过(光线,)=>+[del](,穿过)
[]=>起点(光线,)=>+[del](,起点)
[]=>终点(光线,)=>+[del](,终点)
[]=>光线=>+[del](,光线)
[]=>旧=>+[del](,旧)

是
光线
旧

参考光=>的(参考光,光线)=>+[del](,光线)

[]=>光线=>+[显示](,光线)

测试结构:...
+[场景结构转路线结构](实验场景,测试结构)
+[删除结构](,测试结构)
+[设置结构](,测试结构)

所以, 分光要从经过那里开始分. 
先把每一个支路的光路画好, 然后再把它们关联起来. 


接下来调整镜子的方向. 
对所有的元件, 如果那个元件是某一道光线的起点, 同时是那道光线之前光线的终点, 那么按照反射调整这面镜子; 
如果是光线的终点且之后没有其它光线了, 那么元件指向光线方向. 
如果只有光线经过, 那么把元件调整到面向光线的方向. 

+[matlab]"addpath('Matlab\space');"(Matlab,)

[]=>_元件{经过(,_元件)}->朝着(_元件,方向)=>+[自动调整镜子方向](,_元件)

Matlab=>_元件{经过(,_元件)}->朝着(_元件,方向)=>[]:
->起点(光线#1,_元件)->光线#1(光线#0,)...
->[方向](光线#0,)->+[修改内容](,+[临时文本]#0)->[m_text]([方向],+[修改内容])...
->[方向](光线#1,)->+[修改内容](,+[临时文本]#1)->[m_text]([方向],+[修改内容])...
->+[matlab]"
z=z1/norm(z1)-z0/norm(z0);
[alpha,beta,gamma]=Eulers(z(1),z(2),z(3));
ans=[alpha,beta,gamma];
"(Matlab,方向)->+[.]"z0"(+[matlab],+[临时文本]#0)->+[.]"z1"(+[matlab],+[临时文本]#1),

->终点(光线#2,_元件)->[方向](光线#2,)...
->+[修改内容]([方向],+[临时文本]#2)->[m_text]([方向],+[修改内容])...
->+[matlab]"[alpha,beta,gamma]=Eulers(-z(1),-z(2),-z(3));
ans=[alpha,beta,gamma];
"(Matlab,方向)->+[.]"z"(+[matlab],+[临时文本]#2),

->穿过(光线#3,_元件)->[方向](光线#3,)...
->+[修改内容]([方向],+[临时文本]#3)->[m_text]([方向],+[修改内容])...
->+[matlab]"[alpha,beta,gamma]=Eulers(z(1),z(2),z(3));
ans=[alpha,beta,gamma];
"(Matlab,方向)->+[.]"z"(+[matlab],+[临时文本]#3)

M8->起点(光线,M8)->光线(光线#0,)

用光线的起点和终点可以计算光线的方向. 
测试结构=>的(测试结构,光线)...
=>[方向](光线,)->[m_text]([方向],+[显示])

起点(光线,_元件1)->在(_元件1,空间点#1)...
->终点(光线,_元件2)->在(_元件2,空间点#2)...
->+[matlab]"pt2-pt1;"(Matlab,+[显示])...
->+[.]"pt1"(+[matlab],空间点#1)->+[.]"pt2"(+[matlab],空间点#2)...
->+[显示](,光线)

显示所有元件朝着的方向
[]=>_元件{经过(,_元件)}->朝着(_元件,方向)...
=>+[标题](_元件,)->+[修改内容]"%s: "(+[标题],+[显示])->+[显示](,方向)

+[显示](,_元件)

行了, 接下来把所有的元件都安装上2'的镜子我们就结束吧. 

镜子::
+[创建反射镜](,镜子)->+[设置结构](,镜子)

实验场景=>的(实验场景,_re)->_re"M"=>+是(_re,镜子)


+[显示光路场景结构](,实验场景)
+[显示星图](,实验场景)
## end
#1201, 4:
1235
## end
#1204, 197:

_输出->空间位置(_输出,)->在(_输出,空间点)...
->_光路->光路1(_光路,)->新(_光路,光线#2)->的(光线#2,终点)...
->+[python]"ans=[pt[0]*20,-pt[1]*20]"(Python,终点)->+[.]"pt"(+[python],空间点);

_光路->光路1(_光路,)->新(_光路,光线#2)...
->+[del](,新);
## end
#1206, 4129:

import bpy
from bpy import context, data, ops
from mathutils import Euler, Matrix, Quaternion, Vector
import numpy as np

pi=np.pi


def lens_prototype(name,D,dc,R1,R2):

    # D=1*2.54e-2
    # dc=4e-3
    # R1=1
    # R2=1
    
    N1=200
    N2=200
    N=N1+N2
    
    theta1=np.arcsin(D/2/R1)
    theta2=np.arcsin(D/2/R2)
    de=dc-R1*(1-np.cos(theta1))-R2*(1-np.cos(theta2))
    z01=-R1*np.cos(theta1)
    z02=R2*np.cos(theta2)-de
    
    t1=np.linspace(0,theta1,N1)
    t2=np.linspace(-theta2,0,N2)+np.pi
    
    x1=R1*np.sin(t1)
    z1=R1*np.cos(t1)+z01
    x2=R2*np.sin(t2)
    z2=R2*np.cos(t2)+z02
    
    x=np.concatenate((x1,x2))
    z=np.concatenate((z1,z2))
    y=0*z
    
    ops.curve.primitive_bezier_curve_add(enter_editmode=True)
    #ops.curve.primitive_nurbs_path_add(enter_editmode=True)
    ops.curve.subdivide(number_cuts=N-2)
    ops.object.mode_set(mode='OBJECT')
    curve=context.active_object
    curve.name=name
    bez_points = curve.data.splines[0].bezier_points
    
    for i in range(0,N):
        bez_points[i].co=Vector((x[i],y[i],z[i]))
        if i>0:
            bez_points[i].handle_left_type='VECTOR'
        if i<N-1:
            bez_points[i].handle_right_type='VECTOR'
    
    screw=curve.modifiers.new(name='Screw',type='SCREW')
    screw.axis='Z'
    screw.angle=2*np.pi
    screw.render_steps=64
    screw.steps=64

    return curve


def mirror_prototype(name,D,dc):
    bpy.ops.mesh.primitive_cylinder_add(radius=D/2,depth=dc)
    mirror=bpy.context.selected_objects[0]
    mirror.name=name
    return mirror

def mirror_rect_prototype(name,W,H,d):
    bpy.ops.mesh.primitive_cube_add(scale=(H,W,d))
    mirror=bpy.context.selected_objects[0]
    mirror.name=name
    return mirror


def cylindrical_mirror_prototype(name,D,dc,f,H):

    # D=1*2.54e-2
    # dc=2e-3
    # f=1
    # H=0.5*2.54e-2

    n=50
    N=4*n
    R=2*f
    theta0=np.arcsin(D/2/R)
    z0=R

    t=np.linspace(-theta0,theta0,N-2)
    
    x1=R*np.sin(t)
    z1=-R*np.cos(t)+z0
    
    x=np.concatenate((x1,[D/2,-D/2]))
    z=np.concatenate((z1,[-dc,-dc]))
    y=0*z-H/2
    
    ops.curve.primitive_bezier_circle_add(enter_editmode=True)
    #ops.curve.primitive_nurbs_path_add(enter_editmode=True)
    ops.curve.subdivide(number_cuts=n-1)
    ops.object.mode_set(mode='OBJECT')
    curve=context.active_object
    curve.name=name
    bez_points = curve.data.splines[0].bezier_points
    
    print(bez_points,len(bez_points))
    
    for i in range(0,N):
        bez_points[i].co=Vector((x[i],y[i],z[i]))
        bez_points[i].handle_left_type='VECTOR'
        bez_points[i].handle_right_type='VECTOR'
    
    screw=curve.modifiers.new(name='Screw',type='SCREW')
    screw.axis='Y'
    screw.angle=0
    screw.screw_offset=H
    screw.render_steps=64
    screw.steps=64

    return curve

def laser_prototype(name,pt0,pt1,d,color,strength):

    # pt0=[0,0,0]
    # pt1=[1,1,10]
    
    x=[pt0[0],pt1[0]]
    y=[pt0[1],pt1[1]]
    z=[pt0[2],pt1[2]]
    N=2
    
    ops.curve.primitive_bezier_curve_add(enter_editmode=True)
    #ops.curve.primitive_nurbs_path_add(enter_editmode=True)
    ops.object.mode_set(mode='OBJECT')
    curve=context.active_object
    curve.name=name
    bez_points = curve.data.splines[0].bezier_points
    
    for i in range(0,N):
        bez_points[i].co=Vector((x[i],y[i],z[i]))
        bez_points[i].handle_left_type='VECTOR'
        bez_points[i].handle_right_type='VECTOR'
    
    curve.data.bevel_depth=d
    
    mat=bpy.data.materials.new(name="laser_light")
    mat.use_nodes=True
    nodes=mat.node_tree.nodes
    
    nodes.clear()
    
    # create emission node
    node_emission = nodes.new(type='ShaderNodeEmission')
    node_emission.inputs[0].default_value = color  # green RGBA
    node_emission.inputs[1].default_value = strength # strength
    node_emission.location = 0,0
    
    # create output node
    node_output = nodes.new(type='ShaderNodeOutputMaterial')   
    node_output.location = 400,0
    links = mat.node_tree.links
    link = links.new(node_emission.outputs[0], node_output.inputs[0])
    
    curve.data.materials.append(mat)

%输出
## end
#1208, 341:

_代码->代码(_代码,)->空间点#1->位置(空间点#1,)...
->_光路->光路1(_光路,)->旧(_光路,空间点#2)...
->+[临时文本]"laser_prototype('Laser',[%输入],[%输出],0.1,(1,0,0,1),25.0)
"->+[模板文本](+[临时文本],+[临时文本])...
->+[.]"输出"(+[模板文本],空间点#1)...
->+[.]"输入"(+[模板文本],空间点#2)...
->+[增加内容](+[临时文本],_代码);

_光路->光路1(_光路,)->旧(_光路,)->+[del](,旧);
_光路->光路1(_光路,):->输入,
->空间点->位置(空间点,)->+旧(_光路,空间点);



## end
#1211, 451:

_元件->元件(_元件,)->_代码->代码(_代码,)...
->在(_元件,空间点)->朝着(_元件,方向)...
->是(_元件,_类型):
    ->[is](_类型,光栅)->+[三维光栅](_元件,光栅)->+[Blender](+[三维光栅],)...
->+[增加内容]"%s
"(+[Blender],_代码),
    ->[is](_类型,镜子)->+[三维反射镜](_元件,镜子)->+[Blender](+[三维反射镜],)...
->+[增加内容]"%s
"(+[Blender],_代码),
    ->[is](_类型,晶体)->+[三维光栅](_元件,晶体)->+[Blender](+[三维光栅],)...
->+[增加内容]"%s
"(+[Blender],_代码),
    ->[is](_类型,柱面镜)->+[三维柱面镜](_元件,柱面镜)->+[Blender](+[三维柱面镜],)...
->+[增加内容]"%s
"(+[Blender],_代码)
## end
#1220, 1965:
"""
+[返回目录](,操作序列)
+[新建阅读窗口](,操作序列)

"""

_光路->光路(_光路,)...
->+光线光路->+元件=>的(_光路,_节点):
    ->经过(,_节点)=>+[有](+元件,_节点),
    ->经过(_节点,)=>+[有](+光线光路,_节点);


_代码->代码(_代码,)->光线光路=>的(光线光路,_光路)...
=>+光路{
    的(_光路,输出)->输出(,_元件)...
    ->+[S函数](,反射步骤)->+[的](+[S函数],_代码)...
    ->+[的](+[S函数],+光路)->+[光路1](+光路,):
        ->_元件->在(_元件,空间点)->+[的](+[S函数],空间点)->+[位置](空间点,),
        ->在(输出,空间点#0)->+[的](+[S函数],空间点#0)->+[位置](空间点#0,)
}...

->[]{
    []=>经过(_光路,_元件)->_元件(,)->[]{[]:->反射(_元件,_光路),->反射(经过,)}...
    =>在(_元件,空间点)...
    ->+[S函数](,反射步骤)->+[的](+[S函数],_代码)...
    ->+[的](+[S函数],+光路)->+[光路1](+光路,)...
    ->+[的](+[S函数],空间点)->+[位置](空间点,)
}...

->[]{
    反射步骤:->分出来(,_光路)->从(分出来,经过)->经过(,_元件1)->在(_元件1,空间点#1)...
    ->+光线->+的(_画板,+光线)...
    ->+[S函数](,反射步骤)->+[的](+[S函数],_代码)...
    ->+[的](+[S函数],+光路)->+[光路1](+光路,)...
    ->+[的](+[S函数],空间点#1)->+[位置](空间点#1,)...
    ->+[的](+[S函数],+光线)->+[分光光线](+光线,),

    ->的(_光路,输入)->输入(,_元件)->+[S函数](,反射步骤)...
    ->+[的](+[S函数],输入)->+[的](+[S函数],_代码)...
    ->+[的](+[S函数],+光路)->+[光路1](+光路,):
        ->_元件->在(_元件,空间点)->+[的](+[S函数],空间点)->+[位置](空间点,),
        ->在(输入,空间点#0)->+[的](+[S函数],空间点#0)->+[位置](空间点#0,)
}->+[del](,+光路)






_代码->代码(_代码,)->元件=>的(元件,_元件)...
=>+[S函数](,这些事情)->+的(+[S函数],_元件)->+[del](,+的)->+[元件](_元件,)...
->+的(+[S函数],_代码)->+[del](,+的);



_代码->代码(_代码,)...
->+[模板文本](三维整体模板,_代码)->+[.](+[模板文本],_代码);

+[del](,光线光路)->+[del](,元件)=>新节点=>+[del](,新节点);


"""
三维场景::
三维整体模板:...
+[修改标题]"三维整体模板"(,追踪整体模板)
+[新建阅读窗口](,三维整体模板)

这些事情::
_元件->元件(_元件,)->_代码->代码(_代码,)...
->在(_元件,空间点)->朝着(_元件,方向)...
->是(_元件,_类型):
    ->[is](_类型,光栅)->+[三维光栅](_元件,光栅)->+[Blender](+[三维光栅],)...
->+[增加内容]"%s
"(+[Blender],_代码),
    ->[is](_类型,镜子)->+[三维反射镜](_元件,镜子)->+[Blender](+[三维反射镜],)...
->+[增加内容]"%s
"(+[Blender],_代码),
    ->[is](_类型,晶体)->+[三维光栅](_元件,晶体)->+[Blender](+[三维光栅],)...
->+[增加内容]"%s
"(+[Blender],_代码),
    ->[is](_类型,柱面镜)->+[三维柱面镜](_元件,柱面镜)->+[Blender](+[三维柱面镜],)...
->+[增加内容]"%s
"(+[Blender],_代码)


入射步骤::
分光步骤::
反射步骤:...
透射步骤::

+[设置结构](,操作序列)

"""
## end
#1222, 287:
"""
+[返回目录](,逻辑结构转3D场景)
+[新建阅读窗口](,逻辑结构转3D场景)
操作序列(S代码):...
+[新建阅读窗口](,操作序列)

"""

+逻辑结构转3D场景(_光路,_代码)->+[del](,+逻辑结构转3D场景)...
->的(逻辑结构转3D场景,操作序列)...
->+[S函数](_光路,操作序列)->+[的](+[S函数],_光路)->+[光路](_光路,)...
->+[的](+[S函数],+输出)->+代码(+输出,)->+[del](,+代码)...

->+[修改内容](+输出,_代码)->+[del](,+输出)




## end
#1225, 883:
_结构->路线(_结构,)...
->光线光路=>的(光线光路,_光路)=>[]{
[]=>经过(_光路,_元件)->_元件=>[]:
    ->[]{[]:->反射(_元件,_光路),->反射(经过,),->的(_光路,输入)->输入(,_元件)}...
    ->+的(_结构,+光线)->+终点(+光线,_元件)->+是(+终点,经过)...

->+[显示]"反射: "(,_元件)->+[有](_结构,+终点)->+[有](_结构,+光线)->+[有](_结构,+是)...

    ->[]{
        []:->的(_结构,光线)->光线->[]{[]&:=>旧(光线,),=>[is](光线,+光线)}->+[左连](光线,+光线)->+[旧](光线,)->+起点(光线,_元件)->+是(+起点,经过)...

->+[有](_结构,+起点)->+[有](_结构,+是)->+[显示]"设置光线: "(,光线),

        ->+[显示]"eeeeee...."(,_元件)
    },
    ->的(_结构,光线#2)->光线#2->[]{[]=>旧(光线#2,)}->+穿过(光线#2,_元件)->+是(+穿过,经过)->+[显示]"经过: "(,_元件)...

->+[有](_结构,+穿过)->+[有](_结构,+是)

}:
->的(_光路,输入)->+[显示]"输入: "(,输入)->的(_结构,光线#3)->光线#3->[]{[]=>旧(光线#3,)}->+起点(光线#3,输入)->+[旧](光线#3,)...
->+[有](_结构,+起点),

->分出来(_主光,_光路)->从(分出来,经过)->经过(_主光,_分光镜)...
->的(_结构,光线#4)->光线#4->[]{[]=>旧(光线#4,)}->+起点(光线#4,_分光镜)->+是(+起点,从)->+[旧](光线#4,)...
->+[有](_结构,+起点)->+[有](_结构,+是)...
->+[显示]"输入: "(,_分光镜);
## end
#1227, 290:
_结构->路线(_结构,)...
->光线光路=>的(光线光路,_光路)=>+的(_结构,+光路)->+光路->[]{
[]=>经过(_光路,_元件)->_元件=>[]:
    ->[]{[]:->反射(_元件,_光路),->反射(经过,),->的(_光路,输出)->输出(,_元件)}->+[显示]"反射: "(,_元件),

    ->+[显示]"经过: "(,_元件)

}:
->的(_光路,输入)->+[显示]"输入: "(,输入),

->分出来(_主光,_光路)->从(分出来,经过)->经过(_主光,_分光镜)...
->+[显示]"输入: "(,_分光镜);
## end
#1228, 4:
1241
## end
#1231, 786:
"""
+[返回目录](,方向)
+[复制结构](,方向)


+方向(光线,)->起点(光线,_元件1)->[位置]#1(_元件1,)...
->终点(光线,_元件2)->[位置]#2(_元件2,)...
->+[.]"pt1"([python],[位置]#1)->+[.]"pt2"([python],[位置]#2)...
->[python]"dp=np.array([pt2[0]-pt1[0],pt2[1]-pt1[1],pt2[2]-pt1[2]])
dp=dp/np.sqrt(np.sum(dp*dp))
ans=list(dp)
state=True"(Python,+方向); 


"""

+方向(光线,)->[起点](光线,)->[终点](光线,)...
->+[.]"pt1"([python],[起点])->+[.]"pt2"([python],[终点])...
->[python]"dp=np.array([pt2[0]-pt1[0],pt2[1]-pt1[1],pt2[2]-pt1[2]])
dp=dp/np.sqrt(np.sum(dp*dp))
ans=list(dp)
state=True"(Python,+方向); 

+方向(_元件1,_元件2)...
->[位置]#1(_元件1,)->[位置]#2(_元件2,)...
->+[.]"pt1"([python],[位置]#1)->+[.]"pt2"([python],[位置]#2)...
->[python]"dp=np.array([pt2[0]-pt1[0],pt2[1]-pt1[1],pt2[2]-pt1[2]])
dp=dp/np.sqrt(np.sum(dp*dp))
ans=list(dp)
state=True"(Python,+方向); 





## end
#1233, 896:
"""
+[返回目录](,自动调整镜子方向)

"""

+自动调整镜子方向(,_元件)->+[del](,+自动调整镜子方向)...
->Matlab->+[matlab]"addpath('Matlab/space')"(Matlab,)->朝着(_元件,方向)->[]:

->起点(光线#1,_元件)->光线#1(光线#0,)...
->[方向](光线#0,)->+[修改内容](,+[临时文本]#0)->[m_text]([方向],+[修改内容])...
->[方向](光线#1,)->+[修改内容](,+[临时文本]#1)->[m_text]([方向],+[修改内容])...
->+[matlab]"
z=z1/norm(z1)-z0/norm(z0);
[alpha,beta,gamma]=Eulers(z(1),z(2),z(3));
ans=[alpha,beta,gamma];
"(Matlab,方向)->+[.]"z0"(+[matlab],+[临时文本]#0)->+[.]"z1"(+[matlab],+[临时文本]#1),

->终点(光线#2,_元件)->[方向](光线#2,)...
->+[修改内容]([方向],+[临时文本]#2)->[m_text]([方向],+[修改内容])...
->+[matlab]"[alpha,beta,gamma]=Eulers(-z(1),-z(2),-z(3));
ans=[alpha,beta,gamma];
"(Matlab,方向)->+[.]"z"(+[matlab],+[临时文本]#2),

->穿过(光线#3,_元件)->[方向](光线#3,)...
->+[修改内容]([方向],+[临时文本]#3)->[m_text]([方向],+[修改内容])...
->+[matlab]"[alpha,beta,gamma]=Eulers(z(1),z(2),z(3));
ans=[alpha,beta,gamma];
"(Matlab,方向)->+[.]"z"(+[matlab],+[临时文本]#3)

## end
#1234, 4:
1247
## end
#1237, 262:
"""
+[返回目录](,自动命名)

"""
+自动命名(,_场景)...
->+[模板文本](+[做],+[做])...
->+[.](+[模板文本],+自动命名)...

->+[做]"
+做(,_场景)->+[del](,+做)->+[python]\"i=0\"(Python,)=>的(_场景,%自动命名)...
=>+[python]\"
ans='%自动命名%d'%(i)
i+=1
\"(Python,+[修改标题])->+[修改标题](,%自动命名)
"(,_场景)->+[del](,+自动命名)



## end
#1239, 455:
"""
+[返回目录](,设置位置)
+[复制结构](,设置位置)

"""
+设置位置(,_泵光1)->+[del](,+设置位置)...
->+[python]"name0=''"(Python,)...
->+[临时文本]->[]{
    []=>经过(_泵光1,_元件)...
    =>+[标题](_元件,)->+[python]"
if name0=='':
    ans=''
else:
    ans='+[相对]\"\"(%s)\n'%(name+','+name0)+ans
name0=name
    "(Python,+[临时文本])->+[s]"name"(+[python],+[标题])
}...

->+[python]"
ans='在(%s,空间点)->+[修改内容]\"\"(,空间点)\n'%(name0)+ans
"(Python,+[临时文本])...

->+[修改内容](+[临时文本],+[显示])->+[显示]->+[复制内容](,+[显示])



## end
#1241, 214:
"""
+[返回目录](,对齐X)

"""

+对齐X(_M1,_M2)->+[del](,+对齐X)...
->[物体](_M1,)->在([物体],_位置1)...
->[物体](_M2,)->在([物体],_位置2)...
->+[matlab]"pt2(1)=pt1(1);"(Matlab,)...
->+[.]"pt1"(+[matlab],_位置1)->+[o]"pt2"(+[matlab],_位置2)




## end
#1243, 214:
"""
+[返回目录](,对齐Y)

"""

+对齐Y(_M1,_M2)->+[del](,+对齐Y)...
->[物体](_M1,)->在([物体],_位置1)...
->[物体](_M2,)->在([物体],_位置2)...
->+[matlab]"pt2(2)=pt1(2);"(Matlab,)...
->+[.]"pt1"(+[matlab],_位置1)->+[o]"pt2"(+[matlab],_位置2)




## end
#1247, 883:
_结构->路线(_结构,)...
->光线光路=>的(光线光路,_光路)=>[]{
[]=>经过(_光路,_元件)->_元件=>[]:
    ->[]{[]:->反射(_元件,_光路),->反射(经过,),->的(_光路,输出)->输出(,_元件)}...
    ->+的(_结构,+光线)->+终点(+光线,_元件)->+是(+终点,经过)...

->+[显示]"反射: "(,_元件)->+[有](_结构,+终点)->+[有](_结构,+光线)->+[有](_结构,+是)...

    ->[]{
        []:->的(_结构,光线)->光线->[]{[]&:=>旧(光线,),=>[is](光线,+光线)}->+[左连](光线,+光线)->+[旧](光线,)->+起点(光线,_元件)->+是(+起点,经过)...

->+[有](_结构,+起点)->+[有](_结构,+是)->+[显示]"设置光线: "(,光线),

        ->+[显示]"eeeeee...."(,_元件)
    },
    ->的(_结构,光线#2)->光线#2->[]{[]=>旧(光线#2,)}->+穿过(光线#2,_元件)->+是(+穿过,经过)->+[显示]"经过: "(,_元件)...

->+[有](_结构,+穿过)->+[有](_结构,+是)

}:
->的(_光路,输入)->+[显示]"输入: "(,输入)->的(_结构,光线#3)->光线#3->[]{[]=>旧(光线#3,)}->+起点(光线#3,输入)->+[旧](光线#3,)...
->+[有](_结构,+起点),

->分出来(_主光,_光路)->从(分出来,经过)->经过(_主光,_分光镜)...
->的(_结构,光线#4)->光线#4->[]{[]=>旧(光线#4,)}->+起点(光线#4,_分光镜)->+是(+起点,从)->+[旧](光线#4,)...
->+[有](_结构,+起点)->+[有](_结构,+是)...
->+[显示]"输入: "(,_分光镜);
## end
#1248, 4:
1256
## end
#1250, 4:
1252
## end
#1252, 4:
1266
## end
#1255, 64:
+[返回目录](,模板集合)

14通光路:...
Stretch光路:...
第一级放大:...
第二级放大:...





## end
#1257, 6241:
+[返回目录](,场景)
+[显示星图](,场景)
+[删除结构](,场景)

Faraday

有一束种子光和两束泵光
+种子光->+泵光1->+泵光2

被多次经过的元件有, G1, C1, C2 和 M15, M16, Mask1, D1, W1, Chamber, Crystal, W2, D2, Mask2, M8, M9 和 G2, G3
+G1->+C1->+C2
+M15->+M16->+Mask1->+D1->+W1->+Crystal->+W2->+D2->+Mask2->+M8->+M9
+G2->+G3

+[修改标题]"M30"(,M8)
+[修改标题]"M31"(,M9)
+[修改标题]"M32"(,M15)
+[修改标题]"M33"(,M16)

泵光1经过X, BS, M, M, L, L, M, L, D1, W1, Crystal
+X->+BS->+M->+M->+L->+L->+M->+L->D1->W1->Crystal=>[那](_,)=>+经过(泵光1,_)

在BS上, 从泵光1分出来了泵光2, 然后经过M, L, L, M, L, D2, W2, Chamber, Crystal
经过(泵光1,BS)->+分出来(泵光1,泵光2)->+从(+分出来,经过)
+M->+L->+L->+M->+L->D2->W2->Crystal=>[那](_,)=>+经过(泵光2,_)

种子光经过Vitara, CEP, P, M, I, X, M, I, G1, C1, C2, C1, G1, P, G1, C1, C2, C1, G1, M, M, M, Faraday, I, M, M, Mask1, D1, W1, Crystal, W2, D2, Mask2, M8, M9, Mask2, M, P, X, Pockel cell, I, X, X, L, L, M, M, I, M, M, Mask2, M8, M9, Mask2, D2, W2, Crystal, W1, D1, Mask1, M16, M15, Mask1, D1, W1, Crystal, W2, D2, Mask2, M8, M9, Mask2, D2, W2, Crystal, W1, D1, Mask1, M, M, I, X, X, X, I, G2, G3, P, G3, G2, M, P, M, I, L, I, M, M, HCF, M, M, I 
(我把那可怕的十六通写出来吧. )

G3->G2(,)...
->+M->+P->+M->+I->+L->+I->+M->+M->+HCF->+M->+M->+I(,)...
=>[那](_,)=>+经过(种子光,_)

+M->+M->+I->+X->+X->+X->+I(,)...
->G2->G3->+P(,)...
=>[那](_,)=>+经过(种子光,_)

Mask2->D2->W2->Crystal->W1->D1->Mask1(,)...
=>[那](_,)=>+经过(种子光,_)

Mask1->D1->W1->Crystal->W2->D2->Mask2->M8->M9(,)...
=>[那](_,)=>+经过(种子光,_)
Mask2->D2->W2->Crystal->W1->D1->Mask1->M15->M16(,)...
=>[那](_,)=>+经过(种子光,_)
Mask1->D1->W1->Crystal->W2->D2->Mask2->M8->M9(,)...
=>[那](_,)=>+经过(种子光,_)
Mask2->D2->W2->Crystal->W1->D1->Mask1->M15->M16(,)...
=>[那](_,)=>+经过(种子光,_)
Mask1->D1->W1->Crystal->W2->D2->Mask2->M8->M9(,)...
=>[那](_,)=>+经过(种子光,_)
Mask2->D2->W2->Crystal->W1->D1->Mask1->M15->M16(,)...
=>[那](_,)=>+经过(种子光,_)
Mask1->D1->W1->Crystal->W2->D2->Mask2->M8->M9(,)...
=>[那](_,)=>+经过(种子光,_)
Mask2->D2->W2->Crystal->W1->D1->Mask1->M15->M16(,)...
=>[那](_,)=>+经过(种子光,_)

+M->+P->+X->+Pockel cell->+I->+X->+X->+L->+L->+M->+M->+I->+M->+M(,)...
->Mask2->M8->M9(,)...
=>[那](_,)=>+经过(种子光,_)
Mask2(,)...
=>[那](_,)=>+经过(种子光,_)

Mask1->D1->W1->Crystal->W2->D2->Mask2->M8->M9(,)...
=>[那](_,)=>+经过(种子光,_)
Mask2->D2->W2->Crystal->W1->D1->Mask1->M15->M16(,)...
=>[那](_,)=>+经过(种子光,_)
Mask1->D1->W1->Crystal->W2->D2->Mask2->M8->M9(,)...
=>[那](_,)=>+经过(种子光,_)
Mask2->D2->W2->Crystal->W1->D1->Mask1->M15->M16(,)...
=>[那](_,)=>+经过(种子光,_)
Mask1->D1->W1->Crystal->W2->D2->Mask2->M8->M9(,)...
=>[那](_,)=>+经过(种子光,_)
Mask2->D2->W2->Crystal->W1->D1->Mask1->M15->M16(,)...
=>[那](_,)=>+经过(种子光,_)
Mask1->D1->W1->Crystal->W2->D2->Mask2->M8->M9(,)...
=>[那](_,)=>+经过(种子光,_)
Mask2->D2->W2->Crystal->W1->D1->Mask1->M15->M16(,)...
=>[那](_,)=>+经过(种子光,_)

Mask1->D1->W1->Crystal->W2->D2->Mask2->M8->M9(,)...
=>[那](_,)=>+经过(种子光,_)

C1->G1->+M->+M->+M(,)...
->+Faraday->+I->+M(,)...
->+M(,)...
=>[那](_,)=>+经过(种子光,_)

G1->C1->C2(,)...
=>[那](_,)=>+经过(种子光,_)

C1->G1->+P(,)...
=>[那](_,)=>+经过(种子光,_)

+Vitara->+CEP->+P->+M->+I->+X->+M->+I(,)...
->G1->C1->C2(,)...
=>[那](_,)=>+经过(种子光,_)






所有的镜子M都按顺序命名为Mi. Iris, 透镜, 爬高镜和X都用同样的方法命名. 
+[自动命名]"M"(,场景)
+[自动命名]"I"(,场景)
+[自动命名]"L"(,场景)
+[自动命名]"X"(,场景)
+[自动命名]"P"(,场景)

依次显示种子光经过的元件. 
种子光=>经过(种子光,_元件)=>+[显示](,_元件)

位置::
所有被光线经过的东西都是元件, 都有空间位置
场景=>的(场景,_元件)->[]{经过(,_元件)}=>+的(位置,+空间点)->+在(_元件,+空间点)

显示所有泵光1经过的元件
泵光1=>经过(泵光1,_元件)=>+[显示](,_元件)
设置泵光1的元件
在(X7,空间点)->+[修改内容]"100,40,0"(,空间点)
+[设置位置](,泵光1)
+[相对]"0,-5,0"(X7,BS)
+[相对]"0,-5,0"(BS,M22)
+[相对]"-50,0,0"(M22,M23)
+[相对]"0,-5,0"(M23,L6)
+[相对]"0,-10,0"(L6,L7)
+[相对]"0,-25,0"(M23,M24)
+[相对]"2,0,0"(M24,L8)

设置泵光2的元件
+[设置位置](,泵光2)
+[相对]"15,0,0"(BS,M20)
+[相对]"0,-5,0"(M20,L3)
+[相对]"0,-10,0"(L3,L4)
+[相对]"0,-30,0"(M20,M21)
+[相对]"-2,0,0"(M21,L5)

在(Crystal,空间点)->+[修改内容]"85,5,0"(,空间点)
+[相对]"10,0,0"(Crystal,W2)
+[相对]"20,0,0"(Crystal,D2)
+[相对]"-10,0,0"(Crystal,W1)
+[相对]"-20,0,0"(Crystal,D1)
+[相对]"10,3,0"(D1,Mask1)
+[相对]"2,1,0"(Mask1,M32)
+[相对]"0,2,0"(M32,M33)
+[相对]"-10,-3,0"(D2,Mask2)
+[相对]"-2,-1,0"(Mask2,M30)
+[相对]"0,-2,0"(M30,M31)
+[相对]"3,1,0"(Mask2,M7)

显示所有泵光1经过的元件
种子光=>经过(种子光,_元件)=>+[显示](,_元件)
设置种子光的元件
+[设置位置](,种子光)
在(CEP,空间点)->+[修改内容]"0,30,0"(,空间点)
+[相对]"0,-30,0"(CEP,Vitara)
+[相对]"5,0,0"(CEP,P0)
+[相对]"0,10,0"(P0,M0)
+[相对]"3,0,0"(M0,I0)
+[相对]"5,0,0"(I0,X0)
在(M1,空间点)->+[修改内容]"42,4,0"(,空间点)->+[对齐Y](M0,M1)
+[相对]"-1.5,-2,0"(M1,I1)

在(G1,空间点)->+[修改内容]"30,0,0"(,空间点)
+[相对]"0,15,0"(G1,C2)
+[相对]"0,35,0"(G1,C1)
+[相对]"8,8,0"(C2,P1)
+[相对]"5,5,0"(C2,M2)
+[相对]"-10,0,0"(M2,M3)

在(Faraday,空间点)->+[修改内容]"55,32,0"(,空间点)
+[对齐X](M3,M4)->+[对齐Y](Faraday,M4)
+[相对]"20,0,0"(Faraday,I2)

在(Pockel cell,空间点)->+[修改内容]"100,15,0"(,空间点)
+[对齐Y](Pockel cell,P2)->+[对齐X](M7,P2)
+[相对]"1,0,0"(P2,X1)
+[相对]"2,0,0"(Pockel cell,I3)
+[相对]"2,0,0"(I3,X2)
+[相对]"2,0,0"(X2,X3)
+[相对]"2,0,0"(X3,L0)
+[相对]"2,0,0"(L0,L1)
+[相对]"12,0,0"(Pockel cell,M8)
+[相对]"0,5,0"(M8,M9)
+[相对]"-3,0,0"(M9,I4)
+[相对]"-10,0,0"(M9,M10)
在(M11,空间点)->+[修改内容]"0,4,0"(,空间点)->+[对齐X](M10,M11)


+[相对]"5,0,0"(Mask1,M6)
+[对齐X](M6,M5)->+[对齐Y](Faraday,M5)
+[相对]"5,0,0"(M6,M12)

在(G2,空间点)->+[修改内容]"55,15,0"(,空间点)
+[对齐X](M12,M13)->+[对齐Y](G2,M13)
+[相对]"-5,0,0"(M13,I5)
+[相对]"-5,0,0"(I5,X4)
+[相对]"-2,0,0"(X4,X5)
+[相对]"-2,0,0"(X5,X6)
+[相对]"-2,0,0"(X6,I6)

+[相对]"5,5,0"(G2,G3)
+[相对]"-6,0,0"(G3,P3)
+[相对]"3,0,0"(G2,M14)
+[相对]"0,-10,0"(M14,P4)
+[相对]"0,-3,0"(P4,M15)
+[相对]"5,0,0"(M15,I7)
+[相对]"20,0,0"(M15,L2)
+[相对]"5,0,0"(L2,I8)
+[相对]"30,0,0"(M15,M16)
+[对齐X](M16,M17)->+[对齐Y](HCF,M17)

在(HCF,空间点)->+[修改内容]"60,-5,0"(,空间点)
+[相对]"-20,0,0"(Vitara,M19)->+[对齐Y](HCF,M19)
+[相对]"-20,0,0"(M19,M18)
+[相对]"0,5,0"(M19,I9)


显示种子光和泵光光路
+[matlab]"clf"(Matlab,)...
->+[显示光路](+[matlab],泵光1)->+[显示光路](+[matlab],泵光2)...
->+[显示光路](+[matlab],种子光)

所有经过了镜子的光线都被那面镜子反射. 
[]=>经过(_光线,_re)->_re"M"=>+反射(经过,)
[]=>经过(_光线,_re)->_re"P"=>+反射(经过,)
[]=>经过(_光线,_re)->_re"C"=>+反射(经过,)
[]=>经过(_光线,_re)->_re"G"=>+反射(经过,)
除了Mask
[]=>经过(,_re)->_re"Mask"->反射(经过,)=>+[del](,反射)


种子光经过D的时候都会被反射
种子光=>经过(种子光,_re)->_re"D"=>+反射(经过,)

种子光输出的元件是I9, 输入元件是Vitara. 
泵光1的输入是X9, 输出是Crystal
泵光2的输出是Crystal
+的(种子光,+输出)->+输出(,I9)->+的(种子光,+输入)->+输入(,Vitara)
+的(泵光1,+输出)->+输出(,Crystal)->+的(泵光1,+输入)->+输入(,X7)
+的(泵光2,+输出)->+输出(,Crystal)



测试结构:...
+[场景结构转路线结构](场景,测试结构)
+[删除结构](,测试结构)
+[设置结构](,测试结构)


位置::
所有被光线经过的东西都是元件, 都朝着某个方向
场景=>的(场景,_元件)->[]{经过(,_元件)}=>+朝着(_元件,+方向)

自动调整所有元件的方向. 
场景=>的(场景,_元件)->[]{经过(,_元件)}=>+[自动调整镜子方向](,_元件)


+[显示光路场景结构](,场景)
+[显示星图](,测试结构)
## end
#1259, 453:
"""
+[返回目录](,经过元件)

"""

+经过元件(_描述,_输出)->+[del](,+经过元件)...
->+[python]"
light=string.split('经过')[0]
string=string.split('经过')[1]
list_ele=string.split(', ')

out='%s->+经过(%s,%s)'%(list_ele[0],light,list_ele[0])
for i in range(1,len(list_ele)):
    out+='->%s->+经过(%s,%s)'%(list_ele[i],light,list_ele[i])
"(Python,)->+[.]"string"(+[python],_描述):
    ->_输出->+[o]"out"(+[python],_输出)->+[复制内容](,_输出),
    ->+[o]"out"(+[python],+[临时文本])->+[复制内容](,+[临时文本])



## end
#1260, 4:
1273
## end
#1263, 2335:
+[返回目录](,场景)
+[显示星图](,场景)
+[删除结构](,场景)

有一束种子光和一束泵光
+种子光->+泵光

被多次经过的元件有, G1, C1, C2
+G1->+C1->+C2

描述::泵光经过+Nimma, +M, +P, +1st
+[经过元件](描述,+[显示])
+1st->+经过(泵光,+1st)->+P->+经过(泵光,+P)->+M->+经过(泵光,+M)->+Nimma->+经过(泵光,+Nimma)

描述::种子光经过+14 Pass, +M, +I, +X, +X, +I, +I, +M, +M, G1, C1, C2, C1, G1, +P, G1, C1, C2, C1, G1, +M, +I, +1st
+[经过元件](描述,+[显示])
+1st->+经过(种子光,+1st)->+I->+经过(种子光,+I)->+M->+经过(种子光,+M)->G1->+经过(种子光,G1)->C1->+经过(种子光,C1)->C2->+经过(种子光,C2)->C1->+经过(种子光,C1)->G1->+经过(种子光,G1)->+P->+经过(种子光,+P)->G1->+经过(种子光,G1)->C1->+经过(种子光,C1)->C2->+经过(种子光,C2)->C1->+经过(种子光,C1)->G1->+经过(种子光,G1)->+M->+经过(种子光,+M)->+M->+经过(种子光,+M)->+I->+经过(种子光,+I)->+I->+经过(种子光,+I)->+X->+经过(种子光,+X)->+X->+经过(种子光,+X)->+I->+经过(种子光,+I)->+M->+经过(种子光,+M)->+14 Pass->+经过(种子光,+14 Pass)



所有的镜子M都按顺序命名为Mi. Iris, 透镜, 爬高镜和X都用同样的方法命名. 
+[自动命名]"M"(,场景)
+[自动命名]"I"(,场景)
+[自动命名]"L"(,场景)
+[自动命名]"X"(,场景)
+[自动命名]"P"(,场景)

依次显示种子光经过的元件. 
种子光=>经过(种子光,_元件)=>+[显示](,_元件)

+位置
位置
所有被光线经过的东西都是元件, 都有空间位置
场景=>的(场景,_元件)->[]{经过(,_元件)}=>+的(位置,+空间点)->+在(_元件,+空间点)

显示所有泵光1经过的元件
泵光=>经过(泵光,_元件)=>+[显示](,_元件)
设置泵光的元件
+[设置位置](,泵光)
在(Nimma,空间点)->+[修改内容]"0,0,0"(,空间点)
+[相对]"4,0,0"(Nimma,M4)
+[相对]"0,-10,0"(M4,P1)
+[相对]"0,-25,0"(P1,1st)->经过(泵光,1st)



设置种子光的元件
+[设置位置](,种子光)
在(M3,空间点)->+[修改内容]"50,-30,0"(,空间点)
+[相对]"0,40,0"(M3,14 Pass)
+[相对]"-2,0,0"(M3,I3)
+[相对]"-2,0,0"(I3,X1)
+[相对]"-2,0,0"(X1,X0)
+[相对]"-15,0,0"(M3,I2)
+[相对]"-40,0,0"(M3,M2)
+[相对]"3,0,0"(M2,I1)
+[相对]"10,5,0"(M2,M1)
+[相对]"-15,15,0"(M1,G1)
+[相对]"10,0,0"(G1,C1)
+[相对]"10,0,0"(C1,C2)
+[相对]"-4,4,0"(M1,P0)
+[相对]"-7,7,0"(M1,M0)->经过(种子光,M0)
+[相对]"0,-3,0"(M0,I0)->经过(种子光,M0)
+[对齐X](I0,1st)->+[对齐Y](1st#1,1st)->经过(种子光,1st)->经过(泵光,1st#1)

[]=>1st=>+[修改内容]"1,1,0"(,1st)


显示种子光和泵光光路
+[matlab]"clf"(Matlab,)...
->+[显示光路](+[matlab],泵光)->+[显示光路](+[matlab],种子光)

所有经过了镜子的光线都被那面镜子反射. 
[]=>经过(_光线,_re)->_re"^M"=>+反射(经过,)
[]=>经过(_光线,_re)->_re"^P"=>+反射(经过,)
[]=>经过(_光线,_re)->_re"^C"=>+反射(经过,)
[]=>经过(_光线,_re)->_re"^G"=>+反射(经过,)


种子光输出的元件是1st, 输入元件是14 Pass. 
泵光的输入是Nimma, 输出是1st
经过(种子光,1st)...
->+的(种子光,+输出)->+输出(,1st)->+的(种子光,+输入)->+输入(,14 Pass)
经过(泵光,1st)...
->+的(泵光,+输出)->+输出(,1st)->+的(泵光,+输入)->+输入(,Nimma)



测试结构:...
+[场景结构转路线结构](场景,测试结构)
+[删除结构](,测试结构)
+[设置结构](,测试结构)


位置::
所有被光线经过的东西都是元件, 都朝着某个方向
场景=>的(场景,_元件)->[]{经过(,_元件)}=>+朝着(_元件,+方向)

自动调整所有元件的方向. 
场景=>的(场景,_元件)->[]{经过(,_元件)}=>+[自动调整镜子方向](,_元件)


+[显示光路场景结构](,场景)
+[显示星图](,测试结构)
## end
#1264, 4:
1287
## end
#1267, 4414:
+[返回目录](,场景)
+[显示星图](,场景)
+[删除结构](,场景)

有一束种子光和两束泵光
+种子光->+泵光1->+泵光2

被多次经过的元件有, M1, Crystal
+M1->+Crystal

描述::泵光1经过+X, +S, Crystal
+[经过元件](描述,+[显示])
Crystal->+经过(泵光1,Crystal)->+S->+经过(泵光1,+S)->+X->+经过(泵光1,+X)

描述::在S上, 从泵光1分出来了泵光2, 然后经过+M, +X, +M, +M, Crystal
+[经过元件](描述,+[显示])
Crystal->+经过(泵光2,Crystal)->+M->+经过(泵光2,+M)->+M->+经过(泵光2,+M)->+X->+经过(泵光2,+X)->+M->+经过(泵光2,+M)
经过(泵光1,S)->+分出来(泵光1,泵光2)->+从(+分出来,经过)

描述::种子光经过+Stretcher, M1, +M, M1, +M, +I, +X, +Dazzler, +Faraday, +X, +M, +M, +I, Crystal, +I, +X, +X, +M, +M, Crystal, +X, +M, +M, Crystal, +M, +M, Crystal, +M, +M, Crystal, +M, +M, Crystal, +M, +M, Crystal, +2nd
+[经过元件](描述,+[显示])
+2nd->+经过(种子光,+2nd)->Crystal->+经过(种子光,Crystal)->+M->+经过(种子光,+M)->+M->+经过(种子光,+M)->Crystal->+经过(种子光,Crystal)->+M->+经过(种子光,+M)->+M->+经过(种子光,+M)->Crystal->+经过(种子光,Crystal)->+M->+经过(种子光,+M)->+M->+经过(种子光,+M)->Crystal->+经过(种子光,Crystal)->+M->+经过(种子光,+M)->+M->+经过(种子光,+M)->Crystal->+经过(种子光,Crystal)->+M->+经过(种子光,+M)->+M->+经过(种子光,+M)->+X->+经过(种子光,+X)->Crystal->+经过(种子光,Crystal)->+M->+经过(种子光,+M)->+M->+经过(种子光,+M)->+X->+经过(种子光,+X)->+X->+经过(种子光,+X)->+I->+经过(种子光,+I)->Crystal->+经过(种子光,Crystal)->+I->+经过(种子光,+I)->+M->+经过(种子光,+M)->+M->+经过(种子光,+M)->+X->+经过(种子光,+X)->+Faraday->+经过(种子光,+Faraday)->+Dazzler->+经过(种子光,+Dazzler)->+X->+经过(种子光,+X)->+I->+经过(种子光,+I)->+M->+经过(种子光,+M)->M1->+经过(种子光,M1)->+M->+经过(种子光,+M)->M1->+经过(种子光,M1)->+Stretcher->+经过(种子光,+Stretcher)



所有的镜子M都按顺序命名为Mi. Iris, 透镜, 爬高镜和X都用同样的方法命名. 
+[自动命名]"M"(,场景)
+[自动命名]"I"(,场景)
+[自动命名]"X"(,场景)

+[修改标题]"M19"(,M1)

将所有种子光的经过置顶
种子光=>经过(种子光,)=>+[置顶](种子光,经过)
泵光1=>经过(泵光1,)=>+[置顶](泵光1,经过)
泵光2=>经过(泵光2,)=>+[置顶](泵光2,经过)
依次显示种子光经过的元件. 
种子光=>经过(种子光,_元件)=>+[显示](,_元件)

+位置
位置
所有被光线经过的东西都是元件, 都有空间位置
场景=>的(场景,_元件)->[]{经过(,_元件)}=>+的(位置,+空间点)->+在(_元件,+空间点)

显示所有泵光1经过的元件
泵光1=>经过(泵光1,_元件)=>+[显示](,_元件)
泵光2=>经过(泵光2,_元件)=>+[显示](,_元件)


种子光输出的元件是2nd, 输入元件是Stretcher. 
泵光1有输入, 输出是Crystal
泵光2的输出是Crystal
经过(种子光,2nd)...
->+的(种子光,+输出)->+输出(,2nd)->+的(种子光,+输入)->+输入(,Stretcher)
经过(泵光1,Crystal)...
->+的(泵光1,+输出)->+输出(,Crystal)->+的(泵光1,+输入)->+在(+输入,+空间点)->+的(位置,+空间点)
经过(泵光2,Crystal)...
->+的(泵光2,+输出)->+输出(,Crystal)

泵光1=>的(泵光1,输出)->输出(,_元件)->在(_元件,空间点)=>+[显示](,空间点)




设置泵光1的元件
+[设置位置](,泵光1)
在(X6,空间点)->+[修改内容]"0,0,0"(,空间点)
的(泵光1,输入)->+[相对]"0,10,0"(X6,输入)
+[相对]"0,-5,0"(X6,S)
+[相对]"80,0,0"(S,Crystal)

+[设置位置](,泵光2)
+[相对]"0,-18,0"(S,M18)
+[相对]"80,0,0"(Crystal,M16)
+[对齐Y](M18,M17)->+[对齐X](M16,M17)
+[相对]"-10,0,0"(M17,X5)

+[matlab]"clf"(Matlab,)...
->+[显示光路](+[matlab],泵光1)->+[显示光路](+[matlab],泵光2)

M13,M12
M9,M8
M5,M4
M1,M0

M11,M10
M7,M6
M3,M2

设置种子光的元件
+[设置位置](,种子光)
在(Stretcher,空间点)->+[修改内容]"60,30,0"(,空间点)
+[相对]"0,-80,0"(Stretcher,M19)
+[相对]"40,0,0"(M19,M15)
+[相对]"0,-10,0"(Stretcher,M14)
+[相对]"-2,0,0"(M14,I2)
+[相对]"-2,0,0"(I2,X4)
+[相对]"-2,0,0"(X4,Dazzler)
+[相对]"-2,0,0"(Dazzler,Faraday)
+[相对]"-2,0,0"(Faraday,X3)


+[相对]"-25,0,0"(M14,M13)
+[相对]"0,-41.05,0"(M13,M12)
+[相对]"50"(Crystal,M11)->+[沿着](+[相对],)->[方向](M12,Crystal)->[m_text]([方向],+[沿着])
+[相对]"0,-30,0"(M11,M10)
+[相对]"55"(Crystal,M9)->+[沿着](+[相对],)->[方向](M10,Crystal)->[m_text]([方向],+[沿着])
+[相对]"0,-25,0"(M9,M8)
+[相对]"58"(Crystal,M7)->+[沿着](+[相对],)->[方向](M8,Crystal)->[m_text]([方向],+[沿着])
+[相对]"0,-20,0"(M7,M6)
+[相对]"62"(Crystal,M5)->+[沿着](+[相对],)->[方向](M6,Crystal)->[m_text]([方向],+[沿着])
+[相对]"0,-15,0"(M5,M4)
+[相对]"64"(Crystal,M3)->+[沿着](+[相对],)->[方向](M4,Crystal)->[m_text]([方向],+[沿着])
+[相对]"0,-10,0"(M3,M2)
+[相对]"65"(Crystal,M1)->+[沿着](+[相对],)->[方向](M2,Crystal)->[m_text]([方向],+[沿着])
+[相对]"0,-5,0"(M1,M0)


+[相对]"3"(M12,I1)->+[沿着](+[相对],)->[方向](M12,Crystal)->[m_text]([方向],+[沿着])
+[相对]"5"(M11,I0)->+[沿着](+[相对],)->[方向](M11,Crystal)->[m_text]([方向],+[沿着])
+[相对]"3"(M11,X2)->+[沿着](+[相对],)->[方向](M11,Crystal)->[m_text]([方向],+[沿着])
+[相对]"2"(M11,X1)->+[沿着](+[相对],)->[方向](M11,Crystal)->[m_text]([方向],+[沿着])
+[相对]"5"(M9,X0)->+[沿着](+[相对],)->[方向](M9,Crystal)->[m_text]([方向],+[沿着])

+[matlab]"clf"(Matlab,)->+[显示光路](+[matlab],种子光)
+[相对]"120,0,0"(Crystal,2nd)

显示所有元件所在的空间点位置. 
位置=>的(位置,空间点)->在(_元件,空间点)...
=>+[标题](_元件,)->+[修改内容](+[标题],+[显示])->+[显示](,空间点)



显示种子光和泵光光路
+[matlab]"clf"(Matlab,)...
->+[显示光路](+[matlab],泵光1)->+[显示光路](+[matlab],泵光2)...
->+[显示光路](+[matlab],种子光)

所有经过了镜子的光线都被那面镜子反射. 
[]=>经过(_光线,_re)->_re"^M"=>+反射(经过,)
[]=>经过(_光线,_re)->_re"^S"=>+反射(经过,)


测试结构:...
+[场景结构转路线结构](场景,测试结构)
+[删除结构](,测试结构)
+[设置结构](,测试结构)


位置::
所有被光线经过的东西都是元件, 都朝着某个方向
场景=>的(场景,_元件)->[]{经过(,_元件)}=>+朝着(_元件,+方向)

自动调整所有元件的方向. 
场景=>的(场景,_元件)->[]{经过(,_元件)}=>+[自动调整镜子方向](,_元件)


+[显示光路场景结构](,场景)
+[显示星图](,测试结构)
## end
#1269, 883:
_结构->路线(_结构,)...
->光线光路=>的(光线光路,_光路)=>[]{
[]=>经过(_光路,_元件)->_元件=>[]:
    ->[]{[]:->反射(_元件,_光路),->反射(经过,),->的(_光路,输入)->输入(,_元件)}...
    ->+的(_结构,+光线)->+终点(+光线,_元件)->+是(+终点,经过)...

->+[显示]"反射: "(,_元件)->+[有](_结构,+终点)->+[有](_结构,+光线)->+[有](_结构,+是)...

    ->[]{
        []:->的(_结构,光线)->光线->[]{[]&:=>旧(光线,),=>[is](光线,+光线)}->+[左连](光线,+光线)->+[旧](光线,)->+起点(光线,_元件)->+是(+起点,经过)...

->+[有](_结构,+起点)->+[有](_结构,+是)->+[显示]"设置光线: "(,光线),

        ->+[显示]"eeeeee...."(,_元件)
    },
    ->的(_结构,光线#2)->光线#2->[]{[]=>旧(光线#2,)}->+穿过(光线#2,_元件)->+是(+穿过,经过)->+[显示]"经过: "(,_元件)...

->+[有](_结构,+穿过)->+[有](_结构,+是)

}:
->的(_光路,输入)->+[显示]"输入: "(,输入)->的(_结构,光线#3)->光线#3->[]{[]=>旧(光线#3,)}->+起点(光线#3,输入)->+[旧](光线#3,)...
->+[有](_结构,+起点),

->分出来(_主光,_光路)->从(分出来,经过)->经过(_主光,_分光镜)...
->的(_结构,光线#4)->光线#4->[]{[]=>旧(光线#4,)}->+起点(光线#4,_分光镜)->+是(+起点,从)->+[旧](光线#4,)...
->+[有](_结构,+起点)->+[有](_结构,+是)...
->+[显示]"输入: "(,_分光镜);
## end
#1271, 695:

_结构->路线(_结构,)...
->经过(,_元件)->元件(经过,)->_光线->光线1(_光线,):
    ->_光路->光路1(_光路,)->旧(_光路,光线)->+[左连](光线,_光线)...
    ->+起点(光线,_元件)->+是(+起点,经过)->+的(_结构,+起点)->+的(_结构,+是)...
    ->+终点(_光线,_元件)->+是(+终点,经过)->+的(_结构,+终点)->+的(_结构,+是);

_结构->路线(_结构,)...
->输出->输出#1(输出,)->_光线->光线1(_光线,)...
->+终点(_光线,输出)->+是(+终点,输出)->+的(_结构,+终点)->+的(_结构,+是);

_结构->路线(_结构,)...
->输入->输入#1(输入,)->_光路->光路1(_光路,)->旧(_光路,光线)...
->+起点(光线,输入)->+是(+起点,输入)->+的(_结构,+起点)->+的(_结构,+是);

_结构->路线(_结构,)...
->从(,经过)->分光位置(从,)->经过(,_元件)->_元件(,)...
->_光路->光路1(_光路,)->旧(_光路,光线)...
->+起点(光线,_元件)->+是(+起点,从)->+的(_结构,+起点)->+的(_结构,+是);



_光路->光路1(_光路,)->旧(_光路,光线#2)->+[del](,旧);
_光路->光路1(_光路,):
    ->输入,->_光线->光线1(_光线,)->+旧(_光路,_光线)->+的(_光路,_光线);



## end
#1273, 130:
_结构->路线(_结构,)...
->经过(,_元件)->元件(经过,):
    ->_光路->光路1(_光路,)->旧(_光路,光线)...
    ->+穿过(光线,_元件)->+是(+穿过,经过)->+的(_结构,+穿过)->+的(_结构,+是);


## end
#1275, 357:
"""
+[返回目录](,显示路线)

"""
+显示路线(光线,_文本)->+[del](,+显示路线)...
->+[临时文本]"
%起点->%终点: "...
->起点(光线,_)->+[标题](_,)->终点(光线,_终点)->+[标题]#2(_终点,)...
->[]{
    []=>穿过(光线,_元件)=>+[标题]#3(_元件,)->+[增加内容]"%s "(+[标题]#3,+[临时文本])
}->+[模板文本](+[临时文本],+[临时文本])...
->+[.]"起点"(+[模板文本],+[标题])->+[.]"终点"(+[模板文本],+[标题]#2)...

->+[增加内容](+[临时文本],_文本)...

=>光线#2(光线,)=>+[显示路线](光线#2,_文本)






## end
#1277, 207:
"""
+[返回目录](,位置)

"""

+位置(_物体,):
    ->在(_物体,空间点)->[m_text](空间点,+位置),
    ->[is](_物体,输入)->输入(,_物体1)->在(_物体1,空间点#1)->[m_text](空间点#1,+位置),
    ->[is](_物体,输出)->输出(,_物体2)->在(_物体2,空间点#2)->[m_text](空间点#2,+位置)




## end
#1279, 4655:
+[返回目录](,场景)
+[显示星图](,场景)
+[删除结构](,场景)

有两束种子光和两束泵光
+种子光->+种子光2->+泵光1->+泵光2

被多次经过的元件有 Crystal
+Crystal

描述::泵光1经过+QRE, +X, +M, +Tube, +X, +M, +M, +X, Crystal
+[经过元件](描述,+[显示])
+QRE->+经过(泵光1,+QRE)->+X->+经过(泵光1,+X)->+M->+经过(泵光1,+M)->+Tube->+经过(泵光1,+Tube)->+X->+经过(泵光1,+X)->+M->+经过(泵光1,+M)->+M->+经过(泵光1,+M)->+X->+经过(泵光1,+X)->Crystal->+经过(泵光1,Crystal)

描述::泵光2经过+QRG, +M, +M, +X, Crystal
+[经过元件](描述,+[显示])
+QRG->+经过(泵光2,+QRG)->+M->+经过(泵光2,+M)->+M->+经过(泵光2,+M)->+X->+经过(泵光2,+X)->Crystal->+经过(泵光2,Crystal)

描述::种子光经过+1st, +X, +CM, +M, +M, +I, Crystal, +I, +X, +M, +M, Crystal, +X, +M, +M, Crystal, +I, +M, +BS, +3rd
+[经过元件](描述,+[显示])
+1st->+经过(种子光,+1st)->+X->+经过(种子光,+X)->+CM->+经过(种子光,+CM)->+M->+经过(种子光,+M)->+M->+经过(种子光,+M)->+I->+经过(种子光,+I)->Crystal->+经过(种子光,Crystal)->+I->+经过(种子光,+I)->+X->+经过(种子光,+X)->+M->+经过(种子光,+M)->+M->+经过(种子光,+M)->Crystal->+经过(种子光,Crystal)->+X->+经过(种子光,+X)->+M->+经过(种子光,+M)->+M->+经过(种子光,+M)->Crystal->+经过(种子光,Crystal)->+I->+经过(种子光,+I)->+M->+经过(种子光,+M)->+BS->+经过(种子光,+BS)->+3rd->+经过(种子光,+3rd)

描述::在BS上, 从种子光中分出来种子光2, 然后经过+M, +M, +X, +X, +M, +M, +I, +Booster
描述::种子光2经过+M, +M, +X, +X, +M, +M, +I, +Booster
+[经过元件](描述,+[显示])
+M->+经过(种子光2,+M)->+M->+经过(种子光2,+M)->+X->+经过(种子光2,+X)->+X->+经过(种子光2,+X)->+M->+经过(种子光2,+M)->+M->+经过(种子光2,+M)->+I->+经过(种子光2,+I)->+Booster->+经过(种子光2,+Booster)
经过(种子光,BS)->+分出来(种子光,种子光2)->+从(+分出来,经过)

所有的镜子M都按顺序命名为Mi. Iris, 透镜, 爬高镜和X都用同样的方法命名. 
+[自动命名]"M"(,场景)
+[自动命名]"I"(,场景)
+[自动命名]"X"(,场景)


将所有种子光的经过置顶
种子光=>经过(种子光,)=>+[置顶](种子光,经过)
种子光2=>经过(种子光2,)=>+[置顶](种子光2,经过)
泵光1=>经过(泵光1,)=>+[置顶](泵光1,经过)
泵光2=>经过(泵光2,)=>+[置顶](泵光2,经过)
依次显示种子光经过的元件. 
种子光=>经过(种子光,_元件)=>+[显示](,_元件)

+位置
位置
所有被光线经过的东西都是元件, 都有空间位置
场景=>的(场景,_元件)->[]{经过(,_元件)}=>+的(位置,+空间点)->+在(_元件,+空间点)

显示所有泵光1经过的元件
泵光1=>经过(泵光1,_元件)=>+[显示](,_元件)
泵光2=>经过(泵光2,_元件)=>+[显示](,_元件)


种子光输出的元件是3rd, 输入元件是1st. 
种子光2输出的元件是Booster. 
泵光1输出是Crystal, 输入元件是QRE
泵光2输出是Crystal, 输入元件是QRG
经过(种子光,3rd)->经过(种子光,1st)...
->+的(种子光,+输出)->+输出(,3rd)->+的(种子光,+输入)->+输入(,1st)
经过(种子光2,Booster)...
->+的(种子光2,+输出)->+输出(,Booster)
经过(泵光1,Crystal)->经过(泵光1,QRE)...
->+的(泵光1,+输出)->+输出(,Crystal)->+的(泵光1,+输入)->+输入(,QRE)
经过(泵光2,Crystal)->经过(泵光2,QRG)...
->+的(泵光2,+输出)->+输出(,Crystal)->+的(泵光2,+输入)->+输入(,QRG)



设置泵光1的元件
+[设置位置](,泵光1)
在(Crystal,空间点)->+[修改内容]"100,0,0"(,空间点)
在(QRE,空间点)->+[修改内容]"200,20,0"(,空间点)
+[相对]"0,-30,0"(QRE,X6)
+[相对]"0,-35,0"(QRE,M13)
+[相对]"-70,0,0"(M13,Tube)
+[相对]"-165,0,0"(M13,M14)
+[相对]"5,0,0"(M14,X7)
+[对齐Y](Crystal,M15)->+[对齐X](M14,M15)
+[相对]"5,0,0"(M15,X8)

+[设置位置](,泵光2)
+[相对]"50,0,0"(QRE,QRG)
+[相对]"-5,0,0"(QRG,M11)
+[相对]"0,0,0"(M11,M12)
+[对齐Y](Crystal,M12)->+[对齐X](M11,M12)
+[相对]"-42,0,0"(M12,X5)


+[matlab]"clf"(Matlab,)...
->+[显示光路](+[matlab],泵光1)->+[显示光路](+[matlab],泵光2)...
->+[显示光路](+[matlab],种子光2)->+[显示光路](+[matlab],种子光)


设置种子光的元件
+[设置位置](,种子光)
在(1st,空间点)->+[修改内容]"0,0,0"(,空间点)
+[对齐Y](Crystal,1st)
+[相对]"5,0,0"(1st,X2)
+[相对]"40,0,0"(1st,CM)
+[相对]"5,2,0"(X2,M4)

+[相对]"0,-5,0"(M4,M5)
+[相对]"6"(M5,I1)->+[沿着](+[相对],)->[方向](M5,Crystal)->[m_text]([方向],+[沿着])
+[相对]"80"(Crystal,M6)->+[沿着](+[相对],)->[方向](M5,Crystal)->[m_text]([方向],+[沿着])
+[相对]"3"(M6,X3)->+[沿着](+[相对],)->[方向](M6,Crystal)->[m_text]([方向],+[沿着])
+[相对]"6"(M6,I2)->+[沿着](+[相对],)->[方向](M6,Crystal)->[m_text]([方向],+[沿着])
+[相对]"0,-5,0"(M6,M7)
+[相对]"70"(Crystal,M8)->+[沿着](+[相对],)->[方向](M7,Crystal)->[m_text]([方向],+[沿着])
+[相对]"6"(M8,X4)->+[沿着](+[相对],)->[方向](M8,Crystal)->[m_text]([方向],+[沿着])
+[相对]"0,-2,0"(M8,M9)

+[matlab]"clf"(Matlab,)...
->+[显示光路](+[matlab],泵光1)->+[显示光路](+[matlab],泵光2)...
->+[显示光路](+[matlab],种子光2)->+[显示光路](+[matlab],种子光)


+[相对]"90,0,0"(Crystal,I3)
+[相对]"130,0,0"(Crystal,M10)
+[相对]"0,5,0"(M10,BS)
+[相对]"0,10,0"(BS,3rd)

设置种子光2的元件
+[设置位置](,种子光2)
+[相对]"-40,0,0"(BS,M0)
+[相对]"0,-10,0"(M0,M1)
+[相对]"5,0,0"(M1,X0)
+[相对]"10,0,0"(M1,X1)
+[相对]"20,0,0"(M1,M2)
+[相对]"0,15,0"(M2,M3)
+[相对]"5,0,0"(M3,I0)
+[相对]"50,0,0"(M3,Booster)


显示所有元件所在的空间点位置. 
位置=>的(位置,空间点)->在(_元件,空间点)...
=>+[标题](_元件,)->+[修改内容](+[标题],+[显示])->+[显示](,空间点)


显示种子光和泵光光路
+[matlab]"clf"(Matlab,)...
->+[显示光路](+[matlab],泵光1)->+[显示光路](+[matlab],泵光2)...
->+[显示光路](+[matlab],种子光2)->+[显示光路](+[matlab],种子光)

所有经过了镜子的光线都被那面镜子反射. 
[]=>经过(_光线,_re)->_re"^M"=>+反射(经过,)
[]=>经过(_光线,_re)->_re"^CM"=>+反射(经过,)



测试结构:...
+[删除结构](,测试结构)
+[场景结构转路线结构](场景,测试结构)
+[设置结构](,测试结构)

测试结构=>的(测试结构,光线)=>+[del](,光线)...
=>起点(光线,)->是#1(起点,)->终点(光线,)->是(终点,)...
=>+[del](,起点)->+[del](,是#1)->+[del](,终点)->+[del](,是)


从(,经过)->是(,从)
分出来->从(分出来,经过)
方向

位置::
所有被光线经过的东西都是元件, 都朝着某个方向
场景=>的(场景,_元件)->[]{经过(,_元件)}=>+朝着(_元件,+方向)

自动调整所有元件的方向. 
场景=>的(场景,_元件)->[]{经过(,_元件)}=>+[自动调整镜子方向](,_元件)

显示所有元件的方向
场景=>的(场景,_元件)->朝着(_元件,方向)...
=>+[标题](_元件,)->+[修改内容](+[标题],+[显示])->+[显示](,方向)

显示所有起点是输入的光线信息. 
场景=>的(场景,输入)=>起点(光线,输入)->+[显示路线](光线,+[显示])



+[显示光路场景结构](,场景)
+[显示星图](,测试结构)
## end
#1280, 4:
1288
## end
#1282, 4:
1290
## end
#1284, 4:
1286
## end
#1286, 4:
1288
## end
#1288, 4:
1290
## end
#1290, 4:
1292
## end
#1292, 4:
1294
## end
#1294, 4:
1299
## end
#1296, 4:
1301
## end
#1298, 4:
1300
## end
#1300, 4:
1302
## end
#1302, 4:
1307
## end
#1304, 4:
1310
## end
#1307, 153:
"""
+[返回目录](,起点)

"""

+起点(光线,)->光线(空间点,)->+是(+起点,空间点)...
->[m_text](空间点,+起点); 

+起点(光线,)->起点(光线,_M)->在(_M,空间点)->+是(+起点,空间点)...
->[m_text](空间点,+起点); 




## end
#1309, 238:
"""
+[返回目录](,终点)

"""

+终点(光线,)->光线(,空间点)->+是(+终点,空间点)...
->[m_text](空间点,+终点); 

+终点(光线,)->终点(光线,_M)->_M:
    ->在(_M,空间点)->+是(+终点,空间点)->[m_text](空间点,+终点),
    ->[is](_M,输出)->输出(,_元件)->在(_元件,空间点#1)->+是(+终点,空间点#1)->[m_text](空间点#1,+终点); 




## end
#1310, 4:
1312
## end
#1312, 4:
1314
## end
### 结束