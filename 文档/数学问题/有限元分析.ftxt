### 节点
地址, 的, 有限元分析, 目录, 的, 的, 节点数目统计, 的, 参考, 打开网页, 的, 参考2, 打开网页, 的, 笔记, 的, wiki, 的, 参考, 打开网页, 的, 参考2, 打开网页, 打开网页, 打开网页, 打开网页, 打开网页, 打开网页, 打开网页, 打开网页, 的, 公式推导, html, 的, [1]., 手, 表达式, 的, 公式, 的, [2]., 的, [3]., 的, [4]., 的, [5]., 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, 的, [6]., 的, [7]., 的, [8]., 表达式, 的, 公式, b, a, 手, 表达式, 的, 公式, 表达式, 的, 公式, 的, [9]., 表达式, 的, 公式, 的, [10]., 的, [11]., 的, [12]., 的, [13]., 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, 打开网页, 打开网页, 的, 划分网格, 的, 参考, 的, 参考2, 打开网页, 打开网页, 打开网页, 打开网页, 打开网页, 的, 参考3, 打开网页, 打开网页, 打开网页, 打开网页, 的, AdvancingFront, html, 的, 测试算法, M函数, 的, 保存, 的, 测试相同, 的, 画图, 手, 在, 的, 单步边界, 的, bdFormPolygon, M函数, 的, 地址, bdFormPolygon, 的, 记忆, bdFormPolygon, 的, 单步边界2, 的, 获取数据, 的, 测试, 的, 测试区域, 的, 远程连接, 的, 等比缩小, 手, 的, 完成扫描1, 的, hasInterTriangle, M函数, 的, 测试, 的, 地址, hasInterTriangle, 的, hasInterTriangle, 的, rmInterTriangle, M函数, 的, 地址, rmInterTriangle, 的, rmInterTriangle, 的, 外部三角, 的, 测试区域2, 的, pickUpExistedPt, M函数, 的, 地址, pickUpExistedPt, 的, pickUpExistedPt, 的, 测试区域2, 的, 测试区域, 的, 保存, 的, 测试区域3, 的, intersection_line_lines_2, M函数, 的, 地址, intersection_line_lines_2, 的, intersection_line_lines_2, 的, 完成扫描2, 的, meshGeneration_AF, M函数, 的, 测试, 的, 地址, meshGeneration_AF, 的, meshGeneration_AF, 的, 测试2, 的, 网格动画, 的, 示意图场景, 手, A, 的, B, 的, 样式, y, 的, x, 的, 类型, 的, 样式, y, 的, x, 的, 类型, 的, 的, A1, 的, A2, 的, A3, 的, A4, 空间点, 在, 空间点, 在, 空间点, 在, 空间点, 在, 的, H代码, 的, 图1, SVG, 的, 的, 颜色, 的, 新建主语, 的, [14]., 的, [15]., 表达式, 的, 公式, 表达式, 的, 公式, 的, [16]., 的, [17]., 表达式, 的, 公式, 表达式, 的, 公式, 的, [18]., 表达式, 的, 公式, 打开网页, 的, [19]., 的, [20]., 的, [21]., 的, [22]., 的, [23]., 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, 的, [24]., 的, [25]., 的, [26]., 的, [27]., 表达式, 的, 公式, 表达式, 的, 公式, 的, [28]., 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, 的, [29]., 的, [30]., 的, [31]., 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 的, 区域1, 的, 区域2, 空间点, 在, 空间点, 在, 的, [32]., 表达式, 的, 公式, 的, [33]., 的, [34]., 的, [35]., 的, [36]., 表达式, 的, 公式, 的, 验证公式, M函数, 表达式, 的, 公式, 的, [37]., 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, 的, 课件例子, 的, showMesh_3D, M函数, 的, 地址, showMesh_2D, 的, showMesh_2D, 的, 测试, 测试, 地址, 的, 的, M函数, showMesh_2D, 的, showMesh_patch, 的, showMesh_patch, 的, 获取mesh, 的, 系数矩阵, 地址, 测试, 的, 的, M函数, showMesh_patch, 的, showMesh_3D, 的, showMesh_3D, 的, 参考, 打开网页, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 
### 关联
#, 2#0, #, #, 3#2, 3#6, #, 2#8, #, #8, 2#11, #, #11, 2#14, #, 14#16, #, 14#18, #, #18, 14#21, #, #11, #11, #11, #18, #11, #18, #11, #11, 2#31, #, 31#, 31#34, #, #31, #, 34#36, 34#, 31#40, #, 31#42, #, 31#44, #, 31#46, #, #, 40#47, 40#, #, 42#50, 42#, #, 44#53, 44#, #, 46#56, 46#, 31#60, #, 31#62, #, 31#64, #, #, 60#65, 60#, #, #, #31, #, 62#71, 62#, #, 64#74, 64#, 31#78, #, #, 78#79, 78#, 31#83, #, 31#85, #, 31#87, #, 31#89, #, #, 83#90, 83#, #, 85#93, 85#, #, 87#96, 87#, #, 89#99, 89#, #11, #8, 2#105, #, 105#107, #, 105#109, #, #107, #107, #107, #109, #107, 105#116, #, #107, #107, #107, #116, 105#122, #, 122#, 122#125, #, 125#, 125#128, #, 125#130, #, 125#132, #, #138, #, 125#136, #, 125#138, #, 138#, 138#141, #, #138, 144#142, 3#, #, 125#147, #, 138#149, #, 138#151, #, 125#153, #, 125#155, #, 125#157, #, #198, 125#160, #, 125#162, #, 162#, 162#165, #, 162#167, #, #162, 144#168, #, 125#172, #, 172#, 172#175, #, #172, 144#176, #, 125#180, #, 125#182, #, 125#184, #, 184#, 184#187, #, #184, 144#188, #, 184#192, #, 184#194, #, 184#196, #, 184#198, #, 184#200, #, 200#, 200#203, #, #200, 144#204, #, 125#208, #, 125#210, #, 210#, 210#213, #, 210#215, #, #210, 144#216, #, 210#220, #, 220#222, #, 31#224, #, #31, #, 224#226, #, 224#228, 226#, #, 226#231, #, 226#233, #, 226#235, 228#, #, 228#238, #, 228#240, #, 228#242, 224#245, #, 224#247, #, 224#249, #, 224#251, #, #, 245#252, #, 251#254, #, 249#256, #, 247#258, 224#261, #, 31#263, #, 263#, 224#266, 226#267, #, 224#267, 224#, 31#271, #, 31#273, #, #, 271#274, 271#, #, 273#277, 273#, 31#281, #, 31#283, #, #, 281#284, 281#, #, 283#287, 283#, 31#291, #, #, 291#292, 291#, #11, 31#297, #, 31#299, #, 31#301, #, 31#303, #, 31#305, #, #, 297#306, 297#, #, 299#309, 299#, #, 301#312, 301#, #, 303#315, 303#, #, 305#318, 305#, 31#322, #, 31#324, #, 31#326, #, 31#328, #, #, 322#329, 322#, #, 324#332, 324#, 31#336, #, #, 326#337, 326#, #, 328#340, 328#, #, 336#343, 336#, 31#347, #, 31#349, #, 31#351, #, #, 347#352, 347#, #, 349#355, 349#, #, 351#358, 351#, 226#245, 224#361, 226#247, 224#363, 226#249, 224#365, 226#251, 224#367, 228#247, 224#369, 228#251, 224#371, 224#374, #, 224#376, #, #, 374#377, #, 376#379, 31#382, #, #, 382#383, 382#, 31#387, #, 31#389, #, 31#391, #, 31#393, #, #, 387#394, 387#, 31#398, #, 398#, #, 389#400, 389#, 31#404, #, #, 391#405, 391#, #, 393#408, 393#, #, 404#411, 404#, 398#415, #, 125#417, #, 417#, 417#420, #, #417, 144#421, #, 417#425, #, #, #, 431#426, 431#427, 431#, #, 125#431, #417, 144#433, #, 398#437, #, 398#439, #, #, #, 445#440, 445#441, 445#, #, 125#445, #417, 144#447, #, 417#451, #, #107, 36#del, 47#del, 50#del, 53#del, 56#del, 65#del, 71#del, 74#del, 79#del, 90#del, 93#del, 96#del, 99#del, 274#del, 277#del, 284#del, 287#del, 292#del, 306#del, 309#del, 312#del, 315#del, 318#del, 329#del, 332#del, 337#del, 340#del, 343#del, 352#del, 355#del, 358#del, 383#del, 394#del, 400#del, 405#del, 408#del, 411#del, 
### 内容
#0, 18:
文档/数学问题/有限元分析.ftxt
## end
#2, 243:
+[返回目录](,有限元分析)
地址::文档/数学问题/有限元分析.ftxt


参考::file:///media/xiantao/Elements/paper/Books/Finiteelementcourse.pdf
参考2::file:///media/xiantao/Elements/paper/FEM/ppt
+[打开网页](,参考)

笔记:...
公式推导(html):...
划分网格:...
+[新建阅读窗口](,公式推导)
+[新建阅读窗口](,划分网格)



## end
#3, 49:
有限元分析:...
创建于 20230403

节点数目统计::
+[设置结构](,节点数目统计)
## end
#8, 66:
file:///media/xiantao/Elements/paper/Books/Finiteelementcourse.pdf
## end
#11, 44:
file:///media/xiantao/Elements/paper/FEM/ppt
## end
#14, 568:
wiki::https://en.wikipedia.org/wiki/Finite_element_method
参考::file:///media/xiantao/Elements/paper/Books/Finiteelementcourse.pdf
+[打开网页](,参考)

参考2::https://www.simscale.com/forum/t/the-finite-element-method-fundamentals-strong-and-weak-form-for-1d-problems-5/57940
弱形式和强形式是等价的

记几点. 目前看来有限元好像和变分法没有关系
弱形式是积分的形式. 是用格林定理把微分方程变成了积分方程
加入了一组基函数做展开后, 原方程会变成矩阵方程, 求解就是求这组基的系数
目前不清楚为什么求解要迭代, 可能是因为矩阵太大了
而矩阵的形式, 由基函数以及方程的形式决定
基函数是什么以及怎么取以及为什么这么取大概是下一步要弄清楚的事情了

正方形网格不会带来简化
(三角形网格是最基本的)

然后问题其实基本上就解决了. 有限元是把投影到三角形网格上的曲面划分成一个一个拼接起来的平面. 平面的边界就投影成这些三角形
所以这个拼接曲面是一个C0函数(连续不可导)





## end
#16, 51:
https://en.wikipedia.org/wiki/Finite_element_method
## end
#18, 66:
file:///media/xiantao/Elements/paper/Books/Finiteelementcourse.pdf
## end
#21, 116:
https://www.simscale.com/forum/t/the-finite-element-method-fundamentals-strong-and-weak-form-for-1d-problems-5/57940
## end
#31, 1539:
<!--
+[H函数](,公式推导)
示意图场景:...
+[新建阅读窗口](,示意图场景)
-->

<h2>整体思路</h2>
先将要求解的微分方程从强形式变为弱形式的积分方程(用格林公式). 然后用一组三角形网格上的分块函数来代替真实函数. 每个分块函数由顶点上的参数确定. 比如, 如果令分块函数都是平面的话, 三个点可以确定一个平面. 真实解是一个曲面, 而有限元法求解的数值解是一个很多块小三角形平面拼接成的面. <br>
接下来以二维泊松方程为例, 做一遍有限元模拟. 
%[1].

<h2>弱形式</h2>
令\(v(x,y)\)为任意函数, 于是有,
%[2].
%[3].
%[4].
%[5].

<h2>离散化</h2>
%[6].

在区域\(S_i\)中, \(u(x,y)\)可以写作, 
%[7].
%[8].
%[9].

如果\(S_i\)是三角形区域, 我们应当知道函数在三角形顶点上的值, 由此可以计算出系数\(u_{i,j}\). 假设三角形\(S_i\)的顶点位置分别是\((x_{i,k},y_{i,k})\), 那么有
%[10].
%[11].
写成矩阵形式, 
%[12].
%[13].
因此, 我们可以将\(u\)和\(v\)表示成顶点上的\(U\)和\(V\),
%[14].
%[15].
其中有, 
%[16].
%[17].
%[18].
式(9)的左边记作为,
%[19].
%[20].
%[21].

<h3>源项</h3>
将式(9)右边记作为,
%[22].
%[23].
%[24].
%[25].

而\(F_{i,k}\)的各个分量分别为,
%[26].
%[27].
%[28].

<h3>第一类边条件</h3>
假设离散网格上共有\(n+m\)个格点, 其中有\(n\)个内部点和\(m\)个边界点. 包含了所有点的系数矩阵是,
%[29].
因为\(V_k\)在边界上必须为0, 所以有\(m\)行等式不存在. 而剩下的方程组可以写作, 
%[30].
于是第一类边条件项, \(B_1\)就是,
%[31].
(最后的系数矩阵是\(n\times n\)的矩阵,仍然是一个方阵)

<h3>第二类边界条件</h3>
现在不仔细弄, 因为暂时用不上. 思路是, 边界上的\(\nabla u\)给定后, 边界上有\(m\)个点就有\(m\)条边, 就对应着\(m\)个新的约束方程. 暂时不仔细讨论这些方程长啥样了


<h2>例子</h2>
假设有如下形状的网格, 请求解其对应的系数矩阵
<!--
图1(SVG):...
+[H函数](,公式推导)
-->
%图1<br>

区域(1)的面积是,
%[32].
然后有\(R_1\)为,
%[33].
于是有,
%[34].

用同样的方法处理区域(2),
%[35].
%[36].
(面积是\(S_2=1/2\))

于是全局的系数矩阵是,
%[37].

<!--
[37].:
式(37)转换为"表达式"
将"\mat{C}=\mat{1.0625,-0.1250,0,-0.9375;
-0.1250,2.2500,-2.0000,-0.1250;
0,-2.0000,2.1250,-0.1250;
-0.9375,-0.1250,-0.1250,1.1875}"记作为式(37)



验证公式(M函数):...
+[新建阅读窗口](,验证公式)
更新式(25)
的([3].,表达式)->+[显示星图]"1"(,表达式)
的([10].,表达式)->+[显示星图]"1"(,表达式)
+[H函数](,公式推导)
-->
## end
#34, 59:
\vec{\nabla}^{2}\ u \left( x,y \right)=f \left( x,y \right)
## end
#36, 28:
\vec{\nabla}^2*u(x,y)=f(x,y)
## end
#40, 101:
\int_{}^{}{ds\ }{\vec{\nabla}^{2}\ u \left( x,y \right)\ v}=\int_{}^{}{ds\ }{f \left( x,y \right)\ v}
## end
#42, 128:
\int_{}^{}{ds\ }{\vec{\nabla}\cdot \left(\vec{\nabla}\ u \left( x,y \right)\right)\ v}=\int_{}^{}{ds\ }{f \left( x,y \right)\ v}
## end
#44, 197:
\int_{}^{}{ds\ }{\left(\vec{\nabla}\cdot \left(\vec{\nabla}\ u \left( x,y \right)\ v\right)-\vec{\nabla}\ u \left( x,y \right)\cdot \vec{\nabla}\ v\right)}=\int_{}^{}{ds\ }{f \left( x,y \right)\ v}
## end
#46, 130:
\int_{}^{}{ds\ }{\left(0-\vec{\nabla}\ u \left( x,y \right)\cdot \vec{\nabla}\ v\right)}=\int_{}^{}{ds\ }{f \left( x,y \right)\ v}
## end
#47, 64:
\int_{}^{}{s}{\vec{\nabla}^{2}*u(x,y)*v}=\int_{}^{}{s}{f(x,y)*v}
## end
#50, 80:
\int_{}^{}{s}{\vec{\nabla}\cdot (\vec{\nabla}*u(x,y))*v}=\int_{}^{}{s}{f(x,y)*v}
## end
#53, 120:
\int_{}^{}{s}{\vec{\nabla}\cdot (\vec{\nabla}*u(x,y)*v)-\vec{\nabla}*u(x,y)\cdot \vec{\nabla}*v}=\int_{}^{}{s}{f(x,y)*v}
## end
#56, 80:
\int_{}^{}{s}{0-\vec{\nabla}*u(x,y)\cdot \vec{\nabla}*v}=\int_{}^{}{s}{f(x,y)*v}
## end
#60, 163:
\sum_{i}{\int_{S\ _{i}}^{}{ds\ }{\left(-\vec{\nabla}\ u \left( x,y \right)\cdot \vec{\nabla}\ v\right)}}=\sum_{i}{\int_{S\ _{i}}^{}{ds\ }{f \left( x,y \right)\ v}}
## end
#62, 56:
u \left( x,y \right)=u\ _{i,0}+u\ _{i,1}\ x+u\ _{i,2}\ y
## end
#64, 218:
\sum_{i}{\int_{S\ _{i}}^{}{ds\ }{\left(-\begin{pmatrix}
u\ _{i,1},&u\ _{i,2}
\end{pmatrix}

\cdot \begin{pmatrix}
v\ _{i,1},&v\ _{i,2}
\end{pmatrix}

\right)}}=\sum_{i}{\int_{S\ _{i}}^{}{ds\ }{f \left( x,y \right)\ v}}
## end
#65, 117:
\sum_{}^{}{i}{\int_{S[i]}^{}{s}{-\vec{\nabla}*u(x,y)\cdot \vec{\nabla}*v}}=\sum_{}^{}{i}{\int_{S[i]}^{}{s}{f(x,y)*v}}
## end
#68, 39:
\sum_{}^{}{i}{\int_{S[i]}^{}{s}{[0.0]}}
## end
#69, 17:
\int_{}^{}{s}{_f}
## end
#71, 31:
u(x,y)=u[i,0]+u[i,1]*x+u[i,2]*y
## end
#74, 123:
\sum_{}^{}{i}{\int_{S[i]}^{}{s}{-\vec{u[i,1],u[i,2]}\cdot \vec{v[i,1], v[i,2]}}}=\sum_{}^{}{i}{\int_{S[i]}^{}{s}{f(x,y)*v}}
## end
#78, 162:
\sum_{i}{\int_{S\ _{i}}^{}{ds\ }{\left(-\left(u\ _{i,1}\ v\ _{i,1}+u\ _{i,2}\ v\ _{i,2}\right)\right)}}=\sum_{i}{\int_{S\ _{i}}^{}{ds\ }{f \left( x,y \right)\ v}}
## end
#79, 107:
\sum_{}^{}{i}{\int_{S[i]}^{}{s}{-(u[i,1]*v[i,1]+u[i,2]*v[i,2])}}=\sum_{}^{}{i}{\int_{S[i]}^{}{s}{f(x,y)*v}}
## end
#83, 88:
u \left( x\ _{i,k},y\ _{i,k} \right)=u\ _{i,0}+u\ _{i,1}\ x\ _{i,k}+u\ _{i,2}\ y\ _{i,k}
## end
#85, 61:
U\ _{i,k}=u\ _{i,0}+u\ _{i,1}\ x\ _{i,k}+u\ _{i,2}\ y\ _{i,k}
## end
#87, 27:
\vec{U}=\mathbf{R}\ \vec{u}
## end
#89, 234:
\begin{pmatrix}
U\ _{i,0}\\ U\ _{i,1}\\ U\ _{i,2}
\end{pmatrix}

=\begin{pmatrix}
1&x\ _{i,0}&y\ _{i,0}\\ 1&x\ _{i,1}&y\ _{i,1}\\ 1&x\ _{i,2}&y\ _{i,2}
\end{pmatrix}

\ \begin{pmatrix}
u\ _{i,0}\\ u\ _{i,1}\\ u\ _{i,2}
\end{pmatrix}


## end
#90, 51:
u(x[i,k],y[i,k])=u[i,0]+u[i,1]*x[i,k]+u[i,2]*y[i,k]
## end
#93, 41:
U[i,k]=u[i,0]+u[i,1]*x[i,k]+u[i,2]*y[i,k]
## end
#96, 23:
\vec{U}=\mat{R}*\vec{u}
## end
#99, 107:
\mat{U[i,0];U[i,1];U[i,2]}=\mat{1,x[i,0],y[i,0];1,x[i,1],y[i,1];1,x[i,2],y[i,2]}*\mat{u[i,0];u[i,1];u[i,2]}
## end
#105, 269:

参考::file:///media/xiantao/Elements/paper/FEM/mesh.pdf
参考2::https://www.pre-scient.com/knowledge-center/product-development-by-reverse-engineering/meshing-algorithms.html
参考3::file:///media/xiantao/Elements/paper/FEM/mesh2.pdf
+[打开网页](,参考)


AdvancingFront(html):...



## end
#107, 49:
file:///media/xiantao/Elements/paper/FEM/mesh.pdf
## end
#109, 110:
https://www.pre-scient.com/knowledge-center/product-development-by-reverse-engineering/meshing-algorithms.html
## end
#116, 50:
file:///media/xiantao/Elements/paper/FEM/mesh2.pdf
## end
#122, 152:
<!--
+[H函数](,AdvancingFront)
-->




<!--
测试算法(M函数):...
+[新建阅读窗口](,测试算法)
+[M函数](,测试算法)

在选择区域中, 将'测试算法'的"is\(1\)"替换为"is(2)"

+[H函数](,AdvancingFront)
-->
## end
#125, 1511:
%{
+[M函数](,测试算法)
运行指令"nautilus 文档/计算机问题"
运行指令"nautilus Matlab"
Nini, 打开合并多边形的PtsInPolygon(节点)
faces
画图:...
单步边界:...
单步边界2:...
远程连接:...
完成扫描1:...
外部三角:...
完成扫描2:...

等比缩小:...

保存:...
测试区域:...
测试区域2:...
+[新建阅读窗口](,测试区域2)

bdFormPolygon(M函数):...
pickUpExistedPt(M函数):...
hasInterTriangle(M函数):...
rmInterTriangle(M函数):...
meshGeneration_AF(M函数):...
showMesh_2D(M函数):...
showMesh_patch(M函数):...
showMesh_3D(M函数):...
将条目"showMesh_patch"复制为条目"showMesh_3D"
+[新建阅读窗口](,showMesh_patch)
+[新建阅读窗口](,showMesh_2D)
+[新建阅读窗口](,meshGeneration_AF)
+[新建阅读窗口](,hasInterTriangle)
+[新建阅读窗口](,bdFormPolygon)
%}

addpath('Matlab/mesh')
addpath('Matlab/space')
addpath('Matlab/draw')

t1=linspace(0,360,20);
t2=linspace(0,360,6);
R=5;
N=700;
ratio=0.3;
Dr0=0.3;

x_bd_1=R*cosd(t1(1:end-1));
y_bd_1=R*sind(t1(1:end-1))*1.5;
bd_lines_11=1:length(x_bd_1);
bd_lines_12=[length(x_bd_1),1:length(x_bd_1)-1];

x_bd_2=R*cosd(t2(1:end-1))*0.3;
y_bd_2=R*sind(t2(1:end-1))*0.3;
bd_lines_22=[1:length(x_bd_2)]+length(x_bd_1);
bd_lines_21=[length(x_bd_2),1:length(x_bd_2)-1]+length(x_bd_1);

x_bd_0=[x_bd_1,x_bd_2];
y_bd_0=[y_bd_1,y_bd_2];
bd_lines_1=[bd_lines_11,bd_lines_21];
bd_lines_2=[bd_lines_12,bd_lines_22];

% x_bd_0=[x_bd_1];
% y_bd_0=[y_bd_1];
% bd_lines_1=[bd_lines_11];
% bd_lines_2=[bd_lines_12];

[pts_x,pts_y,lines_1,lines_2,faces]=meshGeneration_AF(x_bd_0,y_bd_0,bd_lines_1,bd_lines_2,N,ratio,Dr0);

clf
% showMesh_2D(pts_x,pts_y,lines_1,lines_2);
showMesh_patch(pts_x,pts_y,lines_1,lines_2,faces);



%{
测试相同:...

+[M函数](,测试算法)
%}
## end
#128, 3649:
%{
+[M函数](,测试算法)
运行指令"nautilus 文档/计算机问题"
运行指令"nautilus Matlab"
Nini, 打开合并多边形(文件)

画图:...
单步边界:...
保存:...

bdFormPolygon(M函数):...
%}

addpath('Matlab/mesh')

t=linspace(0,360,10);
R=2;
ratio=0.5;
x_bd_0=R*cosd(t(1:end-1));
y_bd_0=R*sind(t(1:end-1));

bd_lines_1=1:length(x_bd_0);
bd_lines_2=[length(x_bd_0),1:length(x_bd_0)-1];

pts_x=x_bd_0;
pts_y=y_bd_0;
lines_1=bd_lines_1;
lines_2=bd_lines_2;
% faces=[];

clf 
hold on


for i=1:2

is=[bd_lines_1(1),bd_lines_2(1)];
x0=mean(pts_x(is));
y0=mean(pts_y(is));

Dx=-diff(pts_y(is));
Dy=diff(pts_x(is));
L=sqrt(Dx^2+Dy^2);
Dr=ratio*L;

x_n=x0-Dx*sqrt(3)/2;
y_n=y0-Dy*sqrt(3)/2;

rs=sqrt((pts_x-x_n).^2+(pts_y-y_n).^2);


if isempty(rs(rs<Dr))
    pts_x(end+1)=x_n;
    pts_y(end+1)=y_n;
    n0=length(pts_x);
    lines_1(end+1:end+2)=[is(1),n0];
    lines_2(end+1:end+2)=[n0,is(2)];
    bd_lines_1(end+1:end+2)=[is(1),n0];
    bd_lines_2(end+1:end+2)=[n0,is(2)];
else
    n0=find(rs==min(rs));
    n0=n0(1);
% plot(pts_x(n0),pts_y(n0),'r*')
    con_n=[bd_lines_2(bd_lines_1==n0),bd_lines_1(bd_lines_2==n0)];

    if isempty(con_n(is(1)==con_n))
        lines_1(end+1)=is(1);
        lines_2(end+1)=n0;
        % bd_lines_1(end+1)=is(1);
        % bd_lines_2(end+1)=n0;
        con_1=[bd_lines_2(bd_lines_1==is(1)),bd_lines_1(bd_lines_2==is(1))];
        if sum(sum(con_n==con_1'))==0
            bd_lines_1(end+1)=is(1);
            bd_lines_2(end+1)=n0;
        else
            for j=1:length(con_n)
                if isempty(con_1(con_n(j)==con_1))
                    k=find(bd_lines_1==con_n(j)&bd_lines_2==is(1));
                    bd_lines_1(k)=[];
                    bd_lines_2(k)=[];
                    
                    k=find(bd_lines_2==con_n(j)&bd_lines_1==is(1));
                    bd_lines_1(k)=[];
                    bd_lines_2(k)=[];
                    
                    break;
                end
            end
        end
    else
        k=find(bd_lines_1==n0&bd_lines_2==is(1));
        bd_lines_1(k)=[];
        bd_lines_2(k)=[];
        
        k=find(bd_lines_2==n0&bd_lines_1==is(1));
        bd_lines_1(k)=[];
        bd_lines_2(k)=[];

    end

    if isempty(con_n(is(2)==con_n))
        lines_1(end+1)=n0;
        lines_2(end+1)=is(2);
        % bd_lines_1(end+1)=n0;
        % bd_lines_2(end+1)=is(2);

        con_2=[bd_lines_2(bd_lines_1==is(2)),bd_lines_1(bd_lines_2==is(2))];
        if sum(sum(con_n==con_2'))==0
            bd_lines_1(end+1)=n0;
            bd_lines_2(end+1)=is(2);
        else
            for j=1:length(con_n)
                if isempty(con_2(con_n(j)==con_2))
                    k=find(bd_lines_1==con_n(j)&bd_lines_2==is(2));
                    bd_lines_1(k)=[];
                    bd_lines_2(k)=[];
                    
                    k=find(bd_lines_2==con_n(j)&bd_lines_1==is(2));
                    bd_lines_1(k)=[];
                    bd_lines_2(k)=[];
                    
                    break;
                end
            end
        end
    else
        k=find(bd_lines_1==n0&bd_lines_2==is(2));
        bd_lines_1(k)=[];
        bd_lines_2(k)=[];
        
        k=find(bd_lines_2==n0&bd_lines_1==is(2));
        bd_lines_1(k)=[];
        bd_lines_2(k)=[];

    end


end

bd_lines_1(1)=[];
bd_lines_2(1)=[];

end



% clf 
% hold on
plot(pts_x,pts_y,'o')
for i=1:length(pts_x)
    text(pts_x(i),pts_y(i),num2str(i));
end

for i=1:length(lines_1)
    is_draw=[lines_1(i),lines_2(i)];
    plot(pts_x(is_draw),pts_y(is_draw),'b--')
end

for i=1:length(bd_lines_1)
    is_draw=[bd_lines_1(i),bd_lines_2(i)];
    plot(pts_x(is_draw),pts_y(is_draw),'r-')
end

axis equal


%{
测试相同:...

+[M函数](,测试算法)
%}
## end
#130, 33:
%{

%}

sum(sum([1,2]==[2;3;2]))

## end
#132, 385:
%{
+[M函数](,测试算法)

保存:...
%}

t=linspace(0,360,10);
R=2;
x_bd_0=R*cosd(t(1:end-1));
y_bd_0=R*sind(t(1:end-1));

bd_lines_1=1:length(x_bd_0);
bd_lines_2=[length(x_bd_0),1:length(x_bd_0)-1];

pts_x=x_bd_0;
pts_y=y_bd_0;
lines_1=bd_lines_1;
lines_2=bd_lines_2;

clf
hold on
for i=1:length(lines_1)
    is=[lines_1(i),lines_2(i)];
    plot(x_bd_0(is),y_bd_0(is))
end




%{
+[M函数](,测试算法)
%}
## end
#136, 3517:
%{
+[M函数](,测试算法)

画图:...
单步边界:...
保存:...
%}

t=linspace(0,360,10);
R=2;
ratio=0.5;
x_bd_0=R*cosd(t(1:end-1));
y_bd_0=R*sind(t(1:end-1));

bd_lines_1=1:length(x_bd_0);
bd_lines_2=[length(x_bd_0),1:length(x_bd_0)-1];

pts_x=x_bd_0;
pts_y=y_bd_0;
lines_1=bd_lines_1;
lines_2=bd_lines_2;
% faces=[];

clf 
hold on


for i=1:10

is=[bd_lines_1(1),bd_lines_2(1)];
x0=mean(pts_x(is));
y0=mean(pts_y(is));

Dx=-diff(pts_y(is));
Dy=diff(pts_x(is));
L=sqrt(Dx^2+Dy^2);
Dr=ratio*L;

x_n=x0-Dx*sqrt(3)/2;
y_n=y0-Dy*sqrt(3)/2;

rs=sqrt((pts_x-x_n).^2+(pts_y-y_n).^2);


if isempty(rs(rs<Dr))
    pts_x(end+1)=x_n;
    pts_y(end+1)=y_n;
    n0=length(pts_x);
    lines_1(end+1:end+2)=[is(1),n0];
    lines_2(end+1:end+2)=[n0,is(2)];
    bd_lines_1(end+1:end+2)=[is(1),n0];
    bd_lines_2(end+1:end+2)=[n0,is(2)];
else
    n0=find(rs==min(rs));
    n0=n0(1);
% plot(pts_x(n0),pts_y(n0),'r*')
    con_n=[bd_lines_2(bd_lines_1==n0),bd_lines_1(bd_lines_2==n0)];

    if isempty(con_n(is(1)==con_n))
        lines_1(end+1)=is(1);
        lines_2(end+1)=n0;
        bd_lines_1(end+1)=is(1);
        bd_lines_2(end+1)=n0;

        con_1=[bd_lines_2(bd_lines_1==is(1)),bd_lines_1(bd_lines_2==is(1))];
        if sum(sum(con_n==con_1'))==0
            bd_lines_1(end+1)=is(1);
            bd_lines_2(end+1)=n0;
        else
            for j=1:length(con_n)
                if isempty(con_n(j)==con_1)
                    k=find(bd_lines_1==con_n(j)&bd_lines_2==is(1));
                    bd_lines_1(k)=[];
                    bd_lines_2(k)=[];
                    
                    k=find(bd_lines_2==con_n(j)&bd_lines_1==is(1));
                    bd_lines_1(k)=[];
                    bd_lines_2(k)=[];
                    
                    break;
                end
            end
        end
    else
        k=find(bd_lines_1==n0&bd_lines_2==is(1));
        bd_lines_1(k)=[];
        bd_lines_2(k)=[];
        
        k=find(bd_lines_2==n0&bd_lines_1==is(1));
        bd_lines_1(k)=[];
        bd_lines_2(k)=[];

    end

    if isempty(con_n(is(2)==con_n))
        lines_1(end+1)=is(2);
        lines_2(end+1)=n0;
        bd_lines_1(end+1)=is(2);
        bd_lines_2(end+1)=n0;

        con_2=[bd_lines_2(bd_lines_1==is(2)),bd_lines_1(bd_lines_2==is(2))];
        if sum(sum(con_n==con_1'))==0
            bd_lines_1(end+1)=is(2);
            bd_lines_2(end+1)=n0;
        else
            for j=1:length(con_n)
                if isempty(con_n(j)==con_1)
                    k=find(bd_lines_1==con_n(j)&bd_lines_2==is(2));
                    bd_lines_1(k)=[];
                    bd_lines_2(k)=[];
                    
                    k=find(bd_lines_2==con_n(j)&bd_lines_1==is(2));
                    bd_lines_1(k)=[];
                    bd_lines_2(k)=[];
                    
                    break;
                end
            end
        end
    else
        k=find(bd_lines_1==n0&bd_lines_2==is(2));
        bd_lines_1(k)=[];
        bd_lines_2(k)=[];
        
        k=find(bd_lines_2==n0&bd_lines_1==is(2));
        bd_lines_1(k)=[];
        bd_lines_2(k)=[];

    end


end

bd_lines_1(1)=[];
bd_lines_2(1)=[];

end



% clf 
% hold on
plot(pts_x,pts_y,'o')
for i=1:length(pts_x)
    text(pts_x(i),pts_y(i),num2str(i));
end

for i=1:length(lines_1)
    is_draw=[lines_1(i),lines_2(i)];
    plot(pts_x(is_draw),pts_y(is_draw),'b--')
end

for i=1:length(bd_lines_1)
    is_draw=[bd_lines_1(i),bd_lines_2(i)];
    plot(pts_x(is_draw),pts_y(is_draw),'r-')
end

axis equal


%{
测试相同:...

+[M函数](,测试算法)
%}
## end
#138, 707:
%{
地址::Matlab/mesh/bdFormPolygon.m
+[保存M函数](,bdFormPolygon)

获取数据:...
测试:...
+[新建阅读窗口](,测试)

%}

function [xs,ys,ns]=bdFormPolygon(pts_x,pts_y,lines_1,lines_2,i0)

n0=lines_1(i0);
xs=pts_x(n0);
ys=pts_y(n0);
ns=n0;
n=lines_2(i0);

for i=1:length(pts_x)
xs(end+1)=pts_x(n);
ys(end+1)=pts_y(n);
ns(end+1)=n;

k=find(lines_1==n);
if isempty(k)
    break;
elseif length(k)>1
    for j=1:length(k)
        if ~sum(lines_2(k(j))==ns)
            k=k(j);
            break;
        elseif lines_2(k(j))==n0
            k=k(j);
            break;
        end
    end
    k=k(1);
end

n=lines_2(k);

if n==n0
    break;
end
end

xs(end+1)=xs(1);
ys(end+1)=ys(1);
ns(end+1)=ns(1);

end

%{
+[保存M函数](,bdFormPolygon)
%}
## end
#141, 27:
Matlab/mesh/bdFormPolygon.m
## end
#147, 2621:
%{
+[M函数](,测试算法)
运行指令"nautilus 文档/计算机问题"
运行指令"nautilus Matlab"
Nini, 打开合并多边形(文件)

画图:...
单步边界:...
保存:...

bdFormPolygon(M函数):...
+[新建阅读窗口](,bdFormPolygon)
%}

addpath('Matlab/mesh')

t=linspace(0,360,10);
R=2;
ratio=0.7;
x_bd_0=R*cosd(t(1:end-1));
y_bd_0=R*sind(t(1:end-1));

bd_lines_1=1:length(x_bd_0);
bd_lines_2=[length(x_bd_0),1:length(x_bd_0)-1];
bd_pts_x=x_bd_0;
bd_pts_y=y_bd_0;

pts_x=x_bd_0;
pts_y=y_bd_0;
lines_1=bd_lines_1;
lines_2=bd_lines_2;
% faces=[];

clf 
hold on


for i=1:10

is=[bd_lines_1(1),bd_lines_2(1)];
x0=mean(pts_x(is));
y0=mean(pts_y(is));

Dx=-diff(bd_pts_y(is));
Dy=diff(bd_pts_x(is));
L=sqrt(Dx^2+Dy^2);
Dr=ratio*L;

x_n=x0-Dx*sqrt(3)/2;
y_n=y0-Dy*sqrt(3)/2;

rs=sqrt((bd_pts_x-x_n).^2+(bd_pts_y-y_n).^2);


if isempty(rs(rs<Dr))
    pts_x(end+1)=x_n;
    pts_y(end+1)=y_n;
    bd_pts_x(end+1)=x_n;
    bd_pts_y(end+1)=y_n;

    n0=length(pts_x);
    lines_1(end+1:end+2)=[is(1),n0];
    lines_2(end+1:end+2)=[n0,is(2)];
    bd_lines_1(end+1:end+2)=[is(1),n0];
    bd_lines_2(end+1:end+2)=[n0,is(2)];
else
    n0=find(rs==min(rs));
    n0=n0(1);
% plot(pts_x(n0),pts_y(n0),'r*')
    con_n=[bd_lines_2(bd_lines_1==n0),bd_lines_1(bd_lines_2==n0)];

    if isempty(con_n(is(1)==con_n))
        lines_1(end+1)=is(1);
        lines_2(end+1)=n0;
        bd_lines_1(end+1)=is(1);
        bd_lines_2(end+1)=n0;

    else
        bd_pts_x(is(1))=nan;
        bd_pts_y(is(1))=nan;
        k=find(bd_lines_1==n0&bd_lines_2==is(1));
        if ~isempty(k)
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
        else 
            k=find(bd_lines_2==n0&bd_lines_1==is(1));
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
        end
    end

    if isempty(con_n(is(2)==con_n))
        lines_1(end+1)=n0;
        lines_2(end+1)=is(2);
        bd_lines_1(end+1)=n0;
        bd_lines_2(end+1)=is(2);
    else
        bd_pts_x(is(2))=nan;
        bd_pts_y(is(2))=nan;
        k=find(bd_lines_1==n0&bd_lines_2==is(2));
        if ~isempty(k)
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
        else
            k=find(bd_lines_2==n0&bd_lines_1==is(2));
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
        end

    end


end

bd_lines_1(1)=[];
bd_lines_2(1)=[];

end



% clf 
% hold on
plot(pts_x,pts_y,'o')
for i=1:length(pts_x)
    text(pts_x(i),pts_y(i),num2str(i));
end

for i=1:length(lines_1)
    is_draw=[lines_1(i),lines_2(i)];
    plot(pts_x(is_draw),pts_y(is_draw),'b--')
end

for i=1:length(bd_lines_1)
    is_draw=[bd_lines_1(i),bd_lines_2(i)];
    plot(pts_x(is_draw),pts_y(is_draw),'r-')
end

axis equal


%{
测试相同:...

+[M函数](,测试算法)
%}
## end
#149, 2631:
%{
+[M函数](,测试算法)
运行指令"nautilus 文档/计算机问题"
运行指令"nautilus Matlab"
Nini, 打开合并多边形(文件)

画图:...
单步边界:...
单步边界2:...
保存:...

bdFormPolygon(M函数):...
+[新建阅读窗口](,bdFormPolygon)
%}

addpath('Matlab/mesh')

t=linspace(0,360,10);
R=2;
ratio=0.4;
x_bd_0=R*cosd(t(1:end-1));
y_bd_0=R*sind(t(1:end-1));

bd_lines_1=1:length(x_bd_0);
bd_lines_2=[length(x_bd_0),1:length(x_bd_0)-1];
bd_pts_x=x_bd_0;
bd_pts_y=y_bd_0;

pts_x=x_bd_0;
pts_y=y_bd_0;
lines_1=bd_lines_1;
lines_2=bd_lines_2;
% faces=[];

clf 
hold on


for i=1:10

is=[bd_lines_1(1),bd_lines_2(1)];
x0=mean(pts_x(is));
y0=mean(pts_y(is));

Dx=-diff(bd_pts_y(is));
Dy=diff(bd_pts_x(is));
L=sqrt(Dx^2+Dy^2);
Dr=ratio*L;

x_n=x0-Dx*sqrt(3)/2;
y_n=y0-Dy*sqrt(3)/2;

rs=sqrt((bd_pts_x-x_n).^2+(bd_pts_y-y_n).^2);


if isempty(rs(rs<Dr))
    pts_x(end+1)=x_n;
    pts_y(end+1)=y_n;
    bd_pts_x(end+1)=x_n;
    bd_pts_y(end+1)=y_n;

    n0=length(pts_x);
    lines_1(end+1:end+2)=[is(1),n0];
    lines_2(end+1:end+2)=[n0,is(2)];
    bd_lines_1(end+1:end+2)=[is(1),n0];
    bd_lines_2(end+1:end+2)=[n0,is(2)];
else
    n0=find(rs==min(rs));
    n0=n0(1);
% plot(pts_x(n0),pts_y(n0),'r*')
    con_n=[bd_lines_2(bd_lines_1==n0),bd_lines_1(bd_lines_2==n0)];

    if isempty(con_n(is(1)==con_n))
        lines_1(end+1)=is(1);
        lines_2(end+1)=n0;
        bd_lines_1(end+1)=is(1);
        bd_lines_2(end+1)=n0;

    else
        bd_pts_x(is(1))=nan;
        bd_pts_y(is(1))=nan;
        k=find(bd_lines_1==n0&bd_lines_2==is(1));
        if ~isempty(k)
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
        else 
            k=find(bd_lines_2==n0&bd_lines_1==is(1));
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
        end
    end

    if isempty(con_n(is(2)==con_n))
        lines_1(end+1)=n0;
        lines_2(end+1)=is(2);
        bd_lines_1(end+1)=n0;
        bd_lines_2(end+1)=is(2);
    else
        bd_pts_x(is(2))=nan;
        bd_pts_y(is(2))=nan;
        k=find(bd_lines_1==n0&bd_lines_2==is(2));
        if ~isempty(k)
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
        else
            k=find(bd_lines_2==n0&bd_lines_1==is(2));
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
        end

    end


end

bd_lines_1(1)=[];
bd_lines_2(1)=[];

end



% clf 
% hold on
plot(pts_x,pts_y,'o')
for i=1:length(pts_x)
    text(pts_x(i),pts_y(i),num2str(i));
end

for i=1:length(lines_1)
    is_draw=[lines_1(i),lines_2(i)];
    plot(pts_x(is_draw),pts_y(is_draw),'b--')
end

for i=1:length(bd_lines_1)
    is_draw=[bd_lines_1(i),bd_lines_2(i)];
    plot(pts_x(is_draw),pts_y(is_draw),'r-')
end

axis equal


%{
测试相同:...

+[M函数](,测试算法)
%}
## end
#151, 103:
%{
+[M函数](,测试)
%}

[xs,ys]=bdFormPolygon(pts_x,pts_y,bd_lines_1,bd_lines_2);

plot(xs,ys,'--')


%{

%}
## end
#153, 229:
%{
+[M函数](,测试区域)
is

%}

% ax=pts_x([n0,is,n0]);
% ay=pts_y([n0,is,n0]);
ax=[x_n,pts_x(is),x_n];
ay=[y_n,pts_y(is),y_n];
[n_i,n_w]=PtsInPolygon(ax,ay,pts_x,pts_y);
find(n_i==0)

plot(ax,ay,'r+-')

%{
find(n_i==0)
+[M函数](,测试区域)
%}
## end
#155, 2979:
%{
+[M函数](,测试算法)
运行指令"nautilus 文档/计算机问题"
运行指令"nautilus Matlab"
Nini, 打开合并多边形(文件)

画图:...
单步边界:...
单步边界2:...
远程连接:...

保存:...
测试区域:...
+[新建阅读窗口](,测试区域)

bdFormPolygon(M函数):...
+[新建阅读窗口](,bdFormPolygon)
%}

addpath('Matlab/mesh')
addpath('Matlab/space')
addpath('Matlab/draw')

t=linspace(0,360,20);
R=2;
ratio=0.4;
x_bd_0=R*cosd(t(1:end-1));
y_bd_0=R*sind(t(1:end-1));

bd_lines_1=1:length(x_bd_0);
bd_lines_2=[length(x_bd_0),1:length(x_bd_0)-1];
bd_pts_x=x_bd_0;
bd_pts_y=y_bd_0;

pts_x=x_bd_0;
pts_y=y_bd_0;
lines_1=bd_lines_1;
lines_2=bd_lines_2;
% faces=[];

clf 
hold on


% for i=1:19
for i=1:87

is=[bd_lines_1(1),bd_lines_2(1)];
x0=mean(pts_x(is));
y0=mean(pts_y(is));

Dx=-diff(bd_pts_y(is));
Dy=diff(bd_pts_x(is));
L=sqrt(Dx^2+Dy^2);
Dr=ratio*L;

x_n=x0-Dx*sqrt(3)/2;
y_n=y0-Dy*sqrt(3)/2;

n0=nan;

ax=[x_n,pts_x(is),x_n];
ay=[y_n,pts_y(is),y_n];
[n_i,n_w]=PtsInPolygon(ax,ay,pts_x,pts_y);
if ~isempty(n_i(n_i==0))
    n0=find(n_i==0);
    n0=n0(1);
end

rs=sqrt((bd_pts_x-x_n).^2+(bd_pts_y-y_n).^2);
if ~isempty(rs(rs<Dr))
    n0=find(rs==min(rs));
    n0=n0(1);
end


% if isempty(rs(rs<Dr))
if isnan(n0)
    pts_x(end+1)=x_n;
    pts_y(end+1)=y_n;
    bd_pts_x(end+1)=x_n;
    bd_pts_y(end+1)=y_n;

    n0=length(pts_x);
    lines_1(end+1:end+2)=[is(1),n0];
    lines_2(end+1:end+2)=[n0,is(2)];
    bd_lines_1(end+1:end+2)=[is(1),n0];
    bd_lines_2(end+1:end+2)=[n0,is(2)];
else
% plot(pts_x(n0),pts_y(n0),'r*')
    con_n=[bd_lines_2(bd_lines_1==n0),bd_lines_1(bd_lines_2==n0)];

    if isempty(con_n(is(1)==con_n))
        lines_1(end+1)=is(1);
        lines_2(end+1)=n0;
        bd_lines_1(end+1)=is(1);
        bd_lines_2(end+1)=n0;

    else
        bd_pts_x(is(1))=nan;
        bd_pts_y(is(1))=nan;
        k=find(bd_lines_1==n0&bd_lines_2==is(1));
        if ~isempty(k)
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
        else 
            k=find(bd_lines_2==n0&bd_lines_1==is(1));
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
        end
    end

    if isempty(con_n(is(2)==con_n))
        lines_1(end+1)=n0;
        lines_2(end+1)=is(2);
        bd_lines_1(end+1)=n0;
        bd_lines_2(end+1)=is(2);
    else
        bd_pts_x(is(2))=nan;
        bd_pts_y(is(2))=nan;
        k=find(bd_lines_1==n0&bd_lines_2==is(2));
        if ~isempty(k)
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
        else
            k=find(bd_lines_2==n0&bd_lines_1==is(2));
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
        end

    end


end

bd_lines_1(1)=[];
bd_lines_2(1)=[];

if isempty(bd_lines_1)
    i
    break;
end

end



% clf 
% hold on
plot(pts_x,pts_y,'o')
for i=1:length(pts_x)
    text(pts_x(i),pts_y(i),num2str(i));
end

for i=1:length(lines_1)
    is_draw=[lines_1(i),lines_2(i)];
    plot(pts_x(is_draw),pts_y(is_draw),'b--')
end

for i=1:length(bd_lines_1)
    is_draw=[bd_lines_1(i),bd_lines_2(i)];
    plot(pts_x(is_draw),pts_y(is_draw),'r-')
end

axis equal


%{
测试相同:...

+[M函数](,测试算法)
%}
## end
#157, 3014:
%{
+[M函数](,测试算法)
运行指令"nautilus 文档/计算机问题"
运行指令"nautilus Matlab"
Nini, 打开合并多边形(文件)

画图:...
单步边界:...
单步边界2:...
远程连接:...

保存:...
测试区域:...
+[新建阅读窗口](,测试区域)

bdFormPolygon(M函数):...
+[新建阅读窗口](,bdFormPolygon)
%}

addpath('Matlab/mesh')
addpath('Matlab/space')
addpath('Matlab/draw')

t=linspace(0,360,20);
R=2;
ratio=0.4;
x_bd_0=R*cosd(t(1:end-1));
y_bd_0=R*sind(t(1:end-1));

bd_lines_1=1:length(x_bd_0);
bd_lines_2=[length(x_bd_0),1:length(x_bd_0)-1];
bd_pts_x=x_bd_0;
bd_pts_y=y_bd_0;

pts_x=x_bd_0;
pts_y=y_bd_0;
lines_1=bd_lines_1;
lines_2=bd_lines_2;
% faces=[];

clf 
hold on


% for i=1:19
% for i=1:88
for i=1:300

is=[bd_lines_1(1),bd_lines_2(1)];
x0=mean(pts_x(is));
y0=mean(pts_y(is));

Dx=-diff(bd_pts_y(is));
Dy=diff(bd_pts_x(is));
L=sqrt(Dx^2+Dy^2);
Dr=ratio*L;

x_n=x0-Dx*sqrt(3)/2;
y_n=y0-Dy*sqrt(3)/2;

n0=nan;

ax=[x_n,pts_x(is),x_n];
ay=[y_n,pts_y(is),y_n];
[n_i,n_w]=PtsInPolygon(ax,ay,pts_x,pts_y);
if ~isempty(n_i(n_i==0))
%    n0=find(n_i==0);
%    n0=n0(1);
end

rs=sqrt((bd_pts_x-x_n).^2+(bd_pts_y-y_n).^2);
if ~isempty(rs(rs<Dr))
    n0=find(rs==min(rs));
    n0=n0(1);
end


% if isempty(rs(rs<Dr))
if isnan(n0)
    pts_x(end+1)=x_n;
    pts_y(end+1)=y_n;
    bd_pts_x(end+1)=x_n;
    bd_pts_y(end+1)=y_n;

    n0=length(pts_x);
    lines_1(end+1:end+2)=[is(1),n0];
    lines_2(end+1:end+2)=[n0,is(2)];
    bd_lines_1(end+1:end+2)=[is(1),n0];
    bd_lines_2(end+1:end+2)=[n0,is(2)];
else
% plot(pts_x(n0),pts_y(n0),'r*')
    con_n=[bd_lines_2(bd_lines_1==n0),bd_lines_1(bd_lines_2==n0)];

    if isempty(con_n(is(1)==con_n))
        lines_1(end+1)=is(1);
        lines_2(end+1)=n0;
        bd_lines_1(end+1)=is(1);
        bd_lines_2(end+1)=n0;

    else
        bd_pts_x(is(1))=nan;
        bd_pts_y(is(1))=nan;
        k=find(bd_lines_1==n0&bd_lines_2==is(1));
        if ~isempty(k)
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
        else 
            k=find(bd_lines_2==n0&bd_lines_1==is(1));
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
        end
    end

    if isempty(con_n(is(2)==con_n))
        lines_1(end+1)=n0;
        lines_2(end+1)=is(2);
        bd_lines_1(end+1)=n0;
        bd_lines_2(end+1)=is(2);
    else
        bd_pts_x(is(2))=nan;
        bd_pts_y(is(2))=nan;
        k=find(bd_lines_1==n0&bd_lines_2==is(2));
        if ~isempty(k)
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
        else
            k=find(bd_lines_2==n0&bd_lines_1==is(2));
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
        end

    end


end

bd_lines_1(1)=[];
bd_lines_2(1)=[];

if isempty(bd_lines_1)
    i
    break;
end

end



% clf 
% hold on
plot(pts_x,pts_y,'o')
for i=1:length(pts_x)
    text(pts_x(i),pts_y(i),num2str(i));
end

for i=1:length(lines_1)
    is_draw=[lines_1(i),lines_2(i)];
    plot(pts_x(is_draw),pts_y(is_draw),'b--')
end

for i=1:length(bd_lines_1)
    is_draw=[bd_lines_1(i),bd_lines_2(i)];
    plot(pts_x(is_draw),pts_y(is_draw),'r-')
end

plot(x_n,y_n,'g+')
axis equal


%{
测试相同:...

+[M函数](,测试算法)
%}
## end
#160, 3607:
%{
+[M函数](,测试算法)
运行指令"nautilus 文档/计算机问题"
运行指令"nautilus Matlab"
Nini, 打开合并多边形的PtsInPolygon(节点)
is
画图:...
单步边界:...
单步边界2:...
远程连接:...
完成扫描1:...
外部三角:...

等比缩小:...

保存:...
测试区域:...
+[新建阅读窗口](,测试区域)

bdFormPolygon(M函数):...
hasInterTriangle(M函数):...
rmInterTriangle(M函数):...
+[新建阅读窗口](,hasInterTriangle)
%}

addpath('Matlab/mesh')
addpath('Matlab/space')
addpath('Matlab/draw')

t=linspace(0,360,20);
R=2;
ratio=0.5;
Dr0=0.3;
x_bd_0=R*cosd(t(1:end-1));
y_bd_0=R*sind(t(1:end-1))*2;

bd_lines_1=1:length(x_bd_0);
bd_lines_2=[length(x_bd_0),1:length(x_bd_0)-1];
bd_pts_x=x_bd_0;
bd_pts_y=y_bd_0;

pts_x=x_bd_0;
pts_y=y_bd_0;
lines_1=bd_lines_1;
lines_2=bd_lines_2;
% faces=[];

clf 
hold on

% for i=1:51
for i=1:200
[state,pts_tri,lines_tri]=hasInterTriangle(1,bd_lines_1,bd_lines_2);
if state
    n_del=rmInterTriangle(pts_tri,lines_tri,bd_lines_1,bd_lines_2);
    bd_pts_x(pts_tri(n_del))=nan;
    bd_pts_y(pts_tri(n_del))=nan;
    bd_lines_1(lines_tri)=[];
    bd_lines_2(lines_tri)=[];
    if isempty(bd_lines_1)
        break;
    else
        continue
    end
else
    is=[bd_lines_1(1),bd_lines_2(1)];
end

x0=mean(pts_x(is));
y0=mean(pts_y(is));

Dx=-diff(bd_pts_y(is));
Dy=diff(bd_pts_x(is));
L=sqrt(Dx^2+Dy^2);

Dr=ratio*L;
Dr=max([Dr,Dr0]);

x_n=x0-Dx*sqrt(3)/2;
y_n=y0-Dy*sqrt(3)/2;

n0=nan;

rs=sqrt((bd_pts_x-x_n).^2+(bd_pts_y-y_n).^2);
if ~isempty(rs(rs<Dr))
    n0=find(rs==min(rs));
    n0=n0(1);
end

ax=[x_n,pts_x(is),x_n];
ay=[y_n,pts_y(is),y_n];
% ax=pts_x([n0,is,n0]);
% ay=pts_y([n0,is,n0]);
[n_i,n_w]=PtsInPolygon(ax,ay,pts_x,pts_y);
if ~isempty(n_i(n_i==0))
    n1=find(n_i==0);
    n1(n1==is(1))=[];
    n1(n1==is(2))=[];
    if ~isempty(n1)
        n0=n1(1);
    end
end


% if isempty(rs(rs<Dr))
if isnan(n0)
    pts_x(end+1)=x_n;
    pts_y(end+1)=y_n;
    bd_pts_x(end+1)=x_n;
    bd_pts_y(end+1)=y_n;

    n0=length(pts_x);
    lines_1(end+1:end+2)=[is(1),n0];
    lines_2(end+1:end+2)=[n0,is(2)];
    bd_lines_1(end+1:end+2)=[is(1),n0];
    bd_lines_2(end+1:end+2)=[n0,is(2)];
else
% plot(pts_x(n0),pts_y(n0),'r*')
    con_n=[bd_lines_2(bd_lines_1==n0),bd_lines_1(bd_lines_2==n0)];

    if isempty(con_n(is(1)==con_n))
        lines_1(end+1)=is(1);
        lines_2(end+1)=n0;
        bd_lines_1(end+1)=is(1);
        bd_lines_2(end+1)=n0;

    else
        bd_pts_x(is(1))=nan;
        bd_pts_y(is(1))=nan;
        k=find(bd_lines_1==n0&bd_lines_2==is(1));
        if ~isempty(k)
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
        else 
            k=find(bd_lines_2==n0&bd_lines_1==is(1));
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
        end
    end

    if isempty(con_n(is(2)==con_n))
        lines_1(end+1)=n0;
        lines_2(end+1)=is(2);
        bd_lines_1(end+1)=n0;
        bd_lines_2(end+1)=is(2);
    else
        bd_pts_x(is(2))=nan;
        bd_pts_y(is(2))=nan;
        k=find(bd_lines_1==n0&bd_lines_2==is(2));
        if ~isempty(k)
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
        else
            k=find(bd_lines_2==n0&bd_lines_1==is(2));
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
        end

    end


end

bd_lines_1(1)=[];
bd_lines_2(1)=[];

if isempty(bd_lines_1)
    break;
end

end



% clf 
% hold on
plot(pts_x,pts_y,'o')
for i=1:length(pts_x)
    text(pts_x(i),pts_y(i),num2str(i));
end

for i=1:length(lines_1)
    is_draw=[lines_1(i),lines_2(i)];
    plot(pts_x(is_draw),pts_y(is_draw),'b--')
end

for i=1:length(bd_lines_1)
    is_draw=[bd_lines_1(i),bd_lines_2(i)];
    plot(pts_x(is_draw),pts_y(is_draw),'r-')
end

plot(x_n,y_n,'g+')
axis equal


%{
测试相同:...

+[M函数](,测试算法)
%}
## end
#162, 867:
%{
地址::Matlab/mesh/hasInterTriangle.m
+[保存M函数](,hasInterTriangle)

测试:...
%}

function [state,pts,lines]=hasInterTriangle(li,bd_lines_1,bd_lines_2)
% li=1;
is=[bd_lines_1(li),bd_lines_2(li)];

state=false;
j0=0;
ls=[find(bd_lines_2==is(1)),find(bd_lines_1==is(1))];
js=[bd_lines_1(bd_lines_2==is(1)),bd_lines_2(bd_lines_1==is(1))];
ls(js==is(2))=[];
js(js==is(2))=[];
for i=1:length(js)
    if sum(bd_lines_1(bd_lines_2==js(i))==is(2))
        l0=find(bd_lines_1==is(2) & (bd_lines_2==js(i)));
        state=true;
        j0=js(i);
        break;
    end
    if sum(bd_lines_2(bd_lines_1==js(i))==is(2))
        l0=find(bd_lines_2==is(2) & (bd_lines_1==js(i)));
        state=true;
        j0=js(i);
        break;
    end
end

if state
    lines=[li,ls(i),l0];
    pts=[j0,is];
else
    lines=[];
    pts=[];
end

end


%{
bd_pts_y(is)
+[保存M函数](,hasInterTriangle)
%}
## end
#165, 693:
%{
+[M函数](,hasInterTriangle)
测试:...
%}

li=1;
is=[bd_lines_1(1),bd_lines_2(1)];

state=false;
j0=0;
ls=[find(bd_lines_2==is(1)),find(bd_lines_1==is(1))];
js=[bd_lines_1(bd_lines_2==is(1)),bd_lines_2(bd_lines_1==is(1))];
ls(js==is(2))=[];
js(js==is(2))=[];
for i=1:length(js)
    if sum(bd_lines_1(bd_lines_2==js(i))==is(2))
        l0=find(bd_lines_1==is(2) & (bd_lines_2==js(i)));
        state=true;
        j0=js(i);
        break;
    end
    if sum(bd_lines_2(bd_lines_1==js(i))==is(2))
        l0=find(bd_lines_2==is(2) & (bd_lines_1==js(i)));
        state=true;
        j0=js(i);
        break;
    end
end

lines=[li,ls(i),l0]
pts=[j0,is]

%{
bd_pts_y(is)
+[M函数](,hasInterTriangle)
%}
## end
#167, 30:
Matlab/mesh/hasInterTriangle.m
## end
#172, 398:
%{
地址::Matlab/mesh/rmInterTriangle.m
+[保存M函数](,rmInterTriangle)
%}

function n_del=rmInterTriangle(pts_tri,lines_tri,bd_lines_1,bd_lines_2)
n_del=[false,false,false];
for i=1:3
    ls=[find(bd_lines_1==pts_tri(i)),find(bd_lines_2==pts_tri(i))];
    ls(ls==lines_tri(1))=[];
    ls(ls==lines_tri(2))=[];
    ls(ls==lines_tri(3))=[];
    n_del(i)=isempty(ls);
end

end

%{
+[M函数](,rmInterTriangle)
%}
## end
#175, 29:
Matlab/mesh/rmInterTriangle.m
## end
#180, 3595:
%{
+[M函数](,测试算法)
运行指令"nautilus 文档/计算机问题"
运行指令"nautilus Matlab"
Nini, 打开合并多边形的PtsInPolygon(节点)
is
画图:...
单步边界:...
单步边界2:...
远程连接:...
完成扫描1:...

等比缩小:...

保存:...
测试区域:...
+[新建阅读窗口](,测试区域)

bdFormPolygon(M函数):...
hasInterTriangle(M函数):...
rmInterTriangle(M函数):...
+[新建阅读窗口](,hasInterTriangle)
%}

addpath('Matlab/mesh')
addpath('Matlab/space')
addpath('Matlab/draw')

t=linspace(0,360,20);
R=2;
ratio=0.5;
Dr0=0.4;
x_bd_0=R*cosd(t(1:end-1));
y_bd_0=R*sind(t(1:end-1));

bd_lines_1=1:length(x_bd_0);
bd_lines_2=[length(x_bd_0),1:length(x_bd_0)-1];
bd_pts_x=x_bd_0;
bd_pts_y=y_bd_0;

pts_x=x_bd_0;
pts_y=y_bd_0;
lines_1=bd_lines_1;
lines_2=bd_lines_2;
% faces=[];

clf 
hold on

% for i=1:51
for i=1:77
[state,pts_tri,lines_tri]=hasInterTriangle(1,bd_lines_1,bd_lines_2);
if state
    n_del=rmInterTriangle(pts_tri,lines_tri,bd_lines_1,bd_lines_2);
    bd_pts_x(pts_tri(n_del))=nan;
    bd_pts_y(pts_tri(n_del))=nan;
    bd_lines_1(lines_tri)=[];
    bd_lines_2(lines_tri)=[];
    if isempty(bd_lines_1)
        break;
    else
        continue
    end
else
    is=[bd_lines_1(1),bd_lines_2(1)];
end

x0=mean(pts_x(is));
y0=mean(pts_y(is));

Dx=-diff(bd_pts_y(is));
Dy=diff(bd_pts_x(is));
L=sqrt(Dx^2+Dy^2);

Dr=ratio*L;
Dr=max([Dr,Dr0]);

x_n=x0-Dx*sqrt(3)/2;
y_n=y0-Dy*sqrt(3)/2;

n0=nan;

rs=sqrt((bd_pts_x-x_n).^2+(bd_pts_y-y_n).^2);
if ~isempty(rs(rs<Dr))
    n0=find(rs==min(rs));
    n0=n0(1);
end

ax=[x_n,pts_x(is),x_n];
ay=[y_n,pts_y(is),y_n];
% ax=pts_x([n0,is,n0]);
% ay=pts_y([n0,is,n0]);
[n_i,n_w]=PtsInPolygon(ax,ay,pts_x,pts_y);
if ~isempty(n_i(n_i==0))
    n1=find(n_i==0);
    n1(n1==is(1))=[];
    n1(n1==is(2))=[];
    if ~isempty(n1)
        n0=n1(1);
    end
end


% if isempty(rs(rs<Dr))
if isnan(n0)
    pts_x(end+1)=x_n;
    pts_y(end+1)=y_n;
    bd_pts_x(end+1)=x_n;
    bd_pts_y(end+1)=y_n;

    n0=length(pts_x);
    lines_1(end+1:end+2)=[is(1),n0];
    lines_2(end+1:end+2)=[n0,is(2)];
    bd_lines_1(end+1:end+2)=[is(1),n0];
    bd_lines_2(end+1:end+2)=[n0,is(2)];
else
% plot(pts_x(n0),pts_y(n0),'r*')
    con_n=[bd_lines_2(bd_lines_1==n0),bd_lines_1(bd_lines_2==n0)];

    if isempty(con_n(is(1)==con_n))
        lines_1(end+1)=is(1);
        lines_2(end+1)=n0;
        bd_lines_1(end+1)=is(1);
        bd_lines_2(end+1)=n0;

    else
        bd_pts_x(is(1))=nan;
        bd_pts_y(is(1))=nan;
        k=find(bd_lines_1==n0&bd_lines_2==is(1));
        if ~isempty(k)
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
        else 
            k=find(bd_lines_2==n0&bd_lines_1==is(1));
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
        end
    end

    if isempty(con_n(is(2)==con_n))
        lines_1(end+1)=n0;
        lines_2(end+1)=is(2);
        bd_lines_1(end+1)=n0;
        bd_lines_2(end+1)=is(2);
    else
        bd_pts_x(is(2))=nan;
        bd_pts_y(is(2))=nan;
        k=find(bd_lines_1==n0&bd_lines_2==is(2));
        if ~isempty(k)
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
        else
            k=find(bd_lines_2==n0&bd_lines_1==is(2));
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
        end

    end


end

bd_lines_1(1)=[];
bd_lines_2(1)=[];

if isempty(bd_lines_1)
    break;
end

end



% clf 
% hold on
plot(pts_x,pts_y,'o')
for i=1:length(pts_x)
    text(pts_x(i),pts_y(i),num2str(i));
end

for i=1:length(lines_1)
    is_draw=[lines_1(i),lines_2(i)];
    plot(pts_x(is_draw),pts_y(is_draw),'b--')
end

for i=1:length(bd_lines_1)
    is_draw=[bd_lines_1(i),bd_lines_2(i)];
    plot(pts_x(is_draw),pts_y(is_draw),'r-')
end

plot(x_n,y_n,'g+')
axis equal


%{
测试相同:...

+[M函数](,测试算法)
%}
## end
#182, 425:
%{
+[M函数](,测试区域2)
%}

[xs,ys,ns]=bdFormPolygon(pts_x,pts_y,bd_lines_1,bd_lines_2,1);
[n_i,n_w]=PtsInPolygon(xs,ys,x_n,y_n);

xs0=xs;
ys0=ys;
if n_i==1
    xs(ns==is(1))=[];
    ys(ns==is(1))=[];
    ns(ns==is(1))=[];
    xs(ns==is(2))=[];
    ys(ns==is(2))=[];
    ns(ns==is(2))=[];

    rs=sqrt((xs-x_n).^2+(ys-y_n).^2);
    n0=ns(rs==min(rs));
end
plot(xs,ys,'y',x_n,y_n,'r*',pts_x(n0),pts_y(n0),'ro')

%{
+[M函数](,测试区域2)
%}
## end
#184, 1416:
%{
地址::Matlab/mesh/pickUpExistedPt.m
+[保存M函数](,pickUpExistedPt)

测试区域:...
测试区域2:...
测试区域3:...
+[新建阅读窗口](,测试区域3)

intersection_line_lines_2(M函数):...
保存:...
%}

function n0=pickUpExistedPt(x_n,y_n,Dr,is,pts_x,pts_y,bd_pts_x,bd_pts_y,bd_lines_1,bd_lines_2)

n0=nan;
rs=sqrt((bd_pts_x-x_n).^2+(bd_pts_y-y_n).^2);
if ~isempty(rs(rs<Dr))
    n0=find(rs==min(rs));
    n0=n0(1);
end

ax=[x_n,pts_x(is),x_n];
ay=[y_n,pts_y(is),y_n];
[n_i,n_w]=PtsInPolygon(ax,ay,pts_x,pts_y);
if ~isempty(n_i(n_i==0))
    n1=find(n_i==0);
    n1(n1==is(1))=[];
    n1(n1==is(2))=[];
    if ~isempty(n1)
        n0=n1(1);
    end
end

if ~isnan(n0)
    x_n=pts_x(n0);
    y_n=pts_y(n0);
end

for i=1:2
    x1=[x_n,pts_x(is(i))];
    y1=[y_n,pts_y(is(i))];
    
    xs(1,:)=pts_x(bd_lines_1);
    ys(1,:)=pts_y(bd_lines_1);
    xs(2,:)=pts_x(bd_lines_2);
    ys(2,:)=pts_y(bd_lines_2);
    
    [x0,y0,li]=intersection_line_lines_2(x1,y1,xs,ys);
    li(abs(x0-x1(2))<1e-10&abs(y0-y1(2))<1e-10)=nan;
    li(abs(x0-x1(1))<1e-10&abs(y0-y1(1))<1e-10)=nan;
    li(isnan(li))=[];
    if ~isempty(li)
        % n0=bd_lines_1(li(1));
        ns=[bd_lines_1(li),bd_lines_2(li)];
        ns(ns==is(1))=[];
        ns(ns==is(2))=[];
        xs=pts_x(ns);
        ys=pts_y(ns);
        rs=sqrt((xs-mean(pts_x(is))).^2+(ys-mean(pts_y(is))).^2);
        n0=ns(rs==min(rs));
        n0=n0(1);

        break;
    end
end
end

%{
+[保存M函数](,pickUpExistedPt)
%}
## end
#187, 29:
Matlab/mesh/pickUpExistedPt.m
## end
#192, 409:
%{
+[M函数](,测试区域2)
%}

[xs,ys,ns]=bdFormPolygon(pts_x,pts_y,bd_lines_1,bd_lines_2,1);
[n_i,n_w]=PtsInPolygon(xs,ys,x_n,y_n);

if n_i==1
    xs(ns==is(1))=[];
    ys(ns==is(1))=[];
    ns(ns==is(1))=[];
    xs(ns==is(2))=[];
    ys(ns==is(2))=[];
    ns(ns==is(2))=[];

    rs=sqrt((xs-x_n).^2+(ys-y_n).^2);
    n0=ns(rs==min(rs));
end
plot(xs,ys,'y',x_n,y_n,'r*',pts_x(n0),pts_y(n0),'ro')

%{
+[M函数](,测试区域2)
%}
## end
#194, 229:
%{
+[M函数](,测试区域)
is

%}

% ax=pts_x([n0,is,n0]);
% ay=pts_y([n0,is,n0]);
ax=[x_n,pts_x(is),x_n];
ay=[y_n,pts_y(is),y_n];
[n_i,n_w]=PtsInPolygon(ax,ay,pts_x,pts_y);
find(n_i==0)

plot(ax,ay,'r+-')

%{
find(n_i==0)
+[M函数](,测试区域)
%}
## end
#196, 1111:
%{
地址::Matlab/mesh/pickUpExistedPt.m
+[保存M函数](,pickUpExistedPt)

测试区域:...
测试区域2:...
测试区域3:...
+[新建阅读窗口](,测试区域3)

intersection_line_lines_2(M函数):...
保存:...
%}

function n0=pickUpExistedPt(x_n,y_n,Dr,is,pts_x,pts_y,bd_pts_x,bd_pts_y,bd_lines_1,bd_lines_2)

n0=nan;
rs=sqrt((bd_pts_x-x_n).^2+(bd_pts_y-y_n).^2);
if ~isempty(rs(rs<Dr))
    n0=find(rs==min(rs));
    n0=n0(1);
end

ax=[x_n,pts_x(is),x_n];
ay=[y_n,pts_y(is),y_n];
[n_i,n_w]=PtsInPolygon(ax,ay,pts_x,pts_y);
if ~isempty(n_i(n_i==0))
    n1=find(n_i==0);
    n1(n1==is(1))=[];
    n1(n1==is(2))=[];
    if ~isempty(n1)
        n0=n1(1);
    end
end

if isnan(n0)
    for i=1:2
        x1=[x_n,pts_x(is(i))];
        y1=[y_n,pts_y(is(i))];
        
        xs(1,:)=pts_x(bd_lines_1);
        ys(1,:)=pts_y(bd_lines_1);
        xs(2,:)=pts_x(bd_lines_2);
        ys(2,:)=pts_y(bd_lines_2);
        
        [x0,y0,li]=intersection_line_lines_2(x1,y1,xs,ys);
        li(abs(x0-x1(2))<1e-10&abs(y0-y1(2))<1e-10)=[];
        if ~isempty(li)
            n0=bd_lines_1(li(1))
            break;
        end
    end
end


end


%{
+[保存M函数](,pickUpExistedPt)
%}
## end
#198, 610:
%{
+[M函数](,测试区域3)
%}

addpath('Matlab/space')
i=2;
x1=[x_n,pts_x(is(i))];
y1=[y_n,pts_y(is(i))];


xs=pts_x(bd_lines_1);
ys=pts_y(bd_lines_1);
xs(2,:)=pts_x(bd_lines_2);
ys(2,:)=pts_y(bd_lines_2);

[x0,y0,li]=intersection_line_lines_2(x1,y1,xs,ys);
li(abs(x0-x1(2))<1e-10&abs(y0-y1(2))<1e-10)=nan;
li(abs(x0-x1(1))<1e-10&abs(y0-y1(1))<1e-10)=nan;
li(isnan(li))=[];

ns=[bd_lines_1(li(1)),bd_lines_2(li(1)),bd_lines_1(li(2)),bd_lines_2(li(2))];
xs=pts_x(ns);
ys=pts_y(ns);
rs=sqrt((xs-x1(2)).^2+(ys-y1(2)).^2);
n0=ns(rs==min(rs));
n0=n0(1);

% plot(xs,ys,x1,y1,'r',x0,y0,'ro')
% axis equal

%{
+[M函数](,测试区域3)
%}
## end
#200, 969:
%{
+[保存M函数](,intersection_line_lines_2)
地址::Matlab/mesh/intersection_line_lines_2.m
%}

function [x0,y0,i,xs0,ys0,on_line1,on_line2]=intersection_line_lines_2(x1,y1,x2,y2)

% x1=[2,0];
% y1=[0.2,0.5];
% x2=[0,1,2,3];
% y2=[0,1,0,1];

x2_L1=x2(1,:);
x2_L2=x2(2,:);
y2_L1=y2(1,:);
y2_L2=y2(2,:);

D1=x1(1).*y1(2)-x1(2).*y1(1);
D2=x2_L1.*y2_L2-x2_L2.*y2_L1;
Dx1=x1(2)-x1(1);
Dx2=x2_L2-x2_L1;
Dy1=y1(2)-y1(1);
Dy2=y2_L2-y2_L1;
x0=(D1*Dx2-D2*Dx1)./(Dy1*Dx2-Dy2*Dx1);
y0=(D1*Dy2-D2*Dy1)./(Dy1*Dx2-Dy2*Dx1);

Ds2=(x0-x2_L1).*(x2_L2-x2_L1)+(y0-y2_L1).*(y2_L2-y2_L1);
Ls2=sqrt((x2_L2-x2_L1).^2+(y2_L2-y2_L1).^2);
Ds1=(x0-x1(1)).*(x1(2)-x1(1))+(y0-y1(1)).*(y1(2)-y1(1));
Ls1=sqrt((x1(2)-x1(1)).^2+(y1(2)-y1(1)).^2);

on_line2=(Ds2./Ls2.^2>=-1e-10 & Ds2./Ls2.^2<=1+1e-10);
on_line1=(Ds1./Ls1.^2>=-1e-10 & Ds1./Ls1.^2<=1+1e-10);

xs0=x0;
ys0=y0;
x0=xs0(on_line1 & on_line2);
y0=ys0(on_line1 & on_line2);
i=find(on_line1 & on_line2);
end


%{
+[保存M函数](,intersection_line_lines_2)
%}
## end
#203, 39:
Matlab/mesh/intersection_line_lines_2.m
## end
#208, 3377:
%{
+[M函数](,测试算法)
运行指令"nautilus 文档/计算机问题"
运行指令"nautilus Matlab"
Nini, 打开合并多边形的PtsInPolygon(节点)
is
画图:...
单步边界:...
单步边界2:...
远程连接:...
完成扫描1:...
外部三角:...

等比缩小:...

保存:...
测试区域:...
测试区域2:...
+[新建阅读窗口](,测试区域2)

bdFormPolygon(M函数):...
pickUpExistedPt(M函数):...
hasInterTriangle(M函数):...
rmInterTriangle(M函数):...
+[新建阅读窗口](,hasInterTriangle)
+[新建阅读窗口](,bdFormPolygon)
%}

addpath('Matlab/mesh')
addpath('Matlab/space')
addpath('Matlab/draw')

t=linspace(0,360,40);
R=5;
% ratio=0.9;
ratio=0.3;
Dr0=0.3;
x_bd_0=R*cosd(t(1:end-1));
y_bd_0=R*sind(t(1:end-1));

bd_lines_1=1:length(x_bd_0);
bd_lines_2=[length(x_bd_0),1:length(x_bd_0)-1];
bd_pts_x=x_bd_0;
bd_pts_y=y_bd_0;

pts_x=x_bd_0;
pts_y=y_bd_0;
lines_1=bd_lines_1;
lines_2=bd_lines_2;
% faces=[];

clf 
hold on

for i=1:690
[state,pts_tri,lines_tri]=hasInterTriangle(1,bd_lines_1,bd_lines_2);
if state
    n_del=rmInterTriangle(pts_tri,lines_tri,bd_lines_1,bd_lines_2);
    bd_pts_x(pts_tri(n_del))=nan;
    bd_pts_y(pts_tri(n_del))=nan;
    bd_lines_1(lines_tri)=[];
    bd_lines_2(lines_tri)=[];
    if isempty(bd_lines_1)
        break;
    else
        continue
    end
else
    is=[bd_lines_1(1),bd_lines_2(1)];
end

x0=mean(pts_x(is));
y0=mean(pts_y(is));

Dx=-diff(bd_pts_y(is));
Dy=diff(bd_pts_x(is));
L=sqrt(Dx^2+Dy^2);

x_n=x0-Dx*sqrt(3)/2;
y_n=y0-Dy*sqrt(3)/2;

Dr=ratio*L;
Dr=max([Dr,Dr0]);

n0=pickUpExistedPt(x_n,y_n,Dr,is,pts_x,pts_y,bd_pts_x,bd_pts_y,bd_lines_1,bd_lines_2);

% if isempty(rs(rs<Dr))
if isnan(n0)
    pts_x(end+1)=x_n;
    pts_y(end+1)=y_n;
    bd_pts_x(end+1)=x_n;
    bd_pts_y(end+1)=y_n;

    n0=length(pts_x);
    lines_1(end+1:end+2)=[is(1),n0];
    lines_2(end+1:end+2)=[n0,is(2)];
    bd_lines_1(end+1:end+2)=[is(1),n0];
    bd_lines_2(end+1:end+2)=[n0,is(2)];
else
% plot(pts_x(n0),pts_y(n0),'r*')
    con_n=[bd_lines_2(bd_lines_1==n0),bd_lines_1(bd_lines_2==n0)];

    if isempty(con_n(is(1)==con_n))
        lines_1(end+1)=is(1);
        lines_2(end+1)=n0;
        bd_lines_1(end+1)=is(1);
        bd_lines_2(end+1)=n0;

    else
        bd_pts_x(is(1))=nan;
        bd_pts_y(is(1))=nan;
        k=find(bd_lines_1==n0&bd_lines_2==is(1));
        if ~isempty(k)
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
        else 
            k=find(bd_lines_2==n0&bd_lines_1==is(1));
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
        end
    end

    if isempty(con_n(is(2)==con_n))
        lines_1(end+1)=n0;
        lines_2(end+1)=is(2);
        bd_lines_1(end+1)=n0;
        bd_lines_2(end+1)=is(2);
    else
        bd_pts_x(is(2))=nan;
        bd_pts_y(is(2))=nan;
        k=find(bd_lines_1==n0&bd_lines_2==is(2));
        if ~isempty(k)
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
        else
            k=find(bd_lines_2==n0&bd_lines_1==is(2));
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
        end

    end


end

bd_lines_1(1)=[];
bd_lines_2(1)=[];

if isempty(bd_lines_1)
    break;
end

end



% clf 
% hold on
plot(pts_x,pts_y,'o')
for i=1:length(pts_x)
    text(pts_x(i),pts_y(i),num2str(i));
end

for i=1:length(lines_1)
    is_draw=[lines_1(i),lines_2(i)];
    plot(pts_x(is_draw),pts_y(is_draw),'b--')
end

for i=1:length(bd_lines_1)
    is_draw=[bd_lines_1(i),bd_lines_2(i)];
    plot(pts_x(is_draw),pts_y(is_draw),'r-')
end

plot(pts_x(is),pts_y(is),'g-.',x_n,y_n,'g+')
axis equal


%{
测试相同:...

+[M函数](,测试算法)
%}
## end
#210, 3580:
%{
地址::Matlab/mesh/meshGeneration_AF.m
+[保存M函数](,meshGeneration_AF)
faces
测试:...
测试2:...
+[M函数](,测试2)
%}

function [pts_x,pts_y,lines_1,lines_2,faces]=meshGeneration_AF(x_bd_0,y_bd_0,bd_lines_1,bd_lines_2,N,ratio,Dr0)

% addpath('Matlab/mesh')
% addpath('Matlab/space')
% addpath('Matlab/draw')

% t=linspace(0,360,20);
% R=5;
% ratio=0.9;
% ratio=0.3;
% Dr0=0.3;
% x_bd_0=R*cosd(t(1:end-1));
% y_bd_0=R*sind(t(1:end-1));

% bd_lines_1=1:length(x_bd_0);
% bd_lines_2=[length(x_bd_0),1:length(x_bd_0)-1];
bd_pts_x=x_bd_0;
bd_pts_y=y_bd_0;

pts_x=x_bd_0;
pts_y=y_bd_0;
lines_1=bd_lines_1;
lines_2=bd_lines_2;
bd_lines_i=1:length(lines_1);
faces=[];


for i=1:N
[state,pts_tri,lines_tri]=hasInterTriangle(1,bd_lines_1,bd_lines_2);
if state
    n_del=rmInterTriangle(pts_tri,lines_tri,bd_lines_1,bd_lines_2);
    face=bd_lines_i(lines_tri);
    bd_pts_x(pts_tri(n_del))=nan;
    bd_pts_y(pts_tri(n_del))=nan;
    bd_lines_1(lines_tri)=[];
    bd_lines_2(lines_tri)=[];
    bd_lines_i(lines_tri)=[];

    faces(:,end+1)=face';
    if isempty(bd_lines_1)
        break;
    else
        continue
    end
else
    face=bd_lines_i(1);
    is=[bd_lines_1(1),bd_lines_2(1)];
end

x0=mean(pts_x(is));
y0=mean(pts_y(is));

Dx=-diff(bd_pts_y(is));
Dy=diff(bd_pts_x(is));
L=sqrt(Dx^2+Dy^2);

x_n=x0-Dx*sqrt(3)/2;
y_n=y0-Dy*sqrt(3)/2;

Dr=ratio*L;
Dr=max([Dr,Dr0]);

n0=pickUpExistedPt(x_n,y_n,Dr,is,pts_x,pts_y,bd_pts_x,bd_pts_y,bd_lines_1,bd_lines_2);

% if isempty(rs(rs<Dr))
if isnan(n0)
    pts_x(end+1)=x_n;
    pts_y(end+1)=y_n;
    bd_pts_x(end+1)=x_n;
    bd_pts_y(end+1)=y_n;

    n0=length(pts_x);
    lines_1(end+1:end+2)=[is(1),n0];
    lines_2(end+1:end+2)=[n0,is(2)];
    bd_lines_1(end+1:end+2)=[is(1),n0];
    bd_lines_2(end+1:end+2)=[n0,is(2)];
    bd_lines_i(end+1:end+2)=[-1,0]+length(lines_1);
    face(end+1:end+2)=[length(lines_1)-1,length(lines_1)];

else
% plot(pts_x(n0),pts_y(n0),'r*')
    con_n=[bd_lines_2(bd_lines_1==n0),bd_lines_1(bd_lines_2==n0)];

    if isempty(con_n(is(1)==con_n))
        lines_1(end+1)=is(1);
        lines_2(end+1)=n0;
        face(end+1)=length(lines_1);
        bd_lines_1(end+1)=is(1);
        bd_lines_2(end+1)=n0;
        bd_lines_i(end+1)=length(lines_1);

    else
        bd_pts_x(is(1))=nan;
        bd_pts_y(is(1))=nan;
        k=find(bd_lines_1==n0&bd_lines_2==is(1));
        if ~isempty(k)
            face(end+1)=bd_lines_i(k);
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
            bd_lines_i(k)=[];
        else 
            k=find(bd_lines_2==n0&bd_lines_1==is(1));
            face(end+1)=bd_lines_i(k);
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
            bd_lines_i(k)=[];
        end
    end

    if isempty(con_n(is(2)==con_n))
        lines_1(end+1)=n0;
        lines_2(end+1)=is(2);
        face(end+1)=length(lines_1);
        bd_lines_1(end+1)=n0;
        bd_lines_2(end+1)=is(2);
        bd_lines_i(end+1)=length(lines_1);

    else
        bd_pts_x(is(2))=nan;
        bd_pts_y(is(2))=nan;
        k=find(bd_lines_1==n0&bd_lines_2==is(2));
        if ~isempty(k)
            face(end+1)=bd_lines_i(k);
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
            bd_lines_i(k)=[];
        else
            k=find(bd_lines_2==n0&bd_lines_1==is(2));
            face(end+1)=bd_lines_i(k);
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
            bd_lines_i(k)=[];
        end

    end


end

bd_lines_1(1)=[];
bd_lines_2(1)=[];
bd_lines_i(1)=[];
faces(:,end+1)=face';

if isempty(bd_lines_1)
    break;
end

end

end

%{
+[保存M函数](,meshGeneration_AF)
%}
## end
#213, 3053:
%{
+[M函数](,meshGeneration_AF)
测试:...
%}

addpath('Matlab/mesh')
addpath('Matlab/space')
addpath('Matlab/draw')

t=linspace(0,360,20);
R=5;
% ratio=0.9;
ratio=0.3;
Dr0=0.3;
x_bd_0=R*cosd(t(1:end-1));
y_bd_0=R*sind(t(1:end-1));

bd_lines_1=1:length(x_bd_0);
bd_lines_2=[length(x_bd_0),1:length(x_bd_0)-1];
bd_pts_x=x_bd_0;
bd_pts_y=y_bd_0;

pts_x=x_bd_0;
pts_y=y_bd_0;
lines_1=bd_lines_1;
lines_2=bd_lines_2;
% faces=[];

clf 
hold on

for i=1:690
[state,pts_tri,lines_tri]=hasInterTriangle(1,bd_lines_1,bd_lines_2);
if state
    n_del=rmInterTriangle(pts_tri,lines_tri,bd_lines_1,bd_lines_2);
    bd_pts_x(pts_tri(n_del))=nan;
    bd_pts_y(pts_tri(n_del))=nan;
    bd_lines_1(lines_tri)=[];
    bd_lines_2(lines_tri)=[];
    if isempty(bd_lines_1)
        break;
    else
        continue
    end
else
    is=[bd_lines_1(1),bd_lines_2(1)];
end

x0=mean(pts_x(is));
y0=mean(pts_y(is));

Dx=-diff(bd_pts_y(is));
Dy=diff(bd_pts_x(is));
L=sqrt(Dx^2+Dy^2);

x_n=x0-Dx*sqrt(3)/2;
y_n=y0-Dy*sqrt(3)/2;

Dr=ratio*L;
Dr=max([Dr,Dr0]);

n0=pickUpExistedPt(x_n,y_n,Dr,is,pts_x,pts_y,bd_pts_x,bd_pts_y,bd_lines_1,bd_lines_2);

% if isempty(rs(rs<Dr))
if isnan(n0)
    pts_x(end+1)=x_n;
    pts_y(end+1)=y_n;
    bd_pts_x(end+1)=x_n;
    bd_pts_y(end+1)=y_n;

    n0=length(pts_x);
    lines_1(end+1:end+2)=[is(1),n0];
    lines_2(end+1:end+2)=[n0,is(2)];
    bd_lines_1(end+1:end+2)=[is(1),n0];
    bd_lines_2(end+1:end+2)=[n0,is(2)];
else
% plot(pts_x(n0),pts_y(n0),'r*')
    con_n=[bd_lines_2(bd_lines_1==n0),bd_lines_1(bd_lines_2==n0)];

    if isempty(con_n(is(1)==con_n))
        lines_1(end+1)=is(1);
        lines_2(end+1)=n0;
        bd_lines_1(end+1)=is(1);
        bd_lines_2(end+1)=n0;

    else
        bd_pts_x(is(1))=nan;
        bd_pts_y(is(1))=nan;
        k=find(bd_lines_1==n0&bd_lines_2==is(1));
        if ~isempty(k)
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
        else 
            k=find(bd_lines_2==n0&bd_lines_1==is(1));
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
        end
    end

    if isempty(con_n(is(2)==con_n))
        lines_1(end+1)=n0;
        lines_2(end+1)=is(2);
        bd_lines_1(end+1)=n0;
        bd_lines_2(end+1)=is(2);
    else
        bd_pts_x(is(2))=nan;
        bd_pts_y(is(2))=nan;
        k=find(bd_lines_1==n0&bd_lines_2==is(2));
        if ~isempty(k)
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
        else
            k=find(bd_lines_2==n0&bd_lines_1==is(2));
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
        end

    end


end

bd_lines_1(1)=[];
bd_lines_2(1)=[];

if isempty(bd_lines_1)
    break;
end

end



% clf 
% hold on
plot(pts_x,pts_y,'o')
for i=1:length(pts_x)
    text(pts_x(i),pts_y(i),num2str(i));
end

for i=1:length(lines_1)
    is_draw=[lines_1(i),lines_2(i)];
    plot(pts_x(is_draw),pts_y(is_draw),'b--')
end

for i=1:length(bd_lines_1)
    is_draw=[bd_lines_1(i),bd_lines_2(i)];
    plot(pts_x(is_draw),pts_y(is_draw),'r-')
end

plot(pts_x(is),pts_y(is),'g-.',x_n,y_n,'g+')
axis equal


%{
测试相同:...

+[M函数](,测试算法)
%}
## end
#215, 31:
Matlab/mesh/meshGeneration_AF.m
## end
#220, 3392:
%{
+[M函数](,测试2)
网格动画:...
+[新建阅读窗口](,网格动画)
+[M函数](,网格动画)
%}

addpath('Matlab/mesh')
addpath('Matlab/space')
addpath('Matlab/draw')

t1=linspace(0,360,20);
t2=linspace(0,360,6);
R=5;
% ratio=0.9;
ratio=0.3;
Dr0=0.3;


x_bd_1=R*cosd(t1(1:end-1));
y_bd_1=R*sind(t1(1:end-1));
bd_lines_11=1:length(x_bd_1);
bd_lines_12=[length(x_bd_1),1:length(x_bd_1)-1];

x_bd_2=R*cosd(t2(1:end-1))*0.3;
y_bd_2=R*sind(t2(1:end-1))*0.3;
bd_lines_22=[1:length(x_bd_2)]+length(x_bd_1);
bd_lines_21=[length(x_bd_2),1:length(x_bd_2)-1]+length(x_bd_1);

x_bd_0=[x_bd_1,x_bd_2];
y_bd_0=[y_bd_1,y_bd_2];
bd_lines_1=[bd_lines_11,bd_lines_21];
bd_lines_2=[bd_lines_12,bd_lines_22];


bd_pts_x=x_bd_0;
bd_pts_y=y_bd_0;

pts_x=x_bd_0;
pts_y=y_bd_0;
lines_1=bd_lines_1;
lines_2=bd_lines_2;
% faces=[];

clf 
hold on

for i=1:140
[state,pts_tri,lines_tri]=hasInterTriangle(1,bd_lines_1,bd_lines_2);
if state
    n_del=rmInterTriangle(pts_tri,lines_tri,bd_lines_1,bd_lines_2);
    bd_pts_x(pts_tri(n_del))=nan;
    bd_pts_y(pts_tri(n_del))=nan;
    bd_lines_1(lines_tri)=[];
    bd_lines_2(lines_tri)=[];
    if isempty(bd_lines_1)
        break;
    else
        continue
    end
else
    is=[bd_lines_1(1),bd_lines_2(1)];
end

x0=mean(pts_x(is));
y0=mean(pts_y(is));

Dx=-diff(bd_pts_y(is));
Dy=diff(bd_pts_x(is));
L=sqrt(Dx^2+Dy^2);

x_n=x0-Dx*sqrt(3)/2;
y_n=y0-Dy*sqrt(3)/2;

Dr=ratio*L;
Dr=max([Dr,Dr0]);

n0=pickUpExistedPt(x_n,y_n,Dr,is,pts_x,pts_y,bd_pts_x,bd_pts_y,bd_lines_1,bd_lines_2);

% if isempty(rs(rs<Dr))
if isnan(n0)
    pts_x(end+1)=x_n;
    pts_y(end+1)=y_n;
    bd_pts_x(end+1)=x_n;
    bd_pts_y(end+1)=y_n;

    n0=length(pts_x);
    lines_1(end+1:end+2)=[is(1),n0];
    lines_2(end+1:end+2)=[n0,is(2)];
    bd_lines_1(end+1:end+2)=[is(1),n0];
    bd_lines_2(end+1:end+2)=[n0,is(2)];
else
% plot(pts_x(n0),pts_y(n0),'r*')
    con_n=[bd_lines_2(bd_lines_1==n0),bd_lines_1(bd_lines_2==n0)];

    if isempty(con_n(is(1)==con_n))
        lines_1(end+1)=is(1);
        lines_2(end+1)=n0;
        bd_lines_1(end+1)=is(1);
        bd_lines_2(end+1)=n0;

    else
        bd_pts_x(is(1))=nan;
        bd_pts_y(is(1))=nan;
        k=find(bd_lines_1==n0&bd_lines_2==is(1));
        if ~isempty(k)
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
        else 
            k=find(bd_lines_2==n0&bd_lines_1==is(1));
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
        end
    end

    if isempty(con_n(is(2)==con_n))
        lines_1(end+1)=n0;
        lines_2(end+1)=is(2);
        bd_lines_1(end+1)=n0;
        bd_lines_2(end+1)=is(2);
    else
        bd_pts_x(is(2))=nan;
        bd_pts_y(is(2))=nan;
        k=find(bd_lines_1==n0&bd_lines_2==is(2));
        if ~isempty(k)
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
        else
            k=find(bd_lines_2==n0&bd_lines_1==is(2));
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
        end

    end


end

bd_lines_1(1)=[];
bd_lines_2(1)=[];

if isempty(bd_lines_1)
    break;
end

end



% clf 
% hold on
plot(pts_x,pts_y,'o')
for i=1:length(pts_x)
    text(pts_x(i),pts_y(i),num2str(i));
end

for i=1:length(lines_1)
    is_draw=[lines_1(i),lines_2(i)];
    plot(pts_x(is_draw),pts_y(is_draw),'b--')
end

for i=1:length(bd_lines_1)
    is_draw=[bd_lines_1(i),bd_lines_2(i)];
    plot(pts_x(is_draw),pts_y(is_draw),'r-')
end

plot(pts_x(is),pts_y(is),'g-.',x_n,y_n,'g+')
axis equal


%{
+[M函数](,测试2)
%}
## end
#222, 3456:
%{
+[M函数](,测试2)
%}

addpath('Matlab/mesh')
addpath('Matlab/space')
addpath('Matlab/draw')

t1=linspace(0,360,40);
t2=linspace(0,360,8);
R=5;
% ratio=0.9;
ratio=0.3;
Dr0=0.3;


x_bd_1=R*cosd(t1(1:end-1));
y_bd_1=R*sind(t1(1:end-1))*2;
bd_lines_11=1:length(x_bd_1);
bd_lines_12=[length(x_bd_1),1:length(x_bd_1)-1];

x_bd_2=R*cosd(t2(1:end-1))*0.3;
y_bd_2=R*sind(t2(1:end-1))*0.3;
bd_lines_22=[1:length(x_bd_2)]+length(x_bd_1);
bd_lines_21=[length(x_bd_2),1:length(x_bd_2)-1]+length(x_bd_1);

x_bd_0=[x_bd_1,x_bd_2];
y_bd_0=[y_bd_1,y_bd_2];
bd_lines_1=[bd_lines_11,bd_lines_21];
bd_lines_2=[bd_lines_12,bd_lines_22];


bd_pts_x=x_bd_0;
bd_pts_y=y_bd_0;

pts_x=x_bd_0;
pts_y=y_bd_0;
lines_1=bd_lines_1;
lines_2=bd_lines_2;
% faces=[];

clf 
hold on

for i=1:340
[state,pts_tri,lines_tri]=hasInterTriangle(1,bd_lines_1,bd_lines_2);
if state
    n_del=rmInterTriangle(pts_tri,lines_tri,bd_lines_1,bd_lines_2);
    bd_pts_x(pts_tri(n_del))=nan;
    bd_pts_y(pts_tri(n_del))=nan;
    bd_lines_1(lines_tri)=[];
    bd_lines_2(lines_tri)=[];
    if isempty(bd_lines_1)
        break;
    else
        continue
    end
else
    is=[bd_lines_1(1),bd_lines_2(1)];
end

x0=mean(pts_x(is));
y0=mean(pts_y(is));

Dx=-diff(bd_pts_y(is));
Dy=diff(bd_pts_x(is));
L=sqrt(Dx^2+Dy^2);

x_n=x0-Dx*sqrt(3)/2;
y_n=y0-Dy*sqrt(3)/2;

Dr=ratio*L;
Dr=max([Dr,Dr0]);

n0=pickUpExistedPt(x_n,y_n,Dr,is,pts_x,pts_y,bd_pts_x,bd_pts_y,bd_lines_1,bd_lines_2);

% if isempty(rs(rs<Dr))
if isnan(n0)
    pts_x(end+1)=x_n;
    pts_y(end+1)=y_n;
    bd_pts_x(end+1)=x_n;
    bd_pts_y(end+1)=y_n;

    n0=length(pts_x);
    lines_1(end+1:end+2)=[is(1),n0];
    lines_2(end+1:end+2)=[n0,is(2)];
    bd_lines_1(end+1:end+2)=[is(1),n0];
    bd_lines_2(end+1:end+2)=[n0,is(2)];
else
% plot(pts_x(n0),pts_y(n0),'r*')
    con_n=[bd_lines_2(bd_lines_1==n0),bd_lines_1(bd_lines_2==n0)];

    if isempty(con_n(is(1)==con_n))
        lines_1(end+1)=is(1);
        lines_2(end+1)=n0;
        bd_lines_1(end+1)=is(1);
        bd_lines_2(end+1)=n0;

    else
        bd_pts_x(is(1))=nan;
        bd_pts_y(is(1))=nan;
        k=find(bd_lines_1==n0&bd_lines_2==is(1));
        if ~isempty(k)
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
        else 
            k=find(bd_lines_2==n0&bd_lines_1==is(1));
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
        end
    end

    if isempty(con_n(is(2)==con_n))
        lines_1(end+1)=n0;
        lines_2(end+1)=is(2);
        bd_lines_1(end+1)=n0;
        bd_lines_2(end+1)=is(2);
    else
        bd_pts_x(is(2))=nan;
        bd_pts_y(is(2))=nan;
        k=find(bd_lines_1==n0&bd_lines_2==is(2));
        if ~isempty(k)
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
        else
            k=find(bd_lines_2==n0&bd_lines_1==is(2));
            bd_lines_1(k)=[];
            bd_lines_2(k)=[];
        end

    end


end

bd_lines_1(1)=[];
bd_lines_2(1)=[];

if isempty(bd_lines_1)
    break;
end


if 1==1
    clf 
    hold on
    plot(pts_x,pts_y,'o')
    for j=1:length(pts_x)
        text(pts_x(j),pts_y(j),num2str(j));
    end
    
    for j=1:length(lines_1)
        is_draw=[lines_1(j),lines_2(j)];
        plot(pts_x(is_draw),pts_y(is_draw),'b--')
    end
    
    for j=1:length(bd_lines_1)
        is_draw=[bd_lines_1(j),bd_lines_2(j)];
        plot(pts_x(is_draw),pts_y(is_draw),'r-')
    end
    
    plot(pts_x(is),pts_y(is),'g-.',x_n,y_n,'g+')
    axis equal
    pause(0.2)
end


end




%{
+[M函数](,网格动画)
%}
## end
#224, 453:
+[显示PPT场景]"1"(,示意图场景)

在屏幕"1"中, 添加标记点
有A和B
A是标记点的多边形
B是标记点"2,4"的折线

A1::$$A_1(0,0)$$
A2::$$A_2(2,0.5)$$
A3::$$A_3(2,1)$$
A4::$$A_4(0,1)$$
A1, A2, A3和A4分别在标记点"1", 标记点"2", 标记点"3"和标记点"4"

A1在(0,0)
A2在(2,0.5)
A3在(2,1)
A4在(0,1)

A经过A1, A2, A3和A4
A是多边形
B经过A2和A4
B是折线
A1和A2都距离自己为(0,-0.1)
A3和A4都距离自己为(0,0.1)

区域1::(1)
区域2::(2)
区域1在(0.6,0.55)
区域2在(1.7,0.75)

A的颜色是(255,255,255)
显示A的颜色
H代码:...
+[PPT场景转H代码](示意图场景,H代码)


axis([-1,3,-0.5,1.5])
+[显示PPT场景]"1"(,示意图场景)
## end
#230, 3:
多边形
## end
#231, 18:
1.0, 1.0, 0.5, 0.0
## end
#233, 18:
0.0, 2.0, 2.0, 0.0
## end
#235, 3:
多边形
## end
#237, 2:
曲线
## end
#238, 8:
1.0, 0.5
## end
#240, 8:
0.0, 2.0
## end
#242, 2:
折线
## end
#245, 12:
$$A_1(0,0)$$
## end
#247, 14:
$$A_2(2,0.5)$$
## end
#249, 12:
$$A_3(2,1)$$
## end
#251, 12:
$$A_4(0,1)$$
## end
#252, 9:
0.0, -0.1
## end
#254, 8:
0.0, 1.1
## end
#256, 8:
2.0, 1.1
## end
#258, 8:
2.0, 0.4
## end
#261, 1410:

<svg xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 1000 500.0" style="overflow: hidden;border: 2px solid #888888;"> 
<polygon points="250,125 750,125 750,250 250,375 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polyline points="250,125 750,250 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<text dominant-baseline="middle"  x="675.000000" y="187.500000" font-size="15">(2)</text>
<text dominant-baseline="middle"  x="400.000000" y="237.500000" font-size="15">(1)</text>

  <foreignObject x="-750.000000" y="80.000000" width="2000" height="100">
    <div xmlns="http://www.w3.org/1999/xhtml" style="font-family:Times; font-size:15px;padding:0 0;">$$A_4(0,1)$$</div>
  </foreignObject>

  <foreignObject x="-250.000000" y="80.000000" width="2000" height="100">
    <div xmlns="http://www.w3.org/1999/xhtml" style="font-family:Times; font-size:15px;padding:0 0;">$$A_3(2,1)$$</div>
  </foreignObject>

  <foreignObject x="-250.000000" y="255.000000" width="2000" height="100">
    <div xmlns="http://www.w3.org/1999/xhtml" style="font-family:Times; font-size:15px;padding:0 0;">$$A_2(2,0.5)$$</div>
  </foreignObject>

  <foreignObject x="-750.000000" y="380.000000" width="2000" height="100">
    <div xmlns="http://www.w3.org/1999/xhtml" style="font-family:Times; font-size:15px;padding:0 0;">$$A_1(0,0)$$</div>
  </foreignObject>

</svg>


## end
#263, 1410:

<svg xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 1000 500.0" style="overflow: hidden;border: 2px solid #888888;"> 
<polygon points="250,125 750,125 750,250 250,375 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polyline points="250,125 750,250 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<text dominant-baseline="middle"  x="675.000000" y="187.500000" font-size="15">(2)</text>
<text dominant-baseline="middle"  x="400.000000" y="237.500000" font-size="15">(1)</text>

  <foreignObject x="-750.000000" y="80.000000" width="2000" height="100">
    <div xmlns="http://www.w3.org/1999/xhtml" style="font-family:Times; font-size:15px;padding:0 0;">$$A_4(0,1)$$</div>
  </foreignObject>

  <foreignObject x="-250.000000" y="80.000000" width="2000" height="100">
    <div xmlns="http://www.w3.org/1999/xhtml" style="font-family:Times; font-size:15px;padding:0 0;">$$A_3(2,1)$$</div>
  </foreignObject>

  <foreignObject x="-250.000000" y="255.000000" width="2000" height="100">
    <div xmlns="http://www.w3.org/1999/xhtml" style="font-family:Times; font-size:15px;padding:0 0;">$$A_2(2,0.5)$$</div>
  </foreignObject>

  <foreignObject x="-750.000000" y="380.000000" width="2000" height="100">
    <div xmlns="http://www.w3.org/1999/xhtml" style="font-family:Times; font-size:15px;padding:0 0;">$$A_1(0,0)$$</div>
  </foreignObject>

</svg>


## end
#267, 11:
255,255,255
## end
#269, 140:
"""


"""

+新建主语(_世界,是)->是(_主语,)...

->+的(_世界,+主体)->[m_name](_主语,+主体)...
    ->+[左连](是,+主体)...
=>.(+新建主语,_定语)=>+的#1(_定语,+主体)->+的(_世界,+的#1)


## end
#271, 31:
\vec{u}=\mathbf{R_{r}}\ \vec{U}
## end
#273, 101:
\vec{u}^{T}\ \mathbf{G}\ \vec{v}=\vec{U}^{T}\ \mathbf{R_{r}}^{T}\ \mathbf{G}\ \mathbf{R_{r}}\ \vec{V}
## end
#274, 25:
\vec{u}=\mat{R_r}*\vec{U}
## end
#277, 79:
\vec{u}^{T}*\mat{G}*\vec{v}=\vec{U}^{T}*\mat{R_r}^{T}*\mat{G}*\mat{R_r}*\vec{V}
## end
#281, 30:
\mathbf{R_{r}}=\mathbf{R}^{-1}
## end
#283, 64:
\mathbf{G}=\begin{pmatrix}
0&0&0\\ 0&1&0\\ 0&0&1
\end{pmatrix}


## end
#284, 22:
\mat{R_r}=\mat{R}^{-1}
## end
#287, 31:
\mat{G}=\mat{0,0,0;0,1,0;0,0,1}
## end
#291, 57:
\mathbf{T}=\mathbf{R_{r}}^{T}\ \mathbf{G}\ \mathbf{R_{r}}
## end
#292, 39:
\mat{T}=\mat{R_r}^{T}*\mat{G}*\mat{R_r}
## end
#297, 105:
A=\sum_{i}{\int_{S\ _{i}}^{}{ds\ }{\left(-\left(u\ _{i,1}\ v\ _{i,1}+u\ _{i,2}\ v\ _{i,2}\right)\right)}}
## end
#299, 90:
A=\sum_{i}{\int_{S\ _{i}}^{}{ds\ }{\left(-\sum_{k,j}{U\ _{j}\ T\ _{j,k}\ V\ _{k}}\right)}}
## end
#301, 66:
A=-\sum_{k,j,i}{U\ _{j}\ \left(S_{i}\ T\ _{i,j,k}\right)\ V\ _{k}}
## end
#303, 64:
A_{2}=\sum_{i}{\int_{S\ _{i}}^{}{ds\ }{f \left( x,y \right)\ v}}
## end
#305, 111:
A_{2}=\sum_{i}{\int_{S\ _{i}}^{}{ds\ }{f \left( x,y \right)\ \left(v\ _{i,0}+v\ _{i,1}\ x+v\ _{i,2}\ y\right)}}
## end
#306, 66:
A=\sum_{}^{}{i}{\int_{S[i]}^{}{s}{-(u[i,1]*v[i,1]+u[i,2]*v[i,2])}}
## end
#309, 70:
A=\sum_{}^{}{i}{\int_{S[i]}^{}{s}{-\sum_{}^{}{j,k}{U[j]*T[j,k]*V[k]}}}
## end
#312, 46:
A=-\sum_{}^{}{i,j,k}{U[j]*(S_i*T[i,j,k])*V[k]}
## end
#315, 46:
A_2=\sum_{}^{}{i}{\int_{S[i]}^{}{s}{f(x,y)*v}}
## end
#318, 71:
A_2=\sum_{}^{}{i}{\int_{S[i]}^{}{s}{f(x,y)*(v[i,0]+v[i,1]*x+v[i,2]*y)}}
## end
#322, 38:
A_{2}=\sum_{k,i}{F\ _{i,k}\ v\ _{i,k}}
## end
#324, 63:
A_{2}=\sum_{i,k}{F\ _{i,k}\ \sum_{j}{R_{r}\ _{i,k,j}\ V\ _{j}}}
## end
#326, 53:
F\ _{i,1}=\int_{S_{i}}^{}{ds\ }{f \left( x,y \right)}
## end
#328, 56:
F\ _{i,2}=\int_{S_{i}}^{}{ds\ }{x\ f \left( x,y \right)}
## end
#329, 34:
A_2=\sum_{}^{}{i,k}{F[i,k]*v[i,k]}
## end
#332, 58:
A_2=\sum_{}^{}{k,i}{F[i,k]*\sum_{}^{}{j}{R_r[i,k,j]*V[j]}}
## end
#336, 56:
F\ _{i,3}=\int_{S_{i}}^{}{ds\ }{y\ f \left( x,y \right)}
## end
#337, 31:
F[i,1]=\int_{S_i}^{}{s}{f(x,y)}
## end
#340, 33:
F[i,2]=\int_{S_i}^{}{s}{x*f(x,y)}
## end
#343, 33:
F[i,3]=\int_{S_i}^{}{s}{y*f(x,y)}
## end
#347, 52:
C\ _{j,k}=-\sum_{i}{\left(S_{i}\ T\ _{i,j,k}\right)}
## end
#349, 110:
\sum_{j=1}^{n+m}{U\ _{j}\ C\ _{j,k}}=\sum_{j=1}^{n}{U\ _{j}\ C\ _{j,k}}+\sum_{j=n+1}^{n+m}{U\ _{j}\ C\ _{j,k}}
## end
#351, 64:
B_{1}=-\sum_{k}{\sum_{j=n+1}^{n+m}{U\ _{j}\ C\ _{j,k}}\ V\ _{k}}
## end
#352, 37:
C[j,k]=-\sum_{}^{}{i}{(S_i*T[i,j,k])}
## end
#355, 92:
\sum_{1}^{n+m}{j}{U[j]*C[j,k]}=\sum_{1}^{n}{j}{U[j]*C[j,k]}+\sum_{n+1}^{n+m}{j}{U[j]*C[j,k]}
## end
#358, 57:
B_1=-\sum_{}^{}{k}{\sum_{n+1}^{n+m}{j}{U[j]*C[j,k]}*V[k]}
## end
#374, 3:
(1)
## end
#376, 3:
(2)
## end
#377, 9:
0.6, 0.55
## end
#379, 9:
1.7, 0.75
## end
#382, 19:
S_{1}=1\times 2/2=1
## end
#383, 11:
S_1=1*2/2=1
## end
#387, 70:
\mathbf{R_{1}}=\begin{pmatrix}
1&0&0\\ 1&2&0.5\\ 1&0&1
\end{pmatrix}


## end
#389, 119:
\mathbf{T_{1}}=\begin{pmatrix}
1.0625&-0.1250&-0.9375\\ -0.1250&0.2500&-0.1250\\ -0.9375&-0.1250&1.0625
\end{pmatrix}


## end
#391, 70:
\mathbf{R_{2}}=\begin{pmatrix}
1&2&0.5\\ 1&2&1\\ 1&0&1
\end{pmatrix}


## end
#393, 107:
\mathbf{T_{2}}=\begin{pmatrix}
4.0000&-4.0000&0\\ -4.0000&4.2500&-0.2500\\ 0&-0.2500&0.2500
\end{pmatrix}


## end
#394, 37:
\mat{R_1}=\mat{1,0,0;
1,2,0.5;
1,0,1}
## end
#398, 725:
%{
+[M函数](,验证公式)

课件例子:...
系数矩阵:...
+[新建阅读窗口](,课件例子)

获取mesh:...
+[新建阅读窗口](,获取mesh)
+[M函数](,获取mesh)
%}

G=[0,0,0;0,1,0;0,0,1];

C=sparse(length(pts_x),length(pts_x));
% C=zeros(length(pts_x),length(pts_x));

for i=1:size(faces,2)

face=faces(:,i)';
ns=[lines_1(face),lines_2(face)];
ns=unique(ns);
R=[ones(3,1),pts_x(ns)',pts_y(ns)'];
R_r=R^(-1);
T=R_r'*G*R_r;
S=polyarea(pts_x(ns),pts_y(ns));

C(ns,ns)=C(ns,ns)+S*T;

end

C1=C;
C1([n_bd_1,n_bd_2],:)=[];

B11=-C1(:,n_bd_1);
B12=-C1(:,n_bd_2);
C1(:,[n_bd_1,n_bd_2])=[];

U1=0;
U2=10;
B1=sum(B11,2)*U1+sum(B12,2)*U2;

U=zeros(size(pts_x));
U(n_bd_1)=U1;
U(n_bd_2)=U2;
U(max(n_bd_2)+1:end)=C1^(-1)*B1;

clf
showMesh_3D(pts_x,pts_y,U,lines_1,lines_2,faces)

%{
+[M函数](,验证公式)
%}
## end
#400, 86:
\mat{T_1}=\mat{1.0625,-0.1250,-0.9375;
-0.1250,0.2500,-0.1250;
-0.9375,-0.1250,1.0625}
## end
#404, 160:
\mathbf{C}=\begin{pmatrix}
1.0625&-0.1250&0&-0.9375\\ -0.1250&2.2500&-2.0000&-0.1250\\ 0&-2.0000&2.1250&-0.1250\\ -0.9375&-0.1250&-0.1250&1.1875
\end{pmatrix}


## end
#405, 37:
\mat{R_2}=\mat{1,2,0.5;
1,2,1;
1,0,1}
## end
#408, 74:
\mat{T_2}=\mat{4.0000,-4.0000,0;
-4.0000,4.2500,-0.2500;
0,-0.2500,0.2500}
## end
#411, 128:
\mat{C}=\mat{1.0625,-0.1250,0,-0.9375;
-0.1250,2.2500,-2.0000,-0.1250;
0,-2.0000,2.1250,-0.1250;
-0.9375,-0.1250,-0.1250,1.1875}
## end
#415, 321:
%{
+[M函数](,验证公式)
%}

G=[0,0,0;0,1,0;0,0,1];

face_1=[1,2,4];
R=[1,0,0;1,2,0.5;1,0,1];
R_r=R^(-1);
T_1=R_r'*G*R_r;
S_1=1;

face_2=[2,3,4];
R=[1,2,0.5;1,2,1;1,0,1];
R_r=R^(-1);
T_2=R_r'*G*R_r;
S_2=1/2;

C=zeros(4);
C(face_1,face_1)=C(face_1,face_1)+S_1*T_1;
C(face_2,face_2)=C(face_2,face_2)+S_2*T_2;
C

%{
+[M函数](,验证公式)
%}
## end
#417, 799:
%{
地址::Matlab/mesh/showMesh_3D.m
+[保存M函数](,showMesh_3D)
测试:...
%}

function showMesh_3D(pts_x,pts_y,pts_z,lines_1,lines_2,faces)

hold on
plot3(pts_x,pts_y,pts_z,'o')
for i=1:length(pts_x)
    text(pts_x(i),pts_y(i),pts_z(i),num2str(i));
end

for i=1:length(lines_1)
    is_draw=[lines_1(i),lines_2(i)];
    plot3(pts_x(is_draw),pts_y(is_draw),pts_z(is_draw),'b-')
end

z_min=min(pts_z);
z_max=max(pts_z);
for i=1:size(faces,2)
    face=faces(:,i)';
    ns=[lines_1(face),lines_2(face)];
    xs=pts_x(ns);
    ys=pts_y(ns);
    zs=pts_z(ns);

%     c=(mean(zs)-z_min)/(z_max-z_min);
%     patch(xs,ys,zs,[1,1,1]*c)
    patch(xs,ys,zs,[0.8,0.8,0.8])

end

axis equal

end

%{
参考::https://www.mathworks.com/help/matlab/creating_plots/how-patch-data-relates-to-a-colormap.html
+[保存M函数](,showMesh_3D)
%}
## end
#420, 25:
Matlab/mesh/showMesh_3D.m
## end
#425, 1517:
%{
+[M函数](,测试算法)
运行指令"nautilus 文档/计算机问题"
运行指令"nautilus Matlab"
Nini, 打开合并多边形的PtsInPolygon(节点)
is
画图:...
单步边界:...
单步边界2:...
远程连接:...
完成扫描1:...
外部三角:...
完成扫描2:...

等比缩小:...

保存:...
测试区域:...
测试区域2:...
+[新建阅读窗口](,测试区域2)

bdFormPolygon(M函数):...
pickUpExistedPt(M函数):...
hasInterTriangle(M函数):...
rmInterTriangle(M函数):...
meshGeneration_AF(M函数):...
showMesh_2D(M函数):...
+[新建阅读窗口](,showMesh_2D)
+[新建阅读窗口](,meshGeneration_AF)
+[新建阅读窗口](,hasInterTriangle)
+[新建阅读窗口](,bdFormPolygon)
%}

addpath('Matlab/mesh')
addpath('Matlab/space')
addpath('Matlab/draw')

t1=linspace(0,360,20);
t2=linspace(0,360,6);
R=5;
N=700;
ratio=0.3;
Dr0=0.3;

x_bd_1=R*cosd(t1(1:end-1));
y_bd_1=R*sind(t1(1:end-1))*1.5;
bd_lines_11=1:length(x_bd_1);
bd_lines_12=[length(x_bd_1),1:length(x_bd_1)-1];

x_bd_2=R*cosd(t2(1:end-1))*0.3;
y_bd_2=R*sind(t2(1:end-1))*0.3;
bd_lines_22=[1:length(x_bd_2)]+length(x_bd_1);
bd_lines_21=[length(x_bd_2),1:length(x_bd_2)-1]+length(x_bd_1);

x_bd_0=[x_bd_1,x_bd_2];
y_bd_0=[y_bd_1,y_bd_2];
bd_lines_1=[bd_lines_11,bd_lines_21];
bd_lines_2=[bd_lines_12,bd_lines_22];

% x_bd_0=[x_bd_1];
% y_bd_0=[y_bd_1];
% bd_lines_1=[bd_lines_11];
% bd_lines_2=[bd_lines_12];

[pts_x,pts_y,lines_1,lines_2]=meshGeneration_AF(x_bd_0,y_bd_0,bd_lines_1,bd_lines_2,N,ratio,Dr0);


clf 
hold on
plot(pts_x,pts_y,'o')
for i=1:length(pts_x)
    text(pts_x(i),pts_y(i),num2str(i));
end

for i=1:length(lines_1)
    is_draw=[lines_1(i),lines_2(i)];
    plot(pts_x(is_draw),pts_y(is_draw),'b-')
end
axis equal



%{
测试相同:...

+[M函数](,测试算法)
%}
## end
#426, 1517:
%{
+[M函数](,测试算法)
运行指令"nautilus 文档/计算机问题"
运行指令"nautilus Matlab"
Nini, 打开合并多边形的PtsInPolygon(节点)
is
画图:...
单步边界:...
单步边界2:...
远程连接:...
完成扫描1:...
外部三角:...
完成扫描2:...

等比缩小:...

保存:...
测试区域:...
测试区域2:...
+[新建阅读窗口](,测试区域2)

bdFormPolygon(M函数):...
pickUpExistedPt(M函数):...
hasInterTriangle(M函数):...
rmInterTriangle(M函数):...
meshGeneration_AF(M函数):...
showMesh_2D(M函数):...
+[新建阅读窗口](,showMesh_2D)
+[新建阅读窗口](,meshGeneration_AF)
+[新建阅读窗口](,hasInterTriangle)
+[新建阅读窗口](,bdFormPolygon)
%}

addpath('Matlab/mesh')
addpath('Matlab/space')
addpath('Matlab/draw')

t1=linspace(0,360,20);
t2=linspace(0,360,6);
R=5;
N=700;
ratio=0.3;
Dr0=0.3;

x_bd_1=R*cosd(t1(1:end-1));
y_bd_1=R*sind(t1(1:end-1))*1.5;
bd_lines_11=1:length(x_bd_1);
bd_lines_12=[length(x_bd_1),1:length(x_bd_1)-1];

x_bd_2=R*cosd(t2(1:end-1))*0.3;
y_bd_2=R*sind(t2(1:end-1))*0.3;
bd_lines_22=[1:length(x_bd_2)]+length(x_bd_1);
bd_lines_21=[length(x_bd_2),1:length(x_bd_2)-1]+length(x_bd_1);

x_bd_0=[x_bd_1,x_bd_2];
y_bd_0=[y_bd_1,y_bd_2];
bd_lines_1=[bd_lines_11,bd_lines_21];
bd_lines_2=[bd_lines_12,bd_lines_22];

% x_bd_0=[x_bd_1];
% y_bd_0=[y_bd_1];
% bd_lines_1=[bd_lines_11];
% bd_lines_2=[bd_lines_12];

[pts_x,pts_y,lines_1,lines_2]=meshGeneration_AF(x_bd_0,y_bd_0,bd_lines_1,bd_lines_2,N,ratio,Dr0);


clf 
hold on
plot(pts_x,pts_y,'o')
for i=1:length(pts_x)
    text(pts_x(i),pts_y(i),num2str(i));
end

for i=1:length(lines_1)
    is_draw=[lines_1(i),lines_2(i)];
    plot(pts_x(is_draw),pts_y(is_draw),'b-')
end
axis equal



%{
测试相同:...

+[M函数](,测试算法)
%}
## end
#427, 25:
Matlab/mesh/showMesh_2D.m
## end
#431, 370:
%{
地址::Matlab/mesh/showMesh_2D.m
+[保存M函数](,showMesh_2D)
测试:...
%}

function showMesh_2D(pts_x,pts_y,lines_1,lines_2)

hold on
plot(pts_x,pts_y,'o')
for i=1:length(pts_x)
    text(pts_x(i),pts_y(i),num2str(i));
end

for i=1:length(lines_1)
    is_draw=[lines_1(i),lines_2(i)];
    plot(pts_x(is_draw),pts_y(is_draw),'b-')
end
axis equal

end

%{
+[保存M函数](,showMesh_2D)
%}
## end
#437, 881:
%{
+[M函数](,获取mesh)
%}

addpath('Matlab/mesh')
addpath('Matlab/space')
addpath('Matlab/draw')

t1=linspace(0,360,20);
t2=linspace(0,360,6);
R=5;
N=700;
ratio=0.3;
Dr0=0.3;

x_bd_1=R*cosd(t1(1:end-1));
y_bd_1=R*sind(t1(1:end-1))*1.5;
bd_lines_11=1:length(x_bd_1);
bd_lines_12=[length(x_bd_1),1:length(x_bd_1)-1];

x_bd_2=R*cosd(t2(1:end-1))*0.3;
y_bd_2=R*sind(t2(1:end-1))*0.3;
bd_lines_22=[1:length(x_bd_2)]+length(x_bd_1);
bd_lines_21=[length(x_bd_2),1:length(x_bd_2)-1]+length(x_bd_1);

x_bd_0=[x_bd_1,x_bd_2];
y_bd_0=[y_bd_1,y_bd_2];
bd_lines_1=[bd_lines_11,bd_lines_21];
bd_lines_2=[bd_lines_12,bd_lines_22];

% x_bd_0=[x_bd_1];
% y_bd_0=[y_bd_1];
% bd_lines_1=[bd_lines_11];
% bd_lines_2=[bd_lines_12];

[pts_x,pts_y,lines_1,lines_2,faces]=meshGeneration_AF(x_bd_0,y_bd_0,bd_lines_1,bd_lines_2,N,ratio,Dr0);

n_bd_1=1:length(x_bd_1);
n_bd_2=[1:length(x_bd_2)]+length(n_bd_1);


## end
#439, 418:
%{
+[M函数](,验证公式)

课件例子:...
+[新建阅读窗口](,课件例子)

获取mesh:...
+[M函数](,获取mesh)
%}

G=[0,0,0;0,1,0;0,0,1];

C=sparse(length(pts_x),length(pts_x));
% C=zeros(length(pts_x),length(pts_x));

for i=1:size(faces,2)

face=faces(:,i)';
ns=[lines_1(face),lines_2(face)];
ns=unique(ns);
R=[ones(3,1),pts_x(ns)',pts_y(ns)'];
R_r=R^(-1);
T=R_r'*G*R_r;
S=polyarea(pts_x(ns),pts_y(ns));

C(ns,ns)=C(ns,ns)+S*T;

end

C

%{
+[M函数](,验证公式)
%}
## end
#440, 28:
Matlab/mesh/showMesh_patch.m
## end
#441, 1517:
%{
+[M函数](,测试算法)
运行指令"nautilus 文档/计算机问题"
运行指令"nautilus Matlab"
Nini, 打开合并多边形的PtsInPolygon(节点)
is
画图:...
单步边界:...
单步边界2:...
远程连接:...
完成扫描1:...
外部三角:...
完成扫描2:...

等比缩小:...

保存:...
测试区域:...
测试区域2:...
+[新建阅读窗口](,测试区域2)

bdFormPolygon(M函数):...
pickUpExistedPt(M函数):...
hasInterTriangle(M函数):...
rmInterTriangle(M函数):...
meshGeneration_AF(M函数):...
showMesh_2D(M函数):...
+[新建阅读窗口](,showMesh_2D)
+[新建阅读窗口](,meshGeneration_AF)
+[新建阅读窗口](,hasInterTriangle)
+[新建阅读窗口](,bdFormPolygon)
%}

addpath('Matlab/mesh')
addpath('Matlab/space')
addpath('Matlab/draw')

t1=linspace(0,360,20);
t2=linspace(0,360,6);
R=5;
N=700;
ratio=0.3;
Dr0=0.3;

x_bd_1=R*cosd(t1(1:end-1));
y_bd_1=R*sind(t1(1:end-1))*1.5;
bd_lines_11=1:length(x_bd_1);
bd_lines_12=[length(x_bd_1),1:length(x_bd_1)-1];

x_bd_2=R*cosd(t2(1:end-1))*0.3;
y_bd_2=R*sind(t2(1:end-1))*0.3;
bd_lines_22=[1:length(x_bd_2)]+length(x_bd_1);
bd_lines_21=[length(x_bd_2),1:length(x_bd_2)-1]+length(x_bd_1);

x_bd_0=[x_bd_1,x_bd_2];
y_bd_0=[y_bd_1,y_bd_2];
bd_lines_1=[bd_lines_11,bd_lines_21];
bd_lines_2=[bd_lines_12,bd_lines_22];

% x_bd_0=[x_bd_1];
% y_bd_0=[y_bd_1];
% bd_lines_1=[bd_lines_11];
% bd_lines_2=[bd_lines_12];

[pts_x,pts_y,lines_1,lines_2]=meshGeneration_AF(x_bd_0,y_bd_0,bd_lines_1,bd_lines_2,N,ratio,Dr0);


clf 
hold on
plot(pts_x,pts_y,'o')
for i=1:length(pts_x)
    text(pts_x(i),pts_y(i),num2str(i));
end

for i=1:length(lines_1)
    is_draw=[lines_1(i),lines_2(i)];
    plot(pts_x(is_draw),pts_y(is_draw),'b-')
end
axis equal



%{
测试相同:...

+[M函数](,测试算法)
%}
## end
#445, 572:
%{
地址::Matlab/mesh/showMesh_patch.m
+[保存M函数](,showMesh_patch)
测试:...
%}

function showMesh_patch(pts_x,pts_y,lines_1,lines_2,faces)

hold on
plot(pts_x,pts_y,'o')
for i=1:length(pts_x)
    text(pts_x(i),pts_y(i),num2str(i));
end

for i=1:length(lines_1)
    is_draw=[lines_1(i),lines_2(i)];
    plot(pts_x(is_draw),pts_y(is_draw),'b-')
end

for i=1:size(faces,2)
    face=faces(:,i)';
    ns=[lines_1(face),lines_2(face)];
    xs=pts_x(ns);
    ys=pts_y(ns);
    zs=zeros(size(xs))-i;
    patch(xs,ys,zs,[0.8,0.8,0.8])
end

axis equal

end

%{
+[保存M函数](,showMesh_patch)
%}
## end
#451, 94:
https://www.mathworks.com/help/matlab/creating_plots/how-patch-data-relates-to-a-colormap.html
## end
### 结束