### 节点
地址, 的, 齿轮模拟, 目录, 的, 的, 节点数目统计, 20220716, 的, 的, 操作, 20220718, 的, 的, 整理齿轮场景, 的, 思考结构, 的, 描述模板, 的, 库, 的, 传动动画, 的, M模板, 的, 保存, 的, 保存, 的, 整体动画, 的, 动画框架, 的, M模板, 20220719, 的, 20220720, 的, 的, 参考, 打开网页, 20220723, 的, 的, 测试场景, 的, 画图测试, M函数, 的, obj_2D_shape, 的, 地址, obj_2D_shape, 的, 记忆, obj_2D_shape, 的, 测试, 的, gear_2D, M函数, 的, 地址, gear_2D, 的, gear_2D, 的, rect_2D, M函数, 的, 地址, rect_2D, 的, rect_2D, 的, frame_from_pt_angle, 的, 地址, 的, 测试, frame_from_pt_angle, 的, frame_from_pt_angle, 的, 保存, 的, frame_from_pts, 的, 地址, frame_from_pts, 的, frame_from_pts, 的, 测试, 的, frame_to_pts, 的, 地址, frame_to_pts, 的, frame_to_pts, 的, 测试, 的, 两点固定, 的, 公式推导, html, 的, [1]., 手, 表达式, 的, 公式, 的, [2]., 表达式, 的, 公式, 的, [3]., 表达式, 的, 公式, 的, [4]., 表达式, 的, 公式, 场景, 公式结构, 的, [5]., 表达式, 的, 公式, 的, [6]., 表达式, 的, 公式, 的, [7]., 表达式, 的, 公式, 的, [8]., 表达式, 的, 公式, 的, [9]., 表达式, 的, 公式, 的, [10]., 表达式, 的, 公式, 的, [11]., 表达式, 的, 公式, 的, [12]., 表达式, 的, 公式, 的, [13]., 表达式, 的, 公式, 的, [14]., 表达式, 的, 公式, 的, [15]., 表达式, 的, 公式, 的, [16]., 表达式, 的, 公式, 的, [17]., 表达式, 的, 公式, 的, [18]., 表达式, 的, 公式, 的, [19]., 表达式, 的, 公式, 的, 验证公式, 的, [20]., 表达式, 的, 公式, 的, [21]., 的, [22]., 表达式, 的, 公式, 表达式, 的, 公式, 的, [23]., 表达式, 的, 公式, 场景, 公式结构, 场景, 公式结构, 的, [24]., 表达式, 的, 公式, 的, [25]., 表达式, 的, 公式, 的, [26]., 表达式, 的, 公式, 的, [27]., 表达式, 的, 公式, 的, [28]., 表达式, 的, 公式, 的, 铰链双杆, 的, 导轨杆, 的, joint_two_arms, 的, 地址, joint_two_arms, 的, joint_two_arms, 的, 单个位置, 的, 扫描位置, 的, 例子库, 的, 连杆平动, 的, 驱动连杆, 的, gear_rotation, 的, 地址, gear_rotation, 的, gear_rotation, 的, 驱动夹子, 20220725, 的, 的, 保存, 的, 初始化, 的, 驱动轮, 的, 保存, 的, M模板, 的, 保存, 的, 保存, 的, M模板, 的, 保存, 的, 库, 的, 驱动杆1, 的, 保存, 的, 固定, 的, 驱动杆2, 的, 的, 的, 保存, 20220726, 的, 20220729, 的, 的, 双杆定位, 的, 两点定位, 的, 描述模板, 的, M模板, 的, pt_in_frame, 的, 地址, pt_in_frame, 的, pt_in_frame, 的, 测试, 的, M代码, 的, 位置, 的, 方向, 的, 相对位置, 的, 位置, 的, 角度, 的, M代码, 的, 设置命名空间, 的, M模板2, 20220730, 的, 打开网页, 的, JS版本, 
### 关联
#, 2#0, #, #, 3#2, 3#6, #, #, 6#7, 2#10, #, #, 6#11, 10#14, #, 14#16, #, 14#18, #, 14#20, #, 20#22, #, 22#24, #, 22#26, #, 14#28, #, 20#30, #, 20#32, #, 32#34, #, #, 6#35, #, 6#37, 2#40, #, #40, #, 6#42, 2#45, #, 45#47, #, 47#, 47#50, #, 50#52, #, #50, 55#53, 3#, #, 50#58, #, 50#60, #, 60#, 60#63, #, #60, 55#64, #, 50#68, #, 68#, 68#71, #, #68, 55#72, #, 47#76, #, 76#78, #, 76#80, #, #76, 55#81, #, 47#85, #, 47#87, #, 87#89, #, #87, 55#90, #, 87#94, #, 47#96, #, 96#98, #, #96, 55#99, #, 96#103, #, 47#105, #, 45#107, #, 107#, 107#110, #, #107, #, 110#112, 110#, 107#116, #, #, 116#117, 116#, 107#121, #, #, 121#122, 121#, 107#126, #, #, 126#127, 126#, #, #, 107#133, #, #, 133#134, 133#, 107#138, #, #, 138#139, 138#, 107#143, #, #, 143#144, 143#, 107#148, #, #, 148#149, 148#, 107#153, #, #, 153#154, 153#, 107#158, #, #, 158#159, 158#, 107#163, #, #, 163#164, 163#, 107#168, #, #, 168#169, 168#, 107#173, #, #, 173#174, 173#, 107#178, #, #, 178#179, 178#, 107#183, #, #, 183#184, 183#, 107#188, #, #, 188#189, 188#, 107#193, #, #, 193#194, 193#, 107#198, #, #, 198#199, 198#, 107#203, #, #, 203#204, 203#, 107#208, #, 107#210, #, #, 210#211, 210#, 107#215, #, 107#217, #, #, 215#218, 215#, #, 217#221, 217#, 107#225, #, #, 225#226, 225#, #, #, #, #, 107#234, #, #, 234#235, 234#, 107#239, #, #, 239#240, 239#, 107#244, #, #, 244#245, 244#, 107#249, #, #, 249#250, 249#, 107#254, #, #, 254#255, 254#, 208#259, #, 208#261, #, 208#263, #, 263#265, #, #263, 55#266, #, 259#270, #, 259#272, #, 47#274, #, 274#276, #, 274#278, #, 47#280, #, 280#282, #, #280, 55#283, #, 274#287, #, #, 6#288, 24#291, #, 32#293, #, 32#295, #, 32#297, #, 293#299, #, 293#301, #, 34#303, #, 295#305, #, 16#307, #, 16#309, #, 309#311, #, 311#313, #, 311#315, #, 309#317, #, 309#319, 317#315, 317#321, #, #, 6#322, #, 6#324, 20#327, #, 20#329, #, 327#331, #, 327#333, #, 47#335, #, 335#337, #, #335, 55#338, #, 335#342, #, 327#344, #, 327#346, #, 327#348, #, 327#350, #, 350#352, #, 350#354, #, 350#356, #, 20#358, #, 293#360, #, #, 6#361, #40, 263#365, #, 
### 内容
#0, 16:
文档\S应用\齿轮模拟.ftxt
## end
#2, 272:
+[返回目录](,齿轮模拟)
地址::文档\S应用\齿轮模拟.ftxt


操作:...
+[设置动词](,操作)


Nini, 导入齿轮模拟的库
Nini, 导入词典的库. 导入词典
Nini, 导入PPT的库. Nini, 导入图形库的库
Nini, 打开花园(文件)



参考::file:///C:/Users/cheng/Desktop/paper/Books/%E6%9C%BA%E6%A2%B0%E5%8E%9F%E7%90%86.pdf
+[打开网页](,参考)

测试场景:...
+[新建阅读窗口](,测试场景)




## end
#3, 48:
齿轮模拟:...
创建于 20220717

节点数目统计::
+[设置结构](,节点数目统计)
## end
#7, 1:
9
## end
#10, 17:


整理齿轮场景:...





## end
#11, 2:
36
## end
#14, 1576:
"""
思考结构:...
描述模板::%主语驱动%宾语. 
库:...
+[新建阅读窗口](,思考结构)
+[新建阅读窗口](,库)
保存:...
Nini, 打开词典的条目(节点)

"""

+整理齿轮场景(,_齿轮)->+[del](,+整理齿轮场景)...
->的(整理齿轮场景,思考结构)->的(整理齿轮场景,描述模板)...
->的(整理齿轮场景,库)->的(库,传动动画)->的(库,设置命名空间)...
->的(整理齿轮场景,保存)...

->记忆->[]{
    []:->内景(记忆,),->+内景(记忆,)
}->内景(记忆,)...
->+[code]([想],思考结构)->[想](,_齿轮)...

->+命名空间->+[python]"i=0"(Python,)->Python->[]{
    []=>的(内景,_操作):
        ->[is](_操作,传动)->传动(_主语,_宾语)->_主语->_宾语(,)...
        =>+[做](+命名空间,_主语)->+[code](+[做],设置命名空间)...
            ->+[做](+命名空间,_宾语)->+[code](+[做],设置命名空间),

        ->_条件(_操作,_对象)->_对象->在(_对象,空间点)...
            =>+[做](+命名空间,_对象)->+[code](+[做],设置命名空间)
}...

->+[临时文本]#2->+[临时文本]->[]{
    []=>的(内景,_操作)->_操作:
        ->[is](_操作,传动)->传动(_主语,_宾语)->_主语->_宾语(,)...
        =>+[做](_主语,_宾语)->+[code](+[做],传动动画)...
            ->+输出代码(+[做],+[增加内容2])->+[增加内容2](,+[临时文本])...
            ->+[del](,+输出代码)...
        ->+[标题]#0(_主语,)->+[标题]#1(_宾语,)...
            ->+[模板文本](描述模板,+[增加内容2]#2)->+[增加内容2]#2(,+[临时文本]#2)...
            ->+[.]"主语"(+[模板文本],+[标题]#0)->+[.]"宾语"(+[模板文本],+[标题]#1),

        ->的(库,_条目)->_条目->[eq](_条目,_操作)...
        =>+[做](+操作,+[增加内容2]#3)->+[code](+[做],_条目)...
            ->+[增加内容2]#3(,+[临时文本])->+[del](,+操作)...
        ->[]{
            []=>_条件(_操作,_对象)->_对象(,)...
            =>+条件(+操作,_对象)->[m_name](_条件,+条件)->+[del](,+条件)
        }
}...

->的(库,动画框架)...
->+[做](+命名空间,_齿轮)->+[code](+[做],动画框架)...
    ->+动画代码(+[做],+[临时文本])->+[del](,+动画代码)...
    ->+输出代码(+[做],+[临时文本])->+[del](,+输出代码)...

->+[显示](,+[临时文本]#2)...
->+[修改内容](+[临时文本],保存)->+[M函数](,保存)...
->+[删除结构](,+命名空间)->+[del](,+命名空间)



## end
#16, 1008:
"""
保存:...
库:...
+[新建阅读窗口](,库)

"""

+思考结构(,_齿轮)...
->的(思考结构,库)->的(库,驱动杆1)->的(库,驱动杆2)...

->记忆->内景(记忆,)->[]{
    []:->确定(_齿轮,),->+确定(_齿轮,)
}...

->[]{
    []&:=>接触(_齿轮,_齿轮1)->_齿轮1{[]=>确定(_齿轮1,)}...
        =>+传动(_齿轮,_齿轮1)->+的(内景,+传动)->+确定(_齿轮1,),
    =>接触(_齿轮2,_齿轮)->_齿轮2{[]=>确定(_齿轮2,)}...
        =>+传动(_齿轮,_齿轮2)->+的(内景,+传动)->+确定(_齿轮2,),

    =>固定#1(,_齿轮)->到(固定#1,_杆1)->[]{[]=>确定(_杆1,)}...
    =>[]{
        []:->+[code]([想]#1,驱动杆1)->[想]#1(固定#1,_杆1)->+确定(_杆1,),
        ->[]},

    =>到(固定#2,_齿轮)->固定#2(,_杆2)->[]{[]=>确定(_杆2,)}...
    =>[]{
        []:->+[code]([想]#2,驱动杆2)->[想]#2(固定#2,_杆2)->+确定(_杆2,),
        ->[]}
}...

->[]&:=>接触(_齿轮,_齿轮1)->_齿轮1{[]=>思考结构#1(,_齿轮1)}...
        =>+[code]([想]#1,思考结构)->[想]#1(,_齿轮1),
    =>接触(_齿轮2,_齿轮)->_齿轮2{[]=>思考结构#2(,_齿轮2)}...
        =>+[code]([想]#2,思考结构)->[想]#2(,_齿轮2),
    =>到(固定#1,_齿轮)->固定#1(,_杆1)->[]{[]=>思考结构#3(,_杆1)}...
        =>+[code]([想]#3,思考结构)->[想]#3(,_杆1),
    =>固定#2(,_齿轮)->到(固定#2,_杆2)->[]{[]=>思考结构#3(,_杆2)}...
        =>+[code]([想]#4,思考结构)->[想]#4(,_杆2)




## end
#18, 10:
%主语驱动%宾语. 
## end
#20, 90:

传动动画:...
动画框架:...
动画框架的"传动动画"替换为"动画框架"

两点定位:...
双杆定位:...

设置命名空间:...

+[del](,描述双杆定位)



## end
#22, 373:
"""
M模板:...
+[新建阅读窗口](,M模板)

"""

+传动动画(_主语,_宾语)->+[del](,+传动动画)...
->的(传动动画,M模板)...

->输出代码(+传动动画,_代码)...
->变量#0(,_主语)->的(_主语,齿数#0)...
->变量#1(,_宾语)->的(_宾语,齿数#1)...
->在(_宾语,空间点#1)->的(_宾语,半径#1)...

->+[模板文本](M模板,_代码)...
->+[.]"N0"(+[模板文本],齿数#0)->+[.]"主语"(+[模板文本],变量#0)...
->+[.]"N1"(+[模板文本],齿数#1)->+[.]"宾语"(+[模板文本],变量#1)...
->+[.]"R1"(+[模板文本],半径#1)->+[.]"p1"(+[模板文本],空间点#1)

## end
#24, 128:
%{
保存:...
%}
angle_G%宾语=gear_rotation(angle_G%主语,%N0,%N1,angle_0%主语,angle_0%宾语);
obj_2D_shape(x_%宾语,y_%宾语,angle_G%宾语,pt_G%宾语);


## end
#28, 3379:
%{
+[M函数](,保存)
保存:...
%}

addpath('Matlab\gears')
dt=1;

angle_08=1;
angle_G8=1;
pt_G8=[2.0, 0.0];
[x_8,y_8]=gear_2D(1.0,1.0*1.1,20);

angle_07=1;
angle_G7=1;
pt_G7=[0.0, 0.0];
[x_7,y_7]=gear_2D(1.0,1.0*1.1,20);

angle_06=-135;
pt_G6=[0.0, 0.5];
x_6=[0.0, 0.0, -3.0, -3.0];
y_6=[-0.05, 0.05, 0.05, -0.05];

angle_05=-45;
pt_G5=[2.0, 0.5];
x_5=[0.0, 0.0, -3.0, -3.0];
y_5=[-0.05, 0.05, 0.05, -0.05];

angle_04=-135;
pt_G4=[-0.08939428018113293;
2.589745207444794];
x_4=[0.0, 0.0, -3.0, -3.0];
y_4=[-0.05, 0.05, 0.05, -0.05];

angle_03=-45;
pt_G3=[2.0874677899696854;
2.602780309661266];
x_3=[0.0, 0.0, -3.0, -3.0];
y_3=[-0.05, 0.05, 0.05, -0.05];

angle_02=128.92754359279232;
pt_G2=[1.4457920872899592;
5.466578886042874];
x_2=[0.0, 0.0, -4.0, -4.0];
y_2=[-0.05, 0.05, 0.05, -0.05];

angle_01=-118.14284940473533;
pt_G1=[2.0874677899696854;
2.602780309661266];
x_1=[0.0, 0.0, -4.0, -4.0];
y_1=[-0.05, 0.05, 0.05, -0.05];


for i=1:100
clf
hold on
axis equal

angle_G8=angle_G8+dt*-3;
obj_2D_shape(x_8,y_8,angle_G8,pt_G8,[1,0,0]);
%{
保存:...
%}
angle_G7=gear_rotation(angle_G8,20,20,angle_08,angle_07);
obj_2D_shape(x_7,y_7,angle_G7,pt_G7);


L1=norm([-0.014808145762814796, 0.009465352218564382]-[-1.415823939713337, -0.00896906612288928]);
L2=norm([0.004988506871044299, -0.029262004852423477]-[-1.405244496250206, -0.001610377340241942]);
pt_1=frame_to_pts([0.005248405388562635, 0.5171511223425729],pt_G8,angle_G8);
pt_2=frame_to_pts([-0.015189324925111004, 0.5175078642521834],pt_G7,angle_G7);
[~,pt_3]=joint_two_arms(pt_1,pt_2,L1,L2);
[pt_G5,angle_G5]=frame_from_pts(pt_1,pt_3,[-0.014808145762814796, 0.009465352218564382],[-1.415823939713337, -0.00896906612288928]);
[pt_G6,angle_G6]=frame_from_pts(pt_2,pt_3,[0.004988506871044299, -0.029262004852423477],[-1.405244496250206, -0.001610377340241942]);
obj_2D_shape(x_5,y_5,angle_G5,pt_G5);
obj_2D_shape(x_6,y_6,angle_G6,pt_G6);
plot([pt_1(1),pt_2(1),pt_3(1)],[pt_1(2),pt_2(2),pt_3(2)],'o')


L1=norm([0.0, 0.0]-[-1.5191118671520043, -0.01120234403743492]);
L2=norm([-0.0, 0.0]-[-1.537288796644722, 0.010944855188698144]);
pt_1=frame_to_pts([-2.9629528461030903, -0.010827586510969267],pt_G6,angle_G6);
pt_2=frame_to_pts([-2.955097871224767, 0.0002481430478380453],pt_G5,angle_G5);
[~,pt_3]=joint_two_arms(pt_1,pt_2,L1,L2);
[pt_G3,angle_G3]=frame_from_pts(pt_1,pt_3,[0.0, 0.0],[-1.5191118671520043, -0.01120234403743492]);
[pt_G4,angle_G4]=frame_from_pts(pt_2,pt_3,[-0.0, 0.0],[-1.537288796644722, 0.010944855188698144]);
obj_2D_shape(x_3,y_3,angle_G3,pt_G3);
obj_2D_shape(x_4,y_4,angle_G4,pt_G4);
plot([pt_1(1),pt_2(1),pt_3(1)],[pt_1(2),pt_2(2),pt_3(2)],'o')


L1=norm([-0.9712699589776608, 0.02979374587912148]-[-2.0810185744972527, -4.440892098500626e-16]);
L2=norm([-0.0, 0.0]-[-1.411799409489255, -1.1102230246251565e-16]);
pt_1=frame_to_pts([-2.9873959058167623, 0.013980404424612125],pt_G4,angle_G4);
pt_2=frame_to_pts([0.0, 0.0],pt_G3,angle_G3);
[pt_3,~]=joint_two_arms(pt_1,pt_2,L1,L2);
[pt_G2,angle_G2]=frame_from_pts(pt_1,pt_3,[-0.9712699589776608, 0.02979374587912148],[-2.0810185744972527, -4.440892098500626e-16]);
[pt_G1,angle_G1]=frame_from_pts(pt_2,pt_3,[-0.0, 0.0],[-1.411799409489255, -1.1102230246251565e-16]);
obj_2D_shape(x_2,y_2,angle_G2,pt_G2);
obj_2D_shape(x_1,y_1,angle_G1,pt_G1);
plot([pt_1(1),pt_2(1),pt_3(1)],[pt_1(2),pt_2(2),pt_3(2)],'o')



axis equal
hold off
pause(0.1)
end


%{
+[M函数](,保存)
%}
## end
#32, 393:
"""
M模板:...
+[新建阅读窗口](,M模板)
初始化:...
驱动轮:...

保存:...
+[新建阅读窗口](,保存)

"""

+动画框架(命名空间,_宾语)->+[del](,+动画框架)...
->的(动画框架,M模板)->的(动画框架,初始化)->的(动画框架,驱动轮)...

->输出代码(+动画框架,_代码)->动画代码(+动画框架,_代码2)...

->+[做](命名空间,+[临时文本])->+[code](+[做],初始化)...
->+[做](_宾语,+[临时文本]#0)->+[code](+[做],驱动轮)...

->+[模板文本](M模板,_代码)...
->+[.]"驱动轮"(+[模板文本],+[临时文本]#0)->+[.]"初始化"(+[模板文本],+[临时文本])...
->+[.]"运动过程"(+[模板文本],_代码2)



## end
#34, 164:
%{
+[M函数](,保存)
保存:...
%}

addpath('Matlab\gears')
dt=1;
%初始化

for i=1:100
clf
hold on
axis equal

%驱动轮
%运动过程

axis equal
hold off
pause(0.1)
end


%{
+[M函数](,保存)
%}
## end
#35, 2:
37
## end
#37, 2:
39
## end
#40, 83:
file:///C:/Users/cheng/Desktop/paper/Books/%E6%9C%BA%E6%A2%B0%E5%8E%9F%E7%90%86.pdf
## end
#42, 3:
404
## end
#45, 342:
Nini, 导入公式结构的库. Nini, 导入公式分析器的库
Nini, 导入网页画板的库
Nini, 打开花园(文件)

先做基本函数了. 固定物体1和物体2的时候会记录物体1中的某个点和物体2中的某个点. 方向的话只要记录物体2相对物体1的角度就行了
然后做几组函数:
1.用固定点和方向确定物体2的空间坐标和姿态; 
2.两个固定点确定物体2的空间坐标和姿态; 
3.确定物体2中的固定点的空间坐标; 
4.用两个物体上的固定点全局坐标和物体间的固定点相对坐标, 确定这两个物体的位置和姿态. 
5.用一个固定点全局坐标和另一个限制了方向的固定点, 确定一个物体的坐标. 


画图测试(M函数):...
公式推导(html):...
+[新建阅读窗口](,画图测试)




## end
#47, 1412:
%{
+[M函数](,画图测试)

obj_2D_shape:...
frame_from_pt_angle:...
frame_from_pts:...
frame_to_pts:...
gear_rotation:...
pt_in_frame:...

两点固定:...
例子库:...
+[新建阅读窗口](,例子库)
%}

addpath('Matlab\gears')
%pt_G1=[-2.5/2,1];
%pt_G2=[2.5/2,1];
pt_G1=[4,2.5/2];
pt_G2=[4,-2.5/2];
pt1_g=[1,0];
N=20;
R1=1.1;
R2=1.2;

L=4.5;
d=0.3;
pt_arch1=[d,0];
pt_arch2=[L/2+d,0];
pt_arch3=[L+d,0];

[x_g,y_g]=gear_2D(R1,R2,N);
[x_l,y_l]=rect_2D(0.3,L+2*d);

AngleG=linspace(0,360,100);

i=1;
for i=1:length(AngleG)
angle_G1=AngleG(i);
angle_G2=gear_rotation(angle_G1,N,N,0,0);

pt_1=frame_to_pts(pt1_g,pt_G1,angle_G1);
pt_2=frame_to_pts(pt1_g,pt_G2,angle_G2);

[~,pt_3]=joint_two_arms(pt_1,pt_2,L/2,L/2);
[pt_A,angle_A]=frame_from_pts(pt_1,pt_3,pt_arch1,pt_arch2);
[pt_B,angle_B]=frame_from_pts(pt_2,pt_3,pt_arch1,pt_arch2);

pt_4=frame_to_pts(pt_arch3,pt_A,angle_A);
pt_5=frame_to_pts(pt_arch3,pt_B,angle_B);

[~,pt_6]=joint_two_arms(pt_5,pt_4,L/2,L/2);
[pt_C,angle_C]=frame_from_pts(pt_4,pt_6,pt_arch1,pt_arch2);
[pt_D,angle_D]=frame_from_pts(pt_5,pt_6,pt_arch1,pt_arch2);


clf
hold on
obj_2D_shape(x_g,y_g,angle_G1,pt_G1);
obj_2D_shape(x_g,y_g,angle_G2,pt_G2);
obj_2D_shape(x_l,y_l,angle_A,pt_A);
obj_2D_shape(x_l,y_l,angle_B,pt_B);
obj_2D_shape(x_l,y_l,angle_C,pt_C);
obj_2D_shape(x_l,y_l,angle_D,pt_D);
plot([pt_1(1),pt_2(1),pt_3(1)],[pt_1(2),pt_2(2),pt_3(2)],'o')
axis equal
axis([-7,7,-7,3]);
pause(0.1)
end


%{
clear
+[M函数](,画图测试)
%}
## end
#50, 304:
%{
地址::Matlab\gears\obj_2D_shape.m
+[保存M函数](,obj_2D_shape)

测试:...
gear_2D(M函数):...
rect_2D(M函数):...
%}

function obj_2D_shape(x0,y0,angle,pt,color)

if nargin<5
color=[0,0,0];
end

x=cosd(angle)*x0-sind(angle)*y0+pt(1);
y=cosd(angle)*y0+sind(angle)*x0+pt(2);
patch(x,y,[1,1,1],'EdgeColor',color)

end



## end
#52, 27:
Matlab\gears\obj_2D_shape.m
## end
#58, 261:
%{
+[M函数](,测试)
%}

addpath('Matlab\gears')

N=20;
R1=1;
R2=1.15;
[x,y]=gear_2D(R1,R2,N);

angle=linspace(0,360,100);

for i=1:length(angle)
clf
obj_2D_shape(x,y,angle(i),[0,0]);
obj_2D_shape(x,y,-angle(i)-3,[2.2,0]);
axis equal
pause(0.1)
end

%{
+[M函数](,测试)
%}
## end
#60, 427:
%{
地址::Matlab\gears\gear_2D.m
+[保存M函数](,gear_2D)
%}

function [x,y]=gear_2D(R1,R2,N)

%N=20;
%R1=1;
%R2=1.15;

DN=10;
A=0.2;
B=0.5;

angle=linspace(0,360,N*DN);
x=R1*cosd(angle);
y=R1*sind(angle);

for i=2:DN/2
I=(0:N-1)*DN+i;
x(I)=R2*cosd(angle(I));
y(I)=R2*sind(angle(I));
end

x0=A*R1*cosd(angle);
y0=A*R1*sind(angle);

x=[x,nan,x0,nan,x0,nan,x0+B*R1,nan,x0-B*R1,nan];
y=[y,nan,y0+B*R1,nan,y0-B*R1,nan,y0,nan,y0,nan];

end


## end
#63, 22:
Matlab\gears\gear_2D.m
## end
#68, 129:
%{
地址::Matlab\gears\rect_2D.m
+[保存M函数](,rect_2D)
%}

function [x,y]=rect_2D(W,H)
x=[0,0,H,H,0];
y=[-W/2,W/2,W/2,-W/2,-W/2];
end


## end
#71, 22:
Matlab\gears\rect_2D.m
## end
#76, 195:
%{
地址::Matlab\gears\frame_from_pt_angle.m
测试:...
+[保存M函数](,frame_from_pt_angle)
%}

function [pt,angle]=frame_from_pt_angle(pt_g,angle_g,pt_l,angle_l)
pt=pt_g-pt_l;
angle=angle_g-angle_l;
end




## end
#78, 34:
Matlab\gears\frame_from_pt_angle.m
## end
#80, 285:
%{
+[M函数](,测试)
%}

addpath('Matlab\gears')

pt_g=[1,1];
pt_l=[0,1/3];
angle_g=60;
angle_l=30;
[x0,y0]=rect_2D(4,1);

pt=pt_g-pt_l;
angle=angle_g-angle_l;

clf
obj_2D_shape(x0,y0,angle,pt);
obj_2D_shape(x0,y0,-30,[3,0]);
hold on
plot(pt_g(1),pt_g(2),'.')
axis equal

%{
+[M函数](,画图测试)
%}
## end
#85, 606:
%{
+[M函数](,画图测试)

obj_2D_shape:...
frame_from_pt_angle:...
%}

addpath('Matlab\gears')

pt1_g=[1,1];
pt2_g=[2,2];
pt1_l=[1/3,0];
pt2_l=[1/3+1,0];
[x0,y0]=rect_2D(4,1);

dpt_g=pt2_g-pt1_g;
dpt_l=pt2_l-pt1_l;
dpt_g=dpt_g/norm(dpt_g);
dpt_g(isnan(dpt_g))=0;
dpt_l=dpt_l/norm(dpt_l);
dpt_l(isnan(dpt_l))=0;

angle_g=acosd(dpt_g(1))*sign_1(dpt_g(2));
angle_l=acosd(dpt_l(1))*sign_1(dpt_l(2));

[pt,angle]=frame_from_pt_angle(pt1_g,angle_g,pt1_l,angle_l);


clf
obj_2D_shape(x0,y0,angle,pt);
obj_2D_shape(x0,y0,-30,[3,0]);
hold on
plot(pt1_g(1),pt1_g(2),'.',pt2_g(1),pt2_g(2),'.')
axis equal

%{
+[M函数](,画图测试)
%}
## end
#87, 515:
%{
地址::Matlab\gears\frame_from_pts.m
+[保存M函数](,frame_from_pts)
测试:...
%}

function [pt,angle,vx,vy]=frame_from_pts(pt1_g,pt2_g,pt1_l,pt2_l)

dpt_g=pt2_g-pt1_g;
dpt_l=pt2_l-pt1_l;
dpt_g=dpt_g/norm(dpt_g);
dpt_g(isnan(dpt_g))=0;
dpt_l=dpt_l/norm(dpt_l);
dpt_l(isnan(dpt_l))=0;

angle_g=acosd(dpt_g(1))*sign_1(dpt_g(2));
angle_l=acosd(dpt_l(1))*sign_1(dpt_l(2));
angle=angle_g-angle_l;
vx=[cosd(angle),sind(angle)];
vy=[sind(angle),-cosd(angle)];
pt=pt1_g-vx*pt1_l(1)-vy*pt1_l(2);

end

%{
+[保存M函数](,frame_from_pts)
%}
## end
#89, 29:
Matlab\gears\frame_from_pts.m
## end
#94, 687:
%{
+[M函数](,画图测试)

obj_2D_shape:...
frame_from_pt_angle:...
frame_from_pts:...
保存:...
%}

addpath('Matlab\gears')

pt1_g=[1,1];
pt2_g=[2,3];
pt1_l=[1/3,0];
pt2_l=[1/3+1,0];
[x0,y0]=rect_2D(4,1);

dpt_g=pt2_g-pt1_g;
dpt_l=pt2_l-pt1_l;
dpt_g=dpt_g/norm(dpt_g);
dpt_g(isnan(dpt_g))=0;
dpt_l=dpt_l/norm(dpt_l);
dpt_l(isnan(dpt_l))=0;

angle_g=acosd(dpt_g(1))*sign_1(dpt_g(2));
angle_l=acosd(dpt_l(1))*sign_1(dpt_l(2));
angle=angle_g-angle_l;
vx=[cosd(angle),sind(angle)];
vy=[sind(angle),-cosd(angle)];
pt=pt1_g-vx*pt1_l(1)-vy*pt1_l(2);

clf
obj_2D_shape(x0,y0,angle,pt);
obj_2D_shape(x0,y0,-30,[3,0]);
hold on
plot(pt1_g(1),pt1_g(2),'.',pt2_g(1),pt2_g(2),'.')
axis equal

%{
+[M函数](,画图测试)
%}
## end
#96, 242:
%{
地址::Matlab\gears\frame_to_pts.m
+[保存M函数](,frame_to_pts)
测试:...
%}

function pt1=frame_to_pts(pt1_l,pt,angle)

vx=[cosd(angle),sind(angle)];
vy=[-sind(angle),cosd(angle)];
pt1=pt+vx*pt1_l(1)+vy*pt1_l(2);

end


%{
+[保存M函数](,frame_to_pts)
%}
## end
#98, 27:
Matlab\gears\frame_to_pts.m
## end
#103, 775:
%{
+[M函数](,画图测试)

obj_2D_shape:...
frame_from_pt_angle:...
frame_from_pts:...
frame_to_pts:...
保存:...
%}

addpath('Matlab\gears')

angle0=linspace(0,360,100);
pt1_g=[1,1];
pt1_l=[1/3,0];
pt2_l=[1/3+1,0];
pt3_l=[1/3+1,1];
[x0,y0]=rect_2D(4,1);


for i=1:length(angle0)
Dp=[cosd(angle0(i)),sind(angle0(i))];
pt2_g=[1,1]+Dp;
[pt,angle]=frame_from_pts(pt1_g,pt2_g,pt1_l,pt2_l);
pt1=frame_to_pts(pt1_l,pt,angle);
pt2=frame_to_pts(pt2_l,pt,angle);
pt3=frame_to_pts(pt3_l,pt,angle);
[ptB,angleB]=frame_from_pts(pt2,pt3,pt1_l,pt2_l);

clf
obj_2D_shape(x0,y0,angle,pt);
obj_2D_shape(x0,y0,angleB,ptB);
hold on
plot(pt1_g(1),pt1_g(2),'.',pt2_g(1),pt2_g(2),'.')
plot(pt1(1),pt1(2),'o',pt2(1),pt2(2),'o',pt3(1),pt3(2),'o')
axis equal
axis([-3,5,-3,5])
pause(0.1)
end

%{
+[M函数](,画图测试)
%}
## end
#105, 692:
%{
+[M函数](,两点固定)
%}

addpath('Matlab\gears')

angle0=linspace(0,360,100);
pt1_g=[1,1];
pt1_l=[1/3,0];
pt2_l=[1/3+1,0];
pt3_l=[1/3+1,1];
[x0,y0]=rect_2D(0.3,4);


for i=1:length(angle0)
Dp=[cosd(angle0(i)),sind(angle0(i))];
pt2_g=[1,1]+Dp;
[pt,angle]=frame_from_pts(pt1_g,pt2_g,pt1_l,pt2_l);
pt1=frame_to_pts(pt1_l,pt,angle);
pt2=frame_to_pts(pt2_l,pt,angle);
pt3=frame_to_pts(pt3_l,pt,angle);
[ptB,angleB]=frame_from_pts(pt1,pt3,pt1_l,pt2_l);

clf
obj_2D_shape(x0,y0,angle,pt);
obj_2D_shape(x0,y0,angleB,ptB);
hold on
plot(pt1_g(1),pt1_g(2),'.',pt2_g(1),pt2_g(2),'.')
plot(pt1(1),pt1(2),'o',pt2(1),pt2(2),'o',pt3(1),pt3(2),'o')
axis equal
axis([-3,5,-3,5])
pause(0.1)
end

%{
+[M函数](,画图测试)
%}
## end
#107, 1527:
<!--
+[H函数](,公式推导)
+[修改天使]

[9].:
将"(x-x_2)^2+(y-y_2)^2=L_2^2"记作为式(2)
将"y=\sqrt{L_2^2-(x-x_2)^2}+y_2"记作为式(3)
将式(3)代入到式(4)
式(2)转换为"表达式"
将"4*(DX_1^2+DY_1^2)*DX^2-4*(D*DX_1)*DX+(D^2-4*DY_1^2*L_2^{2})=0"记作为式(16)
将"DY=\sqrt{L_2^{2}-DX^2}"记作为式(19)
-->

<h2>Joint arms</h2>
The length of two arms are \(L_1\) and \(L_2\). Two arms are joint at one end and positions of the other end are \((x_1,y_1)\) and \((x_2,y_2)\). Here we want to determine the position of the joint point, \((x,y)\).
Then we have two equations, 
%[1].
%[2].
By solving eq.[2], we have,
%[3].
%[4].
%[5].
%[6].
%[7].
%[8].
%[9].
Assume following equations,
%[10].
%[11].

Then eq.[9] will be,
%[12].
%[13].
%[14].
%[15].

As a result, \(DX\) can be calculated,
%[16].
%[17].
%[18].

And \(DY\) can be calculated,
%[19].

<h2>Guide rail</h2>
The length of an arm is \(L\). One end of the arm is fixed on a guide rail, which is known. The position of the other end of the arm is known as \((x_1,y_1)\). Calculate the position of the end on a guide rail. Then we have three equations, 
%[20].
%[21].
%[22].
By putting eq.[21] and eq.[22] into eq.[20], we will have,
%[23].
%[24].
%[25].
Then \(t\) can be solved by following,
%[26].
%[27].
%[28].
Then \(x) and \(y\) can be calculated by eq.[21] and eq.[22]. 

<!--
[28].:
将"y=y_0+t*v_y"记作为式(22)
将式(20)记作为式(23)
将式(22)代入到式(23)
式(23)转换为"表达式"
将"t=\frac{-(Dx*v_x+Dy*v_y)+\sqrt{(v_x^2+v_y^2)*L^{2}-(v_x*Dy-v_y*Dx)^2}}{v_x^2+v_y^2}"记作为式(28)

式(22)转换为"Matlab"

验证公式:...
(式(9)不正确, 错了一个负号)
+[新建阅读窗口](,验证公式)
+[H函数](,公式推导)
-->
## end
#110, 53:
\left(x-x_1\right)^{2}+\left(y-y_1\right)^{2}=L_1^{2}
## end
#112, 25:
(x-x_1)^2+(y-y_1)^2=L_1^2
## end
#116, 53:
\left(x-x_2\right)^{2}+\left(y-y_2\right)^{2}=L_2^{2}
## end
#117, 25:
(x-x_2)^2+(y-y_2)^2=L_2^2
## end
#121, 43:
y=\sqrt{L_2^{2}-\left(x-x_2\right)^{2}}+y_2
## end
#122, 28:
y=\sqrt{L_2^2-(x-x_2)^2}+y_2
## end
#126, 93:
\left(x-x_1\right)^{2}+\left(\sqrt{L_2^{2}-\left(x-x_2\right)^{2}}-y_1+y_2\right)^{2}=L_1^{2}
## end
#127, 25:
(x-x_1)^2+(y-y_1)^2=L_1^2
## end
#133, 162:
\left(x-x_1\right)^{2}+\left(L_2^{2}+\left(y_2-y_1\right)^{2}+2\ \left(y_2-y_1\right)\ \sqrt{L_2^{2}-\left(x-x_2\right)^{2}}-\left(x-x_2\right)^{2}\right)=L_1^{2}
## end
#134, 92:
(x-x_1)^{2}+(L_2^{2}-(x-x_2)^{2}+2*(y_2-y_1)*\sqrt{L_2^{2}-(x-x_2)^{2}}+(y_2-y_1)^2)=L_1^{2}
## end
#138, 146:
x_1^{2}-x_2^{2}-2\ \left(x_1-x_2\right)\ x+2\ \left(y_2-y_1\right)\ \sqrt{L_2^{2}-\left(x-x_2\right)^{2}}+\left(y_2-y_1\right)^{2}=L_1^{2}-L_2^{2}
## end
#139, 92:
x_1^2-x_2^2-2*(x_1-x_2)*x+2*(y_2-y_1)*\sqrt{L_2^{2}-(x-x_2)^{2}}+(y_2-y_1)^2=L_1^{2}-L_2^{2}
## end
#143, 151:
\left(x_1-x_2\right)\ \left(x_1+x_2-2\ x\right)+2\ \left(y_2-y_1\right)\ \sqrt{L_2^{2}-\left(x-x_2\right)^{2}}+\left(y_2-y_1\right)^{2}=L_1^{2}-L_2^{2}
## end
#144, 90:
(x_1-x_2)*(x_1+x_2-2*x)+2*(y_2-y_1)*\sqrt{L_2^{2}-(x-x_2)^{2}}+(y_2-y_1)^2=L_1^{2}-L_2^{2}
## end
#148, 201:
\sqrt{L_2^{2}-\left(x-x_2\right)^{2}}=\frac{\left(L_1^{2}-L_2^{2}\right)-\left(x_1-x_2\right)\ \left(\left(x_1-x_2\right)-2\ \left(x-x_2\right)\right)-\left(y_2-y_1\right)^{2}}{2\ \left(y_2-y_1\right)}
## end
#149, 108:
\sqrt{L_2^{2}-(x-x_2)^{2}}=\frac{(L_1^{2}-L_2^{2})-(x_1-x_2)*((x_1-x_2)-2*(x-x_2))-(y_2-y_1)^2}{2*(y_2-y_1)}
## end
#153, 192:
\sqrt{L_2^{2}-\left(x-x_2\right)^{2}}=\frac{\left(L_1^{2}-L_2^{2}\right)+2\ \left(x_1-x_2\right)\ \left(x-x_2\right)-\left(y_2-y_1\right)^{2}-\left(x_1-x_2\right)^{2}}{2\ \left(y_2-y_1\right)}
## end
#154, 108:
\sqrt{L_2^{2}-(x-x_2)^{2}}=\frac{(L_1^{2}-L_2^{2})-(x_1-x_2)^2-(y_2-y_1)^2+2*(x_1-x_2)*(x-x_2)}{2*(y_2-y_1)}
## end
#158, 67:
D=L_1^{2}-\left(y_1-y_2\right)^{2}-\left(x_1-x_2\right)^{2}-L_2^{2}
## end
#159, 41:
D=L_1^{2}-L_2^{2}-(x_1-x_2)^2-(y_1-y_2)^2
## end
#163, 8:
DX=x-x_2
## end
#164, 8:
DX=x-x_2
## end
#168, 52:
\sqrt{L_2^{2}-DX^{2}}=\frac{D+2\ DX_1\ DX}{-2\ DY_1}
## end
#169, 49:
\sqrt{L_2^{2}-DX^{2}}=\frac{D+2*DX_1*DX}{-2*DY_1}
## end
#173, 71:
4\ DY_1^{2}\ \left(L_2^{2}-DX^{2}\right)=\left(D+2\ DX_1\ DX\right)^{2}
## end
#174, 41:
4*DY_1^2*(L_2^{2}-DX^{2})=(D+2*DX_1*DX)^2
## end
#178, 81:
4\ DY_1^{2}\ \left(L_2^{2}-DX^{2}\right)=D^{2}+4\ DX\ DX_1\ D+4\ DX_1^{2}\ DX^{2}
## end
#179, 55:
4*DY_1^2*(L_2^{2}-DX^{2})=D^2+4*D*DX_1*DX+4*DX_1^2*DX^2
## end
#183, 111:
4\ DX^{2}\ \left(DX_1^{2}+DY_1^{2}\right)+\left(D^{2}-4\ DY_1^{2}\ L_2^{2}\right)+4\ \left(D\ DX_1\right)\ DX=0
## end
#184, 61:
4*(DX_1^2+DY_1^2)*DX^2+4*(D*DX_1)*DX+(D^2-4*DY_1^2*L_2^{2})=0
## end
#188, 170:
DX=-\frac{\left(D\ DX_1\right)+\sqrt{\left(D\ DX_1\right)^{2}-\left(DX_1^{2}+DY_1^{2}\right)\ \left(D^{2}-4\ DY_1^{2}\ L_2^{2}\right)}}{2\ \left(DX_1^{2}+DY_1^{2}\right)}
## end
#189, 95:
DX=\frac{-(D*DX_1)-\sqrt{(D*DX_1)^2-(DX_1^2+DY_1^2)*(D^2-4*DY_1^2*L_2^{2})}}{2*(DX_1^2+DY_1^2)}
## end
#193, 176:
DX=-\frac{D\ DX_1+\sqrt{\left(D\ DX_1\right)^{2}-\left(DX_1^{2}+DY_1^{2}\right)\ D^{2}+4\ L_2^{2}\ DY_1^{2}\ \left(DX_1^{2}+DY_1^{2}\right)}}{2\ \left(DX_1^{2}+DY_1^{2}\right)}
## end
#194, 107:
DX=\frac{-D*DX_1-\sqrt{(D*DX_1)^2-(DX_1^2+DY_1^2)*D^2+4*(DX_1^2+DY_1^2)*DY_1^2*L_2^{2}}}{2*(DX_1^2+DY_1^2)}
## end
#198, 138:
DX=-\frac{D\ DX_1+\sqrt{4\ L_2^{2}\ DY_1^{2}\ \left(DX_1^{2}+DY_1^{2}\right)-\left(D\ DY_1\right)^{2}}}{2\ \left(DX_1^{2}+DY_1^{2}\right)}
## end
#199, 87:
DX=\frac{-D*DX_1-\sqrt{4*(DX_1^2+DY_1^2)*DY_1^2*L_2^{2}-(D*DY_1)^2}}{2*(DX_1^2+DY_1^2)}
## end
#203, 24:
DY=\sqrt{L_2^{2}-DX^{2}}
## end
#204, 22:
DY=\sqrt{L_2^{2}-DX^2}
## end
#208, 513:
%{
+[M函数](,验证公式)

joint_two_arms:...
铰链双杆:...
导轨杆:...
+[新建阅读窗口](,joint_two_arms)
%}

L=3;
x_1=0;
x_0=0;
y_0=0;
v_x=1;
v_y=0;

ys_1=linspace(3,0,100);

for i=1:length(ys_1)
y_1=ys_1(i);
Dx=x_0-x_1;
Dy=y_0-y_1;

t=(-(Dx.*v_x+Dy.*v_y)+sqrt((v_x.^(2)+v_y.^(2)).*L.^(2)-(v_x.*Dy-v_y.*Dx).^(2)))./(v_x.^(2)+v_y.^(2));
x=x_0+t.*v_x;
y=y_0+t.*v_y;

plot([x_1,x],[y_1,y],'o-',[x_0,x],[y_0,y],'k--')
title(sprintf('L=%.3f',sqrt((x_1-x)^2+(y_1-y)^2)))
axis equal
axis([-0.2,3.2,-0.2,4]);
pause(0.1)

end

%{
+[M函数](,验证公式)
%}
## end
#210, 51:
\left(x-x_1\right)^{2}+\left(y-y_1\right)^{2}=L^{2}
## end
#211, 23:
(x-x_1)^2+(y-y_1)^2=L^2
## end
#215, 12:
x=x_0+t\ v_x
## end
#217, 12:
y=y_0+t\ v_y
## end
#218, 11:
x=x_0+t*v_x
## end
#221, 11:
y=y_0+t*v_y
## end
#225, 69:
\left(x_0-x_1+t\ v_x\right)^{2}+\left(y_0-y_1+t\ v_y\right)^{2}=L^{2}
## end
#226, 23:
(x-x_1)^2+(y-y_1)^2=L^2
## end
#234, 59:
\left(Dx+t\ v_x\right)^{2}+\left(Dy+t\ v_y\right)^{2}=L^{2}
## end
#235, 35:
(Dx+t*v_x)^{2}+(Dy+t*v_y)^{2}=L^{2}
## end
#239, 105:
\left(v_x^{2}+v_y^{2}\right)\ t^{2}+2\ \left(Dx\ v_x+Dy\ v_y\right)\ t+\left(Dx^{2}+Dy^{2}-L^{2}\right)=0
## end
#240, 57:
(v_x^2+v_y^2)*t^2+2*(Dx*v_x+Dy*v_y)*t+(Dx^2+Dy^2-L^{2})=0
## end
#244, 183:
t=\frac{-2\ \left(Dx\ v_x+Dy\ v_y\right)+\sqrt{4\ \left(Dx\ v_x+Dy\ v_y\right)^{2}-4\ \left(v_x^{2}+v_y^{2}\right)\ \left(Dx^{2}+Dy^{2}-L^{2}\right)}}{2\ \left(v_x^{2}+v_y^{2}\right)}
## end
#245, 105:
t=\frac{-2*(Dx*v_x+Dy*v_y)+\sqrt{4*(Dx*v_x+Dy*v_y)^2-4*(v_x^2+v_y^2)*(Dx^2+Dy^2-L^{2})}}{2*(v_x^2+v_y^2)}
## end
#249, 176:
t=\frac{-\left(Dx\ v_x+Dy\ v_y\right)+\sqrt{2\ v_y\ v_x\ Dy\ Dx+\left(v_x^{2}+v_y^{2}\right)\ L^{2}-\left(v_x^{2}\ Dy^{2}+v_y^{2}\ Dx^{2}\right)}}{\left(v_x^{2}+v_y^{2}\right)}
## end
#250, 107:
t=\frac{-(Dx*v_x+Dy*v_y)+\sqrt{2*Dx*Dy*v_x*v_y-(v_x^2*Dy^2+v_y^2*Dx^2)+(v_x^2+v_y^2)*L^{2}}}{(v_x^2+v_y^2)}
## end
#254, 131:
t=\frac{-\left(Dx\ v_x+Dy\ v_y\right)+\sqrt{\left(v_x^{2}+v_y^{2}\right)\ L^{2}-\left(v_x\ Dy-v_y\ Dx\right)^{2}}}{v_x^{2}+v_y^{2}}
## end
#255, 83:
t=\frac{-(Dx*v_x+Dy*v_y)+\sqrt{(v_x^2+v_y^2)*L^{2}-(v_x*Dy-v_y*Dx)^2}}{v_x^2+v_y^2}
## end
#259, 451:
%{
+[M函数](,铰链双杆)

单个位置:...
扫描位置:...
%}

L_1=3;
L_2=4;
x_1=0;
x_2=2;
y_2=1;

ys_1=linspace(6,-3,40);

for i=1:length(ys_1)
y_1=ys_1(i);
[pt1,pt2]=joint_two_arms([x_1,y_1],[x_2,y_2],L_1,L_2);

clf
plot([x_1,pt1(1),x_2],[y_1,pt1(2),y_2],'o-',[x_1,pt2(1),x_2],[y_1,pt2(2),y_2],'o-')
title(sprintf('L_1=%.3f,L_2=%.3f',sqrt((pt1(1)-x_1)^2+(pt1(2)-y_1)^2),sqrt((pt1(1)-x_2)^2+(pt1(2)-y_2)^2)))
axis equal
axis([-4,6,-4,6])
pause(0.1)
end

%{
+[M函数](,铰链双杆)
%}
## end
#261, 467:
%{
+[M函数](,验证公式)

铰链双杆:...
导轨杆:...
%}

L=3;
x_1=0;
x_0=0;
y_0=0;
v_x=1;
v_y=0;

ys_1=linspace(3,0,100);

for i=1:length(ys_1)
y_1=ys_1(i);
Dx=x_0-x_1;
Dy=y_0-y_1;

t=(-(Dx.*v_x+Dy.*v_y)+sqrt((v_x.^(2)+v_y.^(2)).*L.^(2)-(v_x.*Dy-v_y.*Dx).^(2)))./(v_x.^(2)+v_y.^(2));
x=x_0+t.*v_x;
y=y_0+t.*v_y;

plot([x_1,x],[y_1,y],'o-',[x_0,x],[y_0,y],'k--')
title(sprintf('L=%.3f',sqrt((x_1-x)^2+(y_1-y)^2)))
axis equal
axis([-0.2,3.2,-0.2,4]);
pause(0.1)

end

%{
+[M函数](,验证公式)
%}
## end
#263, 982:
%{
地址::Matlab\gears\joint_two_arms.m
+[保存M函数](,joint_two_arms)

JS版本:...
将'JS版本'的"abs"替换为"Math.abs"
+[新建阅读窗口](,JS版本)
%}

function [pt1,pt2]=joint_two_arms(pt_1,pt_2,L_1,L_2)
% L_1=4;
% L_2=4;
x_1=pt_1(1);
y_1=pt_1(2);
x_2=pt_2(1);
y_2=pt_2(2);

DX_1=x_1-x_2;
DY_1=y_1-y_2;

D=L_1.^(2)-(y_1-y_2).^(2)-(x_1-x_2).^(2)-L_2.^(2);
DX1=(-D.*DX_1-sqrt(4.*L_2.^(2).*DY_1.^(2).*(DX_1.^(2)+DY_1.^(2))-(D.*DY_1).^(2)))./(2.*(DX_1.^(2)+DY_1.^(2)));
DX2=(-D.*DX_1+sqrt(4.*L_2.^(2).*DY_1.^(2).*(DX_1.^(2)+DY_1.^(2))-(D.*DY_1).^(2)))./(2.*(DX_1.^(2)+DY_1.^(2)));

x1=DX1+x_2;
x2=DX2+x_2;


DY1=sqrt(L_2.^(2)-DX1.^(2));
DY2=-sqrt(L_2.^(2)-DX2.^(2));

y1=DY1+y_2;
y2=DY2+y_2;

if abs(sqrt((x1-x_1)^2+(y1-y_1)^2)-L_1)>1e-6
    y1=-DY1+y_2;
end
if abs(sqrt((x2-x_1)^2+(y2-y_1)^2)-L_1)>1e-6
    y2=-DY2+y_2;
end

test=cross([x1-x_1,y1-y_1,0],[x1-x_2,y1-y_2,0]);
test=test(3);
if test<0
    pt2=[x1,y1];
    pt1=[x2,y2];
else
    pt1=[x1,y1];
    pt2=[x2,y2];
end



end


%{
+[保存M函数](,joint_two_arms)
%}
## end
#265, 29:
Matlab\gears\joint_two_arms.m
## end
#270, 459:
%{
+[M函数](,铰链双杆)
%}

L_1=4;
L_2=4;
x_1=0;
y_1=-1;
x_2=2;
y_2=1;

DX_1=x_1-x_2;
DY_1=y_1-y_2;

D=L_1.^(2)-(y_1-y_2).^(2)-(x_1-x_2).^(2)-L_2.^(2);
DX=(-D.*DX_1-sqrt(4.*L_2.^(2).*DY_1.^(2).*(DX_1.^(2)+DY_1.^(2))-(D.*DY_1).^(2)))./(2.*(DX_1.^(2)+DY_1.^(2)));
DY=sqrt(L_2.^(2)-DX.^(2));

x=DX+x_2;
y=DY+y_2;

plot([x_1,x,x_2],[y_1,y,y_2],'o-')
title(sprintf('L_1=%.3f,L_2=%.3f',sqrt((x-x_1)^2+(y-y_1)^2),sqrt((x-x_2)^2+(y-y_2)^2)))
axis equal


%{
+[M函数](,验证公式)
%}
## end
#272, 1046:
%{
+[M函数](,扫描位置)
%}

L_1=3;
L_2=4;
x_1=0;
x_2=2;
y_2=1;

ys_1=linspace(6,-3,100);
%ys_1=1;

for i=1:length(ys_1)
y_1=ys_1(i);
DX_1=x_1-x_2;
DY_1=y_1-y_2;

D=L_1.^(2)-(y_1-y_2).^(2)-(x_1-x_2).^(2)-L_2.^(2);
DX1=(-D.*DX_1-sqrt(4.*L_2.^(2).*DY_1.^(2).*(DX_1.^(2)+DY_1.^(2))-(D.*DY_1).^(2)))./(2.*(DX_1.^(2)+DY_1.^(2)));
DX2=(-D.*DX_1+sqrt(4.*L_2.^(2).*DY_1.^(2).*(DX_1.^(2)+DY_1.^(2))-(D.*DY_1).^(2)))./(2.*(DX_1.^(2)+DY_1.^(2)));

x1=DX1+x_2;
x2=DX2+x_2;

DY1=sqrt(L_2.^(2)-DX1.^(2));
DY2=-sqrt(L_2.^(2)-DX2.^(2));

y1=DY1+y_2;
if abs(sqrt((x1-x_1)^2+(y1-y_1)^2)-L_1)>1e-6
    y1=-DY1+y_2;
end
y2=DY2+y_2;
if abs(sqrt((x2-x_1)^2+(y2-y_1)^2)-L_1)>1e-6
    y2=-DY2+y_2;
end

test=cross([x1-x_1,y1-y_1,0],[x1-x_2,y1-y_2,0]);
test=test(3);
if test<0
    x=x1;
    x1=x2;
    x2=x;
    
    y=y1;
    y1=y2;
    y2=y;
end


clf
plot([x_1,x1,x_2],[y_1,y1,y_2],'o-',[x_1,x2,x_2],[y_1,y2,y_2],'o--')
title(sprintf('L_1=%.3f,L_2=%.3f',sqrt((x1-x_1)^2+(y1-y_1)^2),sqrt((x1-x_2)^2+(y1-y_2)^2)))
axis equal
axis([-4,6,-4,6])
pause(0.1)
end

%{
+[M函数](,扫描位置)
%}
## end
#274, 31:


连杆平动:...
驱动连杆:...
驱动夹子:...



## end
#276, 643:
%{
+[M函数](,连杆平动)
%}

addpath('Matlab\gears')

pt_1=[0,2];
pt_2=[4,0];

L=4;
d=0.3;
pt_arch1=[d,0];
pt_arch2=[L+d,0];
[x0,y0]=rect_2D(0.3,L+2*d);

%{
+[M函数](,画图测试)
%}
ys_1=linspace(-3,11.5,20);

for i=1:length(ys_1)
pt_1(1)=ys_1(i);
%[pt_3,~]=joint_two_arms(pt_1,pt_2,L,L);
[~,pt_3]=joint_two_arms(pt_1,pt_2,L,L);
[pt_A,angle_A]=frame_from_pts(pt_1,pt_3,pt_arch1,pt_arch2);
[pt_B,angle_B]=frame_from_pts(pt_2,pt_3,pt_arch1,pt_arch2);

clf
hold on
obj_2D_shape(x0,y0,angle_A,pt_A);
obj_2D_shape(x0,y0,angle_B,pt_B);
plot([pt_1(1),pt_2(1),pt_3(1)],[pt_1(2),pt_2(2),pt_3(2)],'o')
axis equal
axis([-7,12,-5,5])
pause(0.1)
end



%{
+[M函数](,画图测试)
%}
## end
#278, 833:
%{
+[M函数](,驱动连杆)

obj_2D_shape:...
frame_from_pt_angle:...
frame_from_pts:...
frame_to_pts:...

两点固定:...
例子库:...
+[新建阅读窗口](,例子库)
%}

addpath('Matlab\gears')
pt_G=[1,1];
pt_2=[4,-2];

L=3;
d=0.3;
pt_arch1=[d,0];
pt_arch2=[L+d,0];
pt1_g=[0.5,0.5];

[x_g,y_g]=gear_2D(1,1.15,20);
[x_l,y_l]=rect_2D(0.3,L+2*d);

AngleG=linspace(0,360,100);

for i=1:length(AngleG)
angle_G=AngleG(i);
pt_1=frame_to_pts(pt1_g,pt_G,angle_G);
[~,pt_3]=joint_two_arms(pt_1,pt_2,L,L);

[pt_A,angle_A]=frame_from_pts(pt_1,pt_3,pt_arch1,pt_arch2);
[pt_B,angle_B]=frame_from_pts(pt_2,pt_3,pt_arch1,pt_arch2);

clf
hold on
obj_2D_shape(x_g,y_g,angle_G,pt_G);
obj_2D_shape(x_l,y_l,angle_A,pt_A);
obj_2D_shape(x_l,y_l,angle_B,pt_B);
plot([pt_1(1),pt_2(1),pt_3(1)],[pt_1(2),pt_2(2),pt_3(2)],'o')
axis equal
axis([-6,7,-4,7]);
pause(0.1)
end

%{
clear
+[M函数](,画图测试)
%}
## end
#280, 201:
%{
地址::Matlab\gears\gear_rotation.m
+[保存M函数](,gear_rotation)
%}

function angle2=gear_rotation(angle1,N1,N2,angle01,angle02)
angle2=-(angle1-angle01)*N1/N2+angle02;
end


%{
+[保存M函数](,gear_rotation)
%}
## end
#282, 28:
Matlab\gears\gear_rotation.m
## end
#287, 1398:
%{
+[M函数](,画图测试)

obj_2D_shape:...
frame_from_pt_angle:...
frame_from_pts:...
frame_to_pts:...
gear_rotation:...

两点固定:...
例子库:...
+[新建阅读窗口](,例子库)
%}

addpath('Matlab\gears')
%pt_G1=[-2.5/2,1];
%pt_G2=[2.5/2,1];
pt_G1=[4,2.5/2];
pt_G2=[4,-2.5/2];
pt1_g=[0.5,0];
N=20;
R1=1.1;
R2=1.2;

L=3.5;
d=0.3;
pt_arch1=[d,0];
pt_arch2=[L/2+d,0];
pt_arch3=[L+d,0];

[x_g,y_g]=gear_2D(R1,R2,N);
[x_l,y_l]=rect_2D(0.3,L+2*d);

AngleG=linspace(0,360,100);

i=1;
for i=1:length(AngleG)
angle_G1=AngleG(i);
angle_G2=gear_rotation(angle_G1,N,N,0,0);

pt_1=frame_to_pts(pt1_g,pt_G1,angle_G1);
pt_2=frame_to_pts(pt1_g,pt_G2,angle_G2);

[~,pt_3]=joint_two_arms(pt_1,pt_2,L/2,L/2);
[pt_A,angle_A]=frame_from_pts(pt_1,pt_3,pt_arch1,pt_arch2);
[pt_B,angle_B]=frame_from_pts(pt_2,pt_3,pt_arch1,pt_arch2);

pt_4=frame_to_pts(pt_arch3,pt_A,angle_A);
pt_5=frame_to_pts(pt_arch3,pt_B,angle_B);

[~,pt_6]=joint_two_arms(pt_5,pt_4,L/2,L/2);
[pt_C,angle_C]=frame_from_pts(pt_4,pt_6,pt_arch1,pt_arch2);
[pt_D,angle_D]=frame_from_pts(pt_5,pt_6,pt_arch1,pt_arch2);


clf
hold on
obj_2D_shape(x_g,y_g,angle_G1,pt_G1);
obj_2D_shape(x_g,y_g,angle_G2,pt_G2);
obj_2D_shape(x_l,y_l,angle_A,pt_A);
obj_2D_shape(x_l,y_l,angle_B,pt_B);
obj_2D_shape(x_l,y_l,angle_C,pt_C);
obj_2D_shape(x_l,y_l,angle_D,pt_D);
plot([pt_1(1),pt_2(1),pt_3(1)],[pt_1(2),pt_2(2),pt_3(2)],'o')
axis equal
axis([-7,7,-7,3]);
pause(0.1)
end


%{
clear
+[M函数](,画图测试)
%}
## end
#288, 3:
327
## end
#291, 269:
%{
保存:...
%}

w_%宾语=-w_%主语*%N0/%N1;
angle_%宾语=angle_%宾语+dt*w_%宾语;
pt_%宾语=[%p1];
Dx=%R1*cos(angle_%宾语);
Dy=%R1*sin(angle_%宾语);
plot([pt_%宾语(1),pt_%宾语(1)+Dx],[pt_%宾语(2),pt_%宾语(2)+Dy],'o-')
rectangle('Position',[pt_%宾语(1)-%R1,pt_%宾语(2)-%R1,%R1*2,%R1*2],'Curvature',[1,1])

## end
#293, 862:
"""
M模板:...
M模板2:...
+[新建阅读窗口](,M模板)
保存:...

"""

+初始化(命名空间,_输出)->+[del](,+初始化)...
->的(初始化,M模板)->的(初始化,M模板2)...
->的(初始化,保存)...

->+[临时文本]->[]{
    []=>的(命名空间,变量)->变量(,_齿轮)->_齿轮&:
        =>的(_齿轮,齿数)->的(_齿轮,半径)->的(_齿轮,角度)->在(_齿轮,空间点)...
        ->+[模板文本](M模板,+[增加内容])->+[增加内容](,+[临时文本])...
            ->+[.](+[模板文本],变量)->+[.](+[模板文本],齿数)...
            ->+[.](+[模板文本],半径)->+[.](+[模板文本],角度)...
            ->+[.](+[模板文本],空间点),

        =>的(_齿轮,x)->的(_齿轮,y)->在(_齿轮,空间点#2)...
        ->+[模板文本](M模板2,+[增加内容]#2)->+[增加内容]#2(,+[临时文本])...
            ->+[.](+[模板文本],变量)->+[.](+[模板文本],x)->+[.](+[模板文本],y)...
            ->+[.](+[模板文本],空间点#2)->+[.]"方向"(+[模板文本],+[临时文本]#方向)...
            ->[]{
                []:->朝向(_齿轮,方向#1)->方向#1->[m_text](方向#1,+[临时文本]#方向),
                ->[m_text]"0"(,+[临时文本]#方向)
            }

}...

->+[修改内容](+[临时文本],保存)->+[修改内容](+[临时文本],_输出)



## end
#295, 182:
"""
M模板:...

"""

+驱动轮(_宾语,_输出)->+[del](,+驱动轮)...
->的(驱动轮,M模板)...

->变量(,_宾语)->的(_宾语,齿数)->的(_宾语,角速度)...
->+[模板文本](M模板,_输出)...
->+[.](+[模板文本],变量)->+[.](+[模板文本],齿数)->+[.](+[模板文本],角速度)

## end
#297, 594:
"""
M模板:...
+[新建阅读窗口](,M模板)
初始化:...
驱动轮:...

"""

+动画框架(命名空间,_宾语)->+[del](,+动画框架)...
->的(动画框架,M模板)->的(动画框架,初始化)...

->输出代码(+动画框架,_代码)->动画代码(+动画框架,_代码2)...
->变量#1(,_宾语)->的(_宾语,齿数#1)->的(_宾语,角速度#1)...
->在(_宾语,空间点#1)->的(_宾语,半径#1)...

->+[临时文本]->[]{
    []=>的(命名空间,变量)->变量(,_齿轮)...
        =>+[模板文本]"angle_%n=0;
"(,+[增加内容])->+[增加内容](,+[临时文本])...
        ->+[.]"n"(+[模板文本],变量)
}...

->+[模板文本](M模板,_代码)...
->+[.]"N1"(+[模板文本],齿数#1)->+[.]"w1"(+[模板文本],角速度#1)...
->+[.]"宾语"(+[模板文本],变量#1)...
->+[.]"R1"(+[模板文本],半径#1)->+[.]"p1"(+[模板文本],空间点#1)...
->+[.]"初始化"(+[模板文本],+[临时文本])...
->+[.]"运动过程"(+[模板文本],_代码2)



## end
#299, 89:

angle_0%变量=%角度;
angle_G%变量=%角度;
pt_G%变量=[%空间点];
[x_%变量,y_%变量]=gear_2D(%半径,%半径*1.1,%齿数);

## end
#301, 865:

angle_08=1;
angle_G8=1;
pt_G8=[2.0, 0.0];
[x_8,y_8]=gear_2D(1.0,1.0*1.1,20);

angle_07=1;
angle_G7=1;
pt_G7=[0.0, 0.0];
[x_7,y_7]=gear_2D(1.0,1.0*1.1,20);

angle_06=-135;
pt_G6=[0.0, 0.5];
x_6=[0.0, 0.0, -3.0, -3.0];
y_6=[-0.05, 0.05, 0.05, -0.05];

angle_05=-45;
pt_G5=[2.0, 0.5];
x_5=[0.0, 0.0, -3.0, -3.0];
y_5=[-0.05, 0.05, 0.05, -0.05];

angle_04=-135;
pt_G4=[-0.08939428018113293;
2.589745207444794];
x_4=[0.0, 0.0, -3.0, -3.0];
y_4=[-0.05, 0.05, 0.05, -0.05];

angle_03=-45;
pt_G3=[2.0874677899696854;
2.602780309661266];
x_3=[0.0, 0.0, -3.0, -3.0];
y_3=[-0.05, 0.05, 0.05, -0.05];

angle_02=128.92754359279232;
pt_G2=[1.4457920872899592;
5.466578886042874];
x_2=[0.0, 0.0, -4.0, -4.0];
y_2=[-0.05, 0.05, 0.05, -0.05];

angle_01=-118.14284940473533;
pt_G1=[2.0874677899696854;
2.602780309661266];
x_1=[0.0, 0.0, -4.0, -4.0];
y_1=[-0.05, 0.05, 0.05, -0.05];

## end
#303, 388:
%{
+[M函数](,保存)
保存:...
%}

dt=0.1;
%初始化

for i=1:100
angle_%宾语=angle_%宾语+dt*w_%宾语;
pt_%宾语=[%p1];
Dx=%R1*cos(angle_%宾语);
Dy=%R1*sin(angle_%宾语);
plot([pt_%宾语(1),pt_%宾语(1)+Dx],[pt_%宾语(2),pt_%宾语(2)+Dy],'o-')
rectangle('Position',[pt_%宾语(1)-%R1,pt_%宾语(2)-%R1,%R1*2,%R1*2],'Curvature',[1,1],'EdgeColor','blue','LineWidth',2)
hold on
axis equal

%运动过程

hold off
pause(0.1)
end


%{
+[M函数](,保存)
%}
## end
#305, 84:
angle_G%变量=angle_G%变量+dt*%角速度;
obj_2D_shape(x_%变量,y_%变量,angle_G%变量,pt_G%变量,[1,0,0]);
## end
#307, 284:
"""
保存:...

"""

+思考结构(,_齿轮)...
->思考结构(,)...

->记忆->内景(记忆,)->+转动(_齿轮,)&:
=>接触(_齿轮,_齿轮1)->[]{[]=>转动(_齿轮1,)}...
    =>+[code]([想]#1,思考结构)->[想]#1(,_齿轮1)->+传动(_齿轮,_齿轮1)->+的(内景,+传动),
=>接触(_齿轮2,_齿轮)->[]{[]=>转动(_齿轮2,)}...
    =>+[code]([想]#2,思考结构)->[想]#2(,_齿轮2)->+传动(_齿轮,_齿轮2)->+的(内景,+传动)



## end
#309, 42:


驱动杆1:...
驱动杆2:...

+[修改标题]"驱动杆1"(,驱动杆)


## end
#311, 651:
"""
固定:...
保存:...
+[新建阅读窗口](,保存)

"""

+驱动杆1(固定,_杆)...
->的(驱动杆1,固定#0)...

->记忆->内景(记忆,)...
->固定(,_条件)->到(固定,_杆)...
->+[code]([想],固定#0)->[想](,_杆)...
->到([想],_杆1)->是([想],固定#1)->[]{[]=>[is](固定#1,固定)}:

->确定(_杆1,)...
    ->+两点定位->+的(内景,+两点定位)...
    ->+固定点1(+两点定位,固定)->+定位物体1(+两点定位,_条件)...
    ->+固定点2(+两点定位,固定#1)->+定位物体2(+两点定位,_杆1)...
    ->+调整物体(+两点定位,_杆),

->+[code]([想]#2,固定#0)->[想]#2(,_杆1)...
    ->到([想]#2,_杆2)->是([想]#2,固定#2)->确定(_杆2,)...
    ->+确定(_杆1,)...
    ->+双杆定位->+的(内景,+双杆定位)...
    ->+固定点1(+双杆定位,固定)->+定位物体1(+双杆定位,_条件)...
    ->+固定点2(+双杆定位,固定#2)->+定位物体2(+双杆定位,_杆2)...
    ->+固定点3(+双杆定位,固定#1)...
    ->+调整物体1(+双杆定位,_杆)->+调整物体2(+双杆定位,_杆1)




## end
#313, 497:
"""
固定:...
保存:...
+[新建阅读窗口](,保存)

"""

+驱动杆1(固定,_杆)...
->的(驱动杆1,固定#0)...

->记忆->内景(记忆,)...
->固定(,_条件)->到(固定,_杆)...
->[固定](,_杆)->到([固定],_杆1)->是([固定],固定#1)->[]{[]=>[is](固定#1,固定)}:

->确定(_杆1,)...
    ->+两点定位(+和,_杆)->+的(内景,+两点定位)->+和(+条件#1,+条件#2)...
    ->+条件#1(固定,_条件)->+条件#2(固定#1,_杆1),

->[固定](,_杆1)->到([固定],_杆2)->是([固定],固定#2)->确定(_杆2,)...
    ->+确定(_杆1,)...
    ->+双杆定位(+和#1,+和#2)->+的(内景,+双杆定位)...
    ->+和#1(+条件#11,+条件#12)->+条件#11(固定,_条件)->+条件#12(固定#2,_杆2)...
    ->+和#2(_杆,_杆1)->+交点(+和#2,固定#1)



## end
#315, 145:
"""


"""

+固定(,_杆)->_杆:
    ->固定#1(,_杆)->到(固定#1,_物体1)->+到(+固定,_物体1)->+是(+固定,固定#1),
    ->到(固定#2,_杆)->固定#2(,_物体2)->+到(+固定,_物体2)->+是(+固定,固定#2)




## end
#317, 654:
"""
固定:...
保存:...
+[新建阅读窗口](,保存)


"""

+驱动杆2(固定,_杆)...
->的(驱动杆2,固定#0)...

->记忆->内景(记忆,)...
->固定(,_杆)->到(固定,_条件)...
->+[code]([想],固定#0)->[想](,_杆)...
->到([想],_杆1)->是([想],固定#1)->[]{[]=>[is](固定#1,固定)}:

->确定(_杆1,)...
    ->+两点定位->+的(内景,+两点定位)...
    ->+固定点1(+两点定位,固定)->+定位物体1(+两点定位,_条件)...
    ->+固定点2(+两点定位,固定#1)->+定位物体2(+两点定位,_杆1)...
    ->+调整物体(+两点定位,_杆),

->+[code]([想]#2,固定#0)->[想]#2(,_杆1)...
    ->到([想]#2,_杆2)->是([想]#2,固定#2)->确定(_杆2,)...
    ->+确定(_杆1,)...
    ->+双杆定位->+的(内景,+双杆定位)...
    ->+固定点1(+双杆定位,固定)->+定位物体1(+双杆定位,_条件)...
    ->+固定点2(+双杆定位,固定#2)->+定位物体2(+双杆定位,_杆2)...
    ->+固定点3(+双杆定位,固定#1)...
    ->+调整物体1(+双杆定位,_杆)->+调整物体2(+双杆定位,_杆1)






## end
#321, 547:
"""
固定:...
保存:...
+[新建阅读窗口](,保存)

"""

+驱动杆2(固定,_杆)...
->的(驱动杆2,固定#0)...

->记忆->内景(记忆,)...
->固定(,_杆)->到(固定,_条件)...
->+[code]([想],固定#0)->[想](,_杆)...
->到([想],_杆1)->是([想],固定#1)->[]{[]=>[is](固定#1,固定)}:

->确定(_杆1,)...
    ->+两点定位(+和,_杆)->+的(内景,+两点定位)->+和(+条件#1,+条件#2)...
    ->+条件#1(固定,_条件)->+条件#2(固定#1,_杆1),

->+[code]([想]#2,固定#0)->[想]#2(,_杆1)...
    ->到([想]#2,_杆2)->是([想]#2,固定#2)->确定(_杆2,)...
    ->+确定(_杆1,)...
    ->+双杆定位(+和#1,+和#2)->+的(内景,+双杆定位)...
    ->+和#1(+条件#11,+条件#12)->+条件#11(固定,_条件)->+条件#12(固定#2,_杆2)...
    ->+和#2(_杆,_杆1)->+交点(+和#2,固定#1)

## end
#322, 3:
328
## end
#324, 3:
372
## end
#327, 1066:
"""
描述模板::根据%杆1和%杆2, 确定%杆3和%杆4的位置. 
M模板:...
M代码:...
相对位置:...
+[新建阅读窗口](,M模板)

"""

+双杆定位(操作,_输出)->+[del](,+双杆定位)...
->的(双杆定位,描述模板)->的(双杆定位,M模板)...
->的(双杆定位,M代码)...
->的(双杆定位,相对位置)...

->固定点1(操作,固定#1)->定位物体1(操作,_杆1)...
->固定点2(操作,固定#2)->定位物体2(操作,_杆2)...
->固定点3(操作,固定#3)...
->调整物体1(操作,_杆3)->调整物体2(操作,_杆4)...


->+[做](固定#1,+[临时文本]#11)->+[.](+[做],_杆1)->+[code](+[做],相对位置)...
->+[做](固定#1,+[临时文本]#13)->+[.](+[做],_杆3)->+[code](+[做],相对位置)...
->+[做](固定#2,+[临时文本]#22)->+[.](+[做],_杆2)->+[code](+[做],相对位置)...
->+[做](固定#2,+[临时文本]#24)->+[.](+[做],_杆4)->+[code](+[做],相对位置)...
->+[做](固定#3,+[临时文本]#33)->+[.](+[做],_杆3)->+[code](+[做],相对位置)...
->+[做](固定#3,+[临时文本]#34)->+[.](+[做],_杆4)->+[code](+[做],相对位置)...


->变量#1(,_杆1)->变量#2(,_杆2)->变量#3(,_杆3)->变量#4(,_杆4)...

->+[模板文本](M模板,_输出)...
->+[.]"杆1"(+[模板文本],变量#1)->+[.]"杆2"(+[模板文本],变量#2)...
->+[.]"杆3"(+[模板文本],变量#3)->+[.]"杆4"(+[模板文本],变量#4)...
->+[.]"固定11"(+[模板文本],+[临时文本]#11)->+[.]"固定13"(+[模板文本],+[临时文本]#13)...
->+[.]"固定22"(+[模板文本],+[临时文本]#22)->+[.]"固定24"(+[模板文本],+[临时文本]#24)...
->+[.]"固定33"(+[模板文本],+[临时文本]#33)->+[.]"固定34"(+[模板文本],+[临时文本]#34)

## end
#331, 25:
根据%杆1和%杆2, 确定%杆3和%杆4的位置. 
## end
#333, 472:

L1=norm([%固定13]-[%固定33]);
L2=norm([%固定24]-[%固定34]);
pt_1=frame_to_pts([%固定11],pt_G%杆1,angle_G%杆1);
pt_2=frame_to_pts([%固定22],pt_G%杆2,angle_G%杆2);
[~,pt_3]=joint_two_arms(pt_1,pt_2,L1,L2);
[pt_G%杆3,angle_G%杆3]=frame_from_pts(pt_1,pt_3,[%固定13],[%固定33]);
[pt_G%杆4,angle_G%杆4]=frame_from_pts(pt_2,pt_3,[%固定24],[%固定34]);
obj_2D_shape(x_%杆3,y_%杆3,angle_G%杆3,pt_G%杆3);
obj_2D_shape(x_%杆4,y_%杆4,angle_G%杆4,pt_G%杆4);
plot([pt_1(1),pt_2(1),pt_3(1)],[pt_1(2),pt_2(2),pt_3(2)],'o')


## end
#335, 251:
%{
地址::Matlab\gears\pt_in_frame.m
+[保存M函数](,pt_in_frame)
测试:...
%}

function pt1=pt_in_frame(pt1_g,pt,angle)

vx=[cosd(angle),sind(angle)];
vy=[-sind(angle),cosd(angle)];
dp=pt1_g-pt;
pt1=[sum(dp.*vx),sum(dp.*vy)];

end


%{
+[保存M函数](,frame_to_pts)
%}
## end
#337, 26:
Matlab\gears\pt_in_frame.m
## end
#342, 155:
%{
+[M函数](,测试)
%}

addpath('Matlab\gears')

pt=[1,1];
angle=70;
pt1=[1,2];

pt2=frame_to_pts(pt1,pt,angle)
pt3=pt_in_frame(pt2,pt,angle)

%{
+[M函数](,测试)
%}
## end
#350, 491:
"""
M代码:...
位置:...
角度:...

"""

+相对位置(_固定,_输出)->+[del](,+相对位置)...
->的(相对位置,M代码)...
->的(相对位置,位置)->的(相对位置,角度)...

->.(+相对位置,_坐标系)...

->+[matlab](Matlab,_输出)->+[code](+[matlab],M代码)...
->+[.]"pt1"(+[matlab],+[临时文本]#11)->+[.]"pt2"(+[matlab],+[临时文本]#13)...
->+[.]"angle"(+[matlab],+[临时文本]#12)...
->+[code]([想]#11,位置)->[想]#11(_坐标系,)->[m_text]([想]#11,+[临时文本]#11)...
->+[code]([想]#12,角度)->[想]#12(_坐标系,)->[m_text]([想]#12,+[临时文本]#12)...
->+[code]([想]#13,位置)->[想]#13(_固定,)->[m_text]([想]#13,+[临时文本]#13)
## end
#352, 123:
"""


"""

+位置(_物体,)->_物体:
->在(_物体,空间点)->[m_text](空间点,+位置),
->[is](_物体,固定)->在(固定,_A点)->在(_A点,空间点#1)->[m_text](空间点#1,+位置)



## end
#354, 116:
"""


"""

+角度(_物体,)->_角度:
->朝向(_物体,方向)->[m_text](方向,+角度),
->的(_物体,角度#0)->[m_text](角度#0,+角度),
->[m_text]"0"(,+角度)



## end
#356, 161:
%{

%}

addpath('Matlab\gears')
if isempty(pt2)
    pt2=[0,0];
end
pt2=reshape(pt2,1,numel(pt2));
pt1=reshape(pt1,1,numel(pt1));

ans=pt_in_frame(pt2,pt1,angle);
## end
#358, 150:
"""


"""
+设置命名空间(命名空间,_物体)...

->[]:
    ->的(命名空间,变量)->变量(,_物体),
    ->+的(命名空间,+变量#0)->+变量#0(,_物体)...
        ->+[python]"i+=1
ans=i"(Python,+变量#0)


## end
#360, 57:

angle_0%变量=%方向;
pt_G%变量=[%空间点];
x_%变量=[%x];
y_%变量=[%y];

## end
#361, 3:
367
## end
#365, 1327:
/*
地址::Matlab\gears\joint_two_arms.m
+[保存M函数](,joint_two_arms)
/

function joint_two_arms(pt_1,pt_2,L_1,L_2) {

    x_1=pt_1[0];
    y_1=pt_1[1];
    x_2=pt_2[0];
    y_2=pt_2[1];
    
    DX_1=x_1-x_2;
    DY_1=y_1-y_2;
    
    D=L_1**2-(y_1-y_2)**2-(x_1-x_2)**2-L_2**2;
    DX1=(-D*DX_1-Math.sqrt(4*L_2**2*DY_1**2*(DX_1**2+DY_1**2)-(D*DY_1)**2))/(2*(DX_1**2+DY_1**2));
    DX2=(-D*DX_1+Math.sqrt(4*L_2**2*DY_1**2*(DX_1**2+DY_1**2)-(D*DY_1)**2))/(2*(DX_1**2+DY_1**2));
    
    x1=DX1+x_2;
    x2=DX2+x_2;
    
    
    DY1=Math.sqrt(L_2**2-DX1**2);
    DY2=-Math.sqrt(L_2**2-DX2**2);
    
    y1=DY1+y_2;
    y2=DY2+y_2;
    
    if (Math.abs(Math.sqrt((x1-x_1)**2+(y1-y_1)**2)-L_1)>1e-6) {
        y1=-DY1+y_2;
    }
    
    if (Math.abs(Math.sqrt((x2-x_1)**2+(y2-y_1)**2)-L_1)>1e-6) {
        y2=-DY2+y_2;
    }
    
    X_1=x1-x_1;
    Y_1=y1-y_1;
    X_2=x1-x_2;
    Y_2=y1-y_2;
    // test=cross([x1-x_1,y1-y_1,0],[x1-x_2,y1-y_2,0]);
    test=X_1*Y_2-X_2*Y_1;
    
    if (x1===NaN) {
        x1=0;
    }
    if (y1===NaN) {
        y1=0;
    }
    
    if (x2===NaN) {
        x2=0;
    }
    if (y2===NaN) {
        y2=0;
    }

    if (test<0) {
        pt2=[x1,y1];
        pt1=[x2,y2];
    }
    else {
        pt1=[x1,y1];
        pt2=[x2,y2];
    }
    
    return [pt1,pt2]

}



/*
+[保存M函数](,joint_two_arms)
/
## end
### 结束