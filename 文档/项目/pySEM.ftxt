### 节点
地址, 的, pySEM, 目录, 的, 的, 节点数目统计, 的, 操作, 的, 上传pySEM, 的, 地址, 的, 命令行, 的, 网址, 的, 笔记, 的, 地址, 的, 网址, 的, 测试代码, 的, column, 的, 样本1, 的, pyvista, 的, 参考, 的, 参考vtk, 的, bempp, 的, 参考, 的, 保存, 的, 测试场景, 的, 保存, 的, 测试aperture, 的, 测试lens, 的, 测试dfl, 的, readme, 的, 地址, 的, 网址, 的, 文本内容, 的, 文本结构, 的, 输出报告, 的, fig.1_, 图片, 的, fig.2_, 图片, 的, fig.3_, 图片, 手, 的, 架构, 的, 描述, 的, 结构, 的, 示意图, 的, [1]., 手, 的, 命令行2, 表达式, 的, 公式, 的, 命令行1, 的, 测试代码, 程序, 的, 测试表格, 表格, 结构, 的, 内容, 的, 模块, 的, 的, 起点, 的, 的, 的, 是, 空间点, 在, 运算模块, 的, 的, 的, 空间点, 在, 文字位置, 的, 的, 的, 文字, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 样式, 的, 的, 空间点, 在, 支路模块, 的, 的, 的, 空间点, 在, 文字位置, 的, 的, 的, 文字, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 样式, 的, 的, 空间点, 在, 支路模块, 的, 的, 的, 空间点, 在, 文字位置, 的, 的, 的, 文字, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 样式, 的, 的, 空间点, 在, 支路模块, 的, 的, 的, 空间点, 在, 文字位置, 的, 的, 的, 文字, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 样式, 的, 的, 空间点, 在, 支路模块, 的, 的, 的, 空间点, 在, 文字位置, 的, 的, 的, 文字, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 样式, 的, 的, 空间点, 在, 支路模块, 的, 的, 的, 空间点, 在, 文字位置, 的, 的, 的, 文字, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 样式, 的, 的, 空间点, 在, 支路模块, 的, 的, 的, 空间点, 在, 文字位置, 的, 的, 的, 文字, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 样式, 的, 的, 空间点, 在, 支路模块, 的, 的, 的, 空间点, 在, 文字位置, 的, 的, 的, 文字, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 样式, 的, 的, 空间点, 在, 支路模块, 的, 的, 的, 空间点, 在, 文字位置, 的, 的, 的, 文字, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 样式, 的, 的, 空间点, 在, 支路模块, 的, 的, 的, 空间点, 在, 文字位置, 的, 的, 的, 文字, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 样式, 的, 的, 空间点, 在, 支路模块, 的, 的, 的, 空间点, 在, 文字位置, 的, 的, 的, 文字, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 样式, 的, 的, 空间点, 在, 支路模块, 的, 的, 的, 空间点, 在, 文字位置, 的, 的, 的, 文字, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 样式, 的, 的, 空间点, 在, 支路模块, 的, 的, 的, 空间点, 在, 文字位置, 的, 的, 的, 文字, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 样式, 的, 的, 空间点, 在, 支路模块, 的, 的, 的, 空间点, 在, 文字位置, 的, 的, 的, 文字, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 样式, 的, 的, 空间点, 在, 支路模块, 的, 的, 的, 空间点, 在, 文字位置, 的, 的, 的, 文字, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 样式, 的, 的, 空间点, 在, 支路模块, 的, 的, 的, 空间点, 在, 文字位置, 的, 的, 的, 文字, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 样式, 的, 的, 空间点, 在, 支路模块, 的, 的, 的, 空间点, 在, 文字位置, 的, 的, 的, 文字, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 样式, 的, 的, 空间点, 在, 支路模块, 的, 的, 的, 空间点, 在, 文字位置, 的, 的, 的, 文字, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 样式, 的, 的, 空间点, 在, 支路模块, 的, 的, 的, 空间点, 在, 文字位置, 的, 的, 的, 文字, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 样式, 的, 的, 空间点, 在, 支路模块, 的, 的, 的, 空间点, 在, 文字位置, 的, 的, 的, 文字, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 样式, 的, 的, 空间点, 在, 支路模块, 的, 的, 的, 空间点, 在, 文字位置, 的, 的, 的, 文字, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 样式, 的, 的, 空间点, 在, 支路模块, 的, 的, 的, 空间点, 在, 文字位置, 的, 的, 的, 文字, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 样式, 的, 的, 空间点, 在, 支路模块, 的, 的, 的, 空间点, 在, 文字位置, 的, 的, 的, 文字, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 样式, 的, 的, 空间点, 在, 支路模块, 的, 的, 的, 空间点, 在, 文字位置, 的, 的, 的, 文字, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 样式, 的, 的, 空间点, 在, 支路模块, 的, 的, 的, 空间点, 在, 文字位置, 的, 的, 的, 文字, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 样式, 的, 的, 空间点, 在, 支路模块, 的, 的, 的, 空间点, 在, 文字位置, 的, 的, 的, 文字, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 样式, 的, 的, 空间点, 在, 支路模块, 的, 的, 的, 空间点, 在, 文字位置, 的, 的, 的, 文字, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 样式, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, 的, 地址, 的, 网址, 的, 测试package, 的, 参考, 的, 例子_patch, 的, 参考2, 的, 保存P函数_del, 的, P代码, 的, 模板, 手, 的, 地址, 创造日期, 的, 作者, 的, 的, elements, 的, 地址, 创造日期, 的, 作者, 的, 的, 测试画图, 的, 参考, 的, matlab_style_draw, 的, 地址, 创造日期, 的, 作者, 的, 的, patch测试, 的, 单个lens, 的, 多个lens, 的, 测试aperture, 的, 参考, 的, 测试场, 的, 磁偶极子, 的, 参考, 的, 参考2, 的, [1]., 的, [2]., 的, [3]., 手, 表达式, 的, 公式, 表达式, 的, 公式, 的, 验证公式, 的, 测试patch, 的, 参考circle, 的, space, 的, 地址, 的, 测试画场, 的, 例1_streamplot, 的, 参考, 的, 参考, 的, 矩阵形式场, 创造日期, 的, 作者, 的, 的, 测试场景, 在, 在, 的, 显示场景, 的, 保存, 的, 保存, 在, 在, 的, 显示磁场_1D, 在, 的, 显示磁场_2D, 的, 轨迹1, 图片, 的, 光斑1, 图片, 的, 光斑2, 图片, 的, 误差, 图片, 的, 轨迹2, 图片, 手, 的, fig_traj, 图片, 的, fig_traj_dflt, 图片, 的, fig_space, 图片, 的, fig_spots, 图片, 的, fig_aberration, 图片, 的, stepper, 的, 地址, 的, 测试运行, 的, 测试算法, 在, 在, 在, 在, 在, 在, 在, 在, 在, 在, 在, 在, 在, 在, 在, 在, 在, 在, 在, 在, 在, 在, 在, 在, 在, 的, 保存, 在, 在, 的, 单点测试, 的, 参考, 的, 测试plot, 的, 显示轨迹, 的, 多条轨迹, 在, 在, 在, 在, 在, 创造日期, 的, 作者, 的, 的, tracks, 的, 地址, 的, 测试运行, 创造日期, 的, 作者, 的, 的, hevean, 的, 测试流程, 的, 基本流程, 的, 地址, 创造日期, 的, 作者, 的, 的, 整合流程, 的, 线圈磁场, 的, 四级子电场, 的, 例子_磁场, 的, 例子_点电场, 的, 例子_电透镜, 的, 20230701, 的, 文本内容, 的, 文本结构, 的, 输出报告, 的, [1]., 的, [2]., 的, [3]., 的, [4]., 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, 的, [5]., 表达式, 的, 公式, 的, 收集数据, 的, 等效电场, 的, fig.1a_, 图片, 的, fig.1b_, 图片, 的, fig.1c_, 图片, 的, fig.1d_, 图片, 的, fig.2a_, 图片, 的, fig.2b_, 图片, 的, [6]., 的, [7]., 表达式, 的, 公式, 表达式, 的, 公式, 一级标题, 的, 二级标题, 的, 二级标题, 的, 二级标题, 的, 二级标题, 的, 题目, 的, 的, 然后, 文本, 的, 的, 然后, 公式, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 的, 然后, 公式, 的, LaTeX, 的, 名字, 的, LaTeX, 的, 名字, 的, 题目, 的, 的, 然后, 文本, 的, 的, 然后, 图片, 的, 的, 然后, 图片, 的, 目标地址, 的, 源地址, 的, 位置, 的, 类型, 的, 图例, 的, 名字, 的, 目标地址, 的, 源地址, 的, 位置, 的, 类型, 的, 图例, 的, 名字, 的, 题目, 的, 的, 然后, 文本, 的, 的, 然后, 图片, 的, 的, 然后, 图片, 的, 的, 然后, 文本, 的, 的, 然后, 图片, 的, 的, 然后, 文本, 的, 的, 然后, 图片, 的, 目标地址, 的, 源地址, 的, 位置, 的, 类型, 的, 图例, 的, 名字, 的, 目标地址, 的, 源地址, 的, 位置, 的, 类型, 的, 图例, 的, 名字, 的, 目标地址, 的, 源地址, 的, 位置, 的, 类型, 的, 图例, 的, 名字, 的, 目标地址, 的, 源地址, 的, 位置, 的, 类型, 的, 图例, 的, 名字, 的, 题目, 的, 的, 然后, 文本, 的, 的, 然后, 公式, 的, 的, 然后, 文本, 的, 的, 然后, 公式, 的, 的, 然后, 公式, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 的, 然后, 公式, 的, 的, 然后, 文本, 的, LaTeX, 的, 名字, 的, LaTeX, 的, 名字, 的, LaTeX, 的, 名字, 的, LaTeX, 的, 名字, 的, 题目, 的, 的, 然后, 的, 然后, 的, 然后, 地址, 的, 一级标题, 的, 二级标题, 的, 题目, 的, 的, 然后, 图片, 的, 的, 然后, 图片, 的, 的, 然后, 图片, 的, 的, 然后, 图片, 的, 的, 然后, 图片, 的, 的, 然后, 表格, 的, 内容, 的, 位置, 的, 类型, 的, 图例, 的, 名字, 的, 目标地址, 的, 源地址, 的, 位置, 的, 类型, 的, 图例, 的, 名字, 的, 目标地址, 的, 源地址, 的, 位置, 的, 类型, 的, 图例, 的, 名字, 的, 目标地址, 的, 源地址, 的, 位置, 的, 类型, 的, 图例, 的, 名字, 的, 目标地址, 的, 源地址, 的, 位置, 的, 类型, 的, 图例, 的, 名字, 的, 目标地址, 的, 源地址, 的, 位置, 的, 类型, 的, 图例, 的, 名字, 的, 题目, 的, 地址, 的, 的, log, 的, 文本内容, 的, 架构, 程序, 的, 文本结构, 的, 输出报告, 文本, 的, 一级标题, 的, 二级标题, 的, 题目, 的, 的, 然后, 程序, 的, 内容, 的, 位置, 的, 类型, 的, 图例, 的, 名字, 的, 题目, 的, 地址, 的, 的, tools, patch测试, 作者, 创造日期, 地址, 的, 的, 的, 的, matlab_style_draw, 的, 的, 3d_patch测试, 的, 参考1, 的, 参考2, 的, 2转3, 的, 例子2, 的, 例子3_fv, 的, 测试_xyz, 的, 测试_vf, 的, 匀强磁场轨迹, 的, 交点测试1, 的, 例子_屏幕, 的, 测试电子源, 的, 求和公式, html, 的, [1]., 的, [2]., 的, [3]., 的, [4]., 手, 表达式, 的, 公式, 起点, 的, 表达式, 的, 公式, 表达式, 的, 公式, b, 的, a, 的, 表达式, 的, 公式, 的, [5]., 的, [6]., 表达式, 的, 公式, 的, [7]., 表达式, 的, 公式, 表达式, 的, 公式, 的, [8]., 表达式, 的, 公式, 的, 参考, 的, 太阳花分布, html, 的, 参考, 的, [1]., 的, [2]., 的, [3]., 的, [4]., 的, [5]., 的, [6]., 的, [7]., 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, 的, 二次分布, 的, 均匀分布, 的, basic_tools, P函数, 的, 地址, 的, 测试分布, 手, 创造日期, 的, 作者, 的, 的, 图像分布, 的, 输出图像, 的, 测试电子源, 的, 均匀分布, 的, 文件输入, 的, [4]., 的, [5]., 的, [6]., 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, 的, [7]., 的, [8]., 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, 的, [9]., 的, [10]., 的, [11]., 表达式, 的, 公式, 的, [5.1]., 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, 的, [9.1]., 的, [10.1]., 表达式, 的, 公式, 表达式, 的, 公式, b, 的, a, 的, b, 的, a, 的, 的, [11.1]., 表达式, 的, 公式, b, 的, a, 的, b, 的, a, 的, 的, 保存B_field, 的, 例子_电子源, 的, 保存, 的, 测试元件, 的, 测试Mag, 的, 对称性问题, 的, 例子_电子轨迹, 的, 对称性问题2, 的, 对称性问题3, 的, 例子_线圈旋转, 的, zz代码, 的, bem, 的, fem, 的, mesh, 的, pysem_sf4, 的, 测试, 的, 保存, 的, 保存, 的, phi_func用法, 的, 地址, 创造日期, 的, 作者, 的, 的, 地址, 创造日期, 的, 作者, 的, 的, 地址, 的, 地址, 创造日期, 的, 作者, 的, 的, 地址, 创造日期, 的, 作者, 的, 的, 地址, 创造日期, 的, 作者, 的, 的, 地址, 创造日期, 的, 作者, 的, 的, 地址, 创造日期, 的, 作者, 的, 的, 地址, 创造日期, 的, 作者, 的, 
### 关联
#, 2#0, #, #, 3#2, 3#6, #, 2#8, #, 8#10, #, 10#12, #, 10#14, #, 10#16, #, 2#18, #, 18#20, #, 18#22, #, 2#24, #, 24#26, #, 26#28, #, 26#30, #, 30#32, #, 30#34, #, 26#36, #, 36#38, #, 26#40, #, 26#42, #, 42#44, #, 42#46, #, 42#48, #, 42#50, #, 2#52, #, 52#54, #, 52#56, #, 52#58, #, 52#60, #, 52#62, #, 58#64, #, 64#, 58#67, #, 67#, 58#70, #, 70#, #52, 2#74, #, 74#76, #, 74#78, #, 74#80, #, 58#82, #, #52, 10#85, #, #, 82#86, 82#, 10#90, #, 58#92, #, 92#, 58#95, #, 95#, #, 80#97, 101#, 97#99, #, 97#101, 97#104, #101, 101#108, 111#109, 111#110, 101#111, #, 111#109, #, 80#111, 121#115, 121#116, #, 121#115, #, 121#117, 111#121, 80#121, #, #, 111#122, #, 111#124, #, 111#126, #, 111#128, 111#131, 111#, 136#134, 136#135, #, 136#134, #, 80#136, 146#140, 146#141, #, 146#140, #, 146#142, 136#146, 80#146, #, #, 136#147, #, 136#149, #, 136#151, #, 136#153, 136#156, 136#, 161#159, 161#160, #, 161#159, #, 80#161, 171#165, 171#166, #, 171#165, #, 171#167, 161#171, 80#171, #, #, 161#172, #, 161#174, #, 161#176, #, 161#178, 161#181, 161#, 186#184, 186#185, #, 186#184, #, 80#186, 196#190, 196#191, #, 196#190, #, 196#192, 186#196, 80#196, #, #, 186#197, #, 186#199, #, 186#201, #, 186#203, 186#206, 186#, 211#209, 211#210, #, 211#209, #, 80#211, 221#215, 221#216, #, 221#215, #, 221#217, 211#221, 80#221, #, #, 211#222, #, 211#224, #, 211#226, #, 211#228, 211#231, 211#, 236#234, 236#235, #, 236#234, #, 80#236, 246#240, 246#241, #, 246#240, #, 246#242, 236#246, 80#246, #, #, 236#247, #, 236#249, #, 236#251, #, 236#253, 236#256, 236#, 261#259, 261#260, #, 261#259, #, 80#261, 271#265, 271#266, #, 271#265, #, 271#267, 261#271, 80#271, #, #, 261#272, #, 261#274, #, 261#276, #, 261#278, 261#281, 261#, 286#284, 286#285, #, 286#284, #, 80#286, 296#290, 296#291, #, 296#290, #, 296#292, 286#296, 80#296, #, #, 286#297, #, 286#299, #, 286#301, #, 286#303, 286#306, 286#, 311#309, 311#310, #, 311#309, #, 80#311, 321#315, 321#316, #, 321#315, #, 321#317, 311#321, 80#321, #, #, 311#322, #, 311#324, #, 311#326, #, 311#328, 311#331, 311#, 336#334, 336#335, #, 336#334, #, 80#336, 346#340, 346#341, #, 346#340, #, 346#342, 336#346, 80#346, #, #, 336#347, #, 336#349, #, 336#351, #, 336#353, 336#356, 336#, 361#359, 361#360, #, 361#359, #, 80#361, 371#365, 371#366, #, 371#365, #, 371#367, 361#371, 80#371, #, #, 361#372, #, 361#374, #, 361#376, #, 361#378, 361#381, 361#, 386#384, 386#385, #, 386#384, #, 80#386, 396#390, 396#391, #, 396#390, #, 396#392, 386#396, 80#396, #, #, 386#397, #, 386#399, #, 386#401, #, 386#403, 386#406, 386#, 411#409, 411#410, #, 411#409, #, 80#411, 421#415, 421#416, #, 421#415, #, 421#417, 411#421, 80#421, #, #, 411#422, #, 411#424, #, 411#426, #, 411#428, 411#431, 411#, 436#434, 436#435, #, 436#434, #, 80#436, 446#440, 446#441, #, 446#440, #, 446#442, 436#446, 80#446, #, #, 436#447, #, 436#449, #, 436#451, #, 436#453, 436#456, 436#, 461#459, 461#460, #, 461#459, #, 80#461, 471#465, 471#466, #, 471#465, #, 471#467, 461#471, 80#471, #, #, 461#472, #, 461#474, #, 461#476, #, 461#478, 461#481, 461#, 486#484, 486#485, #, 486#484, #, 80#486, 496#490, 496#491, #, 496#490, #, 496#492, 486#496, 80#496, #, #, 486#497, #, 486#499, #, 486#501, #, 486#503, 486#506, 486#, 511#509, 511#510, #, 511#509, #, 80#511, 521#515, 521#516, #, 521#515, #, 521#517, 511#521, 80#521, #, #, 511#522, #, 511#524, #, 511#526, #, 511#528, 511#531, 511#, 536#534, 536#535, #, 536#534, #, 80#536, 546#540, 546#541, #, 546#540, #, 546#542, 536#546, 80#546, #, #, 536#547, #, 536#549, #, 536#551, #, 536#553, 536#556, 536#, 561#559, 561#560, #, 561#559, #, 80#561, 571#565, 571#566, #, 571#565, #, 571#567, 561#571, 80#571, #, #, 561#572, #, 561#574, #, 561#576, #, 561#578, 561#581, 561#, 586#584, 586#585, #, 586#584, #, 80#586, 596#590, 596#591, #, 596#590, #, 596#592, 586#596, 80#596, #, #, 586#597, #, 586#599, #, 586#601, #, 586#603, 586#606, 586#, 611#609, 611#610, #, 611#609, #, 80#611, 621#615, 621#616, #, 621#615, #, 621#617, 611#621, 80#621, #, #, 611#622, #, 611#624, #, 611#626, #, 611#628, 611#631, 611#, 636#634, 636#635, #, 636#634, #, 80#636, 646#640, 646#641, #, 646#640, #, 646#642, 636#646, 80#646, #, #, 636#647, #, 636#649, #, 636#651, #, 636#653, 636#656, 636#, 661#659, 661#660, #, 661#659, #, 80#661, 671#665, 671#666, #, 671#665, #, 671#667, 661#671, 80#671, #, #, 661#672, #, 661#674, #, 661#676, #, 661#678, 661#681, 661#, 686#684, 686#685, #, 686#684, #, 80#686, 696#690, 696#691, #, 696#690, #, 696#692, 686#696, 80#696, #, #, 686#697, #, 686#699, #, 686#701, #, 686#703, 686#706, 686#, 711#709, 711#710, #, 711#709, #, 80#711, 721#715, 721#716, #, 721#715, #, 721#717, 711#721, 80#721, #, #, 711#722, #, 711#724, #, 711#726, #, 711#728, 711#731, 711#, 736#734, 736#735, #, 736#734, #, 80#736, 746#740, 746#741, #, 746#740, #, 746#742, 736#746, 80#746, #, #, 736#747, #, 736#749, #, 736#751, #, 736#753, 736#756, 736#, 761#759, 761#760, #, 761#759, #, 80#761, 771#765, 771#766, #, 771#765, #, 771#767, 761#771, 80#771, #, #, 761#772, #, 761#774, #, 761#776, #, 761#778, 761#781, 761#, #, 788#782, #, 788#784, 788#787, 788#, 111#136, 80#788, #, 796#790, #, 796#792, 796#795, 796#, 111#161, 80#796, #, 804#798, #, 804#800, 804#803, 804#, 111#286, 80#804, #, 812#806, #, 812#808, 812#811, 812#, 161#186, 80#812, #, 820#814, #, 820#816, 820#819, 820#, 161#211, 80#820, #, 828#822, #, 828#824, 828#827, 828#, 161#236, 80#828, #, 836#830, #, 836#832, 836#835, 836#, 161#261, 80#836, #, 844#838, #, 844#840, 844#843, 844#, 286#311, 80#844, #, 852#846, #, 852#848, 852#851, 852#, 286#336, 80#852, #, 860#854, #, 860#856, 860#859, 860#, 286#361, 80#860, #, 868#862, #, 868#864, 868#867, 868#, 286#386, 80#868, #, 876#870, #, 876#872, 876#875, 876#, 286#411, 80#876, #, 884#878, #, 884#880, 884#883, 884#, 286#436, 80#884, #, 892#886, #, 892#888, 892#891, 892#, 286#461, 80#892, #, 900#894, #, 900#896, 900#899, 900#, 286#561, 80#900, #, 908#902, #, 908#904, 908#907, 908#, 286#636, 80#908, #, 916#910, #, 916#912, 916#915, 916#, 461#486, 80#916, #, 924#918, #, 924#920, 924#923, 924#, 461#511, 80#924, #, 932#926, #, 932#928, 932#931, 932#, 461#536, 80#932, #, 940#934, #, 940#936, 940#939, 940#, 561#586, 80#940, #, 948#942, #, 948#944, 948#947, 948#, 561#611, 80#948, #, 956#950, #, 956#952, 956#955, 956#, 636#661, 80#956, #, 964#958, #, 964#960, 964#963, 964#, 636#686, 80#964, #, 972#966, #, 972#968, 972#971, 972#, 636#711, 80#972, #, 980#974, #, 980#976, 980#979, 980#, 636#736, 80#980, #, 988#982, #, 988#984, 988#987, 988#, 636#761, 80#988, 24#991, #, 24#993, #, 24#995, #, 995#997, #, 995#999, #, 995#1001, #, 8#1003, #, 1003#1005, #, 1003#1007, #, #1016, 42#1010, #, #, 42#1011, #, 42#1013, 24#1016, #, 1016#1018, #, #, 1016#1019, #, 1016#1021, 1016#1024, #, 999#1026, #, 1024#1028, #, 1028#1030, #, #, 1028#1031, #, 1028#1033, 1028#1036, #, 1024#1038, #, 1024#1040, #, 1024#1042, #, 1005#1044, #, 2#1046, #, 1046#1048, #, 1048#1050, #, 1048#1052, #, 1048#1054, #, 1048#1056, #, 1048#1058, #, #1048, #, 1054#1060, 1054#, #, 1056#1063, 1056#, 1048#1067, #, 1016#1069, #, 1069#1071, #, 24#1073, #, 1073#1075, #, 1073#1077, #, 1077#1079, #, 1077#1081, #, 1079#1083, #, 1077#1085, #, #, 1073#1086, #, 1073#1088, 1073#1091, #, #, #, 1091#1095, #, 1091#1097, #, 1073#1099, #, #, #, 1091#1103, #, #, 1091#1106, #, 58#1108, #, 1108#, 58#1111, #, 1111#, 58#1114, #, 1114#, 58#1117, #, 1117#, 58#1120, #, 1120#, #52, 58#1124, #, 1124#, 58#1127, #, 1127#, 58#1130, #, 1130#, 58#1133, #, 1133#, 58#1136, #, 1136#, 24#1139, #, 1139#1141, #, 1139#1143, #, 1139#1145, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, 1145#1172, #, #, #, 1145#1176, #, 1145#1178, #, 1145#1180, #, 1145#1182, #, 1145#1184, #, #, #, #, #, #, #, 1139#1190, #, 1139#1192, 24#1195, #, 1195#1197, #, 1195#1199, #, #, 1195#1200, #, 1195#1202, 24#1205, #, 1205#1207, #, 1207#1209, #, 1205#1211, #, #, 1205#1212, #, 1205#1214, 1207#1217, #, 1091#1219, #, 1091#1221, #, 1207#1223, #, 1207#1225, #, 1207#1227, #, 18#1229, #, 1229#1231, #, 1229#1233, #, 1229#1235, #, 1231#1237, #, 1231#1239, #, 1231#1241, #, 1231#1243, #, #, 1237#1244, 1237#, #, 1239#1247, 1239#, #, 1241#1250, 1241#, #, 1243#1253, 1243#, 1231#1257, #, #, 1257#1258, 1257#, 1229#1262, #, 1262#1264, #, 1231#1266, #, 1266#, 1231#1269, #, 1269#, 1231#1272, #, 1272#, 1231#1275, #, 1275#, 1231#1278, #, 1278#, 1231#1281, #, 1281#, 1231#1284, #, 1231#1286, #, #, 1284#1287, 1284#, #, 1286#1290, 1286#, #, 1233#1293, #, 1233#1295, #, 1233#1297, #, 1233#1299, #, 1233#1301, #, 1301#1303, 1301#1306, 1303#1307, #, 1301#1307, 1301#1310, 1307#1311, #, 1301#1311, 1301#1314, 1311#1315, #, 1301#1315, 1301#1318, 1315#1319, #, 1301#1319, 1301#1322, 1319#1323, #, 1301#1323, #, 1323#1325, #, 1323#1327, #, 1311#1329, #, 1311#1331, #, 1299#1333, 1299#1336, 1333#1337, #, 1299#1337, 1299#1340, 1337#1341, #, 1299#1341, 1299#1344, 1341#1345, #, 1299#1345, #, 1345#1347, #, 1345#1349, #, 1345#1351, #, 1345#1353, #, 1345#1355, #, 1345#1357, #, 1341#1359, #, 1341#1361, #, 1341#1363, #, 1341#1365, #, 1341#1367, #, 1341#1369, #, 1297#1371, 1297#1374, 1371#1375, #, 1297#1375, 1297#1378, 1375#1379, #, 1297#1379, 1297#1382, 1379#1383, #, 1297#1383, 1297#1386, 1383#1387, #, 1297#1387, 1297#1390, 1387#1391, #, 1297#1391, 1297#1394, 1391#1395, #, 1297#1395, 1297#1398, 1395#1399, #, 1297#1399, #, 1399#1401, #, 1399#1403, #, 1399#1405, #, 1399#1407, #, 1399#1409, #, 1399#1411, #, 1391#1413, #, 1391#1415, #, 1391#1417, #, 1391#1419, #, 1391#1421, #, 1391#1423, #, 1383#1425, #, 1383#1427, #, 1383#1429, #, 1383#1431, #, 1383#1433, #, 1383#1435, #, 1379#1437, #, 1379#1439, #, 1379#1441, #, 1379#1443, #, 1379#1445, #, 1379#1447, #, 1295#1449, 1295#1452, 1449#1453, #, 1295#1453, 1295#1456, 1453#1457, #, 1295#1457, 1295#1460, 1457#1461, #, 1295#1461, 1295#1464, 1461#1465, #, 1295#1465, 1295#1468, 1465#1469, #, 1295#1469, 1295#1472, 1469#1473, #, 1295#1473, 1295#1476, 1473#1477, #, 1295#1477, 1295#1480, 1477#1481, #, 1295#1481, 1295#1484, 1481#1485, #, 1295#1485, 1295#1488, 1485#1489, #, 1295#1489, 1295#1492, 1489#1493, #, 1295#1493, #, 1489#1495, #, 1489#1497, #, 1469#1499, #, 1469#1501, #, 1465#1503, #, 1465#1505, #, 1457#1507, #, 1457#1509, #, 1293#1511, 1233#1514, 1295#1297, 1233#1516, 1297#1299, 1233#1518, 1299#1301, #, 1235#1519, #, 60#1521, #, 60#1523, #, 1523#1525, 1523#1528, 1525#1529, #, 1523#1529, 1523#1532, 1529#1533, #, 1523#1533, 1523#1536, 1533#1537, #, 1523#1537, 1523#1540, 1537#1541, #, 1523#1541, 1523#1544, 1541#1545, #, 1523#1545, 1523#1548, 1545#1549, #, 1523#1549, #, 1549#1551, #, 1549#1553, #, 1549#1555, #, 1549#1557, #, 1549#1559, #, 1545#1561, #, 1545#1563, #, 1545#1565, #, 1545#1567, #, 1545#1569, #, 1545#1571, #, 1541#1573, #, 1541#1575, #, 1541#1577, #, 1541#1579, #, 1541#1581, #, 1541#1583, #, 1537#1585, #, 1537#1587, #, 1537#1589, #, 1537#1591, #, 1537#1593, #, 1537#1595, #, 1533#1597, #, 1533#1599, #, 1533#1601, #, 1533#1603, #, 1533#1605, #, 1533#1607, #, 1529#1609, #, 1529#1611, #, 1529#1613, #, 1529#1615, #, 1529#1617, #, 1529#1619, #, 1521#1621, #, 62#1623, 18#1626, #, 1626#1628, #, 1628#1630, #, 1630#, 1626#1633, #, 1626#1635, #, #, 1633#1636, #, 1633#1638, #, 1633#1640, #, 1640#1642, 1640#1645, 1642#1646, #, 1640#1646, #, 1646#1648, #, 1646#1650, #, 1646#1652, #, 1646#1654, #, 1646#1656, #, 1638#1658, #, 1635#1660, 24#1663, #, #, #, #, #, 1672#1664, 1672#1665, 1672#1666, 1672#1667, #, 1663#1672, 1672#1675, #, 1675#1677, #, 1675#1679, #, 1675#1681, #, 1675#1683, #, 1675#1685, #, 1675#1687, #, 1675#1689, #, 1199#1691, #, 1199#1693, #, 1207#1695, #, 2#1697, #, 1697#1699, #, 1699#, 1699#1702, #, 1699#1704, #, 1699#1706, #, 1699#1708, #, #1697, #, 1702#1710, 1702#, #, 1710#1713, #, 1704#1715, 1704#, #, 1706#1718, 1706#, #, 1710#1721, #, 1710#1723, #, 1708#1725, 1708#, 1699#1729, #, 1699#1731, #, #, 1729#1732, 1729#, 1699#1736, #, #, 1731#1737, 1731#, #, 1736#1740, 1736#, 1699#1744, #, #, 1744#1745, 1744#, 1697#1749, #, 1697#1751, #, 1751#, 1751#1754, #, 1751#1756, #, 1751#1758, #, 1751#1760, #, 1751#1762, #, 1751#1764, #, 1751#1766, #, 1751#1768, #, #, 1756#1769, 1756#, #, 1758#1772, 1758#, #, 1760#1775, 1760#, #, 1762#1778, 1762#, 1697#1782, #, 1697#1784, #, 1663#1786, #, 1786#, 1786#1789, #, 1786#1791, #, #1800, #, 1786#1793, #, 1786#1795, 1697#1798, #, 1798#1800, #, 1016#1802, #, 1791#1804, #, 1791#1806, #, 1048#1808, #, 1048#1810, #, 1048#1812, #, #, 1058#1813, 1058#, #, 1808#1816, 1808#, #, 1810#1819, 1810#, 1048#1823, #, 1048#1825, #, #, 1812#1826, 1812#, #, 1823#1829, 1823#, #, 1825#1832, 1825#, 1048#1836, #, 1048#1838, #, 1048#1840, #, #, 1836#1841, 1836#, 1048#1845, #, #, 1845#1846, 1845#, #, 1838#1849, 1838#, #, 1840#1852, 1840#, 1048#1856, #, 1048#1858, #, #, 1856#1859, 1856#, #, 1858#1862, 1858#, #, 1826#1865, #, 1826#1867, #, 1829#1869, #, 1829#1871, 1048#1874, #, #, 1874#1875, 1874#, #, 1846#1878, #, 1846#1880, #, 1832#1882, #, 1832#1884, 1016#1887, #, 1207#1889, #, 1207#1891, #, 1016#1893, #, 1893#1895, #, 1895#1897, #, 1207#1899, #, 1895#1901, #, 1895#1903, #, 1207#1905, #, 2#1907, #, 1907#1909, #, 1907#1911, #, 1907#1913, #, 1907#1915, #, 1907#1917, #, 1915#1919, #, 1917#1921, #, 1917#1923, #, 1207#1925, #, #, 1207#1926, #, 1207#1928, 1889#1931, #, #, 1889#1932, #, 1889#1934, 1695#1937, #, 1899#1939, #, #, 1899#1940, #, 1899#1942, 1905#1945, #, #, 1905#1946, #, 1905#1948, 1199#1951, #, #, 1199#1952, #, 1199#1954, 1691#1957, #, #, 1691#1958, #, 1691#1960, 1143#1963, #, #, 1143#1964, #, 1143#1966, 1145#1969, #, #, 1145#1970, #, 1145#1972, 
### 内容
#0, 16:
文档/项目/pySEM.ftxt
## end
#2, 256:
+[返回目录](,pySEM)
地址::文档/项目/pySEM.ftxt

操作:...
+[设置动词](,操作)
+[新建阅读窗口](,操作)

Nini, 打开电透镜(文件)
Nini, 打开像素矩阵(文件)

笔记:...
测试代码:...
zz代码:...
readme:...
架构:...
+[新建阅读窗口](,笔记)
+[新建阅读窗口](,readme)
+[新建阅读窗口](,测试代码)

测试场:...
测试电子源:...
+[新建阅读窗口](,测试场)
+[新建阅读窗口](,测试电子源)


## end
#3, 49:
pySEM:...
创建于 20230607

节点数目统计::
+[设置结构](,节点数目统计)
## end
#8, 58:
Nini, 打开动词(库)

上传pySEM:...
保存P函数_del:...
+[复制结构](,保存P函数)


## end
#10, 379:
"""
命令行:...
命令行1:...
命令行2:...

地址::/home/xiantao/Documents/Projects/py-sem
网址::https://gitee.com/zz303/py-sem
+[打开文件夹](,地址)

"""
+上传pySEM->+[del](,+上传pySEM)...
->的(上传pySEM,地址)->的(上传pySEM,网址)->的(上传pySEM,命令行)...

->+[打开文件夹](,地址)...
->+[模板文本](命令行,+[临时文本])->+[.]"地址"(+[模板文本],地址)...
    ->+[.]"注释"(+[模板文本],+[临时文本]#注释)...
    ->[m_text](+上传pySEM,+[临时文本]#注释)...
->+[命令行](,+[临时文本])






## end
#12, 39:
/home/xiantao/Documents/Projects/py-sem
## end
#14, 85:
cd %地址;git add --all;git commit -m "%注释";git pull --rebase;git rebase --skip;git push
## end
#16, 30:
https://gitee.com/zz303/py-sem
## end
#18, 130:
地址::/home/xiantao/Documents/Projects/py-sem
网址::https://gitee.com/zz303/py-sem
+[打开文件夹](,地址)
+[打开网页](,网址)

log:...

20230701:...


## end
#20, 39:
/home/xiantao/Documents/Projects/py-sem
## end
#22, 30:
https://gitee.com/zz303/py-sem
## end
#24, 634:
地址::/home/xiantao/Documents/Projects/py-sem
网址::https://gitee.com/zz303/py-sem
+[打开文件夹](,地址)
+[上传pySEM]"update unit_test.stepper"


column:...
tools:...
+[新建阅读窗口](,tools)

elements:...
space:...
在选择区域中, 将'space'的"B"替换为"E"
+[新建阅读窗口](,elements)
+[新建阅读窗口](,space)

stepper:...
tracks:...
在选择区域中, 将'stepper'的"f_6"替换为"self.m_fs[5]"
+[新建阅读窗口](,stepper)
+[新建阅读窗口](,tracks)

hevean:...
+[新建阅读窗口](,hevean)
tools=>的(tools,_代码)->[]{的(_代码,地址)}=>+[P函数](,_代码)
测试代码=>的(测试代码,_代码)->[]{的(_代码,地址)}=>+[P函数](,_代码)

tools=>的(tools,_代码)->[]{的(_代码,地址)}=>+[保存P函数](,_代码)
测试代码=>的(测试代码,_代码)->[]{的(_代码,地址)}=>+[保存P函数](,_代码)


测试package:...
+[新建阅读窗口](,测试package)



## end
#26, 16521:
"""
+[保存P函数](,column)
+[P函数](,column)
pyvista:...
bempp:...
show()
样本1:...
保存:...

"""

import numpy as np
from numpy.polynomial.polynomial import polyval2d, polyder
from numpy.polynomial.hermite import hermfit, hermval, hermder

import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle

import pandas as pd

from scipy.interpolate import UnivariateSpline, InterpolatedUnivariateSpline
from scipy.optimize import minimize_scalar
from scipy.optimize import curve_fit
from scipy.interpolate import CloughTocher2DInterpolator
from scipy.integrate import solve_ivp, trapezoid, quad

from functools import partial

import pyvista as pv
# from pyvistaqt import BackgroundPlotter

import sys
sys.path.append('.')

import os
path = r'C:\Program Files\ParaView 5.11.0\bin'
os.environ["PATH"] = os.environ["PATH"]+';'+path

import bempp.api
from bempp.api.operators.potential import laplace

# bempp.api.PLOT_BACKEND = "gmsh"
bempp.api.PLOT_BACKEND = "paraview"


#%%
class Geometry(object):
    
    def __init__(self):        
        xmin = -15
        xmax = 15
        ymin = 0
        ymax = 20
        
        num_electrode = 3
        thk = [2, 6, 2]
        gap = [4, 4]
        hole = [2, 3, 2] 
        z = 0
                
        pts_y_bc = np.unique(hole + [ymin, ymax])
        points_left = np.ones([len(pts_y_bc),3])*xmin
        points_left[:,1] = pts_y_bc
        points_left[:,2] = z
        
        points_right = np.ones([len(pts_y_bc),3])*xmax
        points_right[:,1] = pts_y_bc[::-1]
        points_right[:,2] = z
        
        left_bc = -(sum(thk) + sum(gap))/2
        right_bc = (sum(thk) + sum(gap))/2
        pos_electrodes = np.ones([num_electrode,2])*left_bc
        for i in np.arange(num_electrode-1):
            pos_electrodes[i,1] = pos_electrodes[i,0] + thk[i]
            pos_electrodes[i+1,0] = pos_electrodes[i,1] + gap[i]
        pos_electrodes[-1,1] = right_bc  

        self.num_electrode = num_electrode        
        self.electrodes = pos_electrodes
        self.thk = thk
        self.hole = hole
        self.rmax = ymax

        
#%%
class Lens(object):
    
    def __init__(self, name, dim=2, sym=1):
        super(Lens, self).__init__()
        
        self.name = name
        self.dim = dim    # dimension
        self.sym = sym    # 0-no symmetry, 1-rotation symmetry
        self.z_lim = []       
        self.position = 0
        
        self.geo = Geometry()

        self.unit_potentials_vtk = []               # e.g. [101, 010]
        self.unit_potentials_fit = []               # e.g. [101, 010]
        self.electrode_potentials = []          # e.g. [5000, 8000]        
        
        self.unit_data_all_vtk = dict()      # vtk results
        self.unit_data_all_vtk_grad = dict()      # vtk results
        self.unit_data_all_grid = dict()    # fem results on mesh grids
               
        self.unit_coeff_fit_all = dict()  # coefficients of the field


    def view_geo(self, rel_pos = True, fig_num = None, edgecolor = 'blue', facecolor = 'blue', lw=1):
        scale = 1.5
        plt.figure(fig_num)
        for i in np.arange(self.geo.num_electrode):
            plt.gca().add_patch(Rectangle((self.geo.electrodes[i][0] + self.position*rel_pos, -self.geo.rmax), self.geo.thk[i], self.geo.rmax - self.geo.hole[i],
                         edgecolor = edgecolor, facecolor = facecolor, fill=True, lw=lw))
            plt.gca().add_patch(Rectangle((self.geo.electrodes[i][0] + self.position*rel_pos, self.geo.rmax), self.geo.thk[i], - (self.geo.rmax - self.geo.hole[i]),
                         edgecolor = edgecolor, facecolor = facecolor, fill=True, lw=lw))
        plt.xlim((self.geo.electrodes.min()*scale + self.position*rel_pos, self.geo.electrodes.max()*scale + self.position*rel_pos))
        plt.ylim((-self.geo.rmax*scale, self.geo.rmax*scale))
        plt.xlabel('[mm]')
        plt.ylabel('[mm]')
        plt.title('geometry of ' + self.name)
        plt.show()
        
        
    def import_data_vtk(self, filename, unit_potentials):       
        vtk_data = pv.read(filename + '.vtk')
        results = pd.DataFrame()
        results['phi'] = vtk_data.point_data["phi"]
        results['z'] = vtk_data.points[:,0]
        results['r'] = vtk_data.points[:,1]
        self.unit_data_all_vtk[unit_potentials] = vtk_data
        self.unit_data_all_vtk_grad[unit_potentials] = vtk_data.compute_derivative(scalars="phi")

        self.unit_data_all_grid[unit_potentials] = results
        if unit_potentials not in self.unit_potentials_vtk:
            self.unit_potentials_vtk.append(unit_potentials)
               
            
    def view_vtk(self, unit_potentials = None):   
        if unit_potentials == None:
            keys = self.unit_data_all_vtk.keys()
        else:
            keys = unit_potentials
            
        pv.global_theme.multi_rendering_splitting_position = 0.35

        for key in keys:
            plotter = BackgroundPlotter(shape='1/2')
            plotter.subplot(2)
            plotter.add_mesh(self.unit_data_all_vtk[key], scalars='phi', show_scalar_bar=True, cmap='jet')
            plotter.add_mesh(self.unit_data_all_vtk[key].contour(), color = 'white')
            plotter.add_text(self.name + ":  " + key + " unit potential [V]")
            
            plotter.subplot(1)
            plotter.add_mesh(self.unit_data_all_vtk[key], scalars='phi', show_edges=True, show_scalar_bar=True, cmap='jet', opacity=1)
            plotter.add_text("mesh")

            plotter.subplot(0)
            plotter.add_mesh(self.unit_data_all_vtk_grad[key], scalars='gradient', show_scalar_bar=True, cmap='jet', clim = None)
            plotter.add_text("unit electrical field [V/mm]")
        
            plotter.link_views()
            plotter.camera_position = 'xy'        
            plotter.show()        


    def import_data_fit_coeff(self, filename, unit_potentials, order_spline = 5, method = 'spline'):
        df = pd.read_csv(filename + '.csv')
        z_points = df.values[:,0]
        coeff = df.values[:,1:]                 
        
        r_order = (coeff.shape[1]-1)*2        
        
        coeff_fn_fit = []
        for kk in np.arange(r_order/2+1):
            if method == 'spline':
                spl = InterpolatedUnivariateSpline(z_points, coeff[:,[int(kk)]], k = order_spline)
                coeff_fn_fit.append(spl)
                # plt.figure()
                # plt.plot(z_points,coeff_fn_fit[int(kk)](z_points),'r')
                # plt.plot(z_points,coeff[:,[int(kk)]],'.')                    
            elif method == 'bspline':
                pass
            elif method == 'hermite':
                c, stats = hermfit(z_points, coeff[:,[int(kk)]], deg = 50, full=True)
                coeff_fn_fit.append(c)
        
        self.unit_coeff_fit_all[unit_potentials] = coeff_fn_fit

        if unit_potentials not in self.unit_potentials_fit:
            self.unit_potentials_fit.append(unit_potentials)


    def calc_unit_phi_fit_results(self, zz, rr, unit_potentials, method = 'spline'):
        phi = np.zeros(zz.shape)
        dphi_dz = np.zeros(zz.shape)
        dphi_dr = np.zeros(zz.shape)            
        r_order = (len(self.unit_coeff_fit_all[unit_potentials])-1)*2
        
        unit_potential_fit_coeff = self.unit_coeff_fit_all[unit_potentials]
        for i in np.arange(r_order/2+1):       
            if method == 'spline' or 'bspline':
                func = unit_potential_fit_coeff[int(i)]
                phi += func(zz)*(rr)**(2*i)
                dphi_dz += func.derivative(n=1)(zz)*(rr)**(2*i)
                dphi_dr += func(zz)*(2*i)*(rr)**(2*i-1)*(np.sign(2*i-1)+1)/2               
            elif method == 'hermite':
                coeff = unit_potential_fit_coeff[int(i)]
                phi += hermval(zz, coeff)*(rr)**(2*i)
                dphi_dz += hermval(zz, hermder(coeff, m=1))*(rr)**(2*i)
                dphi_dr += hermval(zz, coeff)*(2*i)*(rr)**(2*i-1)*(np.sign(2*i-1)+1)/2            
    
        return phi, dphi_dz, dphi_dr
    

    def view_field(self, zz, rr, fig_num = None):
        phi_all = np.zeros(zz.shape)
        dphi_dz_all = np.zeros(zz.shape)
        dphi_dr_all = np.zeros(zz.shape)            
        
        for key in self.unit_potentials_fit:     
            phi, dphi_dz, dphi_dr = self.calc_unit_phi_fit_results(zz=zz, rr=rr, unit_potentials = key)
            phi_all += phi * self.electrode_potentials[key]
            dphi_dz_all += dphi_dz * self.electrode_potentials[key]
            dphi_dr_all += dphi_dr * self.electrode_potentials[key]                        
            # plt.figure(fig_num)
            # fig_num+=1
            # plt.pcolormesh(zz,rr,phi)
            # plt.title(key)
            
        plt.figure(fig_num)
        plt.subplot(1,3,1)
        plt.pcolormesh(zz, rr, phi_all, shading='auto', cmap='jet')
        plt.pcolormesh(zz, -rr, phi_all, shading='auto', cmap='jet')            
        plt.colorbar()
        plt.xlabel('z [mm]')
        plt.ylabel('r [mm]')
        plt.title('phi [V]')
    
        plt.subplot(1,3,2)
        plt.pcolormesh(zz, rr, dphi_dz_all, shading='auto', cmap='jet')
        plt.pcolormesh(zz, -rr, dphi_dz_all, shading='auto', cmap='jet')            
        plt.colorbar()
        plt.xlabel('z [mm]')
        plt.ylabel('r [mm]')
        plt.title('dphi/dz [V/mm]')
    
        plt.subplot(1,3,3)
        plt.pcolormesh(zz, rr, dphi_dr_all, shading='auto', cmap='jet')
        plt.pcolormesh(zz, -rr, dphi_dr_all, shading='auto', cmap='jet')            
        plt.colorbar()
        plt.xlabel('z [mm]')
        plt.ylabel('r [mm]')
        plt.title('dphi/dr [V/mm]')
    
        plt.show()        

    
            
#%%                        
class Deflector(object):
    
    def __init__(self, name):
        super(Deflector, self).__init__()
    
        self.name = name
        self.dflt_num = 0
        self.dflt_angles = []
        self.dflt_r = 5
        self.dflt_z_min = 0
        self.dflt_z_max = 10
                
        self.position = 0

        self.volts = []
        
    def geo_init_angle(self, dflt_num, fill_factor):
        self.dflt_num = dflt_num
        factor_fill = fill_factor
        
        dflt_angle = 2*np.pi/self.dflt_num * factor_fill
        dflt_angle_deg = dflt_angle/np.pi*180
        
        gap_angle = 2*np.pi/self.dflt_num * (1-factor_fill)
        gap_angle_deg = gap_angle/np.pi*180
        
        start_angle = -dflt_angle/2
        start_angle_deg = start_angle/np.pi*180

        ## deflectors,(start angle, end angle) of each electrodes
        self.dflt_angles = np.zeros([self.dflt_num, 2])
        self.dflt_angles[0,0] = start_angle
        for i in np.arange(self.dflt_num-1):
            self.dflt_angles[i,1] = self.dflt_angles[i,0] + dflt_angle
            self.dflt_angles[i+1,0] = self.dflt_angles[i,1] + gap_angle
        self.dflt_angles[-1,1] = self.dflt_angles[-1,0] + dflt_angle
        
    
    def view_geo(self, axis = 'xy', rel_pos = True, fig_num = None, color = 'k', lw=2): 
        plt.figure(fig_num)
        if axis == 'xy':
            ## plot deflectors
            for i in np.arange(self.dflt_num):
                t = np.linspace(self.dflt_angles[i,0], self.dflt_angles[i,1],100);
                plt.plot(np.cos(t), np.sin(t),'r');
            plt.axis('equal')
        elif axis == 'rz':
            plt.plot([self.dflt_z_min+self.position*rel_pos, self.dflt_z_max+self.position*rel_pos], [self.dflt_r, self.dflt_r], color = color, lw = lw)
            plt.plot([self.dflt_z_min+self.position*rel_pos, self.dflt_z_max+self.position*rel_pos], [-self.dflt_r, -self.dflt_r], color = color, lw = lw)
        
            
    def load_results(self, input_file):
        grid = bempp.api.import_grid(input_file+'.msh')
        space = bempp.api.function_space(grid, "DP", 0)
    
        output_file = input_file+'_res'
        rhs_coeff = np.loadtxt(open(output_file+'_coeff_rhs.csv', 'rb'), delimiter=',', skiprows=0)
        sol_coeff = np.loadtxt(open(output_file+'_coeff_sol.csv', 'rb'), delimiter=',', skiprows=0)
    
        rhs_load = bempp.api.GridFunction(space, coefficients = rhs_coeff)
        sol_load = bempp.api.GridFunction(space, coefficients = sol_coeff)
    
        return grid, space, rhs_load, sol_load        


    def view_bem(self, grid=None, rhs=None, sol=None):
        if grid != None:
            grid.plot()    
        if rhs != None:
            rhs.plot()
        if sol != None:
            sol.plot()


    def load_fit3d_results(self, input_file, order_spline):
        # read fit results from files
        output_file = input_file+'_res'        
        df = pd.read_csv(output_file+'_sol_fit.csv')
        z_list = df.values[:,0]
        data = df.values[:,1:]                 
        header = df.columns
        
        order = int((header.size-1)**0.5)-1
        
        mmm = np.zeros([order+1, order+1, len(z_list)])
        volt_fit_func = np.empty((order+1, order+1), dtype=object)
        kl = 0
        
        for i in range(order+1):
            for j in range(order+1):
                mmm[i,j,:] = data[:, kl]
                volt_fit_func[i,j] = InterpolatedUnivariateSpline(z_list, mmm[i,j,:], k = order_spline)
                kl += 1
                
        self.volt_fit_func = volt_fit_func


    def view_field_slice(self, z, grid_ctr, fig_num = None):
        tmp = self.volt_fit_func.shape[0]
        mm_fit = np.zeros([tmp,tmp])
        for i in range(tmp):
            for j in range(tmp):
                mm_fit[i,j] = self.volt_fit_func[i,j](z)
        
        vv_all_fit = polyval2d(grid_ctr[0], grid_ctr[1], mm_fit)
        
        plt.figure(fig_num)
        plt.pcolormesh(grid_ctr[0], grid_ctr[1], vv_all_fit, shading='auto', cmap='jet',clim=None)
        plt.colorbar()
        plt.xlabel('x [mm]')
        plt.ylabel('y [mm]')
        plt.title('deflector fit results loading: phi [V]')
        plt.show()
        


#%%        
class Aperture(object):

    def __init__(self, name, r_hole = 0):
        super(Aperture, self).__init__()
        self.name = name
        self.r_hole = r_hole
        self.position = 0
        self.rmax = 20

    def view_geo(self, rel_pos = True, fig_num = None, color = 'k', lw=2):
        plt.figure(fig_num)
        plt.plot([self.position, self.position] * rel_pos, [self.r_hole, self.rmax], color = color, lw = lw)
        plt.plot([self.position, self.position] * rel_pos, [-self.r_hole, -self.rmax], color = color, lw = lw)
        plt.xlabel('z [mm]')
        plt.ylabel('r [mm]')
        plt.show()
                
            
#%%          
class Column(object):
    
    def __init__(self, name):
        self.name = name
        self.lenses = []
        self.deflectors = []
        self.apertures = []
        
        self.source = []
        self.crosses = []
        self.screen = []
        
        self.v_source = []
        
        self.traj_func = []
        
        self.axial_pot_func = []
        
        
    def add_lens(self, lens, pos):
        self.lenses.append(lens)
        lens.position = pos


    def add_aperture(self, aperture, pos):
        self.apertures.append(aperture)
        aperture.position = pos


    def add_deflectors(self, deflector, pos):
        self.deflectors.append(deflector)
        deflector.position = pos


    def view_geo(self, fig_num = None, edgecolor = 'blue', facecolor = 'blue', color_dflt = 'r', color_aper = 'k', lw=1):
        scale = 1.1
        for lens in self.lenses:     
            lens.view_geo(fig_num = fig_num, edgecolor = edgecolor, facecolor = facecolor, lw=lw)
        # plt.xlim((self.lenses[0].geo.electrodes.min()*scale + self.lenses[0].position, self.lenses[-1].geo.electrodes.max()*scale + self.lenses[-1].position))
        plt.xlim(self.source*scale, self.screen*scale)
        
        plt.plot(self.source, 0, 'k+')
        plt.plot(self.screen, 0, 'k+')
        plt.plot(self.crosses, np.zeros(len(self.crosses)), 'kx')
        
        for aperture in self.apertures:
            aperture.view_geo(fig_num = fig_num, color = color_aper, lw=2*lw)

        for deflector in self.deflectors:
            deflector.view_geo(axis = 'rz', fig_num = fig_num, color = color_dflt, lw=2*lw)
        
        plt.xlabel('z [mm]')
        plt.ylabel('r [mm]')
#        plt.axis('equal')     
        plt.title('geometry of ' + self.name)   



"""
+[P函数](,column)

保存:
测试场景:...
+[新建阅读窗口](,测试场景)

"""
## end
#28, 19256:
"""
+[P函数](,样本1)

"""

import numpy as np
from numpy.polynomial.polynomial import polyval2d, polyder
from numpy.polynomial.hermite import hermfit, hermval, hermder

import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle

import pandas as pd

from scipy.interpolate import UnivariateSpline, InterpolatedUnivariateSpline
from scipy.optimize import minimize_scalar
from scipy.optimize import curve_fit
from scipy.interpolate import CloughTocher2DInterpolator
from scipy.integrate import solve_ivp, trapezoid, quad

from functools import partial

import pyvista as pv
from pyvistaqt import BackgroundPlotter

import sys
sys.path.append('.')

import os
path = r'C:\Program Files\ParaView 5.11.0\bin'
os.environ["PATH"] = os.environ["PATH"]+';'+path

import meshio
import bempp.api
from bempp.api.operators.potential import laplace

# bempp.api.PLOT_BACKEND = "gmsh"
bempp.api.PLOT_BACKEND = "paraview"


#%%
class Geometry(object):
    
    def __init__(self):        
        xmin = -15
        xmax = 15
        ymin = 0
        ymax = 20
        
        num_electrode = 3
        thk = [2, 6, 2]
        gap = [4, 4]
        hole = [2, 3, 2] 
        z = 0
                
        pts_y_bc = np.unique(hole + [ymin, ymax])
        points_left = np.ones([len(pts_y_bc),3])*xmin
        points_left[:,1] = pts_y_bc
        points_left[:,2] = z
        
        points_right = np.ones([len(pts_y_bc),3])*xmax
        points_right[:,1] = pts_y_bc[::-1]
        points_right[:,2] = z
        
        left_bc = -(sum(thk) + sum(gap))/2
        right_bc = (sum(thk) + sum(gap))/2
        pos_electrodes = np.ones([num_electrode,2])*left_bc
        for i in np.arange(num_electrode-1):
            pos_electrodes[i,1] = pos_electrodes[i,0] + thk[i]
            pos_electrodes[i+1,0] = pos_electrodes[i,1] + gap[i]
        pos_electrodes[-1,1] = right_bc  

        self.num_electrode = num_electrode        
        self.electrodes = pos_electrodes
        self.thk = thk
        self.hole = hole
        self.rmax = ymax

        
#%%
class Lens(object):
    
    def __init__(self, name, dim=2, sym=1):
        super(Lens, self).__init__()
        
        self.name = name
        self.dim = dim    # dimension
        self.sym = sym    # 0-no symmetry, 1-rotation symmetry
        self.z_lim = []       
        self.position = 0
        
        self.geo = Geometry()

        self.unit_potentials_vtk = []               # e.g. [101, 010]
        self.unit_potentials_fit = []               # e.g. [101, 010]
        self.electrode_potentials = []          # e.g. [5000, 8000]        
        
        self.unit_data_all_vtk = dict()      # vtk results
        self.unit_data_all_vtk_grad = dict()      # vtk results
        self.unit_data_all_grid = dict()    # fem results on mesh grids
               
        self.unit_coeff_fit_all = dict()  # coefficients of the field


    def view_geo(self, rel_pos = True, fig_num = None, edgecolor = 'blue', facecolor = 'blue', lw=1):
        scale = 1.5
        plt.figure(fig_num)
        for i in np.arange(self.geo.num_electrode):
            plt.gca().add_patch(Rectangle((self.geo.electrodes[i][0] + self.position*rel_pos, -self.geo.rmax), self.geo.thk[i], self.geo.rmax - self.geo.hole[i],
                         edgecolor = edgecolor, facecolor = facecolor, fill=True, lw=lw))
            plt.gca().add_patch(Rectangle((self.geo.electrodes[i][0] + self.position*rel_pos, self.geo.rmax), self.geo.thk[i], - (self.geo.rmax - self.geo.hole[i]),
                         edgecolor = edgecolor, facecolor = facecolor, fill=True, lw=lw))
        plt.xlim((self.geo.electrodes.min()*scale + self.position*rel_pos, self.geo.electrodes.max()*scale + self.position*rel_pos))
        plt.ylim((-self.geo.rmax*scale, self.geo.rmax*scale))
        plt.xlabel('[mm]')
        plt.ylabel('[mm]')
        plt.title('geometry of ' + self.name)
        plt.show()
        
        
    def import_data_vtk(self, filename, unit_potentials):       
        vtk_data = pv.read(filename + '.vtk')
        results = pd.DataFrame()
        results['phi'] = vtk_data.point_data["phi"]
        results['z'] = vtk_data.points[:,0]
        results['r'] = vtk_data.points[:,1]
        self.unit_data_all_vtk[unit_potentials] = vtk_data
        self.unit_data_all_vtk_grad[unit_potentials] = vtk_data.compute_derivative(scalars="phi")

        self.unit_data_all_grid[unit_potentials] = results
        if unit_potentials not in self.unit_potentials_vtk:
            self.unit_potentials_vtk.append(unit_potentials)
               
            
    def view_vtk(self, unit_potentials = None):   
        if unit_potentials == None:
            keys = self.unit_data_all_vtk.keys()
        else:
            keys = unit_potentials
            
        pv.global_theme.multi_rendering_splitting_position = 0.35

        for key in keys:
            plotter = BackgroundPlotter(shape='1/2')
            plotter.subplot(2)
            plotter.add_mesh(self.unit_data_all_vtk[key], scalars='phi', show_scalar_bar=True, cmap='jet')
            plotter.add_mesh(self.unit_data_all_vtk[key].contour(), color = 'white')
            plotter.add_text(self.name + ":  " + key + " unit potential [V]")
            
            plotter.subplot(1)
            plotter.add_mesh(self.unit_data_all_vtk[key], scalars='phi', show_edges=True, show_scalar_bar=True, cmap='jet', opacity=1)
            plotter.add_text("mesh")

            plotter.subplot(0)
            plotter.add_mesh(self.unit_data_all_vtk_grad[key], scalars='gradient', show_scalar_bar=True, cmap='jet', clim = None)
            plotter.add_text("unit electrical field [V/mm]")
        
            plotter.link_views()
            plotter.camera_position = 'xy'        
            plotter.show()        


    def import_data_fit_coeff(self, filename, unit_potentials, order_spline = 5, method = 'spline'):
        df = pd.read_csv(filename + '.csv')
        z_points = df.values[:,0]
        coeff = df.values[:,1:]                 
        
        r_order = (coeff.shape[1]-1)*2        
        
        coeff_fn_fit = []
        for kk in np.arange(r_order/2+1):
            if method == 'spline':
                spl = InterpolatedUnivariateSpline(z_points, coeff[:,[int(kk)]], k = order_spline)
                coeff_fn_fit.append(spl)
                # plt.figure()
                # plt.plot(z_points,coeff_fn_fit[int(kk)](z_points),'r')
                # plt.plot(z_points,coeff[:,[int(kk)]],'.')                    
            elif method == 'bspline':
                pass
            elif method == 'hermite':
                c, stats = hermfit(z_points, coeff[:,[int(kk)]], deg = 50, full=True)
                coeff_fn_fit.append(c)
        
        self.unit_coeff_fit_all[unit_potentials] = coeff_fn_fit

        if unit_potentials not in self.unit_potentials_fit:
            self.unit_potentials_fit.append(unit_potentials)


    def calc_unit_phi_fit_results(self, zz, rr, unit_potentials, method = 'spline'):
        phi = np.zeros(zz.shape)
        dphi_dz = np.zeros(zz.shape)
        dphi_dr = np.zeros(zz.shape)            
        r_order = (len(self.unit_coeff_fit_all[unit_potentials])-1)*2
        
        unit_potential_fit_coeff = self.unit_coeff_fit_all[unit_potentials]
        for i in np.arange(r_order/2+1):       
            if method == 'spline' or 'bspline':
                func = unit_potential_fit_coeff[int(i)]
                phi += func(zz)*(rr)**(2*i)
                dphi_dz += func.derivative(n=1)(zz)*(rr)**(2*i)
                dphi_dr += func(zz)*(2*i)*(rr)**(2*i-1)*(np.sign(2*i-1)+1)/2               
            elif method == 'hermite':
                coeff = unit_potential_fit_coeff[int(i)]
                phi += hermval(zz, coeff)*(rr)**(2*i)
                dphi_dz += hermval(zz, hermder(coeff, m=1))*(rr)**(2*i)
                dphi_dr += hermval(zz, coeff)*(2*i)*(rr)**(2*i-1)*(np.sign(2*i-1)+1)/2            
    
        return phi, dphi_dz, dphi_dr
    

    def view_field(self, zz, rr, fig_num = None):
        phi_all = np.zeros(zz.shape)
        dphi_dz_all = np.zeros(zz.shape)
        dphi_dr_all = np.zeros(zz.shape)            
        
        for key in self.unit_potentials_fit:     
            phi, dphi_dz, dphi_dr = self.calc_unit_phi_fit_results(zz=zz, rr=rr, unit_potentials = key)
            phi_all += phi * self.electrode_potentials[key]
            dphi_dz_all += dphi_dz * self.electrode_potentials[key]
            dphi_dr_all += dphi_dr * self.electrode_potentials[key]                        
            # plt.figure(fig_num)
            # fig_num+=1
            # plt.pcolormesh(zz,rr,phi)
            # plt.title(key)
            
        plt.figure(fig_num)
        plt.subplot(1,3,1)
        plt.pcolormesh(zz, rr, phi_all, shading='auto', cmap='jet')
        plt.pcolormesh(zz, -rr, phi_all, shading='auto', cmap='jet')            
        plt.colorbar()
        plt.xlabel('z [mm]')
        plt.ylabel('r [mm]')
        plt.title('phi [V]')
    
        plt.subplot(1,3,2)
        plt.pcolormesh(zz, rr, dphi_dz_all, shading='auto', cmap='jet')
        plt.pcolormesh(zz, -rr, dphi_dz_all, shading='auto', cmap='jet')            
        plt.colorbar()
        plt.xlabel('z [mm]')
        plt.ylabel('r [mm]')
        plt.title('dphi/dz [V/mm]')
    
        plt.subplot(1,3,3)
        plt.pcolormesh(zz, rr, dphi_dr_all, shading='auto', cmap='jet')
        plt.pcolormesh(zz, -rr, dphi_dr_all, shading='auto', cmap='jet')            
        plt.colorbar()
        plt.xlabel('z [mm]')
        plt.ylabel('r [mm]')
        plt.title('dphi/dr [V/mm]')
    
        plt.show()        

    
            
#%%                        
class Deflector(object):
    
    def __init__(self, name):
        super(Deflector, self).__init__()
    
        self.name = name
        self.dflt_num = 0
        self.dflt_angles = []
        self.dflt_r = 5
        self.dflt_z_min = 0
        self.dflt_z_max = 10
                
        self.position = 0

        self.volts = []
        
    def geo_init_angle(self, dflt_num, fill_factor):
        self.dflt_num = dflt_num
        factor_fill = fill_factor
        
        dflt_angle = 2*np.pi/self.dflt_num * factor_fill
        dflt_angle_deg = dflt_angle/np.pi*180
        
        gap_angle = 2*np.pi/self.dflt_num * (1-factor_fill)
        gap_angle_deg = gap_angle/np.pi*180
        
        start_angle = -dflt_angle/2
        start_angle_deg = start_angle/np.pi*180

        ## deflectors,(start angle, end angle) of each electrodes
        self.dflt_angles = np.zeros([self.dflt_num, 2])
        self.dflt_angles[0,0] = start_angle
        for i in np.arange(self.dflt_num-1):
            self.dflt_angles[i,1] = self.dflt_angles[i,0] + dflt_angle
            self.dflt_angles[i+1,0] = self.dflt_angles[i,1] + gap_angle
        self.dflt_angles[-1,1] = self.dflt_angles[-1,0] + dflt_angle
        
    
    def view_geo(self, axis = 'xy', rel_pos = True, fig_num = None, color = 'k', lw=2): 
        plt.figure(fig_num)
        if axis == 'xy':
            ## plot deflectors
            for i in np.arange(self.dflt_num):
                t = np.linspace(self.dflt_angles[i,0], self.dflt_angles[i,1],100);
                plt.plot(np.cos(t), np.sin(t),'r');
            plt.axis('equal')
        elif axis == 'rz':
            plt.plot([self.dflt_z_min+self.position*rel_pos, self.dflt_z_max+self.position*rel_pos], [self.dflt_r, self.dflt_r], color = color, lw = lw)
            plt.plot([self.dflt_z_min+self.position*rel_pos, self.dflt_z_max+self.position*rel_pos], [-self.dflt_r, -self.dflt_r], color = color, lw = lw)
        
            
    def load_results(self, input_file):
        grid = bempp.api.import_grid(input_file+'.msh')
        space = bempp.api.function_space(grid, "DP", 0)
    
        output_file = input_file+'_res'
        rhs_coeff = np.loadtxt(open(output_file+'_coeff_rhs.csv', 'rb'), delimiter=',', skiprows=0)
        sol_coeff = np.loadtxt(open(output_file+'_coeff_sol.csv', 'rb'), delimiter=',', skiprows=0)
    
        rhs_load = bempp.api.GridFunction(space, coefficients = rhs_coeff)
        sol_load = bempp.api.GridFunction(space, coefficients = sol_coeff)
    
        return grid, space, rhs_load, sol_load        


    def view_bem(self, grid=None, rhs=None, sol=None):
        if grid != None:
            grid.plot()    
        if rhs != None:
            rhs.plot()
        if sol != None:
            sol.plot()


    def load_fit3d_results(self, input_file, order_spline):
        # read fit results from files
        output_file = input_file+'_res'        
        df = pd.read_csv(output_file+'_sol_fit.csv')
        z_list = df.values[:,0]
        data = df.values[:,1:]                 
        header = df.columns
        
        order = int((header.size-1)**0.5)-1
        
        mmm = np.zeros([order+1, order+1, len(z_list)])
        volt_fit_func = np.empty((order+1, order+1), dtype=object)
        kl = 0
        
        for i in range(order+1):
            for j in range(order+1):
                mmm[i,j,:] = data[:, kl]
                volt_fit_func[i,j] = InterpolatedUnivariateSpline(z_list, mmm[i,j,:], k = order_spline)
                kl += 1
                
        self.volt_fit_func = volt_fit_func


    def view_field_slice(self, z, grid_ctr, fig_num = None):
        tmp = self.volt_fit_func.shape[0]
        mm_fit = np.zeros([tmp,tmp])
        for i in range(tmp):
            for j in range(tmp):
                mm_fit[i,j] = self.volt_fit_func[i,j](z)
        
        vv_all_fit = polyval2d(grid_ctr[0], grid_ctr[1], mm_fit)
        
        plt.figure(fig_num)
        plt.pcolormesh(grid_ctr[0], grid_ctr[1], vv_all_fit, shading='auto', cmap='jet',clim=None)
        plt.colorbar()
        plt.xlabel('x [mm]')
        plt.ylabel('y [mm]')
        plt.title('deflector fit results loading: phi [V]')
        plt.show()
        


#%%        
class Aperture(object):

    def __init__(self, name, r_hole = 0):
        super(Aperture, self).__init__()
        self.name = name
        self.r_hole = r_hole
        self.position = 0
        self.rmax = 20

    def view_geo(self, rel_pos = True, fig_num = None, color = 'k', lw=2):
        plt.figure(fig_num)
        plt.plot([self.position, self.position] * rel_pos, [self.r_hole, self.rmax], color = color, lw = lw)
        plt.plot([self.position, self.position] * rel_pos, [-self.r_hole, -self.rmax], color = color, lw = lw)
        plt.xlabel('z [mm]')
        plt.ylabel('r [mm]')
        plt.show()
                
            
#%%          
class Column(object):
    
    def __init__(self, name):
        self.name = name
        self.lenses = []
        self.deflectors = []
        self.apertures = []
        
        self.source = []
        self.crosses = []
        self.screen = []
        
        self.v_source = []
        
        self.traj_func = []
        
        self.axial_pot_func = []
        
        
    def add_lens(self, lens, pos):
        self.lenses.append(lens)
        lens.position = pos


    def add_aperture(self, aperture, pos):
        self.apertures.append(aperture)
        aperture.position = pos


    def add_deflectors(self, deflector, pos):
        self.deflectors.append(deflector)
        deflector.position = pos


    def view_geo(self, fig_num = None, edgecolor = 'blue', facecolor = 'blue', color_dflt = 'r', color_aper = 'k', lw=1):
        scale = 1.1
        for lens in self.lenses:     
            lens.view_geo(fig_num = fig_num, edgecolor = edgecolor, facecolor = facecolor, lw=lw)
        # plt.xlim((self.lenses[0].geo.electrodes.min()*scale + self.lenses[0].position, self.lenses[-1].geo.electrodes.max()*scale + self.lenses[-1].position))
        plt.xlim(self.source*scale, self.screen*scale)
        
        plt.plot(self.source, 0, 'k+')
        plt.plot(self.screen, 0, 'k+')
        plt.plot(self.crosses, np.zeros(len(self.crosses)), 'kx')
        
        for aperture in self.apertures:
            aperture.view_geo(fig_num = fig_num, color = color_aper, lw=2*lw)

        for deflector in self.deflectors:
            deflector.view_geo(axis = 'rz', fig_num = fig_num, color = color_dflt, lw=2*lw)
        
        plt.xlabel('z [mm]')
        plt.ylabel('r [mm]')
#        plt.axis('equal')     
        plt.title('geometry of ' + self.name)   



#%% main
if __name__=='__main__':
    fig_num = 0

    lens_1 = Lens(name = 'lens 1', dim=2, sym=2)
    filename = '.\\data\\einzel_lens_results_'
    lens_1.import_data_vtk(filename+'010', unit_potentials = '010')
    lens_1.import_data_vtk(filename+'101', unit_potentials = '101')
        
    lens_1.import_data_fit_coeff(filename+'010_fit', unit_potentials = '010')
    lens_1.import_data_fit_coeff(filename+'101_fit', unit_potentials = '101')
    
    lens_1.view_geo(fig_num = fig_num)
    lens_1.view_vtk(unit_potentials = ['101'])      # None = ['101', '010']

    zz = np.linspace(-15, 15, 200)
    rr = np.linspace(0, 1, 200)
    zz, rr = np.meshgrid(zz, rr) 
        
    lens_1.electrode_potentials = {'010': 4000, '101': 8000}
    
    fig_num += 1    
    lens_1.view_field(zz, rr, fig_num)
    

#%%
    lens_2 = Lens('lens_2')
    lens_2.__dict__.update(lens_1.__dict__)
    lens_2.name = 'lens_2'
    lens_2.electrode_potentials = {'010': 4000, '101': 8000}
    fig_num += 1        
    lens_2.view_field(zz, rr, fig_num)
    
    lens_3 = Lens('lens_3')
    lens_3.__dict__.update(lens_1.__dict__)
    lens_3.name = 'lens_3'
    lens_3.electrode_potentials = {'010': 4000, '101': 8000}
    fig_num += 1        
    lens_3.view_field(zz, rr, fig_num)


#%%
    dflt_1 = Deflector('deflector_1')
    dflt_1.geo_init_angle(dflt_num = 8, fill_factor = 0.95)
    # fig_num += 1        
    # dflt_1.view_geo(fig_num = fig_num, axis = 'xy')

    input_file = r'.\data\dflts_8'    # .msh file
    # grid_load, space, rhs_load, sol_load = dflt_1.load_results(input_file)   
    # dflt_1.view_bem(grid=grid_load, rhs=rhs_load, sol=sol_load)

    fig_num += 1        
    dflt_1.view_geo(fig_num = fig_num, axis = 'rz')

    dflt_1.load_fit3d_results(input_file, order_spline = 5)

    grid_ctr = np.mgrid[-2:2:100j, -2:2:100j]
    fig_num += 1        
    dflt_1.view_field_slice(z = 5, grid_ctr = grid_ctr, fig_num = fig_num)

#%%
    dflt_2 = Deflector('deflector_2')
    dflt_2.__dict__.update(dflt_1.__dict__)
    dflt_2.name = 'deflector_2'


#%%    
    aperture_1 = Aperture(name = 'aperture 1', r_hole = 0.5)    
    aperture_2 = Aperture(name = 'aperture 2', r_hole = 1)
    aperture_3 = Aperture(name = 'aperture 3', r_hole = 0.3)
    
    
#%%
    column_1 = Column('column_1')

    column_1.add_lens(lens_1, pos = 0)
    column_1.add_lens(lens_2, pos = 70)
    column_1.add_lens(lens_3, pos = 160)

    column_1.add_deflectors(dflt_1, pos = 110)
    column_1.add_deflectors(dflt_2, pos = 130)

    column_1.add_aperture(aperture_1, pos = -20)
    column_1.add_aperture(aperture_2, pos = 40)
    column_1.add_aperture(aperture_3, pos = 100)

    column_1.v_source = 8000
    
    column_1.source = -80
    column_1.crosses = [25, 90, 180]
    column_1.screen = 180

    fig_num += 1
    column_1.view_geo(fig_num = fig_num)
## end
#30, 138:
"""
参考::https://docs.pyvista.org/version/stable/getting-started/installation.html
参考vtk::https://vtk.org/about/#overview
+[打开网页](,参考)

"""
## end
#32, 73:
https://docs.pyvista.org/version/stable/getting-started/installation.html
## end
#34, 31:
https://vtk.org/about/#overview
## end
#36, 48:
"""
参考::https://bempp.com/installation.html

"""
## end
#38, 35:
https://bempp.com/installation.html
## end
#40, 19011:
"""
numba
+[P函数](,测试package)
pyvista:...
bempp:...
样本1:...

"""

import numpy as np
from numpy.polynomial.polynomial import polyval2d, polyder
from numpy.polynomial.hermite import hermfit, hermval, hermder

import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle

import pandas as pd

from scipy.interpolate import UnivariateSpline, InterpolatedUnivariateSpline
from scipy.optimize import minimize_scalar
from scipy.optimize import curve_fit
from scipy.interpolate import CloughTocher2DInterpolator
from scipy.integrate import solve_ivp, trapezoid, quad

from functools import partial

import pyvista as pv
# from pyvistaqt import BackgroundPlotter

import sys
sys.path.append('.')

import os
path = r'C:\Program Files\ParaView 5.11.0\bin'
os.environ["PATH"] = os.environ["PATH"]+';'+path

import bempp.api
from bempp.api.operators.potential import laplace

# bempp.api.PLOT_BACKEND = "gmsh"
bempp.api.PLOT_BACKEND = "paraview"


#%%
class Geometry(object):
    
    def __init__(self):        
        xmin = -15
        xmax = 15
        ymin = 0
        ymax = 20
        
        num_electrode = 3
        thk = [2, 6, 2]
        gap = [4, 4]
        hole = [2, 3, 2] 
        z = 0
                
        pts_y_bc = np.unique(hole + [ymin, ymax])
        points_left = np.ones([len(pts_y_bc),3])*xmin
        points_left[:,1] = pts_y_bc
        points_left[:,2] = z
        
        points_right = np.ones([len(pts_y_bc),3])*xmax
        points_right[:,1] = pts_y_bc[::-1]
        points_right[:,2] = z
        
        left_bc = -(sum(thk) + sum(gap))/2
        right_bc = (sum(thk) + sum(gap))/2
        pos_electrodes = np.ones([num_electrode,2])*left_bc
        for i in np.arange(num_electrode-1):
            pos_electrodes[i,1] = pos_electrodes[i,0] + thk[i]
            pos_electrodes[i+1,0] = pos_electrodes[i,1] + gap[i]
        pos_electrodes[-1,1] = right_bc  

        self.num_electrode = num_electrode        
        self.electrodes = pos_electrodes
        self.thk = thk
        self.hole = hole
        self.rmax = ymax

        
#%%
class Lens(object):
    
    def __init__(self, name, dim=2, sym=1):
        super(Lens, self).__init__()
        
        self.name = name
        self.dim = dim    # dimension
        self.sym = sym    # 0-no symmetry, 1-rotation symmetry
        self.z_lim = []       
        self.position = 0
        
        self.geo = Geometry()

        self.unit_potentials_vtk = []               # e.g. [101, 010]
        self.unit_potentials_fit = []               # e.g. [101, 010]
        self.electrode_potentials = []          # e.g. [5000, 8000]        
        
        self.unit_data_all_vtk = dict()      # vtk results
        self.unit_data_all_vtk_grad = dict()      # vtk results
        self.unit_data_all_grid = dict()    # fem results on mesh grids
               
        self.unit_coeff_fit_all = dict()  # coefficients of the field


    def view_geo(self, rel_pos = True, fig_num = None, edgecolor = 'blue', facecolor = 'blue', lw=1):
        scale = 1.5
        plt.figure(fig_num)
        for i in np.arange(self.geo.num_electrode):
            plt.gca().add_patch(Rectangle((self.geo.electrodes[i][0] + self.position*rel_pos, -self.geo.rmax), self.geo.thk[i], self.geo.rmax - self.geo.hole[i],
                         edgecolor = edgecolor, facecolor = facecolor, fill=True, lw=lw))
            plt.gca().add_patch(Rectangle((self.geo.electrodes[i][0] + self.position*rel_pos, self.geo.rmax), self.geo.thk[i], - (self.geo.rmax - self.geo.hole[i]),
                         edgecolor = edgecolor, facecolor = facecolor, fill=True, lw=lw))
        plt.xlim((self.geo.electrodes.min()*scale + self.position*rel_pos, self.geo.electrodes.max()*scale + self.position*rel_pos))
        plt.ylim((-self.geo.rmax*scale, self.geo.rmax*scale))
        plt.xlabel('[mm]')
        plt.ylabel('[mm]')
        plt.title('geometry of ' + self.name)
        plt.show()
        
        
    def import_data_vtk(self, filename, unit_potentials):       
        vtk_data = pv.read(filename + '.vtk')
        results = pd.DataFrame()
        results['phi'] = vtk_data.point_data["phi"]
        results['z'] = vtk_data.points[:,0]
        results['r'] = vtk_data.points[:,1]
        self.unit_data_all_vtk[unit_potentials] = vtk_data
        self.unit_data_all_vtk_grad[unit_potentials] = vtk_data.compute_derivative(scalars="phi")

        self.unit_data_all_grid[unit_potentials] = results
        if unit_potentials not in self.unit_potentials_vtk:
            self.unit_potentials_vtk.append(unit_potentials)
               
            
    def view_vtk(self, unit_potentials = None):   
        if unit_potentials == None:
            keys = self.unit_data_all_vtk.keys()
        else:
            keys = unit_potentials
            
        pv.global_theme.multi_rendering_splitting_position = 0.35

        for key in keys:
            plotter = BackgroundPlotter(shape='1/2')
            plotter.subplot(2)
            plotter.add_mesh(self.unit_data_all_vtk[key], scalars='phi', show_scalar_bar=True, cmap='jet')
            plotter.add_mesh(self.unit_data_all_vtk[key].contour(), color = 'white')
            plotter.add_text(self.name + ":  " + key + " unit potential [V]")
            
            plotter.subplot(1)
            plotter.add_mesh(self.unit_data_all_vtk[key], scalars='phi', show_edges=True, show_scalar_bar=True, cmap='jet', opacity=1)
            plotter.add_text("mesh")

            plotter.subplot(0)
            plotter.add_mesh(self.unit_data_all_vtk_grad[key], scalars='gradient', show_scalar_bar=True, cmap='jet', clim = None)
            plotter.add_text("unit electrical field [V/mm]")
        
            plotter.link_views()
            plotter.camera_position = 'xy'        
            plotter.show()        


    def import_data_fit_coeff(self, filename, unit_potentials, order_spline = 5, method = 'spline'):
        df = pd.read_csv(filename + '.csv')
        z_points = df.values[:,0]
        coeff = df.values[:,1:]                 
        
        r_order = (coeff.shape[1]-1)*2        
        
        coeff_fn_fit = []
        for kk in np.arange(r_order/2+1):
            if method == 'spline':
                spl = InterpolatedUnivariateSpline(z_points, coeff[:,[int(kk)]], k = order_spline)
                coeff_fn_fit.append(spl)
                # plt.figure()
                # plt.plot(z_points,coeff_fn_fit[int(kk)](z_points),'r')
                # plt.plot(z_points,coeff[:,[int(kk)]],'.')                    
            elif method == 'bspline':
                pass
            elif method == 'hermite':
                c, stats = hermfit(z_points, coeff[:,[int(kk)]], deg = 50, full=True)
                coeff_fn_fit.append(c)
        
        self.unit_coeff_fit_all[unit_potentials] = coeff_fn_fit

        if unit_potentials not in self.unit_potentials_fit:
            self.unit_potentials_fit.append(unit_potentials)


    def calc_unit_phi_fit_results(self, zz, rr, unit_potentials, method = 'spline'):
        phi = np.zeros(zz.shape)
        dphi_dz = np.zeros(zz.shape)
        dphi_dr = np.zeros(zz.shape)            
        r_order = (len(self.unit_coeff_fit_all[unit_potentials])-1)*2
        
        unit_potential_fit_coeff = self.unit_coeff_fit_all[unit_potentials]
        for i in np.arange(r_order/2+1):       
            if method == 'spline' or 'bspline':
                func = unit_potential_fit_coeff[int(i)]
                phi += func(zz)*(rr)**(2*i)
                dphi_dz += func.derivative(n=1)(zz)*(rr)**(2*i)
                dphi_dr += func(zz)*(2*i)*(rr)**(2*i-1)*(np.sign(2*i-1)+1)/2               
            elif method == 'hermite':
                coeff = unit_potential_fit_coeff[int(i)]
                phi += hermval(zz, coeff)*(rr)**(2*i)
                dphi_dz += hermval(zz, hermder(coeff, m=1))*(rr)**(2*i)
                dphi_dr += hermval(zz, coeff)*(2*i)*(rr)**(2*i-1)*(np.sign(2*i-1)+1)/2            
    
        return phi, dphi_dz, dphi_dr
    

    def view_field(self, zz, rr, fig_num = None):
        phi_all = np.zeros(zz.shape)
        dphi_dz_all = np.zeros(zz.shape)
        dphi_dr_all = np.zeros(zz.shape)            
        
        for key in self.unit_potentials_fit:     
            phi, dphi_dz, dphi_dr = self.calc_unit_phi_fit_results(zz=zz, rr=rr, unit_potentials = key)
            phi_all += phi * self.electrode_potentials[key]
            dphi_dz_all += dphi_dz * self.electrode_potentials[key]
            dphi_dr_all += dphi_dr * self.electrode_potentials[key]                        
            # plt.figure(fig_num)
            # fig_num+=1
            # plt.pcolormesh(zz,rr,phi)
            # plt.title(key)
            
        plt.figure(fig_num)
        plt.subplot(1,3,1)
        plt.pcolormesh(zz, rr, phi_all, shading='auto', cmap='jet')
        plt.pcolormesh(zz, -rr, phi_all, shading='auto', cmap='jet')            
        plt.colorbar()
        plt.xlabel('z [mm]')
        plt.ylabel('r [mm]')
        plt.title('phi [V]')
    
        plt.subplot(1,3,2)
        plt.pcolormesh(zz, rr, dphi_dz_all, shading='auto', cmap='jet')
        plt.pcolormesh(zz, -rr, dphi_dz_all, shading='auto', cmap='jet')            
        plt.colorbar()
        plt.xlabel('z [mm]')
        plt.ylabel('r [mm]')
        plt.title('dphi/dz [V/mm]')
    
        plt.subplot(1,3,3)
        plt.pcolormesh(zz, rr, dphi_dr_all, shading='auto', cmap='jet')
        plt.pcolormesh(zz, -rr, dphi_dr_all, shading='auto', cmap='jet')            
        plt.colorbar()
        plt.xlabel('z [mm]')
        plt.ylabel('r [mm]')
        plt.title('dphi/dr [V/mm]')
    
        plt.show()        

    
            
#%%                        
class Deflector(object):
    
    def __init__(self, name):
        super(Deflector, self).__init__()
    
        self.name = name
        self.dflt_num = 0
        self.dflt_angles = []
        self.dflt_r = 5
        self.dflt_z_min = 0
        self.dflt_z_max = 10
                
        self.position = 0

        self.volts = []
        
    def geo_init_angle(self, dflt_num, fill_factor):
        self.dflt_num = dflt_num
        factor_fill = fill_factor
        
        dflt_angle = 2*np.pi/self.dflt_num * factor_fill
        dflt_angle_deg = dflt_angle/np.pi*180
        
        gap_angle = 2*np.pi/self.dflt_num * (1-factor_fill)
        gap_angle_deg = gap_angle/np.pi*180
        
        start_angle = -dflt_angle/2
        start_angle_deg = start_angle/np.pi*180

        ## deflectors,(start angle, end angle) of each electrodes
        self.dflt_angles = np.zeros([self.dflt_num, 2])
        self.dflt_angles[0,0] = start_angle
        for i in np.arange(self.dflt_num-1):
            self.dflt_angles[i,1] = self.dflt_angles[i,0] + dflt_angle
            self.dflt_angles[i+1,0] = self.dflt_angles[i,1] + gap_angle
        self.dflt_angles[-1,1] = self.dflt_angles[-1,0] + dflt_angle
        
    
    def view_geo(self, axis = 'xy', rel_pos = True, fig_num = None, color = 'k', lw=2): 
        plt.figure(fig_num)
        if axis == 'xy':
            ## plot deflectors
            for i in np.arange(self.dflt_num):
                t = np.linspace(self.dflt_angles[i,0], self.dflt_angles[i,1],100);
                plt.plot(np.cos(t), np.sin(t),'r');
            plt.axis('equal')
        elif axis == 'rz':
            plt.plot([self.dflt_z_min+self.position*rel_pos, self.dflt_z_max+self.position*rel_pos], [self.dflt_r, self.dflt_r], color = color, lw = lw)
            plt.plot([self.dflt_z_min+self.position*rel_pos, self.dflt_z_max+self.position*rel_pos], [-self.dflt_r, -self.dflt_r], color = color, lw = lw)
        
            
    def load_results(self, input_file):
        grid = bempp.api.import_grid(input_file+'.msh')
        space = bempp.api.function_space(grid, "DP", 0)
    
        output_file = input_file+'_res'
        rhs_coeff = np.loadtxt(open(output_file+'_coeff_rhs.csv', 'rb'), delimiter=',', skiprows=0)
        sol_coeff = np.loadtxt(open(output_file+'_coeff_sol.csv', 'rb'), delimiter=',', skiprows=0)
    
        rhs_load = bempp.api.GridFunction(space, coefficients = rhs_coeff)
        sol_load = bempp.api.GridFunction(space, coefficients = sol_coeff)
    
        return grid, space, rhs_load, sol_load        


    def view_bem(self, grid=None, rhs=None, sol=None):
        if grid != None:
            grid.plot()    
        if rhs != None:
            rhs.plot()
        if sol != None:
            sol.plot()


    def load_fit3d_results(self, input_file, order_spline):
        # read fit results from files
        output_file = input_file+'_res'        
        df = pd.read_csv(output_file+'_sol_fit.csv')
        z_list = df.values[:,0]
        data = df.values[:,1:]                 
        header = df.columns
        
        order = int((header.size-1)**0.5)-1
        
        mmm = np.zeros([order+1, order+1, len(z_list)])
        volt_fit_func = np.empty((order+1, order+1), dtype=object)
        kl = 0
        
        for i in range(order+1):
            for j in range(order+1):
                mmm[i,j,:] = data[:, kl]
                volt_fit_func[i,j] = InterpolatedUnivariateSpline(z_list, mmm[i,j,:], k = order_spline)
                kl += 1
                
        self.volt_fit_func = volt_fit_func


    def view_field_slice(self, z, grid_ctr, fig_num = None):
        tmp = self.volt_fit_func.shape[0]
        mm_fit = np.zeros([tmp,tmp])
        for i in range(tmp):
            for j in range(tmp):
                mm_fit[i,j] = self.volt_fit_func[i,j](z)
        
        vv_all_fit = polyval2d(grid_ctr[0], grid_ctr[1], mm_fit)
        
        plt.figure(fig_num)
        plt.pcolormesh(grid_ctr[0], grid_ctr[1], vv_all_fit, shading='auto', cmap='jet',clim=None)
        plt.colorbar()
        plt.xlabel('x [mm]')
        plt.ylabel('y [mm]')
        plt.title('deflector fit results loading: phi [V]')
        plt.show()
        


#%%        
class Aperture(object):

    def __init__(self, name, r_hole = 0):
        super(Aperture, self).__init__()
        self.name = name
        self.r_hole = r_hole
        self.position = 0
        self.rmax = 20

    def view_geo(self, rel_pos = True, fig_num = None, color = 'k', lw=2):
        plt.figure(fig_num)
        plt.plot([self.position, self.position] * rel_pos, [self.r_hole, self.rmax], color = color, lw = lw)
        plt.plot([self.position, self.position] * rel_pos, [-self.r_hole, -self.rmax], color = color, lw = lw)
        plt.xlabel('z [mm]')
        plt.ylabel('r [mm]')
        plt.show()
                
            
#%%          
class Column(object):
    
    def __init__(self, name):
        self.name = name
        self.lenses = []
        self.deflectors = []
        self.apertures = []
        
        self.source = []
        self.crosses = []
        self.screen = []
        
        self.v_source = []
        
        self.traj_func = []
        
        self.axial_pot_func = []
        
        
    def add_lens(self, lens, pos):
        self.lenses.append(lens)
        lens.position = pos


    def add_aperture(self, aperture, pos):
        self.apertures.append(aperture)
        aperture.position = pos


    def add_deflectors(self, deflector, pos):
        self.deflectors.append(deflector)
        deflector.position = pos


    def view_geo(self, fig_num = None, edgecolor = 'blue', facecolor = 'blue', color_dflt = 'r', color_aper = 'k', lw=1):
        scale = 1.1
        for lens in self.lenses:     
            lens.view_geo(fig_num = fig_num, edgecolor = edgecolor, facecolor = facecolor, lw=lw)
        # plt.xlim((self.lenses[0].geo.electrodes.min()*scale + self.lenses[0].position, self.lenses[-1].geo.electrodes.max()*scale + self.lenses[-1].position))
        plt.xlim(self.source*scale, self.screen*scale)
        
        plt.plot(self.source, 0, 'k+')
        plt.plot(self.screen, 0, 'k+')
        plt.plot(self.crosses, np.zeros(len(self.crosses)), 'kx')
        
        for aperture in self.apertures:
            aperture.view_geo(fig_num = fig_num, color = color_aper, lw=2*lw)

        for deflector in self.deflectors:
            deflector.view_geo(axis = 'rz', fig_num = fig_num, color = color_dflt, lw=2*lw)
        
        plt.xlabel('z [mm]')
        plt.ylabel('r [mm]')
#        plt.axis('equal')     
        plt.title('geometry of ' + self.name)   



"""
+[P函数](,测试package)

保存:...

"""



fig_num = 0

lens_1 = Lens(name = 'lens 1', dim=2, sym=2)
filename = '.\\data\\einzel_lens_results_'
lens_1.import_data_vtk(filename+'010', unit_potentials = '010')
lens_1.import_data_vtk(filename+'101', unit_potentials = '101')
    
lens_1.import_data_fit_coeff(filename+'010_fit', unit_potentials = '010')
lens_1.import_data_fit_coeff(filename+'101_fit', unit_potentials = '101')

lens_1.view_geo(fig_num = fig_num)
lens_1.view_vtk(unit_potentials = ['101'])      # None = ['101', '010']

zz = np.linspace(-15, 15, 200)
rr = np.linspace(0, 1, 200)
zz, rr = np.meshgrid(zz, rr) 
    
lens_1.electrode_potentials = {'010': 4000, '101': 8000}

fig_num += 1    
lens_1.view_field(zz, rr, fig_num)


#%%
lens_2 = Lens('lens_2')
lens_2.__dict__.update(lens_1.__dict__)
lens_2.name = 'lens_2'
lens_2.electrode_potentials = {'010': 4000, '101': 8000}
fig_num += 1        
lens_2.view_field(zz, rr, fig_num)

lens_3 = Lens('lens_3')
lens_3.__dict__.update(lens_1.__dict__)
lens_3.name = 'lens_3'
lens_3.electrode_potentials = {'010': 4000, '101': 8000}
fig_num += 1        
lens_3.view_field(zz, rr, fig_num)


#%%
dflt_1 = Deflector('deflector_1')
dflt_1.geo_init_angle(dflt_num = 8, fill_factor = 0.95)
# fig_num += 1        
# dflt_1.view_geo(fig_num = fig_num, axis = 'xy')

input_file = r'.\data\dflts_8'    # .msh file
# grid_load, space, rhs_load, sol_load = dflt_1.load_results(input_file)   
# dflt_1.view_bem(grid=grid_load, rhs=rhs_load, sol=sol_load)

fig_num += 1        
dflt_1.view_geo(fig_num = fig_num, axis = 'rz')

dflt_1.load_fit3d_results(input_file, order_spline = 5)

grid_ctr = np.mgrid[-2:2:100j, -2:2:100j]
fig_num += 1        
dflt_1.view_field_slice(z = 5, grid_ctr = grid_ctr, fig_num = fig_num)

#%%
dflt_2 = Deflector('deflector_2')
dflt_2.__dict__.update(dflt_1.__dict__)
dflt_2.name = 'deflector_2'


#%%    
aperture_1 = Aperture(name = 'aperture 1', r_hole = 0.5)    
aperture_2 = Aperture(name = 'aperture 2', r_hole = 1)
aperture_3 = Aperture(name = 'aperture 3', r_hole = 0.3)


#%%
column_1 = Column('column_1')

column_1.add_lens(lens_1, pos = 0)
column_1.add_lens(lens_2, pos = 70)
column_1.add_lens(lens_3, pos = 160)

column_1.add_deflectors(dflt_1, pos = 110)
column_1.add_deflectors(dflt_2, pos = 130)

column_1.add_aperture(aperture_1, pos = -20)
column_1.add_aperture(aperture_2, pos = 40)
column_1.add_aperture(aperture_3, pos = 100)

column_1.v_source = 8000

column_1.source = -80
column_1.crosses = [25, 90, 180]
column_1.screen = 180

fig_num += 1
column_1.view_geo(fig_num = fig_num)
## end
#42, 1988:
"""
地址::
+[保存P函数]"Ze Zhang"(,测试场景)
+[P函数](,测试场景)

测试aperture:...
测试lens:...
测试dfl:...

保存:...
+[P函数](,保存)
+[新建阅读窗口](,保存)


"""

fig_num = 0



zz = np.linspace(-15, 15, 200)
rr = np.linspace(0, 1, 200)
zz, rr = np.meshgrid(zz, rr) 

#%%
lens_2 = Lens('lens_2')
# lens_2.__dict__.update(lens_1.__dict__)
lens_2.name = 'lens_2'
lens_2.electrode_potentials = {'010': 4000, '101': 8000}
fig_num += 1        
lens_2.view_field(zz, rr, fig_num)

lens_3 = Lens('lens_3')
# lens_3.__dict__.update(lens_1.__dict__)
lens_3.name = 'lens_3'
lens_3.electrode_potentials = {'010': 4000, '101': 8000}
fig_num += 1        
lens_3.view_field(zz, rr, fig_num)


#%%
dflt_1 = Deflector('deflector_1')
dflt_1.geo_init_angle(dflt_num = 8, fill_factor = 0.95)
# fig_num += 1        
# dflt_1.view_geo(fig_num = fig_num, axis = 'xy')

input_file = r'/home/xiantao/Documents/Projects/py-sem/data/dflts_8'    # .msh file
# grid_load, space, rhs_load, sol_load = dflt_1.load_results(input_file)   
# dflt_1.view_bem(grid=grid_load, rhs=rhs_load, sol=sol_load)

fig_num += 1        
dflt_1.view_geo(fig_num = fig_num, axis = 'rz')

dflt_1.load_fit3d_results(input_file, order_spline = 5)

grid_ctr = np.mgrid[-2:2:100j, -2:2:100j]
fig_num += 1        
dflt_1.view_field_slice(z = 5, grid_ctr = grid_ctr, fig_num = fig_num)

#%%
dflt_2 = Deflector('deflector_2')
dflt_2.__dict__.update(dflt_1.__dict__)
dflt_2.name = 'deflector_2'



#%%    
aperture_1 = Aperture(name = 'aperture 1', r_hole = 0.5)    
aperture_2 = Aperture(name = 'aperture 2', r_hole = 1)
aperture_3 = Aperture(name = 'aperture 3', r_hole = 0.3)


#%%
column_1 = Column('column_1')

column_1.add_lens(lens_2, pos = 70)
column_1.add_lens(lens_3, pos = 160)

column_1.add_aperture(aperture_1, pos = -20)
column_1.add_aperture(aperture_2, pos = 40)
column_1.add_aperture(aperture_3, pos = 100)

column_1.v_source = 8000

column_1.source = -80
column_1.crosses = [25, 90, 180]
column_1.screen = 180

fig_num += 1
column_1.view_geo(fig_num = fig_num)


## end
#44, 2531:


fig_num = 0

lens_1 = Lens(name = 'lens 1', dim=2, sym=2)
filename = '.\\data\\einzel_lens_results_'
lens_1.import_data_vtk(filename+'010', unit_potentials = '010')
lens_1.import_data_vtk(filename+'101', unit_potentials = '101')
    
lens_1.import_data_fit_coeff(filename+'010_fit', unit_potentials = '010')
lens_1.import_data_fit_coeff(filename+'101_fit', unit_potentials = '101')

lens_1.view_geo(fig_num = fig_num)
lens_1.view_vtk(unit_potentials = ['101'])      # None = ['101', '010']

zz = np.linspace(-15, 15, 200)
rr = np.linspace(0, 1, 200)
zz, rr = np.meshgrid(zz, rr) 
    
lens_1.electrode_potentials = {'010': 4000, '101': 8000}

fig_num += 1    
lens_1.view_field(zz, rr, fig_num)


#%%
lens_2 = Lens('lens_2')
lens_2.__dict__.update(lens_1.__dict__)
lens_2.name = 'lens_2'
lens_2.electrode_potentials = {'010': 4000, '101': 8000}
fig_num += 1        
lens_2.view_field(zz, rr, fig_num)

lens_3 = Lens('lens_3')
lens_3.__dict__.update(lens_1.__dict__)
lens_3.name = 'lens_3'
lens_3.electrode_potentials = {'010': 4000, '101': 8000}
fig_num += 1        
lens_3.view_field(zz, rr, fig_num)


#%%
dflt_1 = Deflector('deflector_1')
dflt_1.geo_init_angle(dflt_num = 8, fill_factor = 0.95)
# fig_num += 1        
# dflt_1.view_geo(fig_num = fig_num, axis = 'xy')

input_file = r'.\data\dflts_8'    # .msh file
# grid_load, space, rhs_load, sol_load = dflt_1.load_results(input_file)   
# dflt_1.view_bem(grid=grid_load, rhs=rhs_load, sol=sol_load)

fig_num += 1        
dflt_1.view_geo(fig_num = fig_num, axis = 'rz')

dflt_1.load_fit3d_results(input_file, order_spline = 5)

grid_ctr = np.mgrid[-2:2:100j, -2:2:100j]
fig_num += 1        
dflt_1.view_field_slice(z = 5, grid_ctr = grid_ctr, fig_num = fig_num)

#%%
dflt_2 = Deflector('deflector_2')
dflt_2.__dict__.update(dflt_1.__dict__)
dflt_2.name = 'deflector_2'


#%%    
aperture_1 = Aperture(name = 'aperture 1', r_hole = 0.5)    
aperture_2 = Aperture(name = 'aperture 2', r_hole = 1)
aperture_3 = Aperture(name = 'aperture 3', r_hole = 0.3)


#%%
column_1 = Column('column_1')

column_1.add_lens(lens_1, pos = 0)
column_1.add_lens(lens_2, pos = 70)
column_1.add_lens(lens_3, pos = 160)

column_1.add_deflectors(dflt_1, pos = 110)
column_1.add_deflectors(dflt_2, pos = 130)

column_1.add_aperture(aperture_1, pos = -20)
column_1.add_aperture(aperture_2, pos = 40)
column_1.add_aperture(aperture_3, pos = 100)

column_1.v_source = 8000

column_1.source = -80
column_1.crosses = [25, 90, 180]
column_1.screen = 180

fig_num += 1
column_1.view_geo(fig_num = fig_num)
## end
#46, 553:
"""
+[P函数](,测试aperture)

"""


fig_num = 0


#%%    
aperture_1 = Aperture(name = 'aperture 1', r_hole = 0.5)    
aperture_2 = Aperture(name = 'aperture 2', r_hole = 1)
aperture_3 = Aperture(name = 'aperture 3', r_hole = 0.3)


#%%
column_1 = Column('column_1')

column_1.add_aperture(aperture_1, pos = -20)
column_1.add_aperture(aperture_2, pos = 40)
column_1.add_aperture(aperture_3, pos = 100)

column_1.v_source = 8000

column_1.source = -80
column_1.crosses = [25, 90, 180]
column_1.screen = 180

fig_num += 1
column_1.view_geo(fig_num = fig_num)


## end
#48, 1168:
"""
+[P函数](,测试场景)

测试aperture:...
测试lens
zz
保存:...
+[新建阅读窗口](,保存)

"""


fig_num = 0



zz = np.linspace(-15, 15, 200)
rr = np.linspace(0, 1, 200)
zz, rr = np.meshgrid(zz, rr) 

#%%
lens_2 = Lens('lens_2')
lens_2.__dict__.update(lens_1.__dict__)
lens_2.name = 'lens_2'
lens_2.electrode_potentials = {'010': 4000, '101': 8000}
fig_num += 1        
lens_2.view_field(zz, rr, fig_num)

lens_3 = Lens('lens_3')
lens_3.__dict__.update(lens_1.__dict__)
lens_3.name = 'lens_3'
lens_3.electrode_potentials = {'010': 4000, '101': 8000}
fig_num += 1        
lens_3.view_field(zz, rr, fig_num)



#%%    
aperture_1 = Aperture(name = 'aperture 1', r_hole = 0.5)    
aperture_2 = Aperture(name = 'aperture 2', r_hole = 1)
aperture_3 = Aperture(name = 'aperture 3', r_hole = 0.3)


#%%
column_1 = Column('column_1')

column_1.add_lens(lens_2, pos = 70)
column_1.add_lens(lens_3, pos = 160)

column_1.add_aperture(aperture_1, pos = -20)
column_1.add_aperture(aperture_2, pos = 40)
column_1.add_aperture(aperture_3, pos = 100)

column_1.v_source = 8000

column_1.source = -80
column_1.crosses = [25, 90, 180]
column_1.screen = 180

fig_num += 1
column_1.view_geo(fig_num = fig_num)


## end
#50, 1882:
"""
+[P函数](,测试dfl)

"""


fig_num = 0



zz = np.linspace(-15, 15, 200)
rr = np.linspace(0, 1, 200)
zz, rr = np.meshgrid(zz, rr) 

#%%
lens_2 = Lens('lens_2')
lens_2.__dict__.update(lens_1.__dict__)
lens_2.name = 'lens_2'
lens_2.electrode_potentials = {'010': 4000, '101': 8000}
fig_num += 1        
lens_2.view_field(zz, rr, fig_num)

lens_3 = Lens('lens_3')
lens_3.__dict__.update(lens_1.__dict__)
lens_3.name = 'lens_3'
lens_3.electrode_potentials = {'010': 4000, '101': 8000}
fig_num += 1        
lens_3.view_field(zz, rr, fig_num)


#%%
dflt_1 = Deflector('deflector_1')
dflt_1.geo_init_angle(dflt_num = 8, fill_factor = 0.95)
# fig_num += 1        
# dflt_1.view_geo(fig_num = fig_num, axis = 'xy')

input_file = r'/home/xiantao/Documents/Projects/py-sem/data/dflts_8'    # .msh file
# grid_load, space, rhs_load, sol_load = dflt_1.load_results(input_file)   
# dflt_1.view_bem(grid=grid_load, rhs=rhs_load, sol=sol_load)

fig_num += 1        
dflt_1.view_geo(fig_num = fig_num, axis = 'rz')

dflt_1.load_fit3d_results(input_file, order_spline = 5)

grid_ctr = np.mgrid[-2:2:100j, -2:2:100j]
fig_num += 1        
dflt_1.view_field_slice(z = 5, grid_ctr = grid_ctr, fig_num = fig_num)

#%%
dflt_2 = Deflector('deflector_2')
dflt_2.__dict__.update(dflt_1.__dict__)
dflt_2.name = 'deflector_2'



#%%    
aperture_1 = Aperture(name = 'aperture 1', r_hole = 0.5)    
aperture_2 = Aperture(name = 'aperture 2', r_hole = 1)
aperture_3 = Aperture(name = 'aperture 3', r_hole = 0.3)


#%%
column_1 = Column('column_1')

column_1.add_lens(lens_2, pos = 70)
column_1.add_lens(lens_3, pos = 160)

column_1.add_aperture(aperture_1, pos = -20)
column_1.add_aperture(aperture_2, pos = 40)
column_1.add_aperture(aperture_3, pos = 100)

column_1.v_source = 8000

column_1.source = -80
column_1.crosses = [25, 90, 180]
column_1.screen = 180

fig_num += 1
column_1.view_geo(fig_num = fig_num)


## end
#52, 353:
地址::/home/xiantao/Documents/Projects/py-sem
网址::https://gitee.com/zz303/py-sem
+[打开文件夹](,地址)
+[打开网页](,网址)
+[上传pySEM]"测试md表格"


文本内容:...
+[新建阅读窗口](,文本内容)
文本结构::
+[删除结构](,文本结构)->+[召唤星辰]"文本结构化"(文本内容,文本结构)
的(文本结构,二级标题)->+[设置结构](,二级标题)

输出报告:...
+[删除结构](,输出报告)
'输出报告'的地址是"/home/xiantao/Documents/Projects/py-sem/test/README.md"
+[召唤星辰]"结构文本转md"(文本结构,输出报告)



## end
#54, 39:
/home/xiantao/Documents/Projects/py-sem
## end
#56, 30:
https://gitee.com/zz303/py-sem
## end
#58, 670:
<!--
+[H函数](,文本内容)
-->

<h1>PySEM</h1>

<h2>Gallery</h2>
%fig_traj*
%fig_traj_dflt*
%fig_space*
%fig_spots*
%fig_aberration*


%测试表格

<!--
[1].:
将"\nabla^2*u+k*u=\p{x,x}{u}+\p{y,y}{u}+\p{z,z}{u}+k*u=0"记作为式(1)

测试代码(程序):...
+[新建阅读窗口](,测试代码)
测试表格(表格):...
+[新建阅读窗口](,测试表格)

fig_traj(图片)::/home/xiantao/Documents/Projects/py-sem/res/fig_traj.png
fig_traj_dflt(图片)::/home/xiantao/Documents/Projects/py-sem/res/fig_traj_dflt.png
fig_space(图片)::/home/xiantao/Documents/Projects/py-sem/res/fig_space.png
fig_spots(图片)::/home/xiantao/Documents/Projects/py-sem/res/fig_spots.png
fig_aberration(图片)::/home/xiantao/Documents/Projects/py-sem/res/fig_aberration.png

+[H函数](,文本内容)
-->
## end
#60, 107:

<h1>PySEM</h1>
<h2>Gallery</h2>
%fig_traj*
%fig_traj_dflt*
%fig_space*
%fig_spots*
%fig_aberration*
%测试表格

## end
#62, 341:
# PySEM
## Gallery
<img src="./res/fig_traj.png" width="100%"/>
<img src="./res/fig_traj_dflt.png" width="100%"/>
<img src="./res/fig_space.png" width="100%"/>
<img src="./res/fig_spots.png" width="100%"/>
<img src="./res/fig_aberration.png" width="100%"/>

|t1|t2|t3|t4|
|:---:|:---:|:---:|:---:|
|a|b|c|d|
|a|b|c|d|
|a|b|a_1 |$$a_1=2$$|



## end
#64, 62:
https://cdn.sj132.com//upload/icon/16822391076444ee831cd59.png
## end
#67, 29:
文档/S应用/周报告/20230609/fig2_.png
## end
#70, 29:
文档/S应用/周报告/20230609/fig3_.png
## end
#74, 221:

描述:...
+[新建阅读窗口](,描述)

结构::
+[删除结构](,结构)->+[分析结构图结构](描述,结构)->+[显示星图](,结构)

示意图:...
+[删除结构](,示意图)->+[召唤星辰]"一般结构转结构文字"(结构,示意图)
+[删除结构](,示意图)->+[召唤星辰]"一般结构转分类图"(结构,示意图)
+[PPT场景转H代码](示意图,示意图)
+[H函数](,示意图)
axis([-3,8,-15,15])
## end
#76, 576:
pySEM{
    object{
        lens,
        aperture,
        deflector,
        fieldObj,
        userDefined
    },
    world{
        field,
        volume
    },
    particle{
        electron,
        ion,
        photon
    },
    trajectory,
    brunch,

    messeger(Q),
    manager(Q),
    equation,
    solver
},

object{
    init,
    set,
    get,
    view
},

lens{
    init,
    set,
    get{
        getShape,
        getRadius,
        getField->field{Ex,Ey,Ez,Bx,By,Bz}
    },
    view,

    vars{
        r,
        R,
        U1,
        U2,
        U3
    }
}
## end
#78, 3653:
name#0"pySEM"(,)
name#1"object"(,)
name#2"lens"(,)
名字#3""(,name#2)
节点#4""(,名字#3)
name#5"aperture"(,)
名字#6""(,name#5)
节点#7""(,名字#6)
name#8"deflector"(,)
名字#9""(,name#8)
节点#10""(,名字#9)
name#11"fieldObj"(,)
名字#12""(,name#11)
节点#13""(,名字#12)
name#14"userDefined"(,)
名字#15""(,name#14)
节点#16""(,名字#15)
行#17""(行#18,节点#16)
行#18""(行#19,节点#13)
行#19""(行#20,节点#10)
行#20""(行#21,节点#7)
行#21""(名字#23,节点#4)
子集#22""(,行#21)
名字#23""(,name#1)
节点#24""(,名字#23)
name#25"world"(,)
name#26"field"(,)
名字#27""(,name#26)
节点#28""(,名字#27)
name#29"volume"(,)
名字#30""(,name#29)
节点#31""(,名字#30)
行#32""(行#33,节点#31)
行#33""(名字#35,节点#28)
子集#34""(,行#33)
名字#35""(,name#25)
节点#36""(,名字#35)
name#37"particle"(,)
name#38"electron"(,)
名字#39""(,name#38)
节点#40""(,名字#39)
name#41"ion"(,)
名字#42""(,name#41)
节点#43""(,名字#42)
name#44"photon"(,)
名字#45""(,name#44)
节点#46""(,名字#45)
行#47""(行#48,节点#46)
行#48""(行#49,节点#43)
行#49""(名字#51,节点#40)
子集#50""(,行#49)
名字#51""(,name#37)
节点#52""(,名字#51)
name#53"trajectory"(,)
名字#54""(,name#53)
节点#55""(,名字#54)
name#56"brunch"(,)
名字#57""(,name#56)
节点#58""(,名字#57)
name#59"messeger"(,)
text#60"Q"(名字#62,)
注释#61""(,text#60)
名字#62""(,name#59)
节点#63""(,名字#62)
name#64"manager"(,)
text#65"Q"(名字#67,)
注释#66""(,text#65)
名字#67""(,name#64)
节点#68""(,名字#67)
name#69"equation"(,)
名字#70""(,name#69)
节点#71""(,名字#70)
name#72"solver"(,)
名字#73""(,name#72)
节点#74""(,名字#73)
行#75""(行#76,节点#74)
行#76""(行#77,节点#71)
行#77""(行#78,节点#68)
行#78""(行#79,节点#63)
行#79""(行#80,节点#58)
行#80""(行#81,节点#55)
行#81""(行#82,节点#52)
行#82""(行#83,节点#36)
行#83""(名字#85,节点#24)
子集#84""(,行#83)
名字#85""(,name#0)
节点#86""(,名字#85)
name#87"object"(,)
name#88"init"(,)
名字#89""(,name#88)
节点#90""(,名字#89)
name#91"set"(,)
名字#92""(,name#91)
节点#93""(,名字#92)
name#94"get"(,)
名字#95""(,name#94)
节点#96""(,名字#95)
name#97"view"(,)
名字#98""(,name#97)
节点#99""(,名字#98)
行#100""(行#101,节点#99)
行#101""(行#102,节点#96)
行#102""(行#103,节点#93)
行#103""(名字#105,节点#90)
子集#104""(,行#103)
名字#105""(,name#87)
节点#106""(,名字#105)
name#107"lens"(,)
name#108"init"(,)
名字#109""(,name#108)
节点#110""(,名字#109)
name#111"set"(,)
名字#112""(,name#111)
节点#113""(,名字#112)
name#114"get"(,)
name#115"getShape"(,)
名字#116""(,name#115)
节点#117""(,名字#116)
name#118"getRadius"(,)
名字#119""(,name#118)
节点#120""(,名字#119)
name#121"getField"(,)
名字#122""(,name#121)
name#123"field"(,)
name#124"Ex"(,)
名字#125""(,name#124)
节点#126""(,名字#125)
name#127"Ey"(,)
名字#128""(,name#127)
节点#129""(,名字#128)
name#130"Ez"(,)
名字#131""(,name#130)
节点#132""(,名字#131)
name#133"Bx"(,)
名字#134""(,name#133)
节点#135""(,名字#134)
name#136"By"(,)
名字#137""(,name#136)
节点#138""(,名字#137)
name#139"Bz"(,)
名字#140""(,name#139)
节点#141""(,名字#140)
行#142""(行#143,节点#141)
行#143""(行#144,节点#138)
行#144""(行#145,节点#135)
行#145""(行#146,节点#132)
行#146""(行#147,节点#129)
行#147""(名字#149,节点#126)
子集#148""(,行#147)
名字#149""(,name#123)
节点#150""(节点#151,名字#149)
节点#151""(,名字#122)
行#152""(行#153,节点#151)
行#153""(行#154,节点#120)
行#154""(名字#156,节点#117)
子集#155""(,行#154)
名字#156""(,name#114)
节点#157""(,名字#156)
name#158"view"(,)
名字#159""(,name#158)
节点#160""(,名字#159)
name#161"vars"(,)
name#162"r"(,)
名字#163""(,name#162)
节点#164""(,名字#163)
name#165"R"(,)
名字#166""(,name#165)
节点#167""(,名字#166)
name#168"U1"(,)
名字#169""(,name#168)
节点#170""(,名字#169)
name#171"U2"(,)
名字#172""(,name#171)
节点#173""(,名字#172)
name#174"U3"(,)
名字#175""(,name#174)
节点#176""(,名字#175)
行#177""(行#178,节点#176)
行#178""(行#179,节点#173)
行#179""(行#180,节点#170)
行#180""(行#181,节点#167)
行#181""(名字#183,节点#164)
子集#182""(,行#181)
名字#183""(,name#161)
节点#184""(,名字#183)
行#185""(行#186,节点#184)
行#186""(行#187,节点#160)
行#187""(行#188,节点#157)
行#188""(行#189,节点#113)
行#189""(名字#191,节点#110)
子集#190""(,行#189)
名字#191""(,name#107)
节点#192""(,名字#191)
行#193""(行#194,节点#192)
行#194""(行#195,节点#106)
行#195""(,节点#86)
起点#196""(,行#195)

## end
#80, 10145:

<svg xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 1000 2727.272727272727" style="overflow: hidden;border: 2px solid #888888;"> 
<polygon points="204,1363 340,1363 340,1427 204,1427 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="386,2500 522,2500 522,2563 386,2563 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="386,2227 522,2227 522,2290 386,2290 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="568,2363 704,2363 704,2427 568,2427 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="568,2272 704,2272 704,2336 568,2336 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="568,2181 704,2181 704,2245 568,2245 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="568,2090 704,2090 704,2154 568,2154 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="386,1090 522,1090 522,1154 386,1154 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="568,1909 704,1909 704,1972 568,1972 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="568,1818 704,1818 704,1881 568,1881 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="568,1727 704,1727 704,1790 568,1790 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="568,1636 704,1636 704,1700 568,1700 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="568,1545 704,1545 704,1609 568,1609 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="568,1454 704,1454 704,1518 568,1518 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="568,1227 704,1227 704,1290 568,1290 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="750,1318 886,1318 886,1381 750,1381 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="750,1227 886,1227 886,1290 750,1290 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="750,1136 886,1136 886,1200 750,1200 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="568,909 704,909 704,972 568,972 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="750,954 886,954 886,1018 750,1018 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="750,863 886,863 886,927 750,927 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="568,500 704,500 704,563 568,563 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="750,681 886,681 886,745 750,745 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="750,590 886,590 886,654 750,654 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="750,500 886,500 886,563 750,563 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="750,409 886,409 886,472 750,472 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="750,318 886,318 886,381 750,381 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polyline points="340,1395 372,1395 372,2531 386,2531 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="340,1395 372,1395 372,2259 386,2259 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="340,1395 372,1395 372,1122 386,1122 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="522,2259 554,2259 554,2395 568,2395 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="522,2259 554,2259 554,2304 568,2304 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="522,2259 554,2259 554,2213 568,2213 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="522,2259 554,2259 554,2122 568,2122 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="522,1122 554,1122 554,1940 568,1940 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="522,1122 554,1122 554,1850 568,1850 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="522,1122 554,1122 554,1759 568,1759 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="522,1122 554,1122 554,1668 568,1668 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="522,1122 554,1122 554,1577 568,1577 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="522,1122 554,1122 554,1486 568,1486 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="522,1122 554,1122 554,1259 568,1259 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="522,1122 554,1122 554,940 568,940 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="522,1122 554,1122 554,531 568,531 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="704,1259 736,1259 736,1350 750,1350 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="704,1259 736,1259 736,1259 750,1259 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="704,1259 736,1259 736,1168 750,1168 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="704,940 736,940 736,986 750,986 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="704,940 736,940 736,895 750,895 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="704,531 736,531 736,713 750,713 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="704,531 736,531 736,622 750,622 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="704,531 736,531 736,531 750,531 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="704,531 736,531 736,440 750,440 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="704,531 736,531 736,349 750,349 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<text dominant-baseline="middle" text-anchor="middle" x="818.181818" y="350.000000" font-size="15">lens</text>
<text dominant-baseline="middle" text-anchor="middle" x="818.181818" y="440.909091" font-size="15">aperture</text>
<text dominant-baseline="middle" text-anchor="middle" x="818.181818" y="531.818182" font-size="15">deflector</text>
<text dominant-baseline="middle" text-anchor="middle" x="818.181818" y="622.727273" font-size="15">fieldObj</text>
<text dominant-baseline="middle" text-anchor="middle" x="818.181818" y="713.636364" font-size="15">userDefined</text>
<text dominant-baseline="middle" text-anchor="middle" x="636.363636" y="531.818182" font-size="15">object</text>
<text dominant-baseline="middle" text-anchor="middle" x="818.181818" y="895.454545" font-size="15">field</text>
<text dominant-baseline="middle" text-anchor="middle" x="818.181818" y="986.363636" font-size="15">volume</text>
<text dominant-baseline="middle" text-anchor="middle" x="636.363636" y="940.909091" font-size="15">world</text>
<text dominant-baseline="middle" text-anchor="middle" x="818.181818" y="1168.181818" font-size="15">electron</text>
<text dominant-baseline="middle" text-anchor="middle" x="818.181818" y="1259.090909" font-size="15">ion</text>
<text dominant-baseline="middle" text-anchor="middle" x="818.181818" y="1350.000000" font-size="15">photon</text>
<text dominant-baseline="middle" text-anchor="middle" x="636.363636" y="1259.090909" font-size="15">particle</text>
<text dominant-baseline="middle" text-anchor="middle" x="636.363636" y="1486.363636" font-size="15">trajectory</text>
<text dominant-baseline="middle" text-anchor="middle" x="636.363636" y="1577.272727" font-size="15">brunch</text>
<text dominant-baseline="middle" text-anchor="middle" x="636.363636" y="1668.181818" font-size="15">messeger</text>
<text dominant-baseline="middle" text-anchor="middle" x="636.363636" y="1759.090909" font-size="15">manager</text>
<text dominant-baseline="middle" text-anchor="middle" x="636.363636" y="1850.000000" font-size="15">equation</text>
<text dominant-baseline="middle" text-anchor="middle" x="636.363636" y="1940.909091" font-size="15">solver</text>
<text dominant-baseline="middle" text-anchor="middle" x="454.545455" y="1122.727273" font-size="15">pySEM</text>
<text dominant-baseline="middle" text-anchor="middle" x="636.363636" y="2122.727273" font-size="15">init</text>
<text dominant-baseline="middle" text-anchor="middle" x="636.363636" y="2213.636364" font-size="15">set</text>
<text dominant-baseline="middle" text-anchor="middle" x="636.363636" y="2304.545455" font-size="15">get</text>
<text dominant-baseline="middle" text-anchor="middle" x="636.363636" y="2395.454545" font-size="15">view</text>
<text dominant-baseline="middle" text-anchor="middle" x="454.545455" y="2259.090909" font-size="15">object</text>
<text dominant-baseline="middle" text-anchor="middle" x="454.545455" y="2531.818182" font-size="15">lens</text>
<text dominant-baseline="middle" text-anchor="middle" x="272.727273" y="1395.454545" font-size="15">起点</text>

</svg>


## end
#82, 133:
\nabla^{2} u+k u=\frac{\partial^{2}u}{\partial x^{2}}+\frac{\partial^{2}u}{\partial y^{2}}+\frac{\partial^{2}u}{\partial z^{2}}+k u=0
## end
#85, 60:
cd %地址;git pull;git commit -m \"%注释\";git add --all;git push
## end
#86, 53:
\nabla^2*u+k*u=\p{x,x}{u}+\p{y,y}{u}+\p{z,z}{u}+k*u=0
## end
#90, 85:
cd %地址;git pull origin master;git add .;git commit -am \"%注释\";git push origin master
## end
#92, 719:
┐
└lens
 └┐
  └init────set────get──────────────────────────────────────────────────────────────view────vars                      
                  └┐                                                                       └┐                        
                   └getShape────getRadius────getField                                       └r────R────U1────U2────U3
                                             field                                                                   
                                             └┐                                                                      
                                              └Ex────Ey────Ez────Bx────By────Bz                                      
## end
#95, 59:
t1, t2, t3, t4
a, b, c, d
a, b, c, d
a, b, a_1 , $$a_1=2$$

## end
#99, 2:
起点
## end
#101, 20:
12.0, 27.0, 2.0, 1.0
## end
#109, 8:
0.0, 0.0
## end
#115, 10:
0.0, -0.35
## end
#117, 2:
居中
## end
#121, 2:
起点
## end
#122, 22:
-0.0, -0.0, -0.7, -0.7
## end
#124, 24:
-0.75, 0.75, 0.75, -0.75
## end
#126, 3:
0.7
## end
#128, 3:
1.5
## end
#131, 3:
多边形
## end
#134, 10:
2.0, -12.5
## end
#140, 11:
2.0, -12.85
## end
#142, 2:
居中
## end
#146, 4:
lens
## end
#147, 22:
-0.0, -0.0, -0.7, -0.7
## end
#149, 24:
-0.75, 0.75, 0.75, -0.75
## end
#151, 3:
0.7
## end
#153, 3:
1.5
## end
#156, 3:
多边形
## end
#159, 9:
2.0, -9.5
## end
#165, 10:
2.0, -9.85
## end
#167, 2:
居中
## end
#171, 6:
object
## end
#172, 22:
-0.0, -0.0, -0.7, -0.7
## end
#174, 24:
-0.75, 0.75, 0.75, -0.75
## end
#176, 3:
0.7
## end
#178, 3:
1.5
## end
#181, 3:
多边形
## end
#184, 10:
4.0, -11.0
## end
#190, 11:
4.0, -11.35
## end
#192, 2:
居中
## end
#196, 4:
view
## end
#197, 22:
-0.0, -0.0, -0.7, -0.7
## end
#199, 24:
-0.75, 0.75, 0.75, -0.75
## end
#201, 3:
0.7
## end
#203, 3:
1.5
## end
#206, 3:
多边形
## end
#209, 10:
4.0, -10.0
## end
#215, 11:
4.0, -10.35
## end
#217, 2:
居中
## end
#221, 3:
get
## end
#222, 22:
-0.0, -0.0, -0.7, -0.7
## end
#224, 24:
-0.75, 0.75, 0.75, -0.75
## end
#226, 3:
0.7
## end
#228, 3:
1.5
## end
#231, 3:
多边形
## end
#234, 9:
4.0, -9.0
## end
#240, 10:
4.0, -9.35
## end
#242, 2:
居中
## end
#246, 3:
set
## end
#247, 22:
-0.0, -0.0, -0.7, -0.7
## end
#249, 24:
-0.75, 0.75, 0.75, -0.75
## end
#251, 3:
0.7
## end
#253, 3:
1.5
## end
#256, 3:
多边形
## end
#259, 9:
4.0, -8.0
## end
#265, 10:
4.0, -8.35
## end
#267, 2:
居中
## end
#271, 4:
init
## end
#272, 22:
-0.0, -0.0, -0.7, -0.7
## end
#274, 24:
-0.75, 0.75, 0.75, -0.75
## end
#276, 3:
0.7
## end
#278, 3:
1.5
## end
#281, 3:
多边形
## end
#284, 8:
2.0, 3.0
## end
#290, 9:
2.0, 2.65
## end
#292, 2:
居中
## end
#296, 5:
pySEM
## end
#297, 22:
-0.0, -0.0, -0.7, -0.7
## end
#299, 24:
-0.75, 0.75, 0.75, -0.75
## end
#301, 3:
0.7
## end
#303, 3:
1.5
## end
#306, 3:
多边形
## end
#309, 9:
4.0, -6.0
## end
#315, 10:
4.0, -6.35
## end
#317, 2:
居中
## end
#321, 6:
solver
## end
#322, 22:
-0.0, -0.0, -0.7, -0.7
## end
#324, 24:
-0.75, 0.75, 0.75, -0.75
## end
#326, 3:
0.7
## end
#328, 3:
1.5
## end
#331, 3:
多边形
## end
#334, 9:
4.0, -5.0
## end
#340, 10:
4.0, -5.35
## end
#342, 2:
居中
## end
#346, 8:
equation
## end
#347, 22:
-0.0, -0.0, -0.7, -0.7
## end
#349, 24:
-0.75, 0.75, 0.75, -0.75
## end
#351, 3:
0.7
## end
#353, 3:
1.5
## end
#356, 3:
多边形
## end
#359, 9:
4.0, -4.0
## end
#365, 10:
4.0, -4.35
## end
#367, 2:
居中
## end
#371, 7:
manager
## end
#372, 22:
-0.0, -0.0, -0.7, -0.7
## end
#374, 24:
-0.75, 0.75, 0.75, -0.75
## end
#376, 3:
0.7
## end
#378, 3:
1.5
## end
#381, 3:
多边形
## end
#384, 9:
4.0, -3.0
## end
#390, 10:
4.0, -3.35
## end
#392, 2:
居中
## end
#396, 8:
messeger
## end
#397, 22:
-0.0, -0.0, -0.7, -0.7
## end
#399, 24:
-0.75, 0.75, 0.75, -0.75
## end
#401, 3:
0.7
## end
#403, 3:
1.5
## end
#406, 3:
多边形
## end
#409, 9:
4.0, -2.0
## end
#415, 10:
4.0, -2.35
## end
#417, 2:
居中
## end
#421, 6:
brunch
## end
#422, 22:
-0.0, -0.0, -0.7, -0.7
## end
#424, 24:
-0.75, 0.75, 0.75, -0.75
## end
#426, 3:
0.7
## end
#428, 3:
1.5
## end
#431, 3:
多边形
## end
#434, 9:
4.0, -1.0
## end
#440, 10:
4.0, -1.35
## end
#442, 2:
居中
## end
#446, 10:
trajectory
## end
#447, 22:
-0.0, -0.0, -0.7, -0.7
## end
#449, 24:
-0.75, 0.75, 0.75, -0.75
## end
#451, 3:
0.7
## end
#453, 3:
1.5
## end
#456, 3:
多边形
## end
#459, 8:
4.0, 1.5
## end
#465, 9:
4.0, 1.15
## end
#467, 2:
居中
## end
#471, 8:
particle
## end
#472, 22:
-0.0, -0.0, -0.7, -0.7
## end
#474, 24:
-0.75, 0.75, 0.75, -0.75
## end
#476, 3:
0.7
## end
#478, 3:
1.5
## end
#481, 3:
多边形
## end
#484, 8:
6.0, 0.5
## end
#490, 24:
6.0, 0.15000000000000002
## end
#492, 2:
居中
## end
#496, 6:
photon
## end
#497, 22:
-0.0, -0.0, -0.7, -0.7
## end
#499, 24:
-0.75, 0.75, 0.75, -0.75
## end
#501, 3:
0.7
## end
#503, 3:
1.5
## end
#506, 3:
多边形
## end
#509, 8:
6.0, 1.5
## end
#515, 9:
6.0, 1.15
## end
#517, 2:
居中
## end
#521, 3:
ion
## end
#522, 22:
-0.0, -0.0, -0.7, -0.7
## end
#524, 24:
-0.75, 0.75, 0.75, -0.75
## end
#526, 3:
0.7
## end
#528, 3:
1.5
## end
#531, 3:
多边形
## end
#534, 8:
6.0, 2.5
## end
#540, 9:
6.0, 2.15
## end
#542, 2:
居中
## end
#546, 8:
electron
## end
#547, 22:
-0.0, -0.0, -0.7, -0.7
## end
#549, 24:
-0.75, 0.75, 0.75, -0.75
## end
#551, 3:
0.7
## end
#553, 3:
1.5
## end
#556, 3:
多边形
## end
#559, 8:
4.0, 5.0
## end
#565, 9:
4.0, 4.65
## end
#567, 2:
居中
## end
#571, 5:
world
## end
#572, 22:
-0.0, -0.0, -0.7, -0.7
## end
#574, 24:
-0.75, 0.75, 0.75, -0.75
## end
#576, 3:
0.7
## end
#578, 3:
1.5
## end
#581, 3:
多边形
## end
#584, 8:
6.0, 4.5
## end
#590, 9:
6.0, 4.15
## end
#592, 2:
居中
## end
#596, 6:
volume
## end
#597, 22:
-0.0, -0.0, -0.7, -0.7
## end
#599, 24:
-0.75, 0.75, 0.75, -0.75
## end
#601, 3:
0.7
## end
#603, 3:
1.5
## end
#606, 3:
多边形
## end
#609, 8:
6.0, 5.5
## end
#615, 9:
6.0, 5.15
## end
#617, 2:
居中
## end
#621, 5:
field
## end
#622, 22:
-0.0, -0.0, -0.7, -0.7
## end
#624, 24:
-0.75, 0.75, 0.75, -0.75
## end
#626, 3:
0.7
## end
#628, 3:
1.5
## end
#631, 3:
多边形
## end
#634, 8:
4.0, 9.5
## end
#640, 9:
4.0, 9.15
## end
#642, 2:
居中
## end
#646, 6:
object
## end
#647, 22:
-0.0, -0.0, -0.7, -0.7
## end
#649, 24:
-0.75, 0.75, 0.75, -0.75
## end
#651, 3:
0.7
## end
#653, 3:
1.5
## end
#656, 3:
多边形
## end
#659, 8:
6.0, 7.5
## end
#665, 9:
6.0, 7.15
## end
#667, 2:
居中
## end
#671, 11:
userDefined
## end
#672, 22:
-0.0, -0.0, -0.7, -0.7
## end
#674, 24:
-0.75, 0.75, 0.75, -0.75
## end
#676, 3:
0.7
## end
#678, 3:
1.5
## end
#681, 3:
多边形
## end
#684, 8:
6.0, 8.5
## end
#690, 9:
6.0, 8.15
## end
#692, 2:
居中
## end
#696, 8:
fieldObj
## end
#697, 22:
-0.0, -0.0, -0.7, -0.7
## end
#699, 24:
-0.75, 0.75, 0.75, -0.75
## end
#701, 3:
0.7
## end
#703, 3:
1.5
## end
#706, 3:
多边形
## end
#709, 8:
6.0, 9.5
## end
#715, 9:
6.0, 9.15
## end
#717, 2:
居中
## end
#721, 9:
deflector
## end
#722, 22:
-0.0, -0.0, -0.7, -0.7
## end
#724, 24:
-0.75, 0.75, 0.75, -0.75
## end
#726, 3:
0.7
## end
#728, 3:
1.5
## end
#731, 3:
多边形
## end
#734, 9:
6.0, 10.5
## end
#740, 10:
6.0, 10.15
## end
#742, 2:
居中
## end
#746, 8:
aperture
## end
#747, 22:
-0.0, -0.0, -0.7, -0.7
## end
#749, 24:
-0.75, 0.75, 0.75, -0.75
## end
#751, 3:
0.7
## end
#753, 3:
1.5
## end
#756, 3:
多边形
## end
#759, 9:
6.0, 11.5
## end
#765, 10:
6.0, 11.15
## end
#767, 2:
居中
## end
#771, 4:
lens
## end
#772, 22:
-0.0, -0.0, -0.7, -0.7
## end
#774, 24:
-0.75, 0.75, 0.75, -0.75
## end
#776, 3:
0.7
## end
#778, 3:
1.5
## end
#781, 3:
多边形
## end
#782, 28:
-0.35, -0.35, -12.85, -12.85
## end
#784, 20:
0.75, 1.1, 1.1, 1.25
## end
#787, 2:
曲线
## end
#790, 26:
-0.35, -0.35, -9.85, -9.85
## end
#792, 20:
0.75, 1.1, 1.1, 1.25
## end
#795, 2:
曲线
## end
#798, 24:
-0.35, -0.35, 2.65, 2.65
## end
#800, 20:
0.75, 1.1, 1.1, 1.25
## end
#803, 2:
曲线
## end
#806, 28:
-9.85, -9.85, -11.35, -11.35
## end
#808, 20:
2.75, 3.1, 3.1, 3.25
## end
#811, 2:
曲线
## end
#814, 28:
-9.85, -9.85, -10.35, -10.35
## end
#816, 20:
2.75, 3.1, 3.1, 3.25
## end
#819, 2:
曲线
## end
#822, 26:
-9.85, -9.85, -9.35, -9.35
## end
#824, 20:
2.75, 3.1, 3.1, 3.25
## end
#827, 2:
曲线
## end
#830, 26:
-9.85, -9.85, -8.35, -8.35
## end
#832, 20:
2.75, 3.1, 3.1, 3.25
## end
#835, 2:
曲线
## end
#838, 24:
2.65, 2.65, -6.35, -6.35
## end
#840, 20:
2.75, 3.1, 3.1, 3.25
## end
#843, 2:
曲线
## end
#846, 24:
2.65, 2.65, -5.35, -5.35
## end
#848, 20:
2.75, 3.1, 3.1, 3.25
## end
#851, 2:
曲线
## end
#854, 24:
2.65, 2.65, -4.35, -4.35
## end
#856, 20:
2.75, 3.1, 3.1, 3.25
## end
#859, 2:
曲线
## end
#862, 24:
2.65, 2.65, -3.35, -3.35
## end
#864, 20:
2.75, 3.1, 3.1, 3.25
## end
#867, 2:
曲线
## end
#870, 24:
2.65, 2.65, -2.35, -2.35
## end
#872, 20:
2.75, 3.1, 3.1, 3.25
## end
#875, 2:
曲线
## end
#878, 24:
2.65, 2.65, -1.35, -1.35
## end
#880, 20:
2.75, 3.1, 3.1, 3.25
## end
#883, 2:
曲线
## end
#886, 22:
2.65, 2.65, 1.15, 1.15
## end
#888, 20:
2.75, 3.1, 3.1, 3.25
## end
#891, 2:
曲线
## end
#894, 22:
2.65, 2.65, 4.65, 4.65
## end
#896, 20:
2.75, 3.1, 3.1, 3.25
## end
#899, 2:
曲线
## end
#902, 22:
2.65, 2.65, 9.15, 9.15
## end
#904, 20:
2.75, 3.1, 3.1, 3.25
## end
#907, 2:
曲线
## end
#910, 52:
1.15, 1.15, 0.15000000000000002, 0.15000000000000002
## end
#912, 20:
4.75, 5.1, 5.1, 5.25
## end
#915, 2:
曲线
## end
#918, 22:
1.15, 1.15, 1.15, 1.15
## end
#920, 20:
4.75, 5.1, 5.1, 5.25
## end
#923, 2:
曲线
## end
#926, 22:
1.15, 1.15, 2.15, 2.15
## end
#928, 20:
4.75, 5.1, 5.1, 5.25
## end
#931, 2:
曲线
## end
#934, 22:
4.65, 4.65, 4.15, 4.15
## end
#936, 20:
4.75, 5.1, 5.1, 5.25
## end
#939, 2:
曲线
## end
#942, 22:
4.65, 4.65, 5.15, 5.15
## end
#944, 20:
4.75, 5.1, 5.1, 5.25
## end
#947, 2:
曲线
## end
#950, 22:
9.15, 9.15, 7.15, 7.15
## end
#952, 20:
4.75, 5.1, 5.1, 5.25
## end
#955, 2:
曲线
## end
#958, 22:
9.15, 9.15, 8.15, 8.15
## end
#960, 20:
4.75, 5.1, 5.1, 5.25
## end
#963, 2:
曲线
## end
#966, 22:
9.15, 9.15, 9.15, 9.15
## end
#968, 20:
4.75, 5.1, 5.1, 5.25
## end
#971, 2:
曲线
## end
#974, 24:
9.15, 9.15, 10.15, 10.15
## end
#976, 20:
4.75, 5.1, 5.1, 5.25
## end
#979, 2:
曲线
## end
#982, 24:
9.15, 9.15, 11.15, 11.15
## end
#984, 20:
4.75, 5.1, 5.1, 5.25
## end
#987, 2:
曲线
## end
#991, 39:
/home/xiantao/Documents/Projects/py-sem
## end
#993, 30:
https://gitee.com/zz303/py-sem
## end
#995, 295:
"""
参考2::https://stackoverflow.com/questions/28269157/plotting-in-a-non-blocking-way-with-matplotlib

记住"Python"
+[P函数](,测试package)

例子_patch:...

"""
import numpy as np

import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle

plt.figure(1)
plt.gca().add_patch()
plt.show()




## end
#997, 130:
https://matplotlib.org/stable/gallery/shapes_and_collections/path_patch.html#sphx-glr-gallery-shapes-and-collections-path-patch-py
## end
#999, 986:
"""
参考::https://matplotlib.org/stable/gallery/shapes_and_collections/path_patch.html#sphx-glr-gallery-shapes-and-collections-path-patch-py
+[打开网页](,参考)
+[P函数](,例子_patch)

"""
import matplotlib.path as mpath
import matplotlib.patches as mpatches
import matplotlib.pyplot as plt

fig, ax = plt.subplots()

Path = mpath.Path
path_data = [
    (Path.MOVETO, (1.58, -2.57)),
    (Path.CURVE4, (0.35, -1.1)),
    (Path.CURVE4, (-1.75, 2.0)),
    (Path.CURVE4, (0.375, 2.0)),
    (Path.LINETO, (0.85, 1.15)),
    (Path.CURVE4, (2.2, 3.2)),
    (Path.CURVE4, (3, 0.05)),
    (Path.CURVE4, (2.0, -0.5)),
    (Path.CLOSEPOLY, (1.58, -2.57)),
    ]
codes, verts = zip(*path_data)
path = mpath.Path(verts, codes)
patch = mpatches.PathPatch(path, facecolor='r', alpha=0.5)
ax.add_patch(patch)

# plot control points and connecting lines
x, y = zip(*path.vertices)
line, = ax.plot(x, y, 'go-')

ax.grid()
ax.axis('equal')
# plt.ion()
plt.show()
plt.pause(0.001)

"""
plt.ioff()
+[P函数](,例子_patch)

"""
## end
#1001, 91:
https://stackoverflow.com/questions/28269157/plotting-in-a-non-blocking-way-with-matplotlib
## end
#1003, 773:
"""
P代码:...
+[新建阅读窗口](,P代码)
模板:...

"""
+保存P函数(,_P函数)->+[del](,+保存P函数)...
->的(保存P函数,P代码)->的(保存P函数,模板)...

->的(_P函数,地址)...
->[]{
    []:->的(_P函数,作者)->作者, ->+的(_P函数,+作者)
}->的(_P函数,作者)...

->+[python](Python,+[临时文本])->+[code](+[python],P代码)...
->+[.]"code"(+[python],_P函数)...
->+[s]"authors0"(+[python],作者)->+[o]"authors"(+[python],作者)...
->+[s]"author0"(+[python],+[临时文本]#a)->[m_text](+保存P函数,+[临时文本]#a)...

->+[o]"date_str0"(+[python],+[临时文本]#d)->[]{
    []:->的(_P函数,创造日期)->创造日期,
    ->+的(_P函数,+创造日期)->+[o]"date_str"(+[python],+创造日期)
}->的(_P函数,创造日期)...

->+[模板文本](模板,+[临时文本]#out)...
->+[.]"内容"(+[模板文本],+[临时文本])->+[.](+[模板文本],作者)...
->+[.]"日期1"(+[模板文本],创造日期)->+[.]"日期2"(+[模板文本],+[临时文本]#d)...

->[]{
    []:->[==](,地址)->+[消息窗口](,+[临时文本]#out),
    ->+[保存文本](地址,+[临时文本]#out)
}



## end
#1005, 774:
"""
记住"Python"
参考::https://docs.python.org/3/howto/regex.html#greedy-versus-non-greedy
+[打开文件夹]"tools/tools_acts.py"

"""

import re
from datetime import datetime
ans=re.sub(r'^\s*"""[\d\D]*?"""\n','',code)

now=datetime.now()
date_str0=now.strftime("%Y-%m-%d %a %H:%M:%S")
date_str=now.strftime("%Y-%m-%d %a %H:%M:%S")

author0=re.sub(r"^\s*","",author0)
author0=re.sub(r"\s*$","",author0)
if authors0=="":
    authors=author0
else:
    authors=authors0
    list_au=authors0.split(", ")
    list_au_in=author0.split(", ")
    for au_in in list_au_in:
        in_state=False
        for au in list_au:
            if au.casefold()==au_in.casefold():
                in_state=True
                break
        if not in_state and au_in!="":
            authors+=", "+au_in


## end
#1007, 83:
# -*- coding: utf-8 -*-
"""
Created on %日期1
Updated on %日期2

@author: %作者
"""
%内容


## end
#1011, 23:
2023-06-12 Mon 22:53:11
## end
#1013, 23:
Xiantao Cheng, Ze Zhang
## end
#1016, 14473:
"""
地址::/home/xiantao/Documents/Projects/py-sem/src/elements.py
+[保存P函数]"Xiantao Cheng, Ze Zhang"(,elements)
+[P函数](,elements)
+[打开文件夹]"body"
ource

测试画图:...
测试patch:...
测试电子源:...
测试元件:...
+[新建阅读窗口](,测试画图)
+[新建阅读窗口](,测试电子源)
uniform

"""

import numpy as np
import matplotlib.pyplot as plt

from src.basic_tools import *
from src.matlab_style_draw import *


class Element:
    def __init__(self):
        pass
    def set(self):
        pass
    def get(self):
        pass

    def view(self, fig_num=None):
        plt.figure(fig_num)
        ax=plt.gca()
        self.add_shape(ax)
        ax.grid()
        ax.axis('equal')
        plt.show()

    def get_EField(self):
        Ex=lambda x,y,z: 0*x
        Ey=lambda x,y,z: 0*x
        Ez=lambda x,y,z: 0*x
        return Ex,Ey,Ez

    def get_BField(self):
        Bx=lambda x,y,z: 0*x
        By=lambda x,y,z: 0*x
        Bz=lambda x,y,z: 0*x
        return Bx,By,Bz

    def getPos(self):
        return self.m_pos[0],self.m_pos[1],0


    def info(self):
        info_txt="%s(%s)"%(self.m_name,self.m_type)
        return info_txt
    def __str__(self):
        return self.info()


class Lens(Element):
    def __init__(self, name="undefined", x=0., y=0., r=1.e-3, R=10.e-2, D=5.e-2, U=-0.6e2):
        self.m_name=name
        self.m_type="lens"
        self.m_r=r
        self.m_R=R
        self.m_D=D
        self.m_U=U
        self.m_pos=[x,y]

    def add_shape(self, ax, color_str='b'):
        W1=1.e-3
        H1=self.m_R-self.m_r
        W2=1.e-3
        H2=self.m_R-self.m_r
        
        r=self.m_r
        d=self.m_D
        
        x1=np.array([0,0,1,1])*W1+self.m_pos[0]
        y1=np.array([-1,1,1,-1])*H1/2+self.m_pos[1]
        x2=np.array([0,0,1,1])*W2+self.m_pos[0]
        y2=np.array([-1,1,1,-1])*H2/2+self.m_pos[1]
        
        patch00 = patch_from_xy(x1-W1-W2/2-d,y1+H1/2+r/2,'b')
        ax.add_patch(patch00)
        patch01 = patch_from_xy(x1-W1-W2/2-d,y1-H1/2-r/2,'b')
        ax.add_patch(patch01)
        
        patch10 = patch_from_xy(x2-W2/2,y2+H2/2+r/2,'b')
        ax.add_patch(patch10)
        patch11 = patch_from_xy(x2-W2/2,y2-H2/2-r/2,'b')
        ax.add_patch(patch11)
        
        patch20 = patch_from_xy(x1+W2/2+d,y1+H1/2+r/2,'b')
        ax.add_patch(patch20)
        patch21 = patch_from_xy(x1+W2/2+d,y1-H1/2-r/2,'b')
        ax.add_patch(patch21)

    def get_EField(self):
        R=self.m_r
        D=self.m_D
        E_0=self.m_U
#         E_0=-0.6e2
        dR=0.1*R

        x1=self.m_pos[0]-D
        x2=self.m_pos[0]
        x3=self.m_pos[0]+D
        y0=self.m_pos[1]


        a=lambda r: np.sqrt(1/(R**2-r**2)*np.heaviside(R-dR>np.abs(r),0.)) \
            +1/dR*np.heaviside(R-dR<=np.abs(r),0.)
        u=lambda z,r: -1/a(r)*np.log(np.cosh(z*a(r)))-np.log(2)/a(r)
        r=lambda y,z: np.sqrt(y**2+z**2)+1.e-8

        E_x=lambda x,y,z: np.tanh(x*a(r(y,z)))
        E_r=lambda x,y,z: (u(x,r(y,z))+E_x(x,y,z)*x)*r(y,z)*a(r(y,z))**2
        E_y=lambda x,y,z: E_r(x,y,z)*y/r(y,z)
        E_z=lambda x,y,z: E_r(x,y,z)*z/r(y,z)

        Ex=lambda x,y,z: -E_0/2*E_x(x-x1,y-y0,z) + E_0*E_x(x-x2,y-y0,z) + \
                                  -E_0/2*E_x(x-x3,y-y0,z)
        Ey=lambda x,y,z: -E_0/2*E_y(x-x1,y-y0,z) + E_0*E_y(x-x2,y-y0,z) + \
                                  -E_0/2*E_y(x-x3,y-y0,z)
        Ez=lambda x,y,z: -E_0/2*E_z(x-x1,y-y0,z) + E_0*E_z(x-x2,y-y0,z) + \
                                  -E_0/2*E_z(x-x3,y-y0,z)

        # Ex=lambda x,y,z: E_0*E_x(x-x2,y-y0,z)
        # Ey=lambda x,y,z: E_0*E_y(x-x2,y-y0,z)


        return Ex,Ey,Ez

"""
+[P函数](,elements)

"""


class Aperture(Element):
    def __init__(self, name="undefined", x=0., y=0., r_inner=1.e-3, r_outer=1.e-2):
        self.m_name=name
        self.m_type="aperture"
        self.m_r=r_inner
        self.m_R=r_outer
        self.m_D=1.e-3
        self.m_pos=[x,y]

    def add_shape(self, ax, color_str='b'):
        W1=self.m_D
        H1=self.m_R-self.m_r
        
        r=self.m_r
        
        x1=np.array([0,0,1,1])*W1+self.m_pos[0]
        y1=np.array([-1,1,1,-1])*H1/2+self.m_pos[1]
        
        patch10 = patch_from_xy(x1-W1/2,y1+H1/2+r/2,'k')
        ax.add_patch(patch10)
        patch11 = patch_from_xy(x1-W1/2,y1-H1/2-r/2,'k')
        ax.add_patch(patch11)


class Deflector(Element):
    def __init__(self, name="undefined", x=0., y=0., r_inner=0.9e-2, r_outer=1.e-2):
        self.m_name=name
        self.m_type="deflector"
        self.m_r=r_inner
        self.m_R=r_outer
        self.m_D=1.e-2
        self.m_pos=[x,y]

    def add_shape(self, ax, color_str='b'):
        W1=self.m_D
        H1=self.m_R-self.m_r
        
        r=self.m_r
        
        x1=np.array([0,0,1,1])*W1+self.m_pos[0]
        y1=np.array([-1,1,1,-1])*H1/2+self.m_pos[1]
        
        patch10 = patch_from_xy(x1-W1/2,y1+H1/2+r/2,'k')
        ax.add_patch(patch10)
        patch11 = patch_from_xy(x1-W1/2,y1-H1/2-r/2,'k')
        ax.add_patch(patch11)


class UniformField(Element):
    def __init__(self, name="undefined", x=0., y=0., W=1.e-2, H=1.e-2,B=None,E=None):
        self.m_name=name
        self.m_type="uniform field"
        self.m_W=W
        self.m_H=H
        self.m_B=B
        self.m_E=E
        self.m_pos=[x,y]

    def add_shape(self, ax, color_str='b'):
        W1=self.m_W
        H1=self.m_H
        
        x1=np.array([0,0,1,1])*W1+self.m_pos[0]
        y1=np.array([-1,1,1,-1])*H1/2+self.m_pos[1]
        
        patch10 = patch_from_xy(x1,y1,'k')
        ax.add_patch(patch10)

    def set_field(B=None,E=None):
        self.m_B=B
        self.m_E=E

    def get_BField(self):
        if self.m_B==None:
            B=[0.,0.,0.]
        else:
            B=self.m_B
        H=self.m_H
        W=self.m_W
        x0=self.m_pos[0]
        y0=self.m_pos[1]

        x1=x0
        x2=x0+W
        y1=y0-H/2
        y2=y0+H/2

        Bx = lambda X,Y,Z: np.heaviside(X-x1,1.)*np.heaviside(x2-X,1.) \
            *np.heaviside(Y-y1,1.)*np.heaviside(y2-Y,1.)*B[0]
        By = lambda X,Y,Z: np.heaviside(X-x1,1.)*np.heaviside(x2-X,1.) \
            *np.heaviside(Y-y1,1.)*np.heaviside(y2-Y,1.)*B[1]
        Bz=lambda X,Y,Z: np.heaviside(X-x1,1.)*np.heaviside(x2-X,1.) \
            *np.heaviside(Y-y1,1.)*np.heaviside(y2-Y,1.)*B[2]
        return Bx, By, Bz

    def get_EField(self):
        if self.m_E==None:
            E=[0.,0.,0.]
        else:
            E=self.m_E
        H=self.m_H
        W=self.m_W
        x0=self.m_pos[0]
        y0=self.m_pos[1]

        x1=x0
        x2=x0+W
        y1=y0-H/2
        y2=y0+H/2

        Ex = lambda X,Y,Z: np.heaviside(X-x1,1.)*np.heaviside(x2-X,1.) \
            *np.heaviside(Y-y1,1.)*np.heaviside(y2-Y,1.)*E[0]
        Ey = lambda X,Y,Z: np.heaviside(X-x1,1.)*np.heaviside(x2-X,1.) \
            *np.heaviside(Y-y1,1.)*np.heaviside(y2-Y,1.)*E[1]
        Ez=lambda X,Y,Z: np.heaviside(X-x1,1.)*np.heaviside(x2-X,1.) \
            *np.heaviside(Y-y1,1.)*np.heaviside(y2-Y,1.)*E[2]
        return Ex, Ey, Ez


class PointField(Element):
    def __init__(self, name="undefined", x=0., y=0., r=0.3e-2, Q=1.):
        self.m_name=name
        self.m_type="point field"
        self.m_Q=Q
        self.m_r=r
        self.m_pos=[x,y]

    def add_shape(self, ax, color_str='b'):
        r1=self.m_r
        
        x1=self.m_pos[0]
        y1=self.m_pos[1]
        
        circle0 = circle_from_pt_r(x1,y1,r1,color_str)
        ax.add_patch(circle0)

    def get_EField(self):
        Q=self.m_Q
        r=self.m_r
        x0=self.m_pos[0]
        y0=self.m_pos[1]
        z0=0.

        R = lambda X,Y,Z: np.sqrt((X-x0)**2+(Y-y0)**2+(Z-z0)**2)

        R3 = lambda X,Y,Z: R(X,Y,Z)**3 + np.heaviside(r*0.9-R(X,Y,Z),1.)

        Ex = lambda X,Y,Z: Q * (X-x0)/R3(X,Y,Z) * np.heaviside(R(X,Y,Z)-r,1.)
        Ey = lambda X,Y,Z: Q * (Y-y0)/R3(X,Y,Z)  * np.heaviside(R(X,Y,Z)-r,1.)
        Ez = lambda X,Y,Z: Q * (Z-z0)/R3(X,Y,Z) * np.heaviside(R(X,Y,Z)-r,1.)
        return Ex, Ey, Ez


"""
记住"Python"
print(np.random.rand(10))
+[P函数](,elements)

"""

class MagneticDipole(Element):
    def __init__(self, name="undefined", x=0., y=0., an0=0., r=0.2e-2, R=1.e-2, I=1.):
        self.m_name=name
        self.m_type="magnetic dipole"
        self.m_r=r
        self.m_R=R
        self.m_I=I
        self.m_an=an0
        self.m_pos=[x,y]

    def add_shape(self, ax, color_str='b'):
        H1=self.m_R
        r=self.m_r
        an0=self.m_an
        
        an0=an0/180*np.pi
        x = np.array([-H1,-H1,H1,H1])
        y = np.array([-r,r,r,-r])
        x1 = self.m_pos[0]+x*np.cos(an0)-y*np.sin(an0)
        y1 = self.m_pos[1]+x*np.sin(an0)+y*np.cos(an0)

        xc = np.array([-H1,H1])
        yc = np.array([0,0])
        xc1 = self.m_pos[0]+xc*np.cos(an0)-yc*np.sin(an0)
        yc1 = self.m_pos[1]+xc*np.sin(an0)+yc*np.cos(an0)

        patch1 = patch_from_xy(x1,y1,color_str)
        ax.add_patch(patch1)
        circle0 = circle_from_pt_r(xc1[0],yc1[0],r,color_str)
        ax.add_patch(circle0)
        circle1 = circle_from_pt_r(xc1[1],yc1[1],r,color_str)
        ax.add_patch(circle1)

    def get_BField(self):
        I=self.m_I
        R=self.m_R
        mu_0=1
        an0=self.m_an
        x0=self.m_pos[0]
        y0=self.m_pos[1]
        z0=0
        
        theta=an0/180*np.pi
        r1 = lambda x,y,z: np.sqrt(x**2+y**2+z**2)
        R1 = lambda x,y,z: r1(x,y,z) + np.heaviside(R*0.1-r1(x,y,z),1.)
        R5 = lambda x,y,z: r1(x,y,z)**5 + np.heaviside(R*0.1-r1(x,y,z),1.)

        x = lambda X,Y,Z: (X-x0)*np.cos(theta) + (Y-y0)*np.sin(theta)
        y = lambda X,Y,Z:-(X-x0)*np.sin(theta) + (Y-y0)*np.cos(theta)
        z = lambda X,Y,Z: (Z-z0)
        rho = lambda X,Y,Z: np.sqrt(x(X,Y,Z)**2+z(X,Y,Z)**2)+1e-9

        Br = lambda x,y,z: (mu_0*(I*np.pi*R**2))/(4*np.pi) \
                *(3*y*np.sqrt(x**2+z**2)) / R5(x,y,z)
        By = lambda x,y,z: (mu_0*(I*np.pi*R**2))/(4*np.pi) \
                *(3*R**2-3*(x**2+z**2)) / R5(x,y,z)

        BX = lambda X,Y,Z: \
                x(X,Y,Z)/rho(X,Y,Z)*np.cos(theta)*Br(x(X,Y,Z),y(X,Y,Z),z(X,Y,Z)) \
                    -np.sin(theta)*By(x(X,Y,Z),y(X,Y,Z),z(X,Y,Z))

        BY = lambda X,Y,Z: \
                x(X,Y,Z)/rho(X,Y,Z)*np.sin(theta)*Br(x(X,Y,Z),y(X,Y,Z),z(X,Y,Z)) \
                    +np.cos(theta)*By(x(X,Y,Z),y(X,Y,Z),z(X,Y,Z))

        BZ = lambda X,Y,Z: \
                z(X,Y,Z)/rho(X,Y,Z)*Br(x(X,Y,Z),y(X,Y,Z),z(X,Y,Z))

        return BX, BY, BZ

"""
z(X,Y,Z)/rho(X,Y,Z)*Br(x(X,Y,Z),y(X,Y,Z),z(X,Y,Z))
print(np.ones(10))
print(np.random.rand(10))
+[P函数](,elements)

保存B_field:...

"""

class Screen(Element):
    def __init__(self, name="undefined", x=0., y=0., an0=0., D=10.e-3, H=10.e-3):
        self.m_name=name
        self.m_type="screen"
        self.m_D=D
        self.m_H=H
        self.m_an=an0
        self.m_pos=[x,y]

    def add_shape(self, ax, color_str='k'):
        D=self.m_D
        H=self.m_H
        d=1.e-3
        an0=self.m_an
        an0=an0*np.pi/180
        
        x=np.array([0,0,1,1])*d
        y=np.array([1,-1,-1,1])*H/2
        x1=self.m_pos[0]+x*np.cos(an0)-y*np.sin(an0)
        y1=self.m_pos[1]+x*np.sin(an0)+y*np.cos(an0)

        patch1 = patch_from_xy(x1,y1,color_str)
        ax.add_patch(patch1)

    def getLocalFrame(self):
        an0=self.m_an
        an0=an0*np.pi/180
        
        vx_f=np.array([0,0,1])
        vy_f=np.array([-np.sin(an0),np.cos(an0),0])
        vz_f=np.array([np.cos(an0),np.sin(an0),0])
        return vx_f,vy_f,vz_f


class Source(Element):
    def __init__(self, name="undefined", x=0., y=0., an0=0., Dan=30., r=0.1e-2, R=1.e-2, srcType="regular", fileName="res/data/G.txt"):
        self.m_name=name
        self.m_type="source"
        self.m_r=r
        self.m_R=R
        self.m_an=an0
        self.m_da=Dan

        self.m_srcType=srcType
        self.m_fileName=fileName

        self.m_pos=[x,y]

    def add_shape(self, ax, color_str='k'):
        R=self.m_R
        r=self.m_r
        an0=self.m_an
        Dan=self.m_da
        
        x=self.m_pos[0]
        y=self.m_pos[1]

        ts=np.linspace(-Dan/2,Dan/2,30)+an0
        ans=ts*np.pi/180
        x1=R*np.cos(ans)+x
        y1=R*np.sin(ans)+y
        x1[0]=x
        x1[-1]=x
        y1[0]=y
        y1[-1]=y

        patch1 = patch_from_xy(x1,y1,color_str)
        ax.add_patch(patch1)
        circle0 = circle_from_pt_r(x,y,r,color_str)
        ax.add_patch(circle0)

    def genSeed(self,n,dist_type=None,file_name="文档/项目/pySEM/G.txt"):
        if dist_type==None:
            dist_type=self.m_srcType
            file_name=self.m_fileName

        if dist_type=="rand":
            x,y,z,v_x,v_y,v_z=self.genSeed_rand(n)
        elif dist_type=="regular":
            x,y,z,v_x,v_y,v_z=self.genSeed_regular(n)
        elif dist_type=="file":
            x,y,z,v_x,v_y,v_z=self.genSeed_file(n,file_name)
        else:
            x,y,z,v_x,v_y,v_z=self.genSeed_rand(n)

        return x,y,z,v_x,v_y,v_z


    def genSeed_file(self,n,file_name):
        x0=self.m_pos[0]
        y0=self.m_pos[1]

        v_x,v_y,v_z=fromG4File_dist(n,file_name)

        n=len(v_x)
        x=np.ones(n)*x0
        y=np.ones(n)*y0
        z=np.ones(n)*0

        return x,y,z,v_x,v_y,v_z


    def genSeed_regular(self,n):
        x0=self.m_pos[0]
        y0=self.m_pos[1]
        an0=self.m_an
        Dan=self.m_da
    
        x=np.ones(n)*x0
        y=np.ones(n)*y0
        z=np.ones(n)*0
        
        x0,y0,ts,ts2=sunflower_dist(n,0.01)
        ts1=ts*Dan/2*np.pi/180
        t0=an0*np.pi/180
        v0=2.
        
        v_x0=v0*np.cos(ts1)
        v_y0=v0*np.sin(ts1)*np.cos(ts2)
        v_z0=v0*np.sin(ts1)*np.sin(ts2)

        v_x=v_x0*np.cos(t0)-v_y0*np.sin(t0)
        v_y=v_x0*np.sin(t0)+v_y0*np.cos(t0)
        v_z=v_z0

        return x,y,z,v_x,v_y,v_z


    def genSeed_rand(self,n):
        x0=self.m_pos[0]
        y0=self.m_pos[1]
        an0=self.m_an
        Dan=self.m_da
    
        x=np.ones(n)*x0
        y=np.ones(n)*y0
        z=np.ones(n)*0
        
        ans=np.random.rand(n)*Dan-Dan/2
        t0=an0*np.pi/180
        ts1=ans*np.pi/180
        ts2=np.random.rand(n)*2*np.pi
        v0=2.
        
        v_x0=v0*np.cos(ts1)
        v_y0=v0*np.sin(ts1)*np.cos(ts2)
        v_z0=v0*np.sin(ts1)*np.sin(ts2)

        v_x=v_x0*np.cos(t0)-v_y0*np.sin(t0)
        v_y=v_x0*np.sin(t0)+v_y0*np.cos(t0)
        v_z=v_z0

        return x,y,z,v_x,v_y,v_z





"""
print(np.ones(10))
print(np.random.rand(10))
+[P函数](,elements)

"""
## end
#1018, 55:
/home/xiantao/Documents/Projects/py-sem/src/elements.py
## end
#1019, 23:
2023-06-12 Mon 23:51:50
## end
#1021, 23:
Xiantao Cheng, Ze Zhang
## end
#1024, 800:
"""
+[P函数](,测试画图)
matlab_style_draw:...
+[P函数](,matlab_style_draw)
+[新建阅读窗口](,matlab_style_draw)
+[复制结构](,matlab_style_draw)

单个lens:...
多个lens:...
测试aperture:...
+[新建阅读窗口](,单个lens)

"""
import numpy as np
import matplotlib.pyplot as plt

ele_1=Lens(x=0.,y=2.1e-2, r=1.e-3, R=10.e-3, D=1.e-3)
ele_2=Aperture(x=5.e-2,y=2.1e-2)
ele_3=Deflector(x=8.e-2,y=2.1e-2)
ele_4=MagneticDipole(x=-5.e-2,y=3.1e-2)
ele_5=Source(x=-8.e-2,y=2.1e-2)
ele_6=UniformField(x=-10.e-2,y=2.1e-2)
ele_7=PointField(x=-12.e-2,y=2.1e-2)
ele_8=Screen(x=-14.e-2,y=2.1e-2,an0=30.)

plt.figure()
ax=plt.gca()
ele_1.add_shape(ax)
ele_2.add_shape(ax)
ele_3.add_shape(ax)
ele_4.add_shape(ax)
ele_5.add_shape(ax)
ele_6.add_shape(ax)
ele_7.add_shape(ax)
ele_8.add_shape(ax)
ax.grid()
ax.axis('equal')
plt.show()




"""
+[P函数](,测试画图)

"""
## end
#1026, 130:
https://matplotlib.org/stable/gallery/shapes_and_collections/path_patch.html#sphx-glr-gallery-shapes-and-collections-path-patch-py
## end
#1028, 816:
"""
地址::/home/xiantao/Documents/Projects/py-sem/src/matlab_style_draw.py
+[保存P函数]"Xiantao Cheng"(,matlab_style_draw)
+[P函数](,matlab_style_draw)
patch测试:...

"""
import matplotlib.path as mpath
import matplotlib.patches as mpatches

def patch_from_xy(x,y,color_str):
    Path=mpath.Path
    path_data=[]
    for i in range(len(x)):
        if i==0:
            path_data.append((Path.MOVETO, (x[i], y[i])))
        else:
            path_data.append((Path.LINETO, (x[i], y[i])))
        if i==len(x)-1:
            path_data.append((Path.CLOSEPOLY, (x[i], y[i])))
    
    codes, verts = zip(*path_data)
    path = mpath.Path(verts, codes)
    shape = mpatches.PathPatch(path, facecolor=color_str, alpha=0.5)
    return shape

def circle_from_pt_r(x,y,r,color_str):
    return mpatches.Circle((x,y),r,ec=color_str)



## end
#1030, 64:
/home/xiantao/Documents/Projects/py-sem/src/matlab_style_draw.py
## end
#1031, 23:
2023-06-13 Tue 00:37:03
## end
#1033, 13:
Xiantao Cheng
## end
#1036, 270:
"""
+[P函数](,测试画图)

"""

import matplotlib.path as mpath
import matplotlib.patches as mpatches
import matplotlib.pyplot as plt

x=[-1,1,1,-3]
y=[0,0,1,2]

fig, ax = plt.subplots()
patch = patch_from_xy(x,y,'b')
ax.add_patch(patch)

ax.grid()
ax.axis('equal')
plt.show()


## end
#1038, 840:
"""
记住"Python"
+[P函数](,单个lens)

"""
import numpy as np
import matplotlib.path as mpath
import matplotlib.patches as mpatches
import matplotlib.pyplot as plt

W1=0.2
H1=1
W2=0.7
H2=1

r=0.2
d=0.2

fig, ax = plt.subplots()

x1=np.array([0,0,1,1])*W1
y1=np.array([-1,1,1,-1])*H1/2
x2=np.array([0,0,1,1])*W2
y2=np.array([-1,1,1,-1])*H2/2

patch00 = patch_from_xy(x1-W1-W2/2-d,y1+H1/2+r/2,'b')
ax.add_patch(patch00)
patch01 = patch_from_xy(x1-W1-W2/2-d,y1-H1/2-r/2,'b')
ax.add_patch(patch01)

patch10 = patch_from_xy(x2-W2/2,y2+H2/2+r/2,'b')
ax.add_patch(patch10)
patch11 = patch_from_xy(x2-W2/2,y2-H2/2-r/2,'b')
ax.add_patch(patch11)

patch20 = patch_from_xy(x1+W2/2+d,y1+H1/2+r/2,'b')
ax.add_patch(patch20)
patch21 = patch_from_xy(x1+W2/2+d,y1-H1/2-r/2,'b')
ax.add_patch(patch21)

ax.grid()
ax.axis('equal')
plt.show()


"""
+[P函数](,测试画图)

"""
## end
#1040, 367:
"""
+[P函数](,测试画图)
matlab_style_draw:...

单个lens:...
+[新建阅读窗口](,单个lens)

"""
import numpy as np
import matplotlib.pyplot as plt

lens_1=Lens(x=0,y=2.1e-2)
lens_2=Lens(x=2.e-2,y=0.e-2)
lens_3=Lens(x=3.e-2,y=-2.1e-2)

plt.figure()
ax=plt.gca()
lens_1.add_shape(ax)
lens_2.add_shape(ax)
lens_3.add_shape(ax)
ax.grid()
ax.axis('equal')
plt.show()



"""
+[P函数](,测试画图)

"""
## end
#1042, 221:
"""
+[P函数](,测试画图)
matlab_style_draw:...

单个lens:...
多个lens:...
测试aperture:...
+[新建阅读窗口](,单个lens)

"""
import numpy as np
import matplotlib.pyplot as plt

apt_1=Aperture(x=0,y=2.1e-2)
apt_1.view()



"""
+[P函数](,测试画图)

"""
## end
#1044, 67:
https://docs.python.org/3/howto/regex.html#greedy-versus-non-greedy
## end
#1046, 15:

磁偶极子:...






## end
#1048, 1148:
<!--
参考::https://en.wikipedia.org/wiki/Magnetic_dipole
参考2::https://web.mit.edu/8.02t/www/802TEAL3D/visualizations/coursenotes/modules/guide09.pdf#page=24
+[打开网页](,参考)
+[打开网页](,参考2)
+[H函数](,磁偶极子)
-->


<h2>Magnetic field</h2>
%[1].
%[2].

<h2>Space transformation</h2>
The local frame is symmetric around the y-axis. <br>
Local frame axis, 
%[3].
%[4].
%[5].
%[5.1].

Local field vector in local frame, 
%[6].
%[7].
%[8].

Local field vector in global frame (local coordinates), 
%[9].
%[9.1].
%[10].
%[10.1].
%[11].
%[11.1].



<!--
[11.1].:
式(2)转换为"表达式"
将"B_\rho=\frac{\mu_0*(I*\pi*R^{2})}{4*\pi}*\frac{3*y*\sqrt{x^2+z^2}}{r^{5}}"记作为式(1)
将"B_y=\frac{\mu_0*(I*\pi*R^{2})}{4*\pi}*\frac{2*r^2-3*(x^2+z^2)}{r^{5}}"记作为式(2)
将"\hat{f_z}=\vec{-z/r, 0, x/r}"记作为式(8)

将"\hat{f_X}=\hat{f_x}*\mat{T}"记作为式(9)
将"\hat{f_Y}=\hat{f_y}*\mat{T}"记作为式(10)
将"\hat{f_Z}=\hat{f_z}*\mat{T}"记作为式(11)

将式(9)记作为式(9.1)
将式(5.1)代入到式(9.1)
将式(6)代入到式(9.1)
计算式(9.1)的'矩阵运算'

将式(10)记作为式(10.1)
将式(5.1)代入到式(10.1)
将式(7)代入到式(10.1)
计算式(10.1)的'矩阵运算'

将式(11)记作为式(11.1)
将式(5.1)代入到式(11.1)
将式(8)代入到式(11.1)
计算式(11.1)的'矩阵运算'



更新式(11.1)
验证公式:...
+[新建阅读窗口](,验证公式)
+[M函数](,验证公式)
+[H函数](,磁偶极子)
-->
## end
#1050, 45:
https://en.wikipedia.org/wiki/Magnetic_dipole
## end
#1052, 94:
https://web.mit.edu/8.02t/www/802TEAL3D/visualizations/coursenotes/modules/guide09.pdf#page=24
## end
#1054, 92:
B_{\rho}=\frac{\mu_{0} \left(I \pi R^{2}\right)}{4 \pi} \frac{3 y \sqrt{x^{2}+z^{2}}}{r^{5}}
## end
#1056, 101:
B_{y}=\frac{\mu_{0} \left(I \pi R^{2}\right)}{4 \pi} \frac{2 r^{2}-3 \left(x^{2}+z^{2}\right)}{r^{5}}
## end
#1058, 95:
\hat{x}=\begin{pmatrix}
cos \left( \theta \right),&sin \left( \theta \right),&0
\end{pmatrix}


## end
#1060, 73:
B_\rho=\frac{\mu_0*(I*\pi*R^{2})}{4*\pi}*\frac{3*y*\sqrt{x^2+z^2}}{r^{5}}
## end
#1063, 69:
B_y=\frac{\mu_0*(I*\pi*R^{2})}{4*\pi}*\frac{2*r^2-3*(x^2+z^2)}{r^{5}}
## end
#1067, 620:
%{
+[M函数](,验证公式)
%}

physics_constant;

I=1;
R=1;

B_x=@(r,theta)(mu_0.*(I.*pi.*R.^2))./(4.*pi).*(3.*sin(theta).*cos(theta))./(r.^3);
B_z=@(r,theta)(mu_0.*(I.*pi.*R.^2))./(4.*pi).*((2-3.*sin(theta).^2))./(r.^3);

x=linspace(-1,1,200);
z=linspace(-1,1,201);
[X,Z]=meshgrid(x,z);

R=sqrt(X.^2+Z.^2);
Theta=acos(Z./R).*sign_1(X);

Bx=B_x(R,Theta);
Bz=B_z(R,Theta);
B0=sqrt(Bx.^2+Bz.^2);

sz1=linspace(0.01,0.1,10);
sz2=linspace(0.11,0.25,10);
sz=[sz1,sz2];
sx=ones(size(sz));
sz=[sz,sz];
sx=[-sx,sx]*0.2;

clf
hold on
streamline(X,Z,Bx./B0,Bz./B0,sx,sz)
streamline(X,Z,-Bx./B0,-Bz./B0,sx,sz)
axis equal

%{
+[M函数](,验证公式)
%}
## end
#1069, 161:
"""
参考circle::https://matplotlib.org/stable/gallery/shapes_and_collections/artist_reference.html#sphx-glr-gallery-shapes-and-collections-artist-reference-py

"""
## end
#1071, 142:
https://matplotlib.org/stable/gallery/shapes_and_collections/artist_reference.html#sphx-glr-gallery-shapes-and-collections-artist-reference-py
## end
#1073, 3735:
"""
地址::/home/xiantao/Documents/Projects/py-sem/src/space.py
+[保存P函数]"Xiantao Cheng"(,space)
+[打开文件夹]"body"
+[P函数](,space)

测试画场:...
测试场景:...
+[新建阅读窗口](,测试场景)
+[新建阅读窗口](,测试画场)

保存:...

"""
import numpy as np
import matplotlib.pyplot as plt
#import sys
#sys.path.append('/home/xiantao/Documents/Projects/py-sem')
# from src.elements import Element

class Space:
    def __init__(self,name="world"):
        self.m_name=name
        self.m_objects=[]

        self.m_Ex=[]
        self.m_Ey=[]
        self.m_Ez=[]

        self.m_Bx=[]
        self.m_By=[]
        self.m_Bz=[]

    def add_obj(self, objects):
        if type(objects)==type([]):
            for obj in objects:
                self.m_objects.append(obj)
        else:
            self.m_objects.append(objects)
        self.update_EField()
        self.update_BField()

    def update_BField(self):
        self.m_Bx=[]
        self.m_By=[]
        self.m_Bz=[]
        for obj in self.m_objects:
            Bx1,By1,Bz1=obj.get_BField()
            self.m_Bx.append(Bx1)
            self.m_By.append(By1)
            self.m_Bz.append(Bz1)
    
    def update_EField(self):
        self.m_Ex=[]
        self.m_Ey=[]
        self.m_Ez=[]
        for obj in self.m_objects:
            Ex1,Ey1,Ez1=obj.get_EField()
            self.m_Ex.append(Ex1)
            self.m_Ey.append(Ey1)
            self.m_Ez.append(Ez1)

    def get_BField(self):
        def Bx(x,y,z):
            field=x*0
            for Bx1 in self.m_Bx:
                field+=Bx1(x,y,z)
            return field

        def By(x,y,z):
            field=x*0
            for By1 in self.m_By:
                field+=By1(x,y,z)
            return field

        def Bz(x,y,z):
            field=x*0
            for Bz1 in self.m_Bz:
                field+=Bz1(x,y,z)
            return field

        return [Bx,By,Bz]
    
    def get_EField(self):
        def Ex(x,y,z):
            field=x*0
            for Ex1 in self.m_Ex:
                field+=Ex1(x,y,z)
            return field

        def Ey(x,y,z):
            field=x*0
            for Ey1 in self.m_Ey:
                field+=Ey1(x,y,z)
            return field

        def Ez(x,y,z):
            field=x*0
            for Ez1 in self.m_Ez:
                field+=Ez1(x,y,z)
            return field

        return [Ex,Ey,Ez]

    def get_obj(self,type_txt=""):
        sel_obj=[]
        for obj in self.m_objects:
            if obj.m_type==type_txt:
                sel_obj.append(obj)
        return sel_obj

    def info(self):
        info_list=[]
        for obj in self.m_objects:
            info_list.append(obj.info())
        info_txt=", ".join(info_list)
        return "%s: %s"%(self.m_name,info_txt)

    def __str__(self):
        return self.info()

    def view_scene(self,ax0=None):
        if ax0==None:
            plt.figure()
            ax=plt.gca()
        else:
            ax=ax0

        for obj in self.m_objects:
            obj.add_shape(ax)

        ax.axis('equal')
        if ax0==None:
            ax.grid()
            plt.show()

    def view_field(self,x_min=-3.,x_max=3.,y_min=-3.,y_max=3., field_type="B",ax0=None):
        Y, X = np.mgrid[y_min:y_max:1000j, x_min:x_max:1000j]
        Z=X*0
        if field_type=="B":
            Fx, Fy, Fz=self.get_BField()
        else:
            Fx, Fy, Fz=self.get_EField()
            # print(Fx,Fx(0,0,0))
        
        if ax0==None:
            plt.figure()
            ax=plt.gca()
        else:
            ax=ax0
        ax.streamplot(X, Y, Fx(X,Y,Z), Fy(X,Y,Z), density=[0.5, 1])
        ax.axis('equal')
        if ax0==None:
            plt.show()


"""
记住"Python"
print([1,2,3,4]==None)
print(np.array([1,2,3,4])==None)

+[P函数](,space)

"""
## end
#1075, 52:
/home/xiantao/Documents/Projects/py-sem/src/space.py
## end
#1077, 495:
"""
+[P函数](,测试画场)
例1_streamplot:...
+[新建阅读窗口](,例1_streamplot)

矩阵形式场:...

"""

import numpy as np
import matplotlib.pyplot as plt

I=1
R=1
mu_0=1
w=3.

Y, X = np.mgrid[-w:w:100j, -w:w:100j]
r=np.sqrt(X**2+Y**2)

B_x = lambda X,Y,r: (mu_0*(I*np.pi*R**2))/(4*np.pi)*(3*X*Y)/(r**5)
B_y = lambda X,Y,r: (mu_0*(I*np.pi*R**2))/(4*np.pi)*((2-3*X**2))/(r**5)


plt.figure()
ax=plt.gca()
ax.streamplot(X, Y, B_x(X,Y,r), B_y(X,Y,r), density=[0.5, 1])
ax.axis('equal')
plt.show()




"""
+[P函数](,测试画场)

"""
## end
#1079, 1816:
"""
参考::https://matplotlib.org/stable/gallery/images_contours_and_fields/plot_streamplot.html
记住"Python"
+[P函数](,例1_streamplot)
height
, height_ratios=[1, 1, 2]

"""


import numpy as np
import matplotlib.pyplot as plt


w = 3
Y, X = np.mgrid[-w:w:100j, -w:w:100j]
U = -1 - X**2 + Y
V = 1 + X - Y**2
speed = np.sqrt(U**2 + V**2)

fig, axs = plt.subplots(3, 2, figsize=(7, 9))
axs = axs.flat

#  Varying density along a streamline
axs[0].streamplot(X, Y, U, V, density=[0.5, 1])
axs[0].set_title('Varying Density')

# Varying color along a streamline
strm = axs[1].streamplot(X, Y, U, V, color=U, linewidth=2, cmap='autumn')
fig.colorbar(strm.lines)
axs[1].set_title('Varying Color')

#  Varying line width along a streamline
lw = 5*speed / speed.max()
axs[2].streamplot(X, Y, U, V, density=0.6, color='k', linewidth=lw)
axs[2].set_title('Varying Line Width')

# Controlling the starting points of the streamlines
seed_points = np.array([[-2, -1, 0, 1, 2, -1], [-2, -1,  0, 1, 2, 2]])

strm = axs[3].streamplot(X, Y, U, V, color=U, linewidth=2,
                         cmap='autumn', start_points=seed_points.T)
fig.colorbar(strm.lines)
axs[3].set_title('Controlling Starting Points')

# Displaying the starting points with blue symbols.
axs[3].plot(seed_points[0], seed_points[1], 'bo')
axs[3].set(xlim=(-w, w), ylim=(-w, w))

# Create a mask
mask = np.zeros(U.shape, dtype=bool)
mask[40:60, 40:60] = True
U[:20, :20] = np.nan
U = np.ma.array(U, mask=mask)

axs[4].streamplot(X, Y, U, V, color='r')
axs[4].set_title('Streamplot with Masking')

axs[4].imshow(~mask, extent=(-w, w, -w, w), alpha=0.5, cmap='gray',
              aspect='auto')
axs[4].set_aspect('equal')

axs[5].streamplot(X, Y, U, V, broken_streamlines=False)
axs[5].set_title('Streamplot with unbroken streamlines')

plt.tight_layout()
plt.show()



## end
#1081, 85:
https://matplotlib.org/stable/gallery/images_contours_and_fields/plot_streamplot.html
## end
#1083, 85:
https://matplotlib.org/stable/gallery/images_contours_and_fields/plot_streamplot.html
## end
#1085, 461:
"""
+[P函数](,测试画场)
例1_streamplot:...
+[新建阅读窗口](,例1_streamplot)

矩阵形式场:...

"""

import numpy as np
import matplotlib.pyplot as plt

I=1
R=1
mu_0=1

Y, X = np.mgrid[-w:w:100j, -w:w:100j]
r=np.sqrt(X**2+Y**2)

B_x=(mu_0*(I*np.pi*R**2))/(4*np.pi)*(3*X*Y)/(r**5)
B_y=(mu_0*(I*np.pi*R**2))/(4*np.pi)*((2-3*X**2))/(r**5)

# B_x=-Y
# B_y=X

plt.figure()
ax=plt.gca()
ax.streamplot(X, Y, B_x, B_y, density=[0.5, 1])
ax.axis('equal')
plt.show()




"""
+[P函数](,测试画场)

"""
## end
#1086, 23:
2023-06-15 Thu 15:20:37
## end
#1088, 13:
Xiantao Cheng
## end
#1091, 523:
"""
+[P函数](,测试场景)

显示场景:...
显示磁场_1D:...
显示磁场_2D:...

线圈磁场:...
四级子电场:...
print(ele_5.get_BField())
del type

保存:...

"""

world=Space()


ele_1 = Lens("E1",x=0.,y=0.,r=1.e-2,D=2.e-2)
ele_2 = Lens("E2",x=-5.e-2,y=0.,r=1.e-2,D=2.e-2)
ele_3 = Lens("E3",x=5.e-2,y=0.,r=1.e-2,D=2.e-2)

world.add_obj([ele_1,ele_2,ele_3])
# world.add_obj([ele_1])

world.view_scene()
# world.view_field(-10.e-2,10.e-2,-10.e-2,10.e-2,'E')
world.view_field(-5.e-2,5.e-2,-10.e-2,10.e-2,'E')


"""
print(world.m_Bx)
print(Bx(X,Y,Z))
+[P函数](,测试场景)

"""
## end
#1095, 277:
"""
+[P函数](,显示场景)

显示场景:...

"""

world=Space()

ele_1=Lens("L1",x=0.,y=2.1e-2)
ele_2=Aperture("A1",x=5.e-2,y=2.1e-2)
ele_3=Deflector("D1",x=8.e-2,y=2.1e-2)
ele_4=MagneticDipole("M1",x=-5.e-2,y=2.1e-2)

world.add_obj([ele_1,ele_2,ele_3,ele_4])
world.view_scene()

print(world)

## end
#1097, 436:
"""
+[P函数](,测试场景)

显示场景:...

"""

world=Space()

ele_1=MagneticDipole("M1",x=-1.,y=-1., I=1)
ele_2=MagneticDipole("M2",x=1.,y=1, I=-1)
world.add_obj([ele_1])


w=3.
Y, X = np.mgrid[-w:w:100j, -w:w:100j]
Z=X*0
Bx, By, Bz=world.get_BField()
# Bx, By, Bz=ele_4.get_BField()

plt.figure()
ax=plt.gca()
ax.streamplot(X, Y, Bx(X,Y,Z), By(X,Y,Z), density=[0.5, 1])
ax.axis('equal')
plt.show()


"""
print(X)
print(Bx(X,Y,Z))
+[P函数](,测试场景)

"""
## end
#1099, 2496:
"""
地址::/home/xiantao/Documents/Projects/py-sem/src/space.py
+[保存P函数]"Xiantao Cheng"(,space)
+[打开文件夹]"body"
+[P函数](,space)

测试画场:...
测试场景:...
+[新建阅读窗口](,测试场景)
+[新建阅读窗口](,测试画场)

"""
import numpy as np
import matplotlib.pyplot as plt
#import sys
#sys.path.append('/home/xiantao/Documents/Projects/py-sem')
# from src.elements import Element

class Space:
    def __init__(self,name="world"):
        self.m_name=name
        self.m_objects=[]

        Ex=lambda x,y,z: 0*x
        Ey=lambda x,y,z: 0*x
        Ez=lambda x,y,z: 0*x
        self.m_EField=[Ex,Ey,Ez]

        Bx=lambda x,y,z: 0*x
        By=lambda x,y,z: 0*x
        Bz=lambda x,y,z: 0*x
        self.m_BField=[Bx,By,Bz]

    def add_obj(self, objects):
        if type(objects)==type([]):
            for obj in objects:
                self.m_objects.append(obj)
        else:
            self.m_objects.append(objects)
        self.update_EField()
        self.update_BField()

    def update_BField(self):
        Bx0=lambda x,y,z: 0*x
        By0=lambda x,y,z: 0*x
        Bz0=lambda x,y,z: 0*x
        for obj in self.m_objects:
            Bx1,By1,Bz1=obj.get_BField()
            Bx=lambda x,y,z: Bx0(x,y,z)+Bx1(x,y,z)
            By=lambda x,y,z: By0(x,y,z)+By1(x,y,z)
            Bz=lambda x,y,z: Bz0(x,y,z)+Bz1(x,y,z)
            Bx0,By0,Bz0=Bx,By,Bz
        self.m_BField=[Bx,By,Bz]
    
    def update_EField(self):
        Ex0=lambda x,y,z: 0*x
        Ey0=lambda x,y,z: 0*x
        Ez0=lambda x,y,z: 0*x
        for obj in self.m_objects:
            Ex,Ey,Ez=obj.get_EField()
            Ex0=lambda x,y,z: Ex0(x,y,z)+Ex(x,y,z)
            Ey0=lambda x,y,z: Ey0(x,y,z)+Ey(x,y,z)
            Ez0=lambda x,y,z: Ez0(x,y,z)+Ez(x,y,z)
        self.m_EField=[Ex0,Ey0,Ez0]

    def get_BField(self):
        Bx=self.m_BField[0]
        By=self.m_BField[1]
        Bz=self.m_BField[2]
        return [Bx,By,Bz]
    
    def get_EField(self):
        Ex=self.m_EField[0]
        Ey=self.m_EField[1]
        Ez=self.m_EField[2]
        return [Ex,Ey,Ez]

    def info(self):
        info_list=[]
        for obj in self.m_objects:
            info_list.append(obj.info())
        info_txt=", ".join(info_list)
        return "%s: %s"%(self.m_name,info_txt)

    def __str__(self):
        return self.info()

    def view_scene(self):
        plt.figure()
        ax=plt.gca()
        for obj in self.m_objects:
            obj.add_shape(ax)
        ax.grid()
        ax.axis('equal')
        plt.show()


"""
+[P函数](,space)

"""
## end
#1103, 559:
"""
+[P函数](,测试场景)

显示场景:...

保存:...

"""

world=Space()

ele_1=MagneticDipole("M1",x=-1.,y=1, I=1)
ele_2=MagneticDipole("M2",x=1.,y=1, I=-1)
world.add_obj([ele_1,ele_2])


w=3.
Y, X = np.mgrid[-w:w:100j, -w:w:100j]
Z=X*0
Bx, By, Bz=world.get_BField()
Bx1, By, Bz=ele_1.get_BField()
Bx2, By, Bz=ele_2.get_BField()

x=X[40,:]
y=x*0
z=x*0

plt.figure()
ax=plt.gca()
# ax.streamplot(X, Y, Bx(X,Y,Z), By(X,Y,Z), density=[0.5, 1])
ax.plot(x,Bx1(x,y,z),x,Bx2(x,y,z),x,Bx(x,y,z))
ax.axis('equal')
plt.show()


"""
print(world.m_Bx)
print(Bx(X,Y,Z))
+[P函数](,测试场景)

"""
## end
#1106, 536:
"""
+[P函数](,测试场景)

显示场景:...
显示磁场_1D:...

保存:...

"""

world=Space()

ele_1=MagneticDipole("M1",x=-0.1,y=0, I=1)
ele_2=MagneticDipole("M2",x=0.,y=0, I=1)
ele_3=MagneticDipole("M2",x=0.1,y=0, I=1)
world.add_obj([ele_1,ele_2,ele_3])


w=3.
Y, X = np.mgrid[-w:w:100j, -w:w:100j]
Z=X*0
Bx, By, Bz=world.get_BField()
# Bx, By, Bz=ele_4.get_BField()

world.view_scene()
plt.figure()
ax=plt.gca()
ax.streamplot(X, Y, Bx(X,Y,Z), By(X,Y,Z), density=[0.5, 1])
ax.axis('equal')
plt.show()


"""
print(world.m_Bx)
print(Bx(X,Y,Z))
+[P函数](,测试场景)

"""
## end
#1108, 56:
/home/xiantao/Documents/Projects/py-sem/res/fig_traj.png
## end
#1111, 57:
/home/xiantao/Documents/Projects/py-sem/res/fig_space.png
## end
#1114, 57:
/home/xiantao/Documents/Projects/py-sem/res/fig_spots.png
## end
#1117, 62:
/home/xiantao/Documents/Projects/py-sem/res/fig_aberration.png
## end
#1120, 61:
/home/xiantao/Documents/Projects/py-sem/res/fig_traj_dflt.png
## end
#1124, 56:
/home/xiantao/Documents/Projects/py-sem/res/fig_traj.png
## end
#1127, 61:
/home/xiantao/Documents/Projects/py-sem/res/fig_traj_dflt.png
## end
#1130, 57:
/home/xiantao/Documents/Projects/py-sem/res/fig_space.png
## end
#1133, 57:
/home/xiantao/Documents/Projects/py-sem/res/fig_spots.png
## end
#1136, 62:
/home/xiantao/Documents/Projects/py-sem/res/fig_aberration.png
## end
#1139, 6020:
"""
地址::/home/xiantao/Documents/Projects/py-sem/src/stepper.py
+[保存P函数]"Xiantao Cheng"(,stepper)
+[P函数](,stepper)

测试运行:...
测试算法:...
+[新建阅读窗口](,测试算法)

"""

import numpy as np
import matplotlib.pyplot as plt


class EM_stepper:
    def __init__(self,x0=0,y0=0,z0=0,vx0=0,vy0=0,vz0=0):
        self.m_x0=np.array(x0)
        self.m_y0=np.array(y0)
        self.m_z0=np.array(z0)
        self.m_vx0=np.array(vx0)
        self.m_vy0=np.array(vy0)
        self.m_vz0=np.array(vz0)

        self.m_Bx=lambda x,y,z: 0*x
        self.m_By=lambda x,y,z: 0*x
        self.m_Bz=lambda x,y,z: 0*x
        self.m_Ex=lambda x,y,z: 0*x
        self.m_Ey=lambda x,y,z: 0*x
        self.m_Ez=lambda x,y,z: 0*x

        self.m_fs=[None,None,None,None,None,None]

    def setPos(self,x0,y0,z0):
        self.m_x0=np.array(x0)
        self.m_y0=np.array(y0)
        self.m_z0=np.array(z0)

    def setVec(self,vx0,vy0,vz0):
        self.m_vx0=np.array(vx0)
        self.m_vy0=np.array(vy0)
        self.m_vz0=np.array(vz0)

    def setBField(self,Bx=None,By=None,Bz=None):
        if Bx!=None:
            self.m_Bx=Bx
        if By!=None:
            self.m_By=By
        if Bz!=None:
            self.m_Bz=Bz
        self.updateFs()
    
    def setEField(self,Ex=None,Ey=None,Ez=None):
        if Ex!=None:
            self.m_Ex=Ex
        if Ey!=None:
            self.m_Ey=Ey
        if Ez!=None:
            self.m_Ez=Ez
        self.updateFs()

    def updateFs(self):
        q=-1.
        m=1.
        B_x=self.m_Bx
        B_y=self.m_By
        B_z=self.m_Bz
        
        E_x=self.m_Ex
        E_y=self.m_Ey
        E_z=self.m_Ez
        
        self.m_fs[0]=lambda t,x,y,z,v_x,v_y,v_z: v_x
        self.m_fs[1]=lambda t,x,y,z,v_x,v_y,v_z: v_y
        self.m_fs[2]=lambda t,x,y,z,v_x,v_y,v_z: v_z
        self.m_fs[3]=lambda t,x,y,z,v_x,v_y,v_z: \
            (v_y* B_z(x,y,z)-v_z* B_y(x,y,z)+ E_x(x,y,z))*q/m
        self.m_fs[4]=lambda t,x,y,z,v_x,v_y,v_z: \
            (v_z* B_x(x,y,z)-v_x* B_z(x,y,z)+ E_y(x,y,z))*q/m
        self.m_fs[5]=lambda t,x,y,z,v_x,v_y,v_z: \
            (v_x* B_y(x,y,z)-v_y* B_x(x,y,z)+ E_z(x,y,z))*q/m

    def stepOn(self,n=1,Delta_t=0.1):
        X,Y,Z=[],[],[]
        x=self.m_x0
        y=self.m_y0
        z=self.m_z0
        v_x=self.m_vx0
        v_y=self.m_vy0
        v_z=self.m_vz0
        for i in range(n):
            x,y,z,v_x,v_y,v_z=self.step_RK4(x,y,z,v_x,v_y,v_z,Delta_t)
# self.collision()
# self.coulomb()
            X.append(x)
            Y.append(y)
            Z.append(z)
        X=np.array(X)
        Y=np.array(Y)
        Z=np.array(Z)
        return X,Y,Z

    def step_RK4(self,x,y,z,v_x,v_y,v_z,Delta_t):
        t=0.
        a_1=self.m_fs[0](t,x,y,z,v_x,v_y,v_z)
        a_2=self.m_fs[1](t,x,y,z,v_x,v_y,v_z)
        a_3=self.m_fs[2](t,x,y,z,v_x,v_y,v_z)
        a_4=self.m_fs[3](t,x,y,z,v_x,v_y,v_z)
        a_5=self.m_fs[4](t,x,y,z,v_x,v_y,v_z)
        a_6=self.m_fs[5](t,x,y,z,v_x,v_y,v_z)
        
        b_1=self.m_fs[0](t+Delta_t/2,x+Delta_t/2*a_1,y+Delta_t/2*a_2,z+Delta_t/2*a_3,\
            v_x+Delta_t/2*a_4,v_y+Delta_t/2*a_5,v_z+Delta_t/2*a_6)
        b_2=self.m_fs[1](t+Delta_t/2,x+Delta_t/2*a_1,y+Delta_t/2*a_2,z+Delta_t/2*a_3,\
            v_x+Delta_t/2*a_4,v_y+Delta_t/2*a_5,v_z+Delta_t/2*a_6)
        b_3=self.m_fs[2](t+Delta_t/2,x+Delta_t/2*a_1,y+Delta_t/2*a_2,z+Delta_t/2*a_3,\
            v_x+Delta_t/2*a_4,v_y+Delta_t/2*a_5,v_z+Delta_t/2*a_6)
        b_4=self.m_fs[3](t+Delta_t/2,x+Delta_t/2*a_1,y+Delta_t/2*a_2,z+Delta_t/2*a_3,\
            v_x+Delta_t/2*a_4,v_y+Delta_t/2*a_5,v_z+Delta_t/2*a_6)
        b_5=self.m_fs[4](t+Delta_t/2,x+Delta_t/2*a_1,y+Delta_t/2*a_2,z+Delta_t/2*a_3,\
            v_x+Delta_t/2*a_4,v_y+Delta_t/2*a_5,v_z+Delta_t/2*a_6)
        b_6=self.m_fs[5](t+Delta_t/2,x+Delta_t/2*a_1,y+Delta_t/2*a_2,z+Delta_t/2*a_3,\
            v_x+Delta_t/2*a_4,v_y+Delta_t/2*a_5,v_z+Delta_t/2*a_6)
        
        c_1=self.m_fs[0](t+Delta_t/2,x+Delta_t/2*b_1,y+Delta_t/2*b_2,z+Delta_t/2*b_3,\
            v_x+Delta_t/2*b_4,v_y+Delta_t/2*b_5,v_z+Delta_t/2*b_6)
        c_2=self.m_fs[1](t+Delta_t/2,x+Delta_t/2*b_1,y+Delta_t/2*b_2,z+Delta_t/2*b_3,\
            v_x+Delta_t/2*b_4,v_y+Delta_t/2*b_5,v_z+Delta_t/2*b_6)
        c_3=self.m_fs[2](t+Delta_t/2,x+Delta_t/2*b_1,y+Delta_t/2*b_2,z+Delta_t/2*b_3,\
            v_x+Delta_t/2*b_4,v_y+Delta_t/2*b_5,v_z+Delta_t/2*b_6)
        c_4=self.m_fs[3](t+Delta_t/2,x+Delta_t/2*b_1,y+Delta_t/2*b_2,z+Delta_t/2*b_3,\
            v_x+Delta_t/2*b_4,v_y+Delta_t/2*b_5,v_z+Delta_t/2*b_6)
        c_5=self.m_fs[4](t+Delta_t/2,x+Delta_t/2*b_1,y+Delta_t/2*b_2,z+Delta_t/2*b_3,\
            v_x+Delta_t/2*b_4,v_y+Delta_t/2*b_5,v_z+Delta_t/2*b_6)
        c_6=self.m_fs[5](t+Delta_t/2,x+Delta_t/2*b_1,y+Delta_t/2*b_2,z+Delta_t/2*b_3,\
            v_x+Delta_t/2*b_4,v_y+Delta_t/2*b_5,v_z+Delta_t/2*b_6)
        
        d_1=self.m_fs[0](t+Delta_t,x+Delta_t*c_1,y+Delta_t*c_2,z+Delta_t*c_3,\
            v_x+Delta_t*c_4,v_y+Delta_t*c_5,v_z+Delta_t*c_6)
        d_2=self.m_fs[1](t+Delta_t,x+Delta_t*c_1,y+Delta_t*c_2,z+Delta_t*c_3,\
            v_x+Delta_t*c_4,v_y+Delta_t*c_5,v_z+Delta_t*c_6)
        d_3=self.m_fs[2](t+Delta_t,x+Delta_t*c_1,y+Delta_t*c_2,z+Delta_t*c_3,\
            v_x+Delta_t*c_4,v_y+Delta_t*c_5,v_z+Delta_t*c_6)
        d_4=self.m_fs[3](t+Delta_t,x+Delta_t*c_1,y+Delta_t*c_2,z+Delta_t*c_3,\
            v_x+Delta_t*c_4,v_y+Delta_t*c_5,v_z+Delta_t*c_6)
        d_5=self.m_fs[4](t+Delta_t,x+Delta_t*c_1,y+Delta_t*c_2,z+Delta_t*c_3,\
            v_x+Delta_t*c_4,v_y+Delta_t*c_5,v_z+Delta_t*c_6)
        d_6=self.m_fs[5](t+Delta_t,x+Delta_t*c_1,y+Delta_t*c_2,z+Delta_t*c_3,\
            v_x+Delta_t*c_4,v_y+Delta_t*c_5,v_z+Delta_t*c_6)
        
        x=x+Delta_t/6*(a_1+2*b_1+2*c_1+d_1)
        y=y+Delta_t/6*(a_2+2*b_2+2*c_2+d_2)
        z=z+Delta_t/6*(a_3+2*b_3+2*c_3+d_3)
        v_x=v_x+Delta_t/6*(a_4+2*b_4+2*c_4+d_4)
        v_y=v_y+Delta_t/6*(a_5+2*b_5+2*c_5+d_5)
        v_z=v_z+Delta_t/6*(a_6+2*b_6+2*c_6+d_6)
    
        return x,y,z,v_x,v_y,v_z


"""
+[P函数](,stepper)

"""
## end
#1141, 54:
/home/xiantao/Documents/Projects/py-sem/src/stepper.py
## end
#1143, 1057:
"""
地址::/home/xiantao/Documents/Projects/py-sem/examples/unit_testing/stepper_test.py
+[保存P函数]"Xiantao Cheng"(,测试运行)
+[P函数](,测试运行)
Nini, 打开龙格库塔方法(文件)

"""
import numpy as np
import matplotlib.pyplot as plt
import sys
if __name__=='__main__':
    sys.path.append(sys.path[0]+'/../..')
from src.stepper import EM_stepper
from src.tracks import Tracks
# from src.elements import *


import numpy as np
import matplotlib.pyplot as plt

q=1
m=1

B_x = lambda x,y,z: x*0
B_y = lambda x,y,z: x*0
B_z = lambda x,y,z: x*0+1

E_x = lambda x,y,z: x*0
E_y = lambda x,y,z: x*0
E_z = lambda x,y,z: x*0

N=10
t=0
x=np.linspace(0,0,N)
y=np.linspace(0,0,N)
z=np.linspace(0,0,N)
v_x=np.linspace(1,2,N)
v_y=np.linspace(0,0,N)
v_z=np.linspace(0,0,N)

stepper=EM_stepper(x,y,z,v_x,v_y,v_z)
stepper.setBField(B_x,B_y,B_z)
stepper.setEField(E_x,E_y,E_z)
X,Y,Z=stepper.stepOn(1000,0.1)


plt.figure().add_subplot(projection="3d")
ax=plt.gca()

for i in range(N):
    ax.plot(X[:,i],Y[:,i],Z[:,i])

ax.grid()
plt.show()


"""
print(len(X.shape))
print(X.shape[1])
+[P函数](,测试运行)

"""
## end
#1145, 4215:
"""
地址::/home/xiantao/Documents/Projects/py-sem/examples/unit_testing/stepper_test_RK4.py
+[保存P函数]"Xiantao Cheng"(,测试算法)
+[P函数](,测试算法)
参考::https://matplotlib.org/stable/gallery/mplot3d/lines3d.html#sphx-glr-gallery-mplot3d-lines3d-py

单点测试:...
显示轨迹:...
多条轨迹:...
测试plot:...

保存:...

"""

import numpy as np
import matplotlib.pyplot as plt

q=1
m=1

B_x = lambda x,y,z: x*0
B_y = lambda x,y,z: x*0
B_z = lambda x,y,z: x*0+1

E_x = lambda x,y,z: x*0
E_y = lambda x,y,z: x*0
E_z = lambda x,y,z: x*0

f_1=lambda t,x,y,z,v_x,v_y,v_z: v_x
f_2=lambda t,x,y,z,v_x,v_y,v_z: v_y
f_3=lambda t,x,y,z,v_x,v_y,v_z: v_z
f_4=lambda t,x,y,z,v_x,v_y,v_z: (v_y* B_z(x,y,z)-v_z* B_y(x,y,z)+ E_x(x,y,z))*q/m
f_5=lambda t,x,y,z,v_x,v_y,v_z: (v_z* B_x(x,y,z)-v_x* B_z(x,y,z)+ E_y(x,y,z))*q/m
f_6=lambda t,x,y,z,v_x,v_y,v_z: (v_x* B_y(x,y,z)-v_y* B_x(x,y,z)+ E_z(x,y,z))*q/m

N=10
t=0
x=np.linspace(0,0,N)
y=np.linspace(0,0,N)
z=np.linspace(0,0,N)
v_x=np.linspace(1,2,N)
v_y=np.linspace(0,0,N)
v_z=np.linspace(0,0,N)
Delta_t=0.1
X,Y,Z=[],[],[]

for i in range(1000):
    a_1=f_1(t,x,y,z,v_x,v_y,v_z)
    a_2=f_2(t,x,y,z,v_x,v_y,v_z)
    a_3=f_3(t,x,y,z,v_x,v_y,v_z)
    a_4=f_4(t,x,y,z,v_x,v_y,v_z)
    a_5=f_5(t,x,y,z,v_x,v_y,v_z)
    a_6=f_6(t,x,y,z,v_x,v_y,v_z)
    
    b_1=f_1(t+Delta_t/2,x+Delta_t/2*a_1,y+Delta_t/2*a_2,z+Delta_t/2*a_3,\
        v_x+Delta_t/2*a_4,v_y+Delta_t/2*a_5,v_z+Delta_t/2*a_6)
    b_2=f_2(t+Delta_t/2,x+Delta_t/2*a_1,y+Delta_t/2*a_2,z+Delta_t/2*a_3,\
        v_x+Delta_t/2*a_4,v_y+Delta_t/2*a_5,v_z+Delta_t/2*a_6)
    b_3=f_3(t+Delta_t/2,x+Delta_t/2*a_1,y+Delta_t/2*a_2,z+Delta_t/2*a_3,\
        v_x+Delta_t/2*a_4,v_y+Delta_t/2*a_5,v_z+Delta_t/2*a_6)
    b_4=f_4(t+Delta_t/2,x+Delta_t/2*a_1,y+Delta_t/2*a_2,z+Delta_t/2*a_3,\
        v_x+Delta_t/2*a_4,v_y+Delta_t/2*a_5,v_z+Delta_t/2*a_6)
    b_5=f_5(t+Delta_t/2,x+Delta_t/2*a_1,y+Delta_t/2*a_2,z+Delta_t/2*a_3,\
        v_x+Delta_t/2*a_4,v_y+Delta_t/2*a_5,v_z+Delta_t/2*a_6)
    b_6=f_6(t+Delta_t/2,x+Delta_t/2*a_1,y+Delta_t/2*a_2,z+Delta_t/2*a_3,\
        v_x+Delta_t/2*a_4,v_y+Delta_t/2*a_5,v_z+Delta_t/2*a_6)
    
    c_1=f_1(t+Delta_t/2,x+Delta_t/2*b_1,y+Delta_t/2*b_2,z+Delta_t/2*b_3,\
        v_x+Delta_t/2*b_4,v_y+Delta_t/2*b_5,v_z+Delta_t/2*b_6)
    c_2=f_2(t+Delta_t/2,x+Delta_t/2*b_1,y+Delta_t/2*b_2,z+Delta_t/2*b_3,\
        v_x+Delta_t/2*b_4,v_y+Delta_t/2*b_5,v_z+Delta_t/2*b_6)
    c_3=f_3(t+Delta_t/2,x+Delta_t/2*b_1,y+Delta_t/2*b_2,z+Delta_t/2*b_3,\
        v_x+Delta_t/2*b_4,v_y+Delta_t/2*b_5,v_z+Delta_t/2*b_6)
    c_4=f_4(t+Delta_t/2,x+Delta_t/2*b_1,y+Delta_t/2*b_2,z+Delta_t/2*b_3,\
        v_x+Delta_t/2*b_4,v_y+Delta_t/2*b_5,v_z+Delta_t/2*b_6)
    c_5=f_5(t+Delta_t/2,x+Delta_t/2*b_1,y+Delta_t/2*b_2,z+Delta_t/2*b_3,\
        v_x+Delta_t/2*b_4,v_y+Delta_t/2*b_5,v_z+Delta_t/2*b_6)
    c_6=f_6(t+Delta_t/2,x+Delta_t/2*b_1,y+Delta_t/2*b_2,z+Delta_t/2*b_3,\
        v_x+Delta_t/2*b_4,v_y+Delta_t/2*b_5,v_z+Delta_t/2*b_6)
    
    d_1=f_1(t+Delta_t,x+Delta_t*c_1,y+Delta_t*c_2,z+Delta_t*c_3,\
        v_x+Delta_t*c_4,v_y+Delta_t*c_5,v_z+Delta_t*c_6)
    d_2=f_2(t+Delta_t,x+Delta_t*c_1,y+Delta_t*c_2,z+Delta_t*c_3,\
        v_x+Delta_t*c_4,v_y+Delta_t*c_5,v_z+Delta_t*c_6)
    d_3=f_3(t+Delta_t,x+Delta_t*c_1,y+Delta_t*c_2,z+Delta_t*c_3,\
        v_x+Delta_t*c_4,v_y+Delta_t*c_5,v_z+Delta_t*c_6)
    d_4=f_4(t+Delta_t,x+Delta_t*c_1,y+Delta_t*c_2,z+Delta_t*c_3,\
        v_x+Delta_t*c_4,v_y+Delta_t*c_5,v_z+Delta_t*c_6)
    d_5=f_5(t+Delta_t,x+Delta_t*c_1,y+Delta_t*c_2,z+Delta_t*c_3,\
        v_x+Delta_t*c_4,v_y+Delta_t*c_5,v_z+Delta_t*c_6)
    d_6=f_6(t+Delta_t,x+Delta_t*c_1,y+Delta_t*c_2,z+Delta_t*c_3,\
        v_x+Delta_t*c_4,v_y+Delta_t*c_5,v_z+Delta_t*c_6)
    
    
    
    x=x+Delta_t/6*(a_1+2*b_1+2*c_1+d_1)
    y=y+Delta_t/6*(a_2+2*b_2+2*c_2+d_2)
    z=z+Delta_t/6*(a_3+2*b_3+2*c_3+d_3)
    v_x=v_x+Delta_t/6*(a_4+2*b_4+2*c_4+d_4)
    v_y=v_y+Delta_t/6*(a_5+2*b_5+2*c_5+d_5)
    v_z=v_z+Delta_t/6*(a_6+2*b_6+2*c_6+d_6)
    
    X.append(x)
    Y.append(y)
    Z.append(z)

X=np.array(X)
Y=np.array(Y)
Z=np.array(Z)



plt.figure().add_subplot(projection="3d")
ax=plt.gca()

for i in range(N):
    ax.plot(X[:,i],Y[:,i],Z[:,i])

ax.grid()
plt.show()



"""
print(len(X))
print(np.array([[1,2],[3,4]]))
记住"Python"
+[P函数](,测试算法)

"""
## end
#1172, 3237:
"""
+[P函数](,测试算法)
保存:...

"""
q=1
m=1

B_x = lambda x,y,z: x*0
B_y = lambda x,y,z: x*0
B_z = lambda x,y,z: x*0+1

E_x = lambda x,y,z: x*0
E_y = lambda x,y,z: x*0
E_z = lambda x,y,z: x*0

f_1=lambda t,x,y,z,v_x,v_y,v_z: v_x
f_2=lambda t,x,y,z,v_x,v_y,v_z: v_y
f_3=lambda t,x,y,z,v_x,v_y,v_z: v_z
f_4=lambda t,x,y,z,v_x,v_y,v_z: (v_y* B_z(x,y,z)-v_z* B_y(x,y,z)+ E_x(x,y,z))*q/m
f_5=lambda t,x,y,z,v_x,v_y,v_z: (v_z* B_x(x,y,z)-v_x* B_z(x,y,z)+ E_y(x,y,z))*q/m
f_6=lambda t,x,y,z,v_x,v_y,v_z: (v_x* B_y(x,y,z)-v_y* B_x(x,y,z)+ E_z(x,y,z))*q/m

t=0
x=0
y=0
z=0
v_x=0
v_y=0
v_z=0
Delta_t=0.1

a_1=f_1(t,x,y,z,v_x,v_y,v_z)
a_2=f_2(t,x,y,z,v_x,v_y,v_z)
a_3=f_3(t,x,y,z,v_x,v_y,v_z)
a_4=f_4(t,x,y,z,v_x,v_y,v_z)
a_5=f_5(t,x,y,z,v_x,v_y,v_z)
a_6=f_6(t,x,y,z,v_x,v_y,v_z)

b_1=f_1(t+Delta_t/2,x+Delta_t/2*a_1,y+Delta_t/2*a_2,z+Delta_t/2*a_3,\
    v_x+Delta_t/2*a_4,v_y+Delta_t/2*a_5,v_z+Delta_t/2*a_6)
b_2=f_2(t+Delta_t/2,x+Delta_t/2*a_1,y+Delta_t/2*a_2,z+Delta_t/2*a_3,\
    v_x+Delta_t/2*a_4,v_y+Delta_t/2*a_5,v_z+Delta_t/2*a_6)
b_3=f_3(t+Delta_t/2,x+Delta_t/2*a_1,y+Delta_t/2*a_2,z+Delta_t/2*a_3,\
    v_x+Delta_t/2*a_4,v_y+Delta_t/2*a_5,v_z+Delta_t/2*a_6)
b_4=f_4(t+Delta_t/2,x+Delta_t/2*a_1,y+Delta_t/2*a_2,z+Delta_t/2*a_3,\
    v_x+Delta_t/2*a_4,v_y+Delta_t/2*a_5,v_z+Delta_t/2*a_6)
b_5=f_5(t+Delta_t/2,x+Delta_t/2*a_1,y+Delta_t/2*a_2,z+Delta_t/2*a_3,\
    v_x+Delta_t/2*a_4,v_y+Delta_t/2*a_5,v_z+Delta_t/2*a_6)
b_6=f_6(t+Delta_t/2,x+Delta_t/2*a_1,y+Delta_t/2*a_2,z+Delta_t/2*a_3,\
    v_x+Delta_t/2*a_4,v_y+Delta_t/2*a_5,v_z+Delta_t/2*a_6)

c_1=f_1(t+Delta_t/2,x+Delta_t/2*b_1,y+Delta_t/2*b_2,z+Delta_t/2*b_3,\
    v_x+Delta_t/2*b_4,v_y+Delta_t/2*b_5,v_z+Delta_t/2*b_6)
c_2=f_2(t+Delta_t/2,x+Delta_t/2*b_1,y+Delta_t/2*b_2,z+Delta_t/2*b_3,\
    v_x+Delta_t/2*b_4,v_y+Delta_t/2*b_5,v_z+Delta_t/2*b_6)
c_3=f_3(t+Delta_t/2,x+Delta_t/2*b_1,y+Delta_t/2*b_2,z+Delta_t/2*b_3,\
    v_x+Delta_t/2*b_4,v_y+Delta_t/2*b_5,v_z+Delta_t/2*b_6)
c_4=f_4(t+Delta_t/2,x+Delta_t/2*b_1,y+Delta_t/2*b_2,z+Delta_t/2*b_3,\
    v_x+Delta_t/2*b_4,v_y+Delta_t/2*b_5,v_z+Delta_t/2*b_6)
c_5=f_5(t+Delta_t/2,x+Delta_t/2*b_1,y+Delta_t/2*b_2,z+Delta_t/2*b_3,\
    v_x+Delta_t/2*b_4,v_y+Delta_t/2*b_5,v_z+Delta_t/2*b_6)
c_6=f_6(t+Delta_t/2,x+Delta_t/2*b_1,y+Delta_t/2*b_2,z+Delta_t/2*b_3,\
    v_x+Delta_t/2*b_4,v_y+Delta_t/2*b_5,v_z+Delta_t/2*b_6)

d_1=f_1(t+Delta_t,x+Delta_t*c_1,y+Delta_t*c_2,z+Delta_t*c_3,\
    v_x+Delta_t*c_4,v_y+Delta_t*c_5,v_z+Delta_t*c_6)
d_2=f_2(t+Delta_t,x+Delta_t*c_1,y+Delta_t*c_2,z+Delta_t*c_3,\
    v_x+Delta_t*c_4,v_y+Delta_t*c_5,v_z+Delta_t*c_6)
d_3=f_3(t+Delta_t,x+Delta_t*c_1,y+Delta_t*c_2,z+Delta_t*c_3,\
    v_x+Delta_t*c_4,v_y+Delta_t*c_5,v_z+Delta_t*c_6)
d_4=f_4(t+Delta_t,x+Delta_t*c_1,y+Delta_t*c_2,z+Delta_t*c_3,\
    v_x+Delta_t*c_4,v_y+Delta_t*c_5,v_z+Delta_t*c_6)
d_5=f_5(t+Delta_t,x+Delta_t*c_1,y+Delta_t*c_2,z+Delta_t*c_3,\
    v_x+Delta_t*c_4,v_y+Delta_t*c_5,v_z+Delta_t*c_6)
d_6=f_6(t+Delta_t,x+Delta_t*c_1,y+Delta_t*c_2,z+Delta_t*c_3,\
    v_x+Delta_t*c_4,v_y+Delta_t*c_5,v_z+Delta_t*c_6)



x=x+Delta_t/6*(a_1+2*b_1+2*c_1+d_1)
y=y+Delta_t/6*(a_2+2*b_2+2*c_2+d_2)
y=y+Delta_t/6*(a_3+2*b_3+2*c_3+d_3)
v_x=v_x+Delta_t/6*(a_4+2*b_4+2*c_4+d_4)
v_y=v_y+Delta_t/6*(a_5+2*b_5+2*c_5+d_5)
v_z=v_z+Delta_t/6*(a_6+2*b_6+2*c_6+d_6)



## end
#1176, 3544:
"""
+[P函数](,测试算法)
保存:...

"""
q=1
m=1

B_x = lambda x,y,z: x*0
B_y = lambda x,y,z: x*0
B_z = lambda x,y,z: x*0+1

E_x = lambda x,y,z: x*0
E_y = lambda x,y,z: x*0
E_z = lambda x,y,z: x*0

f_1=lambda t,x,y,z,v_x,v_y,v_z: v_x
f_2=lambda t,x,y,z,v_x,v_y,v_z: v_y
f_3=lambda t,x,y,z,v_x,v_y,v_z: v_z
f_4=lambda t,x,y,z,v_x,v_y,v_z: (v_y* B_z(x,y,z)-v_z* B_y(x,y,z)+ E_x(x,y,z))*q/m
f_5=lambda t,x,y,z,v_x,v_y,v_z: (v_z* B_x(x,y,z)-v_x* B_z(x,y,z)+ E_y(x,y,z))*q/m
f_6=lambda t,x,y,z,v_x,v_y,v_z: (v_x* B_y(x,y,z)-v_y* B_x(x,y,z)+ E_z(x,y,z))*q/m


t=0
x=0
y=0
z=0
v_x=1
v_y=0
v_z=0
Delta_t=0.1


for i in range(1000):
    a_1=f_1(t,x,y,z,v_x,v_y,v_z)
    a_2=f_2(t,x,y,z,v_x,v_y,v_z)
    a_3=f_3(t,x,y,z,v_x,v_y,v_z)
    a_4=f_4(t,x,y,z,v_x,v_y,v_z)
    a_5=f_5(t,x,y,z,v_x,v_y,v_z)
    a_6=f_6(t,x,y,z,v_x,v_y,v_z)
    
    b_1=f_1(t+Delta_t/2,x+Delta_t/2*a_1,y+Delta_t/2*a_2,z+Delta_t/2*a_3,\
        v_x+Delta_t/2*a_4,v_y+Delta_t/2*a_5,v_z+Delta_t/2*a_6)
    b_2=f_2(t+Delta_t/2,x+Delta_t/2*a_1,y+Delta_t/2*a_2,z+Delta_t/2*a_3,\
        v_x+Delta_t/2*a_4,v_y+Delta_t/2*a_5,v_z+Delta_t/2*a_6)
    b_3=f_3(t+Delta_t/2,x+Delta_t/2*a_1,y+Delta_t/2*a_2,z+Delta_t/2*a_3,\
        v_x+Delta_t/2*a_4,v_y+Delta_t/2*a_5,v_z+Delta_t/2*a_6)
    b_4=f_4(t+Delta_t/2,x+Delta_t/2*a_1,y+Delta_t/2*a_2,z+Delta_t/2*a_3,\
        v_x+Delta_t/2*a_4,v_y+Delta_t/2*a_5,v_z+Delta_t/2*a_6)
    b_5=f_5(t+Delta_t/2,x+Delta_t/2*a_1,y+Delta_t/2*a_2,z+Delta_t/2*a_3,\
        v_x+Delta_t/2*a_4,v_y+Delta_t/2*a_5,v_z+Delta_t/2*a_6)
    b_6=f_6(t+Delta_t/2,x+Delta_t/2*a_1,y+Delta_t/2*a_2,z+Delta_t/2*a_3,\
        v_x+Delta_t/2*a_4,v_y+Delta_t/2*a_5,v_z+Delta_t/2*a_6)
    
    c_1=f_1(t+Delta_t/2,x+Delta_t/2*b_1,y+Delta_t/2*b_2,z+Delta_t/2*b_3,\
        v_x+Delta_t/2*b_4,v_y+Delta_t/2*b_5,v_z+Delta_t/2*b_6)
    c_2=f_2(t+Delta_t/2,x+Delta_t/2*b_1,y+Delta_t/2*b_2,z+Delta_t/2*b_3,\
        v_x+Delta_t/2*b_4,v_y+Delta_t/2*b_5,v_z+Delta_t/2*b_6)
    c_3=f_3(t+Delta_t/2,x+Delta_t/2*b_1,y+Delta_t/2*b_2,z+Delta_t/2*b_3,\
        v_x+Delta_t/2*b_4,v_y+Delta_t/2*b_5,v_z+Delta_t/2*b_6)
    c_4=f_4(t+Delta_t/2,x+Delta_t/2*b_1,y+Delta_t/2*b_2,z+Delta_t/2*b_3,\
        v_x+Delta_t/2*b_4,v_y+Delta_t/2*b_5,v_z+Delta_t/2*b_6)
    c_5=f_5(t+Delta_t/2,x+Delta_t/2*b_1,y+Delta_t/2*b_2,z+Delta_t/2*b_3,\
        v_x+Delta_t/2*b_4,v_y+Delta_t/2*b_5,v_z+Delta_t/2*b_6)
    c_6=f_6(t+Delta_t/2,x+Delta_t/2*b_1,y+Delta_t/2*b_2,z+Delta_t/2*b_3,\
        v_x+Delta_t/2*b_4,v_y+Delta_t/2*b_5,v_z+Delta_t/2*b_6)
    
    d_1=f_1(t+Delta_t,x+Delta_t*c_1,y+Delta_t*c_2,z+Delta_t*c_3,\
        v_x+Delta_t*c_4,v_y+Delta_t*c_5,v_z+Delta_t*c_6)
    d_2=f_2(t+Delta_t,x+Delta_t*c_1,y+Delta_t*c_2,z+Delta_t*c_3,\
        v_x+Delta_t*c_4,v_y+Delta_t*c_5,v_z+Delta_t*c_6)
    d_3=f_3(t+Delta_t,x+Delta_t*c_1,y+Delta_t*c_2,z+Delta_t*c_3,\
        v_x+Delta_t*c_4,v_y+Delta_t*c_5,v_z+Delta_t*c_6)
    d_4=f_4(t+Delta_t,x+Delta_t*c_1,y+Delta_t*c_2,z+Delta_t*c_3,\
        v_x+Delta_t*c_4,v_y+Delta_t*c_5,v_z+Delta_t*c_6)
    d_5=f_5(t+Delta_t,x+Delta_t*c_1,y+Delta_t*c_2,z+Delta_t*c_3,\
        v_x+Delta_t*c_4,v_y+Delta_t*c_5,v_z+Delta_t*c_6)
    d_6=f_6(t+Delta_t,x+Delta_t*c_1,y+Delta_t*c_2,z+Delta_t*c_3,\
        v_x+Delta_t*c_4,v_y+Delta_t*c_5,v_z+Delta_t*c_6)
    
    
    
    x=x+Delta_t/6*(a_1+2*b_1+2*c_1+d_1)
    y=y+Delta_t/6*(a_2+2*b_2+2*c_2+d_2)
    z=z+Delta_t/6*(a_3+2*b_3+2*c_3+d_3)
    v_x=v_x+Delta_t/6*(a_4+2*b_4+2*c_4+d_4)
    v_y=v_y+Delta_t/6*(a_5+2*b_5+2*c_5+d_5)
    v_z=v_z+Delta_t/6*(a_6+2*b_6+2*c_6+d_6)
    
    print(x,y,z)
    print(v_x,v_y,v_z)


"""
+[P函数](,单点测试)

"""
## end
#1178, 94:
https://matplotlib.org/stable/gallery/mplot3d/lines3d.html#sphx-glr-gallery-mplot3d-lines3d-py
## end
#1180, 352:
"""
+[P函数](,测试plot)

"""

import numpy as np
import matplotlib.pyplot as plt


ax = plt.figure().add_subplot(projection='3d')

# Prepare arrays x, y, z
theta = np.linspace(-4 * np.pi, 4 * np.pi, 100)
z = np.linspace(-2, 2, 100)
r = z**2 + 1
x = r * np.sin(theta)
y = r * np.cos(theta)

ax.plot(x, y, z, label='parametric curve')
ax.legend()

plt.show()
## end
#1182, 3834:
"""
+[P函数](,显示轨迹)
参考::https://matplotlib.org/stable/gallery/mplot3d/lines3d.html#sphx-glr-gallery-mplot3d-lines3d-py

单点测试:...
测试plot:...

保存:...

"""

import numpy as np
import matplotlib.pyplot as plt

q=1
m=1

B_x = lambda x,y,z: x*0
B_y = lambda x,y,z: x*0
B_z = lambda x,y,z: x*0+1

E_x = lambda x,y,z: x*0
E_y = lambda x,y,z: x*0
E_z = lambda x,y,z: x*0

f_1=lambda t,x,y,z,v_x,v_y,v_z: v_x
f_2=lambda t,x,y,z,v_x,v_y,v_z: v_y
f_3=lambda t,x,y,z,v_x,v_y,v_z: v_z
f_4=lambda t,x,y,z,v_x,v_y,v_z: (v_y* B_z(x,y,z)-v_z* B_y(x,y,z)+ E_x(x,y,z))*q/m
f_5=lambda t,x,y,z,v_x,v_y,v_z: (v_z* B_x(x,y,z)-v_x* B_z(x,y,z)+ E_y(x,y,z))*q/m
f_6=lambda t,x,y,z,v_x,v_y,v_z: (v_x* B_y(x,y,z)-v_y* B_x(x,y,z)+ E_z(x,y,z))*q/m


t=0
x=0
y=0
z=0
v_x=1
v_y=0
v_z=0
Delta_t=0.1
X,Y,Z=[],[],[]

for i in range(1000):
    a_1=f_1(t,x,y,z,v_x,v_y,v_z)
    a_2=f_2(t,x,y,z,v_x,v_y,v_z)
    a_3=f_3(t,x,y,z,v_x,v_y,v_z)
    a_4=f_4(t,x,y,z,v_x,v_y,v_z)
    a_5=f_5(t,x,y,z,v_x,v_y,v_z)
    a_6=f_6(t,x,y,z,v_x,v_y,v_z)
    
    b_1=f_1(t+Delta_t/2,x+Delta_t/2*a_1,y+Delta_t/2*a_2,z+Delta_t/2*a_3,\
        v_x+Delta_t/2*a_4,v_y+Delta_t/2*a_5,v_z+Delta_t/2*a_6)
    b_2=f_2(t+Delta_t/2,x+Delta_t/2*a_1,y+Delta_t/2*a_2,z+Delta_t/2*a_3,\
        v_x+Delta_t/2*a_4,v_y+Delta_t/2*a_5,v_z+Delta_t/2*a_6)
    b_3=f_3(t+Delta_t/2,x+Delta_t/2*a_1,y+Delta_t/2*a_2,z+Delta_t/2*a_3,\
        v_x+Delta_t/2*a_4,v_y+Delta_t/2*a_5,v_z+Delta_t/2*a_6)
    b_4=f_4(t+Delta_t/2,x+Delta_t/2*a_1,y+Delta_t/2*a_2,z+Delta_t/2*a_3,\
        v_x+Delta_t/2*a_4,v_y+Delta_t/2*a_5,v_z+Delta_t/2*a_6)
    b_5=f_5(t+Delta_t/2,x+Delta_t/2*a_1,y+Delta_t/2*a_2,z+Delta_t/2*a_3,\
        v_x+Delta_t/2*a_4,v_y+Delta_t/2*a_5,v_z+Delta_t/2*a_6)
    b_6=f_6(t+Delta_t/2,x+Delta_t/2*a_1,y+Delta_t/2*a_2,z+Delta_t/2*a_3,\
        v_x+Delta_t/2*a_4,v_y+Delta_t/2*a_5,v_z+Delta_t/2*a_6)
    
    c_1=f_1(t+Delta_t/2,x+Delta_t/2*b_1,y+Delta_t/2*b_2,z+Delta_t/2*b_3,\
        v_x+Delta_t/2*b_4,v_y+Delta_t/2*b_5,v_z+Delta_t/2*b_6)
    c_2=f_2(t+Delta_t/2,x+Delta_t/2*b_1,y+Delta_t/2*b_2,z+Delta_t/2*b_3,\
        v_x+Delta_t/2*b_4,v_y+Delta_t/2*b_5,v_z+Delta_t/2*b_6)
    c_3=f_3(t+Delta_t/2,x+Delta_t/2*b_1,y+Delta_t/2*b_2,z+Delta_t/2*b_3,\
        v_x+Delta_t/2*b_4,v_y+Delta_t/2*b_5,v_z+Delta_t/2*b_6)
    c_4=f_4(t+Delta_t/2,x+Delta_t/2*b_1,y+Delta_t/2*b_2,z+Delta_t/2*b_3,\
        v_x+Delta_t/2*b_4,v_y+Delta_t/2*b_5,v_z+Delta_t/2*b_6)
    c_5=f_5(t+Delta_t/2,x+Delta_t/2*b_1,y+Delta_t/2*b_2,z+Delta_t/2*b_3,\
        v_x+Delta_t/2*b_4,v_y+Delta_t/2*b_5,v_z+Delta_t/2*b_6)
    c_6=f_6(t+Delta_t/2,x+Delta_t/2*b_1,y+Delta_t/2*b_2,z+Delta_t/2*b_3,\
        v_x+Delta_t/2*b_4,v_y+Delta_t/2*b_5,v_z+Delta_t/2*b_6)
    
    d_1=f_1(t+Delta_t,x+Delta_t*c_1,y+Delta_t*c_2,z+Delta_t*c_3,\
        v_x+Delta_t*c_4,v_y+Delta_t*c_5,v_z+Delta_t*c_6)
    d_2=f_2(t+Delta_t,x+Delta_t*c_1,y+Delta_t*c_2,z+Delta_t*c_3,\
        v_x+Delta_t*c_4,v_y+Delta_t*c_5,v_z+Delta_t*c_6)
    d_3=f_3(t+Delta_t,x+Delta_t*c_1,y+Delta_t*c_2,z+Delta_t*c_3,\
        v_x+Delta_t*c_4,v_y+Delta_t*c_5,v_z+Delta_t*c_6)
    d_4=f_4(t+Delta_t,x+Delta_t*c_1,y+Delta_t*c_2,z+Delta_t*c_3,\
        v_x+Delta_t*c_4,v_y+Delta_t*c_5,v_z+Delta_t*c_6)
    d_5=f_5(t+Delta_t,x+Delta_t*c_1,y+Delta_t*c_2,z+Delta_t*c_3,\
        v_x+Delta_t*c_4,v_y+Delta_t*c_5,v_z+Delta_t*c_6)
    d_6=f_6(t+Delta_t,x+Delta_t*c_1,y+Delta_t*c_2,z+Delta_t*c_3,\
        v_x+Delta_t*c_4,v_y+Delta_t*c_5,v_z+Delta_t*c_6)
    
    
    
    x=x+Delta_t/6*(a_1+2*b_1+2*c_1+d_1)
    y=y+Delta_t/6*(a_2+2*b_2+2*c_2+d_2)
    z=z+Delta_t/6*(a_3+2*b_3+2*c_3+d_3)
    v_x=v_x+Delta_t/6*(a_4+2*b_4+2*c_4+d_4)
    v_y=v_y+Delta_t/6*(a_5+2*b_5+2*c_5+d_5)
    v_z=v_z+Delta_t/6*(a_6+2*b_6+2*c_6+d_6)

    X.append(x)
    Y.append(y)
    Z.append(z)
    

plt.figure().add_subplot(projection="3d")
ax=plt.gca()
ax.plot(X,Y,Z)
ax.grid()
plt.show()



"""
+[P函数](,测试算法)

"""
## end
#1184, 4097:
"""
+[P函数](,多条轨迹)
参考::https://matplotlib.org/stable/gallery/mplot3d/lines3d.html#sphx-glr-gallery-mplot3d-lines3d-py

单点测试:...
显示轨迹:...
多条轨迹:...
测试plot:...

保存:...

"""

import numpy as np
import matplotlib.pyplot as plt

q=1
m=1

B_x = lambda x,y,z: x*0
B_y = lambda x,y,z: x*0
B_z = lambda x,y,z: x*0+1

E_x = lambda x,y,z: x*0
E_y = lambda x,y,z: x*0
E_z = lambda x,y,z: x*0

f_1=lambda t,x,y,z,v_x,v_y,v_z: v_x
f_2=lambda t,x,y,z,v_x,v_y,v_z: v_y
f_3=lambda t,x,y,z,v_x,v_y,v_z: v_z
f_4=lambda t,x,y,z,v_x,v_y,v_z: (v_y* B_z(x,y,z)-v_z* B_y(x,y,z)+ E_x(x,y,z))*q/m
f_5=lambda t,x,y,z,v_x,v_y,v_z: (v_z* B_x(x,y,z)-v_x* B_z(x,y,z)+ E_y(x,y,z))*q/m
f_6=lambda t,x,y,z,v_x,v_y,v_z: (v_x* B_y(x,y,z)-v_y* B_x(x,y,z)+ E_z(x,y,z))*q/m

N=5
t=0
x=np.linspace(0,0,N)
y=np.linspace(0,0,N)
z=np.linspace(0,0,N)
v_x=np.linspace(1,2,N)
v_y=np.linspace(0,0,N)
v_z=np.linspace(0,0,N)
Delta_t=0.1
X,Y,Z=[],[],[]

for i in range(1000):
    a_1=f_1(t,x,y,z,v_x,v_y,v_z)
    a_2=f_2(t,x,y,z,v_x,v_y,v_z)
    a_3=f_3(t,x,y,z,v_x,v_y,v_z)
    a_4=f_4(t,x,y,z,v_x,v_y,v_z)
    a_5=f_5(t,x,y,z,v_x,v_y,v_z)
    a_6=f_6(t,x,y,z,v_x,v_y,v_z)
    
    b_1=f_1(t+Delta_t/2,x+Delta_t/2*a_1,y+Delta_t/2*a_2,z+Delta_t/2*a_3,\
        v_x+Delta_t/2*a_4,v_y+Delta_t/2*a_5,v_z+Delta_t/2*a_6)
    b_2=f_2(t+Delta_t/2,x+Delta_t/2*a_1,y+Delta_t/2*a_2,z+Delta_t/2*a_3,\
        v_x+Delta_t/2*a_4,v_y+Delta_t/2*a_5,v_z+Delta_t/2*a_6)
    b_3=f_3(t+Delta_t/2,x+Delta_t/2*a_1,y+Delta_t/2*a_2,z+Delta_t/2*a_3,\
        v_x+Delta_t/2*a_4,v_y+Delta_t/2*a_5,v_z+Delta_t/2*a_6)
    b_4=f_4(t+Delta_t/2,x+Delta_t/2*a_1,y+Delta_t/2*a_2,z+Delta_t/2*a_3,\
        v_x+Delta_t/2*a_4,v_y+Delta_t/2*a_5,v_z+Delta_t/2*a_6)
    b_5=f_5(t+Delta_t/2,x+Delta_t/2*a_1,y+Delta_t/2*a_2,z+Delta_t/2*a_3,\
        v_x+Delta_t/2*a_4,v_y+Delta_t/2*a_5,v_z+Delta_t/2*a_6)
    b_6=f_6(t+Delta_t/2,x+Delta_t/2*a_1,y+Delta_t/2*a_2,z+Delta_t/2*a_3,\
        v_x+Delta_t/2*a_4,v_y+Delta_t/2*a_5,v_z+Delta_t/2*a_6)
    
    c_1=f_1(t+Delta_t/2,x+Delta_t/2*b_1,y+Delta_t/2*b_2,z+Delta_t/2*b_3,\
        v_x+Delta_t/2*b_4,v_y+Delta_t/2*b_5,v_z+Delta_t/2*b_6)
    c_2=f_2(t+Delta_t/2,x+Delta_t/2*b_1,y+Delta_t/2*b_2,z+Delta_t/2*b_3,\
        v_x+Delta_t/2*b_4,v_y+Delta_t/2*b_5,v_z+Delta_t/2*b_6)
    c_3=f_3(t+Delta_t/2,x+Delta_t/2*b_1,y+Delta_t/2*b_2,z+Delta_t/2*b_3,\
        v_x+Delta_t/2*b_4,v_y+Delta_t/2*b_5,v_z+Delta_t/2*b_6)
    c_4=f_4(t+Delta_t/2,x+Delta_t/2*b_1,y+Delta_t/2*b_2,z+Delta_t/2*b_3,\
        v_x+Delta_t/2*b_4,v_y+Delta_t/2*b_5,v_z+Delta_t/2*b_6)
    c_5=f_5(t+Delta_t/2,x+Delta_t/2*b_1,y+Delta_t/2*b_2,z+Delta_t/2*b_3,\
        v_x+Delta_t/2*b_4,v_y+Delta_t/2*b_5,v_z+Delta_t/2*b_6)
    c_6=f_6(t+Delta_t/2,x+Delta_t/2*b_1,y+Delta_t/2*b_2,z+Delta_t/2*b_3,\
        v_x+Delta_t/2*b_4,v_y+Delta_t/2*b_5,v_z+Delta_t/2*b_6)
    
    d_1=f_1(t+Delta_t,x+Delta_t*c_1,y+Delta_t*c_2,z+Delta_t*c_3,\
        v_x+Delta_t*c_4,v_y+Delta_t*c_5,v_z+Delta_t*c_6)
    d_2=f_2(t+Delta_t,x+Delta_t*c_1,y+Delta_t*c_2,z+Delta_t*c_3,\
        v_x+Delta_t*c_4,v_y+Delta_t*c_5,v_z+Delta_t*c_6)
    d_3=f_3(t+Delta_t,x+Delta_t*c_1,y+Delta_t*c_2,z+Delta_t*c_3,\
        v_x+Delta_t*c_4,v_y+Delta_t*c_5,v_z+Delta_t*c_6)
    d_4=f_4(t+Delta_t,x+Delta_t*c_1,y+Delta_t*c_2,z+Delta_t*c_3,\
        v_x+Delta_t*c_4,v_y+Delta_t*c_5,v_z+Delta_t*c_6)
    d_5=f_5(t+Delta_t,x+Delta_t*c_1,y+Delta_t*c_2,z+Delta_t*c_3,\
        v_x+Delta_t*c_4,v_y+Delta_t*c_5,v_z+Delta_t*c_6)
    d_6=f_6(t+Delta_t,x+Delta_t*c_1,y+Delta_t*c_2,z+Delta_t*c_3,\
        v_x+Delta_t*c_4,v_y+Delta_t*c_5,v_z+Delta_t*c_6)
    
    
    
    x=x+Delta_t/6*(a_1+2*b_1+2*c_1+d_1)
    y=y+Delta_t/6*(a_2+2*b_2+2*c_2+d_2)
    z=z+Delta_t/6*(a_3+2*b_3+2*c_3+d_3)
    v_x=v_x+Delta_t/6*(a_4+2*b_4+2*c_4+d_4)
    v_y=v_y+Delta_t/6*(a_5+2*b_5+2*c_5+d_5)
    v_z=v_z+Delta_t/6*(a_6+2*b_6+2*c_6+d_6)
    
    X.append(x)
    Y.append(y)
    Z.append(z)

X=np.array(X)
Y=np.array(Y)
Z=np.array(Z)



plt.figure().add_subplot(projection="3d")
ax=plt.gca()

for i in range(N):
    ax.plot(X[:,i],Y[:,i],Z[:,i])

ax.grid()
plt.show()



"""
print(len(X))
print(np.array([[1,2],[3,4]]))
记住"Python"
+[P函数](,测试算法)

"""
## end
#1190, 23:
2023-06-17 Sat 16:43:52
## end
#1192, 13:
Xiantao Cheng
## end
#1195, 2675:
"""
地址::/home/xiantao/Documents/Projects/py-sem/src/tracks.py
+[保存P函数]"Xiantao Cheng"(,tracks)
+[P函数](,tracks)

测试运行:...
+[新建阅读窗口](,测试运行)

"""

import numpy as np
import matplotlib.pyplot as plt


class Tracks:
    def __init__(self,x0=0,y0=0,z0=0,vx0=0,vy0=0,vz0=0):
        self.m_x0=np.array(x0)
        self.m_y0=np.array(y0)
        self.m_z0=np.array(z0)
        self.m_vx0=np.array(vx0)
        self.m_vy0=np.array(vy0)
        self.m_vz0=np.array(vz0)

    def setPos(self,x0,y0,z0):
        self.m_x0=np.array(x0)
        self.m_y0=np.array(y0)
        self.m_z0=np.array(z0)

    def setVec(self,vx0,vy0,vz0):
        self.m_vx0=np.array(vx0)
        self.m_vy0=np.array(vy0)
        self.m_vz0=np.array(vz0)

    def getIntersection(self,v_f,r_0):
        v_f=v_f/np.linalg.norm(v_f)
        f_x=v_f[0]
        f_y=v_f[1]
        f_z=v_f[2]
        x_0=r_0[0]
        y_0=r_0[1]
        z_0=r_0[2]
        
        x_A=self.m_x0[0:-1,:]
        y_A=self.m_y0[0:-1,:]
        z_A=self.m_z0[0:-1,:]
        x_B=self.m_x0[1:,:]
        y_B=self.m_y0[1:,:]
        z_B=self.m_z0[1:,:]
        
        t=(f_x*(x_0-x_A)+f_y*(y_0-y_A)+f_z*(z_0-z_A))/(f_x*(x_B-x_A)+f_y*(y_B-y_A)+f_z*(z_B-z_A))
        i0=np.logical_and(t>0,t<1)
        
        xs=x_A[i0]+t[i0]*(x_B[i0]-x_A[i0])
        ys=y_A[i0]+t[i0]*(y_B[i0]-y_A[i0])
        zs=z_A[i0]+t[i0]*(z_B[i0]-z_A[i0])
        
        return xs,ys,zs



    def view(self, fig_num=None, fig_type="3d",ax0=None):
        if fig_type=="2d":
            self.view_2d(fig_num,ax0=ax0)
        else:
            self.view_3d(fig_num,ax0=ax0)

    def view_2d(self,fig_num=None,ax0=None):
        if ax0==None:
            plt.figure()
            ax=plt.gca()
        else:
            ax=ax0
        
        X,Y,Z=self.m_x0, self.m_y0, self.m_z0
        if len(X.shape)==2:
            N=X.shape[1]
            for i in range(N):
                ax.plot(X[:,i],Y[:,i])
        else:
            ax.plot(X,Y,Z)
        
        if ax0==None:
            ax.grid()
            plt.show()

    def view_3d(self,fig_num=None,ax0=None):
        if ax0==None:
            plt.figure().add_subplot(projection="3d")
            ax=plt.gca()
            # ax.set_aspect('equal')
        else:
            ax=ax0
        
        X,Y,Z=self.m_x0, self.m_y0, self.m_z0
        if len(X.shape)==2:
            N=X.shape[1]
            for i in range(N):
                ax.plot(X[:,i],Y[:,i],Z[:,i])
        else:
            ax.plot(X,Y,Z)
        
        if ax0==None:
            ax.grid()
            ax.set_xlabel("X")
            ax.set_ylabel("Y")
            ax.set_zlabel("Z")
            plt.show()


"""
+[P函数](,tracks)

"""
## end
#1197, 53:
/home/xiantao/Documents/Projects/py-sem/src/tracks.py
## end
#1199, 1228:
"""
地址::/home/xiantao/Documents/Projects/py-sem/examples/unit_testing/stepper_test.py
+[保存P函数]"Xiantao Cheng"(,测试运行)
+[P函数](,测试运行)

匀强磁场轨迹:...
交点测试1:...

"""

import numpy as np
import matplotlib.pyplot as plt
import sys
if __name__=='__main__':
    sys.path.append(sys.path[0]+'/../..')
from src.stepper import EM_stepper
from src.tracks import Tracks
# from src.elements import *



B_x = lambda x,y,z: x*0
B_y = lambda x,y,z: x*0
B_z = lambda x,y,z: x*0+1

E_x = lambda x,y,z: x*0
E_y = lambda x,y,z: x*0
E_z = lambda x,y,z: x*0+0.1

N=10
t=0
x=np.linspace(0,0,N)
y=np.linspace(0,0,N)
z=np.linspace(0,0,N)
v_x=np.linspace(1,2,N)
v_y=np.linspace(0,0,N)
v_z=np.linspace(0,0,N)

stepper=EM_stepper(x,y,z,v_x,v_y,v_z)
stepper.setBField(B_x,B_y,B_z)
stepper.setEField(E_x,E_y,E_z)
X,Y,Z=stepper.stepOn(1000,0.1)

test_e=Tracks(X,Y,Z)
v_f=np.array([1.,1.,0.1])
r_0=np.array([0.,0.,0.])

xs,ys,zs=test_e.getIntersection(v_f,r_0)

fig = plt.figure()
ax = fig.add_subplot(projection='3d')

ax.scatter(xs, ys, zs, marker='o')
plt.show()

# test_e.view()

"""
print(X[1,:])
print(np.logical_and(t>0,t<1))
print(len(x_A[t<1]))
print(len(x_A[t<1 and t>0]))
t0=np.logical_and(t>0,t<1)
print(len(x_A[t0]))
print(x_A[t0])

+[P函数](,测试运行)

"""
## end
#1200, 23:
2023-06-17 Sat 17:27:43
## end
#1202, 13:
Xiantao Cheng
## end
#1205, 3662:
"""
地址::/home/xiantao/Documents/Projects/py-sem/src/hevean.py
+[保存P函数]"Xiantao Cheng"(,hevean)
+[P函数](,hevean)

测试流程:...
+[新建阅读窗口](,测试流程)

"""

import numpy as np
import matplotlib.pyplot as plt
from src.space import Space
from src.stepper import EM_stepper
from src.tracks import Tracks
from src.basic_tools import *
from src.matlab_style_draw import *


class Lucifer:
    def __init__(self):
        self.m_world=Space()
        self.m_laws=EM_stepper()
        self.m_sprites=Tracks()

    def create(self,objects):
        self.m_world.add_obj(objects)
        E_x, E_y, E_z=self.m_world.get_EField()
        B_x, B_y, B_z=self.m_world.get_BField()
        
        self.m_laws.setBField(B_x,B_y,B_z)
        self.m_laws.setEField(E_x,E_y,E_z)

    def YmirBody(self,n):
        sources=self.m_world.get_obj('source')
        if sources==[]:
            x=np.linspace(0,0,n)
            y=np.linspace(0,0,n)
            z=np.linspace(0,0,n)
            v_x=np.linspace(1,2,n)
            v_y=np.linspace(0,0,n)
            v_z=np.linspace(0,0,n)
        else:
#             x,y,z,v_x,v_y,v_z=sources[0].genSeed(n,'regular')
            x,y,z,v_x,v_y,v_z=sources[0].genSeed(n)
        return x,y,z,v_x,v_y,v_z


    def run(self,N,Dt,n=10):
        x,y,z,v_x,v_y,v_z=self.YmirBody(n)
        
        self.m_laws.setPos(x,y,z)
        self.m_laws.setVec(v_x,v_y,v_z)
        X,Y,Z=self.m_laws.stepOn(N,Dt)
        self.m_sprites.setPos(X,Y,Z)

    def show(self, show_type="trajectory"):
        if show_type=="trajectory":
            self.m_sprites.view()
        elif show_type=="trajectory_2d":
            self.m_sprites.view_2d()
        elif show_type=="scene":
            self.m_world.view_scene()
        elif show_type=="field":
            self.m_world.view_field(-5e-2,5e-2,-5e-2,5e-2,'B')
        elif show_type=="B_field":
            self.m_world.view_field(-5e-2,5e-2,-5e-2,5e-2,'B')
        elif show_type=="E_field":
            self.m_world.view_field(-5e-2,5e-2,-5e-2,5e-2,'E')
        else:
            self.m_sprites.view()


    def show_array(self, show_array=None):
        if show_array==None:
            self.show()
        elif "2D" in show_array:
            plt.figure()
            ax=plt.gca()
        
            for show_type in show_array:
                if show_type=="trajectory":
                    self.m_sprites.view_2d(ax0=ax)
                elif show_type=="trajectory_2d":
                    self.m_sprites.view_2d(ax0=ax)
                elif show_type=="scene":
                    self.m_world.view_scene(ax0=ax)
                elif show_type=="field":
                    self.m_world.view_field(-5e-2,5e-2,-5e-2,5e-2,'B',ax0=ax)
                elif show_type=="B_field":
                    self.m_world.view_field(-5e-2,5e-2,-5e-2,5e-2,'B',ax0=ax)
                elif show_type=="E_field":
                    self.m_world.view_field(-5e-2,5e-2,-5e-2,5e-2,'E',ax0=ax)
    
            ax.grid()
            plt.show()

    def show_detection(self):
        screen=self.m_world.get_obj('screen')
        if screen==[]:
            return
        screen=screen[0]
        x0,y0,z0=screen.getPos()
        vx,vy,vz=screen.getLocalFrame()

        xs,ys,zs=self.m_sprites.getIntersection(vz,[x0,y0,z0])
        fxs=vx[0]*(xs-x0)+vx[1]*(ys-y0)+vx[2]*(zs-z0)
        fys=vy[0]*(xs-x0)+vy[1]*(ys-y0)+vy[2]*(zs-z0)

        plt.figure()
        ax=plt.gca()

        ax.scatter(fxs,fys,marker='o')

        ax.axis('equal')
        ax.grid()
        plt.show()

        return fxs,fys




"""
print(np.dot([1,2],[2,1]))
print(x==None)
print([]==None)
print(type(x)==type(np.array([1])))
+[P函数](,hevean)

"""
## end
#1207, 1294:
"""
地址::/home/xiantao/Documents/Projects/py-sem/examples/Coils.py
+[保存P函数]"Xiantao Cheng"(,测试流程)
+[运行P函数](,测试流程)
+[P函数](,测试流程)

基本流程:...
整合流程:...

例子_磁场:...
例子_点电场:...
例子_电透镜:...
例子_屏幕:...
例子_电子源:...
例子_电子轨迹:...
例子_线圈旋转:...
+[新建阅读窗口](,例子_电子源)

记住"Python"
del str
保存:...
记住"Python"


"""
import sys
if __name__=='__main__':
    sys.path.append(sys.path[0]+'/..')
from src.hevean import Lucifer
from src.elements import *


N=600
Dt=0.00015

luc=Lucifer()


"""
+[P函数](,测试流程)

"""

ele_2a = MagneticDipole("Ma",x=-3.e-2,y=1.5e-2,R=10e-3, an0=30., I=34.e-4)
ele_2b = MagneticDipole("Mb",x=-1.6e-2,y=0.5e-2,R=10e-3, an0=60., I=24.e-4)
ele_2c = MagneticDipole("Mc",x=0.e-2,y=0.,R=10e-3, an0=90., I=24.e-4)
ele_2d = MagneticDipole("Md",x=1.5e-2,y=0.e-2,R=10e-3, an0=90., I=24.e-4)
ele_2e = MagneticDipole("Me",x=3.e-2,y=0.e-2,R=10e-3, an0=90., I=24.e-4)

ele_3 = Screen("D0",x=10.e-2,y=0.,H=50e-3, an0=0.)
ele_4 = Source("S1",x=-5.e-2,y=4.e-2, an0=-50., Dan=10., srcType='regular')
luc.create([ele_2a,ele_2b,ele_2c,ele_2d,ele_2e,ele_3,ele_4])

luc.show_array(["2D","scene","B_field","E_field"])
luc.run(N,Dt,20)
# luc.show('trajectory')
luc.show_array(["2D","scene","B_field","E_field","trajectory"])
# luc.show('trajectory_2d')
# luc.show_detection()



"""
luc.show('trajectory')
+[P函数](,测试流程)

"""
## end
#1209, 703:
"""
+[P函数](,基本流程)

"""

N=10
t=0

x=np.linspace(0,0,N)
y=np.linspace(0,0,N)
z=np.linspace(0,0,N)
v_x=np.linspace(1,2,N)
v_y=np.linspace(0,0,N)
v_z=np.linspace(0,0,N)

world=Space()

ele_1=MagneticDipole("M1",x=-0.5,y=0.3, I=1)
ele_2=MagneticDipole("M2",x=0.,y=0.3, I=-1)
ele_3=MagneticDipole("M2",x=0.5,y=0.3, I=-1)
world.add_obj([ele_1,ele_2,ele_3])

# world.view_scene()
# world.view_field(-1.5,1.5,-1,1)

E_x, E_y, E_z=world.get_EField()
B_x, B_y, B_z=world.get_BField()

stepper=EM_stepper(x,y,z,v_x,v_y,v_z)
stepper.setBField(B_x,B_y,B_z)
stepper.setEField(E_x,E_y,E_z)
X,Y,Z=stepper.stepOn(100,0.001)

test_e=Tracks(X,Y,Z)
test_e.view()



"""
print()
print(world,type)
del type
+[P函数](,测试流程)

"""
## end
#1211, 53:
/home/xiantao/Documents/Projects/py-sem/src/hevean.py
## end
#1212, 23:
2023-06-17 Sat 17:58:39
## end
#1214, 13:
Xiantao Cheng
## end
#1217, 273:
"""
+[P函数](,整合流程)

"""

N=1000
Dt=0.001

luc=Lucifer()

ele_1=MagneticDipole("M1",x=-0.5,y=0.3, I=1)
ele_2=MagneticDipole("M2",x=0.,y=0.3, I=-1)
ele_3=MagneticDipole("M2",x=0.5,y=0.3, I=-1)

luc.create([ele_1,ele_2,ele_3])
luc.run(N,Dt)
luc.show()



"""
+[P函数](,测试流程)

"""
## end
#1219, 523:
"""
+[P函数](,线圈磁场)
记住"Python"

"""

world=Space()

ele_1=MagneticDipole("M2",x=0.,y=50e-3, I=1, R=40.e-3, r=5.e-3, an0=10.)
ele_2=MagneticDipole("M2",x=0.,y=0, I=1, R=20.e-3, r=5.e-3, an0=-10.)
ele_3=MagneticDipole("M2",x=0.,y=-50e-3, I=1, R=40.e-3, r=5.e-3, an0=10.)
world.add_obj([ele_1,ele_2,ele_3])

# ele_2=MagneticDipole("M2",x=0.,y=0, I=1, R=20.e-3, r=5.e-3, an0=-10.)
# world.add_obj([ele_2])

world.view_scene()
world.view_field(-50e-3,50e-3,-50e-3,50e-3)


"""
print(world.m_Bx)
print(Bx(X,Y,Z))
+[P函数](,线圈磁场)

"""
## end
#1221, 656:
"""
+[P函数](,测试场景)

显示场景:...
显示磁场_1D:...
显示磁场_2D:...

线圈磁场:...
四级子电场:...

保存:...

"""

world=Space()


ele_1 = PointField("E1",x=5.e-2,y=0., Q=1)
ele_2 = PointField("E2",x=-5.e-2,y=0., Q=1)
ele_3 = PointField("E1",y=5.e-2,x=0., Q=-1)
ele_4 = PointField("E2",y=-5.e-2,x=0., Q=-1)

# ele_5 = UniformField("E5",x=-10.e-2,y=0., H=20.e-2, W=20.e-2, E=[10.,1000.,0])
ele_5 = UniformField("E5",x=-10.e-2,y=0., H=20.e-2, W=20.e-2,)

world.add_obj([ele_1,ele_2,ele_3,ele_4,ele_5])

world.view_scene()
# world.view_field(-30.e-2,30.e-2,-30.e-2,30.e-2,'E')
world.view_field(-10.e-2,10.e-2,-10.e-2,10.e-2,'E')


"""
print(world.m_Bx)
print(Bx(X,Y,Z))
+[P函数](,测试场景)

"""
## end
#1223, 606:
"""
+[P函数](,测试流程)

基本流程:...
整合流程:...
记住"Python"
del str

"""

N=100
Dt=0.0001

luc=Lucifer()

ele_1=MagneticDipole("M1",x=0.,y=-3e-2, I=1)
ele_2=MagneticDipole("M2",x=0.,y=3e-2, I=-1)
ele_3=MagneticDipole("M2",x=0e-2,y=1e-2, I=-1)
ele_4=Source("S1",x=-5e-2,y=0.3e-2, an0=0, Dan=10)

luc.create([ele_1,ele_2,ele_3,ele_4])
# luc.show('scene')
# luc.show('field')
luc.run(N,Dt)
# luc.show('trajectory')
# luc.show('trajectory_2d')

# luc.show_array(["2D","scene","B_field","trajectory"])
luc.show_array(["2D","scene","B_field"])


"""
x,y,z,v_x,v_y,v_z=luc.YmirBody(10)
print(v_x,v_y,v_z)

+[P函数](,例子_磁场)

"""
## end
#1225, 625:
"""
+[P函数](,例子_点电场)

"""

N=1650
Dt=0.0001

luc=Lucifer()

ele_1 = PointField("P1",x=0.,y=-3e-2,Q=0.2)
ele_2 = PointField("P2",x=0.,y=0.,Q=-0.2)
ele_3 = PointField("P3",x=0.,y=3e-2,Q=0.2)
# ele_2 = MagneticDipole("M2",x=0.,y=3e-2, I=1)
# ele_3 = MagneticDipole("M2",x=0e-2,y=1e-2, I=-1)
ele_4 = Source("S1",x=-3e-2,y=0., an0=50, Dan=10)
ele_5 = Screen("D0",x=4.e-2,y=0.,H=50e-3, an0=0.)

luc.create([ele_1,ele_2,ele_3,ele_4,ele_5])
luc.run(N,Dt,100)
# luc.show_array(["2D","scene","E_field","trajectory"])
luc.show_detection()

"""
# luc.show('scene')
# luc.show('trajectory')
# luc.show('trajectory_2d')
+[P函数](,例子_点电场)

"""
## end
#1227, 722:
"""
+[P函数](,例子_电透镜)

"""

N=250
Dt=0.001

luc=Lucifer()


ele_1 = Lens("E1",x=0.,y=0.,r=1.e-2,D=2.e-2,U=-0.8e2)
ele_2 = Lens("E2",x=-5.e-2,y=0.,r=1.e-2,D=2.e-2)
ele_3 = Lens("E3",x=5.e-2,y=0.,r=1.e-2,D=2.e-2)

# ele_1 = PointField("P1",x=0.,y=-3e-2,Q=0.2)
# ele_2 = PointField("P2",x=0.,y=0.,Q=-0.2)
# ele_3 = PointField("P3",x=0.,y=3e-2,Q=0.2)

ele_4 = Source("S1",x=-14.e-2,y=0., an0=0, Dan=3.)

# luc.create([ele_1,ele_2,ele_3,ele_4])
luc.create([ele_1,ele_4])

# luc.show('scene')
# luc.show('E_field')
luc.run(N,Dt)
# # luc.show('trajectory')
# luc.show('trajectory_2d')

# luc.show('trajectory_2d')
luc.show_array(["2D","scene","E_field","trajectory"])
luc.show_array(["2D","trajectory"])



"""
+[P函数](,例子_电透镜)

"""
## end
#1229, 352:
运行指令"mkdir /home/xiantao/Documents/Projects/py-sem/doc/20230701"
+[上传pySEM]"更新了电透镜的近似电场"

收集数据:...
+[新建阅读窗口](,收集数据)

文本内容:...
+[新建阅读窗口](,文本内容)
文本结构::
+[删除结构](,文本结构)->+[召唤星辰]"文本结构化"(文本内容,文本结构)
的(文本结构,二级标题)->+[设置结构](,二级标题)

输出报告:...
+[删除结构](,输出报告)
'输出报告'的地址是"/home/xiantao/Documents/Projects/py-sem/doc/20230701/README.md"
+[召唤星辰]"结构文本转md"(文本结构,输出报告)




## end
#1231, 1256:
<!--
+[H函数](,文本内容)
-->

<h1>电透镜: 近似电场</h1>
<h2>近似电场表达式</h2>
近似电势: 
%[1].

近似电场: 
%[3].
%[4].

其中, \(a(r)\) 应该满足如下要求:<br>
- 如果透镜的孔径为\(R\), 那么应该有\(a(r>R)=\infty\)<br>
- 在中心处应该有, \(da/dr|_{r=0}=0\)<br>
<br>
这里我们建议一个函数形式,
%[5].

注意到, 以上为单片圆形电极的近似电势. 一个电透镜应该由三片等距的圆形电极构成

<h2>近似电场图像</h2>
一片电极的电势分布为,<br>
%fig.1a_*<br>
%fig.1b_*<br>

不同半径位置处, 电势沿电子运动方向的一维分布, <br>
%fig.1c_*<br>

电透镜的近似电场分布,<br>
%fig.1d_*<br>

<h2>电场中轨迹</h2>
电子在该近似电场中的运动轨迹: <br>
%fig.2a_*<br>
%fig.2b_*<br>

<h2>电场误差</h2>
因为这里的近似电势并非柏松方程的解, 所以当我们将电势代入柏松方程后, 运算的结果并不是零. 我们可以依据其(Q)来评判近似电势的质量,<br>
%[6].
因为有旋转对称性, 所以对\(\phi\)的积分为零. <br>

注意到, \(a(r)\) 是一个可以被任意定义的函数, 当我们将式(1)代入式(6)后, 就可以计算任意给定 \(a(r)\) 的Q,<br>
%[7].



<!--
[7].:
将"Q=a'(r)+r*(a''(r)-2*a'(r)^{2}/a(r)+a(r)^{3}/ln(2))"记作为式(7)

fig.1a_(图片)::/home/xiantao/Documents/Projects/py-sem/doc/20230701/res/fig_1.png
fig.1b_(图片)::/home/xiantao/Documents/Projects/py-sem/doc/20230701/res/fig_1b.png
fig.1c_(图片)::/home/xiantao/Documents/Projects/py-sem/doc/20230701/res/fig_1c.png
fig.1d_(图片)::/home/xiantao/Documents/Projects/py-sem/doc/20230701/res/fig_1d.png

fig.2a_(图片)::/home/xiantao/Documents/Projects/py-sem/doc/20230701/res/fig_2a.png
fig.2b_(图片)::/home/xiantao/Documents/Projects/py-sem/doc/20230701/res/fig_2b.png


+[H函数](,文本内容)
-->
## end
#1233, 574:

<h1>电透镜: 近似电场</h1>
<h2>近似电场表达式</h2>
近似电势: 
%[1].
近似电场: 
%[3].
%[4].
其中, \(a(r)\) 应该满足如下要求:
- 如果透镜的孔径为\(R\), 那么应该有\(a(r>R)=\infty\)
- 在中心处应该有, \(da/dr|_{r=0}=0\)
这里我们建议一个函数形式,
%[5].
注意到, 以上为单片圆形电极的近似电势. 一个电透镜应该由三片等距的圆形电极构成
<h2>近似电场图像</h2>
一片电极的电势分布为,
%fig.1a_*
%fig.1b_*
不同半径位置处, 电势沿电子运动方向的一维分布, 
%fig.1c_*
电透镜的近似电场分布,
%fig.1d_*
<h2>电场中轨迹</h2>
电子在该近似电场中的运动轨迹: 
%fig.2a_*
%fig.2b_*
<h2>电场误差</h2>
因为这里的近似电势并非柏松方程的解, 所以当我们将电势代入柏松方程后, 运算的结果并不是零. 我们可以依据其(Q)来评判近似电势的质量,
%[6].
因为有旋转对称性, 所以对\(\phi\)的积分为零. 
注意到, \(a(r)\) 是一个可以被任意定义的函数, 当我们将式(1)代入式(6)后, 就可以计算任意给定 \(a(r)\) 的Q,
%[7].

## end
#1235, 1430:
# 电透镜: 近似电场
## 近似电场表达式
近似电势: 

$$
u=-E_{0}/a \left( r \right) ln \left( cosh \left( z a \left( r \right) \right) \right)-E_{0} ln \left( 2 \right)/a \left( r \right)+u_{0}
\tag{1}
$$

近似电场: 

$$
E_{r}=\left(u-u_{0}+E_{z} z\right) r a \left( r \right)^{2}
\tag{3}
$$


$$
E_{z}=E_{0} tanh \left( z a \left( r \right) \right)
\tag{4}
$$

其中, \(a(r)\) 应该满足如下要求:
- 如果透镜的孔径为\(R\), 那么应该有\(a(r>R)=\infty\)
- 在中心处应该有, \(da/dr|_{r=0}=0\)
这里我们建议一个函数形式,

$$
a \left( r \right)=\begin{cases}
1/\sqrt{R^{2}-r^{2}}, & r< R\\ \infty, & r\ge R
\end{cases}
\tag{5}
$$

注意到, 以上为单片圆形电极的近似电势. 一个电透镜应该由三片等距的圆形电极构成

## 近似电场图像
一片电极的电势分布为,
<img src="./res/fig.1a_.png" width="95%"/>
<img src="./res/fig.1b_.png" width="95%"/>
不同半径位置处, 电势沿电子运动方向的一维分布, 
<img src="./res/fig.1c_.png" width="95%"/>
电透镜的近似电场分布,
<img src="./res/fig.1d_.png" width="95%"/>

## 电场中轨迹
电子在该近似电场中的运动轨迹: 
<img src="./res/fig.2a_.png" width="95%"/>
<img src="./res/fig.2b_.png" width="95%"/>

## 电场误差
因为这里的近似电势并非柏松方程的解, 所以当我们将电势代入柏松方程后, 运算的结果并不是零. 我们可以依据其(Q)来评判近似电势的质量,

$$
Q=\nabla^{2} u=\frac{1}{r} \frac{\partial}{\partial r}\left(r \frac{\partial u}{\partial r}\right)+\frac{\partial^{2}u}{\partial z^{2}}
\tag{6}
$$

因为有旋转对称性, 所以对\(\phi\)的积分为零. 
注意到, \(a(r)\) 是一个可以被任意定义的函数, 当我们将式(1)代入式(6)后, 就可以计算任意给定 \(a(r)\) 的Q,

$$
Q=a' \left( r \right)+r \left(a'' \left( r \right)-2 a' \left( r \right)^{2}/a \left( r \right)+a \left( r \right)^{3}/ln \left( 2 \right)\right)
\tag{7}
$$



## end
#1237, 137:
u=-E_{0}/a \left( r \right) ln \left( cosh \left( z a \left( r \right) \right) \right)-E_{0} ln \left( 2 \right)/a \left( r \right)+u_{0}
## end
#1239, 52:
E_{z}=E_{0} tanh \left( z a \left( r \right) \right)
## end
#1241, 59:
E_{r}=\left(u-u_{0}+E_{z} z\right) r a \left( r \right)^{2}
## end
#1243, 52:
E_{z}=E_{0} tanh \left( z a \left( r \right) \right)
## end
#1244, 47:
u=-E_0/a(r)*ln(cosh(z*a(r)))-E_0*ln(2)/a(r)+u_0
## end
#1247, 20:
E_z=E_0*tanh(z*a(r))
## end
#1250, 28:
E_r=(u-u_0+E_z*z)*r*a(r)^{2}
## end
#1253, 20:
E_z=E_0*tanh(z*a(r))
## end
#1257, 94:
a \left( r \right)=\begin{cases}
1/\sqrt{R^{2}-r^{2}}, & r< R\\ \infty, & r\ge R
\end{cases}


## end
#1258, 56:
a(r)=\eqs{1/\sqrt{R^{2}-r^{2}},   r<R;
\infty,   r\ge R}
## end
#1262, 177:
运行指令"mkdir /home/xiantao/Documents/Projects/py-sem/doc/20230701/res"
在"/home/xiantao/Documents/Projects/py-sem/doc/20230701/res/fig_1c.png"处, 保存当前图像


等效电场:...
+[新建阅读窗口](,等效电场)

## end
#1264, 419:
%{
+[M函数](,等效电场)


%}


u_0=0;
E_0=1;
R=1e-3;
D=10e-3
z=linspace(-D/3,D/3,400);
r=linspace(-D/3,D/3,50);

dR=0.1*R;

a=@(r)1./sqrt(R.^(2)-r.^(2)).*double(R-dR>abs(r))+1/dR.*double(R-dR<=abs(r));
u=@(z,r)-E_0./a(r).*log(cosh(z.*a(r)))-E_0.*log(2)./a(r)+u_0;

[Z,R]=meshgrid(z,r);
U=u(Z,R);
A=a(R);

% surf(Z/1e-3,R/1e-3,real(U))
% contourf(R'/1e-3,Z'/1e-3,real(U'),30)
% axis equal

plot(Z',u(Z,R)')

%{
+[M函数](,等效电场)
%}
## end
#1266, 66:
/home/xiantao/Documents/Projects/py-sem/doc/20230701/res/fig_1.png
## end
#1269, 67:
/home/xiantao/Documents/Projects/py-sem/doc/20230701/res/fig_1b.png
## end
#1272, 67:
/home/xiantao/Documents/Projects/py-sem/doc/20230701/res/fig_1c.png
## end
#1275, 67:
/home/xiantao/Documents/Projects/py-sem/doc/20230701/res/fig_1d.png
## end
#1278, 67:
/home/xiantao/Documents/Projects/py-sem/doc/20230701/res/fig_2a.png
## end
#1281, 67:
/home/xiantao/Documents/Projects/py-sem/doc/20230701/res/fig_2b.png
## end
#1284, 135:
Q=\nabla^{2} u=\frac{1}{r} \frac{\partial}{\partial r}\left(r \frac{\partial u}{\partial r}\right)+\frac{\partial^{2}u}{\partial z^{2}}
## end
#1286, 145:
Q=a' \left( r \right)+r \left(a'' \left( r \right)-2 a' \left( r \right)^{2}/a \left( r \right)+a \left( r \right)^{3}/ln \left( 2 \right)\right)
## end
#1287, 53:
Q=\nabla^2*u=\frac{1}{r}*\p{r}{r*\p{r}{u}}+\p{z,z}{u}
## end
#1290, 50:
Q=a'(r)+r*(a''(r)-2*a'(r)^{2}/a(r)+a(r)^{3}/ln(2))
## end
#1293, 9:
电透镜: 近似电场
## end
#1295, 193:
近似电场表达式
近似电势: 
%[1].
近似电场: 
%[3].
%[4].
其中, \(a(r)\) 应该满足如下要求:
- 如果透镜的孔径为\(R\), 那么应该有\(a(r>R)=\infty\)
- 在中心处应该有, \(da/dr|_{r=0}=0\)
这里我们建议一个函数形式,
%[5].
注意到, 以上为单片圆形电极的近似电势. 一个电透镜应该由三片等距的圆形电极构成
## end
#1297, 96:
近似电场图像
一片电极的电势分布为,
%fig.1a_*
%fig.1b_*
不同半径位置处, 电势沿电子运动方向的一维分布, 
%fig.1c_*
电透镜的近似电场分布,
%fig.1d_*
## end
#1299, 42:
电场中轨迹
电子在该近似电场中的运动轨迹: 
%fig.2a_*
%fig.2b_*
## end
#1301, 184:
电场误差
因为这里的近似电势并非柏松方程的解, 所以当我们将电势代入柏松方程后, 运算的结果并不是零. 我们可以依据其(Q)来评判近似电势的质量,
%[6].
因为有旋转对称性, 所以对\(\phi\)的积分为零. 
注意到, \(a(r)\) 是一个可以被任意定义的函数, 当我们将式(1)代入式(6)后, 就可以计算任意给定 \(a(r)\) 的Q,
%[7].

## end
#1303, 4:
电场误差
## end
#1307, 68:
因为这里的近似电势并非柏松方程的解, 所以当我们将电势代入柏松方程后, 运算的结果并不是零. 我们可以依据其(Q)来评判近似电势的质量,
## end
#1311, 5:
%[6].
## end
#1315, 28:
因为有旋转对称性, 所以对\(\phi\)的积分为零. 
## end
#1319, 68:
注意到, \(a(r)\) 是一个可以被任意定义的函数, 当我们将式(1)代入式(6)后, 就可以计算任意给定 \(a(r)\) 的Q,
## end
#1323, 5:
%[7].
## end
#1325, 145:
Q=a' \left( r \right)+r \left(a'' \left( r \right)-2 a' \left( r \right)^{2}/a \left( r \right)+a \left( r \right)^{3}/ln \left( 2 \right)\right)
## end
#1327, 4:
[7].
## end
#1329, 135:
Q=\nabla^{2} u=\frac{1}{r} \frac{\partial}{\partial r}\left(r \frac{\partial u}{\partial r}\right)+\frac{\partial^{2}u}{\partial z^{2}}
## end
#1331, 4:
[6].
## end
#1333, 5:
电场中轨迹
## end
#1337, 16:
电子在该近似电场中的运动轨迹: 
## end
#1341, 9:
%fig.2a_*
## end
#1345, 9:
%fig.2b_*
## end
#1347, 17:
./res/fig.2b_.png
## end
#1349, 67:
/home/xiantao/Documents/Projects/py-sem/doc/20230701/res/fig_2b.png
## end
#1351, 1:
b
## end
#1353, 4:
wide
## end
#1357, 7:
fig.2b_
## end
#1359, 17:
./res/fig.2a_.png
## end
#1361, 67:
/home/xiantao/Documents/Projects/py-sem/doc/20230701/res/fig_2a.png
## end
#1363, 1:
b
## end
#1365, 4:
wide
## end
#1369, 7:
fig.2a_
## end
#1371, 6:
近似电场图像
## end
#1375, 11:
一片电极的电势分布为,
## end
#1379, 9:
%fig.1a_*
## end
#1383, 9:
%fig.1b_*
## end
#1387, 25:
不同半径位置处, 电势沿电子运动方向的一维分布, 
## end
#1391, 9:
%fig.1c_*
## end
#1395, 11:
电透镜的近似电场分布,
## end
#1399, 9:
%fig.1d_*
## end
#1401, 17:
./res/fig.1d_.png
## end
#1403, 67:
/home/xiantao/Documents/Projects/py-sem/doc/20230701/res/fig_1d.png
## end
#1405, 1:
b
## end
#1407, 4:
wide
## end
#1411, 7:
fig.1d_
## end
#1413, 17:
./res/fig.1c_.png
## end
#1415, 67:
/home/xiantao/Documents/Projects/py-sem/doc/20230701/res/fig_1c.png
## end
#1417, 1:
b
## end
#1419, 4:
wide
## end
#1423, 7:
fig.1c_
## end
#1425, 17:
./res/fig.1b_.png
## end
#1427, 67:
/home/xiantao/Documents/Projects/py-sem/doc/20230701/res/fig_1b.png
## end
#1429, 1:
b
## end
#1431, 4:
wide
## end
#1435, 7:
fig.1b_
## end
#1437, 17:
./res/fig.1a_.png
## end
#1439, 66:
/home/xiantao/Documents/Projects/py-sem/doc/20230701/res/fig_1.png
## end
#1441, 1:
b
## end
#1443, 4:
wide
## end
#1447, 7:
fig.1a_
## end
#1449, 7:
近似电场表达式
## end
#1453, 6:
近似电势: 
## end
#1457, 5:
%[1].
## end
#1461, 6:
近似电场: 
## end
#1465, 5:
%[3].
## end
#1469, 5:
%[4].
## end
#1473, 22:
其中, \(a(r)\) 应该满足如下要求:
## end
#1477, 39:
- 如果透镜的孔径为\(R\), 那么应该有\(a(r>R)=\infty\)
## end
#1481, 29:
- 在中心处应该有, \(da/dr|_{r=0}=0\)
## end
#1485, 13:
这里我们建议一个函数形式,
## end
#1489, 5:
%[5].
## end
#1493, 40:
注意到, 以上为单片圆形电极的近似电势. 一个电透镜应该由三片等距的圆形电极构成
## end
#1495, 94:
a \left( r \right)=\begin{cases}
1/\sqrt{R^{2}-r^{2}}, & r< R\\ \infty, & r\ge R
\end{cases}


## end
#1497, 4:
[5].
## end
#1499, 52:
E_{z}=E_{0} tanh \left( z a \left( r \right) \right)
## end
#1501, 4:
[4].
## end
#1503, 59:
E_{r}=\left(u-u_{0}+E_{z} z\right) r a \left( r \right)^{2}
## end
#1505, 4:
[3].
## end
#1507, 137:
u=-E_{0}/a \left( r \right) ln \left( cosh \left( z a \left( r \right) \right) \right)-E_{0} ln \left( 2 \right)/a \left( r \right)+u_{0}
## end
#1509, 4:
[1].
## end
#1511, 9:
电透镜: 近似电场
## end
#1519, 52:
/home/xiantao/Documents/Projects/py-sem/doc/20230701
## end
#1521, 5:
PySEM
## end
#1523, 82:
Gallery
%fig_traj*
%fig_traj_dflt*
%fig_space*
%fig_spots*
%fig_aberration*
%测试表格

## end
#1525, 7:
Gallery
## end
#1529, 10:
%fig_traj*
## end
#1533, 15:
%fig_traj_dflt*
## end
#1537, 11:
%fig_space*
## end
#1541, 11:
%fig_spots*
## end
#1545, 16:
%fig_aberration*
## end
#1549, 5:
%测试表格
## end
#1551, 59:
t1, t2, t3, t4
a, b, c, d
a, b, c, d
a, b, a_1 , $$a_1=2$$

## end
#1553, 1:
b
## end
#1555, 6:
normal
## end
#1559, 4:
测试表格
## end
#1561, 24:
./res/fig_aberration.png
## end
#1563, 62:
/home/xiantao/Documents/Projects/py-sem/res/fig_aberration.png
## end
#1565, 1:
b
## end
#1567, 4:
wide
## end
#1571, 14:
fig_aberration
## end
#1573, 19:
./res/fig_spots.png
## end
#1575, 57:
/home/xiantao/Documents/Projects/py-sem/res/fig_spots.png
## end
#1577, 1:
b
## end
#1579, 4:
wide
## end
#1583, 9:
fig_spots
## end
#1585, 19:
./res/fig_space.png
## end
#1587, 57:
/home/xiantao/Documents/Projects/py-sem/res/fig_space.png
## end
#1589, 1:
b
## end
#1591, 4:
wide
## end
#1595, 9:
fig_space
## end
#1597, 23:
./res/fig_traj_dflt.png
## end
#1599, 61:
/home/xiantao/Documents/Projects/py-sem/res/fig_traj_dflt.png
## end
#1601, 1:
b
## end
#1603, 4:
wide
## end
#1607, 13:
fig_traj_dflt
## end
#1609, 18:
./res/fig_traj.png
## end
#1611, 56:
/home/xiantao/Documents/Projects/py-sem/res/fig_traj.png
## end
#1613, 1:
b
## end
#1615, 4:
wide
## end
#1619, 8:
fig_traj
## end
#1621, 5:
PySEM
## end
#1623, 44:
/home/xiantao/Documents/Projects/py-sem/test
## end
#1626, 331:
运行指令"mkdir /home/xiantao/Documents/Projects/py-sem/doc"
+[上传pySEM]"更新log"

收集数据:...
+[新建阅读窗口](,收集数据)

文本内容:...
+[新建阅读窗口](,文本内容)
文本结构::
+[删除结构](,文本结构)->+[召唤星辰]"文本结构化"(文本内容,文本结构)
的(文本结构,二级标题)->+[设置结构](,二级标题)
+[sh]

输出报告:...
+[删除结构](,输出报告)
'输出报告'的地址是"/home/xiantao/Documents/Projects/py-sem/doc/log.md"
+[召唤星辰]"结构文本转md"(文本结构,输出报告)




## end
#1628, 91:
.<!--
+[H函数](,文本内容)
-->

<h1>日志</h1>
<h2>整体架构</h2>
%架构


<!--
架构(程序):...

+[H函数](,文本内容)
-->
## end
#1630, 1395:
(tools)
(code)

Preprocess{
    elements{
        builtin (elements, lens, deflector,...) -> tasks{
            field expression (variable: I, U, r, d) {
                ** ways to express{
                    interp(spline,...),
                    fitting (Hermite, spline, polymial),
                    expansion(? Fourier),
                    经验函数( f(x,y,z)= log (1+cos(x^2)*exp()) )
                } -> research (error, speed) {
                    CAD(self-toolbox),
                    FEM(self-toolbox),
                    BEM(self-toolbox)
                }
            }
        },
        input {
            volume{
                files{obj, ...},
                demonsion { 2D, 3D }
            },
            field{
                file{LaTeX, python func, ..., vtk, gmesh}
            }
        }
}
->Solve{
     elements->space{
        field,
        * volume,
        (sub-space/children)
    } -> stepper{
        -> track (q, m),
        -> responce function(RF, shell first, after auto-focus) { (x,y,z)=f(V,I) },

        solver{
            * collision {kill, scatter(class)},
            * Coulomb,
            different types
        }
    }
}
-> * Postprocess{ 
    track -> output{
        spot,
        aberr
    },
    RF -> af(stepper)
}


others{
    file organization{
        pre-README.md: figs
        log.md: meeting, updates
        0.2 version
    }
}

## end
#1633, 32:
.
<h1>日志</h1>
<h2>整体架构</h2>
%架构

## end
#1635, 1421:
# 日志
## 整体架构

```py
(tools)
(code)

Preprocess{
    elements{
        builtin (elements, lens, deflector,...) -> tasks{
            field expression (variable: I, U, r, d) {
                ** ways to express{
                    interp(spline,...),
                    fitting (Hermite, spline, polymial),
                    expansion(? Fourier),
                    经验函数( f(x,y,z)= log (1+cos(x^2)*exp()) )
                } -> research (error, speed) {
                    CAD(self-toolbox),
                    FEM(self-toolbox),
                    BEM(self-toolbox)
                }
            }
        },
        input {
            volume{
                files{obj, ...},
                demonsion { 2D, 3D }
            },
            field{
                file{LaTeX, python func, ..., vtk, gmesh}
            }
        }
}
->Solve{
     elements->space{
        field,
        * volume,
        (sub-space/children)
    } -> stepper{
        -> track (q, m),
        -> responce function(RF, shell first, after auto-focus) { (x,y,z)=f(V,I) },

        solver{
            * collision {kill, scatter(class)},
            * Coulomb,
            different types
        }
    }
}
-> * Postprocess{ 
    track -> output{
        spot,
        aberr
    },
    RF -> af(stepper)
}


others{
    file organization{
        pre-README.md: figs
        log.md: meeting, updates
        0.2 version
    }
}

```


## end
#1636, 1:
.
## end
#1638, 2:
日志
## end
#1640, 9:
整体架构
%架构

## end
#1642, 4:
整体架构
## end
#1646, 3:
%架构
## end
#1648, 1395:
(tools)
(code)

Preprocess{
    elements{
        builtin (elements, lens, deflector,...) -> tasks{
            field expression (variable: I, U, r, d) {
                ** ways to express{
                    interp(spline,...),
                    fitting (Hermite, spline, polymial),
                    expansion(? Fourier),
                    经验函数( f(x,y,z)= log (1+cos(x^2)*exp()) )
                } -> research (error, speed) {
                    CAD(self-toolbox),
                    FEM(self-toolbox),
                    BEM(self-toolbox)
                }
            }
        },
        input {
            volume{
                files{obj, ...},
                demonsion { 2D, 3D }
            },
            field{
                file{LaTeX, python func, ..., vtk, gmesh}
            }
        }
}
->Solve{
     elements->space{
        field,
        * volume,
        (sub-space/children)
    } -> stepper{
        -> track (q, m),
        -> responce function(RF, shell first, after auto-focus) { (x,y,z)=f(V,I) },

        solver{
            * collision {kill, scatter(class)},
            * Coulomb,
            different types
        }
    }
}
-> * Postprocess{ 
    track -> output{
        spot,
        aberr
    },
    RF -> af(stepper)
}


others{
    file organization{
        pre-README.md: figs
        log.md: meeting, updates
        0.2 version
    }
}

## end
#1650, 1:
b
## end
#1652, 6:
normal
## end
#1656, 2:
架构
## end
#1658, 2:
日志
## end
#1660, 43:
/home/xiantao/Documents/Projects/py-sem/doc
## end
#1663, 65:
+[粘贴](,tools)

matlab_style_draw(P函数):...
basic_tools(P函数):...



## end
#1664, 273:
"""
+[P函数](,patch测试)

"""

import matplotlib.path as mpath
import matplotlib.patches as mpatches
import matplotlib.pyplot as plt

x=[-1,1,1,-3]
y=[0,0,1,2]

fig, ax = plt.subplots()
patch = patch_from_xy(x,y,'b')
ax.add_patch(patch)

ax.grid()
ax.axis('equal')
plt.show()


## end
#1665, 13:
Xiantao Cheng
## end
#1666, 23:
2023-06-13 Tue 00:37:03
## end
#1667, 64:
/home/xiantao/Documents/Projects/py-sem/src/matlab_style_draw.py
## end
#1672, 1278:
"""
地址::/home/xiantao/Documents/Projects/py-sem/src/matlab_style_draw.py
+[保存P函数]"Xiantao Cheng"(,matlab_style_draw)
+[P函数](,matlab_style_draw)
patch测试:...
3d_patch测试:...
+[新建阅读窗口](,3d_patch测试)

"""
import matplotlib.path as mpath
import matplotlib.patches as mpatches
from mpl_toolkits.mplot3d import art3d
import numpy as np

def patch_from_xy(x,y,color_str='w'):
    Path=mpath.Path
    path_data=[]
    for i in range(len(x)):
        if i==0:
            path_data.append((Path.MOVETO, (x[i], y[i])))
        else:
            path_data.append((Path.LINETO, (x[i], y[i])))
        if i==len(x)-1:
            path_data.append((Path.CLOSEPOLY, (x[i], y[i])))
    
    codes, verts = zip(*path_data)
    path = mpath.Path(verts, codes)
    shape = mpatches.PathPatch(path, facecolor=color_str, alpha=0.5)
    return shape

def patch_from_xyz(x,y,z,fc='w',ec='k'):
    shape = art3d.Poly3DCollection([list(zip(x,y,z))])
    shape.set_facecolor(fc)
    shape.set_edgecolor(ec) 
    return shape

def patch_from_vf(v,f,fc='w',ec='k'):
    shape = art3d.Poly3DCollection(v[f])
    shape.set_facecolor(fc)
    shape.set_edgecolor(ec) 
    return shape

def circle_from_pt_r(x,y,r,color_str):
    return mpatches.Circle((x,y),r,ec=color_str)




"""
+[P函数](,matlab_style_draw)

"""
## end
#1675, 811:
"""
+[P函数](,3d_patch测试)
Nini, 打开三维场景(文件)
参考1::https://www.tutorialspoint.com/how-to-plot-a-3d-patch-collection-in-matplotlib
参考2::https://stackoverflow.com/questions/51164291/matplotlib-patch-like-function-for-3d-triangular-meshes

2转3:...
例子2:...
例子3_fv:...
+[新建阅读窗口](,例子2)

测试_xyz:...
测试_vf:...

"""


import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D, art3d

v = np.array([[0,0,0], [1,0,0], [1,1,0], [0,1,0], 
              [0,0,1], [1,0,1], [1,1,1], [0,1,1]])

f = np.array([[0,2,1], [0,3,2], [1,2,6], [1,6,5],
              [0,5,4], [0,1,5], [4,5,6], [6,7,4],
              [3,7,6], [6,2,3], [0,4,7], [7,3,0]])


fig = plt.figure()
ax = fig.add_subplot(projection="3d")

shape = patch_from_vf(v,f)
ax.add_collection(shape)

plt.show()


"""
+[P函数](,3d_patch测试)

"""
## end
#1677, 78:
https://www.tutorialspoint.com/how-to-plot-a-3d-patch-collection-in-matplotlib
## end
#1679, 100:
https://stackoverflow.com/questions/51164291/matplotlib-patch-like-function-for-3d-triangular-meshes
## end
#1681, 633:
"""
+[P函数](,3d_patch测试)
参考1::https://www.tutorialspoint.com/how-to-plot-a-3d-patch-collection-in-matplotlib
参考2::https://stackoverflow.com/questions/51164291/matplotlib-patch-like-function-for-3d-triangular-meshes

2转3:...

"""

import matplotlib.pyplot as plt
from matplotlib.patches import Circle
import mpl_toolkits.mplot3d.art3d as art3d

plt.rcParams["figure.figsize"] = [7.50, 3.50]
plt.rcParams["figure.autolayout"] = True

fig = plt.figure()
ax = fig.gca(projection='3d')

for i in ["x", "y", "z"]:
   cir = Circle((0.5, 0.5), 0.2, color='red')
   ax.add_patch(cir)
   art3d.pathpatch_2d_to_3d(cir, z=0, zdir=i)

plt.show()


## end
#1683, 1283:
"""
+[P函数](,例子2)

"""
import matplotlib as mpl
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d.art3d import Poly3DCollection


def patch(ax, x, y, z, v, vmin=0, vmax=100, cmap_name='viridis'):
    cmap = mpl.cm.get_cmap(cmap_name)               # Get colormap by name
    c = cmap(mpl.colors.Normalize(vmin, vmax)(v))   # Normalize value and get color
    pc = Poly3DCollection([list(zip(x,y,z))])       # Create PolyCollection from coords
    pc.set_facecolor(c)                             # Set facecolor to mapped value
    pc.set_edgecolor('k')                           # Set edgecolor to black
    ax.add_collection3d(pc)                         # Add PolyCollection to axes
    return pc

def view(ax, code):
    if code == 2: #view(2) sets the default two-dimensional view, az = 0, el = 90.
        ax.view_init(90, 0)     # (args are reversed from MATLAB)

    if code == 3: #view(3) sets the default three-dimensional view, az = –37.5, el = 30.
        ax.view_init(30, -37.5)


fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

x = [0.0, 1.0, 0.0];
y = [0.0, 0.0, 1.0];
z = [0.0, 1.0, 1.0];
v = 100.0;

patch(ax, x, y, z, v)

x = [1.0, 1.0, 0.0];
y = [0.0, 1.0, 1.0];
z = [1.0, 0.0, 1.0];
v = 50.0;
patch(ax, x, y, z, v)

view(ax, 3)
plt.show()




## end
#1685, 793:
"""
+[P函数](,例子3_fv)
参考::https://stackoverflow.com/questions/56559379/plot-mesh-stored-as-vertices-and-faces
Nini, 打开三维模型(文件)

"""


import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D, art3d

v = np.array([[0,0,0], [1,0,0], [1,1,0], [0,1,0], 
              [0,0,1], [1,0,1], [1,1,1], [0,1,1]])

f = np.array([[0,2,1], [0,3,2], [1,2,6], [1,6,5],
              [0,5,4], [0,1,5], [4,5,6], [6,7,4],
              [3,7,6], [6,2,3], [0,4,7], [7,3,0]])

C = np.array([1,2,3,4,5,6,7,8,2,3,4,5])


fig = plt.figure()
ax = fig.add_subplot(projection="3d")

norm = plt.Normalize(C.min(), C.max())
colors = plt.cm.viridis(norm(C))

pc = art3d.Poly3DCollection(v[f], facecolors=colors, edgecolor="black")
ax.add_collection(pc)

plt.show()




"""
+[P函数](,例子3_fv)

"""
## end
#1687, 771:
"""
+[P函数](,3d_patch测试)
参考1::https://www.tutorialspoint.com/how-to-plot-a-3d-patch-collection-in-matplotlib
参考2::https://stackoverflow.com/questions/51164291/matplotlib-patch-like-function-for-3d-triangular-meshes

2转3:...
例子2:...
例子3_fv:...
+[新建阅读窗口](,例子2)

测试_xyz:...


"""

import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d.art3d import Poly3DCollection


fig = plt.figure()
# ax = fig.add_subplot(111, projection='3d')
ax = fig.add_subplot(projection='3d')

x = [0.0, 1.0, 0.0,2.0];
y = [0.0, 0.0, 1.0,-2.0];
z = [0.0, 1.0, 1.0,2.0];
shape1=patch_from_xyz(x, y, z)

x = [1.0, 1.0, 0.0];
y = [0.0, 1.0, 1.0];
z = [1.0, 0.0, 1.0];
shape2=patch_from_xyz(x, y, z)

ax.add_collection3d(shape1)
ax.add_collection3d(shape2)
plt.show()



"""
+[P函数](,3d_patch测试)

"""
## end
#1689, 811:
"""
+[P函数](,3d_patch测试)
Nini, 打开三维场景(文件)
参考1::https://www.tutorialspoint.com/how-to-plot-a-3d-patch-collection-in-matplotlib
参考2::https://stackoverflow.com/questions/51164291/matplotlib-patch-like-function-for-3d-triangular-meshes

2转3:...
例子2:...
例子3_fv:...
+[新建阅读窗口](,例子2)

测试_xyz:...
测试_vf:...

"""


import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D, art3d

v = np.array([[0,0,0], [1,0,0], [1,1,0], [0,1,0], 
              [0,0,1], [1,0,1], [1,1,1], [0,1,1]])

f = np.array([[0,2,1], [0,3,2], [1,2,6], [1,6,5],
              [0,5,4], [0,1,5], [4,5,6], [6,7,4],
              [3,7,6], [6,2,3], [0,4,7], [7,3,0]])


fig = plt.figure()
ax = fig.add_subplot(projection="3d")

shape = patch_from_vf(v,f)
ax.add_collection(shape)

plt.show()


"""
+[P函数](,3d_patch测试)

"""
## end
#1691, 691:
"""
地址::/home/xiantao/Documents/Projects/py-sem/examples/unit_testing/stepper_test_RK4.py
+[保存P函数]"Xiantao Cheng"(,匀强磁场轨迹)
+[P函数](,匀强磁场轨迹)

"""

import numpy as np
import matplotlib.pyplot as plt

B_x = lambda x,y,z: x*0
B_y = lambda x,y,z: x*0
B_z = lambda x,y,z: x*0+1

E_x = lambda x,y,z: x*0
E_y = lambda x,y,z: x*0
E_z = lambda x,y,z: x*0+0.1

N=10
t=0
x=np.linspace(0,0,N)
y=np.linspace(0,0,N)
z=np.linspace(0,0,N)
v_x=np.linspace(1,2,N)
v_y=np.linspace(0,0,N)
v_z=np.linspace(0,0,N)

stepper=EM_stepper(x,y,z,v_x,v_y,v_z)
stepper.setBField(B_x,B_y,B_z)
stepper.setEField(E_x,E_y,E_z)
X,Y,Z=stepper.stepOn(1000,0.1)

test_e=Tracks(X,Y,Z)
test_e.view()


"""
print(X)
+[P函数](,测试运行)

"""
## end
#1693, 1285:
"""
+[P函数](,测试运行)

匀强磁场轨迹:...
交点测试1:...

"""

import numpy as np
import matplotlib.pyplot as plt

B_x = lambda x,y,z: x*0
B_y = lambda x,y,z: x*0
B_z = lambda x,y,z: x*0+1

E_x = lambda x,y,z: x*0
E_y = lambda x,y,z: x*0
E_z = lambda x,y,z: x*0+0.1

N=10
t=0
x=np.linspace(0,0,N)
y=np.linspace(0,0,N)
z=np.linspace(0,0,N)
v_x=np.linspace(1,2,N)
v_y=np.linspace(0,0,N)
v_z=np.linspace(0,0,N)

stepper=EM_stepper(x,y,z,v_x,v_y,v_z)
stepper.setBField(B_x,B_y,B_z)
stepper.setEField(E_x,E_y,E_z)
X,Y,Z=stepper.stepOn(1000,0.1)

v_f=np.array([1.,0.,0.])
v_f=v_f/np.linalg.norm(v_f)
r_0=np.array([0.,0.,0.])

f_x=v_f[0]
f_y=v_f[1]
f_z=v_f[2]
x_0=r_0[0]
y_0=r_0[1]
z_0=r_0[2]

x_A=X[0:-1,:]
y_A=Y[0:-1,:]
z_A=Z[0:-1,:]

x_B=X[1:,:]
y_B=Y[1:,:]
z_B=Z[1:,:]

t=(f_x*(x_0-x_A)+f_y*(y_0-y_A)+f_z*(z_0-z_A))/(f_x*(x_B-x_A)+f_y*(y_B-y_A)+f_z*(z_B-z_A))
i0=np.logical_and(t>0,t<1)

xs=x_A[i0]+t[i0]*(x_B[i0]-x_A[i0])
ys=y_A[i0]+t[i0]*(y_B[i0]-y_A[i0])
zs=z_A[i0]+t[i0]*(z_B[i0]-z_A[i0])

fig = plt.figure()
ax = fig.add_subplot(projection='3d')

ax.scatter(xs, ys, zs, marker='o')


test_e=Tracks(X,Y,Z)
test_e.view()

"""
print(X[1,:])
print(np.logical_and(t>0,t<1))
print(len(x_A[t<1]))
print(len(x_A[t<1 and t>0]))
t0=np.logical_and(t>0,t<1)
print(len(x_A[t0]))
print(x_A[t0])

+[P函数](,测试运行)

"""
## end
#1695, 859:
"""
地址::/home/xiantao/Documents/Projects/py-sem/examples/test_screen.py
+[保存P函数]"Xiantao Cheng"(,例子_屏幕)
+[P函数](,例子_屏幕)

"""
import sys
if __name__=='__main__':
    sys.path.append(sys.path[0]+'/..')
from src.hevean import Lucifer
from src.elements import *


N=650
Dt=0.00015

luc=Lucifer()


"""
+[P函数](,测试流程)

"""
ele_1 = Lens("E1",x=0.,y=0.,r=1.e-2,D=10.e-3,R=30e-3)
ele_2 = Screen("D0",x=10.e-2,y=0.,H=50e-3, an0=0.)

ele_4 = Source("S1",x=-5.e-2,y=0., an0=0, Dan=0.1)

luc.create([ele_1,ele_2,ele_4])

# luc.show('scene')
# luc.show('E_field')
luc.run(N,Dt,1000)
# luc.show('trajectory')
# luc.show('trajectory_2d')
# luc.show_array(["2D","scene","E_field","trajectory"])
luc.show_detection()



"""
luc.show('trajectory_2d')
luc.show('scene')
luc.show_array(["2D","scene","E_field"])
fx,fy=luc.show_detection()
print(fx,fy)
记住"Python"
+[P函数](,测试流程)

"""
## end
#1697, 474:
%{
+[M函数](,测试电子源)
Nini, 打开像素矩阵(文件)

求和公式(html):...
太阳花分布(html):...
'太阳花分布'的式(4)转换为"Python"
+[H函数](,太阳花分布)

二次分布:...
均匀分布:...
图像分布:...
%}

physics_constant;


file_name="input/austin.png";
data=imread(file_name);

R_matrix=data(:,:,1);
area0=reshape(double(R_matrix<200),1,numel(R_matrix));

N=50000;

x=1199*rand(1,N);
y=1199*rand(1,N);

i=int64(x);
j=int64(y);
x=x(area0(j+1200*i+1)==1);
y=y(area0(j+1200*i+1)==1);

plot(x,y,'.')
axis equal


%{
length(x)
+[M函数](,测试电子源)
%}
## end
#1699, 241:
<!--
+[H函数](,求和公式)
-->

通项:
%[1].
总点数: 
%[2].
%[3].
%[4].
%[5].
解法:
%[6].
%[7].
%[8].
(N>=3)


<!--
[8].:
将"a[n]=3+n"记作为式(1)
将"n^2+7*n+6-2*N=0"记作为式(6)
将"n=\frac{-7+\sqrt{25+8*N}}{2}"记作为式(8)
将式(2)记作为式(3)
将式(1)代入到式(3)

更新式(3)
+[H函数](,求和公式)
-->
## end
#1702, 9:
a_{n}=3+n
## end
#1704, 23:
N=\sum_{i=0}^{n}{a_{n}}
## end
#1706, 21:
N=\sum_{i=0}^{n}{3+n}
## end
#1708, 49:
N=3 \left(n+1\right)+\frac{n \left(n+1\right)}{2}
## end
#1710, 8:
a[n]=3+n
## end
#1715, 23:
N=\sum_{0}^{n}{i}{a[n]}
## end
#1718, 22:
N=\sum_{0}^{n}{i}{3+n}
## end
#1721, 3:
3+n
## end
#1723, 4:
a[n]
## end
#1725, 27:
N=3*(n+1)+\frac{n*(n+1)}{2}
## end
#1729, 45:
N=\frac{\left(n+6\right) \left(n+1\right)}{2}
## end
#1731, 17:
n^{2}+7 n+6-2 N=0
## end
#1732, 23:
N=\frac{(n+6)*(n+1)}{2}
## end
#1736, 45:
n=\frac{-7+\sqrt{49-4 \left(6-2 N\right)}}{2}
## end
#1737, 15:
n^2+7*n+6-2*N=0
## end
#1740, 34:
n=\frac{-7+\sqrt{49-4*(6-2*N)}}{2}
## end
#1744, 28:
n=\frac{-7+\sqrt{25+8 N}}{2}
## end
#1745, 28:
n=\frac{-7+\sqrt{25+8*N}}{2}
## end
#1749, 90:
https://stackoverflow.com/questions/28567166/uniformly-distribute-x-points-inside-a-circle
## end
#1751, 356:
<!--
+[H函数](,太阳花分布)
参考::https://stackoverflow.com/questions/28567166/uniformly-distribute-x-points-inside-a-circle
-->

%[1].
%[2].
%[3].
%[4].
%[5].
%[6].
%[7].



<!--
[7].:
将"b=\alpha*\sqrt{N}"记作为式(1)
将"\phi=(\sqrt{5}+1)/2"记作为式(2)
将"r(k)=\eqs{1,k>n-b;
\sqrt{\frac{k-1/2}{n-(b+1)/2}},otherwise}"记作为式(3)
将"\theta=2*\pi*k/\phi^2"记作为式(4)

+[H函数](,太阳花分布)
-->
## end
#1754, 90:
https://stackoverflow.com/questions/28567166/uniformly-distribute-x-points-inside-a-circle
## end
#1756, 17:
b=\alpha \sqrt{N}
## end
#1758, 30:
\phi=\left(\sqrt{5}+1\right)/2
## end
#1760, 114:
r \left( k \right)=\begin{cases}
1, & k>n-b\\ \sqrt{\frac{k-1/2}{n-\left(b+1\right)/2}}, & otherwise
\end{cases}


## end
#1762, 23:
\theta=2 \pi k/\phi^{2}
## end
#1769, 17:
b=\alpha*\sqrt{N}
## end
#1772, 19:
\phi=(\sqrt{5}+1)/2
## end
#1775, 60:
r(k)=\eqs{1,k>n-b;
\sqrt{\frac{k-1/2}{n-(b+1)/2}},otherwise}
## end
#1778, 21:
\theta=2*\pi*k/\phi^2
## end
#1782, 513:
%{
+[M函数](,测试电子源)
参考::https://stackoverflow.com/questions/28567166/uniformly-distribute-x-points-inside-a-circle
+[打开网页](,参考)


求和公式(html):...
太阳花分布(html):...
'求和公式'的式(8)转换为"Matlab"

二次分布:...
%}

physics_constant;

N=400;
R=1;

n=(-7+sqrt(25+8.*N))./(2);
n=round(n);
d=R/n;

xs=[];
ys=[];
t=[0,0];

for i=0:n
r_n=d*(i+1);
a_n=3+i;

t0=diff(t(1:2))*rand(1);
t=linspace(0,360,a_n+1)+t0*(-1)^i;
t=t(1:end-1);
x=r_n*cosd(t);
y=r_n*sind(t);

xs=[xs,x];
ys=[ys,y];
end
plot(xs,ys,'bo')
axis equal

%{

+[M函数](,测试电子源)
%}
## end
#1784, 272:
%{
+[M函数](,均匀分布)
%}

physics_constant;

N=400;
alpha=0.01;

k=1:N;
b=alpha.*sqrt(N);
phi=(sqrt(5)+1)./2;
r=sqrt((k-1./2)./(N-(b+1)./2)).*ones(size(k));
r(k>N-b)=1;
theta=2.*pi.*k./phi.^(2);

x=r.*cos(theta);
y=r.*sin(theta);

plot(x,y,'o')
axis equal

%{
+[M函数](,测试电子源)
%}
## end
#1786, 1056:
"""
地址::/home/xiantao/Documents/Projects/py-sem/src/basic_tools.py
+[保存P函数]"Xiantao Cheng"(,basic_tools)
+[P函数](,basic_tools)
测试分布:...
+[新建阅读窗口](,3d_patch测试)

"""
import numpy as np

def sunflower_dist(N,alpha):
    k=np.array(range(N))+1
    b=alpha*np.sqrt(N)
    phi=(np.sqrt(5)+1)/2
    r=np.sqrt((k-1/2)/(N-(b+1)/2))
    r[k>N-b]=1.
    theta=2*np.pi*k/phi**2

    x=r*np.cos(theta)
    y=r*np.sin(theta)

    return x,y,r,theta


def fromG4File_dist(N,file_name):
    f=open(file_name,'r')
    f_txt=f.read()
    f.close()
    
    list_str=f_txt.split('\n')
    list_v=[]
    for v_str in list_str:
        if v_str!="":
            list_str=v_str.split(" ")
            list_n=[float(n_str) for n_str in list_str]
            list_v.append(list_n[3:6])
    list_v=np.array(list_v)
    
    if N<len(list_v):
        vx=list_v[0:N,0]
        vy=list_v[0:N,1]
        vz=list_v[0:N,2]
    else:
        vx=list_v[:,0]
        vy=list_v[:,1]
        vz=list_v[:,2]

    return vx,vy,vz


"""
+[修改标题]"basic_tools"(,math_tools)
+[P函数](,basic_tools)

"""
## end
#1789, 58:
/home/xiantao/Documents/Projects/py-sem/src/basic_tools.py
## end
#1791, 315:
"""
+[P函数](,测试分布)
print(np.array(range(N))+1)

均匀分布:...
文件输入:...

"""

import numpy as np
import matplotlib.pyplot as plt

N=10000
file_name="文档/项目/pySEM/G.txt"
x,y,z=fromG4File_dist(N,file_name)

plt.figure()
ax=plt.gca()

ax.scatter(y,z,marker='o')

ax.axis('equal')
ax.grid()
plt.show()



"""
+[P函数](,测试分布)

"""
## end
#1793, 23:
2023-07-06 Thu 10:20:36
## end
#1795, 13:
Xiantao Cheng
## end
#1798, 800:
%{
+[M函数](,图像分布)
记住"Matlab"

输出图像:...
%}

physics_constant;


% file_name="input/austin.png";
% ratio=0.99;

file_name="input/jiaotong2.png";
ratio=0.9;

% file_name="input/tsinghua3.jpg";
% ratio=0.9;

data=imread(file_name);

R_matrix=data(:,:,1);
% R_matrix=double(data(:,:,1)+data(:,:,2)+data(:,:,3))/3;
R_threshold=ratio*max(max(R_matrix));
area0=reshape(double(R_matrix<R_threshold),1,numel(R_matrix));

N=10000;
% size(data)

Dx=size(data,2);
Dy=size(data,1);
x=(Dx-1)*rand(1,N);
y=(Dy-1)*rand(1,N);

i=int64(x);
j=int64(y);
x=x(area0(j+Dy*i+1)==1);
y=y(area0(j+Dy*i+1)==1);

subplot(1,2,1)
plot(x,y,'.')
axis equal

subplot(1,2,2)
surf(double(R_matrix<R_threshold))
shading interp
view(0,90)
axis equal

%{
size(data)
surf(R_matrix)
surf(data(:,:,3))
shading interp
length(x)
+[M函数](,图像分布)
%}
## end
#1800, 988:
%{
+[M函数](,输出图像)

运行指令"mkdir 文档/项目/pySEM"
+[打开文件夹]"文档/项目/pySEM"
%}

physics_constant;

file_output="文档/项目/pySEM/G.txt";
EN0=2.;
Dan=10;
N=10000;

file_name="input/austin.png";
% file_name="input/jiaotong2.png";
% file_name="input/tsinghua3.jpg";
ratio=0.9;

data=imread(file_name);

R_matrix=data(:,:,1);
% R_matrix=double(data(:,:,1)+data(:,:,2)+data(:,:,3))/3;
R_threshold=ratio*max(max(R_matrix));
area0=reshape(double(R_matrix<R_threshold),1,numel(R_matrix));

% size(data)

Dx=size(data,2);
Dy=size(data,1);
x=(Dx-1)*rand(1,N);
y=(Dy-1)*rand(1,N);

i=int64(x);
j=int64(y);
x=x(area0(j+Dy*i+1)==1);
y=y(area0(j+Dy*i+1)==1);
N=length(x);

tx=(x/Dx-0.5)*Dan;
ty=(y/Dy-0.5)*Dan;
En=EN0*ones(1,N);


P=En;
Py=P.*sind(tx);
Pz=P.*sind(ty);
Px=sqrt(P.^2-Py.^2-Pz.^2);

n=1:N;
Data=[zeros(N,1),zeros(N,1),zeros(N,1),...
        Px',Py',Pz',zeros(N,1),...
        zeros(N,1)+11,n',...
        ones(N,1),zeros(N,1),ones(N,1)];

writematrix(Data,file_output,'Delimiter',' ')

%{
+[M函数](,输出图像)
%}
## end
#1802, 557:
"""
+[P函数](,测试电子源)
记住"Python"

"""

import numpy as np
import matplotlib.pyplot as plt

file_name="文档/项目/pySEM/G.txt"
f=open(file_name,'r')
f_txt=f.read()
f.close()


list_str=f_txt.split('\n')
list_v=[]
for v_str in list_str:
    if v_str!="":
        list_str=v_str.split(" ")
        list_n=[float(n_str) for n_str in list_str]
        list_v.append(list_n[3:6])
list_v=np.array(list_v)

x=list_v[:,0]
y=list_v[:,1]

plt.figure()
ax=plt.gca()

ax.scatter(x,y,marker='o')

ax.axis('equal')
ax.grid()
plt.show()



"""
print(x)
print(y)
+[P函数](,测试电子源)

"""
## end
#1804, 418:
"""
+[P函数](,测试分布)
print(np.array(range(N))+1)

均匀分布:...

"""

import numpy as np
import matplotlib.pyplot as plt

N=400
alpha=0.01

k=np.array(range(N))+1
b=alpha*np.sqrt(N)
phi=(np.sqrt(5)+1)/2
r=np.sqrt((k-1/2)/(N-(b+1)/2))
r[k>N-b]=1.
theta=2*np.pi*k/phi**2

x=r*np.cos(theta)
y=r*np.sin(theta)


plt.figure()
ax=plt.gca()

ax.scatter(x,y,marker='o')

ax.axis('equal')
ax.grid()
plt.show()



"""
+[P函数](,测试分布)

"""
## end
#1806, 573:
"""
+[P函数](,测试分布)
print(np.array(range(N))+1)

均匀分布:...
文件输入:...

"""

import numpy as np
import matplotlib.pyplot as plt

file_name="文档/项目/pySEM/G.txt"
f=open(file_name,'r')
f_txt=f.read()
f.close()


list_str=f_txt.split('\n')
list_v=[]
for v_str in list_str:
    if v_str!="":
        list_str=v_str.split(" ")
        list_n=[float(n_str) for n_str in list_str]
        list_v.append(list_n[3:6])
list_v=np.array(list_v)

x=list_v[:,0]
y=list_v[:,1]

plt.figure()
ax=plt.gca()

ax.scatter(x,y,marker='o')

ax.axis('equal')
ax.grid()
plt.show()



"""
+[P函数](,测试分布)

"""
## end
#1808, 96:
\hat{y}=\begin{pmatrix}
-sin \left( \theta \right),&cos \left( \theta \right),&0
\end{pmatrix}


## end
#1810, 47:
\hat{z}=\begin{pmatrix}
0,&0,&1
\end{pmatrix}


## end
#1812, 55:
\hat{f_{x}}=\begin{pmatrix}
x/r,&0,&z/r
\end{pmatrix}


## end
#1813, 39:
\hat{x}=\vec{cos(\theta),sin(\theta),0}
## end
#1816, 40:
\hat{y}=\vec{-sin(\theta),cos(\theta),0}
## end
#1819, 19:
\hat{z}=\vec{0,0,1}
## end
#1823, 51:
\hat{f_{y}}=\begin{pmatrix}
0,&1,&0
\end{pmatrix}


## end
#1825, 56:
\hat{f_{z}}=\begin{pmatrix}
-z/r,&0,&x/r
\end{pmatrix}


## end
#1826, 27:
\hat{f_x}=\vec{x/r, 0, z/r}
## end
#1829, 21:
\hat{f_y}=\vec{0,1,0}
## end
#1832, 28:
\hat{f_z}=\vec{-z/r, 0, x/r}
## end
#1836, 34:
\hat{f_{X}}=\hat{f_{x}} \mathbf{T}
## end
#1838, 34:
\hat{f_{Y}}=\hat{f_{y}} \mathbf{T}
## end
#1840, 34:
\hat{f_{Z}}=\hat{f_{z}} \mathbf{T}
## end
#1841, 27:
\hat{f_X}=\hat{f_x}*\mat{T}
## end
#1845, 161:
\mathbf{T}=\begin{pmatrix}
cos \left( \theta \right)&sin \left( \theta \right)&0\\ -sin \left( \theta \right)&cos \left( \theta \right)&0\\ 0&0&1
\end{pmatrix}


## end
#1846, 74:
\mat{T}=\mat{cos(\theta),sin(\theta),0;
-sin(\theta),cos(\theta),0;
0,0,1}
## end
#1849, 27:
\hat{f_Y}=\hat{f_y}*\mat{T}
## end
#1852, 27:
\hat{f_Z}=\hat{f_z}*\mat{T}
## end
#1856, 159:
\hat{f_{X}}=\begin{pmatrix}
\left(x/r\right) \left(cos \left( \theta \right)\right)&\left(x/r\right) \left(sin \left( \theta \right)\right)&z/r
\end{pmatrix}


## end
#1858, 98:
\hat{f_{Y}}=\begin{pmatrix}
-sin \left( \theta \right)&cos \left( \theta \right)&0
\end{pmatrix}


## end
#1859, 59:
\hat{f_X}=\mat{(x/r)*(cos(\theta)),(x/r)*(sin(\theta)),z/r}
## end
#1862, 42:
\hat{f_Y}=\mat{-sin(\theta),cos(\theta),0}
## end
#1865, 17:
\vec{x/r, 0, z/r}
## end
#1867, 9:
\hat{f_x}
## end
#1869, 11:
\vec{0,1,0}
## end
#1871, 9:
\hat{f_y}
## end
#1874, 161:
\hat{f_{Z}}=\begin{pmatrix}
\left(-z/r\right) \left(cos \left( \theta \right)\right)&\left(-z/r\right) \left(sin \left( \theta \right)\right)&x/r
\end{pmatrix}


## end
#1875, 61:
\hat{f_Z}=\mat{(-z/r)*(cos(\theta)),(-z/r)*(sin(\theta)),x/r}
## end
#1878, 66:
\mat{cos(\theta),sin(\theta),0;
-sin(\theta),cos(\theta),0;
0,0,1}
## end
#1880, 7:
\mat{T}
## end
#1882, 18:
\vec{-z/r, 0, x/r}
## end
#1884, 9:
\hat{f_z}
## end
#1887, 1275:

    def get_BField(self):
        I=self.m_I
        R=1
        mu_0=1
        t0=45
        x0=self.m_pos[0]
        y0=self.m_pos[1]
        z0=0
        
        theta=t0/np.pi*180
        r1 = lambda X,Y,Z: np.sqrt((X-x0)**2+(Y-y0)**2+(Z-z0)**2)
        R1 = lambda X,Y,Z: r1(X,Y,Z) + np.heaviside(r*0.9-r1(X,Y,Z),1.)
        R5 = lambda X,Y,Z: r1(X,Y,Z)**5 + np.heaviside(r*0.9-r1(X,Y,Z),1.)

        x = lambda X,Y,Z: (X-x0)*np.cos(theta) + (Y-y0)*np.sin(theta)
        y = lambda X,Y,Z:-(X-x0)*np.sin(theta) + (Y-y0)*np.cos(theta)
        z = lambda X,Y,Z: (Z-z0)

        Br = lambda x,y,z: (mu_0*(I*np.pi*R**2))/(4*np.pi) \
                *(3*y*np.sqrt(x**2+z**2)) / R5(x,y,z)
        By = lambda x,y,z: (mu_0*(I*np.pi*R**2))/(4*np.pi) \
                *(2-3*(x**2+z**2)) / R5(x,y,z)

        BX = lambda X,Y,Z: \
                x(X,Y,Z)/R1(X,Y,Z)*np.cos(theta)*Br(x(X,Y,Z),y(X,Y,Z),z(X,Y,Z)) \
                    -np.sin(theta)*By(x(X,Y,Z),y(X,Y,Z),z(X,Y,Z))

        BY = lambda X,Y,Z: \
                x(X,Y,Z)/R1(X,Y,Z)*np.sin(theta)*Br(x(X,Y,Z),y(X,Y,Z),z(X,Y,Z)) \
                    +np.cos(theta)*By(x(X,Y,Z),y(X,Y,Z),z(X,Y,Z))

        BZ = lambda X,Y,Z: \
                z(X,Y,Z)/R1(X,Y,Z)*Br(x(X,Y,Z),y(X,Y,Z),z(X,Y,Z))

        return BX, BY, BZ
## end
#1889, 864:
"""
地址::/home/xiantao/Documents/Projects/py-sem/examples/electron_source.py
+[保存P函数]"Xiantao Cheng"(,例子_电子源)
+[P函数](,例子_电子源)

"""
import sys
if __name__=='__main__':
    sys.path.append(sys.path[0]+'/..')
from src.hevean import Lucifer
from src.elements import *



N=650
Dt=0.00015

luc=Lucifer()


"""
+[P函数](,测试流程)

"""
ele_1 = Lens("E1",x=0.,y=0.,r=1.e-2,D=10.e-3,R=30e-3)
ele_2 = Screen("D0",x=10.e-2,y=0.,H=50e-3, an0=0.)

ele_4 = Source("S1",x=-5.e-2,y=0., an0=2., Dan=10.)

luc.create([ele_1,ele_2,ele_4])

luc.show('scene')
# luc.show('E_field')
luc.run(N,Dt,300)
# luc.show('trajectory')
# luc.show('trajectory_2d')
# luc.show_array(["2D","scene","E_field","trajectory"])
luc.show_detection()



"""
luc.show('trajectory_2d')
luc.show('scene')
luc.show_array(["2D","scene","E_field"])
fx,fy=luc.show_detection()
print(fx,fy)
记住"Python"
+[P函数](,测试流程)

"""
## end
#1891, 1046:
"""
+[P函数](,测试流程)

基本流程:...
整合流程:...

例子_磁场:...
例子_点电场:...
例子_电透镜:...
例子_屏幕:...
例子_电子源:...
例子_

记住"Python"
del str
保存:...

"""

N=600
Dt=0.00015

luc=Lucifer()


"""
+[P函数](,测试流程)

"""
# ele_1 = Lens("E0",x=0.,y=0.,r=1.e-2,D=10.e-3,R=30e-3)
ele_2 = MagneticDipole("M0",x=5.e-2,y=0.,R=20e-3, an0=90., I=3.)
ele_3 = Screen("D0",x=10.e-2,y=0.,H=50e-3, an0=0.)
ele_4 = Source("S1",x=0.e-2,y=0., an0=0., Dan=10., srcType='file')
luc.create([ele_2,ele_3,ele_4])


# ele_2 = MagneticDipole("M0",x=0.,y=0.,R=20e-3, an0=0., I=100.)
# ele_3 = Screen("D0",x=10.e-2,y=0.,H=50e-3, an0=0.)
# ele_4 = Source("S1",x=0.,y=10.e-2, an0=-90., Dan=50.)
# luc.create([ele_2,ele_3,ele_4])


# luc.show('scene')
# luc.show_array(["2D","scene","B_field"])
luc.show_array(["2D","scene","B_field","E_field"])
luc.run(N,Dt,2000)
# luc.show('trajectory')
# luc.show('trajectory_2d')
# luc.show_array(["2D","scene","E_field","trajectory"])
luc.show_detection()



"""
luc.show('trajectory')
luc.show('trajectory_2d')
luc.show_array(["2D","scene","B_field"])
+[P函数](,测试流程)

"""
## end
#1893, 30:

测试Mag:...
+[新建阅读窗口](,测试Mag)


## end
#1895, 534:
"""
+[P函数](,测试Mag)

对称性问题:...
对称性问题2:...
对称性问题3:...

"""

from matplotlib import cm

ele_1 = MagneticDipole("M0",x=0.,y=0.,R=30e-3, an0=0., I=3.)

x_min=-3.e-2
x_max=3.e-2
y_min=-3.e-2
y_max=3.e-2
z_min=-3.e-2
z_max=3.e-2

X, Z = np.mgrid[z_min:z_max:1000j, y_min:y_max:1000j]
Y=X*0+0.5e-2
"""
+[P函数](,测试Mag)

"""


Fx, Fy, Fz=ele_1.get_BField()

plt.figure().add_subplot(projection="3d")
ax=plt.gca()
ax.plot_surface(X, Z, Fy(X,Y,Z),cmap=cm.coolwarm)
# fig.colorbar(surf, shrink=0.5, aspect=10)

plt.show()



"""
+[P函数](,测试Mag)

"""
## end
#1897, 694:
"""
+[P函数](,测试Mag)

对称性问题:...

"""

ele_1 = MagneticDipole("M0",x=2.e-2,y=0.,R=20e-3, an0=90., I=3.)

x_min=-10.e-2
x_max=10.e-2
y_min=-10.e-2
y_max=10.e-2
z_min=-10.e-2
z_max=10.e-2

# Z, X = np.mgrid[z_min:z_max:1000j, x_min:x_max:1000j]
# Y=X*0

"""
+[P函数](,测试Mag)

"""
R, X = np.mgrid[z_min:z_max:1000j, x_min:x_max:1000j]
theta=80/180*np.pi
Y=R*np.cos(theta)
Z=R*np.sin(theta)

Fx, Fy, Fz=ele_1.get_BField()
# Fr = lambda X,Y,Z: Fy(X,Y,Z)*np.cos(theta) + Fz(X,Y,Z)*np.sin(theta)
Fr = lambda X,Y,Z: Fy(X,Y,Z)*np.sin(theta) - Fz(X,Y,Z)*np.cos(theta)

plt.figure()
ax=plt.gca()
ax.streamplot(X, R, Fx(X,Y,Z), Fr(X,Y,Z), density=[0.5, 1])
ax.axis('equal')
plt.show()



"""
+[P函数](,测试Mag)

"""
## end
#1899, 1196:
"""
地址::/home/xiantao/Documents/Projects/py-sem/examples/electron_trajectory.py
+[保存P函数]"Xiantao Cheng"(,例子_电子轨迹)
+[P函数](,例子_电子轨迹)

"""
import sys
if __name__=='__main__':
    sys.path.append(sys.path[0]+'/..')
from src.hevean import Lucifer
from src.elements import *



N=600
Dt=0.00015

luc=Lucifer()


"""
+[P函数](,测试流程)

"""
# ele_1 = Lens("E0",x=0.,y=0.,r=1.e-2,D=10.e-3,R=30e-3)
ele_2 = MagneticDipole("M0",x=2.e-2,y=0.,R=20e-3, an0=90., I=-30.)
ele_3 = Screen("D0",x=10.e-2,y=0.,H=50e-3, an0=0.)
ele_4 = Source("S1",x=0.e-2,y=0., an0=0., Dan=10., srcType='regular')
luc.create([ele_2,ele_3,ele_4])


# ele_2 = MagneticDipole("M0",x=0.,y=0.,R=20e-3, an0=0., I=100.)
# ele_3 = Screen("D0",x=10.e-2,y=0.,H=50e-3, an0=0.)
# ele_4 = Source("S1",x=0.,y=10.e-2, an0=-90., Dan=50.)
# luc.create([ele_2,ele_3,ele_4])


# luc.show('scene')
# luc.show_array(["2D","scene","B_field"])
luc.show_array(["2D","scene","B_field","E_field"])
luc.run(N,Dt,200)
luc.show('trajectory')
# # luc.show('trajectory_2d')
# # luc.show_array(["2D","scene","E_field","trajectory"])
luc.show_detection()



"""
luc.show('trajectory')
luc.show('trajectory_2d')
luc.show_array(["2D","scene","B_field"])
+[P函数](,测试流程)

"""
## end
#1901, 500:
"""
+[P函数](,对称性问题2)

"""

ele_1 = MagneticDipole("M0",x=3.e-2,y=0.,R=20e-3, an0=90., I=3.)

x_min=-10.e-2
x_max=10.e-2
y_min=-10.e-2
y_max=10.e-2
z_min=-10.e-2
z_max=10.e-2

Z, Y = np.mgrid[z_min:z_max:1000j, y_min:y_max:1000j]
X=Y*0+1.001e-2
"""
+[P函数](,对称性问题2)

"""


Fx, Fy, Fz=ele_1.get_BField()

plt.figure().add_subplot(projection="3d")
ax=plt.gca()
ax.plot_surface(Y,Z,Fx(X,Y,Z),cmap=cm.coolwarm)
ax.set_xlabel("X")
ax.set_ylabel("Y")
ax.set_zlabel("Z")

plt.show()



"""
+[P函数](,对称性问题2)

"""
## end
#1903, 534:
"""
+[P函数](,测试Mag)

对称性问题:...
对称性问题2:...
对称性问题3:...

"""

from matplotlib import cm

ele_1 = MagneticDipole("M0",x=0.,y=0.,R=30e-3, an0=0., I=3.)

x_min=-3.e-2
x_max=3.e-2
y_min=-3.e-2
y_max=3.e-2
z_min=-3.e-2
z_max=3.e-2

X, Z = np.mgrid[z_min:z_max:1000j, y_min:y_max:1000j]
Y=X*0+0.5e-2
"""
+[P函数](,测试Mag)

"""


Fx, Fy, Fz=ele_1.get_BField()

plt.figure().add_subplot(projection="3d")
ax=plt.gca()
ax.plot_surface(X, Z, Fy(X,Y,Z),cmap=cm.coolwarm)
# fig.colorbar(surf, shrink=0.5, aspect=10)

plt.show()



"""
+[P函数](,测试Mag)

"""
## end
#1905, 856:
"""
地址::/home/xiantao/Documents/Projects/py-sem/examples/coil_rotation.py
+[保存P函数]"Xiantao Cheng"(,例子_线圈旋转)
+[P函数](,例子_线圈旋转)
+[打开文件夹]"文档/项目/pySEM"

"""
import sys
if __name__=='__main__':
    sys.path.append(sys.path[0]+'/..')
from src.hevean import Lucifer
from src.elements import *


N=600
Dt=0.00015

luc=Lucifer()


"""
+[P函数](,测试流程)

"""

# ele_2 = MagneticDipole("M0",x=2.e-2,y=0.,R=20e-3, an0=90., I=20.e-4)
ele_2 = MagneticDipole("M0",x=2.e-2,y=0.,R=20e-3, an0=90., I=4.e-4)
ele_3 = Screen("D0",x=10.e-2,y=0.,H=50e-3, an0=0.)
ele_4 = Source("S1",x=0.e-2,y=0., an0=0., Dan=10., srcType='file', fileName="res/data/G.txt")
luc.create([ele_2,ele_3,ele_4])

# luc.show_array(["2D","scene","B_field","E_field"])
luc.run(N,Dt,2000)
# luc.show('trajectory')
# luc.show('trajectory_2d')
luc.show_detection()



"""
luc.show('trajectory')
+[P函数](,测试流程)

"""
## end
#1907, 115:

bem:....
fem:...
mesh:...
+[新建阅读窗口](,bem)
+[P函数](,bem)
+[P函数](,fem)
pysem_sf4:...
+[新建阅读窗口](,pysem_sf4)

测试:...



## end
#1909, 7686:
"""
phi_func
load_fit3d_results
def polyval2d

"""

"""
Created on Fri Jul 14 21:50:43 2023


@author: zhang
"""

import os
import csv
import pandas as pd

import matplotlib.pyplot as plt
import math
import numpy as np
from numpy.polynomial.polynomial import polyval2d, polyder

import itertools
from functools import partial
from scipy.interpolate import UnivariateSpline, InterpolatedUnivariateSpline
from scipy.integrate import solve_ivp, trapezoid, quad

import meshio
import bempp.api
from bempp.api.operators.potential import laplace

path = r'C:\Program Files\ParaView 5.11.0\bin'
os.environ["PATH"] = os.environ["PATH"]+';'+path

# bempp.api.PLOT_BACKEND = "gmsh"
bempp.api.PLOT_BACKEND = "paraview"


@bempp.api.real_callable
def f(x, n, domain_index, result):
    num = 8
    a = 1/np.sqrt(2)
    volts = [1, a, 0, -a, -1, -a, 0, a]

    theta = 2*np.pi/num/2
    cx = 0
    cy = 0

    angle = math.atan2(x[1]-cy, x[0]-cx) + theta
    ind = int(np.mod(angle, 2*np.pi)/(2*np.pi/num))
    result[0] = volts[ind]

def calc_dflts(input_file):
    grid = bempp.api.import_grid(input_file+'.msh')
    
    dp0_space = bempp.api.function_space(grid, "DP", 0)
    p1_space = bempp.api.function_space(grid, "P", 1)    

    identity = bempp.api.operators.boundary.sparse.identity(p1_space, p1_space, dp0_space)
    dlp = bempp.api.operators.boundary.laplace.double_layer(p1_space, p1_space, dp0_space)
    slp = bempp.api.operators.boundary.laplace.single_layer(dp0_space, p1_space, dp0_space)

    dirichlet_fun = bempp.api.GridFunction(p1_space, fun=f)
    rhs = (.5 * identity + dlp) * dirichlet_fun
    
    sol, info = bempp.api.linalg.cg(slp, rhs, tol=1E-3)
    
    return grid, dp0_space, p1_space, rhs, sol

def view_results(grid=None, rhs=None, sol=None):
    if grid != None:
        grid.plot()    
    if rhs != None:
        rhs.plot()
    if sol != None:
        sol.plot()

def save_results(input_file, rhs, sol):
    output_file = input_file+'_res'
    bempp.api.export(output_file+'_rhs.msh', grid=None, grid_function=rhs, data_type='node', transformation=None, write_binary=False)

    output_file = input_file+'_res'
    bempp.api.export(output_file+'_sol.msh', grid=None, grid_function=sol, data_type='node', transformation=None, write_binary=False)

    np.savetxt(output_file+'_coeff_rhs.csv',  rhs.coefficients, delimiter = ',')
    np.savetxt(output_file+'_coeff_sol.csv',  sol.coefficients, delimiter = ',')


def load_results(input_file):
    grid = bempp.api.import_grid(input_file+'.msh')

    dp0_space = bempp.api.function_space(grid, "DP", 0)
    p1_space = bempp.api.function_space(grid, "P", 1)

    output_file = input_file+'_res'
    rhs_coeff = np.loadtxt(open(output_file+'_coeff_rhs.csv', 'rb'), delimiter=',', skiprows=0)
    sol_coeff = np.loadtxt(open(output_file+'_coeff_sol.csv', 'rb'), delimiter=',', skiprows=0)

    rhs_load = bempp.api.GridFunction(p1_space, coefficients = rhs_coeff)
    sol_load = bempp.api.GridFunction(dp0_space, coefficients = sol_coeff)

    return grid, dp0_space, p1_space, rhs_load, sol_load


def calc_results(points, dp0_space, p1_space, sol):
    single = laplace.single_layer(dp0_space, points)
    double = laplace.double_layer(p1_space, points)

    slp_pot = bempp.api.operators.potential.laplace.single_layer(dp0_space, points)
    dlp_pot = bempp.api.operators.potential.laplace.double_layer(p1_space, points)
    neumann_fun = sol
    dirichlet_fun = bempp.api.GridFunction(p1_space, fun=f)    
    u_evaluated = slp_pot * neumann_fun - dlp_pot * dirichlet_fun
    
    return u_evaluated


def fit_poly2d(xx, yy, vv, order = 5):
    """
    Fit the 2-D data array v(x,y) to a polynominal surface of given order.
    Returns the polynominal coefficients in matrix form.
    
    """
    x = xx.flatten()
    y = yy.flatten()
    v = vv.flatten()
    ncols = (order + 1)**2
    G = np.zeros((x.size, ncols))
    ij = itertools.product(range(order+1), range(order+1))
    for k, (i,j) in enumerate(ij):
        G[:,k] = x**i * y**j
    m, _, _, _ = np.linalg.lstsq(G, v, rcond=None)
    mm = m.reshape(order+1, order+1)
    
    return mm

def fit_poly2d_z_slice(grid_ctr, z, dp0_space, p1_space, sol, order = 5):
    points_ctr = np.vstack((grid_ctr[0].ravel(),
                        grid_ctr[1].ravel(),
                        z*np.ones(grid_ctr[0].size)))
    
    xx = grid_ctr[0]
    yy = grid_ctr[1]
    vv = calc_results(points_ctr, dp0_space, p1_space, sol).flatten().reshape(xx.shape).T
    mm = fit_poly2d(xx, yy, vv, order = order)

    return mm

def fit_3d(grid_ctr, z_list, dp0_space, p1_space, sol, order_poly = 5, order_spline = 5):
    # 3d fitting, xy by polyominal and z by spline
    # volt_fit_func contains all the information of the fields
    
    order = order_poly
    mmm = np.zeros([order+1, order+1, len(z_list)])
    for i in range(len(z_list)):
        print(i)
        mmm[:,:,i] = fit_poly2d_z_slice(grid_ctr, z_list[i], dp0_space, p1_space, sol, order_poly)
    
    
    volt_fit_func = np.empty((order+1, order+1), dtype=object)
    
    for i in range(order+1):
        for j in range(order+1):
            volt_fit_func[i,j] = InterpolatedUnivariateSpline(z_list, mmm[i,j,:], k = order_spline)
    
    return volt_fit_func, mmm


def save_fit3d_results(input_file, mmm, z_list):
    # save the fit results into files
    headers = ['z']
    order = mmm.shape[0] - 1
    data = np.zeros([len(z_list), (order+1)**2 + 1])
    data[:,0] = z_list
    k = 0
    for i in range(order+1):
        for j in range(order+1):
            k += 1
            headers.append(f'{i},{j}')
            data[:,k] = mmm[i,j,:]

    output_file = input_file+'_res'        
    with open(output_file+'_sol_fit.csv', 'w', newline='') as csvfile:
        csvwriter = csv.writer(csvfile)
        csvwriter.writerow(headers)
        csvwriter.writerows(data)




def load_fit3d_results(input_file, order_spline = 5):
    # read fit results from files
    output_file = input_file+'_res'        
    df = pd.read_csv(output_file+'_sol_fit.csv')
    z_list = df.values[:,0]
    data = df.values[:,1:]                 
    header = df.columns
    
    order = int((header.size-1)**0.5)-1
    
    mmm = np.zeros([order+1, order+1, len(z_list)])
    volt_fit_func = np.empty((order+1, order+1), dtype=object)
    kl = 0
    
    for i in range(order+1):
        for j in range(order+1):
            mmm[i,j,:] = data[:, kl]
            volt_fit_func[i,j] = InterpolatedUnivariateSpline(z_list, mmm[i,j,:], k = order_spline)
            kl += 1

    return volt_fit_func, mmm, z_list

def phi_func(x, y, z, volt_fit_func):
    tmp = volt_fit_func.shape[1]
    mm_fit = np.zeros([tmp, tmp])
    for i in range(tmp):
        for j in range(tmp):
            mm_fit[i,j] = volt_fit_func[i,j](z)

    phi = polyval2d(x,y,mm_fit)
    return phi

def dphi_dx_func(x, y, z, volt_fit_func):
    tmp = volt_fit_func.shape[1]
    mm_fit = np.zeros([tmp, tmp])
    for i in range(tmp):
        for j in range(tmp):
            mm_fit[i,j] = volt_fit_func[i,j](z)

    dphi_dx = polyval2d(x,y,polyder(mm_fit,axis=0))
    return dphi_dx

def dphi_dy_func(x, y, z, volt_fit_func):
    tmp = volt_fit_func.shape[1]
    mm_fit = np.zeros([tmp, tmp])
    for i in range(tmp):
        for j in range(tmp):
            mm_fit[i,j] = volt_fit_func[i,j](z)

    dphi_dy = polyval2d(x,y,polyder(mm_fit,axis=1))
    return dphi_dy

def dphi_dz_func(x,y,z,volt_fit_func):
    tmp = volt_fit_func.shape[1]
    mm_fit = np.zeros([tmp, tmp])
    for i in range(tmp):
        for j in range(tmp):
            mm_fit[i,j] = volt_fit_func[i,j].derivative(n=1)(z)

    dphi_dz = polyval2d(x,y,mm_fit)
    return dphi_dz



## end
#1911, 14810:
"""
Created on Sun Jul  2 18:43:01 2023

@author: zhang

this file calculate the potential field of lenses using FEM method

input:
    .h5 file
    
output: 
    .vtk results of FEM calculation
    2d fitting of the field
    trajectory calculation

"""

# import mesh

import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

from numpy.polynomial.hermite import hermfit, hermval, hermder
from scipy.interpolate import CloughTocher2DInterpolator
from scipy.interpolate import UnivariateSpline, InterpolatedUnivariateSpline
from scipy.integrate import solve_ivp
from functools import partial

# from sfepy.base.base import IndexedStruct
# from sfepy.discrete import (FieldVariable, Material, Integral, Function, Equation, Equations, Problem)
# from sfepy.discrete.fem import Mesh, FEDomain, Field
# from sfepy.terms import Term
# from sfepy.discrete.conditions import Conditions, EssentialBC
# from sfepy.solvers.ls import ScipyDirect
# from sfepy.solvers.nls import Newton

# import pyvista as pv

import sys, csv
sys.path.append('.')

from argparse import ArgumentParser
parser = ArgumentParser()
parser.add_argument('--version', action='version', version='%(prog)s')

#%%

def load_geometry_lens(filename, electrode_pos_x, electrode_pos_y):
    # ## import mesh
    mesh = Mesh.from_file(filename + '.h5')
    domain = FEDomain('domain', mesh)
    
    min_x, max_x = domain.get_mesh_bounding_box()[:,0]
    min_y, max_y = domain.get_mesh_bounding_box()[:,1]
    
    eps_x = 1e-4
    eps_y = 1e-4
    
    omega = domain.create_region('Omega', 'all')
    
    # ## find boundaries
    gamma_l = domain.create_region('Gamma_l',
                                  'vertices in x < %.10f' % (min_x + eps_x),
                                  'facet')
    gamma_r = domain.create_region('Gamma_r',
                                  'vertices in x > %.10f' % (max_x - eps_x),
                                  'facet')
    gamma_t = domain.create_region('Gamma_t',
                                  'vertices in y > %.10f' % (max_y - eps_y),
                                  'facet')
    gamma_b = domain.create_region('Gamma_b',
                                  'vertices in y < %.10f' % (min_y + eps_y),
                                  'facet')
    
    gamma_electrodes = []
    for i in np.arange(len(electrode_pos_x)):
        tmp = 'Gamma_' + str(i+1)
        gamma = domain.create_region(tmp, 'vertices in (x > %.10f) & (x < %.10f) & (y > %.10f)' 
                                     % (electrode_pos_x[i][0]-eps_x, electrode_pos_x[i][1]+eps_x, 
                                        electrode_pos_y[i]-eps_y), 'facet')
        gamma_electrodes.append(gamma)
        
    return omega, domain, gamma_l, gamma_r, gamma_t, gamma_b, gamma_electrodes


def get_r_dependence(ts, coors, mode=None, **kwargs):
    """    
    We want to add an r factor to the laplacian integral.
    For scalar parameters, the shape has to be set to `(coors.shape[0], 1, 1)`.

    ts: time stepper
    coors: coordinates
    """
    if mode == 'qp':
        r = coors[:,1]
        val = r.copy()
        val.shape = (coors.shape[0], 1, 1)
        return {'val' : val}


def calc_phi_field(omega, gamma_l, gamma_r, gamma_t, gamma_b, gamma_electrodes, volts):    
    # =============================================================================
    # ## define variables
    # =============================================================================
    # fields = {<name> : (<float64/complex128/real/complex>, <scalar/vector>, <region_name>, <approx_order>)}
    field = Field.from_args('potential', np.float64, 'scalar', omega, approx_order=1)
    
    # variables = {<name> : (<kind>, <field_name>, <spec>, [<history>])}
    phi = FieldVariable('phi', 'unknown', field)
    v = FieldVariable('v', 'test', field, primary_var_name='phi')
    
    # =============================================================================
    # ## define material properties
    # =============================================================================    
    function_r = Function('get_r_dependence', get_r_dependence)
    m = Material('m', function = function_r)
    # m = Material('m', electric_conductivity=1)

    # =============================================================================
    # ## define boundary conditions
    # =============================================================================
    # Dirichlet (essential) boundary conditions:
    # ebcs = {
    #     <name> : (<region_name>, [<times_specification>,]
    #               {<dof_specification> : <value>[,
    #                <dof_specification> : <value>, ...]})
    # }
    fix_vl = EssentialBC('fix_vl', gamma_l, {'phi.all' : volts[0]})
    fix_all = [fix_vl]
    for i in np.arange(len(gamma_electrodes)):
        tmp = 'fix_v' + str(i+1)
        fix_v = EssentialBC(tmp, gamma_electrodes[i], {'phi.all' : volts[i]})
        fix_all.append(fix_v)
    fix_vr = EssentialBC('fix_vr', gamma_r, {'phi.all' : volts[-1]})
    fix_all.append(fix_vr)
    
    # =============================================================================
    # ## define integrals and solvers
    # =============================================================================
    # integrals = {<name> : <order>}
    integral = Integral('i', order=3)
    ls = ScipyDirect({})
    nls_status = IndexedStruct()
    nls = Newton({}, lin_solver=ls, status=nls_status)
    
    # =============================================================================
    # ## define equations
    # =============================================================================
    t1 = Term.new('dw_laplace(m.val, v, phi)', integral, omega, m=m, v=v, phi=phi)
    eq = Equation('balance', t1)
    eqs = Equations([eq])

    # =============================================================================
    # ## define the problem
    # =============================================================================
    # pb = Problem(<name>, options)
    
    pb = Problem('electrostatics', equations=eqs)    
    pb.set_bcs(ebcs=Conditions(fix_all)) 
    pb.set_solver(nls)
    
    # =============================================================================
    # ## solve problems
    # =============================================================================
    
    status = IndexedStruct()
    variables = pb.solve(status=status)     # save an domain.vtk file here
    
    print('Nonlinear solver status:\n', nls_status)
    print('Stationary solver status:\n', status)

    return pb, variables


def save_results(filename, pb, variables):
    pb.save_state(filename + '.vtk', variables)
    pb.save_regions_as_groups(filename + '_region')        # save a region.vtk file here
    

def load_fem_results(pb, variables):
    results = pd.DataFrame()
    results['phi'] = variables.create_output()['phi'].data.flatten()
    results['z'] = pb.get_mesh_coors()[:,0]
    results['r'] = pb.get_mesh_coors()[:,1]
    
    return results    


def load_vtk_results(filename):
    vtk_data = pv.read(filename + '.vtk')

    results = pd.DataFrame()
    results['phi'] = vtk_data.point_data["phi"]
    results['z'] = vtk_data.points[:,0]
    results['r'] = vtk_data.points[:,1]
    
    return results, vtk_data


def interp_phi_results(results):
    phi_interp_func = CloughTocher2DInterpolator(list(zip(results['z'], results['r'])), results['phi'])
    
    return phi_interp_func


def calc_efield(vtk_data):
    vtk_grad_data = vtk_data.compute_derivative(scalars="phi")

    results_grad = pd.DataFrame()
    results_grad['grad'] = vtk_data_grad.point_data["gradient"]
    results_grad['z'] = vtk_data_grad.points[:,0]
    results_grad['r'] = vtk_data_grad.points[:,1]
    
    return results_grad, vtk_grad_data


def interp_efield_results(results_grad, vtk_grad_data):
    
    if results_grad == None:
        results_grad = pd.DataFrame()
        results_grad['grad'] = vtk_data_grad.point_data["gradient"]
        results_grad['z'] = vtk_data_grad.points[:,0]
        results_grad['r'] = vtk_data_grad.points[:,1]
                
    ez_interp_func = CloughTocher2DInterpolator(list(zip(results_grad['z'], results_grad['r'])), -results_grad['grad'][:,0])
    er_interp_func = CloughTocher2DInterpolator(list(zip(results_grad['z'], results_grad['r'])), -results_grad['grad'][:,1])
                
    return ez_interp_func, er_interp_func
          

def calc_total_potential(unit_potentials, electrode_potentials):
    total_potential = np.zeros(unit_potentials[0].size)
    for i in np.arange(len(electrode_potentials)):
        total_potential += unit_potentials[i] * electrode_potentials[i]
    
    return total_potential


def interp_axial_pot_func(results, total_potential):                
    inds = np.where(np.isclose(results['r'],0,atol=1e-15))
    axial_z_coords = np.array(results['z'])[inds]
    sort_inds = np.argsort(axial_z_coords)
    axial_z_coords = axial_z_coords[sort_inds]
    axial_pot = np.array(total_potential)[inds][sort_inds]
        
    axial_pot_func = InterpolatedUnivariateSpline(axial_z_coords, axial_pot, k = 5)   
    
    return axial_pot_func


def fit_unit_phi_coefficients(phi_interp_func, z_points, r_points, r_order = 14, order_spline = 5, method = 'spline'):
    # V(z,r) = \sum_n f_n(z)*r^n
    coeff = np.zeros([len(z_points), int(r_order/2+1)])
    for j in np.arange(len(z_points)):
        coeff_fn_z = np.polyfit(r_points**2, phi_interp_func(z_points[j], r_points), deg = r_order/2)
        coeff[j] = coeff_fn_z[::-1]              
        # plt.figure()
        # plt.plot(r_points, self.func_unit_phi(z_points[j], r_points),'r.')
        # plt.plot(r_points, np.polyval(coeff_fn_z, r_points**2))
    
    coeff_fn_fit = []
    for kk in np.arange(r_order/2+1):
        if method == 'spline':
            spl = InterpolatedUnivariateSpline(z_points, coeff[:,[int(kk)]], k = order_spline)
            coeff_fn_fit.append(spl)
            # plt.figure()
            # plt.plot(z_points,coeff_fn_fit[int(kk)](z_points),'r')
            # plt.plot(z_points,coeff[:,[int(kk)]],'.')                    
        elif method == 'bspline':
            pass
        elif method == 'hermite':
            c, stats = hermfit(z_points, coeff[:,[int(kk)]], deg = 50, full=True)
            coeff_fn_fit.append(c)
    
    unit_potential_fit_coeff = coeff_fn_fit

    return unit_potential_fit_coeff, coeff


def save_fit_results(filename, coeff, z_list):
    # save the fit results into files
    headers = ['z']
    for i in range(coeff.shape[1]):
        headers.append(f'{2*i}')
    
    r_order = (coeff.shape[1]-1)*2
    data = np.zeros([len(z_list), 1+coeff.shape[1]])
    data[:,0] = z_list
    data[:,1:] = coeff    
    
    with open(filename + '.csv', 'w', newline='') as csvfile:
        csvwriter = csv.writer(csvfile)
        csvwriter.writerow(headers)
        csvwriter.writerows(data)


def load_fit_results(filename, order_spline = 5, method = 'spline'):
    df = pd.read_csv(filename + '.csv')
    z_points = df.values[:,0]
    coeff = df.values[:,1:]                 
    
    r_order = (coeff.shape[1]-1)*2        
    
    coeff_fn_fit = []
    for kk in np.arange(r_order/2+1):
        if method == 'spline':
            spl = InterpolatedUnivariateSpline(z_points, coeff[:,[int(kk)]], k = order_spline)
            coeff_fn_fit.append(spl)
            # plt.figure()
            # plt.plot(z_points,coeff_fn_fit[int(kk)](z_points),'r')
            # plt.plot(z_points,coeff[:,[int(kk)]],'.')                    
        elif method == 'bspline':
            pass
        elif method == 'hermite':
            c, stats = hermfit(z_points, coeff[:,[int(kk)]], deg = 50, full=True)
            coeff_fn_fit.append(c)
    
    unit_potential_fit_coeff = coeff_fn_fit

    return unit_potential_fit_coeff, coeff, z_points

                        
def calc_unit_phi_fit_results(zz, rr, *, unit_potential_fit_coeff, r_order, method = 'spline'):
    phi = np.zeros(zz.shape)
    dphi_dz = np.zeros(zz.shape)
    dphi_dr = np.zeros(zz.shape)            
    for i in np.arange(r_order/2+1):       
        if method == 'spline' or 'bspline':
            func = unit_potential_fit_coeff[int(i)]
            phi += func(zz)*(rr)**(2*i)
            dphi_dz += func.derivative(n=1)(zz)*(rr)**(2*i)
            dphi_dr += func(zz)*(2*i)*(rr)**(2*i-1)*(np.sign(2*i-1)+1)/2               
        elif method == 'hermite':
            coeff = unit_potential_fit_coeff[int(i)]
            phi += hermval(zz, coeff)*(rr)**(2*i)
            dphi_dz += hermval(zz, hermder(coeff, m=1))*(rr)**(2*i)
            dphi_dr += hermval(zz, coeff)*(2*i)*(rr)**(2*i-1)*(np.sign(2*i-1)+1)/2            

    return phi, dphi_dz, dphi_dr
    
    
def calc_phi_interp_func(zz, rr, *, electrode_potentials, all_potential_fit_coeff, method = 'spline'):   
    phi = 0
    
    for i in np.arange(len(electrode_potentials)):

        for j in np.arange(len(all_potential_fit_coeff[0])):

            if method == 'spline' or 'bspline':
                func = all_potential_fit_coeff[i][int(j)]
                phi += func(zz)*(rr)**(2*j) * electrode_potentials[i]
                
            elif method == 'hermite':
                coeff = all_potential_fit_coeff[i][int(j)]
                phi += hermval(zz, coeff)*(rr)**(2*j) * electrode_potentials[i]
            
    return phi
                

def calc_ez_interp_func(zz, rr, *, electrode_potentials, all_potential_fit_coeff, method = 'spline'):   
    dphi_dz = 0
    for i in np.arange(len(electrode_potentials)):

        for j in np.arange(len(all_potential_fit_coeff[0])):

            if method == 'spline' or 'bspline':
                func = all_potential_fit_coeff[i][int(j)]
                dphi_dz += func.derivative(n=1)(zz)*(rr)**(2*j) * electrode_potentials[i]
                
            elif method == 'hermite':
                coeff = all_potential_fit_coeff[i][int(j)]
                dphi_dz += hermval(zz, hermder(coeff, m=1))*(rr)**(2*j) * electrode_potentials[i]
    
    ez = -dphi_dz
    return ez                   


def calc_er_interp_func(zz, rr, * , electrode_potentials, all_potential_fit_coeff, method = 'spline'):   
    dphi_dr = 0
    for i in np.arange(len(electrode_potentials)):

        for j in np.arange(1, len(all_potential_fit_coeff[0])):

            if method == 'spline' or 'bspline':
                func = all_potential_fit_coeff[i][int(j)]
                dphi_dr += func(zz)*(2*j)*(rr)**(2*j-1) * electrode_potentials[i]
                
            elif method == 'hermite':
                coeff = all_potential_fit_coeff[i][int(j)]
                dphi_dr += hermval(zz, coeff)*(2*j)*(rr)**(2*j-1) * electrode_potentials[i]
    
    er = -dphi_dr
    return er                   

## end
#1913, 3936:
"""


"""

"""
Created on Sun Jul  2 17:22:59 2023

@author: zhang

"""

import numpy as np
import gmsh, sys


def def_geo_lens(xlim, ylim, xbc_electrode, num_electrode, thk, gap, hole, z): 

    xmin, xmax = xlim
    ymin, ymax = ylim
    left_bc, right_bc = xbc_electrode
                   
    pts_y_bc = np.unique(hole + [ymin, ymax])
    points_left = np.ones([len(pts_y_bc),3])*xmin
    points_left[:,1] = pts_y_bc
    points_left[:,2] = z
    
    points_right = np.ones([len(pts_y_bc),3])*xmax
    points_right[:,1] = pts_y_bc[::-1]
    points_right[:,2] = z
    
    pos_electrodes = np.ones([num_electrode,2])*left_bc
    for i in np.arange(num_electrode-1):
        pos_electrodes[i,1] = pos_electrodes[i,0] + thk[i]
        pos_electrodes[i+1,0] = pos_electrodes[i,1] + gap[i]
    pos_electrodes[-1,1] = right_bc  
    
    return points_left, pos_electrodes, points_right


def geo_file_lens_2d(filename, xlim, ylim, xbc_electrode, num_electrode, thk, gap, hole, r_refine = 5, dens_fine = 0.02, dens_coarse = 0.2):
    # generate .geo file for 2d lens
    
    z = 0
    
    file = open(filename+'.geo', 'w+')

    # create points
    points_left, pos_electrodes, points_right = def_geo_lens(xlim, ylim, xbc_electrode, num_electrode, thk, gap, hole, z)
    
    points_electrodes = np.ones([num_electrode*4,3])*z
    for i in np.arange(num_electrode):
        points_electrodes[4*i,:-1] = [pos_electrodes[i,0],ylim[1]]
        points_electrodes[4*i+1,:-1] = [pos_electrodes[i,0],hole[i]]
        points_electrodes[4*i+2,:-1] = [pos_electrodes[i,1],hole[i]]
        points_electrodes[4*i+3,:-1] = [pos_electrodes[i,1],ylim[1]]
        
    points_all = np.vstack((points_left,points_electrodes,points_right))
    
    density = np.zeros(np.size(points_all,0))
    
    for i in np.arange(np.size(points_all,0)):
        if points_all[i,1] < r_refine:
            density[i] = dens_fine
        else:
            density[i] = dens_coarse
        file.write('Point(%d) = {%f, %f, %f, %f};\n' %(i+1, points_all[i,0], points_all[i,1], points_all[i,2], density[i]))
                   
    file.write('\n')
    
    #create lines
    for i in np.arange(np.size(points_all,0)-1):           
        file.write('Line(%d) = {%d, %d};\n' %(i+1, i+1, i+2))
    
    file.write('Line(%d) = {%d, %d};\n\n' %(np.size(points_all,0), np.size(points_all,0), 1))
    
    file.write('Curve Loop(1) = {')
    for i in np.arange(np.size(points_all,0)-1):
        file.write('%d, ' %(i+1))
    file.write('%d};\n\n' %(np.size(points_all,0)))
    
    file.write('Plane Surface(1) = {1};\n\n')
    
    file.write('Mesh.CharacteristicLengthMax= %f;\n\n' %(1))
    
    file.write('Coherence;\n\n')
    
    #file.write('Recombine Surface "*";\n\n')    # combine triangle mesh to quad mesh
    
    file.close() # cloes the geofile

    return pos_electrodes


def geo_file_dflt(filename, diameter, length, density = 1):
    # generate .geo file for cylinder deflector
    
    file = open(filename+'.geo', 'w+')
    
    file.write('SetFactory("OpenCASCADE");\n')
    file.write('Circle(1) = {0, 0, %f, %f, 0, 2*Pi};\n' %(length, diameter/2))
    file.write('Extrude {0, 0, %f} {Curve{1};}\n' %(-length))    
    file.write('Mesh.CharacteristicLengthMax= %f;\n\n' %(density))    
    file.write('Coherence;\n\n')
    
    #file.write('Recombine Surface "*";\n\n')    # combine triangle mesh to quad mesh
    
    file.close() # cloes the geofile

    return 


def geo2mesh(filename, mesh_format = '.mesh', flag_view_gmsh = False):    
    # convert .geo file to .mesh/.msh file using gmsh
    # gmsh -2 -format mesh -o filename+'.mesh/.msh' filename+'.geo'
    
    gmsh.initialize()
    gmsh.open(filename+'.geo')
    gmsh.model.mesh.generate()
    gmsh.write(filename+mesh_format)
    # Creates  graphical user interface
    if 'close' not in sys.argv:
        if flag_view_gmsh:
            gmsh.fltk.run()
    gmsh.finalize()

    return

## end
#1915, 6374:
"""
保存:...

"""

import numpy as np
import matplotlib.pyplot as plt
import mesh, fem, bem, elements#, column, stepper, traj, af
import sfepy
import os

#%% create .geo file for lenses

thk = [2, 6, 2]
gap = [4, 4]
hole = [2, 3, 2]  # 2,3,2
num_electrode = len(thk)

left_bc = -(sum(thk) + sum(gap))/2
right_bc = (sum(thk) + sum(gap))/2
xbc_electrode = [left_bc, right_bc]

xlim = [-15, 15]
ylim = [0, 20]

r_refine = 5
dens_fine = 0.2
dens_coarse = 1

filename = r'.\data\mirror'

electrode_pos_x = mesh.geo_file_lens_2d(filename, xlim, ylim, xbc_electrode, num_electrode, thk, gap, hole, r_refine, dens_fine, dens_coarse)
electrode_pos_y = hole

# use gmsh to genreate .mesh file
# gmsh -2 -format mesh -o filename+'.mesh' filename+'.geo'
mesh.geo2mesh(filename, mesh_format = '.mesh', flag_view_gmsh = False)

#%% use sfepy to convert .mesh file to .h5 file
os.system('python ' + sfepy.data_dir +'\\script\\convert_mesh.py' + ' --2d ' + filename+'.mesh ' + filename+'.h5')

#%% calculate unit potential distribution using fem method, save .vtk results

omega, domain, gamma_l, gamma_r, gamma_t, gamma_b, gamma_electrodes = fem.load_geometry_lens(filename, electrode_pos_x, electrode_pos_y)

pb_010, variables_010 = fem.calc_phi_field(omega, gamma_l, gamma_r, gamma_t, gamma_b, gamma_electrodes, volts = [0, 1, 0])
fem.save_results(filename + '_results_010', pb_010, variables_010)

pb_101, variables_101 = fem.calc_phi_field(omega, gamma_l, gamma_r, gamma_t, gamma_b, gamma_electrodes, volts = [1, 0, 1])
fem.save_results(filename + '_results_101', pb_101, variables_101)

# convert fem results to structure data
results_010 = fem.load_fem_results(pb_010, variables_010)
results_101 = fem.load_fem_results(pb_101, variables_101)

#%% load .vtk results from file    
results_010, vtk_data_010 = fem.load_vtk_results(filename + '_results_010')
results_101, vtk_data_101 = fem.load_vtk_results(filename + '_results_101')

#%% fit the results and save coefficients into .csv file
z_points = np.arange(-15,15,0.004)
r_points = np.arange(0,1,0.001)
r_order = 14   

phi_interp_func_010 = fem.interp_phi_results(results_010)
unit_potential_fit_coeff_010, coeff_010 = fem.fit_unit_phi_coefficients(phi_interp_func = phi_interp_func_010, z_points = z_points, r_points = r_points, r_order = r_order)
fem.save_fit_results(filename + '_results_010_fit', coeff_010, z_list = z_points)

phi_interp_func_101 = fem.interp_phi_results(results_101)
unit_potential_fit_coeff_101, coeff_101 = fem.fit_unit_phi_coefficients(phi_interp_func = phi_interp_func_101, z_points = z_points, r_points = r_points, r_order = r_order)
fem.save_fit_results(filename + '_results_101_fit', coeff_101, z_list = z_points)

#%% load fit results from file
unit_potential_fit_coeff_010, coeff_010, z_points = fem.load_fit_results(filename + '_results_010_fit')
unit_potential_fit_coeff_101, coeff_101, z_points = fem.load_fit_results(filename + '_results_101_fit')


#%% create .geo file for deflectors
diameter = 9
length = 30
density = 0.6
filename = r'.\data\dflt_' + str(diameter) + '_' + str(length)

mesh.geo_file_dflt(filename, diameter, length, density)
# use gmsh to genreate .msh file
# gmsh -2 -format mesh -o filename+'.msh' filename+'.geo'
mesh.geo2mesh(filename, mesh_format = '.msh', flag_view_gmsh = False)

#%% calculate unit potential distribution using bem method, save .csv results
input_file = filename
grid, dp0_space, p1_space, rhs, sol = bem.calc_dflts(input_file)
bem.save_results(input_file, rhs, sol)

#%% view the results
bem.view_results(grid=grid, rhs=rhs, sol=sol)

#%% plot the results
# 1d
plot_grid = np.arange(-5, 5, 0.05)
points = np.vstack((plot_grid,
                    (0*np.ones(plot_grid.size)),
                    5*np.ones(plot_grid.size)))

vv = bem.calc_results(points, dp0_space, p1_space, sol)

plt.figure()
plt.plot(plot_grid, vv.flatten())
plt.grid()

# 2d
plot_grid = np.mgrid[-5:5:50j, -5:5:50j]
points = np.vstack((plot_grid[0].ravel(),
                    plot_grid[1].ravel(),
                    5*np.ones(plot_grid[0].size)))

vv = bem.calc_results(points, dp0_space, p1_space, sol)

plt.figure()
plt.pcolormesh(vv.flatten().reshape([plot_grid.shape[1],plot_grid.shape[2]]).T, shading='auto', cmap='jet',clim=[-1,1])
plt.colorbar()

#%% load results
grid, dp0_space, p1_space, rhs, sol = bem.load_results(input_file)   
bem.view_results(grid=grid, rhs=rhs, sol=sol)

# %% fit the center area and save results
grid_ctr = np.mgrid[-2:2:100j, -2:2:100j]
z_list = np.linspace(grid.bounding_box[2][0]-10, grid.bounding_box[2][1]+10, 300)
volt_fit_func, mmm = bem.fit_3d(grid_ctr, z_list, dp0_space, p1_space, sol, order_poly = 5, order_spline = 5)     

bem.save_fit3d_results(input_file, mmm, z_list)
    
#%% test 2d fitting results
z = 5    
points_ctr = np.vstack((grid_ctr[0].ravel(),
                    grid_ctr[1].ravel(),
                    z*np.ones(grid_ctr[0].size)))
xx = grid_ctr[0]

vv = bem.calc_results(points_ctr, dp0_space, p1_space, sol).flatten().reshape(xx.shape).T

mm = bem.fit_poly2d_z_slice(grid_ctr, z, space, sol, order = 5)
vv_fit = bem.polyval2d(grid_ctr[0], grid_ctr[1], mm)

plt.figure()
plt.subplot(1,3,1)
plt.pcolormesh(vv, shading='auto', cmap='jet',clim=None)
plt.colorbar()
plt.subplot(1,3,2)
plt.pcolormesh(vv_fit, shading='auto', cmap='jet',clim=None)
plt.colorbar()
plt.subplot(1,3,3)
plt.pcolormesh((vv_fit-vv)/vv, shading='auto', cmap='jet',clim=[-1e-3, 1e-3])
plt.colorbar()

#%% load fitting results from file and test results in 2d
z=5
grid_ctr
input_file="/home/xiantao/Documents/Projects/py-sem/archive/v0.3/data/dflt_9_15"
# volt_fit_func, mmm, z_list = bem.load_fit3d_results(input_file)
volt_fit_func, mmm, z_list = load_fit3d_results(input_file)

tmp = volt_fit_func.shape[0]
mm_fit = np.zeros([tmp,tmp])
for i in range(tmp):
    for j in range(tmp):
#         mm_fit[i,j] = bem.volt_fit_func[i,j](z)
        mm_fit[i,j] = volt_fit_func[i,j](z)

# vv_all_fit = bem.polyval2d(grid_ctr[0], grid_ctr[1], mm_fit)
vv_all_fit = polyval2d(grid_ctr[0], grid_ctr[1], mm_fit)



plt.figure()
plt.subplot(1,3,1)
plt.pcolormesh(vv, shading='auto', cmap='jet',clim=None)
plt.colorbar()

plt.subplot(1,3,2)
plt.pcolormesh(vv_all_fit, shading='auto', cmap='jet',clim=None)
plt.colorbar()

plt.subplot(1,3,3)
plt.pcolormesh((vv_all_fit-vv)/vv, shading='auto', cmap='jet', clim=[-2e-3, 2e-3])
plt.colorbar()

plt.show()





## end
#1917, 454:
"""
+[P函数](,测试)

[mm], [V]

phi_func用法:...
保存:...
+[新建阅读窗口](,保存)

"""

z=5
grid_ctr = np.mgrid[-2:2:100j, -2:2:100j]
input_file="/home/xiantao/Documents/Projects/py-sem/archive/v0.3/data/dflt_9_30"

volt_fit_func, mmm, z_list = load_fit3d_results(input_file)
vv_all_fit = phi_func(grid_ctr[0], grid_ctr[1], z, volt_fit_func)

plt.figure()

plt.pcolormesh(vv_all_fit, shading='auto', cmap='jet',clim=None)
plt.colorbar()

plt.show()


"""
+[P函数](,测试)

"""
## end
#1919, 6368:
"""


"""

import numpy as np
import matplotlib.pyplot as plt
import mesh, fem, bem, elements#, column, stepper, traj, af
import sfepy
import os

#%% create .geo file for lenses

thk = [2, 6, 2]
gap = [4, 4]
hole = [2, 3, 2]  # 2,3,2
num_electrode = len(thk)

left_bc = -(sum(thk) + sum(gap))/2
right_bc = (sum(thk) + sum(gap))/2
xbc_electrode = [left_bc, right_bc]

xlim = [-15, 15]
ylim = [0, 20]

r_refine = 5
dens_fine = 0.2
dens_coarse = 1

filename = r'.\data\mirror'

electrode_pos_x = mesh.geo_file_lens_2d(filename, xlim, ylim, xbc_electrode, num_electrode, thk, gap, hole, r_refine, dens_fine, dens_coarse)
electrode_pos_y = hole

# use gmsh to genreate .mesh file
# gmsh -2 -format mesh -o filename+'.mesh' filename+'.geo'
mesh.geo2mesh(filename, mesh_format = '.mesh', flag_view_gmsh = False)

#%% use sfepy to convert .mesh file to .h5 file
os.system('python ' + sfepy.data_dir +'\\script\\convert_mesh.py' + ' --2d ' + filename+'.mesh ' + filename+'.h5')

#%% calculate unit potential distribution using fem method, save .vtk results

omega, domain, gamma_l, gamma_r, gamma_t, gamma_b, gamma_electrodes = fem.load_geometry_lens(filename, electrode_pos_x, electrode_pos_y)

pb_010, variables_010 = fem.calc_phi_field(omega, gamma_l, gamma_r, gamma_t, gamma_b, gamma_electrodes, volts = [0, 1, 0])
fem.save_results(filename + '_results_010', pb_010, variables_010)

pb_101, variables_101 = fem.calc_phi_field(omega, gamma_l, gamma_r, gamma_t, gamma_b, gamma_electrodes, volts = [1, 0, 1])
fem.save_results(filename + '_results_101', pb_101, variables_101)

# convert fem results to structure data
results_010 = fem.load_fem_results(pb_010, variables_010)
results_101 = fem.load_fem_results(pb_101, variables_101)

#%% load .vtk results from file    
results_010, vtk_data_010 = fem.load_vtk_results(filename + '_results_010')
results_101, vtk_data_101 = fem.load_vtk_results(filename + '_results_101')

#%% fit the results and save coefficients into .csv file
z_points = np.arange(-15,15,0.004)
r_points = np.arange(0,1,0.001)
r_order = 14   

phi_interp_func_010 = fem.interp_phi_results(results_010)
unit_potential_fit_coeff_010, coeff_010 = fem.fit_unit_phi_coefficients(phi_interp_func = phi_interp_func_010, z_points = z_points, r_points = r_points, r_order = r_order)
fem.save_fit_results(filename + '_results_010_fit', coeff_010, z_list = z_points)

phi_interp_func_101 = fem.interp_phi_results(results_101)
unit_potential_fit_coeff_101, coeff_101 = fem.fit_unit_phi_coefficients(phi_interp_func = phi_interp_func_101, z_points = z_points, r_points = r_points, r_order = r_order)
fem.save_fit_results(filename + '_results_101_fit', coeff_101, z_list = z_points)

#%% load fit results from file
unit_potential_fit_coeff_010, coeff_010, z_points = fem.load_fit_results(filename + '_results_010_fit')
unit_potential_fit_coeff_101, coeff_101, z_points = fem.load_fit_results(filename + '_results_101_fit')


#%% create .geo file for deflectors
diameter = 9
length = 30
density = 0.6
filename = r'.\data\dflt_' + str(diameter) + '_' + str(length)

mesh.geo_file_dflt(filename, diameter, length, density)
# use gmsh to genreate .msh file
# gmsh -2 -format mesh -o filename+'.msh' filename+'.geo'
mesh.geo2mesh(filename, mesh_format = '.msh', flag_view_gmsh = False)

#%% calculate unit potential distribution using bem method, save .csv results
input_file = filename
grid, dp0_space, p1_space, rhs, sol = bem.calc_dflts(input_file)
bem.save_results(input_file, rhs, sol)

#%% view the results
bem.view_results(grid=grid, rhs=rhs, sol=sol)

#%% plot the results
# 1d
plot_grid = np.arange(-5, 5, 0.05)
points = np.vstack((plot_grid,
                    (0*np.ones(plot_grid.size)),
                    5*np.ones(plot_grid.size)))

vv = bem.calc_results(points, dp0_space, p1_space, sol)

plt.figure()
plt.plot(plot_grid, vv.flatten())
plt.grid()

# 2d
plot_grid = np.mgrid[-5:5:50j, -5:5:50j]
points = np.vstack((plot_grid[0].ravel(),
                    plot_grid[1].ravel(),
                    5*np.ones(plot_grid[0].size)))

vv = bem.calc_results(points, dp0_space, p1_space, sol)

plt.figure()
plt.pcolormesh(vv.flatten().reshape([plot_grid.shape[1],plot_grid.shape[2]]).T, shading='auto', cmap='jet',clim=[-1,1])
plt.colorbar()

#%% load results
grid, dp0_space, p1_space, rhs, sol = bem.load_results(input_file)   
bem.view_results(grid=grid, rhs=rhs, sol=sol)

# %% fit the center area and save results
grid_ctr = np.mgrid[-2:2:100j, -2:2:100j]
z_list = np.linspace(grid.bounding_box[2][0]-10, grid.bounding_box[2][1]+10, 300)
volt_fit_func, mmm = bem.fit_3d(grid_ctr, z_list, dp0_space, p1_space, sol, order_poly = 5, order_spline = 5)     

bem.save_fit3d_results(input_file, mmm, z_list)
    
#%% test 2d fitting results
z = 5    
points_ctr = np.vstack((grid_ctr[0].ravel(),
                    grid_ctr[1].ravel(),
                    z*np.ones(grid_ctr[0].size)))
xx = grid_ctr[0]

vv = bem.calc_results(points_ctr, dp0_space, p1_space, sol).flatten().reshape(xx.shape).T

mm = bem.fit_poly2d_z_slice(grid_ctr, z, space, sol, order = 5)
vv_fit = bem.polyval2d(grid_ctr[0], grid_ctr[1], mm)

plt.figure()
plt.subplot(1,3,1)
plt.pcolormesh(vv, shading='auto', cmap='jet',clim=None)
plt.colorbar()
plt.subplot(1,3,2)
plt.pcolormesh(vv_fit, shading='auto', cmap='jet',clim=None)
plt.colorbar()
plt.subplot(1,3,3)
plt.pcolormesh((vv_fit-vv)/vv, shading='auto', cmap='jet',clim=[-1e-3, 1e-3])
plt.colorbar()

#%% load fitting results from file and test results in 2d
z=5
grid_ctr
input_file="/home/xiantao/Documents/Projects/py-sem/archive/v0.3/data/dflt_9_15"
# volt_fit_func, mmm, z_list = bem.load_fit3d_results(input_file)
volt_fit_func, mmm, z_list = load_fit3d_results(input_file)

tmp = volt_fit_func.shape[0]
mm_fit = np.zeros([tmp,tmp])
for i in range(tmp):
    for j in range(tmp):
#         mm_fit[i,j] = bem.volt_fit_func[i,j](z)
        mm_fit[i,j] = volt_fit_func[i,j](z)

# vv_all_fit = bem.polyval2d(grid_ctr[0], grid_ctr[1], mm_fit)
vv_all_fit = polyval2d(grid_ctr[0], grid_ctr[1], mm_fit)



plt.figure()
plt.subplot(1,3,1)
plt.pcolormesh(vv, shading='auto', cmap='jet',clim=None)
plt.colorbar()

plt.subplot(1,3,2)
plt.pcolormesh(vv_all_fit, shading='auto', cmap='jet',clim=None)
plt.colorbar()

plt.subplot(1,3,3)
plt.pcolormesh((vv_all_fit-vv)/vv, shading='auto', cmap='jet', clim=[-2e-3, 2e-3])
plt.colorbar()

plt.show()





## end
#1921, 1121:
"""
+[P函数](,测试)

保存:...

"""

z=5
grid_ctr = np.mgrid[-2:2:100j, -2:2:100j]
# input_file="/home/xiantao/Documents/Projects/py-sem/archive/v0.3/data/dflt_9_15"
input_file="/home/xiantao/Documents/Projects/py-sem/archive/v0.3/data/dflt_9_30"
# input_file="/home/xiantao/Documents/Projects/py-sem/archive/v0.3/data/dflt_9_8"

# volt_fit_func, mmm, z_list = bem.load_fit3d_results(input_file)
volt_fit_func, mmm, z_list = load_fit3d_results(input_file)

tmp = volt_fit_func.shape[0]
mm_fit = np.zeros([tmp,tmp])
for i in range(tmp):
    for j in range(tmp):
#         mm_fit[i,j] = bem.volt_fit_func[i,j](z)
        mm_fit[i,j] = volt_fit_func[i,j](z)

# vv_all_fit = bem.polyval2d(grid_ctr[0], grid_ctr[1], mm_fit)
vv_all_fit = polyval2d(grid_ctr[0], grid_ctr[1], mm_fit)



plt.figure()
# plt.subplot(1,3,1)
# plt.pcolormesh(vv, shading='auto', cmap='jet',clim=None)
# plt.colorbar()

# plt.subplot(1,3,2)
plt.pcolormesh(vv_all_fit, shading='auto', cmap='jet',clim=None)
plt.colorbar()

# plt.subplot(1,3,3)
# plt.pcolormesh((vv_all_fit-vv)/vv, shading='auto', cmap='jet', clim=[-2e-3, 2e-3])
# plt.colorbar()

plt.show()


## end
#1923, 310:
"""
+[P函数](,测试)

phi_func用法:...
保存:...

"""

z=5
grid_ctr = np.mgrid[-2:2:100j, -2:2:100j]
input_file="/home/xiantao/Documents/Projects/py-sem/archive/v0.3/data/dflt_9_30"

volt_fit_func, mmm, z_list = load_fit3d_results(input_file)
print(volt_fit_func[0][0](range(20)))
print(phi_func(0, 0, z, volt_fit_func))
## end
#1925, 57:
/home/xiantao/Documents/Projects/py-sem/examples/Coils.py
## end
#1926, 23:
2023-07-29 Sat 21:00:31
## end
#1928, 13:
Xiantao Cheng
## end
#1931, 67:
/home/xiantao/Documents/Projects/py-sem/examples/electron_source.py
## end
#1932, 23:
2023-07-29 Sat 21:37:00
## end
#1934, 13:
Xiantao Cheng
## end
#1937, 63:
/home/xiantao/Documents/Projects/py-sem/examples/test_screen.py
## end
#1939, 71:
/home/xiantao/Documents/Projects/py-sem/examples/electron_trajectory.py
## end
#1940, 23:
2023-07-29 Sat 21:40:27
## end
#1942, 13:
Xiantao Cheng
## end
#1945, 65:
/home/xiantao/Documents/Projects/py-sem/examples/coil_rotation.py
## end
#1946, 23:
2023-07-29 Sat 21:42:39
## end
#1948, 13:
Xiantao Cheng
## end
#1951, 77:
/home/xiantao/Documents/Projects/py-sem/examples/unit_testing/stepper_test.py
## end
#1952, 23:
2023-07-29 Sat 22:01:59
## end
#1954, 13:
Xiantao Cheng
## end
#1957, 81:
/home/xiantao/Documents/Projects/py-sem/examples/unit_testing/stepper_test_RK4.py
## end
#1958, 23:
2023-07-29 Sat 22:04:30
## end
#1960, 13:
Xiantao Cheng
## end
#1963, 77:
/home/xiantao/Documents/Projects/py-sem/examples/unit_testing/stepper_test.py
## end
#1964, 23:
2023-07-29 Sat 22:06:37
## end
#1966, 13:
Xiantao Cheng
## end
#1969, 81:
/home/xiantao/Documents/Projects/py-sem/examples/unit_testing/stepper_test_RK4.py
## end
#1970, 23:
2023-07-29 Sat 22:07:32
## end
#1972, 13:
Xiantao Cheng
## end
### 结束