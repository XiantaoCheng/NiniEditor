### 节点
的, 测试图形, 长度, 地址, 样本库, 样本库, 地址, 画图样本库, [标题], 的, 的, 目录, 的, 的, 光路图, 起点, 终点, 线颜色, 线型, 线粗细, 文字, 位移距离, 输入, 的, 的, 的, 的, 的, 的, 的, 输出, 图形, 选中框, 画图, 的, 的, 的, 的, 类型, 输入, 的, 的, 输出, LaTeX数学记号, 点线公式, 的, 选中区域, 的, 的, 的, 长度, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 输出, 选中框, 图形, 画图, 的, 的, 的, 的, 类型, 输出, 输入, 的, 的, 选中区域, 的, 的, 镜子, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 样本库动词, 的, 创建镜子, 文字, 字体, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 输出, 选中框, 图形, 画图, 的, 的, 的, 的, 类型, 输出, 输入, 的, 的, 选中区域, 的, 的, 单元, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 创建单元, 的, 抛物线关联, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 输入, 输出, 图形, 选中框, 类型, 的, 的, 的, 选中区域, 的, 的, 输入, 起点, 终点, 输出, 的, 点线公式, LaTeX数学记号, 线颜色, 线型, 线粗细, 按键位置, 按键位置, 的, 解释, 的, 验证, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 的, 曲率, 的, 箭头大小, 的, 的, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 的, 创建抛物线关联, 按键位置, 按键位置, 按键位置, 按键位置, 的, 规则库, 的, 距离, 的, 条件结构, 的, 结果结构, 通用, 通用, 位置2, 位置1, 和, 距离, 的, 的, 的, 的, 的, 的, 的, P代码, 的, 输出, 的, 输入, 的, pt0, 的, pt1, 的, d, 的, 的, 的, 的, 是, 是, 是, 的, 的, 的, 的, 的, 测试, 的, 词头, del, 测试, del, 测试, 的, 的, 的, 的, 的, 的, 的, del, 测试, del, 测试, del, 测试, 测试, 结构, 的, del, 测试, del, 测试, del, 测试, del, 测试, del, 测试, del, 测试, del, 测试, 的, 创建距离关系, del, 测试, del, 创建距离关系, 的, 水平中心, 的, 条件结构, 的, 结果结构, 尺寸, 的, 起点, 的, 水平中心, 矩形, 的, 的, 的, 的, 的, 的, 的, 通用, 的, center, 的, size, 的, pt, 的, P代码, 的, 输出, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 词头, 的, 是, 是, 是, 的, 的, 的, 的, 的, 创建水平中心, del, 创建水平中心, del, 创建水平中心, del, 创建水平中心, 的, 左边界, 的, 词头, 的, 条件结构, 尺寸, 的, 起点, 的, 矩形, 的, 左边界, 尺寸, 的, 起点, 的, 矩形, 的, 左边界, 的, 的, 的, 的, 的, 的, 的, 通用, 的, 结果结构, 的, b, 的, size, 的, pt, 的, P代码, 的, 输出, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 是, 是, 是, 的, 的, 的, 的, 的, 创建左边界, del, 测试, del, 创建左边界, del, 测试, del, 测试, del, 创建左边界, del, 创建水平中心, 的, 样本, 的, 等距, 的, 解释, 的, 条件结构, 距离B, 距离A, 和, 是, 等距, 的, 的, 的, 的, 的, 通用, 通用, 的, 结果结构, 的, A, 的, B, 的, P代码, 的, 输出, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 是, 是, 的, 的, 的, 的, 词头, del, 测试, 的, 等高, 的, 解释, 的, 条件结构, 尺寸, 的, 矩形B, 尺寸, 的, 矩形A, 和, 是, 等高, 的, 的, 的, 的, 的, 的, 的, 的, 的, 通用, 通用, 的, 结果结构, 的, sizeA, 的, sizeB, 的, P代码, 的, 输出, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 是, 是, 的, 的, 的, 的, 词头, del, 测试, 是, 是, 通用, 通用, 和, 是, 的, 等宽, 的, 反射, 的, 条件结构, 通用, 通用, 的, 词头, 的, 结果结构, 通用, 通用, 终点, 的, 终点, 的, 起点, 的, 出射光线, 反射点, 入射光线, 角度, 的, 中心, 的, 透镜, 反射, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 通用, 通用, 通用, 的, pt0, 的, pt1, 的, pt2, 的, P代码, 的, 输出, 的, 输入, 的, 的, 的, 通用, 的, 的, 的, 的, 的, 的, 的, 的, 的, 是, 是, 是, 的, 的, 的, del, 测试, 的, 在光路上, 的, 条件结构, 终点, 的, 起点, 的, 光线, 角度, 的, 中心, 的, 反射镜, 在光路上, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 通用, 通用, 的, 结果结构, 的, pt0, 的, pt1, 的, P代码, 的, 输出, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, center, 的, angle, 的, 的, 的, 词头, 是, 是, 的, 的, 是, 是, 的, 的, 的, 关联结构, del, 测试, 的, center, 的, angle, 的, 的, 的, 的, 等于, 等于, 的, 的, del, 测试, del, 测试, 的, 创建反射, 的, 创建在光路上, del, 创建反射, del, 创建在光路上, del, 创建在光路上, del, 创建反射, del, 创建反射, del, 创建反射, del, 创建反射, del, 创建反射, del, 创建反射, del, 创建反射, 的, 沿着, 的, 条件结构, 终点, 的, 起点, 的, 光线, 方向, 沿着, 的, 的, 的, 的, 的, 的, 的, 通用, 通用, 的, 结果结构, 的, pt0, 的, pt1, 的, angle, 的, P代码, 的, 输出, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 词头, 的, 的, 等于, 是, 的, 的, 是, 的, 的, 关联结构, del, 测试, 的, 创建沿着, del, 创建沿着, 的, 网格, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 的, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 输入, 输出, 选中框, 图形, 类型, 的, 选中区域, 输出, 面颜色, 线颜色, 线型, 线粗细, 字体, 文字, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 的, 创建网格, 的, 坐标点, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 输入, 输出, 选中框, 图形, 类型, 角度, 的, 的, 选中区域, 输出, 的, 的, 输入, 中心, 半径, 面颜色, 线颜色, 线型, 线粗细, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 的, 创建坐标点, 按键位置, 测试, 字体, 文字, 线粗细, 线型, 线颜色, 面颜色, 半径, 中心, 的, 的, 输入, 输出, 的, 的, 选中区域, 角度, 类型, 图形, 选中框, 输出, 厚度, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 输入, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 光路模块, 的, 的, 创建光路模块, 的, 可选, 的, 可选, 的, del, 创建沿着, del, 创建沿着, 的, 方向, 的, 条件结构, 终点, 的, 起点, 的, 光线, 方向, 的, 的, 的, 的, 的, 的, 通用, 的, 词头, 的, 结果结构, 的, angle, 的, pt0, 的, pt1, 的, P代码, 的, 输出, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 是, 是, 的, 的, 等于, 的, 的, 关联结构, del, 测试, del, 测试, 的, 创建方向, del, 创建方向, del, 测试, del, 创建方向, del, 创建方向, del, 创建沿着, 的, 经过, 的, 条件结构, 终点..., 终点, 的, 起点, 的, 光线, 点, 经过, 终点, 的, 起点, 的, 光线, 点, 经过, 的, 的, 的, 的, 的, 的, 的, 通用, 通用, 的, 结果结构, 的, pt, 的, pt0, 的, pt1, 的, P代码, 的, 输出, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 词头, 的, 的, 是, 是, 的, 的, 等于, 的, del, 测试, del, 测试, 的, 创建经过, del, 创建经过, del, 测试, del, 创建反射, 的, 的, 的, HTML, 比例, 的, 尺寸, 的, 原点, 的, 坐标系, 的, 的, HTML, 的, 的, HTML, 的, 的, HTML, 的, 的, HTML, 的, 的, HTML, 的, 的, HTML, 的, 节点数目统计, 20210309, 的, 20210310, 的, 20210311, 的, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 20210314, 的, 20210316, 的, 的, 箭头, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线型, 线粗细, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 按键位置, 的, 创建箭头, 20210319, 的, 的, 的, 起点, 的, 尺寸, 的, 的, 的, 的, 创建长度, 20210321, 的, 的, 单向箭头, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线型, 线粗细, 的, 创建单向箭头, 20210322, 的, 的, 图片, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 选中区域, 的, 的, 输出, HTML, 的, 的, 输出, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 起点, 尺寸, 类型, 文字, 字体, 线型, 线粗细, 面颜色, 线颜色, 的, 图片1, 的, 图片2, 的, 的, 20210326, 的, 20210328, 的, 20210331, 的, 20210404, 的, 20210407, 的, 20210410, 的, 20210411, 的, 20210413, 的, 20210414, 的, 的, 创建图片, 的, 地址, 的, 20210415, 的, 20210416, 的, 20210418, 的, 20210419, 的, 20210420, 的, 20210422, 的, 20210425, 的, 20210426, 的, 20210519, 的, 20210520, 的, 的, 光线, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 的, 测试, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, HTML, 的, 的, 输出, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 面颜色, 线颜色, 线型, 线粗细, 文字, 字体, 起点, 尺寸, 的, 焦点, 的, 直径, 的, 的, 的, 20210525, 的, 20210526, 的, 的, 光栅, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 图形, 的, 闪耀角, 的, 光栅数目, 的, 的, 的, 凹面镜, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 球面半径, 的, 的, 创建光栅, 的, 创建光线, 的, 创建凹面镜, 20210528, 的, 20210529, 的, 20210530, 的, 20210531, 的, 20210603, 的, 20210604, 的, 半径, 内部半径, 面颜色, 名字, 线粗细, 线型, 线颜色, 角度, 中心, 厚度, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 输入, 的, HTML, 的, 的, 输入, 输出, 的, 的, 选中区域, 类型, 图形, 选中框, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, iris, 的, 的, 创建iris, 20210611, 的, 20210706, 的, 的, 圆弧, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, HTML, 的, 选中区域, 的, 的, 输入, 的, 的, 输出, 类型, 画图, 的, 的, 的, 的, 图形, 选中框, 输出, 输入, 的, 的, 的, 的, 的, 的, 的, 线粗细, 线型, 线颜色, 面颜色, 角度, 半径, 中心, 的, 起始角度, 的, 的, 创建圆弧, 的, 更新, 20210707, 的, 20210713, 的, 20210822, 的, 
### 关联
387#394, #, #, #, #, #, #, #, #, 7#5, 7#6, #, 11#7, 7#14, #, #, #, #, #, #, #, #, #, 22#15, 22#16, 22#17, 22#18, 22#19, 22#20, 22#21, #, #, #, #, 33#22, 33#30, 33#31, 33#32, #, #, 39#15, 39#16, #, #, #, 44#43, #, 46#39, 46#42, 46#44, #, 50#15, 50#16, 50#33, 50#38, 50#46, 50#17, 50#18, 50#19, 50#20, 50#21, 5#50, #, #, #, #, #, #, #, #, #, 70#62, 70#63, 70#64, 70#65, 70#66, 70#67, 70#68, 70#69, #, #, #, #, 82#70, 82#79, 82#80, 82#81, #, #, #, 89#63, 89#64, #, 92#88, 92#89, #, 95#62, 95#63, 95#64, 95#82, 95#87, 95#65, 95#92, 95#66, 95#67, 95#68, 95#69, 5#95, 7#109, #, 109#111, #, #, #, #, #, #, #, #, #, #, #, 121#113, 121#112, 121#114, 121#115, 121#116, 121#117, 121#118, 121#119, 121#120, #, #, #, #, 134#121, 134#131, 134#132, 134#133, #, #, #, 141#114, 141#115, #, 144#140, 144#141, #, 147#112, 147#113, 147#114, 147#115, 147#134, 147#139, 147#116, 147#144, 147#117, 147#118, 147#119, 147#120, 5#147, 109#162, #, 5#164, #, 164#195, 164#196, 164#177, 164#187, 164#191, 164#201, 164#202, 164#203, 177#183, 177#184, 177#185, 177#186, #, 183#195, 183#196, 183#201, 183#202, 183#203, #, #, #, #, #, 191#194, 191#197, 191#199, #, 194#195, 194#196, #, #, #, #, 199#200, #, #, #, #, #, #, #, 164#207, #, 207#209, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, 164#279, #, 164#281, #, 183#279, 183#281, #, #, #, #, #, #, #, 109#292, #, #, #, #, #, 7#298, #, 298#300, #, 300#302, #, 300#304, #, 307#, 308#, #, #, 308#307, #, 309#310, 302#310, 302#311, 302#309, 302#308, 302#307, 304#318, #, 318#320, #, 318#322, #, 304#324, #, 304#326, #, 304#328, #, 322#326, 322#328, 320#324, 310#318, 324#308, 310#328, 307#326, 304#335, 304#334, 304#333, 304#332, 298#341, #, 300#343, #310, #345, #, #347, #, 304#322, 304#330, 304#329, 304#320, 304#331, 304#321, 304#319, #356, #, #358, #, #360, #, #, #, 362#361, #365, #, #367, #, #369, #, #371, #, #373, #, #375, #, #377, #310, 109#379, #, #381, #310, #383, #310, 298#385, #, 385#387, #, 385#389, #, #, 395#390, #, 395#392, #, #, 395#394, 387#396, 387#395, 387#393, 387#392, 387#391, 387#390, 395#, 389#405, #, 389#407, #, 389#409, #, 389#411, #, 411#413, #, 411#415, #, 415#407, 415#409, 413#405, 389#413, 389#418, 389#415, 389#417, 389#416, 389#412, 389#414, 385#427, #394, 394#411, 405#394, 392#409, 390#407, 389#431, 389#430, 389#429, 389#428, 109#437, #, #439, #394, #441, #394, #443, #394, 298#445, #, 445#447, #463, 445#449, #, #, 454#450, #, 454#452, #, 454#456, #, #, 461#457, #, 461#459, #, 461#463, #, 449#463, 449#462, 449#461, 449#460, 449#459, 449#458, 449#457, 461#, 445#473, #, 473#475, #, 473#477, #, 473#479, #, 473#481, #, 481#483, #, 481#485, #, 485#477, 485#479, 483#475, 473#483, 473#488, 473#485, 473#487, 473#486, 473#482, 473#484, 463#481, 475#463, 457#477, 459#479, 473#499, 473#498, 473#497, 473#496, 109#505, #, #507, #463, #509, #463, #511, #463, #513, #463, #515, #463, #517, #394, 298#519, #, 298#521, #, 521#523, #, 521#525, #, #, #, 527#526, 528#530, #, 525#530, 525#529, 525#528, 525#527, 525#526, 526#, 527#, 521#539, #, 539#541, #, 539#543, #, 539#545, #, 545#547, #, 545#549, #, 549#543, 547#541, 539#547, 539#551, 539#549, 539#550, 539#546, 539#548, 521#545, 541#527, 526#543, 539#560, 539#559, 539#558, 521#565, #530, #567, #530, 298#569, #, 569#571, #, 569#573, #, #, 576#574, #, #, 579#577, #, 579#576, 580#582, #, 573#582, 573#581, 573#580, 573#579, 573#578, 573#577, 573#576, 573#575, 573#574, 579#, 576#, 569#595, #, 595#597, #, 595#599, #, 595#601, #, 601#603, #, 601#605, #, 605#599, 603#597, 595#603, 595#607, 595#605, 595#606, 595#602, 595#604, 582#601, 597#577, 574#599, 595#616, 595#615, 595#614, 569#621, #582, #623, #582, #, #, #, #, #, 628#, 298#631, #, 298#633, #, 633#635, #, #, #, 633#639, #658, 633#641, #, #, #, #, 650#644, #, 652#646, #, 652#648, 651#, #, #651, #, 657#653, #, 657#655, #, 657#652, 635#658, 635#657, 635#656, 635#655, 635#654, 635#653, 635#652, 635#651, 635#650, 635#649, 635#648, 635#647, 635#646, 635#645, 635#644, 657#, 652#, 650#, 641#678, #, 641#680, #, 641#682, #, 641#684, #, 684#686, #, 684#688, #, 688#678, 688#680, 688#682, 651#, 641#686, 641#688, 641#691, 641#690, 641#689, 641#685, 641#687, 658#684, 641#700, 644#682, 646#680, 648#678, 641#704, 641#703, 641#702, #709, #658, 298#711, #, 711#713, #, #, 718#714, #, 718#716, #, #, 723#719, #, 723#721, #, 723#718, 713#724, 713#723, 713#722, 713#721, 713#720, 713#719, 713#718, 713#717, 713#716, 713#715, 713#714, 723#, 718#, 711#739, #, 739#741, #, 739#743, #, 739#745, #, 745#747, #, 745#749, #, 749#741, 749#743, 739#747, 739#749, 739#751, 739#750, 739#746, 739#748, 739#759, #, 739#761, #, 747#759, 747#761, 711#765, #724, 714#743, 716#741, 739#767, 739#766, 761#719, 759#721, 739#771, 739#770, 711#775, #, #777, #724, 641#779, #, 641#781, #, 686#779, 686#781, 641#783, 641#782, 781#653, 779#655, 641#787, 641#786, #791, #658, #793, #658, 109#795, #, 109#797, #, #799, #658, #801, #724, #803, #724, #805, #658, #807, #658, #809, #658, #811, #658, #813, #658, #815, #658, #817, #658, 298#819, #, 819#821, #, #, 826#822, #, 826#824, #, #, 826#827, 821#828, 821#827, 821#826, 821#825, 821#824, 821#823, 821#822, 826#, 827#, 819#839, #, 839#841, #, 839#843, #, 839#845, #, 839#847, #, 847#849, #, 847#851, #, 851#841, 851#845, 849#843, 839#849, 839#854, 839#851, 839#853, 839#852, 839#848, 839#850, 819#863, #828, 828#847, 839#864, 843#822, 824#841, 839#867, 839#866, 827#845, 839#870, 819#873, #, #875, #828, 109#877, #, #879, #828, 5#881, #, #, #, #, #, #, 95#888, #, 70#888, 881#903, 881#914, 881#916, 881#918, 881#919, 881#920, 881#921, 881#922, 881#923, 903#910, 903#911, 903#912, 903#913, #, 910#918, 910#919, 910#920, 910#921, 910#923, 910#922, #, #, #, #, #, 916#917, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, 109#939, #, 5#941, #, 941#977, 941#978, 941#956, 941#968, 941#969, 941#972, 941#979, 941#980, 941#981, 941#982, 956#964, 956#965, 956#966, 956#967, #, 964#977, 964#978, 964#969, 964#979, 964#980, 964#981, 964#982, #, #, #, #, #, #, 972#973, 972#976, #, #, 976#977, 976#978, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, 109#996, #, #, #, #, #, #, #, #, #, #, #, 1009#1005, 1009#1006, #, #, 1013#1009, 1013#1010, #, #, #, #, #, #, #, 1030#999, 1030#1000, 1030#1001, 1030#1002, 1030#1003, 1030#1004, 1030#1014, 1030#1005, 1030#1006, 1030#1019, #, 1035#1016, 1035#1017, 1035#1018, 1035#1030, #, 1049#999, 1049#1000, 1049#1001, 1049#1002, 1049#1003, 1049#1004, 1049#1013, 1049#1014, 1049#1015, 1049#1035, 1049#1005, 1049#1006, 1049#1019, #, 5#1049, 109#1052, #, 881#1054, #, 1049#1056, #, 1009#1056, #1059, #828, #1061, #828, 298#1063, #, 1063#1065, #, #, 1070#1066, #, 1070#1068, #, 1070#, 1065#1071, 1065#1070, 1065#1069, 1065#1068, 1065#1067, 1065#1066, 1070#, 1063#1080, #1071, 1063#1082, #, 1082#1084, #, 1082#1086, #, 1082#1088, #, 1082#1090, #, 1090#1092, #, 1090#1094, #, 1094#1086, 1094#1088, 1092#1084, 1082#1097, 1082#1092, 1082#1096, 1082#1095, 1082#1094, 1082#1091, 1082#1093, 1071#1090, 1082#1105, 1066#1088, 1068#1086, 1082#1108, 1082#1107, 1084#1071, 1082#1111, 1063#1114, #, #1116, #1071, #1118, #1071, 109#1120, #, #1122, #1071, #1124, #1071, #1126, #1071, #1128, #1071, #1130, #828, 298#1132, #, 1132#1134, #, #, #, 1140#1136, #, 1140#1138, #, #, 1140#1141, #, 1147#1143, #, 1147#1145, #, #, 1147#1148, 1134#1149, 1134#1148, 1134#1147, 1134#1146, 1134#1145, 1134#1144, 1134#1143, 1147#, 1148#, 1132#1160, #, 1160#1162, #, 1160#1164, #, 1160#1166, #, 1160#1168, #, 1168#1170, #, 1168#1172, #, 1172#1162, 1172#1164, 1170#1166, 1160#1175, 1160#1170, 1160#1174, 1160#1173, 1160#1172, 1160#1169, 1160#1171, 1132#1184, #1149, 1149#1168, 1160#1185, 1145#1164, 1148#1162, 1160#1188, 1160#1187, 1166#1143, 1160#1191, #1194, #1149, #1196, #1149, 109#1198, #, #1200, #1149, #1202, #658, #1204, #658, #183, 1208#183, 164#1208, #, #, 1215#1209, #, 1215#1211, #, 1215#1213, 5#, 1218#121, 147#1218, #, 1221#910, 881#1221, #, 1224#1030, 1049#1224, #, 1227#964, 941#1227, #, 1230#70, 95#1230, #, 1233#22, 50#1233, #, 11#1235, #, #, 1235#1236, #, 1235#1238, #, 1235#1240, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, 1235#1264, #, 1235#1266, 5#1269, #, 1269#1307, 1269#1308, 1269#1279, 1269#1287, 1269#1288, 1269#1309, 1269#1310, 1269#1311, 1269#1299, #, 1279#1301, 1279#1284, 1279#1285, 1279#1286, #, #, #, #, #, 1288#1292, 1288#1295, 1288#1296, #, 1292#1307, 1292#1308, #, #, 1296#1298, #, #, 1299#1301, #, 1301#1307, 1301#1308, 1301#1309, 1301#1310, 1301#1311, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, 109#1326, #, #, 1235#1327, 916#910, 881#1331, #, 881#1333, #, 910#1331, 910#1333, 910#1054, 109#1338, #, #, 1235#1339, 5#1342, #, 1342#1380, 1342#1381, 1342#1352, 1342#1360, 1342#1361, 1342#1382, 1342#1383, 1342#1384, 1342#1372, #, 1352#1374, 1352#1357, 1352#1358, 1352#1359, #, #, #, #, #, 1361#1365, 1361#1368, 1361#1369, #, 1365#1380, 1365#1381, #, #, 1369#1371, #, #, 1372#1374, #, 1374#1380, 1374#1381, 1374#1382, 1374#1383, 1374#1384, #, #, #, #, #, 109#1386, #, #, 1235#1387, 5#1390, #, 1390#1403, 1390#1411, 1390#1415, 1390#1428, 1390#1429, 1390#1430, 1390#1431, 1390#1432, 1390#1433, 1390#1434, 1390#1435, 1390#1436, #, 1403#1419, 1403#1408, 1403#1409, 1403#1410, #, #, #, #, 1411#1414, 1411#1419, #, #, 1415#1418, 1415#1419, #, #, 1419#1435, 1419#1436, 1419#1433, 1419#1434, 1419#1431, 1419#1432, 1419#1429, 1419#1428, #, #, #, #, #, #, #, #, #, 5#1438, #, 5#1440, #, 1408#1428, 1408#1429, #, 1235#1443, #, 1235#1445, #, 1235#1447, #, 1235#1449, #, 1235#1451, #, 1235#1453, #, 1235#1455, #, 1235#1457, #, 1235#1459, 109#1462, #, 1390#1464, #, 1419#1464, #, 1235#1466, #, 1235#1468, #, 1235#1470, #, 1235#1472, #, 1235#1474, #, 1235#1476, #, 1235#1478, #, 1235#1480, #, 1235#1482, #, 1235#1484, 5#1487, #, 1487#1525, 1487#1526, 1487#1497, 1487#1505, 1487#1506, 1487#1527, 1487#1528, 1487#1517, 1487#1529, #, 1497#1519, 1497#1502, 1497#1503, 1497#1504, #, #, #, #, #, 1506#1510, 1506#1513, 1506#1514, #, 1510#1525, 1510#1526, #, #, 1514#1516, #, #, 1517#1519, #, 1519#1525, 1519#1526, 1519#1527, 1519#1529, 1519#1528, #, #, #, #, #, 5#1531, #, 1531#1544, 1531#1552, 1531#1574, 1531#1553, 1531#1570, 1531#1571, 1531#1572, 1531#1573, 1531#1575, 1531#1557, 1531#1576, 1531#1577, #, 1544#1561, 1544#1549, 1544#1550, 1544#1551, #, #, #, #, #, 1553#1556, 1553#1561, #, #, 1557#1560, 1557#1561, #, #, 1561#1570, 1561#1571, 1561#1572, 1561#1573, 1561#1574, 1561#1575, 1561#1577, 1561#1576, #, #, #, #, #, #, #, #, 1487#1579, #, 1487#1581, #, 1519#1579, 1519#1581, 1510#1581, #, 1235#1585, #, 1235#1587, 5#1590, #, 1590#1632, 1590#1633, 1590#1634, 1590#1604, 1590#1612, 1590#1635, 1590#1613, 1590#1636, 1590#1637, 1590#1638, 1590#1639, 1590#1640, 1590#1620, #, 1604#1622, 1604#1609, 1604#1610, 1604#1611, #, #, #, #, #, 1613#1616, 1613#1617, #, #, 1617#1633, 1617#1634, #, 1620#1622, #, 1622#1632, 1622#1633, 1622#1634, 1622#1635, 1622#1636, 1622#1637, 1622#1638, 1622#1639, 1622#1640, #, #, #, #, #, #, #, #, #, 1590#1642, #, 1590#1644, #, 1590#1646, #, 1622#1644, 1622#1646, 5#1650, #, 1650#1692, 1650#1693, 1650#1694, 1650#1664, 1650#1672, 1650#1695, 1650#1673, 1650#1696, 1650#1697, 1650#1698, 1650#1699, 1650#1700, 1650#1680, #, 1664#1682, 1664#1669, 1664#1670, 1664#1671, #, #, #, #, #, 1673#1676, 1673#1677, #, #, 1677#1693, 1677#1694, #, 1680#1682, #, 1682#1692, 1682#1693, 1682#1694, 1682#1695, 1682#1696, 1682#1697, 1682#1698, 1682#1699, 1682#1700, #, #, #, #, #, #, #, #, #, 1650#1702, #, 1682#1702, 109#1705, #, 109#1707, #, 109#1709, #, #, 1235#1710, #, 1235#1712, #, 1235#1714, #, 1235#1716, #, 1235#1718, #, 1235#1720, #, #, #, #, #, #, #, #, #, #, 1742#1723, 1742#1725, 1742#1726, 1742#1727, 1742#1728, 1742#1724, 1742#1729, 1742#1722, 1742#1730, 1742#1731, #, 1744#1742, #, 1747#1722, 1747#1730, #, #, 1751#1747, 1751#1748, #, #, #, #, #, 1760#1753, 1760#1754, 1760#1755, 1760#1742, #, 1775#1722, 1775#1723, 1775#1724, 1775#1725, 1775#1744, 1775#1726, 1775#1727, 1775#1728, 1775#1751, 1775#1729, 1775#1752, 1775#1760, 1775#1730, 1775#1731, #, 5#1775, 109#1778, #, #, 1235#1779, #, 1235#1781, 5#1784, #, 1784#1796, 1784#1822, 1784#1823, 1784#1824, 1784#1825, 1784#1798, 1784#1826, 1784#1805, 1784#1806, 1784#1827, 1784#1828, #, 1796#1814, #, 1798#1801, 1798#1804, #, 1801#1827, 1801#1828, #, #, #, 1806#1811, 1806#1812, 1806#1813, 1806#1814, #, #, #, #, 1814#1822, 1814#1823, 1814#1824, 1814#1825, 1814#1826, 1814#1827, 1814#1828, #, #, #, #, #, #, #, 1784#1830, #, 1814#1830, 109#1833, #, 109#1835, #, #, 1235#1836, #, 1235#1838, #, 1235#1840, 
### 内容
#1, 272:
+[返回目录](,长度)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1
文字::10 cm
位移距离::20

画图:...
选中区域:...

动词:...
动作:...
的(动词,去掉选中框)->+[做](,直线)->+[code](+[做],去掉选中框)

+[创建输入](线颜色,画图)...
->+[创建输入](线型,画图)->+[创建输入](线粗细,画图)
+[创建输入](文字,画图)->+[创建输入](位移距离,画图)

+[粘贴](,直线)
## end
#2, 272:
+[返回目录](,长度)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1
文字::10 cm
位移距离::20

画图:...
选中区域:...

动词:...
动作:...
的(动词,去掉选中框)->+[做](,直线)->+[code](+[做],去掉选中框)

+[创建输入](线颜色,画图)...
->+[创建输入](线型,画图)->+[创建输入](线粗细,画图)
+[创建输入](文字,画图)->+[创建输入](位移距离,画图)

+[粘贴](,直线)
## end
#3, 16:
文档\S应用\画图样本库.txt
## end
#5, 509:
+[返回目录](,样本库)
+[场景HTML](样本库,+[临时文本])->+[H函数](,+[临时文本])
图片1::https://pythonspot.com/pyqt5-image/
图片2::https://stackoverflow.com/questions/42769354/draw-on-top-of-image

+[输出PPT]"文档\输出\20210526\test4.pptx"(样本库,)

图片:...
网格:...
坐标点:...
+[创建矩形](,图片)

来自 透镜系统.ftxt:
箭头:...
单向箭头:...
+[创建箭头](,单向箭头)


来自 绘制光路图.txt:
长度:...
镜子:...
光路模块:...

来自 喷嘴设计.txt:
单元:...
抛物线关联:...

光线:...
光栅:...
凹面镜:...
iris:...
+[创建镜子](,凹面镜)


圆弧:...
+[创建圆形](,圆弧)



+[设置结构](,样本库)
样本库=>的(样本库,_)->[]{[]=>的(_,类型)}=>+[del](,的)

测试:
+[创建矩形](,测试)


## end
#6, 17:
文档\S应用\画图样本库.ftxt
## end
#7, 478:
+[返回目录]
地址::文档\S应用\画图样本库.ftxt
[当前编辑器](画图样本库,)->是([当前编辑器],_)->+[另存为](_,地址)
+[导出结构](,画图样本库)

样本库动词:...
+[设置动词](,样本库动词)


光路图::文档\S应用\绘制光路图.ftxt
+[打开文件](+新窗口,光路图)

样本库:...
+[画板](+显示样本,样本库)
的(样本库,圆弧)->的(样本库动词,创建圆弧)->+[生成动词](圆弧,创建圆弧)

规则库:...
的(规则库,反射)->的(样本库动词,创建反射)->+[生成规则](反射,创建反射)
的(规则库,方向)->的(方向,结果结构)->的(结果结构,P代码)->+[阅读节点](P代码,P代码)
是([动词库],动词)->+[打开文件](+新窗口,动词)


测试结构::
+[del](,测试结构)
+[选择结构](测试结构,规则库)
+[显示结构关系](,测试结构)


+[粘贴](,样本库)

[当前文件](画图样本库,)->是([当前文件],_)->+[显示星图](,_)

## end
#8, 5:
画图样本库
## end
#11, 67:
画图样本库:...
创建于 20210108
+[修改标题]"目录"(,文本)

节点数目统计::
+[设置结构](,节点数目统计)

## end
#14, 17:
文档\S应用\绘制光路图.ftxt
## end
#15, 38:
-342.6228000000001, -233.7175000000001
## end
#16, 37:
26.37719999999993, -278.7175000000001
## end
#17, 5:
0,0,0
## end
#18, 8:
DashLine
## end
#19, 1:
1
## end
#20, 5:
20 cm
## end
#21, 2:
30
## end
#22, 50:
线颜色::0,0,0
线型::DashLine
线粗细::2
文字::10 cm
位移距离::20

## end
#31, 1610:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

angle=30
l=20
D=位移距离[0]
d=10
text=文字


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush(QColor(edgeColor[0],edgeColor[1],edgeColor[2])))

r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
if r!=0:
    theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]

Dx=D*np.cos(np.deg2rad(theta-90))
Dy=-D*np.sin(np.deg2rad(theta-90))
pt10=[0,0]
pt20=[0,0]
pt10[0]=pt1[0]+Dx
pt10[1]=pt1[1]+Dy
pt20[0]=pt2[0]+Dx
pt20[1]=pt2[1]+Dy

path1=QPainterPath()
path1.moveTo(pt10[0],pt10[1])
path1.lineTo(pt10[0]+dp21[0],pt10[1]+dp21[1])
path1.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1])
path1.lineTo(pt10[0],pt10[1])

path2=QPainterPath()
path2.moveTo(pt20[0],pt20[1])
path2.lineTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])
path2.lineTo(pt20[0],pt20[1])

qp.drawPath(path1)
qp.drawPath(path2)
qp.drawLine(pt1[0],pt1[1],pt10[0],pt10[1])
qp.drawLine(pt2[0],pt2[1],pt20[0],pt20[1])


dx=d*np.cos(np.deg2rad(theta-90))
dy=-d*np.sin(np.deg2rad(theta-90))
pt0=[0,0]
pt0[0]=(pt10[0]+pt20[0])/2+dx
pt0[1]=(pt10[1]+pt20[1])/2+dy

L=300
H=100
qp.drawText(pt0[0]-L/2,pt0[1]-H/2,L,H,Qt.AlignHCenter|Qt.AlignVCenter,text)

qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])

qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#32, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#33, 1610:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

angle=30
l=20
D=位移距离[0]
d=10
text=文字


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush(QColor(edgeColor[0],edgeColor[1],edgeColor[2])))

r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
if r!=0:
    theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]

Dx=D*np.cos(np.deg2rad(theta-90))
Dy=-D*np.sin(np.deg2rad(theta-90))
pt10=[0,0]
pt20=[0,0]
pt10[0]=pt1[0]+Dx
pt10[1]=pt1[1]+Dy
pt20[0]=pt2[0]+Dx
pt20[1]=pt2[1]+Dy

path1=QPainterPath()
path1.moveTo(pt10[0],pt10[1])
path1.lineTo(pt10[0]+dp21[0],pt10[1]+dp21[1])
path1.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1])
path1.lineTo(pt10[0],pt10[1])

path2=QPainterPath()
path2.moveTo(pt20[0],pt20[1])
path2.lineTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])
path2.lineTo(pt20[0],pt20[1])

qp.drawPath(path1)
qp.drawPath(path2)
qp.drawLine(pt1[0],pt1[1],pt10[0],pt10[1])
qp.drawLine(pt2[0],pt2[1],pt20[0],pt20[1])


dx=d*np.cos(np.deg2rad(theta-90))
dy=-d*np.sin(np.deg2rad(theta-90))
pt0=[0,0]
pt0[0]=(pt10[0]+pt20[0])/2+dx
pt0[1]=(pt10[1]+pt20[1])/2+dy

L=300
H=100
qp.drawText(pt0[0]-L/2,pt0[1]-H/2,L,H,Qt.AlignHCenter|Qt.AlignVCenter,text)

qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])

qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#38, 2:
直线
## end
#39, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#42, 14:
+[返回目录]
+[内容]

## end
#43, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#44, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#46, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#50, 125:
+[返回目录](,长度)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1
文字::10 cm
位移距离::20

画图:...
选中区域:...
HTML:...


## end
#62, 2:
10
## end
#63, 39:
-527.0760000000002, -181.54840000000007
## end
#64, 18:
48.373546489791295
## end
#65, 18:
-24.55999832281032
## end
#66, 11:
255,255,255
## end
#67, 5:
0,0,0
## end
#68, 8:
DashLine
## end
#69, 1:
2
## end
#70, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#80, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#81, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#82, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#87, 2:
圆形
## end
#88, 14:
+[返回目录]
+[内容]

## end
#89, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#92, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#95, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#109, 262:
+[返回目录](,样本库动词)

创建图片:...

创建镜子:...
创建单元:...
创建抛物线关联:...
创建网格:...
创建坐标点:...
创建光路模块:...

创建箭头:...
创建单向箭头:...


创建长度:...

创建光栅:...
创建光线:...
创建凹面镜:...
创建iris:...

创建圆弧:...


创建距离关系:...
创建水平中心:...
创建左边界:...

创建反射:...
创建在光路上:...
创建沿着:...
创建方向:...
创建经过:...


更新:...



## end
#111, 6539:
"""
+[返回目录](,创建镜子)

"""


+创建镜子#0(,_镜子#54)->+[del]#1(,+创建镜子#0)...


...............................................
->+[临时文本]#2"+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...
"(,)...
...............................................


->+[修改内容]#3(+[临时文本]#2,_镜子#54)->+名字#4"镜子"(,)->+线粗细#5"2"(,)...


...............................................
->+线型#6"DashLine"(,)...
...............................................





...............................................
->+线颜色#7"0,0,0"(,)...
...............................................





...............................................
->+面颜色#8"255,255,255"(,)...
...............................................





...............................................
->+角度#9"-24.55999832281032"(,)...
...............................................





...............................................
->+半径#10"48.373546489791295"(,)...
...............................................





...............................................
->+中心#11"-527.0760000000002, -181.54840000000007"(,)...
...............................................


->+厚度#12"10"(,)->+的#13(+输入#22,+名字#4)->+的#14(+输入#22,+线粗细#5)->+的#15(+输入#22,+线型#6)->+的#16(+输入#22,+线颜色#7)->+的#17(+输入#22,+面颜色#8)->+的#18(+输入#22,+角度#9)->+的#19(+输入#22,+半径#10)->+的#20(+输入#22,+中心#11)->+的#21(+输入#22,+厚度#12)...


...............................................
->+输入#22"+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子
"(,)...
...............................................


->+的#23(+HTML#24,+输入#22)...


...............................................
->+HTML#24"/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/"(,)...
...............................................


->+的#25(+输入#27,+半径#10)->+的#26(+输入#27,+中心#11)...


...............................................
->+输入#27"+[返回目录](,输入)
+[内容]
中心::200,100
半径::100
"(,)...
...............................................





...............................................
->+输出#28"+[返回目录]
+[内容]
"(,)...
...............................................


->+的#29(+选中区域#31,+输入#27)->+的#30(+选中区域#31,+输出#28)...


...............................................
->+选中区域#31"\"\"\"
+[返回目录](,选中区域)
输入:...

\"\"\"

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False"(,)...
...............................................


->+类型#32"圆形"(,)...


...............................................
->+图形#33"\"\"\"
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

\"\"\"
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont(\"Decorative\",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)


"(,)...
...............................................





...............................................
->+选中框#34"\"\"\"
+[返回目录](,选中框)

\"\"\"

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))


"(,)...
...............................................


->+输出#35(,)->+的#36(+画图#40,+图形#33)->+的#37(+画图#40,+选中框#34)->+的#38(+画图#40,+输出#35)->+的#39(+画图#40,+输入#22)...


...............................................
->+画图#40"\"\"\"
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

\"\"\"
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont(\"Decorative\",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)


"(,)...
...............................................


->+的#41(_镜子#54,+HTML#24)->+的#42(_镜子#54,+名字#4)->+的#43(_镜子#54,+线粗细#5)->+的#44(_镜子#54,+线型#6)->+的#45(_镜子#54,+线颜色#7)->+的#46(_镜子#54,+面颜色#8)->+的#47(_镜子#54,+选中区域#31)->+的#48(_镜子#54,+角度#9)->+的#49(_镜子#54,+类型#32)->+的#50(_镜子#54,+画图#40)->+的#51(_镜子#54,+半径#10)->+的#52(_镜子#54,+中心#11)->+的#53(_镜子#54,+厚度#12)->_镜子#54(,)
## end
#112, 2:
那么
## end
#113, 2:
20
## end
#114, 38:
168.37150000000008, -244.5047000000001
## end
#115, 17:
54.08326913195984
## end
#116, 17:
67.89638663736889
## end
#117, 11:
255,255,255
## end
#118, 5:
0,0,0
## end
#119, 8:
DashLine
## end
#120, 1:
2
## end
#121, 82:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
文字::test
字体::20

## end
#132, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#133, 812:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型

text=str(文字)
size_F=字体[0]

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


x0=pt[0]
y0=pt[1]
M=qp.transform()
M.translate(x0,y0)
M.rotate(-angle+90)
M.translate(-x0,-y0)

M0=qp.transform()
qp.setTransform(M)

qp.drawRect(x0-r,y0-r,2*r,2*r)

qp.setFont(QFont("Decorative",size_F))
qp.drawText(x0-r,y0-r,2*r,2*r,Qt.AlignHCenter|Qt.AlignVCenter,text)

qp.setTransform(M0)

qp.setFont(QFont())
qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#134, 812:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型

text=str(文字)
size_F=字体[0]

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


x0=pt[0]
y0=pt[1]
M=qp.transform()
M.translate(x0,y0)
M.rotate(-angle+90)
M.translate(-x0,-y0)

M0=qp.transform()
qp.setTransform(M)

qp.drawRect(x0-r,y0-r,2*r,2*r)

qp.setFont(QFont("Decorative",size_F))
qp.drawText(x0-r,y0-r,2*r,2*r,Qt.AlignHCenter|Qt.AlignVCenter,text)

qp.setTransform(M0)

qp.setFont(QFont())
qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#139, 2:
圆形
## end
#140, 14:
+[返回目录]
+[内容]

## end
#141, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#144, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#147, 135:
+[返回目录](,单元)

中心::200,100
半径::100
类型::圆形
角度::0

文字::那么
字体::20

面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#162, 6050:
"""
+[返回目录](,创建单元)

"""


+创建单元#0(,_单元#54)->+[del]#1(,+创建单元#0)...


...............................................
->+[临时文本]#2"+[返回目录](,单元)

中心::200,100
半径::100
类型::圆形
角度::0

文字::那么
字体::20

面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...
"(,)...
...............................................


->+[修改内容]#3(+[临时文本]#2,_单元#54)->+线粗细#4"2"(,)...


...............................................
->+线型#5"DashLine"(,)...
...............................................





...............................................
->+线颜色#6"0,0,0"(,)...
...............................................





...............................................
->+面颜色#7"255,255,255"(,)...
...............................................





...............................................
->+角度#8"67.89638663736889"(,)...
...............................................





...............................................
->+半径#9"54.08326913195984"(,)...
...............................................





...............................................
->+中心#10"168.37150000000008, -244.5047000000001"(,)...
...............................................


->+文字#11"那么"(,)->+字体#12"20"(,)->+的#13(+输入#22,+线粗细#4)->+的#14(+输入#22,+线型#5)->+的#15(+输入#22,+线颜色#6)->+的#16(+输入#22,+面颜色#7)->+的#17(+输入#22,+角度#8)->+的#18(+输入#22,+半径#9)->+的#19(+输入#22,+中心#10)->+的#20(+输入#22,+文字#11)->+的#21(+输入#22,+字体#12)...


...............................................
->+输入#22"+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
文字::test
字体::20
"(,)...
...............................................


->+的#23(+HTML#24,+输入#22)...


...............................................
->+HTML#24"/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


pt=[%中心];
r=%半径;
angle=%角度;
theta=angle/180*Math.PI;

x0=pt[0];
y0=pt[1];

ctx.save()
ctx.translate(x0,y0)
ctx.rotate(-theta+90/180*Math.PI)
ctx.translate(-x0,-y0)

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0-r,2*r,2*r);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0-r,2*r,2*r);
}


ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',x0,y0);


ctx.restore()




/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/"(,)...
...............................................


->+的#25(+输入#27,+半径#9)->+的#26(+输入#27,+中心#10)...


...............................................
->+输入#27"+[返回目录](,输入)
+[内容]
中心::200,100
半径::100
"(,)...
...............................................





...............................................
->+输出#28"+[返回目录]
+[内容]
"(,)...
...............................................


->+的#29(+选中区域#31,+输入#27)->+的#30(+选中区域#31,+输出#28)...


...............................................
->+选中区域#31"\"\"\"
+[返回目录](,选中区域)
输入:...

\"\"\"

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False"(,)...
...............................................


->+类型#32"圆形"(,)...


...............................................
->+图形#33"\"\"\"
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

\"\"\"
pt=中心
r=半径[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型

text=str(文字)
size_F=字体[0]

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


x0=pt[0]
y0=pt[1]
M=qp.transform()
M.translate(x0,y0)
M.rotate(-angle+90)
M.translate(-x0,-y0)

M0=qp.transform()
qp.setTransform(M)

qp.drawRect(x0-r,y0-r,2*r,2*r)

qp.setFont(QFont(\"Decorative\",size_F))
qp.drawText(x0-r,y0-r,2*r,2*r,Qt.AlignHCenter|Qt.AlignVCenter,text)

qp.setTransform(M0)

qp.setFont(QFont())
qp.setBrush(QBrush())
qp.setPen(QPen())


"(,)...
...............................................





...............................................
->+选中框#34"\"\"\"
+[返回目录](,选中框)

\"\"\"

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))


"(,)...
...............................................


->+输出#35(,)->+的#36(+画图#40,+图形#33)->+的#37(+画图#40,+选中框#34)->+的#38(+画图#40,+输出#35)->+的#39(+画图#40,+输入#22)...


...............................................
->+画图#40"\"\"\"
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

\"\"\"
pt=中心
r=半径[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型

text=str(文字)
size_F=字体[0]

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


x0=pt[0]
y0=pt[1]
M=qp.transform()
M.translate(x0,y0)
M.rotate(-angle+90)
M.translate(-x0,-y0)

M0=qp.transform()
qp.setTransform(M)

qp.drawRect(x0-r,y0-r,2*r,2*r)

qp.setFont(QFont(\"Decorative\",size_F))
qp.drawText(x0-r,y0-r,2*r,2*r,Qt.AlignHCenter|Qt.AlignVCenter,text)

qp.setTransform(M0)

qp.setFont(QFont())
qp.setBrush(QBrush())
qp.setPen(QPen())


"(,)...
...............................................


->+的#41(_单元#54,+HTML#24)->+的#42(_单元#54,+线粗细#4)->+的#43(_单元#54,+线型#5)->+的#44(_单元#54,+线颜色#6)->+的#45(_单元#54,+面颜色#7)->+的#46(_单元#54,+选中区域#31)->+的#47(_单元#54,+角度#8)->+的#48(_单元#54,+类型#32)->+的#49(_单元#54,+画图#40)->+的#50(_单元#54,+半径#9)->+的#51(_单元#54,+中心#10)->+的#52(_单元#54,+字体#12)->+的#53(_单元#54,+文字#11)->_单元#54(,)
## end
#164, 175:
+[返回目录](,抛物线关联)
解释:...
+[调用知识](+[LaTeX网页],解释)->+[全局](+[调用知识],)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::2

曲率::0.5
箭头大小::30

画图:...
选中区域:...
HTML:...



## end
#177, 1260:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点
a=曲率[0]
l=箭头大小[0]

angle=30

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))

if pt2[0]==pt1[0]:
    qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
else:
    A=a/np.abs(pt2[0]-pt1[0])

    k=(pt2[1]-pt1[1])/(pt2[0]-pt1[0])
    d=(pt2[0]*pt1[1]-pt1[0]*pt2[1])/(pt2[0]-pt1[0])
    x_i=np.linspace(pt1[0],pt2[0],500)
    y_i=A*(x_i-pt1[0])*(x_i-pt2[0])+k*x_i+d

    path=QPainterPath()
    for i in range(len(x_i)):
        if i==0:
            path.moveTo(x_i[i],y_i[i])
        else:
            path.lineTo(x_i[i],y_i[i])
    qp.drawPath(path)

    if pt2[0]<pt1[0]:
        l=-l

    theta=-np.arctan(A*(pt2[0]-pt1[0]-l/2)+k)
    Dtheta=np.deg2rad(angle)
    dp21=[l*np.cos(theta-Dtheta/2),-l*np.sin(theta-Dtheta/2)]
    dp22=[l*np.cos(theta+Dtheta/2),-l*np.sin(theta+Dtheta/2)]
    path1=QPainterPath()
    path1.moveTo(pt2[0],pt2[1])
    path1.lineTo(pt2[0]-dp21[0],pt2[1]-dp21[1])
    path1.lineTo(pt2[0]-dp22[0],pt2[1]-dp22[1])
    path1.lineTo(pt2[0],pt2[1])

    qp.setBrush(QBrush(Qt.white))
    qp.drawPath(path1)

qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#183, 60:
+[返回目录](,输入)

线颜色::0,0,0
线型::DashLine
线粗细::2
曲率::1
箭头大小::30

## end
#185, 1260:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点
a=曲率[0]
l=箭头大小[0]

angle=30

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))

if pt2[0]==pt1[0]:
    qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
else:
    A=a/np.abs(pt2[0]-pt1[0])

    k=(pt2[1]-pt1[1])/(pt2[0]-pt1[0])
    d=(pt2[0]*pt1[1]-pt1[0]*pt2[1])/(pt2[0]-pt1[0])
    x_i=np.linspace(pt1[0],pt2[0],500)
    y_i=A*(x_i-pt1[0])*(x_i-pt2[0])+k*x_i+d

    path=QPainterPath()
    for i in range(len(x_i)):
        if i==0:
            path.moveTo(x_i[i],y_i[i])
        else:
            path.lineTo(x_i[i],y_i[i])
    qp.drawPath(path)

    if pt2[0]<pt1[0]:
        l=-l

    theta=-np.arctan(A*(pt2[0]-pt1[0]-l/2)+k)
    Dtheta=np.deg2rad(angle)
    dp21=[l*np.cos(theta-Dtheta/2),-l*np.sin(theta-Dtheta/2)]
    dp22=[l*np.cos(theta+Dtheta/2),-l*np.sin(theta+Dtheta/2)]
    path1=QPainterPath()
    path1.moveTo(pt2[0],pt2[1])
    path1.lineTo(pt2[0]-dp21[0],pt2[1]-dp21[1])
    path1.lineTo(pt2[0]-dp22[0],pt2[1]-dp22[1])
    path1.lineTo(pt2[0],pt2[1])

    qp.setBrush(QBrush(Qt.white))
    qp.drawPath(path1)

qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#186, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#187, 2:
直线
## end
#191, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#194, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#195, 37:
-626.3247000000002, 89.25885000000004
## end
#196, 39:
-300.14050000000015, -40.99480000000002
## end
#197, 14:
+[返回目录]
+[内容]

## end
#199, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#200, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#201, 5:
0,0,0
## end
#202, 8:
DashLine
## end
#203, 1:
2
## end
#204, 2:
终点
## end
#205, 2:
起点
## end
#207, 827:
<!--
+[返回目录](,解释)

+[网页](web,解释)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
绘制一段过指定两点的抛物线. 使用的曲线方程如下:
$$
y=a(x-x_1)(x-x_2)+k(\vec{r}_1,\vec{r}_2)\cdot x+d(\vec{r}_1,\vec{r}_2)
$$
$$
k(\vec{r}_1,\vec{r}_2)=\frac{y_2-y_1}{x_2-x_1}
$$$$
d(\vec{r}_1,\vec{r}_2)=y_1- k\cdot x_1\\
=\frac{y_1(x_2-x_1)}{x_2-x_1}-\frac{x_1(y_2-y_1)}{x_2-x_1}
=\frac{y_1x_2-x_1y_2}{x_2-x_1}
$$

而在\((x_2,y_2)\)位置处, 曲线的斜率为:
$$
\frac{dy}{dx}|_{x=x_2}=k+a(2x-x_1-x_2)|_{x=x_2}\\
=a(x_2-x_1-dx)+k
$$

<!--
+[网页](web,解释)

验证:...
+[matlabStart](,Matlab)
-->
    </mathjax></p>
  </body>
</html>

## end
#209, 261:
%{
+[返回目录](,验证)

+[M函数](,验证)
%}

p1=[1,0];
p2=[4,4];

hold off
for a=-3:3
a=0.4*a
k=(p2(2)-p1(2))/(p2(1)-p1(1));
d=p1(2)-k*p1(1)

x=linspace(p1(1)-1,p2(1)+1,200);
y=a*(x-p1(1)).*(x-p2(1))+k*x+d;
plot(x,y,[p1(1),p2(1)],[p1(2),p2(2)],'r*')
hold on
end

axis equal
## end
#210, 2:
起点
## end
#211, 2:
里面
## end
#212, 2:
起点
## end
#213, 2:
起点
## end
#214, 2:
起点
## end
#215, 2:
起点
## end
#216, 2:
起点
## end
#217, 2:
起点
## end
#218, 2:
起点
## end
#219, 2:
起点
## end
#220, 2:
起点
## end
#221, 2:
起点
## end
#222, 2:
起点
## end
#223, 2:
起点
## end
#224, 2:
起点
## end
#225, 2:
起点
## end
#226, 2:
起点
## end
#227, 2:
起点
## end
#228, 2:
起点
## end
#229, 2:
起点
## end
#230, 2:
起点
## end
#231, 2:
起点
## end
#232, 2:
起点
## end
#233, 2:
起点
## end
#234, 2:
起点
## end
#235, 2:
起点
## end
#236, 2:
起点
## end
#237, 2:
起点
## end
#238, 2:
起点
## end
#239, 2:
起点
## end
#240, 2:
起点
## end
#241, 2:
起点
## end
#242, 2:
起点
## end
#243, 2:
起点
## end
#244, 2:
起点
## end
#245, 2:
起点
## end
#246, 2:
起点
## end
#247, 2:
终点
## end
#248, 2:
终点
## end
#249, 2:
终点
## end
#250, 2:
起点
## end
#251, 2:
终点
## end
#252, 2:
起点
## end
#253, 2:
终点
## end
#254, 2:
起点
## end
#255, 2:
终点
## end
#256, 2:
终点
## end
#257, 2:
终点
## end
#258, 2:
终点
## end
#259, 2:
终点
## end
#260, 2:
终点
## end
#261, 2:
终点
## end
#262, 2:
终点
## end
#263, 2:
终点
## end
#264, 2:
终点
## end
#265, 2:
终点
## end
#266, 2:
终点
## end
#267, 2:
终点
## end
#268, 2:
起点
## end
#269, 2:
终点
## end
#270, 2:
终点
## end
#271, 2:
终点
## end
#272, 2:
起点
## end
#273, 2:
终点
## end
#274, 2:
终点
## end
#275, 2:
终点
## end
#276, 2:
终点
## end
#277, 2:
终点
## end
#279, 3:
0.5
## end
#281, 2:
30
## end
#284, 2:
终点
## end
#285, 2:
终点
## end
#286, 2:
终点
## end
#287, 2:
终点
## end
#288, 2:
终点
## end
#289, 2:
终点
## end
#290, 2:
终点
## end
#292, 9558:
"""
+[返回目录](,创建抛物线关联)

"""


+创建抛物线关联#0(,_抛物线关联#56)->+[del]#1(,+创建抛物线关联#0)...


...............................................
->+[临时文本]#2"+[返回目录](,抛物线关联)
解释:...
+[调用知识](+[LaTeX网页],解释)->+[全局](+[调用知识],)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::2

曲率::0.5
箭头大小::30

画图:...
选中区域:...
HTML:...


"(,)...
...............................................


->+[修改内容]#3(+[临时文本]#2,_抛物线关联#56)->+箭头大小#4"30"(,)->+曲率#5"0.5"(,)->+线粗细#6"2"(,)...


...............................................
->+线型#7"DashLine"(,)...
...............................................





...............................................
->+线颜色#8"0,0,0"(,)...
...............................................





...............................................
->+终点#9"-568.3809000000002, -238.59705000000008"(,)...
...............................................





...............................................
->+起点#10"-626.3247000000002, 89.25885000000004"(,)...
...............................................


->+的#11(+输入#18,+箭头大小#4)->+的#12(+输入#18,+曲率#5)->+的#13(+输入#18,+线粗细#6)->+的#14(+输入#18,+线型#7)->+的#15(+输入#18,+线颜色#8)->+的#16(+输入#18,+终点#9)->+的#17(+输入#18,+起点#10)...


...............................................
->+输入#18"+[返回目录](,输入)

线颜色::0,0,0
线型::DashLine
线粗细::2
曲率::1
箭头大小::30
"(,)...
...............................................


->+的#19(+HTML#20,+输入#18)...


...............................................
->+HTML#20"/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


pt1=[%起点];
pt2=[%终点];
a=%曲率;
l=%箭头大小;

angle=30/180*Math.PI;

dx=(pt2[0]-pt1[0])/500;


ctx.beginPath();

if(pt2[0]==pt1[0]) {
    ctx.moveTo(pt1[0],pt1[1]);
    ctx.lineTo(pt2[0],pt2[1]);
}
else {
    A=a/Math.abs(pt2[0]-pt1[0]);

    k=(pt2[1]-pt1[1])/(pt2[0]-pt1[0]);
    d=(pt2[0]*pt1[1]-pt1[0]*pt2[1])/(pt2[0]-pt1[0]);

    ctx.moveTo(pt1[0],pt1[1]);
    for (let x_i=pt1[0];x_i<=pt2[0];x_i+=dx) {
        y_i=A*(x_i-pt1[0])*(x_i-pt2[0])+k*x_i+d
        ctx.lineTo(x_i,y_i);
    }

    ctx.stroke();


    ctx.beginPath();

    theta=-Math.atan(A*(pt2[0]-pt1[0]-l/2)+k);
    Dtheta=angle;
    dp21=[l*Math.cos(theta-Dtheta/2),-l*Math.sin(theta-Dtheta/2)];
    dp22=[l*Math.cos(theta+Dtheta/2),-l*Math.sin(theta+Dtheta/2)];

    ctx.moveTo(pt2[0],pt2[1]);
    ctx.lineTo(pt2[0]-dp21[0],pt2[1]-dp21[1]);
    ctx.lineTo(pt2[0]-dp22[0],pt2[1]-dp22[1]);
    ctx.lineTo(pt2[0],pt2[1]);
    ctx.fill();
    ctx.stroke();
}


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/"(,)...
...............................................





...............................................
->+验证#21"%{
+[返回目录](,验证)

+[M函数](,验证)
%}

p1=[1,0];
p2=[4,4];

hold off
for a=-3:3
a=0.4*a
k=(p2(2)-p1(2))/(p2(1)-p1(1));
d=p1(2)-k*p1(1)

x=linspace(p1(1)-1,p2(1)+1,200);
y=a*(x-p1(1)).*(x-p2(1))+k*x+d;
plot(x,y,[p1(1),p2(1)],[p1(2),p2(2)],'r*')
hold on
end

axis equal"(,)...
...............................................


->+的#22(+解释#23,+验证#21)...


...............................................
->+解释#23"<!--
+[返回目录](,解释)

+[网页](web,解释)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type=\"text/javascript\" src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"></script>
  </head>
  <body>
    <p><mathjax style=\"font-size:1.5em\">
绘制一段过指定两点的抛物线. 使用的曲线方程如下:
$$
y=a(x-x_1)(x-x_2)+k(\vec{r}_1,\vec{r}_2)\cdot x+d(\vec{r}_1,\vec{r}_2)
$$
$$
k(\vec{r}_1,\vec{r}_2)=\frac{y_2-y_1}{x_2-x_1}
$$$$
d(\vec{r}_1,\vec{r}_2)=y_1- k\cdot x_1\\
=\frac{y_1(x_2-x_1)}{x_2-x_1}-\frac{x_1(y_2-y_1)}{x_2-x_1}
=\frac{y_1x_2-x_1y_2}{x_2-x_1}
$$

而在\((x_2,y_2)\)位置处, 曲线的斜率为:
$$
\frac{dy}{dx}|_{x=x_2}=k+a(2x-x_1-x_2)|_{x=x_2}\\
=a(x_2-x_1-dx)+k
$$

<!--
+[网页](web,解释)

验证:...
+[matlabStart](,Matlab)
-->
    </mathjax></p>
  </body>
</html>
"(,)...
...............................................





...............................................
->+LaTeX数学记号#24"https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols"(,)...
...............................................


->+的#25(+点线公式#26,+LaTeX数学记号#24)...


...............................................
->+点线公式#26"<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type=\"text/javascript\" src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"></script>
  </head>
  <body>
    <p><mathjax style=\"font-size:1.5em\">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>
"(,)...
...............................................





...............................................
->+输出#27"+[返回目录]
+[内容]
"(,)...
...............................................


->+的#28(+输入#30,+终点#9)->+的#29(+输入#30,+起点#10)...


...............................................
->+输入#30"+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0
"(,)...
...............................................


->+的#31(+选中区域#34,+点线公式#26)->+的#32(+选中区域#34,+输出#27)->+的#33(+选中区域#34,+输入#30)...


...............................................
->+选中区域#34"\"\"\"
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

\"\"\"

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False
"(,)...
...............................................


->+类型#35"直线"(,)...


...............................................
->+选中框#36"\"\"\"
+[返回目录](,选中框)

\"\"\"
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))"(,)...
...............................................





...............................................
->+图形#37"\"\"\"
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

\"\"\"
pt1=起点
pt2=终点
a=曲率[0]
l=箭头大小[0]

angle=30

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))

if pt2[0]==pt1[0]:
    qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
else:
    A=a/np.abs(pt2[0]-pt1[0])

    k=(pt2[1]-pt1[1])/(pt2[0]-pt1[0])
    d=(pt2[0]*pt1[1]-pt1[0]*pt2[1])/(pt2[0]-pt1[0])
    x_i=np.linspace(pt1[0],pt2[0],500)
    y_i=A*(x_i-pt1[0])*(x_i-pt2[0])+k*x_i+d

    path=QPainterPath()
    for i in range(len(x_i)):
        if i==0:
            path.moveTo(x_i[i],y_i[i])
        else:
            path.lineTo(x_i[i],y_i[i])
    qp.drawPath(path)

    if pt2[0]<pt1[0]:
        l=-l

    theta=-np.arctan(A*(pt2[0]-pt1[0]-l/2)+k)
    Dtheta=np.deg2rad(angle)
    dp21=[l*np.cos(theta-Dtheta/2),-l*np.sin(theta-Dtheta/2)]
    dp22=[l*np.cos(theta+Dtheta/2),-l*np.sin(theta+Dtheta/2)]
    path1=QPainterPath()
    path1.moveTo(pt2[0],pt2[1])
    path1.lineTo(pt2[0]-dp21[0],pt2[1]-dp21[1])
    path1.lineTo(pt2[0]-dp22[0],pt2[1]-dp22[1])
    path1.lineTo(pt2[0],pt2[1])

    qp.setBrush(QBrush(Qt.white))
    qp.drawPath(path1)

qp.setBrush(QBrush())
qp.setPen(QPen())

"(,)...
...............................................


->+输出#38(,)->+的#39(+画图#43,+选中框#36)->+的#40(+画图#43,+图形#37)->+的#41(+画图#43,+输出#38)->+的#42(+画图#43,+输入#18)...


...............................................
->+画图#43"\"\"\"
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

\"\"\"
pt1=起点
pt2=终点
a=曲率[0]
l=箭头大小[0]

angle=30

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))

if pt2[0]==pt1[0]:
    qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
else:
    A=a/np.abs(pt2[0]-pt1[0])

    k=(pt2[1]-pt1[1])/(pt2[0]-pt1[0])
    d=(pt2[0]*pt1[1]-pt1[0]*pt2[1])/(pt2[0]-pt1[0])
    x_i=np.linspace(pt1[0],pt2[0],500)
    y_i=A*(x_i-pt1[0])*(x_i-pt2[0])+k*x_i+d

    path=QPainterPath()
    for i in range(len(x_i)):
        if i==0:
            path.moveTo(x_i[i],y_i[i])
        else:
            path.lineTo(x_i[i],y_i[i])
    qp.drawPath(path)

    if pt2[0]<pt1[0]:
        l=-l

    theta=-np.arctan(A*(pt2[0]-pt1[0]-l/2)+k)
    Dtheta=np.deg2rad(angle)
    dp21=[l*np.cos(theta-Dtheta/2),-l*np.sin(theta-Dtheta/2)]
    dp22=[l*np.cos(theta+Dtheta/2),-l*np.sin(theta+Dtheta/2)]
    path1=QPainterPath()
    path1.moveTo(pt2[0],pt2[1])
    path1.lineTo(pt2[0]-dp21[0],pt2[1]-dp21[1])
    path1.lineTo(pt2[0]-dp22[0],pt2[1]-dp22[1])
    path1.lineTo(pt2[0],pt2[1])

    qp.setBrush(QBrush(Qt.white))
    qp.drawPath(path1)

qp.setBrush(QBrush())
qp.setPen(QPen())

"(,)...
...............................................


->+的#44(_抛物线关联#56,+HTML#20)->+的#45(_抛物线关联#56,+箭头大小#4)->+的#46(_抛物线关联#56,+曲率#5)->+的#47(_抛物线关联#56,+解释#23)->+的#48(_抛物线关联#56,+线粗细#6)->+的#49(_抛物线关联#56,+线型#7)->+的#50(_抛物线关联#56,+线颜色#8)->+的#51(_抛物线关联#56,+选中区域#34)->+的#52(_抛物线关联#56,+类型#35)->+的#53(_抛物线关联#56,+画图#43)->+的#54(_抛物线关联#56,+终点#9)->+的#55(_抛物线关联#56,+起点#10)->_抛物线关联#56(,)
## end
#293, 2:
终点
## end
#294, 2:
终点
## end
#295, 2:
终点
## end
#296, 2:
终点
## end
#298, 349:
+[返回目录](,规则库)
样本:...

距离:...
水平中心:...
左边界:...
等距:...
等高:...
等宽:


光路相关:
反射:...
在光路上:...
沿着:...
方向:...
经过:...
+[修改内容](样本,经过)

是([动词库],动词)->+[打开文件](+新窗口,动词)
测试结构::
+[del](,测试结构)
+[选择结构](测试结构,经过)
+[显示结构关系](,测试结构)
[当前文件](规则库,)->是([当前文件],_)=>的(_,_节点)=>+[显示](,_节点)
->+[显示结构关系](,_)


+[复制结构](,等高)
(复制结构的动词有问题, 需要解决一下)
+[粘贴](,规则库)




+[生成规则](反射,测试)

测试:...
## end
#300, 292:
+[返回目录](,距离)

词头::
词头(,距离)

条件结构:...
结果结构:...

的(结果结构,P代码)->的(结果结构,pt0)->的(结果结构,pt1)->的(结果结构,d)...
->的(条件结构,位置1)->的(条件结构,位置2)->的(条件结构,距离)...
->+是(位置2,pt1)->+[有](结果结构,+是)...
->+是(距离,d)->+[有](结果结构,+是)...
->+是(pt0,位置1)->+[有](结果结构,+是)...
->+的(距离,P代码)->+[有](结果结构,+的)

是([动词库],动词)->+[打开文件](+新窗口,动词)
## end
#302, 175:
+[返回目录](,条件结构)

距离::
和::
位置1::
位置2::

的(和,距离)->和(位置1,位置2)
...

->+[有](条件结构,+距离)->+[有](条件结构,+的)->+[有](条件结构,+和)...
->+[有](条件结构,+位置1)->+[有](条件结构,+位置2)...
->+通用(+位置1,)->+通用(+位置2,)
## end
#304, 130:
+[返回目录](,结果结构)

pt0::
pt1::
d::

P代码:...

+[创建函数](,P代码)
+[创建输入](pt1,P代码)->+[创建输入](d,P代码)...
->+[创建输出](pt0,P代码)

+[选择结构](结果结构,P代码)

## end
#318, 66:
"""
+[返回目录](,P代码)
输入:...
输出:...
+[P函数](,P代码)

"""

pt0=pt1[0]+d[0]
## end
#320, 25:
+[返回目录](,输出)
+[内容]
pt0::

## end
#322, 29:
+[返回目录](,输入)
+[内容]
pt1::
d::

## end
#341, 1657:
"""
+[返回目录](,测试)

"""

+测试#1(,反射#4)->+[del]#2(,+测试#1)...

->反射#4(_透镜#5,_入射光线#10)->_透镜#5(,)->的#6(_透镜#5,中心#7)->中心#7(,)->的#8(_透镜#5,角度#9)->角度#9(,)->_入射光线#10(,_反射点#11)->_反射点#11(,)->_出射光线#12(_反射点#11,)->的#13(_入射光线#10,起点#14)->起点#14(,)->的#15(_入射光线#10,终点#16)->终点#16(,)->的#17(_出射光线#12,终点#18)->终点#18(,)...

->+pt0#20(,)->+pt1#21(,)->+pt2#22(,)...


...............................................
->+P代码#23"\"\"\"
+[返回目录](,P代码)
输入:...
输出:...
+[P函数](,P代码)

\"\"\"

dx01=pt0[0]-pt1[0]
dy01=pt0[1]-pt1[1]
r01=np.sqrt(dx01**2+dy01**2)

dx12=pt2[0]-pt1[0]
dy12=pt2[1]-pt1[1]
r12=np.sqrt(dx12**2+dy12**2)

center=pt1

if dy01!=0:
    angle1=-np.rad2deg(np.arccos(dx01/r01)*np.sign(dy01))
else:
    if dx01<0:
        angle1=180
    else:
        angle1=0

if dy12!=0:
    angle2=-np.rad2deg(np.arccos(dx12/r12)*np.sign(dy12))
else:
    if dx12<0:
        angle2=180
    else:
        angle2=0

dangle=angle2-angle1
angle=(angle1+angle2)/2


if dangle<-180 or dangle>180:
    angle+=180

"(,)...
...............................................





...............................................
->+输出#24"+[返回目录]
+[内容]
center::
angle::
"(,)...
...............................................





...............................................
->+输入#25"+[返回目录]
+[内容]
pt0::
pt1::
pt2::
"(,)...
...............................................


->+的#26(+输入#25,+pt2#22)->+的#27(+输入#25,+pt1#21)->+的#28(+输入#25,+pt0#20)->+的#29(+P代码#23,+输出#24)->+的#30(+P代码#23,+输入#25)->+的#31(反射#4,+P代码#23)->+是#32(起点#14,+pt0#20)->+是#33(终点#16,+pt1#21)->+是#34(终点#18,+pt2#22)->+center#35(,)->+angle#36(,)->+的#37(+输出#24,+angle#36)->+的#38(+输出#24,+center#35)->+等于#39(+center#35,中心#7)->+等于#40(+angle#36,角度#9)
## end
#379, 861:
"""
+[返回目录](,创建距离关系)

"""

+创建距离关系#1(,距离#4)->+[del]#2(,+创建距离关系#1)...

->距离#4(,)->的#5(和#6,距离#4)->和#6(_位置1#7,_位置2#8)->_位置1#7(,)->_位置2#8(,)...




...............................................
->+P代码#10"\"\"\"
+[返回目录](,P代码)
输入:...
输出:...
+[P函数](,P代码)

\"\"\"

pt0=pt1[0]+d[0]"(,)...
...............................................


->+pt0#11(,)->+pt1#12(,)->+d#13(,)->+是#14(_位置2#8,+pt1#12)->+是#15(距离#4,+d#13)->+是#16(+pt0#11,_位置1#7)->+的#17(距离#4,+P代码#10)...


...............................................
->+输入#18"+[返回目录](,输入)
+[内容]
pt1::
d::
"(,)...
...............................................


->+的#19(+输入#18,+d#13)->+的#20(+输入#18,+pt1#12)...


...............................................
->+输出#21"+[返回目录](,输出)
+[内容]
pt0::
"(,)...
...............................................


->+的#22(+输出#21,+pt0#11)->+的#23(+P代码#10,+输入#18)->+的#24(+P代码#10,+输出#21)
## end
#385, 309:
+[返回目录](,水平中心)

词头::
词头(,水平中心)
的(条件结构,水平中心)->+[右连](词头,水平中心)

条件结构:...
结果结构:...


的(结果结构,P代码)->的(结果结构,pt)->的(结果结构,size)->的(结果结构,center)...
->的(条件结构,尺寸)->的(条件结构,起点)->的(条件结构,水平中心)...
->+是(尺寸,size)->+[有](结果结构,+是)...
->+是(起点,pt)->+[有](结果结构,+是)...
->+是(center,水平中心)->+[有](结果结构,+是)...
->+的(水平中心,P代码)->+[有](结果结构,+的)


## end
#387, 131:
+[返回目录](,条件结构)

水平中心::
矩形::


+通用(矩形,)
水平中心->的(矩形,水平中心)->矩形->的(矩形,起点)->起点->的(矩形,尺寸)->尺寸(,)...
=>[那](,_)=>+[显示](,_)->+[置顶结构](条件结构,_)
## end
#389, 138:
+[返回目录](,结果结构)

center::
size::
pt::

P代码:...
+[创建函数](,P代码)
+[创建输入](size,P代码)->+[创建输入](pt,P代码)...
->+[创建输出](center,P代码)

+[选择结构](结果结构,P代码)
## end
#411, 76:
"""
+[返回目录](,P代码)
输入:...
输出:...
+[P函数](,P代码)

"""

pt[0]=center[0]-size[0]/2
## end
#413, 23:
+[返回目录]
+[内容]
center::

## end
#415, 26:
+[返回目录]
+[内容]
size::
pt::

## end
#437, 912:
"""
+[返回目录](,创建水平中心)

"""

+创建水平中心#1(,水平中心#4)->+[del]#2(,+创建水平中心#1)...

->水平中心#4(,)->的#5(_矩形#6,水平中心#4)->_矩形#6(,)->的#7(_矩形#6,起点#8)->起点#8(,)->的#9(_矩形#6,尺寸#10)->尺寸#10(,)...

->+center#12(,)->+size#13(,)->+pt#14(,)...


...............................................
->+P代码#15"\"\"\"
+[返回目录](,P代码)
输入:...
输出:...
+[P函数](,P代码)

\"\"\"

pt[0]=center[0]-size[0]/2"(,)...
...............................................





...............................................
->+输出#16"+[返回目录]
+[内容]
center::
"(,)...
...............................................


->+的#17(+输出#16,+center#12)...


...............................................
->+输入#18"+[返回目录]
+[内容]
size::
pt::
"(,)...
...............................................


->+的#19(+输入#18,+pt#14)->+的#20(+输入#18,+size#13)->+的#21(+P代码#15,+输出#16)->+的#22(+P代码#15,+输入#18)->+是#23(尺寸#10,+size#13)->+是#24(起点#8,+pt#14)->+是#25(+center#12,水平中心#4)->+的#26(水平中心#4,+P代码#15)
## end
#445, 320:
+[返回目录](,左边界)

词头::
的(条件结构,左边界)->+[右连](词头,左边界)
词头(,左边界)

条件结构:...
结果结构:...

的(结果结构,P代码)->的(结果结构,pt)->的(结果结构,size)->的(结果结构,b)...
->的(条件结构,起点)->的(条件结构,尺寸)->的(条件结构,左边界)...
->+是(起点,pt)->+[有](结果结构,+是)...
->+是(尺寸,size)->+[有](结果结构,+是)...
->+是(b,左边界)->+[有](结果结构,+是)...
->+的(左边界,P代码)->+[有](结果结构,+的)

是([动词库],动词)->+[打开文件](+新窗口,动词)
## end
#449, 126:
+[返回目录](,条件结构)


+左边界->+的(+矩形,+左边界)->+矩形->+的(+矩形,+起点)->+起点->+的(+矩形,+尺寸)->+尺寸(,)...
=>[那](,_)=>+[显示](,_)->+[有](条件结构,_)
+通用(矩形,)
## end
#473, 128:
+[返回目录](,结果结构)

b::
size::
pt::

P代码:...
+[创建函数](,P代码)
+[创建输入](size,P代码)->+[创建输入](pt,P代码)...
->+[创建输出](b,P代码)

+[选择结构](结果结构,P代码)
## end
#481, 59:
"""
+[返回目录](,P代码)
输入:...
输出:...

+[P函数](,P代码)

"""

b=pt[0]
## end
#483, 18:
+[返回目录]
+[内容]
b::

## end
#485, 26:
+[返回目录]
+[内容]
size::
pt::

## end
#505, 867:
"""
+[返回目录](,创建左边界)

"""

+创建左边界#1(,左边界#4)->+[del]#2(,+创建左边界#1)...

->左边界#4(,)->的#5(_矩形#6,左边界#4)->_矩形#6(,)->的#7(_矩形#6,起点#8)->起点#8(,)->的#9(_矩形#6,尺寸#10)->尺寸#10(,)...

->+pt#12(,)->+size#13(,)->+b#14(,)...


...............................................
->+P代码#15"\"\"\"
+[返回目录](,P代码)
输入:...
输出:...

+[P函数](,P代码)

\"\"\"

b=pt[0]"(,)...
...............................................





...............................................
->+输出#16"+[返回目录]
+[内容]
b::
"(,)...
...............................................


->+的#17(+输出#16,+b#14)...


...............................................
->+输入#18"+[返回目录]
+[内容]
size::
pt::
"(,)...
...............................................


->+的#19(+输入#18,+pt#12)->+的#20(+输入#18,+size#13)->+的#21(+P代码#15,+输出#16)->+的#22(+P代码#15,+输入#18)->+是#23(起点#8,+pt#12)->+是#24(尺寸#10,+size#13)->+是#25(+b#14,左边界#4)->+的#26(左边界#4,+P代码#15)
## end
#519, 628:
+[返回目录](,样本)

词头::
的(条件结构,样本)->+[右连](词头,样本)
词头(,样本)

条件结构:
+左边界->+的(+矩形,+左边界)->+矩形->+的(+矩形,+起点)->+起点->+的(+矩形,+尺寸)->+尺寸(,)...
=>[那](,_)=>+[显示](,_)->+[有](条件结构,_)
+通用(矩形,)



结果结构:
b::
size::
pt::

P代码:...
+[创建函数](,P代码)
+[创建输入](size,P代码)->+[创建输入](pt,P代码)...
->+[创建输出](b,P代码)

+[选择结构](结果结构,P代码)




关联结构:
的(结果结构,P代码)->的(条件结构,在光路上)...
->+的(在光路上,P代码)->+[有](结果结构,+的)


的(结果结构,pt0)->的(结果结构,pt1)...
->的(条件结构,光线)->的(光线,起点)->的(光线,终点)...
->+是(起点,pt0)->+[有](结果结构,+是)...
->+是(终点,pt1)->+[有](结果结构,+是)


的(结果结构,center)->的(结果结构,angle)...
->的(条件结构,反射镜)->的(反射镜,中心)->的(反射镜,角度)...
->+等于(center,中心)->+[有](结果结构,+等于)...
->+等于(angle,角度)->+[有](结果结构,+等于)


## end
#521, 260:
+[返回目录](,等距)
解释::和(_距离A,_距离B)->是(和,等距)


词头::
词头(,等距)

条件结构:...
结果结构:...


的(结果结构,P代码)->的(结果结构,A)->的(结果结构,B)...
->的(条件结构,距离A)->的(条件结构,距离B)...
->+是(距离B,B)->+[有](结果结构,+是)...
->+是(A,距离A)->+[有](结果结构,+是)...
->+的(等距,P代码)->+[有](结果结构,+的)

是([动词库],动词)->+[打开文件](+新窗口,动词)
## end
#523, 21:
和(_距离A,_距离B)->是(和,等距)
## end
#525, 146:
+[返回目录](,条件结构)
和(_距离A,_距离B)->是(和,等距)

+等距->+是(+和,+等距)->+和(+距离A,+距离B)->+距离A->+距离B(,)...

=>[那](,_)=>+[显示](,_)->+[有](条件结构,_)



+通用(距离A,)->+通用(距离B,)
## end
#539, 87:


A::
B::

P代码:...
+[创建函数](,P代码)
+[创建输入](B,P代码)...
->+[创建输出](A,P代码)

+[选择结构](结果结构,P代码)

## end
#545, 1:
.
## end
#547, 18:
+[返回目录]
+[内容]
A::

## end
#549, 18:
+[返回目录]
+[内容]
B::

## end
#569, 320:
+[返回目录](,等宽)
解释::和(_矩形A,_矩形B)->是(和,等高)

词头::
词头(,等高)

条件结构:...
结果结构:...



的(结果结构,P代码)->的(结果结构,sizeA)->的(结果结构,sizeB)...
->的(条件结构,等高)->的(条件结构,矩形A)->的(矩形A,尺寸#A)...
->的(条件结构,矩形B)->的(矩形B,尺寸#B)...
->+是(尺寸#B,sizeB)->+[有](结果结构,+是)...
->+是(sizeA,尺寸#A)->+[有](结果结构,+是)...
->+的(等高,P代码)->+[有](结果结构,+的)

是([动词库],动词)->+[打开文件](+新窗口,动词)
## end
#571, 21:
和(_矩形A,_矩形B)->是(和,等高)
## end
#573, 188:

和(_矩形A,_矩形B)->是(和,等高)

+等高->+是(+和,+等高)->+和(+矩形A,+矩形B)...
->+矩形A->+的(+矩形A,+尺寸#A)->+尺寸#A(,)...
->+矩形B->+的(+矩形B,+尺寸#B)->+尺寸#B(,)...

=>[那](,_)=>+[显示](,_)->+[有](条件结构,_)



+通用(矩形A,)
+通用(矩形B,)
## end
#595, 100:
sizeA::
sizeB::

P代码:...
+[创建函数](,P代码)
+[创建输入](sizeB,P代码)...
->+[创建输出](sizeA,P代码)

+[选择结构](结果结构,P代码)
## end
#603, 22:
+[返回目录]
+[内容]
sizeA::

## end
#605, 22:
+[返回目录]
+[内容]
sizeB::

## end
#631, 539:
+[返回目录](,样本)

词头::
的(条件结构,样本)->+[右连](词头,样本)
词头(,样本)

条件结构:
+左边界->+的(+矩形,+左边界)->+矩形->+的(+矩形,+起点)->+起点->+的(+矩形,+尺寸)->+尺寸(,)...
=>[那](,_)=>+[显示](,_)->+[有](条件结构,_)
+通用(矩形,)



结果结构:
b::
size::
pt::

P代码:...
+[创建函数](,P代码)
+[创建输入](size,P代码)->+[创建输入](pt,P代码)...
->+[创建输出](b,P代码)

+[选择结构](结果结构,P代码)



的(结果结构,P代码)->的(结果结构,pt0)->的(结果结构,pt1)->的(结果结构,d)...
->的(条件结构,位置1)->的(条件结构,位置2)->的(条件结构,距离)...
->+是(位置2,pt1)->+[有](结果结构,+是)...
->+是(距离,d)->+[有](结果结构,+是)...
->+是(pt0,位置1)->+[有](结果结构,+是)...
->+的(距离,P代码)->+[有](结果结构,+的)

是([动词库],动词)->+[打开文件](+新窗口,动词)
## end
#633, 500:
+[返回目录](,反射)

词头::
的(条件结构,反射)->+[右连](词头,反射)
词头(,反射)

条件结构:...
结果结构:...


关联结构:
的(结果结构,P代码)->的(条件结构,反射)...
->+的(反射,P代码)->+[有](结果结构,+的)


的(结果结构,pt0)->的(结果结构,pt1)->的(结果结构,pt2)...
->的(条件结构,入射光线)->的(入射光线,起点)->的(入射光线,终点)...
->的(条件结构,出射光线)->的(出射光线,终点#2)...
->+是(起点,pt0)->+[有](结果结构,+是)...
->+是(终点,pt1)->+[有](结果结构,+是)...
->+是(终点#2,pt2)->+[有](结果结构,+是)


的(结果结构,center)->的(结果结构,angle)...
->的(条件结构,中心)->的(条件结构,角度)...
->+是(center,中心)->+[有](结果结构,+是)...
->+是(angle,角度)->+[有](结果结构,+是)

是([动词库],动词)->+[打开文件](+新窗口,动词)
## end
#635, 298:
+[返回目录](,条件结构)

+[删除结构](,条件结构)

+反射(+透镜,+入射光线)...
->+透镜(,)...
->+的(+透镜,+中心)->+中心->+的(+透镜,+角度)->+角度(,)...
->+入射光线(,+反射点)->+反射点->+出射光线(+反射点,)...
->+的(+入射光线,+起点)->+起点->+的(+入射光线,+终点)->+终点(,)...
->+的(+出射光线,+终点#2)->+终点#2(,)...
=>[那](,_)=>+[显示](,_)->+[有](条件结构,_)


+通用(透镜,)
+通用(入射光线,)
+通用(出射光线,)
+通用(反射点,)
## end
#641, 377:
+[返回目录](,结果结构)

center::
angle::
pt0::
pt1::
pt2::


P代码:...
+[创建函数](,P代码)
+[创建输入](pt0,P代码)->+[创建输入](pt1,P代码)->+[创建输入](pt2,P代码)
+[创建输出](center,P代码)->+[创建输出](angle,P代码)

(不要再次执行[选择结构]了)
+[选择结构](结果结构,P代码)

center->是(中心,center)->+[左连](是,center)->+[右连](是,中心)
angle->是(角度,angle)->+[左连](是,angle)->+[右连](是,角度)

center->是(center,中心)->+[修改标题]"等于"(,是)
angle->是(angle,角度)->+[修改标题]"等于"(,是)
## end
#684, 568:
"""
+[返回目录](,P代码)
输入:...
输出:...
+[P函数](,P代码)

"""

dx01=pt0[0]-pt1[0]
dy01=pt0[1]-pt1[1]
r01=np.sqrt(dx01**2+dy01**2)

dx12=pt2[0]-pt1[0]
dy12=pt2[1]-pt1[1]
r12=np.sqrt(dx12**2+dy12**2)

center=pt1

if dy01!=0:
    angle1=-np.rad2deg(np.arccos(dx01/r01)*np.sign(dy01))
else:
    if dx01<0:
        angle1=180
    else:
        angle1=0

if dy12!=0:
    angle2=-np.rad2deg(np.arccos(dx12/r12)*np.sign(dy12))
else:
    if dx12<0:
        angle2=180
    else:
        angle2=0

dangle=angle2-angle1
angle=(angle1+angle2)/2


if dangle<-180 or dangle>180:
    angle+=180


## end
#686, 31:
+[返回目录]
+[内容]
center::
angle::

## end
#688, 32:
+[返回目录]
+[内容]
pt0::
pt1::
pt2::

## end
#711, 89:
+[返回目录](,在光路上)

词头::
的(条件结构,在光路上)->+[右连](词头,在光路上)
词头(,在光路上)

条件结构:...
结果结构:...


关联结构:...
## end
#713, 222:
+[返回目录](,条件结构)

+在光路上(+反射镜,+光线)...
->+反射镜(,)...
->+的(+反射镜,+中心)->+中心->+的(+反射镜,+角度)->+角度(,)...
->+光线(,)...
->+的(+光线,+起点)->+起点->+的(+光线,+终点)->+终点(,)...

=>[那](,_)=>+[显示](,_)->+[有](条件结构,_)


+通用(反射镜,)
+通用(光线,)

+[显示结构关系](,条件结构)
## end
#739, 174:
+[返回目录](,结果结构)

center::
angle::
pt0::
pt1::

P代码:...
+[创建函数](,P代码)
+[创建输入](pt0,P代码)->+[创建输入](pt1,P代码)
+[创建输出](center,P代码)->+[创建输出](angle,P代码)

(已完成[选择结构])
+[选择结构](结果结构,P代码)

## end
#745, 230:
"""
+[返回目录](,P代码)

输入:...
输出:...

+[P函数](,P代码)

"""

center[0]=(pt0[0]+pt1[0])/2
center[1]=(pt0[1]+pt1[1])/2

dx01=pt0[0]-pt1[0]
dy01=pt0[1]-pt1[1]
r01=np.sqrt(dx01**2+dy01**2)
angle=-np.rad2deg(np.arccos(dx01/r01)*np.sign(dy01))

## end
#747, 31:
+[返回目录]
+[内容]
center::
angle::

## end
#749, 26:
+[返回目录]
+[内容]
pt0::
pt1::

## end
#775, 322:
的(结果结构,P代码)->的(条件结构,在光路上)...
->+的(在光路上,P代码)->+[有](结果结构,+的)


的(结果结构,pt0)->的(结果结构,pt1)...
->的(条件结构,光线)->的(光线,起点)->的(光线,终点)...
->+是(起点,pt0)->+[有](结果结构,+是)...
->+是(终点,pt1)->+[有](结果结构,+是)


的(结果结构,center)->的(结果结构,angle)...
->的(条件结构,反射镜)->的(反射镜,中心)->的(反射镜,角度)...
->+是(center,中心)->+[有](结果结构,+是)...
->+是(angle,角度)->+[有](结果结构,+是)

## end
#795, 1663:
"""
+[返回目录](,创建反射)

"""

+创建反射#1(,反射#4)->+[del]#2(,+创建反射#1)...

->反射#4(_透镜#5,_入射光线#10)->_透镜#5(,)->的#6(_透镜#5,中心#7)->中心#7(,)->的#8(_透镜#5,角度#9)->角度#9(,)->_入射光线#10(,_反射点#11)->_反射点#11(,)->_出射光线#12(_反射点#11,)->的#13(_入射光线#10,起点#14)->起点#14(,)->的#15(_入射光线#10,终点#16)->终点#16(,)->的#17(_出射光线#12,终点#18)->终点#18(,)...

->+pt0#20(,)->+pt1#21(,)->+pt2#22(,)...


...............................................
->+P代码#23"\"\"\"
+[返回目录](,P代码)
输入:...
输出:...
+[P函数](,P代码)

\"\"\"

dx01=pt0[0]-pt1[0]
dy01=pt0[1]-pt1[1]
r01=np.sqrt(dx01**2+dy01**2)

dx12=pt2[0]-pt1[0]
dy12=pt2[1]-pt1[1]
r12=np.sqrt(dx12**2+dy12**2)

center=pt1

if dy01!=0:
    angle1=-np.rad2deg(np.arccos(dx01/r01)*np.sign(dy01))
else:
    if dx01<0:
        angle1=180
    else:
        angle1=0

if dy12!=0:
    angle2=-np.rad2deg(np.arccos(dx12/r12)*np.sign(dy12))
else:
    if dx12<0:
        angle2=180
    else:
        angle2=0

dangle=angle2-angle1
angle=(angle1+angle2)/2


if dangle<-180 or dangle>180:
    angle+=180

"(,)...
...............................................





...............................................
->+输出#24"+[返回目录]
+[内容]
center::
angle::
"(,)...
...............................................





...............................................
->+输入#25"+[返回目录]
+[内容]
pt0::
pt1::
pt2::
"(,)...
...............................................


->+的#26(+输入#25,+pt2#22)->+的#27(+输入#25,+pt1#21)->+的#28(+输入#25,+pt0#20)->+的#29(+P代码#23,+输出#24)->+的#30(+P代码#23,+输入#25)->+的#31(反射#4,+P代码#23)->+是#32(起点#14,+pt0#20)->+是#33(终点#16,+pt1#21)->+是#34(终点#18,+pt2#22)->+center#35(,)->+angle#36(,)->+的#37(+输出#24,+angle#36)->+的#38(+输出#24,+center#35)->+等于#39(+center#35,中心#7)->+等于#40(+angle#36,角度#9)
## end
#797, 1123:
"""
+[返回目录](,创建在光路上)

"""

+创建在光路上#1(,在光路上#4)->+[del]#2(,+创建在光路上#1)...

->在光路上#4(_反射镜#5,_光线#10)->_反射镜#5(,)->的#6(_反射镜#5,中心#7)->中心#7(,)->的#8(_反射镜#5,角度#9)->角度#9(,)->_光线#10(,)->的#11(_光线#10,起点#12)->起点#12(,)->的#13(_光线#10,终点#14)->终点#14(,)...

->+pt0#16(,)->+pt1#17(,)...


...............................................
->+P代码#18"\"\"\"
+[返回目录](,P代码)

输入:...
输出:...

+[P函数](,P代码)

\"\"\"

center[0]=(pt0[0]+pt1[0])/2
center[1]=(pt0[1]+pt1[1])/2

dx01=pt0[0]-pt1[0]
dy01=pt0[1]-pt1[1]
r01=np.sqrt(dx01**2+dy01**2)
angle=-np.rad2deg(np.arccos(dx01/r01)*np.sign(dy01))
"(,)...
...............................................





...............................................
->+输出#19"+[返回目录]
+[内容]
center::
angle::
"(,)...
...............................................





...............................................
->+输入#20"+[返回目录]
+[内容]
pt0::
pt1::
"(,)...
...............................................


->+的#21(+输入#20,+pt1#17)->+的#22(+输入#20,+pt0#16)->+的#23(+P代码#18,+输出#19)->+的#24(+P代码#18,+输入#20)->+center#25(,)->+angle#26(,)->+是#27(起点#12,+pt0#16)->+是#28(终点#14,+pt1#17)->+是#29(+center#25,中心#7)->+是#30(+angle#26,角度#9)
## end
#819, 48:
+[返回目录](,沿着)

词头::

条件结构:...
结果结构:...

关联结构:...

## end
#821, 166:
+[返回目录](,条件结构)

+沿着(+光线,+方向)->+方向(,)...
->+光线->+的(+光线,+起点)->+起点(,)...
->+的(+光线,+终点)->+终点(,)...
=>[那](,_)=>+[显示](,_)->+[有](条件结构,_)

+通用(光线,)
+通用(方向,)

+[显示结构关系](,条件结构)
## end
#839, 251:
+[返回目录](,结果结构)

pt0::
angle::
pt1::

P代码:...
+[创建函数](,P代码)
+[创建输入](pt0,P代码)->+[创建输入](angle,P代码)...
->+[创建输出](pt1,P代码)

+[选择结构](结果结构,P代码)

+[设置结构](,结果结构)

是(angle,方向)->+[左连](是,方向)->+[右连](是,angle)

是(终点,pt1)->终点->+[显示](,是)...
->+[左连](是,pt1)->+[右连](是,终点)
## end
#847, 201:
"""
+[返回目录](,P代码)
+[P函数](,P代码)
输入:...
输出:...

"""

theta=np.deg2rad(angle[0])
dr=[pt1[0]-pt0[0],pt1[1]-pt0[1]]
r=np.sqrt(dr[0]**2+dr[1]**2)

pt1[0]=pt0[0]+r*np.cos(theta)
pt1[1]=pt0[1]-r*np.sin(theta)

## end
#849, 20:
+[返回目录]
+[内容]
pt1::

## end
#851, 28:
+[返回目录]
+[内容]
pt0::
angle::

## end
#873, 241:
的(结果结构,P代码)->的(条件结构,沿着)...
->+的(沿着,P代码)->+[有](结果结构,+的)


的(结果结构,pt0)->的(结果结构,pt1)...
->的(条件结构,光线)->的(光线,起点)->的(光线,终点)...
->+是(起点,pt0)->+[有](结果结构,+是)...
->+是(pt1,终点)->+[有](结果结构,+是)


的(结果结构,angle)->的(条件结构,方向)...
->+是(方向,angle)->+[有](结果结构,+是)

## end
#877, 1022:
"""
+[返回目录](,创建沿着)

"""

+创建沿着#1(,沿着#4)->+[del]#2(,+创建沿着#1)...

->沿着#4(_光线#6,_方向#5)->_方向#5(,)->_光线#6(,)->的#7(_光线#6,起点#8)->起点#8(,)->的#9(_光线#6,终点#10)->终点#10(,)...

->+pt0#12(,)->+pt1#13(,)->+angle#14(,)...


...............................................
->+P代码#15"\"\"\"
+[返回目录](,P代码)
+[P函数](,P代码)
输入:...
输出:...

\"\"\"

theta=np.deg2rad(angle[0])
dr=[pt1[0]-pt0[0],pt1[1]-pt0[1]]
r=np.sqrt(dr[0]**2+dr[1]**2)

pt1[0]=pt0[0]+r*np.cos(theta)
pt1[1]=pt0[1]-r*np.sin(theta)
"(,)...
...............................................





...............................................
->+输出#16"+[返回目录]
+[内容]
pt1::
"(,)...
...............................................


->+的#17(+输出#16,+pt1#13)...


...............................................
->+输入#18"+[返回目录]
+[内容]
pt0::
angle::
"(,)...
...............................................


->+的#19(+输入#18,+angle#14)->+的#20(+输入#18,+pt0#12)->+的#21(+P代码#15,+输出#16)->+的#22(+P代码#15,+输入#18)->+的#23(沿着#4,+P代码#15)->+是#24(起点#8,+pt0#12)->+等于#25(+pt1#13,终点#10)->+是#26(_方向#5,+angle#14)
## end
#881, 393:
+[返回目录](,网格)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10

可选::YES

面颜色::None
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

+[生成类函数](画图,+[显示])->+[显示]
的(画图,输入)->的(输入,_变量)->+[显示](,_变量)

动词:...
动作:...
+[删除结构](,动词)->+[del](,动词)
+[删除结构](,动作)->+[del](,动作)
的(选中区域,输入)->+[del](,输入)
的(画图,输入)->+[有](选中区域,输入)
+[创建输入](起点,画图)
+[创建输入](尺寸,画图)
+[创建输入](可选,画图)

的(选中区域,输入)->+[设置结构](,输入)
+[设置结构](,网格)
## end
#882, 2:
里面
## end
#883, 2:
里面
## end
#884, 2:
里面
## end
#885, 2:
里面
## end
#886, 2:
里面
## end
#888, 2:
镜子
## end
#903, 945:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]
d=50

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
x0=pt[0]//d*d
y0=pt[1]//d*d
x1=(pt[0]+size[0])
y1=(pt[1]+size[1])

if x0<x1:
    X=np.arange(x0+d,x1,d)
else:
    X=np.arange(x1+d,x0,d)

if y0<y1:
    Y=np.arange(y0+d,y1,d)
else:
    Y=np.arange(y1+d,y0,d)

for x in X:
    qp.drawLine(x,pt[1],x,pt[1]+size[1])
    qp.drawText(x,pt[1],d,d,Qt.AlignLeft|Qt.AlignTop,"%d"%(x))

for y in Y:
    qp.drawLine(pt[0],y,pt[0]+size[0],y)
    qp.drawText(pt[0],y,d,d,Qt.AlignLeft|Qt.AlignTop,"%d"%(y))


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#910, 109:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
起点::-200,100
尺寸::100,100
可选::YES

## end
#912, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#913, 945:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]
d=50

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
x0=pt[0]//d*d
y0=pt[1]//d*d
x1=(pt[0]+size[0])
y1=(pt[1]+size[1])

if x0<x1:
    X=np.arange(x0+d,x1,d)
else:
    X=np.arange(x1+d,x0,d)

if y0<y1:
    Y=np.arange(y0+d,y1,d)
else:
    Y=np.arange(y1+d,y0,d)

for x in X:
    qp.drawLine(x,pt[1],x,pt[1]+size[1])
    qp.drawText(x,pt[1],d,d,Qt.AlignLeft|Qt.AlignTop,"%d"%(x))

for y in Y:
    qp.drawLine(pt[0],y,pt[0]+size[0],y)
    qp.drawText(pt[0],y,d,d,Qt.AlignLeft|Qt.AlignTop,"%d"%(y))


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#914, 2:
矩形
## end
#916, 248:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False

if 可选=="NO":
    state=False


## end
#917, 14:
+[返回目录]
+[内容]

## end
#918, 4:
None
## end
#919, 5:
0,0,0
## end
#920, 8:
DashLine
## end
#921, 1:
1
## end
#922, 2:
10
## end
#924, 2:
里面
## end
#925, 3:
右下角
## end
#926, 3:
右下角
## end
#927, 2:
里面
## end
#928, 2:
下面
## end
#929, 2:
右面
## end
#930, 3:
右上角
## end
#931, 2:
里面
## end
#932, 2:
上面
## end
#933, 2:
左面
## end
#934, 2:
里面
## end
#935, 2:
里面
## end
#936, 3:
右上角
## end
#937, 2:
里面
## end
#939, 7721:
"""
+[返回目录](,创建网格)

"""


+创建网格#0(,_网格#51)->+[del]#1(,+创建网格#0)...


...............................................
->+[临时文本]#2"+[返回目录](,网格)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10

可选::YES

面颜色::None
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

+[生成类函数](画图,+[显示])->+[显示]
的(画图,输入)->的(输入,_变量)->+[显示](,_变量)

动词:...
动作:...
+[删除结构](,动词)->+[del](,动词)
+[删除结构](,动作)->+[del](,动作)
的(选中区域,输入)->+[del](,输入)
的(画图,输入)->+[有](选中区域,输入)
+[创建输入](起点,画图)
+[创建输入](尺寸,画图)
+[创建输入](可选,画图)

的(选中区域,输入)->+[设置结构](,输入)
+[设置结构](,网格)"(,)...
...............................................


->+[修改内容]#3(+[临时文本]#2,_网格#51)...


...............................................
->+尺寸#4"592.3788000000002, 197.0718"(,)...
...............................................





...............................................
->+起点#5"-360.6098000000001, -12.153999999999968"(,)...
...............................................


->+可选#6"YES"(,)->+字体#7"10"(,)->+文字#8(,)->+线粗细#9"1"(,)...


...............................................
->+线型#10"DashLine"(,)...
...............................................





...............................................
->+线颜色#11"0,0,0"(,)...
...............................................


->+面颜色#12"None"(,)->+的#13(+输入#22,+可选#6)->+的#14(+输入#22,+尺寸#4)->+的#15(+输入#22,+起点#5)->+的#16(+输入#22,+字体#7)->+的#17(+输入#22,+文字#8)->+的#18(+输入#22,+线粗细#9)->+的#19(+输入#22,+线型#10)->+的#20(+输入#22,+线颜色#11)->+的#21(+输入#22,+面颜色#12)...


...............................................
->+输入#22"+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
起点::-200,100
尺寸::100,100
可选::YES
"(,)...
...............................................


->+的#23(+HTML#24,+输入#22)...


...............................................
->+HTML#24"/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var d=50;
var size=[%尺寸];
var pt=[%起点];
var size_F=%字体;

var lineWidth=%线粗细;

var X=[];
var Y=[];
var x0,x1,y0,y1;

if (size[0]>0) {
    x0=pt[0];
    x1=pt[0]+size[0];
}
else {
    x1=pt[0];
    x0=pt[0]+size[0];
}


if (size[1]>0) {
    y0=pt[1];
    y1=pt[1]+size[1];
}
else {
    y1=pt[1];
    y0=pt[1]+size[1];
}

xs=x0-x0%d;
xe=x1-x1%d;
ys=y0-y0%d;
ye=y1-y1%d;

if (xs<x0) {
    xs+=d
}
if (xe>x1) {
    xe-=d
}
if (ys<y0) {
    ys+=d
}
if (ye>y1) {
    ye-=d
}

//window.alert([x0,x1])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.beginPath();

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}


ctx.fillStyle='rgba(0,0,0,1)';
ctx.font=%字体*1.5+'px serif'


ctx.textAlign='center'
ctx.textBaseline='bottom'
for (let x=xs; x<=xe; x+=d) {
    ctx.moveTo(x,y0);
    ctx.lineTo(x,y1);
    ctx.fillText(x,x,y0);
}

ctx.textAlign='right'
ctx.textBaseline='middle'
for (let y=ys; y<=ye; y+=d) {
    ctx.moveTo(x0,y);
    ctx.lineTo(x1,y);
    ctx.fillText(y,x0,y);
}
ctx.stroke()



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/"(,)...
...............................................





...............................................
->+输出#25"+[返回目录]
+[内容]
"(,)...
...............................................


->+的#26(+选中区域#28,+输入#22)->+的#27(+选中区域#28,+输出#25)...


...............................................
->+选中区域#28"\"\"\"
+[返回目录](,选中区域)
输入:...

\"\"\"

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False

if 可选==\"NO\":
    state=False

"(,)...
...............................................


->+类型#29"矩形"(,)...


...............................................
->+图形#30"\"\"\"
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

\"\"\"


pt=起点
size=尺寸
size_F=字体[0]
d=50

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
x0=pt[0]//d*d
y0=pt[1]//d*d
x1=(pt[0]+size[0])
y1=(pt[1]+size[1])

if x0<x1:
    X=np.arange(x0+d,x1,d)
else:
    X=np.arange(x1+d,x0,d)

if y0<y1:
    Y=np.arange(y0+d,y1,d)
else:
    Y=np.arange(y1+d,y0,d)

for x in X:
    qp.drawLine(x,pt[1],x,pt[1]+size[1])
    qp.drawText(x,pt[1],d,d,Qt.AlignLeft|Qt.AlignTop,\"%d\"%(x))

for y in Y:
    qp.drawLine(pt[0],y,pt[0]+size[0],y)
    qp.drawText(pt[0],y,d,d,Qt.AlignLeft|Qt.AlignTop,\"%d\"%(y))


qp.setBrush(QBrush())
qp.setPen(QPen())

"(,)...
...............................................





...............................................
->+选中框#31"\"\"\"
+[返回目录](,选中框)

\"\"\"


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
"(,)...
...............................................


->+输出#32(,)->+的#33(+画图#37,+图形#30)->+的#34(+画图#37,+选中框#31)->+的#35(+画图#37,+输出#32)->+的#36(+画图#37,+输入#22)...


...............................................
->+画图#37"\"\"\"
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

\"\"\"


pt=起点
size=尺寸
size_F=字体[0]
d=50

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
x0=pt[0]//d*d
y0=pt[1]//d*d
x1=(pt[0]+size[0])
y1=(pt[1]+size[1])

if x0<x1:
    X=np.arange(x0+d,x1,d)
else:
    X=np.arange(x1+d,x0,d)

if y0<y1:
    Y=np.arange(y0+d,y1,d)
else:
    Y=np.arange(y1+d,y0,d)

for x in X:
    qp.drawLine(x,pt[1],x,pt[1]+size[1])
    qp.drawText(x,pt[1],d,d,Qt.AlignLeft|Qt.AlignTop,\"%d\"%(x))

for y in Y:
    qp.drawLine(pt[0],y,pt[0]+size[0],y)
    qp.drawText(pt[0],y,d,d,Qt.AlignLeft|Qt.AlignTop,\"%d\"%(y))


qp.setBrush(QBrush())
qp.setPen(QPen())

\"\"\"
+[返回目录](,选中框)

\"\"\"


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
"(,)...
...............................................


->+的#38(_网格#51,+尺寸#4)->+的#39(_网格#51,+起点#5)->+的#40(_网格#51,+HTML#24)->+的#41(_网格#51,+可选#6)->+的#42(_网格#51,+文字#8)->+的#43(_网格#51,+字体#7)->+的#44(_网格#51,+线粗细#9)->+的#45(_网格#51,+线型#10)->+的#46(_网格#51,+线颜色#11)->+的#47(_网格#51,+面颜色#12)->+的#48(_网格#51,+选中区域#28)->+的#49(_网格#51,+类型#29)->+的#50(_网格#51,+画图#37)->_网格#51(,)
## end
#941, 123:
+[返回目录](,坐标点)

中心::200,100
半径::100
类型::圆形
角度::0


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...


## end
#956, 611:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
R=5
r=半径[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))

x0=pt[0]
y0=pt[1]
dx=np.cos(theta)*r
dy=-np.sin(theta)*r
qp.drawEllipse(x0-R,y0-R,2*R,2*R)
qp.drawText(x0+dx,y0+dy,"(%.2f,%.2f)"%(x0,y0))

qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#964, 66:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#966, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#967, 611:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
R=5
r=半径[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))

x0=pt[0]
y0=pt[1]
dx=np.cos(theta)*r
dy=-np.sin(theta)*r
qp.drawEllipse(x0-R,y0-R,2*R,2*R)
qp.drawText(x0+dx,y0+dy,"(%.2f,%.2f)"%(x0,y0))

qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#968, 2:
圆形
## end
#969, 17:
86.63353933657021
## end
#972, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#973, 14:
+[返回目录]
+[内容]

## end
#976, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#977, 39:
-358.70450000000017, -96.63060000000004
## end
#978, 2:
15
## end
#979, 11:
255,255,255
## end
#980, 5:
0,0,0
## end
#981, 8:
DashLine
## end
#982, 1:
2
## end
#983, 2:
里面
## end
#984, 2:
里面
## end
#985, 3:
半径点
## end
#986, 2:
里面
## end
#987, 2:
里面
## end
#988, 3:
角度点
## end
#989, 3:
角度点
## end
#990, 3:
半径点
## end
#991, 3:
角度点
## end
#992, 3:
半径点
## end
#993, 3:
角度点
## end
#994, 2:
里面
## end
#996, 5431:
"""
+[返回目录](,创建坐标点)

"""


+创建坐标点#0(,_坐标点#48)->+[del]#1(,+创建坐标点#0)...


...............................................
->+[临时文本]#2"+[返回目录](,坐标点)

中心::200,100
半径::100
类型::圆形
角度::0


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

"(,)...
...............................................


->+[修改内容]#3(+[临时文本]#2,_坐标点#48)->+线粗细#4"2"(,)...


...............................................
->+线型#5"DashLine"(,)...
...............................................





...............................................
->+线颜色#6"0,0,0"(,)...
...............................................





...............................................
->+面颜色#7"255,255,255"(,)...
...............................................





...............................................
->+角度#8"86.63353933657021"(,)...
...............................................


->+半径#9"15"(,)...


...............................................
->+中心#10"-358.70450000000017, -96.63060000000004"(,)...
...............................................


->+的#11(+输入#18,+线粗细#4)->+的#12(+输入#18,+线型#5)->+的#13(+输入#18,+线颜色#6)->+的#14(+输入#18,+面颜色#7)->+的#15(+输入#18,+角度#8)->+的#16(+输入#18,+半径#9)->+的#17(+输入#18,+中心#10)...


...............................................
->+输入#18"+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
"(,)...
...............................................


->+的#19(+HTML#20,+输入#18)...


...............................................
->+HTML#20"/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var pt=[%中心];
var R=5;
var r=%半径;
var angle=%角度;
var theta=angle/180*Math.PI;

var lineWidth=%线粗细;

var x0=pt[0]
var y0=pt[1]
var dx=Math.cos(theta)*r
var dy=-Math.sin(theta)*r


ctx.beginPath();
ctx.arc(%中心,5,0,2*Math.PI)

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fill();
}

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(0,0,0)';
} else {
        ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.stroke();
}

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='left'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText(`(${x0.toFixed(2)},${y0.toFixed(2)})`,x0+dx,y0+dy)

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/"(,)...
...............................................


->+的#21(+输入#23,+半径#9)->+的#22(+输入#23,+中心#10)...


...............................................
->+输入#23"+[返回目录](,输入)
+[内容]
中心::200,100
半径::100
"(,)...
...............................................





...............................................
->+输出#24"+[返回目录]
+[内容]
"(,)...
...............................................


->+的#25(+选中区域#27,+输入#23)->+的#26(+选中区域#27,+输出#24)...


...............................................
->+选中区域#27"\"\"\"
+[返回目录](,选中区域)
输入:...

\"\"\"

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False"(,)...
...............................................


->+类型#28"圆形"(,)...


...............................................
->+图形#29"\"\"\"
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

\"\"\"
pt=中心
R=5
r=半径[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))

x0=pt[0]
y0=pt[1]
dx=np.cos(theta)*r
dy=-np.sin(theta)*r
qp.drawEllipse(x0-R,y0-R,2*R,2*R)
qp.drawText(x0+dx,y0+dy,\"(%.2f,%.2f)\"%(x0,y0))

qp.setBrush(QBrush())
qp.setPen(QPen())

"(,)...
...............................................





...............................................
->+选中框#30"\"\"\"
+[返回目录](,选中框)

\"\"\"

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))


"(,)...
...............................................


->+输出#31(,)->+的#32(+画图#36,+图形#29)->+的#33(+画图#36,+选中框#30)->+的#34(+画图#36,+输出#31)->+的#35(+画图#36,+输入#18)...


...............................................
->+画图#36"\"\"\"
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

\"\"\"
pt=中心
R=5
r=半径[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))

x0=pt[0]
y0=pt[1]
dx=np.cos(theta)*r
dy=-np.sin(theta)*r
qp.drawEllipse(x0-R,y0-R,2*R,2*R)
qp.drawText(x0+dx,y0+dy,\"(%.2f,%.2f)\"%(x0,y0))

qp.setBrush(QBrush())
qp.setPen(QPen())

"(,)...
...............................................


->+的#37(_坐标点#48,+HTML#20)->+的#38(_坐标点#48,+线粗细#4)->+的#39(_坐标点#48,+线型#5)->+的#40(_坐标点#48,+线颜色#6)->+的#41(_坐标点#48,+面颜色#7)->+的#42(_坐标点#48,+选中区域#27)->+的#43(_坐标点#48,+角度#8)->+的#44(_坐标点#48,+类型#28)->+的#45(_坐标点#48,+画图#36)->+的#46(_坐标点#48,+半径#9)->+的#47(_坐标点#48,+中心#10)->_坐标点#48(,)
## end
#997, 2:
里面
## end
#998, 37:
+[粘贴](,测试)
+[删除结构](,测试)

+[设置结构](,测试)
## end
#999, 2:
20
## end
#1000, 4:
test
## end
#1001, 1:
2
## end
#1002, 8:
DashLine
## end
#1003, 5:
0,0,0
## end
#1004, 11:
255,255,255
## end
#1005, 3:
100
## end
#1006, 38:
358.70450000000017, -221.0791000000001
## end
#1009, 46:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100
可选::NO

## end
#1010, 14:
+[返回目录]
+[内容]

## end
#1013, 196:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False

if 可选=="NO":
    state=False


## end
#1014, 3:
0.0
## end
#1015, 2:
圆形
## end
#1016, 789:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


x0=pt[0]
y0=pt[1]
M=qp.transform()
M.translate(x0,y0)
M.rotate(-angle+90)
M.translate(-x0,-y0)

M0=qp.transform()
qp.setTransform(M)
qp.setFont(QFont("Decorative",字体[0]))

qp.drawRect(x0-r,y0-d/2,2*r,d)
qp.drawText(x0-r,y0-d/2,2*r,d,Qt.AlignHCenter|Qt.AlignVCenter,文字)


qp.setFont(QFont())
qp.setTransform(M0)
qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#1017, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#1019, 2:
80
## end
#1030, 89:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
文字::test
字体::20

## end
#1035, 789:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


x0=pt[0]
y0=pt[1]
M=qp.transform()
M.translate(x0,y0)
M.rotate(-angle+90)
M.translate(-x0,-y0)

M0=qp.transform()
qp.setTransform(M)
qp.setFont(QFont("Decorative",字体[0]))

qp.drawRect(x0-r,y0-d/2,2*r,d)
qp.drawText(x0-r,y0-d/2,2*r,d,Qt.AlignHCenter|Qt.AlignVCenter,文字)


qp.setFont(QFont())
qp.setTransform(M0)
qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#1049, 155:
+[返回目录](,光路模块)

中心::200,100
半径::100
厚度::80
类型::圆形
角度::0
文字::test
字体::20

可选::YES

面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...


## end
#1052, 6009:
"""
+[返回目录](,创建光路模块)

"""


+创建光路模块#0(,_光路模块#60)->+[del]#1(,+创建光路模块#0)...


...............................................
->+[临时文本]#2"+[返回目录](,光路模块)

中心::200,100
半径::100
厚度::80
类型::圆形
角度::0
文字::test
字体::20

可选::YES

面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

"(,)...
...............................................


->+[修改内容]#3(+[临时文本]#2,_光路模块#60)->+厚度#4"80"(,)...


...............................................
->+中心#5"358.70450000000017, -221.0791000000001"(,)...
...............................................


->+半径#6"100"(,)->+角度#7"0.0"(,)...


...............................................
->+面颜色#8"255,255,255"(,)...
...............................................





...............................................
->+线颜色#9"0,0,0"(,)...
...............................................





...............................................
->+线型#10"DashLine"(,)...
...............................................


->+线粗细#11"2"(,)->+文字#12"test"(,)->+字体#13"20"(,)->+的#14(+输入#24,+厚度#4)->+的#15(+输入#24,+中心#5)->+的#16(+输入#24,+半径#6)->+的#17(+输入#24,+角度#7)->+的#18(+输入#24,+面颜色#8)->+的#19(+输入#24,+线颜色#9)->+的#20(+输入#24,+线型#10)->+的#21(+输入#24,+线粗细#11)->+的#22(+输入#24,+文字#12)->+的#23(+输入#24,+字体#13)...


...............................................
->+输入#24"+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
文字::test
字体::20
"(,)...
...............................................


->+的#25(+HTML#26,+输入#24)...


...............................................
->+HTML#26"/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;

x0=pt[0];
y0=pt[1];

ctx.save()
ctx.translate(x0,y0)
ctx.rotate(-theta+90/180*Math.PI)
ctx.translate(-x0,-y0)

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0-d/2,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0-d/2,2*r,d);
}


ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',x0,y0);


ctx.restore()




/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/"(,)...
...............................................


->+可选#27"YES"(,)->+输出#28(,)...


...............................................
->+选中框#29"\"\"\"
+[返回目录](,选中框)

\"\"\"

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))


"(,)...
...............................................





...............................................
->+图形#30"\"\"\"
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

\"\"\"
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


x0=pt[0]
y0=pt[1]
M=qp.transform()
M.translate(x0,y0)
M.rotate(-angle+90)
M.translate(-x0,-y0)

M0=qp.transform()
qp.setTransform(M)
qp.setFont(QFont(\"Decorative\",字体[0]))

qp.drawRect(x0-r,y0-d/2,2*r,d)
qp.drawText(x0-r,y0-d/2,2*r,d,Qt.AlignHCenter|Qt.AlignVCenter,文字)


qp.setFont(QFont())
qp.setTransform(M0)
qp.setBrush(QBrush())
qp.setPen(QPen())


"(,)...
...............................................


->+的#31(+画图#35,+输入#24)->+的#32(+画图#35,+输出#28)->+的#33(+画图#35,+选中框#29)->+的#34(+画图#35,+图形#30)...


...............................................
->+画图#35"\"\"\"
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

\"\"\"
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


x0=pt[0]
y0=pt[1]
M=qp.transform()
M.translate(x0,y0)
M.rotate(-angle+90)
M.translate(-x0,-y0)

M0=qp.transform()
qp.setTransform(M)
qp.setFont(QFont(\"Decorative\",字体[0]))

qp.drawRect(x0-r,y0-d/2,2*r,d)
qp.drawText(x0-r,y0-d/2,2*r,d,Qt.AlignHCenter|Qt.AlignVCenter,文字)


qp.setFont(QFont())
qp.setTransform(M0)
qp.setBrush(QBrush())
qp.setPen(QPen())


"(,)...
...............................................


->+类型#36"圆形"(,)...


...............................................
->+输出#37"+[返回目录]
+[内容]
"(,)...
...............................................


->+的#38(+输入#41,+可选#27)->+的#39(+输入#41,+中心#5)->+的#40(+输入#41,+半径#6)...


...............................................
->+输入#41"+[返回目录](,输入)
+[内容]
中心::200,100
半径::100
可选::NO
"(,)...
...............................................


->+的#42(+选中区域#44,+输出#37)->+的#43(+选中区域#44,+输入#41)...


...............................................
->+选中区域#44"\"\"\"
+[返回目录](,选中区域)
输入:...

\"\"\"

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False

if 可选==\"NO\":
    state=False

"(,)...
...............................................


->+的#45(_光路模块#60,+HTML#26)->+的#46(_光路模块#60,+可选#27)->+的#47(_光路模块#60,+厚度#4)->+的#48(_光路模块#60,+中心#5)->+的#49(_光路模块#60,+半径#6)->+的#50(_光路模块#60,+画图#35)->+的#51(_光路模块#60,+类型#36)->+的#52(_光路模块#60,+角度#7)->+的#53(_光路模块#60,+选中区域#44)->+的#54(_光路模块#60,+面颜色#8)->+的#55(_光路模块#60,+线颜色#9)->+的#56(_光路模块#60,+线型#10)->+的#57(_光路模块#60,+线粗细#11)->+的#58(_光路模块#60,+文字#12)->+的#59(_光路模块#60,+字体#13)->_光路模块#60(,)
## end
#1054, 3:
YES
## end
#1056, 3:
YES
## end
#1063, 83:
+[返回目录](,方向)

词头::
的(条件结构,方向)->+[右连](词头,方向)
词头(,方向)

条件结构:...
结果结构:...




关联结构:...
## end
#1065, 145:
+[返回目录](,条件结构)

+[左连](方向,光线)->的(光线,方向)->+[del](,的)

+方向(+光线,)->+光线->+的(+光线,+起点)->+起点->+的(+光线,+终点)...
=>[那](,_)=>+[显示](,_)->+[有](条件结构,_)
+通用(光线,)

## end
#1082, 136:
+[返回目录](,结果结构)

angle::
pt0::
pt1::

P代码:...
+[创建函数](,P代码)
+[创建输入](pt0,P代码)->+[创建输入](pt1,P代码)...
->+[创建输出](angle,P代码)

+[选择结构](结果结构,P代码)
## end
#1090, 230:
"""
+[返回目录](,P代码)
+[P函数](,P代码)

"""


dx=pt1[0]-pt0[0]
dy=pt1[1]-pt0[1]
dr=np.sqrt(dx**2+dy**2)

if dr==0:
    theta=0
elif dy==0:
    theta=np.arccos(dx/dr)
else:
    theta=-np.arccos(dx/dr)*np.sign(dy)

angle=np.rad2deg(theta)


## end
#1092, 22:
+[返回目录]
+[内容]
angle::

## end
#1094, 26:
+[返回目录]
+[内容]
pt0::
pt1::

## end
#1114, 243:
的(结果结构,P代码)->的(条件结构,方向)...
->+的(方向,P代码)->+[有](结果结构,+的)


的(结果结构,pt0)->的(结果结构,pt1)...
->的(条件结构,光线)->的(光线,起点)->的(光线,终点)...
->+是(起点,pt0)->+[有](结果结构,+是)...
->+是(终点,pt1)->+[有](结果结构,+是)


的(结果结构,angle)->的(条件结构,方向)...
->+等于(angle,方向)->+[有](结果结构,+等于)

## end
#1120, 1035:
"""
+[返回目录](,创建方向)

"""

+创建方向#1(,方向#4)->+[del]#2(,+创建方向#1)...

->方向#4(_光线#5,)->_光线#5(,)->的#6(_光线#5,起点#7)->起点#7(,)->的#8(_光线#5,终点#9)->终点#9(,)...

->+angle#11(,)->+pt0#12(,)->+pt1#13(,)...


...............................................
->+P代码#14"\"\"\"
+[返回目录](,P代码)
+[P函数](,P代码)

\"\"\"


dx=pt1[0]-pt0[0]
dy=pt1[1]-pt0[1]
dr=np.sqrt(dx**2+dy**2)

if dr==0:
    theta=0
elif dy==0:
    theta=np.arccos(dx/dr)
else:
    theta=-np.arccos(dx/dr)*np.sign(dy)

angle=np.rad2deg(theta)

"(,)...
...............................................


->+的#15(+输出#16,+angle#11)...


...............................................
->+输出#16"+[返回目录]
+[内容]
angle::
"(,)...
...............................................


->+的#17(+输入#19,+pt1#13)->+的#18(+输入#19,+pt0#12)...


...............................................
->+输入#19"+[返回目录]
+[内容]
pt0::
pt1::
"(,)...
...............................................


->+的#20(+P代码#14,+输出#16)->+的#21(+P代码#14,+输入#19)->+的#22(方向#4,+P代码#14)->+是#23(起点#7,+pt0#12)->+是#24(终点#9,+pt1#13)->+等于#25(+angle#11,方向#4)
## end
#1132, 331:
+[返回目录](,经过)

词头::
的(条件结构,经过)->+[右连](词头,经过)
词头(,经过)

条件结构:...
结果结构:...


关联结构:
的(结果结构,P代码)->的(条件结构,经过)...
->+的(经过,P代码)->+[有](结果结构,+的)


的(结果结构,pt)->的(结果结构,pt0)...
->的(条件结构,点)->的(条件结构,光线)->的(光线,起点)...
->+是(点,pt)->+[有](结果结构,+是)...
->+是(起点,pt0)->+[有](结果结构,+是)


的(结果结构,pt1)...
->的(条件结构,光线)->的(光线,终点)...
->+等于(pt1,终点)->+[有](结果结构,+等于)


## end
#1134, 150:

+[设置结构](,条件结构)

+经过(+光线,+点)->+点->+光线->+的(+光线,+起点)->+起点->+的(+光线,+终点)->+终点(,)...
=>[那](,_)=>+[显示](,_)->+[有](条件结构,_)
+通用(光线,)
+通用(点,)


+[显示结构关系](,条件结构)
## end
#1160, 132:
+[返回目录](,结果结构)

pt::
pt0::
pt1::

P代码:...
+[创建函数](,P代码)
+[创建输入](pt,P代码)->+[创建输入](pt0,P代码)...
->+[创建输出](pt1,P代码)

+[选择结构](结果结构,P代码)


## end
#1168, 337:
"""
+[返回目录](,P代码)
+[P函数](,P代码)

输入:...
输出:...

"""

dx=pt[0]-pt0[0]
dy=pt[1]-pt0[1]
dr=np.sqrt(dx**2+dy**2)

Dx=pt1[0]-pt0[0]
Dy=pt1[1]-pt0[1]
L=np.sqrt(Dx**2+Dy**2)


if dr==0:
    theta=0
elif dy==0:
    theta=np.arccos(dx/dr)
else:
    theta=-np.arccos(dx/dr)*np.sign(dy)

pt1[0]=pt0[0]+L*np.cos(theta)
pt1[1]=pt0[1]-L*np.sin(theta)


## end
#1170, 20:
+[返回目录]
+[内容]
pt1::

## end
#1172, 25:
+[返回目录]
+[内容]
pt::
pt0::

## end
#1198, 1146:
"""
+[返回目录](,创建经过)

"""

+创建经过#1(,经过#4)->+[del]#2(,+创建经过#1)...

->经过#4(_光线#6,_点#5)->_点#5(,)->_光线#6(,)->的#7(_光线#6,起点#8)->起点#8(,)->的#9(_光线#6,终点#10)->终点#10(,)...

->+pt#12(,)->+pt0#13(,)->+pt1#14(,)...


...............................................
->+P代码#15"\"\"\"
+[返回目录](,P代码)
+[P函数](,P代码)

输入:...
输出:...

\"\"\"

dx=pt[0]-pt0[0]
dy=pt[1]-pt0[1]
dr=np.sqrt(dx**2+dy**2)

Dx=pt1[0]-pt0[0]
Dy=pt1[1]-pt0[1]
L=np.sqrt(Dx**2+Dy**2)


if dr==0:
    theta=0
elif dy==0:
    theta=np.arccos(dx/dr)
else:
    theta=-np.arccos(dx/dr)*np.sign(dy)

pt1[0]=pt0[0]+L*np.cos(theta)
pt1[1]=pt0[1]-L*np.sin(theta)

"(,)...
...............................................


->+的#16(+输出#17,+pt1#14)...


...............................................
->+输出#17"+[返回目录]
+[内容]
pt1::
"(,)...
...............................................


->+的#18(+输入#20,+pt0#13)->+的#19(+输入#20,+pt#12)...


...............................................
->+输入#20"+[返回目录]
+[内容]
pt::
pt0::
"(,)...
...............................................


->+的#21(+P代码#15,+输出#17)->+的#22(+P代码#15,+输入#20)->+的#23(经过#4,+P代码#15)->+是#24(_点#5,+pt#12)->+是#25(起点#8,+pt0#13)->+等于#26(+pt1#14,终点#10)
## end
#1208, 1008:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


pt1=[%起点];
pt2=[%终点];
a=%曲率;
l=%箭头大小;

angle=30/180*Math.PI;

dx=(pt2[0]-pt1[0])/500;


ctx.beginPath();

if(pt2[0]==pt1[0]) {
    ctx.moveTo(pt1[0],pt1[1]);
    ctx.lineTo(pt2[0],pt2[1]);
}
else {
    A=a/Math.abs(pt2[0]-pt1[0]);

    k=(pt2[1]-pt1[1])/(pt2[0]-pt1[0]);
    d=(pt2[0]*pt1[1]-pt1[0]*pt2[1])/(pt2[0]-pt1[0]);

    ctx.moveTo(pt1[0],pt1[1]);
    for (let x_i=pt1[0];x_i<=pt2[0];x_i+=dx) {
        y_i=A*(x_i-pt1[0])*(x_i-pt2[0])+k*x_i+d
        ctx.lineTo(x_i,y_i);
    }

    ctx.stroke();


    ctx.beginPath();

    theta=-Math.atan(A*(pt2[0]-pt1[0]-l/2)+k);
    Dtheta=angle;
    dp21=[l*Math.cos(theta-Dtheta/2),-l*Math.sin(theta-Dtheta/2)];
    dp22=[l*Math.cos(theta+Dtheta/2),-l*Math.sin(theta+Dtheta/2)];

    ctx.moveTo(pt2[0],pt2[1]);
    ctx.lineTo(pt2[0]-dp21[0],pt2[1]-dp21[1]);
    ctx.lineTo(pt2[0]-dp22[0],pt2[1]-dp22[1]);
    ctx.lineTo(pt2[0],pt2[1]);
    ctx.fill();
    ctx.stroke();
}


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1209, 17:
1.278553289310001
## end
#1211, 8:
958, 476
## end
#1213, 12:
100.0, 150.0
## end
#1218, 718:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


pt=[%中心];
r=%半径;
angle=%角度;
theta=angle/180*Math.PI;

x0=pt[0];
y0=pt[1];

ctx.save()
ctx.translate(x0,y0)
ctx.rotate(-theta+90/180*Math.PI)
ctx.translate(-x0,-y0)

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0-r,2*r,2*r);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0-r,2*r,2*r);
}


ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',x0,y0);


ctx.restore()




/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1221, 1305:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var d=50;
var size=[%尺寸];
var pt=[%起点];
var size_F=%字体;

var lineWidth=%线粗细;

var X=[];
var Y=[];
var x0,x1,y0,y1;

if (size[0]>0) {
    x0=pt[0];
    x1=pt[0]+size[0];
}
else {
    x1=pt[0];
    x0=pt[0]+size[0];
}


if (size[1]>0) {
    y0=pt[1];
    y1=pt[1]+size[1];
}
else {
    y1=pt[1];
    y0=pt[1]+size[1];
}

xs=x0-x0%d;
xe=x1-x1%d;
ys=y0-y0%d;
ye=y1-y1%d;

if (xs<x0) {
    xs+=d
}
if (xe>x1) {
    xe-=d
}
if (ys<y0) {
    ys+=d
}
if (ye>y1) {
    ye-=d
}

//window.alert([x0,x1])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.beginPath();

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}


ctx.fillStyle='rgba(0,0,0,1)';
ctx.font=%字体*1.5+'px serif'


ctx.textAlign='center'
ctx.textBaseline='bottom'
for (let x=xs; x<=xe; x+=d) {
    ctx.moveTo(x,y0);
    ctx.lineTo(x,y1);
    ctx.fillText(x,x,y0);
}

ctx.textAlign='right'
ctx.textBaseline='middle'
for (let y=ys; y<=ye; y+=d) {
    ctx.moveTo(x0,y);
    ctx.lineTo(x1,y);
    ctx.fillText(y,x0,y);
}
ctx.stroke()



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1224, 725:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;

x0=pt[0];
y0=pt[1];

ctx.save()
ctx.translate(x0,y0)
ctx.rotate(-theta+90/180*Math.PI)
ctx.translate(-x0,-y0)

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0-d/2,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0-d/2,2*r,d);
}


ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',x0,y0);


ctx.restore()




/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1227, 746:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var pt=[%中心];
var R=5;
var r=%半径;
var angle=%角度;
var theta=angle/180*Math.PI;

var lineWidth=%线粗细;

var x0=pt[0]
var y0=pt[1]
var dx=Math.cos(theta)*r
var dy=-Math.sin(theta)*r


ctx.beginPath();
ctx.arc(%中心,5,0,2*Math.PI)

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fill();
}

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(0,0,0)';
} else {
        ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.stroke();
}

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='left'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText(`(${x0.toFixed(2)},${y0.toFixed(2)})`,x0+dx,y0+dy)

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1230, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1233, 1487:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var pt1=[%起点];
var pt2=[%终点];


//arrows
var angle=30/180*Math.PI;
var l=20;
var D=%位移距离;
var d=10;

r=Math.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2);
if (r!=0) {
    theta=Math.sign(pt1[1]-pt2[1])*Math.acos((pt2[0]-pt1[0])/r);
}

dp21=[l*Math.cos(theta-angle/2),-l*Math.sin(theta-angle/2)];
dp22=[l*Math.cos(theta+angle/2),-l*Math.sin(theta+angle/2)];

Dx=D*Math.cos(theta-90/180*Math.PI);
Dy=-D*Math.sin(theta-90/180*Math.PI);
pt10=[0,0];
pt20=[0,0];
pt10[0]=pt1[0]+Dx;
pt10[1]=pt1[1]+Dy;
pt20[0]=pt2[0]+Dx;
pt20[1]=pt2[1]+Dy;


ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();


ctx.moveTo(pt10[0],pt10[1]);
ctx.lineTo(pt10[0]+dp21[0],pt10[1]+dp21[1]);
ctx.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1]);
ctx.lineTo(pt10[0],pt10[1]);

ctx.moveTo(pt20[0],pt20[1]);
ctx.lineTo(pt20[0]-dp21[0],pt20[1]-dp21[1]);
ctx.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1]);
ctx.lineTo(pt20[0],pt20[1]);

ctx.moveTo(pt1[0],pt1[1]);
ctx.lineTo(pt10[0],pt10[1]);
ctx.moveTo(pt2[0],pt2[1]);
ctx.lineTo(pt20[0],pt20[1]);

ctx.moveTo(pt10[0],pt10[1]);
ctx.lineTo(pt20[0],pt20[1]);

ctx.stroke()
ctx.fill()


// text
dx=d*Math.cos(theta-90/180*Math.PI)
dy=-d*Math.sin(theta-90/180*Math.PI)
pt0=[0,0]
pt0[0]=(pt10[0]+pt20[0])/2+dx
pt0[1]=(pt10[1]+pt20[1])/2+dy


ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
L=300
H=100
ctx.fillText('%文字',pt0[0],pt0[1]);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1236, 4:
1453
## end
#1238, 4:
1455
## end
#1240, 4:
1480
## end
#1242, 2:
里面
## end
#1243, 2:
里面
## end
#1244, 2:
里面
## end
#1245, 2:
里面
## end
#1246, 2:
里面
## end
#1247, 2:
里面
## end
#1248, 3:
角度点
## end
#1249, 2:
里面
## end
#1250, 2:
里面
## end
#1251, 2:
里面
## end
#1252, 3:
角度点
## end
#1253, 2:
里面
## end
#1254, 2:
里面
## end
#1255, 2:
里面
## end
#1256, 2:
左面
## end
#1257, 2:
里面
## end
#1258, 2:
里面
## end
#1259, 2:
里面
## end
#1260, 2:
里面
## end
#1261, 2:
里面
## end
#1262, 3:
右下角
## end
#1263, 2:
里面
## end
#1264, 4:
1481
## end
#1266, 4:
1572
## end
#1269, 105:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...

## end
#1279, 1164:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

angle=30
l=30
D=0
d=10
text=文字


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush())

r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
if r!=0:
    theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]

pt10=[0,0]
pt20=[0,0]
pt10[0]=pt1[0]
pt10[1]=pt1[1]
pt20[0]=pt2[0]
pt20[1]=pt2[1]

path1=QPainterPath()
#path1.moveTo(pt10[0],pt10[1])
path1.moveTo(pt10[0]+dp21[0],pt10[1]+dp21[1])
path1.lineTo(pt10[0],pt10[1])
path1.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1])

path2=QPainterPath()
#path2.moveTo(pt20[0],pt20[1])
path2.moveTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
path2.lineTo(pt20[0],pt20[1])
path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])

qp.drawPath(path1)
qp.drawPath(path2)


qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])

qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#1285, 1164:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

angle=30
l=30
D=0
d=10
text=文字


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush())

r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
if r!=0:
    theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]

pt10=[0,0]
pt20=[0,0]
pt10[0]=pt1[0]
pt10[1]=pt1[1]
pt20[0]=pt2[0]
pt20[1]=pt2[1]

path1=QPainterPath()
#path1.moveTo(pt10[0],pt10[1])
path1.moveTo(pt10[0]+dp21[0],pt10[1]+dp21[1])
path1.lineTo(pt10[0],pt10[1])
path1.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1])

path2=QPainterPath()
#path2.moveTo(pt20[0],pt20[1])
path2.moveTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
path2.lineTo(pt20[0],pt20[1])
path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])

qp.drawPath(path1)
qp.drawPath(path2)


qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])

qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#1286, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1287, 2:
直线
## end
#1288, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#1292, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#1295, 14:
+[返回目录]
+[内容]

## end
#1296, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1298, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1299, 944:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var pt1=[%起点];
var pt2=[%终点];


//arrows
var angle=30/180*Math.PI;
var l=20;
var d=10;

r=Math.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2);
if (r!=0) {
    theta=Math.sign(pt1[1]-pt2[1])*Math.acos((pt2[0]-pt1[0])/r);
}

dp21=[l*Math.cos(theta-angle/2),-l*Math.sin(theta-angle/2)];
dp22=[l*Math.cos(theta+angle/2),-l*Math.sin(theta+angle/2)];

pt10=[0,0];
pt20=[0,0];
pt10[0]=pt1[0];
pt10[1]=pt1[1];
pt20[0]=pt2[0];
pt20[1]=pt2[1];


ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
ctx.fillStyle='rgb(0,0,0,0)';


ctx.beginPath();


ctx.moveTo(pt10[0]+dp21[0],pt10[1]+dp21[1]);
ctx.lineTo(pt10[0],pt10[1]);
ctx.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1]);

ctx.moveTo(pt20[0]-dp21[0],pt20[1]-dp21[1]);
ctx.lineTo(pt20[0],pt20[1]);
ctx.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1]);


ctx.moveTo(pt10[0],pt10[1]);
ctx.lineTo(pt20[0],pt20[1]);

ctx.stroke()
ctx.fill()



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1301, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#1307, 38:
-539.9782518102502, -43.86350330175003
## end
#1308, 37:
-365.10174818975, -235.64649669825008
## end
#1309, 5:
0,0,0
## end
#1310, 8:
DashLine
## end
#1311, 1:
1
## end
#1312, 2:
里面
## end
#1313, 2:
起点
## end
#1314, 2:
起点
## end
#1315, 2:
起点
## end
#1316, 2:
里面
## end
#1317, 2:
起点
## end
#1318, 2:
起点
## end
#1319, 2:
起点
## end
#1320, 2:
终点
## end
#1321, 2:
终点
## end
#1322, 2:
里面
## end
#1323, 2:
里面
## end
#1324, 2:
终点
## end
#1326, 7643:
"""
+[返回目录](,创建箭头)

"""


+创建箭头#0(,_箭头#46)->+[del]#1(,+创建箭头#0)...


...............................................
->+[临时文本]#2"+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...
"(,)...
...............................................


->+[修改内容]#3(+[临时文本]#2,_箭头#46)->+线粗细#4"1"(,)...


...............................................
->+线型#5"DashLine"(,)...
...............................................





...............................................
->+线颜色#6"0,0,0"(,)...
...............................................





...............................................
->+终点#7"-359.11224818975006, -217.41179669825007"(,)...
...............................................





...............................................
->+起点#8"-533.9887518102503, -25.628803301750025"(,)...
...............................................


->+的#9(+输入#14,+线粗细#4)->+的#10(+输入#14,+线型#5)->+的#11(+输入#14,+线颜色#6)->+的#12(+输入#14,+终点#7)->+的#13(+输入#14,+起点#8)...


...............................................
->+输入#14"线颜色::0,0,0
线型::DashLine
线粗细::2
"(,)...
...............................................


->+的#15(+HTML#16,+输入#14)...


...............................................
->+HTML#16"/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var pt1=[%起点];
var pt2=[%终点];


//arrows
var angle=30/180*Math.PI;
var l=20;
var d=10;

r=Math.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2);
if (r!=0) {
    theta=Math.sign(pt1[1]-pt2[1])*Math.acos((pt2[0]-pt1[0])/r);
}

dp21=[l*Math.cos(theta-angle/2),-l*Math.sin(theta-angle/2)];
dp22=[l*Math.cos(theta+angle/2),-l*Math.sin(theta+angle/2)];

pt10=[0,0];
pt20=[0,0];
pt10[0]=pt1[0];
pt10[1]=pt1[1];
pt20[0]=pt2[0];
pt20[1]=pt2[1];


ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
ctx.fillStyle='rgb(0,0,0,0)';


ctx.beginPath();


ctx.moveTo(pt10[0]+dp21[0],pt10[1]+dp21[1]);
ctx.lineTo(pt10[0],pt10[1]);
ctx.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1]);

ctx.moveTo(pt20[0]-dp21[0],pt20[1]-dp21[1]);
ctx.lineTo(pt20[0],pt20[1]);
ctx.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1]);


ctx.moveTo(pt10[0],pt10[1]);
ctx.lineTo(pt20[0],pt20[1]);

ctx.stroke()
ctx.fill()



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/"(,)...
...............................................





...............................................
->+LaTeX数学记号#17"https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols"(,)...
...............................................


->+的#18(+点线公式#19,+LaTeX数学记号#17)...


...............................................
->+点线公式#19"<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type=\"text/javascript\" src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"></script>
  </head>
  <body>
    <p><mathjax style=\"font-size:1.5em\">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>
"(,)...
...............................................





...............................................
->+输出#20"+[返回目录]
+[内容]
"(,)...
...............................................


->+的#21(+输入#23,+终点#7)->+的#22(+输入#23,+起点#8)...


...............................................
->+输入#23"+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0
"(,)...
...............................................


->+的#24(+选中区域#27,+点线公式#19)->+的#25(+选中区域#27,+输出#20)->+的#26(+选中区域#27,+输入#23)...


...............................................
->+选中区域#27"\"\"\"
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

\"\"\"

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False
"(,)...
...............................................


->+类型#28"直线"(,)...


...............................................
->+选中框#29"\"\"\"
+[返回目录](,选中框)

\"\"\"
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))"(,)...
...............................................





...............................................
->+图形#30"\"\"\"
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

\"\"\"
pt1=起点
pt2=终点

angle=30
l=30
D=0
d=10
text=文字


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush())

r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
if r!=0:
    theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]

pt10=[0,0]
pt20=[0,0]
pt10[0]=pt1[0]
pt10[1]=pt1[1]
pt20[0]=pt2[0]
pt20[1]=pt2[1]

path1=QPainterPath()
#path1.moveTo(pt10[0],pt10[1])
path1.moveTo(pt10[0]+dp21[0],pt10[1]+dp21[1])
path1.lineTo(pt10[0],pt10[1])
path1.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1])

path2=QPainterPath()
#path2.moveTo(pt20[0],pt20[1])
path2.moveTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
path2.lineTo(pt20[0],pt20[1])
path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])

qp.drawPath(path1)
qp.drawPath(path2)


qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])

qp.setBrush(QBrush())
qp.setPen(QPen())


"(,)...
...............................................


->+输出#31(,)->+的#32(+画图#36,+选中框#29)->+的#33(+画图#36,+图形#30)->+的#34(+画图#36,+输出#31)->+的#35(+画图#36,+输入#14)...


...............................................
->+画图#36"\"\"\"
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

\"\"\"
pt1=起点
pt2=终点

angle=30
l=30
D=0
d=10


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush())

r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
if r!=0:
    theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]

pt10=[0,0]
pt20=[0,0]
pt10[0]=pt1[0]
pt10[1]=pt1[1]
pt20[0]=pt2[0]
pt20[1]=pt2[1]

path1=QPainterPath()
#path1.moveTo(pt10[0],pt10[1])
path1.moveTo(pt10[0]+dp21[0],pt10[1]+dp21[1])
path1.lineTo(pt10[0],pt10[1])
path1.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1])

path2=QPainterPath()
#path2.moveTo(pt20[0],pt20[1])
path2.moveTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
path2.lineTo(pt20[0],pt20[1])
path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])

qp.drawPath(path1)
qp.drawPath(path2)


qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])

qp.setBrush(QBrush())
qp.setPen(QPen())


"(,)...
...............................................


->+的#37(_箭头#46,+HTML#16)->+的#38(_箭头#46,+线粗细#4)->+的#39(_箭头#46,+线型#5)->+的#40(_箭头#46,+线颜色#6)->+的#41(_箭头#46,+选中区域#27)->+的#42(_箭头#46,+类型#28)->+的#43(_箭头#46,+画图#36)->+的#44(_箭头#46,+终点#7)->+的#45(_箭头#46,+起点#8)->_箭头#46(,)
## end
#1327, 4:
1342
## end
#1331, 39:
-360.6098000000001, -12.153999999999968
## end
#1333, 27:
592.3788000000002, 197.0718
## end
#1338, 9355:
"""
+[返回目录](,创建长度)

"""


+创建长度#0(,_长度#52)->+[del]#1(,+创建长度#0)...


...............................................
->+[临时文本]#2"+[返回目录](,长度)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1
文字::10 cm
位移距离::20

画图:...
选中区域:...
HTML:...

"(,)...
...............................................


->+[修改内容]#3(+[临时文本]#2,_长度#52)->+位移距离#4"30"(,)...


...............................................
->+文字#5"20 cm"(,)...
...............................................


->+线粗细#6"1"(,)...


...............................................
->+线型#7"DashLine"(,)...
...............................................





...............................................
->+线颜色#8"0,0,0"(,)...
...............................................





...............................................
->+终点#9"26.37719999999993, -278.7175000000001"(,)...
...............................................





...............................................
->+起点#10"-342.6228000000001, -233.7175000000001"(,)...
...............................................


->+的#11(+输入#18,+位移距离#4)->+的#12(+输入#18,+文字#5)->+的#13(+输入#18,+线粗细#6)->+的#14(+输入#18,+线型#7)->+的#15(+输入#18,+线颜色#8)->+的#16(+输入#18,+终点#9)->+的#17(+输入#18,+起点#10)...


...............................................
->+输入#18"线颜色::0,0,0
线型::DashLine
线粗细::2
文字::10 cm
位移距离::20
"(,)...
...............................................


->+的#19(+HTML#20,+输入#18)...


...............................................
->+HTML#20"/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var pt1=[%起点];
var pt2=[%终点];


//arrows
var angle=30/180*Math.PI;
var l=20;
var D=%位移距离;
var d=10;

r=Math.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2);
if (r!=0) {
    theta=Math.sign(pt1[1]-pt2[1])*Math.acos((pt2[0]-pt1[0])/r);
}

dp21=[l*Math.cos(theta-angle/2),-l*Math.sin(theta-angle/2)];
dp22=[l*Math.cos(theta+angle/2),-l*Math.sin(theta+angle/2)];

Dx=D*Math.cos(theta-90/180*Math.PI);
Dy=-D*Math.sin(theta-90/180*Math.PI);
pt10=[0,0];
pt20=[0,0];
pt10[0]=pt1[0]+Dx;
pt10[1]=pt1[1]+Dy;
pt20[0]=pt2[0]+Dx;
pt20[1]=pt2[1]+Dy;


ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();


ctx.moveTo(pt10[0],pt10[1]);
ctx.lineTo(pt10[0]+dp21[0],pt10[1]+dp21[1]);
ctx.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1]);
ctx.lineTo(pt10[0],pt10[1]);

ctx.moveTo(pt20[0],pt20[1]);
ctx.lineTo(pt20[0]-dp21[0],pt20[1]-dp21[1]);
ctx.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1]);
ctx.lineTo(pt20[0],pt20[1]);

ctx.moveTo(pt1[0],pt1[1]);
ctx.lineTo(pt10[0],pt10[1]);
ctx.moveTo(pt2[0],pt2[1]);
ctx.lineTo(pt20[0],pt20[1]);

ctx.moveTo(pt10[0],pt10[1]);
ctx.lineTo(pt20[0],pt20[1]);

ctx.stroke()
ctx.fill()


// text
dx=d*Math.cos(theta-90/180*Math.PI)
dy=-d*Math.sin(theta-90/180*Math.PI)
pt0=[0,0]
pt0[0]=(pt10[0]+pt20[0])/2+dx
pt0[1]=(pt10[1]+pt20[1])/2+dy


ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
L=300
H=100
ctx.fillText('%文字',pt0[0],pt0[1]);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/"(,)...
...............................................





...............................................
->+LaTeX数学记号#21"https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols"(,)...
...............................................


->+的#22(+点线公式#23,+LaTeX数学记号#21)...


...............................................
->+点线公式#23"<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type=\"text/javascript\" src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"></script>
  </head>
  <body>
    <p><mathjax style=\"font-size:1.5em\">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>
"(,)...
...............................................





...............................................
->+输出#24"+[返回目录]
+[内容]
"(,)...
...............................................


->+的#25(+输入#27,+终点#9)->+的#26(+输入#27,+起点#10)...


...............................................
->+输入#27"+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0
"(,)...
...............................................


->+的#28(+选中区域#31,+点线公式#23)->+的#29(+选中区域#31,+输出#24)->+的#30(+选中区域#31,+输入#27)...


...............................................
->+选中区域#31"\"\"\"
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

\"\"\"

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False
"(,)...
...............................................


->+类型#32"直线"(,)...


...............................................
->+选中框#33"\"\"\"
+[返回目录](,选中框)

\"\"\"
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))"(,)...
...............................................





...............................................
->+图形#34"\"\"\"
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

\"\"\"
pt1=起点
pt2=终点

angle=30
l=20
D=位移距离[0]
d=10
text=文字


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush(QColor(edgeColor[0],edgeColor[1],edgeColor[2])))

r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
if r!=0:
    theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]

Dx=D*np.cos(np.deg2rad(theta-90))
Dy=-D*np.sin(np.deg2rad(theta-90))
pt10=[0,0]
pt20=[0,0]
pt10[0]=pt1[0]+Dx
pt10[1]=pt1[1]+Dy
pt20[0]=pt2[0]+Dx
pt20[1]=pt2[1]+Dy

path1=QPainterPath()
path1.moveTo(pt10[0],pt10[1])
path1.lineTo(pt10[0]+dp21[0],pt10[1]+dp21[1])
path1.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1])
path1.lineTo(pt10[0],pt10[1])

path2=QPainterPath()
path2.moveTo(pt20[0],pt20[1])
path2.lineTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])
path2.lineTo(pt20[0],pt20[1])

qp.drawPath(path1)
qp.drawPath(path2)
qp.drawLine(pt1[0],pt1[1],pt10[0],pt10[1])
qp.drawLine(pt2[0],pt2[1],pt20[0],pt20[1])


dx=d*np.cos(np.deg2rad(theta-90))
dy=-d*np.sin(np.deg2rad(theta-90))
pt0=[0,0]
pt0[0]=(pt10[0]+pt20[0])/2+dx
pt0[1]=(pt10[1]+pt20[1])/2+dy

L=300
H=100
qp.drawText(pt0[0]-L/2,pt0[1]-H/2,L,H,Qt.AlignHCenter|Qt.AlignVCenter,text)

qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])

qp.setBrush(QBrush())
qp.setPen(QPen())


"(,)...
...............................................


->+输出#35(,)->+的#36(+画图#40,+选中框#33)->+的#37(+画图#40,+图形#34)->+的#38(+画图#40,+输出#35)->+的#39(+画图#40,+输入#18)...


...............................................
->+画图#40"\"\"\"
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

\"\"\"
pt1=起点
pt2=终点

angle=30
l=20
D=位移距离[0]
d=10
text=文字


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush(QColor(edgeColor[0],edgeColor[1],edgeColor[2])))

r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
if r!=0:
    theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]

Dx=D*np.cos(np.deg2rad(theta-90))
Dy=-D*np.sin(np.deg2rad(theta-90))
pt10=[0,0]
pt20=[0,0]
pt10[0]=pt1[0]+Dx
pt10[1]=pt1[1]+Dy
pt20[0]=pt2[0]+Dx
pt20[1]=pt2[1]+Dy

path1=QPainterPath()
path1.moveTo(pt10[0],pt10[1])
path1.lineTo(pt10[0]+dp21[0],pt10[1]+dp21[1])
path1.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1])
path1.lineTo(pt10[0],pt10[1])

path2=QPainterPath()
path2.moveTo(pt20[0],pt20[1])
path2.lineTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])
path2.lineTo(pt20[0],pt20[1])

qp.drawPath(path1)
qp.drawPath(path2)
qp.drawLine(pt1[0],pt1[1],pt10[0],pt10[1])
qp.drawLine(pt2[0],pt2[1],pt20[0],pt20[1])


dx=d*np.cos(np.deg2rad(theta-90))
dy=-d*np.sin(np.deg2rad(theta-90))
pt0=[0,0]
pt0[0]=(pt10[0]+pt20[0])/2+dx
pt0[1]=(pt10[1]+pt20[1])/2+dy

L=300
H=100
qp.drawText(pt0[0]-L/2,pt0[1]-H/2,L,H,Qt.AlignHCenter|Qt.AlignVCenter,text)

qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])

qp.setBrush(QBrush())
qp.setPen(QPen())


"(,)...
...............................................


->+的#41(_长度#52,+HTML#20)->+的#42(_长度#52,+位移距离#4)->+的#43(_长度#52,+文字#5)->+的#44(_长度#52,+线粗细#6)->+的#45(_长度#52,+线型#7)->+的#46(_长度#52,+线颜色#8)->+的#47(_长度#52,+选中区域#31)->+的#48(_长度#52,+类型#32)->+的#49(_长度#52,+画图#40)->+的#50(_长度#52,+终点#9)->+的#51(_长度#52,+起点#10)->_长度#52(,)
## end
#1339, 4:
1387
## end
#1342, 105:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...

## end
#1352, 1161:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

angle=30
l=30
D=0
d=10


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush())

r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
if r!=0:
    theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]

pt10=[0,0]
pt20=[0,0]
pt10[0]=pt1[0]
pt10[1]=pt1[1]
pt20[0]=pt2[0]
pt20[1]=pt2[1]

#path1=QPainterPath()
#path1.moveTo(pt10[0],pt10[1])
#path1.moveTo(pt10[0]+dp21[0],pt10[1]+dp21[1])
#path1.lineTo(pt10[0],pt10[1])
#path1.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1])

path2=QPainterPath()
#path2.moveTo(pt20[0],pt20[1])
path2.moveTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
path2.lineTo(pt20[0],pt20[1])
path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])

#qp.drawPath(path1)
qp.drawPath(path2)


qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])

qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#1358, 1161:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

angle=30
l=30
D=0
d=10


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush())

r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
if r!=0:
    theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]

pt10=[0,0]
pt20=[0,0]
pt10[0]=pt1[0]
pt10[1]=pt1[1]
pt20[0]=pt2[0]
pt20[1]=pt2[1]

#path1=QPainterPath()
#path1.moveTo(pt10[0],pt10[1])
#path1.moveTo(pt10[0]+dp21[0],pt10[1]+dp21[1])
#path1.lineTo(pt10[0],pt10[1])
#path1.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1])

path2=QPainterPath()
#path2.moveTo(pt20[0],pt20[1])
path2.moveTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
path2.lineTo(pt20[0],pt20[1])
path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])

#qp.drawPath(path1)
qp.drawPath(path2)


qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])

qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#1359, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1360, 2:
直线
## end
#1361, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#1365, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#1368, 14:
+[返回目录]
+[内容]

## end
#1369, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1371, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1372, 950:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var pt1=[%起点];
var pt2=[%终点];


//arrows
var angle=30/180*Math.PI;
var l=20;
var d=10;

r=Math.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2);
if (r!=0) {
    theta=Math.sign(pt1[1]-pt2[1])*Math.acos((pt2[0]-pt1[0])/r);
}

dp21=[l*Math.cos(theta-angle/2),-l*Math.sin(theta-angle/2)];
dp22=[l*Math.cos(theta+angle/2),-l*Math.sin(theta+angle/2)];

pt10=[0,0];
pt20=[0,0];
pt10[0]=pt1[0];
pt10[1]=pt1[1];
pt20[0]=pt2[0];
pt20[1]=pt2[1];


ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
ctx.fillStyle='rgb(0,0,0,0)';


ctx.beginPath();


//ctx.moveTo(pt10[0]+dp21[0],pt10[1]+dp21[1]);
//ctx.lineTo(pt10[0],pt10[1]);
//ctx.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1]);

ctx.moveTo(pt20[0]-dp21[0],pt20[1]-dp21[1]);
ctx.lineTo(pt20[0],pt20[1]);
ctx.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1]);


ctx.moveTo(pt10[0],pt10[1]);
ctx.lineTo(pt20[0],pt20[1]);

ctx.stroke()
ctx.fill()



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1374, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#1380, 38:
-553.2882518102502, 205.03349669825008
## end
#1381, 36:
-378.41174818975, 13.250503301750015
## end
#1382, 5:
0,0,0
## end
#1383, 8:
DashLine
## end
#1384, 1:
1
## end
#1386, 7676:
"""
+[返回目录](,创建单向箭头)

"""


+创建单向箭头#0(,_单向箭头#46)->+[del]#1(,+创建单向箭头#0)...


...............................................
->+[临时文本]#2"+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...
"(,)...
...............................................


->+[修改内容]#3(+[临时文本]#2,_单向箭头#46)->+线粗细#4"1"(,)...


...............................................
->+线型#5"DashLine"(,)...
...............................................





...............................................
->+线颜色#6"0,0,0"(,)...
...............................................





...............................................
->+终点#7"-378.41174818975, 13.250503301750015"(,)...
...............................................





...............................................
->+起点#8"-553.2882518102502, 205.03349669825008"(,)...
...............................................


->+的#9(+输入#14,+线粗细#4)->+的#10(+输入#14,+线型#5)->+的#11(+输入#14,+线颜色#6)->+的#12(+输入#14,+终点#7)->+的#13(+输入#14,+起点#8)...


...............................................
->+输入#14"线颜色::0,0,0
线型::DashLine
线粗细::2
"(,)...
...............................................


->+的#15(+HTML#16,+输入#14)...


...............................................
->+HTML#16"/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var pt1=[%起点];
var pt2=[%终点];


//arrows
var angle=30/180*Math.PI;
var l=20;
var d=10;

r=Math.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2);
if (r!=0) {
    theta=Math.sign(pt1[1]-pt2[1])*Math.acos((pt2[0]-pt1[0])/r);
}

dp21=[l*Math.cos(theta-angle/2),-l*Math.sin(theta-angle/2)];
dp22=[l*Math.cos(theta+angle/2),-l*Math.sin(theta+angle/2)];

pt10=[0,0];
pt20=[0,0];
pt10[0]=pt1[0];
pt10[1]=pt1[1];
pt20[0]=pt2[0];
pt20[1]=pt2[1];


ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
ctx.fillStyle='rgb(0,0,0,0)';


ctx.beginPath();


//ctx.moveTo(pt10[0]+dp21[0],pt10[1]+dp21[1]);
//ctx.lineTo(pt10[0],pt10[1]);
//ctx.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1]);

ctx.moveTo(pt20[0]-dp21[0],pt20[1]-dp21[1]);
ctx.lineTo(pt20[0],pt20[1]);
ctx.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1]);


ctx.moveTo(pt10[0],pt10[1]);
ctx.lineTo(pt20[0],pt20[1]);

ctx.stroke()
ctx.fill()



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/"(,)...
...............................................





...............................................
->+LaTeX数学记号#17"https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols"(,)...
...............................................


->+的#18(+点线公式#19,+LaTeX数学记号#17)...


...............................................
->+点线公式#19"<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type=\"text/javascript\" src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"></script>
  </head>
  <body>
    <p><mathjax style=\"font-size:1.5em\">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>
"(,)...
...............................................





...............................................
->+输出#20"+[返回目录]
+[内容]
"(,)...
...............................................


->+的#21(+输入#23,+终点#7)->+的#22(+输入#23,+起点#8)...


...............................................
->+输入#23"+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0
"(,)...
...............................................


->+的#24(+选中区域#27,+点线公式#19)->+的#25(+选中区域#27,+输出#20)->+的#26(+选中区域#27,+输入#23)...


...............................................
->+选中区域#27"\"\"\"
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

\"\"\"

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False
"(,)...
...............................................


->+类型#28"直线"(,)...


...............................................
->+选中框#29"\"\"\"
+[返回目录](,选中框)

\"\"\"
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))"(,)...
...............................................





...............................................
->+图形#30"\"\"\"
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

\"\"\"
pt1=起点
pt2=终点

angle=30
l=30
D=0
d=10


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush())

r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
if r!=0:
    theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]

pt10=[0,0]
pt20=[0,0]
pt10[0]=pt1[0]
pt10[1]=pt1[1]
pt20[0]=pt2[0]
pt20[1]=pt2[1]

#path1=QPainterPath()
#path1.moveTo(pt10[0],pt10[1])
#path1.moveTo(pt10[0]+dp21[0],pt10[1]+dp21[1])
#path1.lineTo(pt10[0],pt10[1])
#path1.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1])

path2=QPainterPath()
#path2.moveTo(pt20[0],pt20[1])
path2.moveTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
path2.lineTo(pt20[0],pt20[1])
path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])

#qp.drawPath(path1)
qp.drawPath(path2)


qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])

qp.setBrush(QBrush())
qp.setPen(QPen())


"(,)...
...............................................


->+输出#31(,)->+的#32(+画图#36,+选中框#29)->+的#33(+画图#36,+图形#30)->+的#34(+画图#36,+输出#31)->+的#35(+画图#36,+输入#14)...


...............................................
->+画图#36"\"\"\"
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

\"\"\"
pt1=起点
pt2=终点

angle=30
l=30
D=0
d=10


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush())

r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
if r!=0:
    theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]

pt10=[0,0]
pt20=[0,0]
pt10[0]=pt1[0]
pt10[1]=pt1[1]
pt20[0]=pt2[0]
pt20[1]=pt2[1]

#path1=QPainterPath()
#path1.moveTo(pt10[0],pt10[1])
#path1.moveTo(pt10[0]+dp21[0],pt10[1]+dp21[1])
#path1.lineTo(pt10[0],pt10[1])
#path1.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1])

path2=QPainterPath()
#path2.moveTo(pt20[0],pt20[1])
path2.moveTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
path2.lineTo(pt20[0],pt20[1])
path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])

#qp.drawPath(path1)
qp.drawPath(path2)


qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])

qp.setBrush(QBrush())
qp.setPen(QPen())


"(,)...
...............................................


->+的#37(_单向箭头#46,+HTML#16)->+的#38(_单向箭头#46,+线粗细#4)->+的#39(_单向箭头#46,+线型#5)->+的#40(_单向箭头#46,+线颜色#6)->+的#41(_单向箭头#46,+选中区域#27)->+的#42(_单向箭头#46,+类型#28)->+的#43(_单向箭头#46,+画图#36)->+的#44(_单向箭头#46,+终点#7)->+的#45(_单向箭头#46,+起点#8)->_单向箭头#46(,)
## end
#1387, 4:
1447
## end
#1390, 175:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10
地址::test.png

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

+[创建输入](地址,画图)

## end
#1403, 841:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""


from PyQt5.QtGui import QPixmap



pt=起点
size=尺寸
size_F=字体[0]
pic_file=地址

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


#qp.drawRect(pt[0],pt[1],size[0],size[1])

pixmap=QPixmap(pic_file)
size[1]=pixmap.height()/pixmap.width()*size[0]
qp.drawPixmap(pt[0],pt[1],size[0],size[1],pixmap)
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())


尺寸=size







## end
#1408, 85:
起点::281.49455475000013, -84.73663301562507
尺寸::397.9895365000002, 241.94621603125017

## end
#1409, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#1410, 841:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""


from PyQt5.QtGui import QPixmap



pt=起点
size=尺寸
size_F=字体[0]
pic_file=地址

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


#qp.drawRect(pt[0],pt[1],size[0],size[1])

pixmap=QPixmap(pic_file)
size[1]=pixmap.height()/pixmap.width()*size[0]
qp.drawPixmap(pt[0],pt[1],size[0],size[1],pixmap)
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())


尺寸=size







## end
#1411, 231:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


## end
#1414, 14:
+[返回目录]
+[内容]

## end
#1415, 1178:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];
var img1=new Image();
var img=new Image();

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(%起点,%尺寸);
}

/*
if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}*/


/*
var img2 = new Image(),
        f = document.getElementById("uploadimage").files[0],
        url = window.URL || window.webkitURL,
        //src = url.createObjectURL(f);
        src=f;

    img2.src = src;
    img2.onload = function() {
        ctx.drawImage(img2, 0, 0);
        url.revokeObjectURL(src);
    }
*/



img1.onload=function() {
    ctx.drawImage(img1,%起点,%尺寸);
}
img1.src='https://img.moegirl.org.cn/common/thumb/8/86/Aj353_19.jpg/800px-Aj353_19.jpg'




//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1418, 14:
+[返回目录]
+[内容]

## end
#1419, 115:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100
地址::test1.png

## end
#1428, 38:
330.9876832968751, -3.0544400273438015
## end
#1429, 36:
301.2829167031252, 169.4716406455079
## end
#1430, 2:
矩形
## end
#1432, 2:
10
## end
#1433, 8:
DashLine
## end
#1434, 1:
2
## end
#1435, 11:
255,255,255
## end
#1436, 5:
0,0,0
## end
#1438, 35:
https://pythonspot.com/pyqt5-image/
## end
#1440, 65:
https://stackoverflow.com/questions/42769354/draw-on-top-of-image
## end
#1443, 4:
1445
## end
#1445, 4:
1447
## end
#1447, 4:
1449
## end
#1449, 4:
1451
## end
#1451, 4:
1453
## end
#1453, 4:
1455
## end
#1455, 4:
1457
## end
#1457, 4:
1459
## end
#1459, 4:
1466
## end
#1462, 7780:
"""
+[返回目录](,创建图片)

"""


+创建图片#0(,_图片#55)->+[del]#1(,+创建图片#0)...


...............................................
->+[临时文本]#2"+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10
地址::test.png

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

+[创建输入](地址,画图)
"(,)...
...............................................


->+[修改内容]#3(+[临时文本]#2,_图片#55)...


...............................................
->+地址#4"test.png"(,)...
...............................................





...............................................
->+线颜色#5"0,0,0"(,)...
...............................................





...............................................
->+面颜色#6"255,255,255"(,)...
...............................................


->+线粗细#7"2"(,)...


...............................................
->+线型#8"DashLine"(,)...
...............................................


->+字体#9"10"(,)->+文字#10(,)->+类型#11"矩形"(,)...


...............................................
->+尺寸#12"255.51950940625025, 143.72972404101577"(,)...
...............................................





...............................................
->+起点#13"330.9876832968751, -3.0544400273438015"(,)...
...............................................


->+的#14(+输入#23,+地址#4)->+的#15(+输入#23,+起点#13)->+的#16(+输入#23,+尺寸#12)->+的#17(+输入#23,+字体#9)->+的#18(+输入#23,+文字#10)->+的#19(+输入#23,+线粗细#7)->+的#20(+输入#23,+线型#8)->+的#21(+输入#23,+线颜色#5)->+的#22(+输入#23,+面颜色#6)...


...............................................
->+输入#23"+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100
地址::test1.png
"(,)...
...............................................





...............................................
->+输出#24"+[返回目录]
+[内容]
"(,)...
...............................................


->+的#25(+HTML#27,+输入#23)->+的#26(+HTML#27,+输出#24)...


...............................................
->+HTML#27"/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];
var img1=new Image();
var img=new Image();

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(%起点,%尺寸);
}

/*
if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}*/


/*
var img2 = new Image(),
        f = document.getElementById(\"uploadimage\").files[0],
        url = window.URL || window.webkitURL,
        //src = url.createObjectURL(f);
        src=f;

    img2.src = src;
    img2.onload = function() {
        ctx.drawImage(img2, 0, 0);
        url.revokeObjectURL(src);
    }
*/



img1.onload=function() {
    ctx.drawImage(img1,%起点,%尺寸);
}
img1.src='https://img.moegirl.org.cn/common/thumb/8/86/Aj353_19.jpg/800px-Aj353_19.jpg'




//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/"(,)...
...............................................





...............................................
->+输出#28"+[返回目录]
+[内容]
"(,)...
...............................................


->+的#29(+选中区域#31,+输入#23)->+的#30(+选中区域#31,+输出#28)...


...............................................
->+选中区域#31"\"\"\"
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

\"\"\"

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False

"(,)...
...............................................





...............................................
->+图形#32"\"\"\"
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

\"\"\"


from PyQt5.QtGui import QPixmap



pt=起点
size=尺寸
size_F=字体[0]
pic_file=地址

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


#qp.drawRect(pt[0],pt[1],size[0],size[1])

pixmap=QPixmap(pic_file)
size[1]=pixmap.height()/pixmap.width()*size[0]
qp.drawPixmap(pt[0],pt[1],size[0],size[1],pixmap)
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont(\"Decorative\",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())


尺寸=size






"(,)...
...............................................





...............................................
->+选中框#33"\"\"\"
+[返回目录](,选中框)

\"\"\"


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
"(,)...
...............................................


->+的#34(+输出#36,+尺寸#12)->+的#35(+输出#36,+起点#13)...


...............................................
->+输出#36"起点::281.49455475000013, -84.73663301562507
尺寸::397.9895365000002, 241.94621603125017
"(,)...
...............................................


->+的#37(+画图#41,+图形#32)->+的#38(+画图#41,+选中框#33)->+的#39(+画图#41,+输出#36)->+的#40(+画图#41,+输入#23)...


...............................................
->+画图#41"\"\"\"
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

\"\"\"


from PyQt5.QtGui import QPixmap



pt=起点
size=尺寸
size_F=字体[0]
pic_file=地址

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


#qp.drawRect(pt[0],pt[1],size[0],size[1])

pixmap=QPixmap(pic_file)
size[1]=pixmap.height()/pixmap.width()*size[0]
qp.drawPixmap(pt[0],pt[1],size[0],size[1],pixmap)
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont(\"Decorative\",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())


尺寸=size






\"\"\"
+[返回目录](,选中框)

\"\"\"


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
"(,)...
...............................................


->+的#42(_图片#55,+地址#4)->+的#43(_图片#55,+线颜色#5)->+的#44(_图片#55,+面颜色#6)->+的#45(_图片#55,+线粗细#7)->+的#46(_图片#55,+线型#8)->+的#47(_图片#55,+字体#9)->+的#48(_图片#55,+文字#10)->+的#49(_图片#55,+类型#11)->+的#50(_图片#55,+尺寸#12)->+的#51(_图片#55,+起点#13)->+的#52(_图片#55,+HTML#27)->+的#53(_图片#55,+选中区域#31)->+的#54(_图片#55,+画图#41)->_图片#55(,)
## end
#1464, 8:
test.png
## end
#1466, 4:
1468
## end
#1468, 4:
1470
## end
#1470, 4:
1472
## end
#1472, 4:
1474
## end
#1474, 4:
1476
## end
#1476, 4:
1478
## end
#1478, 4:
1480
## end
#1480, 4:
1482
## end
#1482, 4:
1484
## end
#1484, 4:
1590
## end
#1487, 163:
+[返回目录](,光线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

焦点::0.7
直径::70

画图:...
选中区域:...
HTML:...
+[创建输入](直径,选中区域)
的(画图,输入)->+[有](HTML,输入)

## end
#1497, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1503, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1504, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1505, 2:
直线
## end
#1506, 362:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and (d<直径[0]/4 or d<5):
    state=True
else:
    state=False

## end
#1510, 49:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0
直径::70

## end
#1513, 14:
+[返回目录]
+[内容]

## end
#1514, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1516, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1517, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1519, 46:
线颜色::0,0,0
线型::DashLine
线粗细::2
焦点::0.7
直径::70

## end
#1525, 37:
833.8418364467149, 346.18431379878376
## end
#1526, 36:
972.9779361785412, 162.3415312943341
## end
#1527, 7:
255,0,0
## end
#1528, 1:
1
## end
#1529, 9:
SolidLine
## end
#1531, 149:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10

面颜色::255,255,255
线颜色::0,0,0
线型::SolidLine
线粗细::2

画图:...
选中区域:...
HTML:...



## end
#1544, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#1550, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#1551, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#1552, 2:
矩形
## end
#1553, 231:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


## end
#1556, 14:
+[返回目录]
+[内容]

## end
#1557, 754:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细
        if('%线型'==='DashLine') {
            ctx.setLineDash([5,5])
        };
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

ctx.setLineDash([])

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1560, 14:
+[返回目录]
+[内容]

## end
#1561, 101:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100

## end
#1570, 11:
255,255,255
## end
#1571, 5:
0,0,0
## end
#1572, 9:
SolidLine
## end
#1573, 1:
2
## end
#1574, 2:
你好
## end
#1575, 2:
10
## end
#1576, 39:
-860.6789643837382, -131.11579201271815
## end
#1577, 12:
246.0, 157.0
## end
#1579, 3:
0.4
## end
#1581, 2:
70
## end
#1585, 4:
1587
## end
#1587, 4:
1714
## end
#1590, 172:
+[返回目录](,光栅)
+[设置结构](,光栅)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::光栅
图形::光栅
闪耀角::30
光栅数目::3


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...


## end
#1604, 1298:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""

pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10
N=光栅数目[0]
blaze=闪耀角[0]


lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

L=2*r/N
angle=np.deg2rad(blaze)

dr1=np.cos(angle)*dx-np.sin(angle)*dy
dr2=dx

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt4[0]]
y=[pt4[1]]
pt_i=pt4
for i in range(int(N)):
    pt_i1=pt_i+dr1*np.cos(angle)*L
    pt_i=pt_i+dr2*L
    x+=[pt_i1[0],pt_i[0]]
    y+=[pt_i1[1],pt_i[1]]
x+=[pt1[0],pt2[0],pt3[0],pt4[0]]
y+=[pt1[1],pt2[1],pt3[1],pt4[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#1610, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#1611, 1298:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""

pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10
N=光栅数目[0]
blaze=闪耀角[0]


lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

L=2*r/N
angle=np.deg2rad(blaze)

dr1=np.cos(angle)*dx-np.sin(angle)*dy
dr2=dx

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt4[0]]
y=[pt4[1]]
pt_i=pt4
for i in range(int(N)):
    pt_i1=pt_i+dr1*np.cos(angle)*L
    pt_i=pt_i+dr2*L
    x+=[pt_i1[0],pt_i[0]]
    y+=[pt_i1[1],pt_i[1]]
x+=[pt1[0],pt2[0],pt3[0],pt4[0]]
y+=[pt1[1],pt2[1],pt3[1],pt4[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#1612, 2:
圆形
## end
#1613, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#1616, 14:
+[返回目录]
+[内容]

## end
#1617, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#1620, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1622, 96:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子
闪耀角::30
光栅数目::3

## end
#1632, 2:
10
## end
#1633, 36:
762.0499467844676, 184.0010120246174
## end
#1634, 16:
78.2464212343558
## end
#1635, 18:
31.366191259065204
## end
#1636, 11:
150,150,150
## end
#1637, 5:
0,0,0
## end
#1638, 8:
DashLine
## end
#1639, 1:
2
## end
#1640, 2:
光栅
## end
#1642, 2:
光栅
## end
#1644, 2:
10
## end
#1646, 1:
6
## end
#1650, 176:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::凹面镜
球面半径::100


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

+[创建输入](球面半径,画图)
## end
#1664, 1232:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10
R=球面半径[0]
if R<r:
    R=r

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])


pt0=np.array(pt)
pt1=pt0+dx*r+dy*d
pt2=pt0-dx*r+dy*d

x=[pt2[0]]
y=[pt2[1]]

Dangle=np.arcsin(r/R)
angles=np.linspace(-Dangle,Dangle,100)
pt_i0=np.array(pt)-R*dy
for angle in angles:
    pt_i=pt_i0+R*np.cos(angle)*dy+R*np.sin(angle)*dx
    x.append(pt_i[0])
    y.append(pt_i[1])

x+=[pt1[0],pt2[0]]
y+=[pt1[1],pt2[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#1670, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#1671, 1262:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10
R=球面半径[0]
if R<r:
    R=r

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])


pt0=np.array(pt)
pt1=pt0+dx*r+dy*d
pt2=pt0-dx*r+dy*d

x=[pt2[0]]
y=[pt2[1]]

Dangle=np.arcsin(r/R)
angles=np.linspace(-Dangle,Dangle,100)
pt_i0=np.array(pt)-R*dy
for angle in angles:
    pt_i=pt_i0+R*np.cos(angle)*dy+R*np.sin(angle)*dx
    x.append(pt_i[0])
    y.append(pt_i[1])

x+=[pt1[0],pt2[0]]
y+=[pt1[1],pt2[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#1672, 2:
圆形
## end
#1673, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#1676, 14:
+[返回目录]
+[内容]

## end
#1677, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#1680, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1682, 90:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子
球面半径::100

## end
#1692, 2:
10
## end
#1693, 37:
610.5856990812765, 280.63513985343536
## end
#1694, 17:
40.63902511438941
## end
#1695, 18:
-19.65382405805335
## end
#1696, 11:
255,255,255
## end
#1697, 5:
0,0,0
## end
#1698, 8:
DashLine
## end
#1699, 1:
2
## end
#1700, 3:
凹面镜
## end
#1702, 3:
100
## end
#1705, 7246:
"""
+[返回目录](,创建光栅)

"""


+创建光栅#0(,_光栅#62)->+[del]#1(,+创建光栅#0)...


...............................................
->+[临时文本]#2"+[返回目录](,光栅)
+[设置结构](,光栅)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::光栅
图形::光栅
闪耀角::30
光栅数目::3


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

"(,)...
...............................................


->+[修改内容]#3(+[临时文本]#2,_光栅#62)->+光栅数目#4"6"(,)->+闪耀角#5"10"(,)->+图形#6"光栅"(,)->+名字#7"光栅"(,)->+线粗细#8"2"(,)...


...............................................
->+线型#9"DashLine"(,)...
...............................................





...............................................
->+线颜色#10"0,0,0"(,)...
...............................................





...............................................
->+面颜色#11"150,150,150"(,)...
...............................................





...............................................
->+角度#12"31.366191259065204"(,)...
...............................................





...............................................
->+半径#13"78.2464212343558"(,)...
...............................................





...............................................
->+中心#14"762.0499467844676, 184.0010120246174"(,)...
...............................................


->+厚度#15"10"(,)->+的#16(+输入#27,+光栅数目#4)->+的#17(+输入#27,+闪耀角#5)->+的#18(+输入#27,+名字#7)->+的#19(+输入#27,+线粗细#8)->+的#20(+输入#27,+线型#9)->+的#21(+输入#27,+线颜色#10)->+的#22(+输入#27,+面颜色#11)->+的#23(+输入#27,+角度#12)->+的#24(+输入#27,+半径#13)->+的#25(+输入#27,+中心#14)->+的#26(+输入#27,+厚度#15)...


...............................................
->+输入#27"+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子
闪耀角::30
光栅数目::3
"(,)...
...............................................


->+的#28(+HTML#29,+输入#27)...


...............................................
->+HTML#29"/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/"(,)...
...............................................


->+的#30(+输入#32,+半径#13)->+的#31(+输入#32,+中心#14)...


...............................................
->+输入#32"+[返回目录](,输入)
+[内容]
中心::200,100
半径::100
"(,)...
...............................................





...............................................
->+输出#33"+[返回目录]
+[内容]
"(,)...
...............................................


->+的#34(+选中区域#36,+输入#32)->+的#35(+选中区域#36,+输出#33)...


...............................................
->+选中区域#36"\"\"\"
+[返回目录](,选中区域)
输入:...

\"\"\"

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False"(,)...
...............................................


->+类型#37"圆形"(,)...


...............................................
->+图形#38"\"\"\"
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

\"\"\"

pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10
N=光栅数目[0]
blaze=闪耀角[0]


lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

L=2*r/N
angle=np.deg2rad(blaze)

dr1=np.cos(angle)*dx-np.sin(angle)*dy
dr2=dx

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt4[0]]
y=[pt4[1]]
pt_i=pt4
for i in range(int(N)):
    pt_i1=pt_i+dr1*np.cos(angle)*L
    pt_i=pt_i+dr2*L
    x+=[pt_i1[0],pt_i[0]]
    y+=[pt_i1[1],pt_i[1]]
x+=[pt1[0],pt2[0],pt3[0],pt4[0]]
y+=[pt1[1],pt2[1],pt3[1],pt4[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont(\"Decorative\",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)


"(,)...
...............................................





...............................................
->+选中框#39"\"\"\"
+[返回目录](,选中框)

\"\"\"

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))


"(,)...
...............................................


->+输出#40(,)->+的#41(+画图#45,+图形#38)->+的#42(+画图#45,+选中框#39)->+的#43(+画图#45,+输出#40)->+的#44(+画图#45,+输入#27)...


...............................................
->+画图#45"\"\"\"
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

\"\"\"

pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10
N=光栅数目[0]
blaze=闪耀角[0]


lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

L=2*r/N
angle=np.deg2rad(blaze)

dr1=np.cos(angle)*dx-np.sin(angle)*dy
dr2=dx

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt4[0]]
y=[pt4[1]]
pt_i=pt4
for i in range(int(N)):
    pt_i1=pt_i+dr1*np.cos(angle)*L
    pt_i=pt_i+dr2*L
    x+=[pt_i1[0],pt_i[0]]
    y+=[pt_i1[1],pt_i[1]]
x+=[pt1[0],pt2[0],pt3[0],pt4[0]]
y+=[pt1[1],pt2[1],pt3[1],pt4[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont(\"Decorative\",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)


"(,)...
...............................................


->+的#46(_光栅#62,+光栅数目#4)->+的#47(_光栅#62,+闪耀角#5)->+的#48(_光栅#62,+图形#6)->+的#49(_光栅#62,+名字#7)->+的#50(_光栅#62,+HTML#29)->+的#51(_光栅#62,+线粗细#8)->+的#52(_光栅#62,+线型#9)->+的#53(_光栅#62,+线颜色#10)->+的#54(_光栅#62,+面颜色#11)->+的#55(_光栅#62,+选中区域#36)->+的#56(_光栅#62,+角度#12)->+的#57(_光栅#62,+类型#37)->+的#58(_光栅#62,+画图#45)->+的#59(_光栅#62,+半径#13)->+的#60(_光栅#62,+中心#14)->+的#61(_光栅#62,+厚度#15)->_光栅#62(,)
## end
#1707, 7217:
"""
+[返回目录](,创建光线)

"""


+创建光线#0(,_光线#53)->+[del]#1(,+创建光线#0)...


...............................................
->+[临时文本]#2"+[返回目录](,光线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

焦点::0.7
直径::70

画图:...
选中区域:...
HTML:...
+[创建输入](直径,选中区域)
的(画图,输入)->+[有](HTML,输入)
"(,)...
...............................................


->+[修改内容]#3(+[临时文本]#2,_光线#53)->+直径#4"70"(,)->+焦点#5"0.4"(,)...


...............................................
->+线型#6"SolidLine"(,)...
...............................................


->+线粗细#7"1"(,)...


...............................................
->+线颜色#8"255,0,0"(,)...
...............................................





...............................................
->+终点#9"972.9779361785412, 162.3415312943341"(,)...
...............................................





...............................................
->+起点#10"833.8418364467149, 346.18431379878376"(,)...
...............................................


->+的#11(+输入#18,+直径#4)->+的#12(+输入#18,+焦点#5)->+的#13(+输入#18,+线粗细#7)->+的#14(+输入#18,+线型#6)->+的#15(+输入#18,+线颜色#8)->+的#16(+输入#18,+终点#9)->+的#17(+输入#18,+起点#10)...


...............................................
->+输入#18"线颜色::0,0,0
线型::DashLine
线粗细::2
焦点::0.7
直径::70
"(,)...
...............................................


->+的#19(+HTML#20,+输入#18)...


...............................................
->+HTML#20"/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/"(,)...
...............................................





...............................................
->+LaTeX数学记号#21"https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols"(,)...
...............................................


->+的#22(+点线公式#23,+LaTeX数学记号#21)...


...............................................
->+点线公式#23"<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type=\"text/javascript\" src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML\"></script>
  </head>
  <body>
    <p><mathjax style=\"font-size:1.5em\">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>
"(,)...
...............................................





...............................................
->+输出#24"+[返回目录]
+[内容]
"(,)...
...............................................


->+的#25(+输入#28,+直径#4)->+的#26(+输入#28,+终点#9)->+的#27(+输入#28,+起点#10)...


...............................................
->+输入#28"+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0
直径::70
"(,)...
...............................................


->+的#29(+选中区域#32,+点线公式#23)->+的#30(+选中区域#32,+输出#24)->+的#31(+选中区域#32,+输入#28)...


...............................................
->+选中区域#32"\"\"\"
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

\"\"\"

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and (d<直径[0]/4 or d<5):
    state=True
else:
    state=False
"(,)...
...............................................


->+类型#33"直线"(,)...


...............................................
->+选中框#34"\"\"\"
+[返回目录](,选中框)

\"\"\"
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))"(,)...
...............................................





...............................................
->+图形#35"\"\"\"
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

\"\"\"
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())

"(,)...
...............................................


->+输出#36(,)->+的#37(+画图#41,+选中框#34)->+的#38(+画图#41,+图形#35)->+的#39(+画图#41,+输出#36)->+的#40(+画图#41,+输入#18)...


...............................................
->+画图#41"\"\"\"
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

\"\"\"
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())

"(,)...
...............................................


->+的#42(_光线#53,+直径#4)->+的#43(_光线#53,+焦点#5)->+的#44(_光线#53,+线型#6)->+的#45(_光线#53,+HTML#20)->+的#46(_光线#53,+线粗细#7)->+的#47(_光线#53,+线颜色#8)->+的#48(_光线#53,+选中区域#32)->+的#49(_光线#53,+类型#33)->+的#50(_光线#53,+画图#41)->+的#51(_光线#53,+终点#9)->+的#52(_光线#53,+起点#10)->_光线#53(,)
## end
#1709, 7037:
"""
+[返回目录](,创建凹面镜)

"""


+创建凹面镜#0(,_凹面镜#57)->+[del]#1(,+创建凹面镜#0)...


...............................................
->+[临时文本]#2"+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::凹面镜
球面半径::100


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

+[创建输入](球面半径,画图)"(,)...
...............................................


->+[修改内容]#3(+[临时文本]#2,_凹面镜#57)->+球面半径#4"100"(,)->+名字#5"凹面镜"(,)->+线粗细#6"2"(,)...


...............................................
->+线型#7"DashLine"(,)...
...............................................





...............................................
->+线颜色#8"0,0,0"(,)...
...............................................





...............................................
->+面颜色#9"255,255,255"(,)...
...............................................





...............................................
->+角度#10"-19.65382405805335"(,)...
...............................................





...............................................
->+半径#11"40.63902511438941"(,)...
...............................................





...............................................
->+中心#12"610.5856990812765, 280.63513985343536"(,)...
...............................................


->+厚度#13"10"(,)->+的#14(+输入#24,+球面半径#4)->+的#15(+输入#24,+名字#5)->+的#16(+输入#24,+线粗细#6)->+的#17(+输入#24,+线型#7)->+的#18(+输入#24,+线颜色#8)->+的#19(+输入#24,+面颜色#9)->+的#20(+输入#24,+角度#10)->+的#21(+输入#24,+半径#11)->+的#22(+输入#24,+中心#12)->+的#23(+输入#24,+厚度#13)...


...............................................
->+输入#24"+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子
球面半径::100
"(,)...
...............................................


->+的#25(+HTML#26,+输入#24)...


...............................................
->+HTML#26"/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/"(,)...
...............................................


->+的#27(+输入#29,+半径#11)->+的#28(+输入#29,+中心#12)...


...............................................
->+输入#29"+[返回目录](,输入)
+[内容]
中心::200,100
半径::100
"(,)...
...............................................





...............................................
->+输出#30"+[返回目录]
+[内容]
"(,)...
...............................................


->+的#31(+选中区域#33,+输入#29)->+的#32(+选中区域#33,+输出#30)...


...............................................
->+选中区域#33"\"\"\"
+[返回目录](,选中区域)
输入:...

\"\"\"

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False"(,)...
...............................................


->+类型#34"圆形"(,)...


...............................................
->+图形#35"\"\"\"
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

\"\"\"
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10
R=球面半径[0]
if R<r:
    R=r

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])


pt0=np.array(pt)
pt1=pt0+dx*r+dy*d
pt2=pt0-dx*r+dy*d

x=[pt2[0]]
y=[pt2[1]]

Dangle=np.arcsin(r/R)
angles=np.linspace(-Dangle,Dangle,100)
pt_i0=np.array(pt)-R*dy
for angle in angles:
    pt_i=pt_i0+R*np.cos(angle)*dy+R*np.sin(angle)*dx
    x.append(pt_i[0])
    y.append(pt_i[1])

x+=[pt1[0],pt2[0]]
y+=[pt1[1],pt2[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont(\"Decorative\",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)


"(,)...
...............................................





...............................................
->+选中框#36"\"\"\"
+[返回目录](,选中框)

\"\"\"

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))


"(,)...
...............................................


->+输出#37(,)->+的#38(+画图#42,+图形#35)->+的#39(+画图#42,+选中框#36)->+的#40(+画图#42,+输出#37)->+的#41(+画图#42,+输入#24)...


...............................................
->+画图#42"\"\"\"
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

\"\"\"
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10
R=球面半径[0]
if R<r:
    R=r

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])


pt0=np.array(pt)
pt1=pt0+dx*r+dy*d
pt2=pt0-dx*r+dy*d

x=[pt2[0]]
y=[pt2[1]]

Dangle=np.arcsin(r/R)
angles=np.linspace(-Dangle,Dangle,100)
pt_i0=np.array(pt)-R*dy
for angle in angles:
    pt_i=pt_i0+R*np.cos(angle)*dy+R*np.sin(angle)*dx
    x.append(pt_i[0])
    y.append(pt_i[1])

x+=[pt1[0],pt2[0]]
y+=[pt1[1],pt2[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont(\"Decorative\",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)


"(,)...
...............................................


->+的#43(_凹面镜#57,+球面半径#4)->+的#44(_凹面镜#57,+名字#5)->+的#45(_凹面镜#57,+HTML#26)->+的#46(_凹面镜#57,+线粗细#6)->+的#47(_凹面镜#57,+线型#7)->+的#48(_凹面镜#57,+线颜色#8)->+的#49(_凹面镜#57,+面颜色#9)->+的#50(_凹面镜#57,+选中区域#33)->+的#51(_凹面镜#57,+角度#10)->+的#52(_凹面镜#57,+类型#34)->+的#53(_凹面镜#57,+画图#42)->+的#54(_凹面镜#57,+半径#11)->+的#55(_凹面镜#57,+中心#12)->+的#56(_凹面镜#57,+厚度#13)->_凹面镜#57(,)
## end
#1710, 4:
1712
## end
#1712, 4:
1714
## end
#1714, 4:
1716
## end
#1716, 4:
1718
## end
#1718, 4:
1720
## end
#1720, 4:
1782
## end
#1722, 3:
100
## end
#1723, 2:
50
## end
#1724, 7:
255,0,0
## end
#1725, 3:
凹面镜
## end
#1726, 1:
2
## end
#1727, 8:
DashLine
## end
#1728, 5:
0,0,0
## end
#1729, 17:
74.21924669048461
## end
#1730, 12:
599.0, 185.0
## end
#1731, 2:
10
## end
#1742, 90:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子
球面半径::100

## end
#1744, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1747, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#1748, 14:
+[返回目录]
+[内容]

## end
#1751, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#1752, 2:
圆形
## end
#1753, 951:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10
R1=内部半径[0]
R2=r

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


angles=np.linspace(angle,angle+360,100)
alphas=np.deg2rad(angles)

x=[]
y=[]
for alpha in alphas:
    x.append(pt[0]+R1*np.cos(alpha))
    y.append(pt[1]-R1*np.sin(alpha))
for alpha in alphas:
    x.append(pt[0]+R2*np.cos(alpha))
    y.append(pt[1]-R2*np.sin(alpha))




path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())





## end
#1754, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#1760, 951:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10
R1=内部半径[0]
R2=r

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


angles=np.linspace(angle,angle+360,100)
alphas=np.deg2rad(angles)

x=[]
y=[]
for alpha in alphas:
    x.append(pt[0]+R1*np.cos(alpha))
    y.append(pt[1]-R1*np.sin(alpha))
for alpha in alphas:
    x.append(pt[0]+R2*np.cos(alpha))
    y.append(pt[1]-R2*np.sin(alpha))




path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())





## end
#1775, 199:
+[返回目录](,iris)
+[设置结构](,iris)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::iris
内部半径::50
+[修改标题]"内部半径"(,球面半径)


面颜色::255,0,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

+[创建输入](球面半径,画图)
## end
#1778, 6869:
"""
+[返回目录](,创建iris)

"""


+创建iris#0(,_iris#57)->+[del]#1(,+创建iris#0)...


...............................................
->+[临时文本]#2"+[返回目录](,iris)
+[设置结构](,iris)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::iris
内部半径::50
+[修改标题]\"内部半径\"(,球面半径)


面颜色::255,0,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

+[创建输入](球面半径,画图)"(,)...
...............................................


->+[修改内容]#3(+[临时文本]#2,_iris#57)->+厚度#4"10"(,)...


...............................................
->+中心#5"599.0, 185.0"(,)...
...............................................


->+半径#6"100"(,)...


...............................................
->+角度#7"74.21924669048461"(,)...
...............................................





...............................................
->+面颜色#8"255,0,0"(,)...
...............................................





...............................................
->+线颜色#9"0,0,0"(,)...
...............................................





...............................................
->+线型#10"DashLine"(,)...
...............................................


->+线粗细#11"2"(,)->+名字#12"凹面镜"(,)->+内部半径#13"50"(,)->+的#14(+输入#24,+厚度#4)->+的#15(+输入#24,+中心#5)->+的#16(+输入#24,+半径#6)->+的#17(+输入#24,+角度#7)->+的#18(+输入#24,+面颜色#8)->+的#19(+输入#24,+线颜色#9)->+的#20(+输入#24,+线型#10)->+的#21(+输入#24,+线粗细#11)->+的#22(+输入#24,+名字#12)->+的#23(+输入#24,+内部半径#13)...


...............................................
->+输入#24"+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子
球面半径::100
"(,)...
...............................................


->+输出#25(,)...


...............................................
->+选中框#26"\"\"\"
+[返回目录](,选中框)

\"\"\"

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))


"(,)...
...............................................





...............................................
->+图形#27"\"\"\"
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

\"\"\"
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10
R1=内部半径[0]
R2=r

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


angles=np.linspace(angle,angle+360,100)
alphas=np.deg2rad(angles)

x=[]
y=[]
for alpha in alphas:
    x.append(pt[0]+R1*np.cos(alpha))
    y.append(pt[1]-R1*np.sin(alpha))
for alpha in alphas:
    x.append(pt[0]+R2*np.cos(alpha))
    y.append(pt[1]-R2*np.sin(alpha))




path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())




"(,)...
...............................................


->+的#28(+画图#32,+输入#24)->+的#29(+画图#32,+输出#25)->+的#30(+画图#32,+选中框#26)->+的#31(+画图#32,+图形#27)...


...............................................
->+画图#32"\"\"\"
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

\"\"\"
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10
R1=内部半径[0]
R2=r

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


angles=np.linspace(angle,angle+360,100)
alphas=np.deg2rad(angles)

x=[]
y=[]
for alpha in alphas:
    x.append(pt[0]+R1*np.cos(alpha))
    y.append(pt[1]-R1*np.sin(alpha))
for alpha in alphas:
    x.append(pt[0]+R2*np.cos(alpha))
    y.append(pt[1]-R2*np.sin(alpha))




path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())




\"\"\"
+[返回目录](,选中框)

\"\"\"

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))


"(,)...
...............................................


->+类型#33"圆形"(,)...


...............................................
->+输出#34"+[返回目录]
+[内容]
"(,)...
...............................................


->+的#35(+输入#37,+中心#5)->+的#36(+输入#37,+半径#6)...


...............................................
->+输入#37"+[返回目录](,输入)
+[内容]
中心::200,100
半径::100
"(,)...
...............................................


->+的#38(+选中区域#40,+输出#34)->+的#39(+选中区域#40,+输入#37)...


...............................................
->+选中区域#40"\"\"\"
+[返回目录](,选中区域)
输入:...

\"\"\"

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False"(,)...
...............................................


->+的#41(+HTML#42,+输入#24)...


...............................................
->+HTML#42"/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/"(,)...
...............................................


->+的#43(_iris#57,+厚度#4)->+的#44(_iris#57,+中心#5)->+的#45(_iris#57,+画图#32)->+的#46(_iris#57,+类型#33)->+的#47(_iris#57,+角度#7)->+的#48(_iris#57,+选中区域#40)->+的#49(_iris#57,+线颜色#9)->+的#50(_iris#57,+线型#10)->+的#51(_iris#57,+线粗细#11)->+的#52(_iris#57,+HTML#42)->+的#53(_iris#57,+名字#12)->+的#54(_iris#57,+面颜色#8)->+的#55(_iris#57,+内部半径#13)->+的#56(_iris#57,+半径#6)->_iris#57(,)
## end
#1779, 4:
1781
## end
#1781, 4:
1834
## end
#1784, 171:
+[返回目录](,圆形)

中心::200,100
半径::100
类型::圆形
角度::0
起始角度::30


面颜色::255,255,0
线颜色::None
线型::SolidLine
线粗细::2

画图:...
选中区域:...
HTML:...
+[创建输入](起始角度,画图)
的(画图,输入)->+[有](HTML,输入)

## end
#1796, 519:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.beginPath();
ctx.arc(%中心,%半径,0,2*Math.PI)

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fill();
}

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(0,0,0)';
} else {
        ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        if('%线型'==='DashLine') {
            ctx.setLineDash([5,5])
        }
        ctx.stroke();
}

ctx.setLineDash([])

//ctx.stroke()

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1798, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#1801, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#1804, 14:
+[返回目录]
+[内容]

## end
#1805, 2:
圆形
## end
#1806, 760:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
angle_0=起始角度[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型


if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


an=np.linspace(angle_0,angle,20)
t=np.deg2rad(an)
x=pt[0]+r*np.cos(t)
y=pt[1]-r*np.sin(t)


path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())





## end
#1811, 760:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
angle_0=起始角度[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型


if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


an=np.linspace(angle_0,angle,20)
t=np.deg2rad(an)
x=pt[0]+r*np.cos(t)
y=pt[1]-r*np.sin(t)


path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())





## end
#1812, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#1814, 75:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
起始角度::30

## end
#1822, 1:
2
## end
#1823, 9:
SolidLine
## end
#1824, 5:
0,0,0
## end
#1825, 4:
None
## end
#1826, 2:
45
## end
#1827, 17:
75.23961722390672
## end
#1828, 36:
5.387056591059931, 291.9194151134101
## end
#1830, 3:
-45
## end
#1833, 5492:
"""
+[返回目录](,创建圆弧)

"""


+创建圆弧#0(,_圆弧#51)->+[del]#1(,+创建圆弧#0)...


...............................................
->+[临时文本]#2"+[返回目录](,圆形)

中心::200,100
半径::100
类型::圆形
角度::0
起始角度::30


面颜色::255,255,0
线颜色::None
线型::SolidLine
线粗细::2

画图:...
选中区域:...
HTML:...
+[创建输入](起始角度,画图)
的(画图,输入)->+[有](HTML,输入)
"(,)...
...............................................


->+[修改内容]#3(+[临时文本]#2,_圆弧#51)->+起始角度#4"-45"(,)...


...............................................
->+中心#5"5.387056591059931, 291.9194151134101"(,)...
...............................................





...............................................
->+半径#6"75.23961722390672"(,)...
...............................................


->+角度#7"45"(,)->+面颜色#8"None"(,)...


...............................................
->+线颜色#9"0,0,0"(,)...
...............................................





...............................................
->+线型#10"SolidLine"(,)...
...............................................


->+线粗细#11"2"(,)->+的#12(+输入#20,+起始角度#4)->+的#13(+输入#20,+中心#5)->+的#14(+输入#20,+半径#6)->+的#15(+输入#20,+角度#7)->+的#16(+输入#20,+面颜色#8)->+的#17(+输入#20,+线颜色#9)->+的#18(+输入#20,+线型#10)->+的#19(+输入#20,+线粗细#11)...


...............................................
->+输入#20"+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
起始角度::30
"(,)...
...............................................


->+输出#21(,)...


...............................................
->+选中框#22"\"\"\"
+[返回目录](,选中框)

\"\"\"

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))


"(,)...
...............................................





...............................................
->+图形#23"\"\"\"
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

\"\"\"
pt=中心
r=半径[0]
angle_0=起始角度[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型


if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


an=np.linspace(angle_0,angle,20)
t=np.deg2rad(an)
x=pt[0]+r*np.cos(t)
y=pt[1]-r*np.sin(t)


path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())




"(,)...
...............................................


->+的#24(+画图#28,+输入#20)->+的#25(+画图#28,+输出#21)->+的#26(+画图#28,+选中框#22)->+的#27(+画图#28,+图形#23)...


...............................................
->+画图#28"\"\"\"
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

\"\"\"
pt=中心
r=半径[0]
angle_0=起始角度[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型


if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


an=np.linspace(angle_0,angle,20)
t=np.deg2rad(an)
x=pt[0]+r*np.cos(t)
y=pt[1]-r*np.sin(t)


path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())




"(,)...
...............................................


->+类型#29"圆形"(,)...


...............................................
->+输出#30"+[返回目录]
+[内容]
"(,)...
...............................................


->+的#31(+输入#33,+中心#5)->+的#32(+输入#33,+半径#6)...


...............................................
->+输入#33"+[返回目录](,输入)
+[内容]
中心::200,100
半径::100
"(,)...
...............................................


->+的#34(+选中区域#36,+输出#30)->+的#35(+选中区域#36,+输入#33)...


...............................................
->+选中区域#36"\"\"\"
+[返回目录](,选中区域)
输入:...

\"\"\"

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False"(,)...
...............................................


->+的#37(+HTML#38,+输入#20)...


...............................................
->+HTML#38"/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.beginPath();
ctx.arc(%中心,%半径,0,2*Math.PI)

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fill();
}

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(0,0,0)';
} else {
        ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        if('%线型'==='DashLine') {
            ctx.setLineDash([5,5])
        }
        ctx.stroke();
}

ctx.setLineDash([])

//ctx.stroke()

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/"(,)...
...............................................


->+的#39(_圆弧#51,+起始角度#4)->+的#40(_圆弧#51,+中心#5)->+的#41(_圆弧#51,+半径#6)->+的#42(_圆弧#51,+画图#28)->+的#43(_圆弧#51,+类型#29)->+的#44(_圆弧#51,+角度#7)->+的#45(_圆弧#51,+选中区域#36)->+的#46(_圆弧#51,+面颜色#8)->+的#47(_圆弧#51,+线颜色#9)->+的#48(_圆弧#51,+线型#10)->+的#49(_圆弧#51,+线粗细#11)->+的#50(_圆弧#51,+HTML#38)->_圆弧#51(,)
## end
#1835, 63:
"""
+[返回目录](,更新)

"""

+更新(,_动词)->+[del](,+更新)...
->的(更新,词典)



## end
#1836, 4:
1838
## end
#1838, 4:
1840
## end
#1840, 4:
1842
## end
### 结束