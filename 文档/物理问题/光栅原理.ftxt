### 节点
地址, 的, 光栅原理, 目录, 的, 的, 节点数目统计, 20210411, 的, 的, 几何画图, 的, 光栅图示, 的, 光栅平面, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线型, 线粗细, 的, 法线1, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, pt12, pt11, pt02, 的, 的, 的, 输入, 等于, pt01, 的, 输出, 的, 的, P代码, pt11, 线粗细, 线型, 线颜色, 是, 终点, 起点, 的, 的, 的, 的, 的, 的, 输入, 的, HTML, LaTeX数学记号, 的, 点线公式, 输出, 的, 的, 输入, 的, 的, 的, 选中区域, 类型, 选中框, 图形, 输出, 的, 的, 的, 的, 画图, 是, 是, 是, 是, 比例, 的, 尺寸, 的, 原点, 的, 坐标系, 的, 法线2, 等于, 是, 是, 是, 是, 是, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, pt12, pt11, pt02, 的, 的, 的, 输入, 等于, pt01, 的, 输出, 的, 的, P代码, pt11, 线粗细, 线型, 线颜色, 是, 终点, 起点, 的, 的, 的, 的, 的, 的, 输入, 的, HTML, LaTeX数学记号, 的, 点线公式, 输出, 的, 的, 输入, 的, 的, 的, 选中区域, 类型, 选中框, 图形, 输出, 的, 的, 的, 的, 画图, 是, 是, 是, 是, 的, 入射光1, 的, 入射光2, 的, 出射光1, 的, 出射光2, 的, alpha1, 的, beta1, 的, alpha2, 的, beta2, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线型, 线粗细, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线型, 线粗细, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线型, 线粗细, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线型, 线粗细, 矩形, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 选中区域, 的, 的, 输出, HTML, 的, 的, 输出, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 起点, 尺寸, 类型, 文字, 字体, 线型, 线粗细, 面颜色, 线颜色, 的, A, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, pt12, pt11, pt02, 的, 的, 的, 输入, 等于, pt01, 的, 输出, 的, 的, P代码, pt11, 线粗细, 线型, 线颜色, 是, 终点, 起点, 的, 的, 的, 的, 的, 的, 输入, 的, HTML, LaTeX数学记号, 的, 点线公式, 输出, 的, 的, 输入, 的, 的, 的, 选中区域, 类型, 选中框, 图形, 输出, 的, 的, 的, 的, 画图, 是, 是, 是, 是, 的, B, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, pt12, pt11, pt02, 的, 的, 的, 输入, 等于, pt01, 的, 输出, 的, 的, P代码, pt11, 线粗细, 线型, 线颜色, 是, 终点, 起点, 的, 的, 的, 的, 的, 的, 输入, 的, HTML, LaTeX数学记号, 的, 点线公式, 输出, 的, 的, 输入, 的, 的, 的, 选中区域, 类型, 选中框, 图形, 输出, 的, 的, 的, 的, 画图, 是, 是, 是, 是, 的, 正文, html, 的, 的, 光谱宽度, M函数, 的, 公式, html, 的, 波长与出射角, 20210425, 的, 的, 画板, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 起始角度, 半径, 中心, 数值, 标记, 的, 的, 的, 的, 的, 输入, 的, HTML, 的, 画图, 等于, pt11, 等于, pt12, 等于, pt21, 等于, pt22, 等于, angle, 的, 的, 的, 的, 的, 的, 的, 输出, 的, 的, 的, 的, 的, 的, 的, 输入, 的, 的, P代码, 类型, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 起始角度, 半径, 中心, 数值, 标记, 的, 的, 的, 的, 的, 输入, 的, HTML, 的, 画图, 等于, pt11, 等于, pt12, 等于, pt21, 等于, pt22, 等于, angle, 的, 的, 的, 的, 的, 的, 的, 输出, 的, 的, 的, 的, 的, 的, 的, 输入, 的, 的, P代码, 类型, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 起始角度, 半径, 中心, 数值, 标记, 的, 的, 的, 的, 的, 输入, 的, HTML, 的, 画图, 等于, pt11, 等于, pt12, 等于, pt21, 等于, pt22, 等于, angle, 的, 的, 的, 的, 的, 的, 的, 输出, 的, 的, 的, 的, 的, 的, 的, 输入, 的, 的, P代码, 类型, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 起始角度, 半径, 中心, 数值, 标记, 的, 的, 的, 的, 的, 输入, 的, HTML, 的, 画图, 等于, pt11, 等于, pt12, 等于, pt21, 等于, pt22, 等于, angle, 的, 的, 的, 的, 的, 的, 的, 输出, 的, 的, 的, 的, 的, 的, 的, 输入, 的, 的, P代码, 类型, 的, 波包, 参考2, 参考, 位移距离, 文字, 线粗细, 线型, 线颜色, 终点, 起点, 的, 的, 的, 的, 的, 的, 的, 输入, 的, HTML, LaTeX数学记号, 的, 点线公式, 输出, 的, 的, 输入, 的, 的, 的, 选中区域, 类型, 选中框, 图形, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 标记水平距离, 线粗细, 线型, 线颜色, 终点, 起点, 的, 的, 的, 的, 的, 输入, 的, HTML, LaTeX数学记号, 的, 点线公式, 输出, 的, 的, 输入, 的, 的, 的, 选中区域, 类型, 选中框, 图形, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 水平距离, 线颜色, 面颜色, 线粗细, 线型, 字体, 文字, 类型, 尺寸, 起点, 的, 的, 的, 的, 的, 的, 的, 的, 输入, 输出, 的, 的, HTML, 输出, 的, 的, 选中区域, 图形, 选中框, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 矩形, 位移距离, 文字, 线粗细, 线型, 线颜色, 终点, 起点, 的, 的, 的, 的, 的, 的, 的, 输入, 的, HTML, LaTeX数学记号, 的, 点线公式, 输出, 的, 的, 输入, 的, 的, 的, 选中区域, 类型, 选中框, 图形, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 间距, beta, theta, 线粗细, 线型, 线颜色, 终点, 起点, 的, 的, 的, 的, 的, 输入, 的, HTML, LaTeX数学记号, 的, 点线公式, 输出, 的, 的, 输入, 的, 的, 的, 选中区域, 类型, 选中框, 图形, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 法线1, 线粗细, 线型, 线颜色, 终点, 起点, 的, 的, 的, 的, 的, 输入, 的, HTML, LaTeX数学记号, 的, 点线公式, 输出, 的, 的, 输入, 的, 的, 的, 选中区域, 类型, 选中框, 图形, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 出射光线2, 线粗细, 线型, 线颜色, 终点, 起点, 的, 的, 的, 的, 的, 输入, 的, HTML, LaTeX数学记号, 的, 点线公式, 输出, 的, 的, 输入, 的, 的, 的, 选中区域, 类型, 选中框, 图形, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 内部光线2, 线粗细, 线型, 线颜色, 终点, 起点, 的, 的, 的, 的, 的, 输入, 的, HTML, LaTeX数学记号, 的, 点线公式, 输出, 的, 的, 输入, 的, 的, 的, 选中区域, 类型, 选中框, 图形, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 出射光线1, 线粗细, 线型, 线颜色, 终点, 起点, 的, 的, 的, 的, 的, 输入, 的, HTML, LaTeX数学记号, 的, 点线公式, 输出, 的, 的, 输入, 的, 的, 的, 选中区域, 类型, 选中框, 图形, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 内部光线1, 线粗细, 线型, 线颜色, 终点, 起点, 的, 的, 的, 的, 的, 输入, 的, HTML, LaTeX数学记号, 的, 点线公式, 输出, 的, 的, 输入, 的, 的, 的, 选中区域, 类型, 选中框, 图形, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 入射光线, 名字, 线粗细, 线型, 线颜色, 面颜色, 角度, 半径, 中心, 厚度, 的, 的, 的, 的, 的, 的, 的, 的, 的, 输入, 的, HTML, 的, 的, 输入, 输出, 的, 的, 选中区域, 类型, 图形, 选中框, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 光栅2, 名字, 线粗细, 线型, 线颜色, 面颜色, 角度, 半径, 中心, 厚度, 的, 的, 的, 的, 的, 的, 的, 的, 的, 输入, 的, HTML, 的, 的, 输入, 输出, 的, 的, 选中区域, 类型, 图形, 选中框, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 光栅1, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 坐标系, 的, 光栅对, 的, 的, 的, html, 光栅色散, 比例, 的, 尺寸, 的, 原点, 的, 坐标系, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 起始角度, 半径, 中心, 数值, 标记, 的, 的, 的, 的, 的, 输入, 的, HTML, 的, 画图, 等于, pt11, 等于, pt12, 等于, pt21, 等于, pt22, 等于, angle, 的, 的, 的, 的, 的, 的, 的, 输出, 的, 的, 的, 的, 的, 的, 的, 输入, 的, 的, P代码, 类型, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 起始角度, 半径, 中心, 数值, 标记, 的, 的, 的, 的, 的, 输入, 的, HTML, 的, 画图, 等于, pt11, 等于, pt12, 等于, pt21, 等于, pt22, 等于, angle, 的, 的, 的, 的, 的, 的, 的, 输出, 的, 的, 的, 的, 的, 的, 的, 输入, 的, 的, P代码, 类型, 的, 光栅对, 的, 的, 光栅宽度, html, 的, 场景, 的, 光栅A, 的, 光栅B, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 比例, 的, 尺寸, 的, 原点, 的, 坐标系, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 入射光线, 的, 红光, 的, 蓝光, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 的, 法线, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 的, alpha, 的, beta1, 的, beta2, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 起始角度, 半径, 中心, 数值, 标记, 的, 的, 的, 的, 的, 输入, 的, HTML, 的, 画图, 等于, pt11, 等于, pt12, 等于, pt21, 等于, pt22, 等于, angle, 的, 的, 的, 的, 的, 的, 的, 输出, 的, 的, 的, 的, 的, 的, 的, 输入, 的, 的, P代码, 类型, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 起始角度, 半径, 中心, 数值, 标记, 的, 的, 的, 的, 的, 输入, 的, HTML, 的, 画图, 等于, pt11, 等于, pt12, 等于, pt21, 等于, pt22, 等于, angle, 的, 的, 的, 的, 的, 的, 的, 输出, 的, 的, 的, 的, 的, 的, 的, 输入, 的, 的, P代码, 类型, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 起始角度, 半径, 中心, 数值, 标记, 的, 的, 的, 的, 的, 输入, 的, HTML, 的, 画图, 等于, pt11, 等于, pt12, 等于, pt21, 等于, pt22, 等于, angle, 的, 的, 的, 的, 的, 的, 的, 输出, 的, 的, 的, 的, 的, 的, 的, 输入, 的, 的, P代码, 类型, 的, 间距, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线型, 线粗细, 文字, 位移距离, 的, 新窗口, 的, 计算宽度, M函数, 的, 扫二维参数, M函数, 的, 画板, 的, 光栅对比, html, 的, 的, 参考, 参考, 的, 初步感受, M函数, 20210426, 的, 的, 光谱光栅, 的, 光谱仪, 20210427, 的, 的, 闪耀光栅, 的, 参考材料, 的, 定义, html, 的, 场景, 的, 基底, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, HTML, 的, 的, 输出, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 面颜色, 线颜色, 线型, 线粗细, 文字, 字体, 起点, 尺寸, 的, 长边, 的, 短边, 的, 入射光, 的, 出射光, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 线型, 线粗细, 线颜色, 终点, 起点, 的, 的, 的, 的, 的, 输入, 的, HTML, LaTeX数学记号, 的, 点线公式, 输出, 的, 的, 输入, 的, 的, 的, 选中区域, 类型, 选中框, 图形, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 长边, 的, 线型, 线粗细, 线颜色, 终点, 起点, 的, 的, 的, 的, 的, 输入, 的, HTML, LaTeX数学记号, 的, 点线公式, 输出, 的, 的, 输入, 的, 的, 的, 选中区域, 类型, 选中框, 图形, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 短边, 的, 起点, 终点, 线颜色, 线型, 线粗细, 的, 的, 的, 的, 的, 输入, 输出, 图形, 选中框, 的, 的, 的, 的, 画图, 类型, 的, 的, 输入, 输出, LaTeX数学记号, 的, 点线公式, 的, 的, 的, 选中区域, 的, HTML, 的, 的, 的, 的, 的, 的, 的, 的, 的, 长边, 的, 线型, 线粗细, 线颜色, 终点, 起点, 的, 的, 的, 的, 的, 输入, 的, HTML, LaTeX数学记号, 的, 点线公式, 输出, 的, 的, 输入, 的, 的, 的, 选中区域, 类型, 选中框, 图形, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 短边, 的, 的, 法线, 等于, 是, 是, 是, 是, 是, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, pt12, pt11, pt02, 的, 的, 的, 输入, 等于, pt01, 的, 输出, 的, 的, P代码, pt11, 线粗细, 线型, 线颜色, 是, 终点, 起点, 的, 的, 的, 的, 的, 的, 输入, 的, HTML, LaTeX数学记号, 的, 点线公式, 输出, 的, 的, 输入, 的, 的, 的, 选中区域, 类型, 选中框, 图形, 输出, 的, 的, 的, 的, 画图, 是, 是, 是, 是, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 的, a, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 起始角度, 半径, 中心, 数值, 标记, 的, 的, 的, 的, 的, 输入, 的, HTML, 的, 画图, 等于, pt11, 等于, pt12, 等于, pt21, 等于, pt22, 等于, angle, 的, 的, 的, 的, 的, 的, 的, 输出, 的, 的, 的, 的, 的, 的, 的, 输入, 的, 的, P代码, 类型, 比例, 的, 尺寸, 的, 原点, 的, 坐标系, 的, b, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 起始角度, 半径, 中心, 数值, 标记, 的, 的, 的, 的, 的, 输入, 的, HTML, 的, 画图, 等于, pt11, 等于, pt12, 等于, pt21, 等于, pt22, 等于, angle, 的, 的, 的, 的, 的, 的, 的, 输出, 的, 的, 的, 的, 的, 的, 的, 输入, 的, 的, P代码, 类型, 的, 水平线, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 的, c, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 起始角度, 半径, 中心, 数值, 标记, 的, 的, 的, 的, 的, 输入, 的, HTML, 的, 画图, 等于, pt11, 等于, pt12, 等于, pt21, 等于, pt22, 等于, angle, 的, 的, 的, 的, 的, 的, 的, 输出, 的, 的, 的, 的, 的, 的, 的, 输入, 的, 的, P代码, 类型, 的, 计算, M函数, 的, 画板, 的, 光谱宽度, html, 的, 手册, 的, 计算入射角, M函数, 20210504, 的, 20210518, 的, 20210519, 的, 的, 网页画板, 20210713, 的, M函数, 估计compressor, 的, 20210721, 的, 20210722, 的, 的, 验证计算, M函数, 20220721, 的, 的, Reflection_grating, M函数, 的, 例1, 的, 测试, 的, 地址, Reflection_grating, 的, 记忆, 的, 的, Reflection_grating, 中, 
### 关联
#, 2#0, #, #, 3#2, 3#6, #, #, 6#7, 2#10, #, 2#12, #, 12#14, #, 14#52, 14#53, 14#24, 14#32, 14#33, 14#54, 14#55, 14#56, 14#44, #, 24#46, 24#29, 24#30, 24#31, #, #, #, #, #, 33#37, 33#40, 33#41, #, 37#52, 37#53, #, #, 41#43, #, #, 44#46, #, 46#52, 46#53, 46#54, 46#55, 46#56, #, #, #, #, #, 12#58, 14#, 58#89, 58#88, 58#118, 58#110, 58#109, 58#86, 58#85, 58#84, 58#98, 58#82, #, #, #, 75#69, 75#70, 75#71, #, 77#89, #, 79#77, #, 82#75, 82#79, #, #, #, #, #, 88#71, #, #, 96#83, 96#84, 96#85, 96#86, 96#88, 96#89, #, 98#96, #, #, 101#99, #, #, 105#88, 105#89, #, 109#101, 109#102, 109#105, #, #, #, #, #, 118#111, 118#112, 118#113, 118#96, #, 88#71, 52#70, 53#69, 52#83, #, 129#123, #, 129#125, #, 129#127, 12#, 12#131, 14#, #, #, #, 52#, 53#, 52#, 131#168, 131#167, 131#197, 131#189, 131#188, 131#165, 131#164, 131#163, 131#177, 131#161, #, #, #, 154#148, 154#149, 154#150, #, 156#168, #, 158#156, #, 161#154, 161#158, #, #, #, #, #, 167#150, #, #, 175#162, 175#163, 175#164, 175#165, 175#167, 175#168, #, 177#175, #, #, 180#178, #, #, 184#167, 184#168, #, 188#180, 188#181, 188#184, #, #, #, #, #, 197#190, 197#191, 197#192, 197#175, #, 167#150, 52#149, 53#148, 52#162, 12#203, #, 12#205, #, 12#207, #, 12#209, #, 12#211, 203#58, 12#213, 207#58, 12#215, 205#131, 12#217, 209#131, 203#255, 203#256, 203#227, 203#235, 203#236, 203#257, 203#258, 203#259, 203#247, #, 227#249, 227#232, 227#233, 227#234, #, #, #, #, #, 236#240, 236#243, 236#244, #, 240#255, 240#256, #, #, 244#246, #, #, 247#249, #, 249#255, 249#256, 249#257, 249#258, 249#259, #, #, #, #, #, 205#297, 205#298, 205#269, 205#277, 205#278, 205#299, 205#300, 205#301, 205#289, #, 269#291, 269#274, 269#275, 269#276, #, #, #, #, #, 278#282, 278#285, 278#286, #, 282#297, 282#298, #, #, 286#288, #, #, 289#291, #, 291#297, 291#298, 291#299, 291#300, 291#301, #, #, #, #, #, 209#339, 209#340, 209#311, 209#319, 209#320, 209#341, 209#342, 209#343, 209#331, #, 311#333, 311#316, 311#317, 311#318, #, #, #, #, #, 320#324, 320#327, 320#328, #, 324#339, 324#340, #, #, 328#330, #, #, 331#333, #, 333#339, 333#340, 333#341, 333#342, 333#343, #, #, #, #, #, 207#381, 207#382, 207#353, 207#361, 207#362, 207#383, 207#384, 207#385, 207#373, #, 353#375, 353#358, 353#359, 353#360, #, #, #, #, #, 362#366, 362#369, 362#370, #, 366#381, 366#382, #, #, 370#372, #, #, 373#375, #, 375#381, 375#382, 375#383, 375#384, 375#385, #, #, #, #, #, #, 12#386, 386#400, 386#408, 386#412, 386#425, 386#426, 386#427, 386#428, 386#429, 386#430, 386#431, 386#432, 386#433, #, 400#416, 400#405, 400#406, 400#407, #, #, #, #, 408#411, 408#416, #, #, 412#415, 412#416, #, #, 416#432, 416#433, 416#430, 416#431, 416#428, 416#429, 416#426, 416#425, #, #, #, #, #, #, #, #, #, 12#435, 205#, 435#466, 435#465, 435#495, 435#487, 435#486, 435#463, 435#462, 435#461, 435#475, 435#459, #, #, #, 452#446, 452#447, 452#448, #, 454#466, #, 456#454, #, 459#452, 459#456, #, #, #, #, #, 465#448, #, #, 473#460, 473#461, 473#462, 473#463, 473#465, 473#466, #, 475#473, #, #, 478#476, #, #, 482#465, 482#466, #, 486#478, 486#479, 486#482, #, #, #, #, #, 495#488, 495#489, 495#490, 495#473, #, 465#448, 297#447, 298#446, 297#460, 12#501, 207#, 501#532, 501#531, 501#561, 501#553, 501#552, 501#529, 501#528, 501#527, 501#541, 501#525, #, #, #, 518#512, 518#513, 518#514, #, 520#532, #, 522#520, #, 525#518, 525#522, #, #, #, #, #, 531#514, #, #, 539#526, 539#527, 539#528, 539#529, 539#531, 539#532, #, 541#539, #, #, 544#542, #, #, 548#531, 548#532, #, 552#544, 552#545, 552#548, #, #, #, #, #, 561#554, 561#555, 561#556, 561#539, #, 531#514, 381#513, 382#512, 381#526, 2#567, #, 567#, 567#12, 2#571, #, 571#, 571#574, #, 574#, 571#577, #, #, 6#578, 567#581, 12#, 217#604, 217#645, 217#644, 217#625, 217#624, 217#623, 217#622, 217#621, 217#620, 217#619, 217#618, 217#617, 217#616, 217#615, 217#605, 217#613, 217#603, 217#602, 217#601, #, #, #, #, #, 611#604, 611#601, 611#602, 611#603, 611#605, #, 613#611, #, 615#611, #, 617#339, #, 619#340, #, 621#168, #, 623#167, #, 625#604, #, 633#601, 633#603, 633#625, 633#623, 633#621, 633#619, 633#617, #, 641#617, 641#619, 641#621, 641#623, 641#625, 641#603, 641#601, #, 644#633, 644#641, #, #, 213#668, 213#709, 213#708, 213#689, 213#688, 213#687, 213#686, 213#685, 213#684, 213#683, 213#682, 213#681, 213#680, 213#679, 213#669, 213#677, 213#667, 213#666, 213#665, #, #, #, #, #, 675#668, 675#665, 675#666, 675#667, 675#669, #, 677#675, #, 679#675, #, 681#381, #, 683#382, #, 685#89, #, 687#88, #, 689#668, #, 697#665, 697#667, 697#689, 697#687, 697#685, 697#683, 697#681, #, 705#681, 705#683, 705#685, 705#687, 705#689, 705#667, 705#665, #, 708#697, 708#705, #, #, 211#732, 211#773, 211#772, 211#753, 211#752, 211#751, 211#750, 211#749, 211#748, 211#747, 211#746, 211#745, 211#744, 211#743, 211#733, 211#741, 211#731, 211#730, 211#729, #, #, #, #, #, 739#732, 739#729, 739#730, 739#731, 739#733, #, 741#739, #, 743#739, #, 745#255, #, 747#256, #, 749#89, #, 751#88, #, 753#732, #, 761#729, 761#731, 761#753, 761#751, 761#749, 761#747, 761#745, #, 769#745, 769#747, 769#749, 769#751, 769#753, 769#731, 769#729, #, 772#761, 772#769, #, #, 215#796, 215#837, 215#836, 215#817, 215#816, 215#815, 215#814, 215#813, 215#812, 215#811, 215#810, 215#809, 215#808, 215#807, 215#797, 215#805, 215#795, 215#794, 215#793, #, #, #, #, #, 803#796, 803#793, 803#794, 803#795, 803#797, #, 805#803, #, 807#803, #, 809#297, #, 811#298, #, 813#168, #, 815#167, #, 817#796, #, 825#793, 825#795, 825#817, 825#815, 825#813, 825#811, 825#809, #, 833#809, 833#811, 833#813, 833#815, 833#817, 833#795, 833#793, #, 836#825, 836#833, #, #, 2#839, #, #, #, #, #, #, #, #, #, #, 856#842, 856#843, 856#844, 856#845, 856#846, 856#847, 856#848, #, 858#856, #, #, 861#859, #, #, 865#847, 865#848, #, 869#861, 869#862, 869#865, #, #, #, #, #, 878#871, 878#872, 878#873, 878#856, #, 890#858, 890#842, 890#843, 890#844, 890#845, 890#846, 890#869, 890#870, 890#878, 890#847, 890#848, #, #, #, #, #, #, 901#891, 901#892, 901#893, 901#894, 901#895, #, 903#901, #, #, 906#904, #, #, 910#894, 910#895, #, 914#906, 914#907, 914#910, #, #, #, #, #, 923#916, 923#917, 923#918, 923#901, #, 933#903, 933#891, 933#892, 933#893, 933#914, 933#915, 933#923, 933#894, 933#895, #, #, #, #, #, #, #, #, #, #, 951#942, 951#941, 951#938, 951#939, 951#936, 951#937, 951#934, 951#935, #, #, 955#951, 955#952, #, #, 959#951, 959#956, #, #, #, #, 967#960, 967#961, 967#962, 967#951, #, 980#934, 980#935, 980#936, 980#937, 980#938, 980#939, 980#940, 980#941, 980#942, 980#955, 980#959, 980#967, #, #, #, #, #, #, #, #, 995#981, 995#982, 995#983, 995#984, 995#985, 995#986, 995#987, #, 997#995, #, #, 1000#998, #, #, 1004#986, 1004#987, #, 1008#1000, 1008#1001, 1008#1004, #, #, #, #, #, 1017#1010, 1017#1011, 1017#1012, 1017#995, #, 1029#997, 1029#981, 1029#982, 1029#983, 1029#984, 1029#985, 1029#1008, 1029#1009, 1029#1017, 1029#986, 1029#987, #, 1246#1074, 1289#1074, #, #, #, #, #, 1042#1032, 1042#1033, 1042#1034, 1042#1035, 1042#1036, #, 1044#1042, #, #, 1047#1045, #, #, 1051#1035, 1051#1036, #, 1055#1047, 1055#1048, 1055#1051, #, #, #, #, #, 1064#1057, 1064#1058, 1064#1059, 1064#1042, #, 1074#1044, 1074#1032, 1074#1033, 1074#1034, 1074#1055, 1074#1056, 1074#1064, 1074#1035, 1074#1036, #, #, #, #, #, #, 1085#1075, 1085#1076, 1085#1077, 1085#1078, 1085#1079, #, 1087#1085, #, #, 1090#1088, #, #, 1094#1078, 1094#1079, #, 1098#1090, 1098#1091, 1098#1094, #, #, #, #, #, 1107#1100, 1107#1101, 1107#1102, 1107#1085, #, 1117#1087, 1117#1075, 1117#1076, 1117#1077, 1117#1098, 1117#1099, 1117#1107, 1117#1078, 1117#1079, #, #, #, #, #, #, 1128#1118, 1128#1119, 1128#1120, 1128#1121, 1128#1122, #, 1130#1128, #, #, 1133#1131, #, #, 1137#1121, 1137#1122, #, 1141#1133, 1141#1134, 1141#1137, #, #, #, #, #, 1150#1143, 1150#1144, 1150#1145, 1150#1128, #, 1160#1130, 1160#1118, 1160#1119, 1160#1120, 1160#1141, 1160#1142, 1160#1150, 1160#1121, 1160#1122, #, #, #, #, #, #, 1171#1161, 1171#1162, 1171#1163, 1171#1164, 1171#1165, #, 1173#1171, #, #, 1176#1174, #, #, 1180#1164, 1180#1165, #, 1184#1176, 1184#1177, 1184#1180, #, #, #, #, #, 1193#1186, 1193#1187, 1193#1188, 1193#1171, #, 1203#1173, 1203#1161, 1203#1162, 1203#1163, 1203#1184, 1203#1185, 1203#1193, 1203#1164, 1203#1165, #, #, #, #, #, #, 1214#1204, 1214#1205, 1214#1206, 1214#1207, 1214#1208, #, 1216#1214, #, #, 1219#1217, #, #, 1223#1207, 1223#1208, #, 1227#1219, 1227#1220, 1227#1223, #, #, #, #, #, 1236#1229, 1236#1230, 1236#1231, 1236#1214, #, 1246#1216, 1246#1204, 1246#1205, 1246#1206, 1246#1227, 1246#1228, 1246#1236, 1246#1207, 1246#1208, #, #, #, #, #, #, 1257#1247, 1257#1248, 1257#1249, 1257#1250, 1257#1251, #, 1259#1257, #, #, 1262#1260, #, #, 1266#1250, 1266#1251, #, 1270#1262, 1270#1263, 1270#1266, #, #, #, #, #, 1279#1272, 1279#1273, 1279#1274, 1279#1257, #, 1289#1259, 1289#1247, 1289#1248, 1289#1249, 1289#1270, 1289#1271, 1289#1279, 1289#1250, 1289#1251, #, #, #, #, #, #, #, #, #, #, 1308#1290, 1308#1291, 1308#1292, 1308#1293, 1308#1294, 1308#1295, 1308#1296, 1308#1297, 1308#1298, #, 1310#1308, #, 1313#1296, 1313#1297, #, #, 1317#1313, 1317#1314, #, #, #, #, #, 1326#1319, 1326#1320, 1326#1321, 1326#1308, #, 1340#1310, 1340#1290, 1340#1291, 1340#1292, 1340#1293, 1340#1294, 1340#1317, 1340#1295, 1340#1318, 1340#1326, 1340#1296, 1340#1297, 1340#1298, #, #, #, #, #, #, #, #, #, #, 1359#1341, 1359#1342, 1359#1343, 1359#1344, 1359#1345, 1359#1346, 1359#1347, 1359#1348, 1359#1349, #, 1361#1359, #, 1364#1347, 1364#1348, #, #, 1368#1364, 1368#1365, #, #, #, #, #, 1377#1370, 1377#1371, 1377#1372, 1377#1359, #, 1391#1361, 1391#1341, 1391#1342, 1391#1343, 1391#1344, 1391#1345, 1391#1368, 1391#1346, 1391#1369, 1391#1377, 1391#1347, 1391#1348, 1391#1349, #, 1407#890, 1407#933, 1407#980, 1407#1029, 1407#1030, 1407#1031, 1407#1074, 1407#1117, 1407#1160, 1407#1203, 1407#1246, 1407#1289, 1407#1340, 1407#, 1407#1391, #, 1412#840, 1412#841, 1412#1407, 1412#, #, #, 1419#1413, #, 1419#1415, #, 1419#1417, 1407#, 1031#1442, 1031#1483, 1031#1482, 1031#1463, 1031#1462, 1031#1461, 1031#1460, 1031#1459, 1031#1458, 1031#1457, 1031#1456, 1031#1455, 1031#1454, 1031#1453, 1031#1443, 1031#1451, 1031#1441, 1031#1440, 1031#1439, #, #, #, #, #, 1449#1442, 1449#1439, 1449#1440, 1449#1441, 1449#1443, #, 1451#1449, #, 1453#1449, #, 1455#1251, #, 1457#1250, #, 1459#1036, #, 1461#1035, #, 1463#1442, #, 1471#1439, 1471#1441, 1471#1463, 1471#1461, 1471#1459, 1471#1457, 1471#1455, #, 1479#1455, 1479#1457, 1479#1459, 1479#1461, 1479#1463, 1479#1441, 1479#1439, #, 1482#1471, 1482#1479, #, #, 1030#1506, 1030#1547, 1030#1546, 1030#1527, 1030#1526, 1030#1525, 1030#1524, 1030#1523, 1030#1522, 1030#1521, 1030#1520, 1030#1519, 1030#1518, 1030#1517, 1030#1507, 1030#1515, 1030#1505, 1030#1504, 1030#1503, #, #, #, #, #, 1513#1506, 1513#1503, 1513#1504, 1513#1505, 1513#1507, #, 1515#1513, #, 1517#1513, #, 1519#1208, #, 1521#1207, #, 1523#1036, #, 1525#1035, #, 1527#1506, #, 1535#1503, 1535#1505, 1535#1527, 1535#1525, 1535#1523, 1535#1521, 1535#1519, #, 1543#1519, 1543#1521, 1543#1523, 1543#1525, 1543#1527, 1543#1505, 1543#1503, #, 1546#1535, 1546#1543, #, #, 2#1549, #, 1549#1412, 1549#1552, #, 1552#, 1552#1555, #, 1555#1557, #, 1555#1559, #, 1557#1601, 1557#1602, 1557#1603, 1557#1573, 1557#1581, 1557#1604, 1557#1582, 1557#1605, 1557#1606, 1557#1607, 1557#1608, 1557#1609, 1557#1589, #, 1573#1591, 1573#1578, 1573#1579, 1573#1580, #, #, #, #, #, 1582#1585, 1582#1586, #, #, 1586#1602, 1586#1603, #, 1589#1591, #, 1591#1601, 1591#1602, 1591#1603, 1591#1604, 1591#1605, 1591#1606, 1591#1607, 1591#1608, 1591#1609, #, #, #, #, #, #, #, #, #, #, 1616#1610, #, 1616#1612, #, 1616#1614, 1555#, 1559#1658, 1559#1659, 1559#1660, 1559#1630, 1559#1638, 1559#1661, 1559#1639, 1559#1662, 1559#1663, 1559#1664, 1559#1665, 1559#1666, 1559#1646, #, 1630#1648, 1630#1635, 1630#1636, 1630#1637, #, #, #, #, #, 1639#1642, 1639#1643, #, #, 1643#1659, 1643#1660, #, 1646#1648, #, 1648#1658, 1648#1659, 1648#1660, 1648#1661, 1648#1662, 1648#1663, 1648#1664, 1648#1665, 1648#1666, #, #, #, #, #, #, #, #, #, 1555#1668, #, 1555#1670, #, 1555#1672, #, 1668#1710, 1668#1711, 1668#1682, 1668#1690, 1668#1691, 1668#1712, 1668#1713, 1668#1702, 1668#1714, #, 1682#1704, 1682#1687, 1682#1688, 1682#1689, #, #, #, #, #, 1691#1695, 1691#1698, 1691#1699, #, 1695#1710, 1695#1711, #, #, 1699#1701, #, #, 1702#1704, #, 1704#1710, 1704#1711, 1704#1712, 1704#1714, 1704#1713, #, #, #, #, #, 1670#1752, 1670#1753, 1670#1724, 1670#1732, 1670#1733, 1670#1754, 1670#1755, 1670#1744, 1670#1756, #, 1724#1746, 1724#1729, 1724#1730, 1724#1731, #, #, #, #, #, 1733#1737, 1733#1740, 1733#1741, #, 1737#1752, 1737#1753, #, #, 1741#1743, #, #, 1744#1746, #, 1746#1752, 1746#1753, 1746#1754, 1746#1756, 1746#1755, #, #, #, #, #, 1672#1794, 1672#1795, 1672#1766, 1672#1774, 1672#1775, 1672#1796, 1672#1797, 1672#1786, 1672#1798, #, 1766#1788, 1766#1771, 1766#1772, 1766#1773, #, #, #, #, #, 1775#1779, 1775#1782, 1775#1783, #, 1779#1794, 1779#1795, #, #, 1783#1785, #, #, 1786#1788, #, 1788#1794, 1788#1795, 1788#1796, 1788#1798, 1788#1797, #, #, #, #, #, 1555#1800, #, 1800#1838, 1800#1839, 1800#1810, 1800#1818, 1800#1819, 1800#1840, 1800#1841, 1800#1830, 1800#1842, #, 1810#1832, 1810#1815, 1810#1816, 1810#1817, #, #, #, #, #, 1819#1823, 1819#1826, 1819#1827, #, 1823#1838, 1823#1839, #, #, 1827#1829, #, #, 1830#1832, #, 1832#1838, 1832#1839, 1832#1840, 1832#1842, 1832#1841, #, #, #, #, #, 1555#1844, 1668#1800, 1555#1846, 1670#1800, 1555#1848, 1672#1800, 1844#1871, 1844#1912, 1844#1911, 1844#1892, 1844#1891, 1844#1890, 1844#1889, 1844#1888, 1844#1887, 1844#1886, 1844#1885, 1844#1884, 1844#1883, 1844#1882, 1844#1872, 1844#1880, 1844#1870, 1844#1869, 1844#1868, #, #, #, #, #, 1878#1871, 1878#1868, 1878#1869, 1878#1870, 1878#1872, #, 1880#1878, #, 1882#1878, #, 1884#1710, #, 1886#1711, #, 1888#1838, #, 1890#1839, #, 1892#1871, #, 1900#1868, 1900#1870, 1900#1892, 1900#1890, 1900#1888, 1900#1886, 1900#1884, #, 1908#1884, 1908#1886, 1908#1888, 1908#1890, 1908#1892, 1908#1870, 1908#1868, #, 1911#1900, 1911#1908, #, #, 1846#1935, 1846#1976, 1846#1975, 1846#1956, 1846#1955, 1846#1954, 1846#1953, 1846#1952, 1846#1951, 1846#1950, 1846#1949, 1846#1948, 1846#1947, 1846#1946, 1846#1936, 1846#1944, 1846#1934, 1846#1933, 1846#1932, #, #, #, #, #, 1942#1935, 1942#1932, 1942#1933, 1942#1934, 1942#1936, #, 1944#1942, #, 1946#1942, #, 1948#1752, #, 1950#1753, #, 1952#1838, #, 1954#1839, #, 1956#1935, #, 1964#1932, 1964#1934, 1964#1956, 1964#1954, 1964#1952, 1964#1950, 1964#1948, #, 1972#1948, 1972#1950, 1972#1952, 1972#1954, 1972#1956, 1972#1934, 1972#1932, #, 1975#1964, 1975#1972, #, #, 1848#1999, 1848#2040, 1848#2039, 1848#2020, 1848#2019, 1848#2018, 1848#2017, 1848#2016, 1848#2015, 1848#2014, 1848#2013, 1848#2012, 1848#2011, 1848#2010, 1848#2000, 1848#2008, 1848#1998, 1848#1997, 1848#1996, #, #, #, #, #, 2006#1999, 2006#1996, 2006#1997, 2006#1998, 2006#2000, #, 2008#2006, #, 2010#2006, #, 2012#1794, #, 2014#1795, #, 2016#1838, #, 2018#1839, #, 2020#1999, #, 2028#1996, 2028#1998, 2028#2020, 2028#2018, 2028#2016, 2028#2014, 2028#2012, #, 2036#2012, 2036#2014, 2036#2016, 2036#2018, 2036#2020, 2036#1998, 2036#1996, #, 2039#2028, 2039#2036, #, #, 1555#2042, #, 2042#2084, 2042#2085, 2042#2054, 2042#2062, 2042#2063, 2042#2086, 2042#2087, 2042#2088, 2042#2089, 2042#2090, 2042#2074, #, 2054#2076, 2054#2059, 2054#2060, 2054#2061, #, #, #, #, #, 2063#2067, 2063#2070, 2063#2071, #, 2067#2084, 2067#2085, #, #, 2071#2073, #, #, 2074#2076, #, 2076#2084, 2076#2085, 2076#2086, 2076#2087, 2076#2088, 2076#2089, 2076#2090, #, #, #, #, #, #, #, 1552#2092, #, 1552#2094, #, 2094#, 2094#2097, #, 2097#, 1552#2100, 1555#, 1549#2102, #, 2102#, 1549#2106, 1549#2107, 2102#1412, 2102#1552, 2102#2109, #, 2109#, #, 6#2111, 2#2114, #, 2114#2116, #, #, 6#2117, 2#2120, #, 2120#2122, #, 2120#2124, #, 2124#, 2124#2127, #, 2127#2129, #, 2129#2142, 2129#2150, 2129#2172, 2129#2151, 2129#2168, 2129#2169, 2129#2170, 2129#2171, 2129#2173, 2129#2155, 2129#2174, 2129#2175, #, 2142#2159, 2142#2147, 2142#2148, 2142#2149, #, #, #, #, #, 2151#2154, 2151#2159, #, #, 2155#2158, 2155#2159, #, #, 2159#2168, 2159#2169, 2159#2170, 2159#2171, 2159#2172, 2159#2173, 2159#2175, 2159#2174, #, #, #, #, #, #, #, #, 2127#2177, #, 2127#2179, #, 2127#2181, #, 2127#2183, #, 2177#2221, 2177#2222, 2177#2193, 2177#2201, 2177#2202, 2177#2223, 2177#2224, 2177#2213, 2177#2225, #, 2193#2215, 2193#2198, 2193#2199, 2193#2200, #, #, #, #, #, 2202#2206, 2202#2209, 2202#2210, #, 2206#2221, 2206#2222, #, #, 2210#2212, #, #, 2213#2215, #, 2215#2221, 2215#2222, 2215#2223, 2215#2225, 2215#2224, #, #, #, #, #, 2179#2263, 2179#2264, 2179#2235, 2179#2243, 2179#2244, 2179#2265, 2179#2266, 2179#2255, 2179#2267, #, 2235#2257, 2235#2240, 2235#2241, 2235#2242, #, #, #, #, #, 2244#2248, 2244#2251, 2244#2252, #, 2248#2263, 2248#2264, #, #, 2252#2254, #, #, 2255#2257, #, 2257#2263, 2257#2264, 2257#2265, 2257#2267, 2257#2266, #, #, #, #, #, #, #, #, #, #, 2278#2269, 2278#2268, 2278#2270, 2278#2271, 2278#2272, #, 2280#2278, #, #, 2283#2281, #, #, 2287#2271, 2287#2272, #, 2291#2283, 2291#2284, 2291#2287, #, #, #, #, #, 2300#2293, 2300#2294, 2300#2295, 2300#2278, #, 2310#2268, 2310#2280, 2310#2269, 2310#2270, 2310#2291, 2310#2292, 2310#2300, 2310#2271, 2310#2272, #, 2127#2310, #, #, #, #, #, 2322#2313, 2322#2312, 2322#2314, 2322#2315, 2322#2316, #, 2324#2322, #, #, 2327#2325, #, #, 2331#2315, 2331#2316, #, 2335#2327, 2335#2328, 2335#2331, #, #, #, #, #, 2344#2337, 2344#2338, 2344#2339, 2344#2322, #, 2354#2312, 2354#2324, 2354#2313, 2354#2314, 2354#2335, 2354#2336, 2354#2344, 2354#2315, 2354#2316, #, 2127#2354, #, #, #, #, #, 2366#2356, 2366#2357, 2366#2358, 2366#2359, 2366#2360, #, #, #, #, 2374#2366, 2374#2367, 2374#2368, 2374#2369, #, #, 2378#2356, 2378#2357, #, #, #, 2382#2380, #, 2386#2378, 2386#2379, 2386#2382, #, 2388#2366, #, 2398#2356, 2398#2357, 2398#2374, 2398#2375, 2398#2386, 2398#2358, 2398#2360, 2398#2388, 2398#2359, #, 2127#2398, #, #, #, #, #, 2410#2401, 2410#2400, 2410#2402, 2410#2403, 2410#2404, #, 2412#2410, #, #, 2415#2413, #, #, 2419#2403, 2419#2404, #, 2423#2415, 2423#2416, 2423#2419, #, #, #, #, #, 2432#2425, 2432#2426, 2432#2427, 2432#2410, #, 2442#2400, 2442#2412, 2442#2401, 2442#2402, 2442#2423, 2442#2424, 2442#2432, 2442#2403, 2442#2404, #, 2127#2442, 2127#2445, 2177#, #, #, #, 2221#, 2222#, 2221#, 2445#2482, 2445#2481, 2445#2511, 2445#2503, 2445#2502, 2445#2479, 2445#2478, 2445#2477, 2445#2491, 2445#2475, #, #, #, 2468#2462, 2468#2463, 2468#2464, #, 2470#2482, #, 2472#2470, #, 2475#2468, 2475#2472, #, #, #, #, #, 2481#2464, #, #, 2489#2476, 2489#2477, 2489#2478, 2489#2479, 2489#2481, 2489#2482, #, 2491#2489, #, #, 2494#2492, #, #, 2498#2481, 2498#2482, #, 2502#2494, 2502#2495, 2502#2498, #, #, #, #, #, 2511#2504, 2511#2505, 2511#2506, 2511#2489, #, 2481#2464, 2221#2463, 2222#2462, 2221#2476, 2181#2553, 2181#2554, 2181#2525, 2181#2533, 2181#2534, 2181#2555, 2181#2556, 2181#2545, 2181#2557, #, 2525#2547, 2525#2530, 2525#2531, 2525#2532, #, #, #, #, #, 2534#2538, 2534#2541, 2534#2542, #, 2538#2553, 2538#2554, #, #, 2542#2544, #, #, 2545#2547, #, 2547#2553, 2547#2554, 2547#2555, 2547#2557, 2547#2556, #, #, #, #, #, 2183#2595, 2183#2596, 2183#2567, 2183#2575, 2183#2576, 2183#2597, 2183#2598, 2183#2587, 2183#2599, #, 2567#2589, 2567#2572, 2567#2573, 2567#2574, #, #, #, #, #, 2576#2580, 2576#2583, 2576#2584, #, 2580#2595, 2580#2596, #, #, 2584#2586, #, #, 2587#2589, #, 2589#2595, 2589#2596, 2589#2597, 2589#2599, 2589#2598, #, #, #, #, #, 2127#2601, 2181#2445, 2601#2624, 2601#2665, 2601#2664, 2601#2645, 2601#2644, 2601#2643, 2601#2642, 2601#2641, 2601#2640, 2601#2639, 2601#2638, 2601#2637, 2601#2636, 2601#2635, 2601#2625, 2601#2633, 2601#2623, 2601#2622, 2601#2621, #, #, #, #, #, 2631#2624, 2631#2621, 2631#2622, 2631#2623, 2631#2625, #, 2633#2631, #, 2635#2631, #, 2637#2553, #, 2639#2554, #, 2641#2482, #, 2643#2481, #, 2645#2624, #, 2653#2621, 2653#2623, 2653#2645, 2653#2643, 2653#2641, 2653#2639, 2653#2637, #, 2661#2637, 2661#2639, 2661#2641, 2661#2643, 2661#2645, 2661#2623, 2661#2621, #, 2664#2653, 2664#2661, #, #, #, 2672#2666, #, 2672#2668, #, 2672#2670, 2127#, 2127#2674, 2183#2445, 2674#2697, 2674#2738, 2674#2737, 2674#2718, 2674#2717, 2674#2716, 2674#2715, 2674#2714, 2674#2713, 2674#2712, 2674#2711, 2674#2710, 2674#2709, 2674#2708, 2674#2698, 2674#2706, 2674#2696, 2674#2695, 2674#2694, #, #, #, #, #, 2704#2697, 2704#2694, 2704#2695, 2704#2696, 2704#2698, #, 2706#2704, #, 2708#2704, #, 2710#2595, #, 2712#2596, #, 2714#2482, #, 2716#2481, #, 2718#2697, #, 2726#2694, 2726#2696, 2726#2718, 2726#2716, 2726#2714, 2726#2712, 2726#2710, #, 2734#2710, 2734#2712, 2734#2714, 2734#2716, 2734#2718, 2734#2696, 2734#2694, #, 2737#2726, 2737#2734, #, #, 2127#2740, #, 2740#2778, 2740#2779, 2740#2750, 2740#2758, 2740#2759, 2740#2780, 2740#2781, 2740#2770, 2740#2782, #, 2750#2772, 2750#2755, 2750#2756, 2750#2757, #, #, #, #, #, 2759#2763, 2759#2766, 2759#2767, #, 2763#2778, 2763#2779, #, #, 2767#2769, #, #, 2770#2772, #, 2772#2778, 2772#2779, 2772#2780, 2772#2782, 2772#2781, #, #, #, #, #, 2127#2784, 2177#2740, 2784#2807, 2784#2848, 2784#2847, 2784#2828, 2784#2827, 2784#2826, 2784#2825, 2784#2824, 2784#2823, 2784#2822, 2784#2821, 2784#2820, 2784#2819, 2784#2818, 2784#2808, 2784#2816, 2784#2806, 2784#2805, 2784#2804, #, #, #, #, #, 2814#2807, 2814#2804, 2814#2805, 2814#2806, 2814#2808, #, 2816#2814, #, 2818#2814, #, 2820#2221, #, 2822#2222, #, 2824#2778, #, 2826#2779, #, 2828#2807, #, 2836#2804, 2836#2806, 2836#2828, 2836#2826, 2836#2824, 2836#2822, 2836#2820, #, 2844#2820, 2844#2822, 2844#2824, 2844#2826, 2844#2828, 2844#2806, 2844#2804, #, 2847#2836, 2847#2844, #, #, 2124#2850, #, 2850#, 2124#2853, 2127#, 2114#2855, #, 2855#, 2855#2858, #, 2855#2860, #, 2860#, #, 6#2862, #, 6#2864, #, 6#2866, 2#2869, #, #, 6#2870, 2873#, #, 1549#2873, #, 6#2875, #, 6#2877, 567#2880, #, 2880#, #, 6#2882, 2880#2885, #, 2885#, 2880#2888, #, 2885#2890, #, 2885#2892, #, #2885, 2895#2893, 3#, del#2899, del#2898, #, del#2898, 
### 内容
#0, 17:
文档\物理问题\光栅原理.ftxt
## end
#2, 310:
+[返回目录](,光栅原理)
地址::文档\物理问题\光栅原理.ftxt
+[设置结构](,光栅原理)

几何画图::文档\S应用\几何样本库.ftxt
+[打开文件](+新窗口,几何画图)
网页画板::文档\S应用\网页画板.ftxt
+[打开文件](+新窗口,网页画板)

光栅图示(画板):...
+[画板](+图示,光栅图示)
正文(html):...
+[H函数](,正文)
光谱宽度(M函数):...


光栅对:...
光谱光栅:...
闪耀光栅:...

horiba
1480 grating compressor gold


波包::文档\物理问题\波包.ftxt
+[打开文件](+新窗口,波包)
## end
#3, 48:
光栅原理:...
创建于 20210411

节点数目统计::
+[设置结构](,节点数目统计)
## end
#7, 3:
759
## end
#10, 17:
文档\S应用\几何样本库.ftxt
## end
#12, 390:
+[返回目录](,光栅图示)
光栅图示=>的(光栅图示,_)->的(_,P代码)=>+[P函数](,P代码)
+画板(光栅图示,)

光栅平面:...
+[创建直线](,光栅平面)
法线1:...
法线2:...
+[创建垂线](,法线2)
+法线2(光栅平面,)

入射光1:...
入射光2:...

出射光1:...
出射光2:...

alpha2:...
beta2:...

+alpha1(入射光1,法线1)
+beta1(出射光1,法线1)
+alpha2(入射光2,法线2)
+beta2(出射光2,法线2)

+[删除结构](,alpha2)
+[创建角度](,alpha2)

A:...
B:...
+A(入射光2,)->+[创建垂线](,+A)
+B(出射光1,)->+[创建垂线](,+B)

[选中](光栅图示,_)->+[阅读节点](光栅图示,_)
## end
#14, 129:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#24, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#30, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#31, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#32, 2:
直线
## end
#33, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#37, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#40, 14:
+[返回目录]
+[内容]

## end
#41, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#43, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#44, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#46, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#52, 11:
363.0, 52.0
## end
#53, 12:
-296.0, 53.0
## end
#54, 5:
0,0,0
## end
#55, 8:
DashLine
## end
#56, 1:
1
## end
#58, 128:
+[返回目录](,垂线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...

P代码:...
+[P函数](,P代码)


## end
#69, 12:
-296.0, 53.0
## end
#70, 11:
363.0, 52.0
## end
#71, 37:
28.88732321394499, -97.25400200790412
## end
#75, 35:
+[返回目录]
+[内容]
pt02::
pt11::
pt12::

## end
#77, 37:
29.114577624680656, 52.50665466216242
## end
#79, 21:
+[返回目录]
+[内容]
pt01::

## end
#82, 363:
"""
+[返回目录](,P代码)
+[P函数](,P代码)

输入:...
输出:...
+[设置结构](,输入)

"""


Dx1=pt12[0]-pt11[0]
Dy1=pt12[1]-pt11[1]

Dxr=pt12[0]-pt02[0]
Dyr=pt12[1]-pt02[1]

sign=np.sign(Dy1)
theta1=np.arccos(Dx1/np.sqrt(Dx1**2+Dy1**2))
angle1=-np.rad2deg(theta1)*sign

theta=np.deg2rad(angle1+90)

dx=np.cos(theta)
dy=-np.sin(theta)
DL=Dxr*dx+Dyr*dy

pt01=[pt02[0]+DL*dx,pt02[1]+DL*dy]



## end
#83, 11:
363.0, 52.0
## end
#84, 5:
[1.0]
## end
#85, 8:
DashLine
## end
#86, 15:
[0.0, 0.0, 0.0]
## end
#88, 37:
28.88732321394499, -97.25400200790412
## end
#89, 37:
29.114577624680656, 52.50665466216242
## end
#96, 65:
线颜色::0,0,0
线型::DashLine
线粗细::2
pt11::

pt11->是(_,pt11)->+[显示](,_)
## end
#98, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#99, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#101, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#102, 14:
+[返回目录]
+[内容]

## end
#105, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#109, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#110, 2:
直线
## end
#111, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#112, 871:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

d=10

lineWidth=线粗细[0]
lineType=线型

Dx=pt2[0]-pt1[0]
Dy=pt2[1]-pt1[1]

Dx1=pt11[0]-pt1[0]
Dy1=pt11[1]-pt1[1]

sign=np.sign(Dy)
theta1=-sign*np.arccos(Dx/np.sqrt(Dx**2+Dy**2))
angle1=np.rad2deg(theta1)
theta2=np.deg2rad(angle1+90)

dp1=[d*np.cos(theta1),-d*np.sin(theta1)]
dp2=[d*np.cos(theta2),-d*np.sin(theta2)]

sign2=np.sign(Dx1*dp2[0]+Dy1*dp2[1])
dp2=[sign2*dp2[0],sign2*dp2[1]]


pt01=[pt1[0]+dp1[0],pt1[1]+dp1[1]]
pt02=[pt01[0]+dp2[0],pt01[1]+dp2[1]]
pt03=[pt02[0]-dp1[0],pt02[1]-dp1[1]]

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.drawLine(pt01[0],pt01[1],pt02[0],pt02[1])
qp.drawLine(pt02[0],pt02[1],pt03[0],pt03[1])


qp.setPen(QPen())




## end
#118, 871:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

d=10

lineWidth=线粗细[0]
lineType=线型

Dx=pt2[0]-pt1[0]
Dy=pt2[1]-pt1[1]

Dx1=pt11[0]-pt1[0]
Dy1=pt11[1]-pt1[1]

sign=np.sign(Dy)
theta1=-sign*np.arccos(Dx/np.sqrt(Dx**2+Dy**2))
angle1=np.rad2deg(theta1)
theta2=np.deg2rad(angle1+90)

dp1=[d*np.cos(theta1),-d*np.sin(theta1)]
dp2=[d*np.cos(theta2),-d*np.sin(theta2)]

sign2=np.sign(Dx1*dp2[0]+Dy1*dp2[1])
dp2=[sign2*dp2[0],sign2*dp2[1]]


pt01=[pt1[0]+dp1[0],pt1[1]+dp1[1]]
pt02=[pt01[0]+dp2[0],pt01[1]+dp2[1]]
pt03=[pt02[0]-dp1[0],pt02[1]-dp1[1]]

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.drawLine(pt01[0],pt01[1],pt02[0],pt02[1])
qp.drawLine(pt02[0],pt02[1],pt03[0],pt03[1])


qp.setPen(QPen())




## end
#123, 18:
1.4641000000000006
## end
#125, 8:
958, 148
## end
#127, 9:
50.0, 0.0
## end
#131, 128:
+[返回目录](,垂线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...

P代码:...
+[P函数](,P代码)


## end
#148, 12:
-296.0, 53.0
## end
#149, 11:
363.0, 52.0
## end
#150, 12:
107.0, -95.0
## end
#154, 35:
+[返回目录]
+[内容]
pt02::
pt11::
pt12::

## end
#156, 37:
107.22365421547073, 52.38812799054895
## end
#158, 21:
+[返回目录]
+[内容]
pt01::

## end
#161, 363:
"""
+[返回目录](,P代码)
+[P函数](,P代码)

输入:...
输出:...
+[设置结构](,输入)

"""


Dx1=pt12[0]-pt11[0]
Dy1=pt12[1]-pt11[1]

Dxr=pt12[0]-pt02[0]
Dyr=pt12[1]-pt02[1]

sign=np.sign(Dy1)
theta1=np.arccos(Dx1/np.sqrt(Dx1**2+Dy1**2))
angle1=-np.rad2deg(theta1)*sign

theta=np.deg2rad(angle1+90)

dx=np.cos(theta)
dy=-np.sin(theta)
DL=Dxr*dx+Dyr*dy

pt01=[pt02[0]+DL*dx,pt02[1]+DL*dy]



## end
#162, 11:
363.0, 52.0
## end
#163, 5:
[1.0]
## end
#164, 8:
DashLine
## end
#165, 15:
[0.0, 0.0, 0.0]
## end
#167, 12:
107.0, -95.0
## end
#168, 37:
107.22365421547073, 52.38812799054895
## end
#175, 65:
线颜色::0,0,0
线型::DashLine
线粗细::2
pt11::

pt11->是(_,pt11)->+[显示](,_)
## end
#177, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#178, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#180, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#181, 14:
+[返回目录]
+[内容]

## end
#184, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#188, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#189, 2:
直线
## end
#190, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#191, 870:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

d=10

lineWidth=线粗细[0]
lineType=线型

Dx=pt2[0]-pt1[0]
Dy=pt2[1]-pt1[1]

Dx1=pt11[0]-pt1[0]
Dy1=pt11[1]-pt1[1]

sign=np.sign(Dy)
theta1=-sign*np.arccos(Dx/np.sqrt(Dx**2+Dy**2))
angle1=np.rad2deg(theta1)
theta2=np.deg2rad(angle1+90)

dp1=[d*np.cos(theta1),-d*np.sin(theta1)]
dp2=[d*np.cos(theta2),-d*np.sin(theta2)]

sign2=np.sign(Dx1*dp2[0]+Dy1*dp2[1])
dp2=[sign2*dp2[0],sign2*dp2[1]]


pt01=[pt1[0]+dp1[0],pt1[1]+dp1[1]]
pt02=[pt01[0]+dp2[0],pt01[1]+dp2[1]]
pt03=[pt02[0]-dp1[0],pt02[1]-dp1[1]]

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.drawLine(pt01[0],pt01[1],pt02[0],pt02[1])
qp.drawLine(pt02[0],pt02[1],pt03[0],pt03[1])

qp.setPen(QPen())




## end
#197, 870:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

d=10

lineWidth=线粗细[0]
lineType=线型

Dx=pt2[0]-pt1[0]
Dy=pt2[1]-pt1[1]

Dx1=pt11[0]-pt1[0]
Dy1=pt11[1]-pt1[1]

sign=np.sign(Dy)
theta1=-sign*np.arccos(Dx/np.sqrt(Dx**2+Dy**2))
angle1=np.rad2deg(theta1)
theta2=np.deg2rad(angle1+90)

dp1=[d*np.cos(theta1),-d*np.sin(theta1)]
dp2=[d*np.cos(theta2),-d*np.sin(theta2)]

sign2=np.sign(Dx1*dp2[0]+Dy1*dp2[1])
dp2=[sign2*dp2[0],sign2*dp2[1]]


pt01=[pt1[0]+dp1[0],pt1[1]+dp1[1]]
pt02=[pt01[0]+dp2[0],pt01[1]+dp2[1]]
pt03=[pt02[0]-dp1[0],pt02[1]-dp1[1]]

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.drawLine(pt01[0],pt01[1],pt02[0],pt02[1])
qp.drawLine(pt02[0],pt02[1],pt03[0],pt03[1])

qp.setPen(QPen())




## end
#203, 129:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#205, 129:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#207, 129:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#209, 129:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#211, 111:
+[返回目录](,角度)

数值::
中心::
半径::20
起始角度::
类型::角度

标记::%数值

画图:...
HTML:...
P代码:...
+[P函数](,P代码)



+[创建输入](标记,画图)


## end
#213, 111:
+[返回目录](,角度)

数值::
中心::
半径::20
起始角度::
类型::角度

标记::%数值

画图:...
HTML:...
P代码:...
+[P函数](,P代码)



+[创建输入](标记,画图)


## end
#215, 111:
+[返回目录](,角度)

数值::
中心::
半径::20
起始角度::
类型::角度

标记::%数值

画图:...
HTML:...
P代码:...
+[P函数](,P代码)



+[创建输入](标记,画图)


## end
#217, 111:
+[返回目录](,角度)

数值::
中心::
半径::20
起始角度::
类型::角度

标记::%数值

画图:...
HTML:...
P代码:...
+[P函数](,P代码)



+[创建输入](标记,画图)


## end
#227, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#233, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#234, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#235, 2:
直线
## end
#236, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#240, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#243, 14:
+[返回目录]
+[内容]

## end
#244, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#246, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#247, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#249, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#255, 13:
-177.0, -70.0
## end
#256, 10:
29.5, 50.0
## end
#257, 5:
0,0,0
## end
#258, 8:
DashLine
## end
#259, 1:
1
## end
#269, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#275, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#276, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#277, 2:
直线
## end
#278, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#282, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#285, 14:
+[返回目录]
+[内容]

## end
#286, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#288, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#289, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#291, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#297, 13:
-125.0, -91.0
## end
#298, 13:
108.75, 54.75
## end
#299, 5:
0,0,0
## end
#300, 8:
DashLine
## end
#301, 1:
1
## end
#311, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#317, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#318, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#319, 2:
直线
## end
#320, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#324, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#327, 14:
+[返回目录]
+[内容]

## end
#328, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#330, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#331, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#333, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#339, 12:
375.0, -61.0
## end
#340, 11:
108.0, 51.0
## end
#341, 5:
0,0,0
## end
#342, 8:
DashLine
## end
#343, 1:
1
## end
#353, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#359, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#360, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#361, 2:
直线
## end
#362, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#366, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#369, 14:
+[返回目录]
+[内容]

## end
#370, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#372, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#373, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#375, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#381, 12:
360.0, -92.0
## end
#382, 10:
29.0, 52.0
## end
#383, 5:
0,0,0
## end
#384, 8:
DashLine
## end
#385, 1:
1
## end
#386, 148:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...



## end
#400, 870:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#406, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#407, 870:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#408, 231:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


## end
#411, 14:
+[返回目录]
+[内容]

## end
#412, 655:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#415, 14:
+[返回目录]
+[内容]

## end
#416, 101:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100

## end
#425, 10:
33.0, 58.0
## end
#426, 10:
70.0, 32.0
## end
#427, 2:
矩形
## end
#428, 1:
d
## end
#429, 2:
10
## end
#430, 8:
DashLine
## end
#431, 1:
2
## end
#432, 4:
None
## end
#433, 4:
None
## end
#435, 128:
+[返回目录](,垂线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...

P代码:...
+[P函数](,P代码)


## end
#446, 13:
108.75, 54.75
## end
#447, 13:
-125.0, -91.0
## end
#448, 38:
30.846077720749463, 49.341196108232054
## end
#452, 35:
+[返回目录]
+[内容]
pt02::
pt11::
pt12::

## end
#454, 37:
50.22672912098868, 18.259019334263513
## end
#456, 21:
+[返回目录]
+[内容]
pt01::

## end
#459, 363:
"""
+[返回目录](,P代码)
+[P函数](,P代码)

输入:...
输出:...
+[设置结构](,输入)

"""


Dx1=pt12[0]-pt11[0]
Dy1=pt12[1]-pt11[1]

Dxr=pt12[0]-pt02[0]
Dyr=pt12[1]-pt02[1]

sign=np.sign(Dy1)
theta1=np.arccos(Dx1/np.sqrt(Dx1**2+Dy1**2))
angle1=-np.rad2deg(theta1)*sign

theta=np.deg2rad(angle1+90)

dx=np.cos(theta)
dy=-np.sin(theta)
DL=Dxr*dx+Dyr*dy

pt01=[pt02[0]+DL*dx,pt02[1]+DL*dy]



## end
#460, 13:
-125.0, -91.0
## end
#461, 5:
[1.0]
## end
#462, 8:
DashLine
## end
#463, 15:
[0.0, 0.0, 0.0]
## end
#465, 38:
30.846077720749463, 49.341196108232054
## end
#466, 37:
50.22672912098868, 18.259019334263513
## end
#473, 65:
线颜色::0,0,0
线型::DashLine
线粗细::2
pt11::

pt11->是(_,pt11)->+[显示](,_)
## end
#475, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#476, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#478, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#479, 14:
+[返回目录]
+[内容]

## end
#482, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#486, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#487, 2:
直线
## end
#488, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#489, 967:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

d=10

lineWidth=线粗细[0]
lineType=线型

Dx=pt2[0]-pt1[0]
Dy=pt2[1]-pt1[1]

Dx1=pt11[0]-pt1[0]
Dy1=pt11[1]-pt1[1]

sign=np.sign(Dy)
theta1=-sign*np.arccos(Dx/np.sqrt(Dx**2+Dy**2))
angle1=np.rad2deg(theta1)
theta2=np.deg2rad(angle1+90)

dp1=[d*np.cos(theta1),-d*np.sin(theta1)]
dp2=[d*np.cos(theta2),-d*np.sin(theta2)]

sign2=np.sign(Dx1*dp2[0]+Dy1*dp2[1])
dp2=[sign2*dp2[0],sign2*dp2[1]]


pt01=[pt1[0]+dp1[0],pt1[1]+dp1[1]]
pt02=[pt01[0]+dp2[0],pt01[1]+dp2[1]]
pt03=[pt02[0]-dp1[0],pt02[1]-dp1[1]]

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.drawLine(pt01[0],pt01[1],pt02[0],pt02[1])
qp.drawLine(pt02[0],pt02[1],pt03[0],pt03[1])

qp.setPen(QPen(QColor(0,0,0),lineWidth,Qt.DashLine))
qp.drawLine(pt11[0],pt11[1],pt1[0],pt1[1])

qp.setPen(QPen())




## end
#495, 967:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

d=10

lineWidth=线粗细[0]
lineType=线型

Dx=pt2[0]-pt1[0]
Dy=pt2[1]-pt1[1]

Dx1=pt11[0]-pt1[0]
Dy1=pt11[1]-pt1[1]

sign=np.sign(Dy)
theta1=-sign*np.arccos(Dx/np.sqrt(Dx**2+Dy**2))
angle1=np.rad2deg(theta1)
theta2=np.deg2rad(angle1+90)

dp1=[d*np.cos(theta1),-d*np.sin(theta1)]
dp2=[d*np.cos(theta2),-d*np.sin(theta2)]

sign2=np.sign(Dx1*dp2[0]+Dy1*dp2[1])
dp2=[sign2*dp2[0],sign2*dp2[1]]


pt01=[pt1[0]+dp1[0],pt1[1]+dp1[1]]
pt02=[pt01[0]+dp2[0],pt01[1]+dp2[1]]
pt03=[pt02[0]-dp1[0],pt02[1]-dp1[1]]

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.drawLine(pt01[0],pt01[1],pt02[0],pt02[1])
qp.drawLine(pt02[0],pt02[1],pt03[0],pt03[1])

qp.setPen(QPen(QColor(0,0,0),lineWidth,Qt.DashLine))
qp.drawLine(pt11[0],pt11[1],pt1[0],pt1[1])

qp.setPen(QPen())




## end
#501, 128:
+[返回目录](,垂线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...

P代码:...
+[P函数](,P代码)


## end
#512, 10:
29.0, 52.0
## end
#513, 12:
360.0, -92.0
## end
#514, 38:
107.85153984512294, 53.832358949553566
## end
#518, 35:
+[返回目录]
+[内容]
pt02::
pt11::
pt12::

## end
#520, 37:
94.63248578248148, 23.446894402787475
## end
#522, 21:
+[返回目录]
+[内容]
pt01::

## end
#525, 363:
"""
+[返回目录](,P代码)
+[P函数](,P代码)

输入:...
输出:...
+[设置结构](,输入)

"""


Dx1=pt12[0]-pt11[0]
Dy1=pt12[1]-pt11[1]

Dxr=pt12[0]-pt02[0]
Dyr=pt12[1]-pt02[1]

sign=np.sign(Dy1)
theta1=np.arccos(Dx1/np.sqrt(Dx1**2+Dy1**2))
angle1=-np.rad2deg(theta1)*sign

theta=np.deg2rad(angle1+90)

dx=np.cos(theta)
dy=-np.sin(theta)
DL=Dxr*dx+Dyr*dy

pt01=[pt02[0]+DL*dx,pt02[1]+DL*dy]



## end
#526, 12:
360.0, -92.0
## end
#527, 5:
[1.0]
## end
#528, 8:
DashLine
## end
#529, 15:
[0.0, 0.0, 0.0]
## end
#531, 38:
107.85153984512294, 53.832358949553566
## end
#532, 37:
94.63248578248148, 23.446894402787475
## end
#539, 65:
线颜色::0,0,0
线型::DashLine
线粗细::2
pt11::

pt11->是(_,pt11)->+[显示](,_)
## end
#541, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#542, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#544, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#545, 14:
+[返回目录]
+[内容]

## end
#548, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#552, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#553, 2:
直线
## end
#554, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#555, 967:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

d=10

lineWidth=线粗细[0]
lineType=线型

Dx=pt2[0]-pt1[0]
Dy=pt2[1]-pt1[1]

Dx1=pt11[0]-pt1[0]
Dy1=pt11[1]-pt1[1]

sign=np.sign(Dy)
theta1=-sign*np.arccos(Dx/np.sqrt(Dx**2+Dy**2))
angle1=np.rad2deg(theta1)
theta2=np.deg2rad(angle1+90)

dp1=[d*np.cos(theta1),-d*np.sin(theta1)]
dp2=[d*np.cos(theta2),-d*np.sin(theta2)]

sign2=np.sign(Dx1*dp2[0]+Dy1*dp2[1])
dp2=[sign2*dp2[0],sign2*dp2[1]]


pt01=[pt1[0]+dp1[0],pt1[1]+dp1[1]]
pt02=[pt01[0]+dp2[0],pt01[1]+dp2[1]]
pt03=[pt02[0]-dp1[0],pt02[1]-dp1[1]]

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.drawLine(pt01[0],pt01[1],pt02[0],pt02[1])
qp.drawLine(pt02[0],pt02[1],pt03[0],pt03[1])

qp.setPen(QPen(QColor(0,0,0),lineWidth,Qt.DashLine))
qp.drawLine(pt11[0],pt11[1],pt1[0],pt1[1])

qp.setPen(QPen())




## end
#561, 967:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

d=10

lineWidth=线粗细[0]
lineType=线型

Dx=pt2[0]-pt1[0]
Dy=pt2[1]-pt1[1]

Dx1=pt11[0]-pt1[0]
Dy1=pt11[1]-pt1[1]

sign=np.sign(Dy)
theta1=-sign*np.arccos(Dx/np.sqrt(Dx**2+Dy**2))
angle1=np.rad2deg(theta1)
theta2=np.deg2rad(angle1+90)

dp1=[d*np.cos(theta1),-d*np.sin(theta1)]
dp2=[d*np.cos(theta2),-d*np.sin(theta2)]

sign2=np.sign(Dx1*dp2[0]+Dy1*dp2[1])
dp2=[sign2*dp2[0],sign2*dp2[1]]


pt01=[pt1[0]+dp1[0],pt1[1]+dp1[1]]
pt02=[pt01[0]+dp2[0],pt01[1]+dp2[1]]
pt03=[pt02[0]-dp1[0],pt02[1]-dp1[1]]

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.drawLine(pt01[0],pt01[1],pt02[0],pt02[1])
qp.drawLine(pt02[0],pt02[1],pt03[0],pt03[1])

qp.setPen(QPen(QColor(0,0,0),lineWidth,Qt.DashLine))
qp.drawLine(pt11[0],pt11[1],pt1[0],pt1[1])

qp.setPen(QPen())




## end
#567, 338:
<!--
+[返回目录](,正文)

+[H函数](,正文)
光栅图示(画板):...
+画板(光栅图示,)
画板(光栅图示,)->+[del](,画板)
-->

%光栅图示
<br>
假设光栅的重复单元间隔为\(d\), 入射光线的入射角为\(\alpha\), 出射光线的出射角为\(\beta\). 因为不同入射光线的波前相位差应该为0, 而出射光线的相位差则应该为\(2\pi\)的整数倍. 所以会有, 
$$
d (sin\beta-sin\alpha)=n\lambda=\frac{2n\pi}{k}
$$$$
sin\beta=sin\alpha+\frac{2n\pi}{kd}
$$

<!--
+[H函数](,正文)
验证计算(M函数):...
-->
## end
#571, 669:
%{
+[返回目录](,光谱宽度)
+[M函数](,光谱宽度)

公式(html):...
+[H函数](,公式)

波长与出射角:...
+[M函数](,波长与出射角)
%}

n=-1;
alpha=50;
N=1480;

lambda1=740e-9;
lambda2=850e-9;

d=1e-3/N;
b1=sind(alpha)+n*lambda1/d;
b2=sind(alpha)+n*lambda2/d;
beta1=asind(b1);
beta2=asind(b2);

D=8;
H=1.5;

clf
% draw
% input
x0=-D/2;
y0=-x0/tand(alpha);

% output1
x1=D/2*ones(size(n));
y1=x1./tand(beta1);
i=find(y1<0);
x1(i)=-x1(i);
y1(i)=-y1(i);
x2=x1;
y2=x1./tand(beta2);
i=find(y2<0);
x2(i)=-x2(i);
y2(i)=-y2(i);



hold on
plot([x0,0],[y0,0],'k',[0*x1;x1],[0*y1;y1],'b',[0*x2;x2],[0*y2;y2],'r')

rectangle('Position',[-D/2,-H,D,H]);
axis([-1.1*D/2,1.1*D/2,-1.1*D/2,1.1*D/2])
axis equal


%{
+[M函数](,光谱宽度)
%}
## end
#574, 190:
<!--
+[返回目录](,公式)

+[H函数](,公式)
-->

光栅常数为\(N(N=1/d)\), 入射角度为\(\alpha\), 入射光波数为\(k\), 那么\(n\)阶的出射角\(\beta\)可以由下面的公式计算获得, 
$$
sin\beta=sin\alpha+\frac{2n\pi}{kd}
=sin\alpha+N\frac{2n\pi}{k}
$$
## end
#577, 333:
%{
+[返回目录](,波长与出射角)
+[M函数](,波长与出射角)
%}

%alpha=10;
%N=800;
%d=1e-3/N;

%n=1;
%lambda1=700e-9;
%lambda2=900e-9;

lm=linspace(lambda1,lambda2,100);

b=sind(alpha)+n*lm/d;
beta=asind(b);

clf
plot(lm/1e-9,beta)
xlabel('\lambda [nm]')
ylabel('\beta [deg]')

title(sprintf('N=%d, n=%d, \\alpha=%.2f deg',N,n,alpha))

%{
+[M函数](,波长与出射角)
%}
## end
#578, 4:
2129
## end
#601, 18:
-22.75686309705781
## end
#602, 6:
[20.0]
## end
#603, 37:
107.22204299549165, 51.32633402436304
## end
#604, 18:
-67.33008035595809
## end
#605, 3:
%数值
## end
#611, 121:
+[返回目录]
+[内容]
标记::%数值
中心::-338.8789230341691, -3.8202594274802757
半径::10
起始角度::136.10929165904932
数值::62.220685781962224

## end
#613, 775:
/*
+[返回目录](,HTML)

+[新建阅读窗口](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var pt0=[%中心];
var r=%半径;
var Dangle=%数值;
var angle0=%起始角度;
var text="%标记";

dx=1.5*r*Math.cos((angle0+Dangle)/180*Math.PI/2);
dy=1.5*r*Math.sin((angle0+Dangle)/180*Math.PI/2);


ctx.beginPath();
if(Dangle>0) {
    ctx.arc(pt0[0],pt0[1],r,angle0/180*Math.PI,(angle0+Dangle)/180*Math.PI);
} else {
    ctx.arc(pt0[0],pt0[1],r,(angle0+Dangle)/180*Math.PI,angle0/180*Math.PI);
}

ctx.strokeStyle='rgba(0,0,0)';
ctx.stroke();

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center';
ctx.textBaseline='middle';
ctx.font=8*2+'px serif';

if (text[0]==='%') {
    ctx.fillText(`${-Dangle.toFixed(2)}`,pt0[0]+dx,pt0[1]+dy);
} else {
    ctx.fillText(text,pt0[0]+dx,pt0[1]+dy);
}


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/

## end
#615, 562:
"""
+[返回目录](,画图)

输入:...
+[设置结构](,输入)

"""

pt0=中心
r=半径[0]
angle0=-起始角度[0]
Dangle=-数值[0]

dx=r*np.cos(np.deg2rad(angle0+Dangle)/2)
dy=r*np.sin(np.deg2rad(angle0+Dangle)/2)


qp.setPen(QPen(QColor(0,0,0)))
qp.setBrush(QBrush(QColor(255,255,255)))

qp.drawArc(pt0[0]-r,pt0[1]-r,2*r,2*r,angle0*16,Dangle*16)

qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",10))


if 标记=='%数值':
    qp.drawText(pt0[0]+dx,pt0[1]+dy,"%.2f"%(Dangle))
else:
    qp.drawText(pt0[0]+dx,pt0[1]+dy,str(标记))

qp.drawPoint(pt0[0]+dx,pt0[1]+dy)

qp.setFont(QFont())




## end
#617, 12:
375.0, -61.0
## end
#619, 11:
108.0, 51.0
## end
#621, 37:
107.22365421547073, 52.38812799054895
## end
#623, 12:
107.0, -95.0
## end
#625, 18:
-67.33008035595809
## end
#633, 62:
+[返回目录]
+[内容]
pt11::
pt12::
pt21::
pt22::
angle::
中心::
起始角度::

## end
#641, 14:
+[返回目录]
+[内容]

## end
#644, 940:
"""
+[返回目录](,P代码)

+[P函数](,P代码)

输出:...
+[设置结构](,输出)

"""

Dx1=pt11[0]-pt12[0]
Dy1=pt11[1]-pt12[1]

Dx2=pt21[0]-pt22[0]
Dy2=pt21[1]-pt22[1]

D1=pt11[0]*Dy1-pt11[1]*Dx1
D2=pt21[0]*Dy2-pt21[1]*Dx2

L=Dy1*Dx2-Dy2*Dx1
if L==0:
    pt0="None"
else:
    pt0=[(D1*Dx2-D2*Dx1)/L, (D1*Dy2-D2*Dy1)/L]
    if np.sqrt((pt0[0]-pt11[0])**2+(pt0[1]-pt11[1])**2) < np.sqrt((pt0[0]-pt12[0])**2+(pt0[1]-pt12[1])**2):
        Dx1=-Dx1
        Dy1=-Dy1
    
    if np.sqrt((pt0[0]-pt21[0])**2+(pt0[1]-pt21[1])**2) < np.sqrt((pt0[0]-pt22[0])**2+(pt0[1]-pt22[1])**2):
        Dx2=-Dx2
        Dy2=-Dy2

    sign=np.sign(Dx1*Dy2-Dx2*Dy1)
    Dtheta=np.arccos((Dx1*Dx2+Dy1*Dy2)/np.sqrt((Dx1**2+Dy1**2)*(Dx2**2+Dy2**2)))
    angle=np.rad2deg(Dtheta)*sign

    theta0=np.arccos(Dx1/np.sqrt(Dx1**2+Dy1**2))
    angle0=np.rad2deg(theta0)*np.sign(Dy1)

    print(Dy1/np.sqrt(Dx1**2+Dy1**2),theta0,angle0)

    中心=pt0
    起始角度=angle0


"""
+[P函数](,P代码)
+[设置结构](,输出)

"""
## end
#645, 2:
角度
## end
#665, 19:
-23.511223530493353
## end
#666, 6:
[20.0]
## end
#667, 38:
29.113733718786953, 51.950520678231655
## end
#668, 18:
-66.57571992252254
## end
#669, 3:
%数值
## end
#675, 121:
+[返回目录]
+[内容]
标记::%数值
中心::-338.8789230341691, -3.8202594274802757
半径::10
起始角度::136.10929165904932
数值::62.220685781962224

## end
#677, 775:
/*
+[返回目录](,HTML)

+[新建阅读窗口](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var pt0=[%中心];
var r=%半径;
var Dangle=%数值;
var angle0=%起始角度;
var text="%标记";

dx=1.5*r*Math.cos((angle0+Dangle)/180*Math.PI/2);
dy=1.5*r*Math.sin((angle0+Dangle)/180*Math.PI/2);


ctx.beginPath();
if(Dangle>0) {
    ctx.arc(pt0[0],pt0[1],r,angle0/180*Math.PI,(angle0+Dangle)/180*Math.PI);
} else {
    ctx.arc(pt0[0],pt0[1],r,(angle0+Dangle)/180*Math.PI,angle0/180*Math.PI);
}

ctx.strokeStyle='rgba(0,0,0)';
ctx.stroke();

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center';
ctx.textBaseline='middle';
ctx.font=8*2+'px serif';

if (text[0]==='%') {
    ctx.fillText(`${-Dangle.toFixed(2)}`,pt0[0]+dx,pt0[1]+dy);
} else {
    ctx.fillText(text,pt0[0]+dx,pt0[1]+dy);
}


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/

## end
#679, 562:
"""
+[返回目录](,画图)

输入:...
+[设置结构](,输入)

"""

pt0=中心
r=半径[0]
angle0=-起始角度[0]
Dangle=-数值[0]

dx=r*np.cos(np.deg2rad(angle0+Dangle)/2)
dy=r*np.sin(np.deg2rad(angle0+Dangle)/2)


qp.setPen(QPen(QColor(0,0,0)))
qp.setBrush(QBrush(QColor(255,255,255)))

qp.drawArc(pt0[0]-r,pt0[1]-r,2*r,2*r,angle0*16,Dangle*16)

qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",10))


if 标记=='%数值':
    qp.drawText(pt0[0]+dx,pt0[1]+dy,"%.2f"%(Dangle))
else:
    qp.drawText(pt0[0]+dx,pt0[1]+dy,str(标记))

qp.drawPoint(pt0[0]+dx,pt0[1]+dy)

qp.setFont(QFont())




## end
#681, 12:
360.0, -92.0
## end
#683, 10:
29.0, 52.0
## end
#685, 37:
29.114577624680656, 52.50665466216242
## end
#687, 37:
28.88732321394499, -97.25400200790412
## end
#689, 18:
-66.57571992252254
## end
#697, 62:
+[返回目录]
+[内容]
pt11::
pt12::
pt21::
pt22::
angle::
中心::
起始角度::

## end
#705, 14:
+[返回目录]
+[内容]

## end
#708, 940:
"""
+[返回目录](,P代码)

+[P函数](,P代码)

输出:...
+[设置结构](,输出)

"""

Dx1=pt11[0]-pt12[0]
Dy1=pt11[1]-pt12[1]

Dx2=pt21[0]-pt22[0]
Dy2=pt21[1]-pt22[1]

D1=pt11[0]*Dy1-pt11[1]*Dx1
D2=pt21[0]*Dy2-pt21[1]*Dx2

L=Dy1*Dx2-Dy2*Dx1
if L==0:
    pt0="None"
else:
    pt0=[(D1*Dx2-D2*Dx1)/L, (D1*Dy2-D2*Dy1)/L]
    if np.sqrt((pt0[0]-pt11[0])**2+(pt0[1]-pt11[1])**2) < np.sqrt((pt0[0]-pt12[0])**2+(pt0[1]-pt12[1])**2):
        Dx1=-Dx1
        Dy1=-Dy1
    
    if np.sqrt((pt0[0]-pt21[0])**2+(pt0[1]-pt21[1])**2) < np.sqrt((pt0[0]-pt22[0])**2+(pt0[1]-pt22[1])**2):
        Dx2=-Dx2
        Dy2=-Dy2

    sign=np.sign(Dx1*Dy2-Dx2*Dy1)
    Dtheta=np.arccos((Dx1*Dx2+Dy1*Dy2)/np.sqrt((Dx1**2+Dy1**2)*(Dx2**2+Dy2**2)))
    angle=np.rad2deg(Dtheta)*sign

    theta0=np.arccos(Dx1/np.sqrt(Dx1**2+Dy1**2))
    angle0=np.rad2deg(theta0)*np.sign(Dy1)

    print(Dy1/np.sqrt(Dx1**2+Dy1**2),theta0,angle0)

    中心=pt0
    起始角度=angle0


"""
+[P函数](,P代码)
+[设置结构](,输出)

"""
## end
#709, 2:
角度
## end
#729, 18:
-149.8385376703151
## end
#730, 6:
[20.0]
## end
#731, 38:
29.110430372860915, 49.773615713042666
## end
#732, 17:
59.75159421729923
## end
#733, 3:
%数值
## end
#739, 121:
+[返回目录]
+[内容]
标记::%数值
中心::-338.8789230341691, -3.8202594274802757
半径::10
起始角度::136.10929165904932
数值::62.220685781962224

## end
#741, 775:
/*
+[返回目录](,HTML)

+[新建阅读窗口](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var pt0=[%中心];
var r=%半径;
var Dangle=%数值;
var angle0=%起始角度;
var text="%标记";

dx=1.5*r*Math.cos((angle0+Dangle)/180*Math.PI/2);
dy=1.5*r*Math.sin((angle0+Dangle)/180*Math.PI/2);


ctx.beginPath();
if(Dangle>0) {
    ctx.arc(pt0[0],pt0[1],r,angle0/180*Math.PI,(angle0+Dangle)/180*Math.PI);
} else {
    ctx.arc(pt0[0],pt0[1],r,(angle0+Dangle)/180*Math.PI,angle0/180*Math.PI);
}

ctx.strokeStyle='rgba(0,0,0)';
ctx.stroke();

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center';
ctx.textBaseline='middle';
ctx.font=8*2+'px serif';

if (text[0]==='%') {
    ctx.fillText(`${-Dangle.toFixed(2)}`,pt0[0]+dx,pt0[1]+dy);
} else {
    ctx.fillText(text,pt0[0]+dx,pt0[1]+dy);
}


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/

## end
#743, 562:
"""
+[返回目录](,画图)

输入:...
+[设置结构](,输入)

"""

pt0=中心
r=半径[0]
angle0=-起始角度[0]
Dangle=-数值[0]

dx=r*np.cos(np.deg2rad(angle0+Dangle)/2)
dy=r*np.sin(np.deg2rad(angle0+Dangle)/2)


qp.setPen(QPen(QColor(0,0,0)))
qp.setBrush(QBrush(QColor(255,255,255)))

qp.drawArc(pt0[0]-r,pt0[1]-r,2*r,2*r,angle0*16,Dangle*16)

qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",10))


if 标记=='%数值':
    qp.drawText(pt0[0]+dx,pt0[1]+dy,"%.2f"%(Dangle))
else:
    qp.drawText(pt0[0]+dx,pt0[1]+dy,str(标记))

qp.drawPoint(pt0[0]+dx,pt0[1]+dy)

qp.setFont(QFont())




## end
#745, 13:
-177.0, -70.0
## end
#747, 10:
29.5, 50.0
## end
#749, 37:
29.114577624680656, 52.50665466216242
## end
#751, 37:
28.88732321394499, -97.25400200790412
## end
#753, 17:
59.75159421729923
## end
#761, 62:
+[返回目录]
+[内容]
pt11::
pt12::
pt21::
pt22::
angle::
中心::
起始角度::

## end
#769, 14:
+[返回目录]
+[内容]

## end
#772, 940:
"""
+[返回目录](,P代码)

+[P函数](,P代码)

输出:...
+[设置结构](,输出)

"""

Dx1=pt11[0]-pt12[0]
Dy1=pt11[1]-pt12[1]

Dx2=pt21[0]-pt22[0]
Dy2=pt21[1]-pt22[1]

D1=pt11[0]*Dy1-pt11[1]*Dx1
D2=pt21[0]*Dy2-pt21[1]*Dx2

L=Dy1*Dx2-Dy2*Dx1
if L==0:
    pt0="None"
else:
    pt0=[(D1*Dx2-D2*Dx1)/L, (D1*Dy2-D2*Dy1)/L]
    if np.sqrt((pt0[0]-pt11[0])**2+(pt0[1]-pt11[1])**2) < np.sqrt((pt0[0]-pt12[0])**2+(pt0[1]-pt12[1])**2):
        Dx1=-Dx1
        Dy1=-Dy1
    
    if np.sqrt((pt0[0]-pt21[0])**2+(pt0[1]-pt21[1])**2) < np.sqrt((pt0[0]-pt22[0])**2+(pt0[1]-pt22[1])**2):
        Dx2=-Dx2
        Dy2=-Dy2

    sign=np.sign(Dx1*Dy2-Dx2*Dy1)
    Dtheta=np.arccos((Dx1*Dx2+Dy1*Dy2)/np.sqrt((Dx1**2+Dy1**2)*(Dx2**2+Dy2**2)))
    angle=np.rad2deg(Dtheta)*sign

    theta0=np.arccos(Dx1/np.sqrt(Dx1**2+Dy1**2))
    angle0=np.rad2deg(theta0)*np.sign(Dy1)

    print(Dy1/np.sqrt(Dx1**2+Dy1**2),theta0,angle0)

    中心=pt0
    起始角度=angle0


"""
+[P函数](,P代码)
+[设置结构](,输出)

"""
## end
#773, 2:
角度
## end
#793, 18:
-148.0552472237966
## end
#794, 6:
[20.0]
## end
#795, 38:
107.22579607591582, 53.799614023806335
## end
#796, 17:
57.96830377078075
## end
#797, 3:
%数值
## end
#803, 121:
+[返回目录]
+[内容]
标记::%数值
中心::-338.8789230341691, -3.8202594274802757
半径::10
起始角度::136.10929165904932
数值::62.220685781962224

## end
#805, 775:
/*
+[返回目录](,HTML)

+[新建阅读窗口](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var pt0=[%中心];
var r=%半径;
var Dangle=%数值;
var angle0=%起始角度;
var text="%标记";

dx=1.5*r*Math.cos((angle0+Dangle)/180*Math.PI/2);
dy=1.5*r*Math.sin((angle0+Dangle)/180*Math.PI/2);


ctx.beginPath();
if(Dangle>0) {
    ctx.arc(pt0[0],pt0[1],r,angle0/180*Math.PI,(angle0+Dangle)/180*Math.PI);
} else {
    ctx.arc(pt0[0],pt0[1],r,(angle0+Dangle)/180*Math.PI,angle0/180*Math.PI);
}

ctx.strokeStyle='rgba(0,0,0)';
ctx.stroke();

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center';
ctx.textBaseline='middle';
ctx.font=8*2+'px serif';

if (text[0]==='%') {
    ctx.fillText(`${-Dangle.toFixed(2)}`,pt0[0]+dx,pt0[1]+dy);
} else {
    ctx.fillText(text,pt0[0]+dx,pt0[1]+dy);
}


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/

## end
#807, 562:
"""
+[返回目录](,画图)

输入:...
+[设置结构](,输入)

"""

pt0=中心
r=半径[0]
angle0=-起始角度[0]
Dangle=-数值[0]

dx=r*np.cos(np.deg2rad(angle0+Dangle)/2)
dy=r*np.sin(np.deg2rad(angle0+Dangle)/2)


qp.setPen(QPen(QColor(0,0,0)))
qp.setBrush(QBrush(QColor(255,255,255)))

qp.drawArc(pt0[0]-r,pt0[1]-r,2*r,2*r,angle0*16,Dangle*16)

qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",10))


if 标记=='%数值':
    qp.drawText(pt0[0]+dx,pt0[1]+dy,"%.2f"%(Dangle))
else:
    qp.drawText(pt0[0]+dx,pt0[1]+dy,str(标记))

qp.drawPoint(pt0[0]+dx,pt0[1]+dy)

qp.setFont(QFont())




## end
#809, 13:
-125.0, -91.0
## end
#811, 13:
108.75, 54.75
## end
#813, 37:
107.22365421547073, 52.38812799054895
## end
#815, 12:
107.0, -95.0
## end
#817, 17:
57.96830377078075
## end
#825, 62:
+[返回目录]
+[内容]
pt11::
pt12::
pt21::
pt22::
angle::
中心::
起始角度::

## end
#833, 14:
+[返回目录]
+[内容]

## end
#836, 940:
"""
+[返回目录](,P代码)

+[P函数](,P代码)

输出:...
+[设置结构](,输出)

"""

Dx1=pt11[0]-pt12[0]
Dy1=pt11[1]-pt12[1]

Dx2=pt21[0]-pt22[0]
Dy2=pt21[1]-pt22[1]

D1=pt11[0]*Dy1-pt11[1]*Dx1
D2=pt21[0]*Dy2-pt21[1]*Dx2

L=Dy1*Dx2-Dy2*Dx1
if L==0:
    pt0="None"
else:
    pt0=[(D1*Dx2-D2*Dx1)/L, (D1*Dy2-D2*Dy1)/L]
    if np.sqrt((pt0[0]-pt11[0])**2+(pt0[1]-pt11[1])**2) < np.sqrt((pt0[0]-pt12[0])**2+(pt0[1]-pt12[1])**2):
        Dx1=-Dx1
        Dy1=-Dy1
    
    if np.sqrt((pt0[0]-pt21[0])**2+(pt0[1]-pt21[1])**2) < np.sqrt((pt0[0]-pt22[0])**2+(pt0[1]-pt22[1])**2):
        Dx2=-Dx2
        Dy2=-Dy2

    sign=np.sign(Dx1*Dy2-Dx2*Dy1)
    Dtheta=np.arccos((Dx1*Dx2+Dy1*Dy2)/np.sqrt((Dx1**2+Dy1**2)*(Dx2**2+Dy2**2)))
    angle=np.rad2deg(Dtheta)*sign

    theta0=np.arccos(Dx1/np.sqrt(Dx1**2+Dy1**2))
    angle0=np.rad2deg(theta0)*np.sign(Dy1)

    print(Dy1/np.sqrt(Dx1**2+Dy1**2),theta0,angle0)

    中心=pt0
    起始角度=angle0


"""
+[P函数](,P代码)
+[设置结构](,输出)

"""
## end
#837, 2:
角度
## end
#839, 15:
文档\物理问题\波包.ftxt
## end
#840, 45:
http://toolbox.lightcon.com/tools/gratingpair
## end
#841, 65:
file:///C:/Users/cheng/Desktop/paper/gratingTreacy(69).pdf#page=2
## end
#842, 4:
-100
## end
#843, 3:
l_2
## end
#844, 1:
1
## end
#845, 8:
DashLine
## end
#846, 5:
0,0,0
## end
#847, 40:
-1.7993952627139151, -122.55922224361282
## end
#848, 39:
-44.98488156784782, -122.55922224361282
## end
#856, 50:
线颜色::0,0,0
线型::DashLine
线粗细::2
文字::10 cm
位移距离::20

## end
#858, 1487:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var pt1=[%起点];
var pt2=[%终点];


//arrows
var angle=30/180*Math.PI;
var l=20;
var D=%位移距离;
var d=10;

r=Math.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2);
if (r!=0) {
    theta=Math.sign(pt1[1]-pt2[1])*Math.acos((pt2[0]-pt1[0])/r);
}

dp21=[l*Math.cos(theta-angle/2),-l*Math.sin(theta-angle/2)];
dp22=[l*Math.cos(theta+angle/2),-l*Math.sin(theta+angle/2)];

Dx=D*Math.cos(theta-90/180*Math.PI);
Dy=-D*Math.sin(theta-90/180*Math.PI);
pt10=[0,0];
pt20=[0,0];
pt10[0]=pt1[0]+Dx;
pt10[1]=pt1[1]+Dy;
pt20[0]=pt2[0]+Dx;
pt20[1]=pt2[1]+Dy;


ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();


ctx.moveTo(pt10[0],pt10[1]);
ctx.lineTo(pt10[0]+dp21[0],pt10[1]+dp21[1]);
ctx.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1]);
ctx.lineTo(pt10[0],pt10[1]);

ctx.moveTo(pt20[0],pt20[1]);
ctx.lineTo(pt20[0]-dp21[0],pt20[1]-dp21[1]);
ctx.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1]);
ctx.lineTo(pt20[0],pt20[1]);

ctx.moveTo(pt1[0],pt1[1]);
ctx.lineTo(pt10[0],pt10[1]);
ctx.moveTo(pt2[0],pt2[1]);
ctx.lineTo(pt20[0],pt20[1]);

ctx.moveTo(pt10[0],pt10[1]);
ctx.lineTo(pt20[0],pt20[1]);

ctx.stroke()
ctx.fill()


// text
dx=d*Math.cos(theta-90/180*Math.PI)
dy=-d*Math.sin(theta-90/180*Math.PI)
pt0=[0,0]
pt0[0]=(pt10[0]+pt20[0])/2+dx
pt0[1]=(pt10[1]+pt20[1])/2+dy


ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
L=300
H=100
ctx.fillText('%文字',pt0[0],pt0[1]);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#859, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#861, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#862, 14:
+[返回目录]
+[内容]

## end
#865, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#869, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#870, 2:
直线
## end
#871, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#872, 1610:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

angle=30
l=20
D=位移距离[0]
d=10
text=文字


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush(QColor(edgeColor[0],edgeColor[1],edgeColor[2])))

r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
if r!=0:
    theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]

Dx=D*np.cos(np.deg2rad(theta-90))
Dy=-D*np.sin(np.deg2rad(theta-90))
pt10=[0,0]
pt20=[0,0]
pt10[0]=pt1[0]+Dx
pt10[1]=pt1[1]+Dy
pt20[0]=pt2[0]+Dx
pt20[1]=pt2[1]+Dy

path1=QPainterPath()
path1.moveTo(pt10[0],pt10[1])
path1.lineTo(pt10[0]+dp21[0],pt10[1]+dp21[1])
path1.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1])
path1.lineTo(pt10[0],pt10[1])

path2=QPainterPath()
path2.moveTo(pt20[0],pt20[1])
path2.lineTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])
path2.lineTo(pt20[0],pt20[1])

qp.drawPath(path1)
qp.drawPath(path2)
qp.drawLine(pt1[0],pt1[1],pt10[0],pt10[1])
qp.drawLine(pt2[0],pt2[1],pt20[0],pt20[1])


dx=d*np.cos(np.deg2rad(theta-90))
dy=-d*np.sin(np.deg2rad(theta-90))
pt0=[0,0]
pt0[0]=(pt10[0]+pt20[0])/2+dx
pt0[1]=(pt10[1]+pt20[1])/2+dy

L=300
H=100
qp.drawText(pt0[0]-L/2,pt0[1]-H/2,L,H,Qt.AlignHCenter|Qt.AlignVCenter,text)

qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])

qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#878, 1610:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

angle=30
l=20
D=位移距离[0]
d=10
text=文字


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush(QColor(edgeColor[0],edgeColor[1],edgeColor[2])))

r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
if r!=0:
    theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]

Dx=D*np.cos(np.deg2rad(theta-90))
Dy=-D*np.sin(np.deg2rad(theta-90))
pt10=[0,0]
pt20=[0,0]
pt10[0]=pt1[0]+Dx
pt10[1]=pt1[1]+Dy
pt20[0]=pt2[0]+Dx
pt20[1]=pt2[1]+Dy

path1=QPainterPath()
path1.moveTo(pt10[0],pt10[1])
path1.lineTo(pt10[0]+dp21[0],pt10[1]+dp21[1])
path1.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1])
path1.lineTo(pt10[0],pt10[1])

path2=QPainterPath()
path2.moveTo(pt20[0],pt20[1])
path2.lineTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])
path2.lineTo(pt20[0],pt20[1])

qp.drawPath(path1)
qp.drawPath(path2)
qp.drawLine(pt1[0],pt1[1],pt10[0],pt10[1])
qp.drawLine(pt2[0],pt2[1],pt20[0],pt20[1])


dx=d*np.cos(np.deg2rad(theta-90))
dy=-d*np.sin(np.deg2rad(theta-90))
pt0=[0,0]
pt0[0]=(pt10[0]+pt20[0])/2+dx
pt0[1]=(pt10[1]+pt20[1])/2+dy

L=300
H=100
qp.drawText(pt0[0]-L/2,pt0[1]-H/2,L,H,Qt.AlignHCenter|Qt.AlignVCenter,text)

qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])

qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#890, 123:
+[返回目录](,长度)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1
文字::l_2
位移距离::20

画图:...
选中区域:...
HTML:...


## end
#891, 1:
1
## end
#892, 8:
DashLine
## end
#893, 5:
0,0,0
## end
#894, 38:
-46.10634974150391, -120.6033260550735
## end
#895, 24:
0.0, -120.24319670553152
## end
#901, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#903, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#904, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#906, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#907, 14:
+[返回目录]
+[内容]

## end
#910, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#914, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#915, 2:
直线
## end
#916, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#917, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#923, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#933, 129:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#934, 4:
None
## end
#935, 4:
None
## end
#936, 1:
2
## end
#937, 8:
DashLine
## end
#938, 2:
10
## end
#939, 3:
l_1
## end
#940, 2:
矩形
## end
#941, 38:
45.501511843215226, 43.702116580501304
## end
#942, 40:
-2.9574080317545715, -127.69909289407087
## end
#951, 101:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100

## end
#952, 14:
+[返回目录]
+[内容]

## end
#955, 655:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#956, 14:
+[返回目录]
+[内容]

## end
#959, 231:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


## end
#960, 855:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#961, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#967, 855:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#980, 148:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...



## end
#981, 3:
-80
## end
#982, 1:
D
## end
#983, 1:
1
## end
#984, 8:
DashLine
## end
#985, 5:
0,0,0
## end
#986, 37:
61.88526633696034, -65.13094666611808
## end
#987, 37:
9.009738751968428, -152.1073579834598
## end
#995, 50:
线颜色::0,0,0
线型::DashLine
线粗细::2
文字::10 cm
位移距离::20

## end
#997, 1487:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var pt1=[%起点];
var pt2=[%终点];


//arrows
var angle=30/180*Math.PI;
var l=20;
var D=%位移距离;
var d=10;

r=Math.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2);
if (r!=0) {
    theta=Math.sign(pt1[1]-pt2[1])*Math.acos((pt2[0]-pt1[0])/r);
}

dp21=[l*Math.cos(theta-angle/2),-l*Math.sin(theta-angle/2)];
dp22=[l*Math.cos(theta+angle/2),-l*Math.sin(theta+angle/2)];

Dx=D*Math.cos(theta-90/180*Math.PI);
Dy=-D*Math.sin(theta-90/180*Math.PI);
pt10=[0,0];
pt20=[0,0];
pt10[0]=pt1[0]+Dx;
pt10[1]=pt1[1]+Dy;
pt20[0]=pt2[0]+Dx;
pt20[1]=pt2[1]+Dy;


ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();


ctx.moveTo(pt10[0],pt10[1]);
ctx.lineTo(pt10[0]+dp21[0],pt10[1]+dp21[1]);
ctx.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1]);
ctx.lineTo(pt10[0],pt10[1]);

ctx.moveTo(pt20[0],pt20[1]);
ctx.lineTo(pt20[0]-dp21[0],pt20[1]-dp21[1]);
ctx.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1]);
ctx.lineTo(pt20[0],pt20[1]);

ctx.moveTo(pt1[0],pt1[1]);
ctx.lineTo(pt10[0],pt10[1]);
ctx.moveTo(pt2[0],pt2[1]);
ctx.lineTo(pt20[0],pt20[1]);

ctx.moveTo(pt10[0],pt10[1]);
ctx.lineTo(pt20[0],pt20[1]);

ctx.stroke()
ctx.fill()


// text
dx=d*Math.cos(theta-90/180*Math.PI)
dy=-d*Math.sin(theta-90/180*Math.PI)
pt0=[0,0]
pt0[0]=(pt10[0]+pt20[0])/2+dx
pt0[1]=(pt10[1]+pt20[1])/2+dy


ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
L=300
H=100
ctx.fillText('%文字',pt0[0],pt0[1]);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#998, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1000, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1001, 14:
+[返回目录]
+[内容]

## end
#1004, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#1008, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#1009, 2:
直线
## end
#1010, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1011, 1610:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

angle=30
l=20
D=位移距离[0]
d=10
text=文字


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush(QColor(edgeColor[0],edgeColor[1],edgeColor[2])))

r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
if r!=0:
    theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]

Dx=D*np.cos(np.deg2rad(theta-90))
Dy=-D*np.sin(np.deg2rad(theta-90))
pt10=[0,0]
pt20=[0,0]
pt10[0]=pt1[0]+Dx
pt10[1]=pt1[1]+Dy
pt20[0]=pt2[0]+Dx
pt20[1]=pt2[1]+Dy

path1=QPainterPath()
path1.moveTo(pt10[0],pt10[1])
path1.lineTo(pt10[0]+dp21[0],pt10[1]+dp21[1])
path1.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1])
path1.lineTo(pt10[0],pt10[1])

path2=QPainterPath()
path2.moveTo(pt20[0],pt20[1])
path2.lineTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])
path2.lineTo(pt20[0],pt20[1])

qp.drawPath(path1)
qp.drawPath(path2)
qp.drawLine(pt1[0],pt1[1],pt10[0],pt10[1])
qp.drawLine(pt2[0],pt2[1],pt20[0],pt20[1])


dx=d*np.cos(np.deg2rad(theta-90))
dy=-d*np.sin(np.deg2rad(theta-90))
pt0=[0,0]
pt0[0]=(pt10[0]+pt20[0])/2+dx
pt0[1]=(pt10[1]+pt20[1])/2+dy

L=300
H=100
qp.drawText(pt0[0]-L/2,pt0[1]-H/2,L,H,Qt.AlignHCenter|Qt.AlignVCenter,text)

qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])

qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#1017, 1610:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

angle=30
l=20
D=位移距离[0]
d=10
text=文字


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush(QColor(edgeColor[0],edgeColor[1],edgeColor[2])))

r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
if r!=0:
    theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]

Dx=D*np.cos(np.deg2rad(theta-90))
Dy=-D*np.sin(np.deg2rad(theta-90))
pt10=[0,0]
pt20=[0,0]
pt10[0]=pt1[0]+Dx
pt10[1]=pt1[1]+Dy
pt20[0]=pt2[0]+Dx
pt20[1]=pt2[1]+Dy

path1=QPainterPath()
path1.moveTo(pt10[0],pt10[1])
path1.lineTo(pt10[0]+dp21[0],pt10[1]+dp21[1])
path1.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1])
path1.lineTo(pt10[0],pt10[1])

path2=QPainterPath()
path2.moveTo(pt20[0],pt20[1])
path2.lineTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])
path2.lineTo(pt20[0],pt20[1])

qp.drawPath(path1)
qp.drawPath(path2)
qp.drawLine(pt1[0],pt1[1],pt10[0],pt10[1])
qp.drawLine(pt2[0],pt2[1],pt20[0],pt20[1])


dx=d*np.cos(np.deg2rad(theta-90))
dy=-d*np.sin(np.deg2rad(theta-90))
pt0=[0,0]
pt0[0]=(pt10[0]+pt20[0])/2+dx
pt0[1]=(pt10[1]+pt20[1])/2+dy

L=300
H=100
qp.drawText(pt0[0]-L/2,pt0[1]-H/2,L,H,Qt.AlignHCenter|Qt.AlignVCenter,text)

qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])

qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#1029, 125:
+[返回目录](,长度)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1
文字::10 cm
位移距离::20

画图:...
选中区域:...
HTML:...


## end
#1030, 112:
+[返回目录](,角度)

数值::
中心::
半径::20
起始角度::
类型::角度

标记::beta

画图:...
HTML:...
P代码:...
+[P函数](,P代码)



+[创建输入](标记,画图)


## end
#1031, 113:
+[返回目录](,角度)

数值::
中心::
半径::20
起始角度::
类型::角度

标记::theta

画图:...
HTML:...
P代码:...
+[P函数](,P代码)



+[创建输入](标记,画图)


## end
#1032, 1:
1
## end
#1033, 8:
DashLine
## end
#1034, 5:
0,0,0
## end
#1035, 38:
5.482750000000095, -36.123484999999995
## end
#1036, 39:
-44.73013599999998, -122.80741700000003
## end
#1042, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#1044, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1045, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1047, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1048, 14:
+[返回目录]
+[内容]

## end
#1051, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#1055, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#1056, 2:
直线
## end
#1057, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1058, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1064, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1074, 129:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#1075, 1:
1
## end
#1076, 8:
DashLine
## end
#1077, 7:
0,0,255
## end
#1078, 6:
0,-148
## end
#1079, 13:
244.0, -148.0
## end
#1085, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#1087, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1088, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1090, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1091, 14:
+[返回目录]
+[内容]

## end
#1094, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#1098, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#1099, 2:
直线
## end
#1100, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1101, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1107, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1117, 129:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#1118, 1:
1
## end
#1119, 8:
DashLine
## end
#1120, 7:
0,0,255
## end
#1121, 12:
-1.0, -147.0
## end
#1122, 10:
7.0, -34.0
## end
#1128, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#1130, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1131, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1133, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1134, 14:
+[返回目录]
+[内容]

## end
#1137, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#1141, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#1142, 2:
直线
## end
#1143, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1144, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1150, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1160, 129:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#1161, 1:
1
## end
#1162, 8:
DashLine
## end
#1163, 7:
255,0,0
## end
#1164, 13:
-27.0, -131.0
## end
#1165, 13:
240.0, -131.0
## end
#1171, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#1173, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1174, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1176, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1177, 14:
+[返回目录]
+[内容]

## end
#1180, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#1184, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#1185, 2:
直线
## end
#1186, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1187, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1193, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1203, 129:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#1204, 1:
1
## end
#1205, 8:
DashLine
## end
#1206, 7:
255,0,0
## end
#1207, 37:
7.351082000000034, -34.05676999999999
## end
#1208, 39:
-29.06394388401367, -131.12721744944702
## end
#1214, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#1216, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1217, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1219, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1220, 14:
+[返回目录]
+[内容]

## end
#1223, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#1227, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#1228, 2:
直线
## end
#1229, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1230, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1236, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1246, 129:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#1247, 1:
1
## end
#1248, 8:
DashLine
## end
#1249, 5:
0,0,0
## end
#1250, 10:
9.5, -34.5
## end
#1251, 38:
-463.9490300000001, -34.05676999999999
## end
#1257, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#1259, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1260, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1262, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1263, 14:
+[返回目录]
+[内容]

## end
#1266, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#1270, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#1271, 2:
直线
## end
#1272, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1273, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1279, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1289, 144:
+[返回目录](,直线)
+[设置结构](,入射光线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#1290, 9:
Grating B
## end
#1291, 1:
2
## end
#1292, 8:
DashLine
## end
#1293, 5:
0,0,0
## end
#1294, 11:
255,255,255
## end
#1295, 3:
-60
## end
#1296, 18:
48.373546489791295
## end
#1297, 13:
-13.0, -140.0
## end
#1298, 2:
10
## end
#1308, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#1310, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1313, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#1314, 14:
+[返回目录]
+[内容]

## end
#1317, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#1318, 2:
圆形
## end
#1319, 804:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


x0=pt[0]
y0=pt[1]
M=qp.transform()
M.translate(x0,y0)
M.rotate(-angle+90)
M.translate(-x0,-y0)

M0=qp.transform()
qp.setTransform(M)

qp.drawRect(x0-r,y0,2*r,d)

qp.setTransform(M0)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(x0-area,y0+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#1320, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#1326, 804:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


x0=pt[0]
y0=pt[1]
M=qp.transform()
M.translate(x0,y0)
M.rotate(-angle+90)
M.translate(-x0,-y0)

M0=qp.transform()
qp.setTransform(M)

qp.drawRect(x0-r,y0,2*r,d)

qp.setTransform(M0)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(x0-area,y0+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#1340, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#1341, 9:
Grating A
## end
#1342, 1:
2
## end
#1343, 8:
DashLine
## end
#1344, 5:
0,0,0
## end
#1345, 11:
255,255,255
## end
#1346, 3:
120
## end
#1347, 18:
48.373546489791295
## end
#1348, 11:
17.0, -40.0
## end
#1349, 2:
10
## end
#1359, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#1361, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1364, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#1365, 14:
+[返回目录]
+[内容]

## end
#1368, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#1369, 2:
圆形
## end
#1370, 804:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


x0=pt[0]
y0=pt[1]
M=qp.transform()
M.translate(x0,y0)
M.rotate(-angle+90)
M.translate(-x0,-y0)

M0=qp.transform()
qp.setTransform(M)

qp.drawRect(x0-r,y0,2*r,d)

qp.setTransform(M0)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(x0-area,y0+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#1371, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#1377, 804:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


x0=pt[0]
y0=pt[1]
M=qp.transform()
M.translate(x0,y0)
M.rotate(-angle+90)
M.translate(-x0,-y0)

M0=qp.transform()
qp.setTransform(M)

qp.drawRect(x0-r,y0,2*r,d)

qp.setTransform(M0)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(x0-area,y0+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#1391, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#1407, 217:
+[返回目录](,光栅对)


光栅1:...
光栅2:...
入射光线:
内部光线1:
出射光线1:
内部光线2:
出射光线2:
法线1:...
theta:...
beta:...
水平距离:...
标记水平距离:...

+[删除结构](,beta)
+[创建角度](,beta)

间距:
+[创建长度](,标记水平距离)
+beta(内部光线1,法线1)->+[创建角度](,+beta)
+[创建直线](,水平距离)



## end
#1412, 5240:
<!--
+[返回目录](,光栅色散)
+[H函数](,光栅色散)

光栅对(画板):...
+画板(光栅对,)
画板(光栅对,)->+[del](,画板)
+[画板](+光栅画板,光栅对)
-->
%光栅对
<br>
<b><u>Phase of a grating compressor</u></b><br>
Consider a grating compressor with two gratings. The grating constant for both of them is \(d\). The distance between them is \(D\). Assuming \(\theta\) is the angle between the incoming beam and the normal line of the grating and \(\beta\) is the diffraction angle.<br>
Then, 
$$
sin(\theta)+sin(\beta) = \frac{n \lambda}{d}
$$
The total length of the light path is,
$$
l=l_1-l_2
\\
l_1=D/cos(\beta)
\\
l_2=D\ tan(\beta) sin(\theta)
$$
Then, 
$$
l
=D\left(\frac{1-sin(\beta)sin(\theta)}{cos(\beta)}\right)
$$
The phase on the surface of the grating is changing over the distance. When you scattered different color beams into one beam, those beams should be scattered from different locations. We need to add this difference to compensate the phase shift. <br>
If the distance is \(d\), which is the cycle length, the phase difference will be \(2 n \pi\). Then if the distance is \(\Delta=D tan \beta\), the phase difference is, 
$$
\Delta \phi = (2 n \pi)\frac{\Delta}{d}
=\frac{2 n \pi D tan \beta}{d}
$$
Since here \(n=-1\), the total phase shift is, 
$$
\phi=\frac{\omega l}{c}+\Delta \phi
=
\frac{\omega D}{c}
\left(\frac{1-sin(\beta)sin(\theta)}{cos(\beta)}\right)
-
\frac{2 \pi D tan \beta}{d}
$$
The 1st order differential over \(\omega\) is, 
$$
\frac{\partial \phi}{\partial \omega}
=
\frac{\partial}{\partial \omega}
\frac{\omega D}{c}
\left(\frac{1-sin(\beta)sin(\theta)}{cos(\beta)}\right)
-
\frac{\partial}{\partial \omega}
\frac{2 \pi D tan \beta}{d}
$$$$
=
\frac{D}{c}
\left(\frac{1-sin(\beta)sin(\theta)}{cos(\beta)}\right)
+
\frac{\omega D}{c}
\frac{\partial}{\partial \omega}
\left(\frac{1-sin(\beta)sin(\theta)}{cos(\beta)}\right)
-
\frac{\partial}{\partial \omega}
\frac{2 \pi D tan \beta}{d}
$$

Since \(\beta\) is a function of the wavelength \(\lambda\), we have,
$$
sin(\beta)=\frac{n\lambda}{d}-sin(\theta)
=\frac{2 n \pi c}{\omega d}
-sin(\theta)
$$$$
\frac{d sin(\beta)}{d \omega}
=cos(\beta)\frac{d \beta}{d \omega}
=\frac{d}{d \omega}
\frac{2 n \pi c}{\omega d}
=-\frac{2 n \pi c}{\omega^2 d}
$$
$$
\frac{d \beta}{d \omega}
=-\frac{2 n \pi c}{cos(\beta)\omega^2 d}
$$
And we have, 
$$
\frac{d}{d\omega} tan\beta
=-\frac{1}{cos\beta^2}\frac{d\beta}{d\omega}
$$$$
\frac{d}{d\omega} \frac{1}{cos\beta}
=\frac{sin\beta}{cos\beta^2}\frac{d\beta}{d\omega}
$$
Then the result is, 
$$
\frac{\partial \phi}{\partial \omega}
=
\frac{D}{c}
\left(\frac{1-sin(\beta)sin(\theta)}{cos(\beta)}\right)
+
\frac{\omega D}{c}
\frac{\partial}{\partial \omega}
\left(\frac{1-sin(\beta)sin(\theta)}{cos(\beta)}\right)
-
\frac{\partial}{\partial \omega}
\frac{2 \pi D tan \beta}{d}
$$$$
=
\frac{l}{c}
+
\frac{\omega D}{c}
\frac{\partial}{\partial \omega}\frac{1}{cos\beta}
-
\frac{\omega D sin\theta}{c}
\frac{\partial}{\partial \omega}
tan\beta
-
\frac{2 \pi D}{d}
\frac{\partial}{\partial \omega}
tan \beta
$$$$
=
\frac{l}{c}
+
\frac{\omega D}{c}
\frac{sin\beta}{cos\beta^2}\frac{d\beta}{d\omega}
+
\left(
\frac{\omega D sin\theta}{c}
+
\frac{2 \pi D}{d}
\right)
\frac{1}{cos\beta^2}\frac{d\beta}{d\omega}
$$
$$
=
\frac{l}{c}
+
\frac{\omega D}{c}
\frac{(sin\beta+sin\theta)}
{cos\beta^2}\frac{d\beta}{d\omega}
+
\frac{2 \pi D}{d}
\frac{1}{cos\beta^2}\frac{d\beta}{d\omega}

=\frac{l}{c}
$$
And,
$$
l
=D\left(\frac{1-sin(\beta)sin(\theta)}{cos(\beta)}\right)
$$
<br>
<b><u>Second order dispersion</u></b><br>
$$
\frac{\partial^2 \phi}{\partial \omega^2}
=\frac{\partial}{\partial \omega}
\frac{l}{c}
=
-\frac{2 \pi D}{\omega d}
\frac{1}{cos\beta^2}\frac{d\beta}{d\omega}
\\
=
\frac{2 \pi D}{d^2}
\frac{2 n \pi c}{cos\beta^3\omega^3}
=
-\frac{4 \pi^2 c D}{\omega^3 d^2}
\frac{1}{cos\beta^3}
=
-\frac{4 \pi^2 c D}{\omega^3 d^2}
\frac{1}{(1-sin\beta^2)^{3/2}}
\\
=
-\frac{4 \pi^2 c D}{\omega^3 d^2}
\frac{1}{[1-(\lambda/d+sin\theta)^2]^{3/2}}
$$
<br>



(something wrong...)<br>
<b><u>Third order dispersion</u></b><br>
$$
\frac{\partial^3 \phi}{\partial \omega^3}
=-
\frac{4 \pi^2 c D}{d^2}
\frac{\partial}{\partial \omega}
\frac{1}{\omega^2 cos\beta^3}
=
\frac{4 \pi^2 c D}{d^2}
\left(
\frac{2}{\omega^3}
\frac{1}{cos\beta^3}
-
\frac{1}{\omega^2}
\frac{\partial}{\partial \omega}
\frac{1}{cos\beta^3}
\right)
\\
=
\frac{4 \pi^2 c D}{d^2}
\left(
\frac{2}{\omega^3}
\frac{1}{cos\beta^3}
-
\frac{1}{\omega^2}
\frac{3 sin\beta}{cos\beta^4}
\right)
=
\frac{4 \pi^2 c D}
{\omega^2 d^2}
\frac{1}{cos\beta^3}
\left(
\frac{2}{\omega}
-
\frac{3 sin\beta}{cos\beta}
\right)
$$
We can write \(
(
2/\omega
-3 sin\beta/cos\beta
)
\) as a function of the incident angle, 
$$
\frac{2}{\omega}-\frac{3 sin\beta}{cos\beta}
=
\frac{1}{\omega}\frac{2 cos\beta-3 \omega sin\beta}{cos\beta}
$$$$
=
\frac{1}{\omega}\frac{2 \sqrt{1-sin\beta^2}
-3 \omega sin\beta}{\sqrt{1-sin\beta^2}}
$$




<!--
+[H函数](,光栅色散)
-->




<br><br><br><br><br>
I'm using the formula from Optics Toolbox directly then, 
$$
GDD(\lambda)=-\frac{\lambda^3 D}{\pi c^2 d^2}
\left[
1-\left(
\frac{\lambda}{d}-sin\theta
\right)^2
\right]^{-\frac{3}{2}}
$$

<!--
+[H函数](,光栅色散)

参考::file:///C:/Users/cheng/Desktop/paper/gratingTreacy(69).pdf#page=2
+[打开网页](,参考)
参考2::http://toolbox.lightcon.com/tools/gratingpair
+[打开网页](,参考2)
-->
## end
#1413, 18:
0.6495390000000002
## end
#1415, 8:
958, 476
## end
#1417, 11:
0.0, -100.0
## end
#1439, 18:
179.94636127792435
## end
#1440, 6:
[20.0]
## end
#1441, 37:
6.424844134934674, -34.49712112339934
## end
#1442, 17:
59.97146796251176
## end
#1443, 5:
theta
## end
#1449, 121:
+[返回目录]
+[内容]
标记::%数值
中心::-338.8789230341691, -3.8202594274802757
半径::10
起始角度::136.10929165904932
数值::62.220685781962224

## end
#1451, 775:
/*
+[返回目录](,HTML)

+[新建阅读窗口](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var pt0=[%中心];
var r=%半径;
var Dangle=%数值;
var angle0=%起始角度;
var text="%标记";

dx=1.5*r*Math.cos((angle0+Dangle)/180*Math.PI/2);
dy=1.5*r*Math.sin((angle0+Dangle)/180*Math.PI/2);


ctx.beginPath();
if(Dangle>0) {
    ctx.arc(pt0[0],pt0[1],r,angle0/180*Math.PI,(angle0+Dangle)/180*Math.PI);
} else {
    ctx.arc(pt0[0],pt0[1],r,(angle0+Dangle)/180*Math.PI,angle0/180*Math.PI);
}

ctx.strokeStyle='rgba(0,0,0)';
ctx.stroke();

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center';
ctx.textBaseline='middle';
ctx.font=8*2+'px serif';

if (text[0]==='%') {
    ctx.fillText(`${-Dangle.toFixed(2)}`,pt0[0]+dx,pt0[1]+dy);
} else {
    ctx.fillText(text,pt0[0]+dx,pt0[1]+dy);
}


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/

## end
#1453, 562:
"""
+[返回目录](,画图)

输入:...
+[设置结构](,输入)

"""

pt0=中心
r=半径[0]
angle0=-起始角度[0]
Dangle=-数值[0]

dx=r*np.cos(np.deg2rad(angle0+Dangle)/2)
dy=r*np.sin(np.deg2rad(angle0+Dangle)/2)


qp.setPen(QPen(QColor(0,0,0)))
qp.setBrush(QBrush(QColor(255,255,255)))

qp.drawArc(pt0[0]-r,pt0[1]-r,2*r,2*r,angle0*16,Dangle*16)

qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",10))


if 标记=='%数值':
    qp.drawText(pt0[0]+dx,pt0[1]+dy,"%.2f"%(Dangle))
else:
    qp.drawText(pt0[0]+dx,pt0[1]+dy,str(标记))

qp.drawPoint(pt0[0]+dx,pt0[1]+dy)

qp.setFont(QFont())




## end
#1455, 38:
-463.9490300000001, -34.05676999999999
## end
#1457, 10:
9.5, -34.5
## end
#1459, 39:
-44.73013599999998, -122.80741700000003
## end
#1461, 38:
5.482750000000095, -36.123484999999995
## end
#1463, 17:
59.97146796251176
## end
#1471, 62:
+[返回目录]
+[内容]
pt11::
pt12::
pt21::
pt22::
angle::
中心::
起始角度::

## end
#1479, 14:
+[返回目录]
+[内容]

## end
#1482, 940:
"""
+[返回目录](,P代码)

+[P函数](,P代码)

输出:...
+[设置结构](,输出)

"""

Dx1=pt11[0]-pt12[0]
Dy1=pt11[1]-pt12[1]

Dx2=pt21[0]-pt22[0]
Dy2=pt21[1]-pt22[1]

D1=pt11[0]*Dy1-pt11[1]*Dx1
D2=pt21[0]*Dy2-pt21[1]*Dx2

L=Dy1*Dx2-Dy2*Dx1
if L==0:
    pt0="None"
else:
    pt0=[(D1*Dx2-D2*Dx1)/L, (D1*Dy2-D2*Dy1)/L]
    if np.sqrt((pt0[0]-pt11[0])**2+(pt0[1]-pt11[1])**2) < np.sqrt((pt0[0]-pt12[0])**2+(pt0[1]-pt12[1])**2):
        Dx1=-Dx1
        Dy1=-Dy1
    
    if np.sqrt((pt0[0]-pt21[0])**2+(pt0[1]-pt21[1])**2) < np.sqrt((pt0[0]-pt22[0])**2+(pt0[1]-pt22[1])**2):
        Dx2=-Dx2
        Dy2=-Dy2

    sign=np.sign(Dx1*Dy2-Dx2*Dy1)
    Dtheta=np.arccos((Dx1*Dx2+Dy1*Dy2)/np.sqrt((Dx1**2+Dy1**2)*(Dx2**2+Dy2**2)))
    angle=np.rad2deg(Dtheta)*sign

    theta0=np.arccos(Dx1/np.sqrt(Dx1**2+Dy1**2))
    angle0=np.rad2deg(theta0)*np.sign(Dy1)

    print(Dy1/np.sqrt(Dx1**2+Dy1**2),theta0,angle0)

    中心=pt0
    起始角度=angle0


"""
+[P函数](,P代码)
+[设置结构](,输出)

"""
## end
#1483, 2:
角度
## end
#1503, 19:
-110.56308679580577
## end
#1504, 6:
[20.0]
## end
#1505, 38:
8.584541118517363, -30.768774848590777
## end
#1506, 18:
-9.519083963752843
## end
#1507, 4:
beta
## end
#1513, 121:
+[返回目录]
+[内容]
标记::%数值
中心::-338.8789230341691, -3.8202594274802757
半径::10
起始角度::136.10929165904932
数值::62.220685781962224

## end
#1515, 775:
/*
+[返回目录](,HTML)

+[新建阅读窗口](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var pt0=[%中心];
var r=%半径;
var Dangle=%数值;
var angle0=%起始角度;
var text="%标记";

dx=1.5*r*Math.cos((angle0+Dangle)/180*Math.PI/2);
dy=1.5*r*Math.sin((angle0+Dangle)/180*Math.PI/2);


ctx.beginPath();
if(Dangle>0) {
    ctx.arc(pt0[0],pt0[1],r,angle0/180*Math.PI,(angle0+Dangle)/180*Math.PI);
} else {
    ctx.arc(pt0[0],pt0[1],r,(angle0+Dangle)/180*Math.PI,angle0/180*Math.PI);
}

ctx.strokeStyle='rgba(0,0,0)';
ctx.stroke();

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center';
ctx.textBaseline='middle';
ctx.font=8*2+'px serif';

if (text[0]==='%') {
    ctx.fillText(`${-Dangle.toFixed(2)}`,pt0[0]+dx,pt0[1]+dy);
} else {
    ctx.fillText(text,pt0[0]+dx,pt0[1]+dy);
}


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/

## end
#1517, 562:
"""
+[返回目录](,画图)

输入:...
+[设置结构](,输入)

"""

pt0=中心
r=半径[0]
angle0=-起始角度[0]
Dangle=-数值[0]

dx=r*np.cos(np.deg2rad(angle0+Dangle)/2)
dy=r*np.sin(np.deg2rad(angle0+Dangle)/2)


qp.setPen(QPen(QColor(0,0,0)))
qp.setBrush(QBrush(QColor(255,255,255)))

qp.drawArc(pt0[0]-r,pt0[1]-r,2*r,2*r,angle0*16,Dangle*16)

qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",10))


if 标记=='%数值':
    qp.drawText(pt0[0]+dx,pt0[1]+dy,"%.2f"%(Dangle))
else:
    qp.drawText(pt0[0]+dx,pt0[1]+dy,str(标记))

qp.drawPoint(pt0[0]+dx,pt0[1]+dy)

qp.setFont(QFont())




## end
#1519, 39:
-29.06394388401367, -131.12721744944702
## end
#1521, 37:
7.351082000000034, -34.05676999999999
## end
#1523, 39:
-44.73013599999998, -122.80741700000003
## end
#1525, 38:
5.482750000000095, -36.123484999999995
## end
#1527, 18:
-9.519083963752843
## end
#1535, 62:
+[返回目录]
+[内容]
pt11::
pt12::
pt21::
pt22::
angle::
中心::
起始角度::

## end
#1543, 14:
+[返回目录]
+[内容]

## end
#1546, 940:
"""
+[返回目录](,P代码)

+[P函数](,P代码)

输出:...
+[设置结构](,输出)

"""

Dx1=pt11[0]-pt12[0]
Dy1=pt11[1]-pt12[1]

Dx2=pt21[0]-pt22[0]
Dy2=pt21[1]-pt22[1]

D1=pt11[0]*Dy1-pt11[1]*Dx1
D2=pt21[0]*Dy2-pt21[1]*Dx2

L=Dy1*Dx2-Dy2*Dx1
if L==0:
    pt0="None"
else:
    pt0=[(D1*Dx2-D2*Dx1)/L, (D1*Dy2-D2*Dy1)/L]
    if np.sqrt((pt0[0]-pt11[0])**2+(pt0[1]-pt11[1])**2) < np.sqrt((pt0[0]-pt12[0])**2+(pt0[1]-pt12[1])**2):
        Dx1=-Dx1
        Dy1=-Dy1
    
    if np.sqrt((pt0[0]-pt21[0])**2+(pt0[1]-pt21[1])**2) < np.sqrt((pt0[0]-pt22[0])**2+(pt0[1]-pt22[1])**2):
        Dx2=-Dx2
        Dy2=-Dy2

    sign=np.sign(Dx1*Dy2-Dx2*Dy1)
    Dtheta=np.arccos((Dx1*Dx2+Dy1*Dy2)/np.sqrt((Dx1**2+Dy1**2)*(Dx2**2+Dy2**2)))
    angle=np.rad2deg(Dtheta)*sign

    theta0=np.arccos(Dx1/np.sqrt(Dx1**2+Dy1**2))
    angle0=np.rad2deg(theta0)*np.sign(Dy1)

    print(Dy1/np.sqrt(Dx1**2+Dy1**2),theta0,angle0)

    中心=pt0
    起始角度=angle0


"""
+[P函数](,P代码)
+[设置结构](,输出)

"""
## end
#1547, 2:
角度
## end
#1549, 259:
+[返回目录](,光栅对)

光栅宽度(html):...
+[H函数](,光栅宽度)
光栅色散(html):...
+[H函数](,光栅色散)
+[复制结构](,光栅色散)

回答一个问题, 不同光栅常数的光栅对, 是否可以通过调整间距和角度, 实现相似的GDD和TOD? 
暂时没办法比较TOD, 只能比较GDD. 应该可以先用着差一点的光栅. 

光栅对比(html):...
+参考(光栅对比,光栅宽度)->+参考(光栅对比,光栅色散)

+[粘贴](,光栅对)
估计compressor(M函数):...


## end
#1552, 749:
<!--
+[H函数](,光栅宽度)

场景(画板):...
+画板(场景,)
画板(场景,)->+[del](,画板)
+[画板](+新画板,场景)

+[新建阅读窗口](+新窗口,光栅宽度)
-->

%场景<br>
光栅公式为, 
$$
sin\beta=sin\alpha+\frac{n\lambda}{d}
$$
如果光栅对的间距为\(D\), 而光谱中红光的波长为\(\lambda_1\), 蓝光的波长为\(\lambda_2\), 那么在第二块光栅上, 这两种光的间距为, 
$$
L=D tan(\beta)=\frac{D sin(\beta)}{\sqrt{1-sin(\beta)^2}}
\\
=\frac{D (sin\alpha+n\lambda/d)}{\sqrt{1-(sin\alpha+n\lambda/d)^2}}
$$$$
\Delta L=L_2-L_1
\\
=\frac{D (sin\alpha+n\lambda_2/d)}{\sqrt{1-(sin\alpha+n\lambda_2/d)^2}}
-\frac{D (sin\alpha+n\lambda_1/d)}{\sqrt{1-(sin\alpha+n\lambda_1/d)^2}}
$$
接着计算, 在实验室参数下, 宽度为,
$$
D=18 cm, \alpha=51^\circ, 1/d=1480 mm^{-1}
\\
\lambda_1=740 nm, \lambda_2=850 nm
\\\Rightarrow
Width=3.83 cm
$$



<!--
+[H函数](,光栅宽度)

计算宽度(M函数):包括了扫二维参数...
+[M函数](,计算宽度)
-->

## end
#1555, 141:
+[返回目录](,场景)


光栅A:...
光栅B:...

入射光线:...
红光:...
蓝光:...
法线:...

alpha(入射光线,法线):...
beta1(红光,法线):...
beta2(蓝光,法线):...

间距:...

+[创建长度](,间距)




## end
#1557, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#1559, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#1573, 804:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


x0=pt[0]
y0=pt[1]
M=qp.transform()
M.translate(x0,y0)
M.rotate(-angle+90)
M.translate(-x0,-y0)

M0=qp.transform()
qp.setTransform(M)

qp.drawRect(x0-r,y0,2*r,d)

qp.setTransform(M0)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(x0-area,y0+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#1579, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#1580, 804:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


x0=pt[0]
y0=pt[1]
M=qp.transform()
M.translate(x0,y0)
M.rotate(-angle+90)
M.translate(-x0,-y0)

M0=qp.transform()
qp.setTransform(M)

qp.drawRect(x0-r,y0,2*r,d)

qp.setTransform(M0)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(x0-area,y0+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#1581, 2:
圆形
## end
#1582, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#1585, 14:
+[返回目录]
+[内容]

## end
#1586, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#1589, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1591, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#1601, 2:
10
## end
#1602, 12:
-290.0, 22.0
## end
#1603, 18:
48.373546489791295
## end
#1604, 2:
90
## end
#1605, 11:
255,255,255
## end
#1606, 5:
0,0,0
## end
#1607, 8:
DashLine
## end
#1608, 1:
2
## end
#1609, 1:
A
## end
#1610, 1:
1
## end
#1612, 8:
653, 220
## end
#1614, 11:
-300.0, 0.0
## end
#1630, 804:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


x0=pt[0]
y0=pt[1]
M=qp.transform()
M.translate(x0,y0)
M.rotate(-angle+90)
M.translate(-x0,-y0)

M0=qp.transform()
qp.setTransform(M)

qp.drawRect(x0-r,y0,2*r,d)

qp.setTransform(M0)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(x0-area,y0+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#1636, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#1637, 804:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


x0=pt[0]
y0=pt[1]
M=qp.transform()
M.translate(x0,y0)
M.rotate(-angle+90)
M.translate(-x0,-y0)

M0=qp.transform()
qp.setTransform(M)

qp.drawRect(x0-r,y0,2*r,d)

qp.setTransform(M0)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(x0-area,y0+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#1638, 2:
圆形
## end
#1639, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#1642, 14:
+[返回目录]
+[内容]

## end
#1643, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#1646, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1648, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#1658, 2:
10
## end
#1659, 13:
-214.0, -77.0
## end
#1660, 18:
48.373546489791295
## end
#1661, 3:
-90
## end
#1662, 11:
255,255,255
## end
#1663, 5:
0,0,0
## end
#1664, 8:
DashLine
## end
#1665, 1:
2
## end
#1666, 1:
B
## end
#1668, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#1670, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#1672, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#1682, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1688, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1689, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1690, 2:
直线
## end
#1691, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#1695, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#1698, 14:
+[返回目录]
+[内容]

## end
#1699, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1701, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1702, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1704, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#1710, 12:
-289.0, 21.0
## end
#1711, 14:
-549.0, -101.0
## end
#1712, 5:
0,0,0
## end
#1713, 1:
2
## end
#1714, 9:
SolidLine
## end
#1724, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1730, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1731, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1732, 2:
直线
## end
#1733, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#1737, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#1740, 14:
+[返回目录]
+[内容]

## end
#1741, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1743, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1744, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1746, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#1752, 13:
-239.0, -77.0
## end
#1753, 12:
-290.0, 22.0
## end
#1754, 7:
255,0,0
## end
#1755, 1:
2
## end
#1756, 9:
SolidLine
## end
#1766, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1772, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1773, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1774, 2:
直线
## end
#1775, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#1779, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#1782, 14:
+[返回目录]
+[内容]

## end
#1783, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1785, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1786, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1788, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#1794, 13:
-184.0, -77.0
## end
#1795, 12:
-290.0, 22.0
## end
#1796, 7:
0,0,255
## end
#1797, 1:
2
## end
#1798, 9:
SolidLine
## end
#1800, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#1810, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1816, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1817, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1818, 2:
直线
## end
#1819, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#1823, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#1826, 14:
+[返回目录]
+[内容]

## end
#1827, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1829, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1830, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1832, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#1838, 12:
-288.0, 22.0
## end
#1839, 14:
-288.0, -105.0
## end
#1840, 5:
0,0,0
## end
#1841, 1:
1
## end
#1842, 8:
DashLine
## end
#1844, 113:
+[返回目录](,角度)

数值::
中心::
半径::20
起始角度::
类型::角度

标记::alpha

画图:...
HTML:...
P代码:...
+[P函数](,P代码)



+[创建输入](标记,画图)


## end
#1846, 113:
+[返回目录](,角度)

数值::
中心::
半径::20
起始角度::
类型::角度

标记::beta1

画图:...
HTML:...
P代码:...
+[P函数](,P代码)



+[创建输入](标记,画图)


## end
#1848, 113:
+[返回目录](,角度)

数值::
中心::
半径::20
起始角度::
类型::角度

标记::beta2

画图:...
HTML:...
P代码:...
+[P函数](,P代码)



+[创建输入](标记,画图)


## end
#1868, 19:
-154.86258549748226
## end
#1869, 6:
[20.0]
## end
#1870, 25:
-288.0, 21.46923076923077
## end
#1871, 17:
64.86258549748226
## end
#1872, 5:
alpha
## end
#1878, 121:
+[返回目录]
+[内容]
标记::%数值
中心::-338.8789230341691, -3.8202594274802757
半径::10
起始角度::136.10929165904932
数值::62.220685781962224

## end
#1880, 775:
/*
+[返回目录](,HTML)

+[新建阅读窗口](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var pt0=[%中心];
var r=%半径;
var Dangle=%数值;
var angle0=%起始角度;
var text="%标记";

dx=1.5*r*Math.cos((angle0+Dangle)/180*Math.PI/2);
dy=1.5*r*Math.sin((angle0+Dangle)/180*Math.PI/2);


ctx.beginPath();
if(Dangle>0) {
    ctx.arc(pt0[0],pt0[1],r,angle0/180*Math.PI,(angle0+Dangle)/180*Math.PI);
} else {
    ctx.arc(pt0[0],pt0[1],r,(angle0+Dangle)/180*Math.PI,angle0/180*Math.PI);
}

ctx.strokeStyle='rgba(0,0,0)';
ctx.stroke();

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center';
ctx.textBaseline='middle';
ctx.font=8*2+'px serif';

if (text[0]==='%') {
    ctx.fillText(`${-Dangle.toFixed(2)}`,pt0[0]+dx,pt0[1]+dy);
} else {
    ctx.fillText(text,pt0[0]+dx,pt0[1]+dy);
}


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/

## end
#1882, 562:
"""
+[返回目录](,画图)

输入:...
+[设置结构](,输入)

"""

pt0=中心
r=半径[0]
angle0=-起始角度[0]
Dangle=-数值[0]

dx=r*np.cos(np.deg2rad(angle0+Dangle)/2)
dy=r*np.sin(np.deg2rad(angle0+Dangle)/2)


qp.setPen(QPen(QColor(0,0,0)))
qp.setBrush(QBrush(QColor(255,255,255)))

qp.drawArc(pt0[0]-r,pt0[1]-r,2*r,2*r,angle0*16,Dangle*16)

qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",10))


if 标记=='%数值':
    qp.drawText(pt0[0]+dx,pt0[1]+dy,"%.2f"%(Dangle))
else:
    qp.drawText(pt0[0]+dx,pt0[1]+dy,str(标记))

qp.drawPoint(pt0[0]+dx,pt0[1]+dy)

qp.setFont(QFont())




## end
#1884, 12:
-289.0, 21.0
## end
#1886, 14:
-549.0, -101.0
## end
#1888, 12:
-288.0, 22.0
## end
#1890, 14:
-288.0, -105.0
## end
#1892, 17:
64.86258549748226
## end
#1900, 62:
+[返回目录]
+[内容]
pt11::
pt12::
pt21::
pt22::
angle::
中心::
起始角度::

## end
#1908, 14:
+[返回目录]
+[内容]

## end
#1911, 940:
"""
+[返回目录](,P代码)

+[P函数](,P代码)

输出:...
+[设置结构](,输出)

"""

Dx1=pt11[0]-pt12[0]
Dy1=pt11[1]-pt12[1]

Dx2=pt21[0]-pt22[0]
Dy2=pt21[1]-pt22[1]

D1=pt11[0]*Dy1-pt11[1]*Dx1
D2=pt21[0]*Dy2-pt21[1]*Dx2

L=Dy1*Dx2-Dy2*Dx1
if L==0:
    pt0="None"
else:
    pt0=[(D1*Dx2-D2*Dx1)/L, (D1*Dy2-D2*Dy1)/L]
    if np.sqrt((pt0[0]-pt11[0])**2+(pt0[1]-pt11[1])**2) < np.sqrt((pt0[0]-pt12[0])**2+(pt0[1]-pt12[1])**2):
        Dx1=-Dx1
        Dy1=-Dy1
    
    if np.sqrt((pt0[0]-pt21[0])**2+(pt0[1]-pt21[1])**2) < np.sqrt((pt0[0]-pt22[0])**2+(pt0[1]-pt22[1])**2):
        Dx2=-Dx2
        Dy2=-Dy2

    sign=np.sign(Dx1*Dy2-Dx2*Dy1)
    Dtheta=np.arccos((Dx1*Dx2+Dy1*Dy2)/np.sqrt((Dx1**2+Dy1**2)*(Dx2**2+Dy2**2)))
    angle=np.rad2deg(Dtheta)*sign

    theta0=np.arccos(Dx1/np.sqrt(Dx1**2+Dy1**2))
    angle0=np.rad2deg(theta0)*np.sign(Dy1)

    print(Dy1/np.sqrt(Dx1**2+Dy1**2),theta0,angle0)

    中心=pt0
    起始角度=angle0


"""
+[P函数](,P代码)
+[设置结构](,输出)

"""
## end
#1912, 2:
角度
## end
#1932, 18:
-62.74467162505693
## end
#1933, 6:
[20.0]
## end
#1934, 25:
-288.0, 18.11764705882353
## end
#1935, 19:
-27.255328374943076
## end
#1936, 5:
beta1
## end
#1942, 121:
+[返回目录]
+[内容]
标记::%数值
中心::-338.8789230341691, -3.8202594274802757
半径::10
起始角度::136.10929165904932
数值::62.220685781962224

## end
#1944, 775:
/*
+[返回目录](,HTML)

+[新建阅读窗口](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var pt0=[%中心];
var r=%半径;
var Dangle=%数值;
var angle0=%起始角度;
var text="%标记";

dx=1.5*r*Math.cos((angle0+Dangle)/180*Math.PI/2);
dy=1.5*r*Math.sin((angle0+Dangle)/180*Math.PI/2);


ctx.beginPath();
if(Dangle>0) {
    ctx.arc(pt0[0],pt0[1],r,angle0/180*Math.PI,(angle0+Dangle)/180*Math.PI);
} else {
    ctx.arc(pt0[0],pt0[1],r,(angle0+Dangle)/180*Math.PI,angle0/180*Math.PI);
}

ctx.strokeStyle='rgba(0,0,0)';
ctx.stroke();

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center';
ctx.textBaseline='middle';
ctx.font=8*2+'px serif';

if (text[0]==='%') {
    ctx.fillText(`${-Dangle.toFixed(2)}`,pt0[0]+dx,pt0[1]+dy);
} else {
    ctx.fillText(text,pt0[0]+dx,pt0[1]+dy);
}


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/

## end
#1946, 562:
"""
+[返回目录](,画图)

输入:...
+[设置结构](,输入)

"""

pt0=中心
r=半径[0]
angle0=-起始角度[0]
Dangle=-数值[0]

dx=r*np.cos(np.deg2rad(angle0+Dangle)/2)
dy=r*np.sin(np.deg2rad(angle0+Dangle)/2)


qp.setPen(QPen(QColor(0,0,0)))
qp.setBrush(QBrush(QColor(255,255,255)))

qp.drawArc(pt0[0]-r,pt0[1]-r,2*r,2*r,angle0*16,Dangle*16)

qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",10))


if 标记=='%数值':
    qp.drawText(pt0[0]+dx,pt0[1]+dy,"%.2f"%(Dangle))
else:
    qp.drawText(pt0[0]+dx,pt0[1]+dy,str(标记))

qp.drawPoint(pt0[0]+dx,pt0[1]+dy)

qp.setFont(QFont())




## end
#1948, 13:
-239.0, -77.0
## end
#1950, 12:
-290.0, 22.0
## end
#1952, 12:
-288.0, 22.0
## end
#1954, 14:
-288.0, -105.0
## end
#1956, 19:
-27.255328374943076
## end
#1964, 62:
+[返回目录]
+[内容]
pt11::
pt12::
pt21::
pt22::
angle::
中心::
起始角度::

## end
#1972, 14:
+[返回目录]
+[内容]

## end
#1975, 940:
"""
+[返回目录](,P代码)

+[P函数](,P代码)

输出:...
+[设置结构](,输出)

"""

Dx1=pt11[0]-pt12[0]
Dy1=pt11[1]-pt12[1]

Dx2=pt21[0]-pt22[0]
Dy2=pt21[1]-pt22[1]

D1=pt11[0]*Dy1-pt11[1]*Dx1
D2=pt21[0]*Dy2-pt21[1]*Dx2

L=Dy1*Dx2-Dy2*Dx1
if L==0:
    pt0="None"
else:
    pt0=[(D1*Dx2-D2*Dx1)/L, (D1*Dy2-D2*Dy1)/L]
    if np.sqrt((pt0[0]-pt11[0])**2+(pt0[1]-pt11[1])**2) < np.sqrt((pt0[0]-pt12[0])**2+(pt0[1]-pt12[1])**2):
        Dx1=-Dx1
        Dy1=-Dy1
    
    if np.sqrt((pt0[0]-pt21[0])**2+(pt0[1]-pt21[1])**2) < np.sqrt((pt0[0]-pt22[0])**2+(pt0[1]-pt22[1])**2):
        Dx2=-Dx2
        Dy2=-Dy2

    sign=np.sign(Dx1*Dy2-Dx2*Dy1)
    Dtheta=np.arccos((Dx1*Dx2+Dy1*Dy2)/np.sqrt((Dx1**2+Dy1**2)*(Dx2**2+Dy2**2)))
    angle=np.rad2deg(Dtheta)*sign

    theta0=np.arccos(Dx1/np.sqrt(Dx1**2+Dy1**2))
    angle0=np.rad2deg(theta0)*np.sign(Dy1)

    print(Dy1/np.sqrt(Dx1**2+Dy1**2),theta0,angle0)

    中心=pt0
    起始角度=angle0


"""
+[P函数](,P代码)
+[设置结构](,输出)

"""
## end
#1976, 2:
角度
## end
#1996, 18:
-43.04431860247711
## end
#1997, 6:
[20.0]
## end
#1998, 26:
-288.0, 20.132075471698112
## end
#1999, 18:
-46.95568139752289
## end
#2000, 5:
beta2
## end
#2006, 121:
+[返回目录]
+[内容]
标记::%数值
中心::-338.8789230341691, -3.8202594274802757
半径::10
起始角度::136.10929165904932
数值::62.220685781962224

## end
#2008, 775:
/*
+[返回目录](,HTML)

+[新建阅读窗口](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var pt0=[%中心];
var r=%半径;
var Dangle=%数值;
var angle0=%起始角度;
var text="%标记";

dx=1.5*r*Math.cos((angle0+Dangle)/180*Math.PI/2);
dy=1.5*r*Math.sin((angle0+Dangle)/180*Math.PI/2);


ctx.beginPath();
if(Dangle>0) {
    ctx.arc(pt0[0],pt0[1],r,angle0/180*Math.PI,(angle0+Dangle)/180*Math.PI);
} else {
    ctx.arc(pt0[0],pt0[1],r,(angle0+Dangle)/180*Math.PI,angle0/180*Math.PI);
}

ctx.strokeStyle='rgba(0,0,0)';
ctx.stroke();

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center';
ctx.textBaseline='middle';
ctx.font=8*2+'px serif';

if (text[0]==='%') {
    ctx.fillText(`${-Dangle.toFixed(2)}`,pt0[0]+dx,pt0[1]+dy);
} else {
    ctx.fillText(text,pt0[0]+dx,pt0[1]+dy);
}


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/

## end
#2010, 562:
"""
+[返回目录](,画图)

输入:...
+[设置结构](,输入)

"""

pt0=中心
r=半径[0]
angle0=-起始角度[0]
Dangle=-数值[0]

dx=r*np.cos(np.deg2rad(angle0+Dangle)/2)
dy=r*np.sin(np.deg2rad(angle0+Dangle)/2)


qp.setPen(QPen(QColor(0,0,0)))
qp.setBrush(QBrush(QColor(255,255,255)))

qp.drawArc(pt0[0]-r,pt0[1]-r,2*r,2*r,angle0*16,Dangle*16)

qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",10))


if 标记=='%数值':
    qp.drawText(pt0[0]+dx,pt0[1]+dy,"%.2f"%(Dangle))
else:
    qp.drawText(pt0[0]+dx,pt0[1]+dy,str(标记))

qp.drawPoint(pt0[0]+dx,pt0[1]+dy)

qp.setFont(QFont())




## end
#2012, 13:
-184.0, -77.0
## end
#2014, 12:
-290.0, 22.0
## end
#2016, 12:
-288.0, 22.0
## end
#2018, 14:
-288.0, -105.0
## end
#2020, 18:
-46.95568139752289
## end
#2028, 62:
+[返回目录]
+[内容]
pt11::
pt12::
pt21::
pt22::
angle::
中心::
起始角度::

## end
#2036, 14:
+[返回目录]
+[内容]

## end
#2039, 940:
"""
+[返回目录](,P代码)

+[P函数](,P代码)

输出:...
+[设置结构](,输出)

"""

Dx1=pt11[0]-pt12[0]
Dy1=pt11[1]-pt12[1]

Dx2=pt21[0]-pt22[0]
Dy2=pt21[1]-pt22[1]

D1=pt11[0]*Dy1-pt11[1]*Dx1
D2=pt21[0]*Dy2-pt21[1]*Dx2

L=Dy1*Dx2-Dy2*Dx1
if L==0:
    pt0="None"
else:
    pt0=[(D1*Dx2-D2*Dx1)/L, (D1*Dy2-D2*Dy1)/L]
    if np.sqrt((pt0[0]-pt11[0])**2+(pt0[1]-pt11[1])**2) < np.sqrt((pt0[0]-pt12[0])**2+(pt0[1]-pt12[1])**2):
        Dx1=-Dx1
        Dy1=-Dy1
    
    if np.sqrt((pt0[0]-pt21[0])**2+(pt0[1]-pt21[1])**2) < np.sqrt((pt0[0]-pt22[0])**2+(pt0[1]-pt22[1])**2):
        Dx2=-Dx2
        Dy2=-Dy2

    sign=np.sign(Dx1*Dy2-Dx2*Dy1)
    Dtheta=np.arccos((Dx1*Dx2+Dy1*Dy2)/np.sqrt((Dx1**2+Dy1**2)*(Dx2**2+Dy2**2)))
    angle=np.rad2deg(Dtheta)*sign

    theta0=np.arccos(Dx1/np.sqrt(Dx1**2+Dy1**2))
    angle0=np.rad2deg(theta0)*np.sign(Dy1)

    print(Dy1/np.sqrt(Dx1**2+Dy1**2),theta0,angle0)

    中心=pt0
    起始角度=angle0


"""
+[P函数](,P代码)
+[设置结构](,输出)

"""
## end
#2040, 2:
角度
## end
#2042, 121:
+[返回目录](,长度)

起点::-243,22
终点::-243,-77
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1
文字::D
位移距离::100

画图:...
选中区域:...
HTML:...


## end
#2054, 1610:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

angle=30
l=20
D=位移距离[0]
d=10
text=文字


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush(QColor(edgeColor[0],edgeColor[1],edgeColor[2])))

r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
if r!=0:
    theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]

Dx=D*np.cos(np.deg2rad(theta-90))
Dy=-D*np.sin(np.deg2rad(theta-90))
pt10=[0,0]
pt20=[0,0]
pt10[0]=pt1[0]+Dx
pt10[1]=pt1[1]+Dy
pt20[0]=pt2[0]+Dx
pt20[1]=pt2[1]+Dy

path1=QPainterPath()
path1.moveTo(pt10[0],pt10[1])
path1.lineTo(pt10[0]+dp21[0],pt10[1]+dp21[1])
path1.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1])
path1.lineTo(pt10[0],pt10[1])

path2=QPainterPath()
path2.moveTo(pt20[0],pt20[1])
path2.lineTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])
path2.lineTo(pt20[0],pt20[1])

qp.drawPath(path1)
qp.drawPath(path2)
qp.drawLine(pt1[0],pt1[1],pt10[0],pt10[1])
qp.drawLine(pt2[0],pt2[1],pt20[0],pt20[1])


dx=d*np.cos(np.deg2rad(theta-90))
dy=-d*np.sin(np.deg2rad(theta-90))
pt0=[0,0]
pt0[0]=(pt10[0]+pt20[0])/2+dx
pt0[1]=(pt10[1]+pt20[1])/2+dy

L=300
H=100
qp.drawText(pt0[0]-L/2,pt0[1]-H/2,L,H,Qt.AlignHCenter|Qt.AlignVCenter,text)

qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])

qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#2060, 1610:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

angle=30
l=20
D=位移距离[0]
d=10
text=文字


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush(QColor(edgeColor[0],edgeColor[1],edgeColor[2])))

r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
if r!=0:
    theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]

Dx=D*np.cos(np.deg2rad(theta-90))
Dy=-D*np.sin(np.deg2rad(theta-90))
pt10=[0,0]
pt20=[0,0]
pt10[0]=pt1[0]+Dx
pt10[1]=pt1[1]+Dy
pt20[0]=pt2[0]+Dx
pt20[1]=pt2[1]+Dy

path1=QPainterPath()
path1.moveTo(pt10[0],pt10[1])
path1.lineTo(pt10[0]+dp21[0],pt10[1]+dp21[1])
path1.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1])
path1.lineTo(pt10[0],pt10[1])

path2=QPainterPath()
path2.moveTo(pt20[0],pt20[1])
path2.lineTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])
path2.lineTo(pt20[0],pt20[1])

qp.drawPath(path1)
qp.drawPath(path2)
qp.drawLine(pt1[0],pt1[1],pt10[0],pt10[1])
qp.drawLine(pt2[0],pt2[1],pt20[0],pt20[1])


dx=d*np.cos(np.deg2rad(theta-90))
dy=-d*np.sin(np.deg2rad(theta-90))
pt0=[0,0]
pt0[0]=(pt10[0]+pt20[0])/2+dx
pt0[1]=(pt10[1]+pt20[1])/2+dy

L=300
H=100
qp.drawText(pt0[0]-L/2,pt0[1]-H/2,L,H,Qt.AlignHCenter|Qt.AlignVCenter,text)

qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])

qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#2061, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#2062, 2:
直线
## end
#2063, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#2067, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#2070, 14:
+[返回目录]
+[内容]

## end
#2071, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#2073, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#2074, 1487:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var pt1=[%起点];
var pt2=[%终点];


//arrows
var angle=30/180*Math.PI;
var l=20;
var D=%位移距离;
var d=10;

r=Math.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2);
if (r!=0) {
    theta=Math.sign(pt1[1]-pt2[1])*Math.acos((pt2[0]-pt1[0])/r);
}

dp21=[l*Math.cos(theta-angle/2),-l*Math.sin(theta-angle/2)];
dp22=[l*Math.cos(theta+angle/2),-l*Math.sin(theta+angle/2)];

Dx=D*Math.cos(theta-90/180*Math.PI);
Dy=-D*Math.sin(theta-90/180*Math.PI);
pt10=[0,0];
pt20=[0,0];
pt10[0]=pt1[0]+Dx;
pt10[1]=pt1[1]+Dy;
pt20[0]=pt2[0]+Dx;
pt20[1]=pt2[1]+Dy;


ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();


ctx.moveTo(pt10[0],pt10[1]);
ctx.lineTo(pt10[0]+dp21[0],pt10[1]+dp21[1]);
ctx.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1]);
ctx.lineTo(pt10[0],pt10[1]);

ctx.moveTo(pt20[0],pt20[1]);
ctx.lineTo(pt20[0]-dp21[0],pt20[1]-dp21[1]);
ctx.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1]);
ctx.lineTo(pt20[0],pt20[1]);

ctx.moveTo(pt1[0],pt1[1]);
ctx.lineTo(pt10[0],pt10[1]);
ctx.moveTo(pt2[0],pt2[1]);
ctx.lineTo(pt20[0],pt20[1]);

ctx.moveTo(pt10[0],pt10[1]);
ctx.lineTo(pt20[0],pt20[1]);

ctx.stroke()
ctx.fill()


// text
dx=d*Math.cos(theta-90/180*Math.PI)
dy=-d*Math.sin(theta-90/180*Math.PI)
pt0=[0,0]
pt0[0]=(pt10[0]+pt20[0])/2+dx
pt0[1]=(pt10[1]+pt20[1])/2+dy


ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
L=300
H=100
ctx.fillText('%文字',pt0[0],pt0[1]);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#2076, 50:
线颜色::0,0,0
线型::DashLine
线粗细::2
文字::10 cm
位移距离::20

## end
#2084, 7:
-243,22
## end
#2085, 8:
-243,-77
## end
#2086, 5:
0,0,0
## end
#2087, 8:
DashLine
## end
#2088, 1:
1
## end
#2089, 1:
D
## end
#2090, 3:
100
## end
#2094, 465:
%{
+[返回目录](,计算宽度)

+[M函数](,计算宽度)
%}

physics_constant;
D=18e-2;
alpha=51;
N=1480;
d=1/N*1e-3;
lm1=740e-9;
lm2=850e-9;

n=-1;

beta1=asind(sind(alpha)+n*lm1/d);
beta2=asind(sind(alpha)+n*lm2/d);

%L1=D*(sind(alpha)+n*lm1/d)./sqrt(1-(sind(alpha)+n*lm1/d).^2);
%L2=D*(sind(alpha)+n*lm2/d)./sqrt(1-(sind(alpha)+n*lm2/d).^2);
L1=D*tand(beta1);
L2=D*tand(beta2);

DL=abs(L2-L1);

disp(sprintf('Width: %d cm',DL/1e-2))



%{
+[M函数](,计算宽度)

扫二维参数(M函数):...
+[M函数](,扫二维参数)
%}
## end
#2097, 456:
%{
+[返回目录](,扫二维参数)

+[M函数](,扫二维参数)
%}

physics_constant;
D=18e-2;
%alpha=51;
%N=1480;
lm1=740e-9;
lm2=850e-9;

alpha=linspace(40,60,100);
N_i=fix(linspace(800,1480,5));
[Alpha,N]=meshgrid(alpha,N_i);

n=-1;
d=1./N*1e-3;


beta1=asind(sind(Alpha)+n*lm1./d);
beta2=asind(sind(Alpha)+n*lm2./d);

L1=D*tand(beta1);
L2=D*tand(beta2);

DL=abs(L2-L1);

plot(Alpha',DL'/1e-2)
legend(num2str(N_i'))
xlabel('\theta [deg]')
ylabel('Width [cm]')


%{
+[M函数](,扫二维参数)
%}
## end
#2102, 461:
<!--
+[返回目录](,光栅对比)
+[H函数](,光栅对比)

参考(光栅对比,光栅宽度)->+[H函数](,光栅宽度)
参考(光栅对比,光栅色散)->+[H函数](,光栅色散)
-->
光栅对GDD的计算公式, 
$$
GDD(\lambda)=-\frac{\lambda^3 D}{\pi c^2 d^2}
\left[
1-\left(
\frac{\lambda}{d}-sin\theta
\right)^2
\right]^{-\frac{3}{2}}
$$
而宽度的计算公式, 
$$
\Delta L=L_2-L_1
\\
=\frac{D (sin\theta+n\lambda_2/d)}{\sqrt{1-(sin\theta+n\lambda_2/d)^2}}
-\frac{D (sin\theta+n\lambda_1/d)}{\sqrt{1-(sin\theta+n\lambda_1/d)^2}}
$$



<!--
+[H函数](,光栅对比)

初步感受(M函数):...
-->
## end
#2109, 802:
%{
+[返回目录](,初步感受)

+[M函数](,初步感受)
%}

physics_constant;

lm1=740e-9;
lm2=850e-9;
n=-1;

N0=1480;
theta0=51;
D0=18e-2;

N1=1200;
theta1=26.7;
D1=22.8e-2;

d0=1/N0*1e-3;
d1=1/N1*1e-3;

lm=linspace(lm1,lm2,100);
GDD0=-lm.^3*D0/pi/c^2/d0^2.*(1-(lm/d0-sind(theta0)).^2).^(-3/2);
GDD1=-lm.^3*D1/pi/c^2/d1^2.*(1-(lm/d1-sind(theta1)).^2).^(-3/2);

beta0=asind(sind(theta0)+n*lm/d0);
beta1=asind(sind(theta1)+n*lm/d1);
L0=D0*tand(beta0)
DL0=L0-L0(1);
L1=D1*tand(beta1)
DL1=L1-L1(1);

subplot(2,1,1)
plot(lm/1e-9,GDD0/1e-30,lm/1e-9,GDD1/1e-30)
xlabel('\lambda [nm]')
ylabel('GDD [fs^{-2}]')
legend(num2str(N0),num2str(N1))

subplot(2,1,2)
plot(lm/1e-9,DL0/1e-2,lm/1e-9,DL1/1e-2)
xlabel('\lambda [nm]')
ylabel('Width [cm]')
legend(num2str(N0),num2str(N1))
title('Width of the second grating')


%{
+[M函数](,初步感受)
%}
## end
#2111, 4:
2122
## end
#2114, 127:
+[返回目录](,光谱光栅)
光谱仪::file:///C:/Users/cheng/Desktop/paper/Spectrometer/Spectrometer.pdf#page=25
+[打开网页](,光谱仪)

光谱宽度(html):...



## end
#2116, 74:
file:///C:/Users/cheng/Desktop/paper/Spectrometer/Spectrometer.pdf#page=25
## end
#2117, 4:
2867
## end
#2120, 108:
+[返回目录](,闪耀光栅)
参考材料::https://www.shimadzu.com/opt/guide/diffraction/07.html
+[打开网页](,参考材料)

定义(html):...




## end
#2122, 54:
https://www.shimadzu.com/opt/guide/diffraction/07.html
## end
#2124, 652:
<!--
+[返回目录](,定义)

场景(画板):...
+[画板](+新画板,场景)
场景->画板(场景,)->+[del](,画板)
+画板(场景,)

+[H函数](,定义)
-->

%场景<br>
<img src="https://www.shimadzu.com/sites/shimadzu.com/files/opt/guide/diffraction/k25cur0000003vsg-img/oh80jt0000001uzf.gif"></img>
<br>
The surface of the blaze grating is showed in the above image. The blaze angle is \(\theta_B\), which also shows in the image. <br>
If we know the incident light, \(\alpha\), and the blaze wavelength, \(\lambda_B\), then the blaze angle will be calculated as the following,
$$
sin(\beta)=sin(\alpha)-\frac{n\lambda_B}{d}
$$
$$
\theta_B=\frac{\alpha-\beta}{2}
$$



<!--
+[H函数](,定义)

计算(M函数):...
+[M函数](,计算)
-->
## end
#2127, 229:
+[返回目录](,场景)

基底:...
长边:...
短边:...
法线:...

入射光:...
出射光:...
a:...
b:...
c:...
+[创建直线](,出射光)
+[创建垂线](,法线)

水平线:...
+[创建直线](,水平线)


+法线(长边,)->+[创建垂线](,+法线)
+a(入射光,法线)->+[创建角度](,+a)
+b(出射光,法线)->+[创建角度](,+b)
+c(长边,水平线)->+[创建角度](,+c)


## end
#2129, 149:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10

面颜色::255,255,255
线颜色::0,0,0
线型::SolidLine
线粗细::2

画图:...
选中区域:...
HTML:...



## end
#2142, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#2148, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#2149, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#2150, 2:
矩形
## end
#2151, 231:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


## end
#2154, 14:
+[返回目录]
+[内容]

## end
#2155, 754:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细
        if('%线型'==='DashLine') {
            ctx.setLineDash([5,5])
        };
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

ctx.setLineDash([])

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#2158, 14:
+[返回目录]
+[内容]

## end
#2159, 101:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100

## end
#2168, 11:
255,255,255
## end
#2169, 4:
None
## end
#2170, 9:
SolidLine
## end
#2171, 1:
2
## end
#2172, 1:
 
## end
#2173, 2:
10
## end
#2174, 12:
-269.0, 3.25
## end
#2175, 11:
352.0, 81.5
## end
#2177, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#2179, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#2181, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#2183, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#2193, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#2199, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#2200, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#2201, 2:
直线
## end
#2202, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#2206, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#2209, 14:
+[返回目录]
+[内容]

## end
#2210, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#2212, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#2213, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#2215, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#2221, 11:
-152.0, 2.0
## end
#2222, 12:
-76.0, -40.0
## end
#2223, 5:
0,0,0
## end
#2224, 1:
1
## end
#2225, 9:
SolidLine
## end
#2235, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#2241, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#2242, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#2243, 2:
直线
## end
#2244, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#2248, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#2251, 14:
+[返回目录]
+[内容]

## end
#2252, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#2254, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#2255, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#2257, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#2263, 10:
-51.0, 0.5
## end
#2264, 12:
-75.0, -40.5
## end
#2265, 5:
0,0,0
## end
#2266, 1:
1
## end
#2267, 9:
SolidLine
## end
#2268, 9:
SolidLine
## end
#2269, 1:
1
## end
#2270, 5:
0,0,0
## end
#2271, 11:
28.0, -42.0
## end
#2272, 10:
-48.0, 0.0
## end
#2278, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#2280, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#2281, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#2283, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#2284, 14:
+[返回目录]
+[内容]

## end
#2287, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#2291, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#2292, 2:
直线
## end
#2293, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#2294, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#2300, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#2310, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#2312, 9:
SolidLine
## end
#2313, 1:
1
## end
#2314, 5:
0,0,0
## end
#2315, 13:
-179.0, -37.5
## end
#2316, 11:
-155.0, 3.5
## end
#2322, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#2324, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#2325, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#2327, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#2328, 14:
+[返回目录]
+[内容]

## end
#2331, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#2335, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#2336, 2:
直线
## end
#2337, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#2338, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#2344, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#2354, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#2356, 11:
-256.0, 4.0
## end
#2357, 13:
-180.0, -38.0
## end
#2358, 5:
0,0,0
## end
#2359, 9:
SolidLine
## end
#2360, 1:
1
## end
#2366, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#2368, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#2369, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#2374, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#2375, 2:
直线
## end
#2378, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#2379, 14:
+[返回目录]
+[内容]

## end
#2380, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#2382, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#2386, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#2388, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#2398, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#2400, 9:
SolidLine
## end
#2401, 1:
1
## end
#2402, 5:
0,0,0
## end
#2403, 11:
31.0, -41.5
## end
#2404, 10:
55.0, -0.5
## end
#2410, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#2412, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#2413, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#2415, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#2416, 14:
+[返回目录]
+[内容]

## end
#2419, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#2423, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#2424, 2:
直线
## end
#2425, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#2426, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#2432, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#2442, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#2445, 128:
+[返回目录](,垂线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...

P代码:...
+[P函数](,P代码)


## end
#2462, 12:
-76.0, -40.0
## end
#2463, 11:
-152.0, 2.0
## end
#2464, 40:
-182.09394661416206, -140.88428434943603
## end
#2468, 35:
+[返回目录]
+[内容]
pt02::
pt11::
pt12::

## end
#2470, 39:
-114.56445623342177, -18.68806366047744
## end
#2472, 21:
+[返回目录]
+[内容]
pt01::

## end
#2475, 363:
"""
+[返回目录](,P代码)
+[P函数](,P代码)

输入:...
输出:...
+[设置结构](,输入)

"""


Dx1=pt12[0]-pt11[0]
Dy1=pt12[1]-pt11[1]

Dxr=pt12[0]-pt02[0]
Dyr=pt12[1]-pt02[1]

sign=np.sign(Dy1)
theta1=np.arccos(Dx1/np.sqrt(Dx1**2+Dy1**2))
angle1=-np.rad2deg(theta1)*sign

theta=np.deg2rad(angle1+90)

dx=np.cos(theta)
dy=-np.sin(theta)
DL=Dxr*dx+Dyr*dy

pt01=[pt02[0]+DL*dx,pt02[1]+DL*dy]



## end
#2476, 11:
-152.0, 2.0
## end
#2477, 5:
[1.0]
## end
#2478, 8:
DashLine
## end
#2479, 15:
[0.0, 0.0, 0.0]
## end
#2481, 40:
-182.09394661416206, -140.88428434943603
## end
#2482, 39:
-114.56445623342177, -18.68806366047744
## end
#2489, 65:
线颜色::0,0,0
线型::DashLine
线粗细::2
pt11::

pt11->是(_,pt11)->+[显示](,_)
## end
#2491, 274:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/

## end
#2492, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#2494, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#2495, 14:
+[返回目录]
+[内容]

## end
#2498, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#2502, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#2503, 2:
直线
## end
#2504, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#2505, 1097:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

d=10

lineWidth=线粗细[0]
lineType=线型

Dx=pt2[0]-pt1[0]
Dy=pt2[1]-pt1[1]

Dx1=pt11[0]-pt1[0]
Dy1=pt11[1]-pt1[1]

sign=np.sign(Dy)
theta1=-sign*np.arccos(Dx/np.sqrt(Dx**2+Dy**2))
angle1=np.rad2deg(theta1)
theta2=np.deg2rad(angle1+90)

dp1=[d*np.cos(theta1),-d*np.sin(theta1)]
dp2=[d*np.cos(theta2),-d*np.sin(theta2)]

sign2=np.sign(Dx1*dp2[0]+Dy1*dp2[1])
dp2=[sign2*dp2[0],sign2*dp2[1]]


pt01=[pt1[0]+dp1[0],pt1[1]+dp1[1]]
pt02=[pt01[0]+dp2[0],pt01[1]+dp2[1]]
pt03=[pt02[0]-dp1[0],pt02[1]-dp1[1]]

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
qp.drawLine(pt01[0],pt01[1],pt02[0],pt02[1])
qp.drawLine(pt02[0],pt02[1],pt03[0],pt03[1])


qp.setPen(QPen())




## end
#2511, 1097:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

d=10

lineWidth=线粗细[0]
lineType=线型

Dx=pt2[0]-pt1[0]
Dy=pt2[1]-pt1[1]

Dx1=pt11[0]-pt1[0]
Dy1=pt11[1]-pt1[1]

sign=np.sign(Dy)
theta1=-sign*np.arccos(Dx/np.sqrt(Dx**2+Dy**2))
angle1=np.rad2deg(theta1)
theta2=np.deg2rad(angle1+90)

dp1=[d*np.cos(theta1),-d*np.sin(theta1)]
dp2=[d*np.cos(theta2),-d*np.sin(theta2)]

sign2=np.sign(Dx1*dp2[0]+Dy1*dp2[1])
dp2=[sign2*dp2[0],sign2*dp2[1]]


pt01=[pt1[0]+dp1[0],pt1[1]+dp1[1]]
pt02=[pt01[0]+dp2[0],pt01[1]+dp2[1]]
pt03=[pt02[0]-dp1[0],pt02[1]-dp1[1]]

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
qp.drawLine(pt01[0],pt01[1],pt02[0],pt02[1])
qp.drawLine(pt02[0],pt02[1],pt03[0],pt03[1])


qp.setPen(QPen())




## end
#2525, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#2531, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#2532, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#2533, 2:
直线
## end
#2534, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#2538, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#2541, 14:
+[返回目录]
+[内容]

## end
#2542, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#2544, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#2545, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#2547, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#2553, 13:
-115.0, -17.0
## end
#2554, 14:
-292.0, -149.0
## end
#2555, 5:
0,0,0
## end
#2556, 1:
1
## end
#2557, 9:
SolidLine
## end
#2567, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#2573, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#2574, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#2575, 2:
直线
## end
#2576, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#2580, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#2583, 14:
+[返回目录]
+[内容]

## end
#2584, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#2586, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#2587, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#2589, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#2595, 14:
-107.0, -196.0
## end
#2596, 13:
-115.0, -19.0
## end
#2597, 5:
0,0,0
## end
#2598, 1:
1
## end
#2599, 9:
SolidLine
## end
#2601, 109:
+[返回目录](,角度)

数值::
中心::
半径::20
起始角度::
类型::角度

标记::a

画图:...
HTML:...
P代码:...
+[P函数](,P代码)



+[创建输入](标记,画图)


## end
#2621, 19:
-143.28579702395376
## end
#2622, 6:
[20.0]
## end
#2623, 39:
-112.67223065250384, -15.26403641881641
## end
#2624, 18:
24.359371188700134
## end
#2625, 1:
a
## end
#2631, 121:
+[返回目录]
+[内容]
标记::%数值
中心::-338.8789230341691, -3.8202594274802757
半径::10
起始角度::136.10929165904932
数值::62.220685781962224

## end
#2633, 775:
/*
+[返回目录](,HTML)

+[新建阅读窗口](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var pt0=[%中心];
var r=%半径;
var Dangle=%数值;
var angle0=%起始角度;
var text="%标记";

dx=1.5*r*Math.cos((angle0+Dangle)/180*Math.PI/2);
dy=1.5*r*Math.sin((angle0+Dangle)/180*Math.PI/2);


ctx.beginPath();
if(Dangle>0) {
    ctx.arc(pt0[0],pt0[1],r,angle0/180*Math.PI,(angle0+Dangle)/180*Math.PI);
} else {
    ctx.arc(pt0[0],pt0[1],r,(angle0+Dangle)/180*Math.PI,angle0/180*Math.PI);
}

ctx.strokeStyle='rgba(0,0,0)';
ctx.stroke();

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center';
ctx.textBaseline='middle';
ctx.font=8*2+'px serif';

if (text[0]==='%') {
    ctx.fillText(`${-Dangle.toFixed(2)}`,pt0[0]+dx,pt0[1]+dy);
} else {
    ctx.fillText(text,pt0[0]+dx,pt0[1]+dy);
}


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/

## end
#2635, 562:
"""
+[返回目录](,画图)

输入:...
+[设置结构](,输入)

"""

pt0=中心
r=半径[0]
angle0=-起始角度[0]
Dangle=-数值[0]

dx=r*np.cos(np.deg2rad(angle0+Dangle)/2)
dy=r*np.sin(np.deg2rad(angle0+Dangle)/2)


qp.setPen(QPen(QColor(0,0,0)))
qp.setBrush(QBrush(QColor(255,255,255)))

qp.drawArc(pt0[0]-r,pt0[1]-r,2*r,2*r,angle0*16,Dangle*16)

qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",10))


if 标记=='%数值':
    qp.drawText(pt0[0]+dx,pt0[1]+dy,"%.2f"%(Dangle))
else:
    qp.drawText(pt0[0]+dx,pt0[1]+dy,str(标记))

qp.drawPoint(pt0[0]+dx,pt0[1]+dy)

qp.setFont(QFont())




## end
#2637, 13:
-115.0, -17.0
## end
#2639, 14:
-292.0, -149.0
## end
#2641, 39:
-114.56445623342177, -18.68806366047744
## end
#2643, 40:
-182.09394661416206, -140.88428434943603
## end
#2645, 18:
24.359371188700134
## end
#2653, 62:
+[返回目录]
+[内容]
pt11::
pt12::
pt21::
pt22::
angle::
中心::
起始角度::

## end
#2661, 14:
+[返回目录]
+[内容]

## end
#2664, 940:
"""
+[返回目录](,P代码)

+[P函数](,P代码)

输出:...
+[设置结构](,输出)

"""

Dx1=pt11[0]-pt12[0]
Dy1=pt11[1]-pt12[1]

Dx2=pt21[0]-pt22[0]
Dy2=pt21[1]-pt22[1]

D1=pt11[0]*Dy1-pt11[1]*Dx1
D2=pt21[0]*Dy2-pt21[1]*Dx2

L=Dy1*Dx2-Dy2*Dx1
if L==0:
    pt0="None"
else:
    pt0=[(D1*Dx2-D2*Dx1)/L, (D1*Dy2-D2*Dy1)/L]
    if np.sqrt((pt0[0]-pt11[0])**2+(pt0[1]-pt11[1])**2) < np.sqrt((pt0[0]-pt12[0])**2+(pt0[1]-pt12[1])**2):
        Dx1=-Dx1
        Dy1=-Dy1
    
    if np.sqrt((pt0[0]-pt21[0])**2+(pt0[1]-pt21[1])**2) < np.sqrt((pt0[0]-pt22[0])**2+(pt0[1]-pt22[1])**2):
        Dx2=-Dx2
        Dy2=-Dy2

    sign=np.sign(Dx1*Dy2-Dx2*Dy1)
    Dtheta=np.arccos((Dx1*Dx2+Dy1*Dy2)/np.sqrt((Dx1**2+Dy1**2)*(Dx2**2+Dy2**2)))
    angle=np.rad2deg(Dtheta)*sign

    theta0=np.arccos(Dx1/np.sqrt(Dx1**2+Dy1**2))
    angle0=np.rad2deg(theta0)*np.sign(Dy1)

    print(Dy1/np.sqrt(Dx1**2+Dy1**2),theta0,angle0)

    中心=pt0
    起始角度=angle0


"""
+[P函数](,P代码)
+[设置结构](,输出)

"""
## end
#2665, 2:
角度
## end
#2666, 18:
0.9317522064242411
## end
#2668, 8:
587, 237
## end
#2670, 13:
-100.0, -50.0
## end
#2674, 109:
+[返回目录](,角度)

数值::
中心::
半径::20
起始角度::
类型::角度

标记::b

画图:...
HTML:...
P代码:...
+[P函数](,P代码)



+[创建输入](标记,画图)


## end
#2694, 17:
-87.4121214925947
## end
#2695, 6:
[20.0]
## end
#2696, 40:
-114.98010445162895, -19.440189007709478
## end
#2697, 19:
-31.514304342658924
## end
#2698, 1:
b
## end
#2704, 121:
+[返回目录]
+[内容]
标记::%数值
中心::-338.8789230341691, -3.8202594274802757
半径::10
起始角度::136.10929165904932
数值::62.220685781962224

## end
#2706, 775:
/*
+[返回目录](,HTML)

+[新建阅读窗口](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var pt0=[%中心];
var r=%半径;
var Dangle=%数值;
var angle0=%起始角度;
var text="%标记";

dx=1.5*r*Math.cos((angle0+Dangle)/180*Math.PI/2);
dy=1.5*r*Math.sin((angle0+Dangle)/180*Math.PI/2);


ctx.beginPath();
if(Dangle>0) {
    ctx.arc(pt0[0],pt0[1],r,angle0/180*Math.PI,(angle0+Dangle)/180*Math.PI);
} else {
    ctx.arc(pt0[0],pt0[1],r,(angle0+Dangle)/180*Math.PI,angle0/180*Math.PI);
}

ctx.strokeStyle='rgba(0,0,0)';
ctx.stroke();

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center';
ctx.textBaseline='middle';
ctx.font=8*2+'px serif';

if (text[0]==='%') {
    ctx.fillText(`${-Dangle.toFixed(2)}`,pt0[0]+dx,pt0[1]+dy);
} else {
    ctx.fillText(text,pt0[0]+dx,pt0[1]+dy);
}


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/

## end
#2708, 562:
"""
+[返回目录](,画图)

输入:...
+[设置结构](,输入)

"""

pt0=中心
r=半径[0]
angle0=-起始角度[0]
Dangle=-数值[0]

dx=r*np.cos(np.deg2rad(angle0+Dangle)/2)
dy=r*np.sin(np.deg2rad(angle0+Dangle)/2)


qp.setPen(QPen(QColor(0,0,0)))
qp.setBrush(QBrush(QColor(255,255,255)))

qp.drawArc(pt0[0]-r,pt0[1]-r,2*r,2*r,angle0*16,Dangle*16)

qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",10))


if 标记=='%数值':
    qp.drawText(pt0[0]+dx,pt0[1]+dy,"%.2f"%(Dangle))
else:
    qp.drawText(pt0[0]+dx,pt0[1]+dy,str(标记))

qp.drawPoint(pt0[0]+dx,pt0[1]+dy)

qp.setFont(QFont())




## end
#2710, 14:
-107.0, -196.0
## end
#2712, 13:
-115.0, -19.0
## end
#2714, 39:
-114.56445623342177, -18.68806366047744
## end
#2716, 40:
-182.09394661416206, -140.88428434943603
## end
#2718, 19:
-31.514304342658924
## end
#2726, 62:
+[返回目录]
+[内容]
pt11::
pt12::
pt21::
pt22::
angle::
中心::
起始角度::

## end
#2734, 14:
+[返回目录]
+[内容]

## end
#2737, 940:
"""
+[返回目录](,P代码)

+[P函数](,P代码)

输出:...
+[设置结构](,输出)

"""

Dx1=pt11[0]-pt12[0]
Dy1=pt11[1]-pt12[1]

Dx2=pt21[0]-pt22[0]
Dy2=pt21[1]-pt22[1]

D1=pt11[0]*Dy1-pt11[1]*Dx1
D2=pt21[0]*Dy2-pt21[1]*Dx2

L=Dy1*Dx2-Dy2*Dx1
if L==0:
    pt0="None"
else:
    pt0=[(D1*Dx2-D2*Dx1)/L, (D1*Dy2-D2*Dy1)/L]
    if np.sqrt((pt0[0]-pt11[0])**2+(pt0[1]-pt11[1])**2) < np.sqrt((pt0[0]-pt12[0])**2+(pt0[1]-pt12[1])**2):
        Dx1=-Dx1
        Dy1=-Dy1
    
    if np.sqrt((pt0[0]-pt21[0])**2+(pt0[1]-pt21[1])**2) < np.sqrt((pt0[0]-pt22[0])**2+(pt0[1]-pt22[1])**2):
        Dx2=-Dx2
        Dy2=-Dy2

    sign=np.sign(Dx1*Dy2-Dx2*Dy1)
    Dtheta=np.arccos((Dx1*Dx2+Dy1*Dy2)/np.sqrt((Dx1**2+Dy1**2)*(Dx2**2+Dy2**2)))
    angle=np.rad2deg(Dtheta)*sign

    theta0=np.arccos(Dx1/np.sqrt(Dx1**2+Dy1**2))
    angle0=np.rad2deg(theta0)*np.sign(Dy1)

    print(Dy1/np.sqrt(Dx1**2+Dy1**2),theta0,angle0)

    中心=pt0
    起始角度=angle0


"""
+[P函数](,P代码)
+[设置结构](,输出)

"""
## end
#2738, 2:
角度
## end
#2740, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#2750, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#2756, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#2757, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#2758, 2:
直线
## end
#2759, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#2763, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#2766, 14:
+[返回目录]
+[内容]

## end
#2767, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#2769, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#2770, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#2772, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#2778, 38:
-101.61874073177742, 4.527129173148857
## end
#2779, 38:
-153.66736403341952, 4.527129173148857
## end
#2780, 5:
0,0,0
## end
#2781, 1:
1
## end
#2782, 8:
DashLine
## end
#2784, 113:
+[返回目录](,角度)

数值::
中心::
半径::20
起始角度::
类型::角度

标记::theta

画图:...
HTML:...
P代码:...
+[P函数](,P代码)



+[创建输入](标记,画图)


## end
#2804, 18:
-28.92642583525362
## end
#2805, 6:
[20.0]
## end
#2806, 38:
-156.57290040855506, 4.527129173148857
## end
#2807, 18:
28.926425835253607
## end
#2808, 5:
theta
## end
#2814, 121:
+[返回目录]
+[内容]
标记::%数值
中心::-338.8789230341691, -3.8202594274802757
半径::10
起始角度::136.10929165904932
数值::62.220685781962224

## end
#2816, 775:
/*
+[返回目录](,HTML)

+[新建阅读窗口](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var pt0=[%中心];
var r=%半径;
var Dangle=%数值;
var angle0=%起始角度;
var text="%标记";

dx=1.5*r*Math.cos((angle0+Dangle)/180*Math.PI/2);
dy=1.5*r*Math.sin((angle0+Dangle)/180*Math.PI/2);


ctx.beginPath();
if(Dangle>0) {
    ctx.arc(pt0[0],pt0[1],r,angle0/180*Math.PI,(angle0+Dangle)/180*Math.PI);
} else {
    ctx.arc(pt0[0],pt0[1],r,(angle0+Dangle)/180*Math.PI,angle0/180*Math.PI);
}

ctx.strokeStyle='rgba(0,0,0)';
ctx.stroke();

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center';
ctx.textBaseline='middle';
ctx.font=8*2+'px serif';

if (text[0]==='%') {
    ctx.fillText(`${-Dangle.toFixed(2)}`,pt0[0]+dx,pt0[1]+dy);
} else {
    ctx.fillText(text,pt0[0]+dx,pt0[1]+dy);
}


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/

## end
#2818, 562:
"""
+[返回目录](,画图)

输入:...
+[设置结构](,输入)

"""

pt0=中心
r=半径[0]
angle0=-起始角度[0]
Dangle=-数值[0]

dx=r*np.cos(np.deg2rad(angle0+Dangle)/2)
dy=r*np.sin(np.deg2rad(angle0+Dangle)/2)


qp.setPen(QPen(QColor(0,0,0)))
qp.setBrush(QBrush(QColor(255,255,255)))

qp.drawArc(pt0[0]-r,pt0[1]-r,2*r,2*r,angle0*16,Dangle*16)

qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",10))


if 标记=='%数值':
    qp.drawText(pt0[0]+dx,pt0[1]+dy,"%.2f"%(Dangle))
else:
    qp.drawText(pt0[0]+dx,pt0[1]+dy,str(标记))

qp.drawPoint(pt0[0]+dx,pt0[1]+dy)

qp.setFont(QFont())




## end
#2820, 11:
-152.0, 2.0
## end
#2822, 12:
-76.0, -40.0
## end
#2824, 38:
-101.61874073177742, 4.527129173148857
## end
#2826, 38:
-153.66736403341952, 4.527129173148857
## end
#2828, 18:
28.926425835253607
## end
#2836, 62:
+[返回目录]
+[内容]
pt11::
pt12::
pt21::
pt22::
angle::
中心::
起始角度::

## end
#2844, 14:
+[返回目录]
+[内容]

## end
#2847, 940:
"""
+[返回目录](,P代码)

+[P函数](,P代码)

输出:...
+[设置结构](,输出)

"""

Dx1=pt11[0]-pt12[0]
Dy1=pt11[1]-pt12[1]

Dx2=pt21[0]-pt22[0]
Dy2=pt21[1]-pt22[1]

D1=pt11[0]*Dy1-pt11[1]*Dx1
D2=pt21[0]*Dy2-pt21[1]*Dx2

L=Dy1*Dx2-Dy2*Dx1
if L==0:
    pt0="None"
else:
    pt0=[(D1*Dx2-D2*Dx1)/L, (D1*Dy2-D2*Dy1)/L]
    if np.sqrt((pt0[0]-pt11[0])**2+(pt0[1]-pt11[1])**2) < np.sqrt((pt0[0]-pt12[0])**2+(pt0[1]-pt12[1])**2):
        Dx1=-Dx1
        Dy1=-Dy1
    
    if np.sqrt((pt0[0]-pt21[0])**2+(pt0[1]-pt21[1])**2) < np.sqrt((pt0[0]-pt22[0])**2+(pt0[1]-pt22[1])**2):
        Dx2=-Dx2
        Dy2=-Dy2

    sign=np.sign(Dx1*Dy2-Dx2*Dy1)
    Dtheta=np.arccos((Dx1*Dx2+Dy1*Dy2)/np.sqrt((Dx1**2+Dy1**2)*(Dx2**2+Dy2**2)))
    angle=np.rad2deg(Dtheta)*sign

    theta0=np.arccos(Dx1/np.sqrt(Dx1**2+Dy1**2))
    angle0=np.rad2deg(theta0)*np.sign(Dy1)

    print(Dy1/np.sqrt(Dx1**2+Dy1**2),theta0,angle0)

    中心=pt0
    起始角度=angle0


"""
+[P函数](,P代码)
+[设置结构](,输出)

"""
## end
#2848, 2:
角度
## end
#2850, 159:
%{
+[返回目录](,计算)

+[M函数](,计算)
%}

physics_constant;
N=1200;
alpha=26.2;
lm_B=800e-9;
n=1;

d=1/N*1e-3;

beta=asind(sind(alpha)-n*lm_B/d)
theta_B=(alpha-beta)/2

## end
#2855, 1047:
<!--
+[返回目录](,光谱宽度)

+[H函数](,光谱宽度)
-->

光栅出射角\(\beta\)的计算公式为, 
$$
sin(\beta)=sin(\alpha) - \frac{n\lambda}{d}
$$
所以, 当我们固定入射角时, 我们有, 
$$
\Delta sin\beta= -\frac{n\Delta\lambda}{d}
$$$$
cos\beta d\beta=-\frac{nd\lambda}{d}
\Rightarrow
\frac{d\lambda}{d\beta}= -\frac{cos\beta d}{n}
$$
也就是说, 波长的角分辨率只取决于出射角度. 
<br>
接着可以讨论出射光线和入射光线的夹角, 
$$
sin\alpha - sin\beta=\frac{n\lambda}{d}
\Rightarrow
cos\left(\frac{\alpha+\beta}{2}\right)
sin\left(\frac{\alpha-\beta}{2}\right)
=\frac{n\lambda}{d}

\\\Rightarrow
cos(\Delta/2)=\frac{\lambda n}{sin(\theta) d}
$$
用
<a href="file:///C:/Users/cheng/Desktop/paper/Spectrometer/Spectrometer.pdf#page=25">
手册
</a>
中的参数, 尝试估计入射角度.<br>
焦距: \(f=0.32 m\)<br>
空间色散率: \(R=2.64 nm/mm\)<br>
中心波长: \(\lambda_0=546.074 nm\)<br>
透镜中心到像平面的距离为\(f\), 则有, 
$$
\frac{d\lambda}{d\beta}=R\cdot f=-\frac{cos(\beta) d}{n},
\\
cos\beta=-\frac{n f R}{d}
,
\beta=arccos\left(-\frac{n f R}{d}\right)
$$


<!--
+[H函数](,光谱宽度)

计算入射角(M函数):...
+[M函数](,计算入射角)
手册::file:///C:/Users/cheng/Desktop/paper/Spectrometer/Spectrometer.pdf#page=25
-->

## end
#2858, 74:
file:///C:/Users/cheng/Desktop/paper/Spectrometer/Spectrometer.pdf#page=25
## end
#2860, 137:
%{
+[返回目录](,计算入射角)

+[M函数](,计算入射角)
%}

f=0.32/1e-3;
R=2.64e-9;
N=1200;
n=-1;

d=1e-3/N
f*R

beta=acosd(-(f*R*n)/d)


%{
+[M函数](,计算入射角)
%}
## end
#2862, 4:
2866
## end
#2864, 4:
2868
## end
#2866, 4:
2870
## end
#2869, 16:
文档\S应用\网页画板.ftxt
## end
#2870, 4:
2877
## end
#2873, 867:
%{
+[返回目录](,计算光强)

+[M函数](,估计compressor)
%}

physics_constant;
%theta=90-42.72;
%theta=30;
theta0=90-42.72;
Dtheta=10;
theta=linspace(theta0-Dtheta/2,theta0+Dtheta/2,100);

lm=790e-9;
D0=0.67;
dD=0.05;
%D=linspace(D0-dD*1.5,D0+dD/2,100);
D=D0;
N=1480;
dtau=45e-15;

Energy=30e-3;
eff=[0.80,0.95,0.95]';
w0=[0.4e-3,3e-3,20e-3]';

E=[Energy*eff(1)*(1-eff(2))*(1-eff(3));
Energy*eff(2)*(1-eff(3));
Energy*eff(3)
];

d=1e-3/N;
%GDD_grating0=-lm.^3*D0/pi/c^2/d^2.*(1-(lm/d-sind(theta)).^2).^(-3/2);
GDD_grating0=0;
GDD_grating=-lm.^3*D/pi/c^2/d^2.*(1-(lm/d-sind(theta)).^2).^(-3/2);



dGDD=GDD_grating-GDD_grating0;
GDD=GDD_grating-GDD_grating0;
dt=sqrt((GDD*2/dtau).^2+dtau^2);


I0=2*E/sqrt(pi)/pi./w0.^2./dt;

clf
%plot(D/1e-3,dt/1e-12);
plot(theta,dt/1e-12);
%xlabel('Grating pair distance [mm]')
xlabel('Incoming angle [deg]')
ylabel('Pulse duration [ps]')


%{
 
%}
## end
#2875, 4:
2877
## end
#2877, 4:
2879
## end
#2880, 715:
%{
+[M函数](,验证计算)

Reflection_grating(M函数):...
例1:...
%}


physics_constant;
addpath('Matlab\optics')

N=1200;
lm_B=800e-9;
n=-1;

G1_pt=[0,0];
G1_angle=135;
pt0=[0,1];
angle0=-100;

[x1,y1,angle_out]=Reflection_grating(pt0,angle0,G1_pt,G1_angle,N,lm_B,n);

Dr0=[cosd(G1_angle),sind(G1_angle)];
Dr01=[cosd(G1_angle+90),sind(G1_angle+90)];
Dr1=[cosd(angle0),sind(angle0)];
Dr2=[cosd(angle_out),sind(angle_out)];

clf
hold on
plot([pt0(1),x1],[pt0(2),y1],'*-')
plot([x1,x1+Dr2(1)],[y1,y1+Dr2(2)])
plot([G1_pt(1)-Dr01(1),G1_pt(1)+Dr01(1)],[G1_pt(2)-Dr01(2),G1_pt(2)+Dr01(2)],'k')
plot([x1,x1+Dr0(1)],[y1,y1+Dr0(2)],'k--')
%rectangle('Position',[-1,-0.1,2,0.1])
axis equal
axis([-2,2,-0.5,1])


%{
clear
+[M函数](,验证计算)
%}
## end
#2882, 4:
2900
## end
#2885, 500:
%{
地址::Matlab\optics\Reflection_grating.m
+[保存M函数](,Reflection_grating)

测试:...
%}

function [x1,y1,angle_out]=Reflection_grating(pt0,angle0,G1_pt,G1_angle,N,lm_B,n)
physics_constant;
addpath('Matlab\space')

%N=1200;
%lm_B=800e-9;
%n=1;

%G1_pt=[0,0];
%G1_angle=45;
%pt0=[0,1];
%angle0=-100;

[x1,y1]=intersection_lines_dir_pt(G1_pt,(G1_angle+90)/180*pi,pt0,angle0/180*pi);

alpha=angle0+180-G1_angle;
d=1/N*1e-3;
beta=asind(sind(alpha)-n*lm_B/d);
angle_out=G1_angle-beta;


end

%{
+[M函数](,验证计算)
%}
## end
#2888, 354:
%{
+[M函数](,例1)
beta
Reflection_grating(M函数):...
%}

clf
physics_constant;
N=1200;
alpha=45;
lm_B=800e-9;
n=1;

d=1/N*1e-3;
beta=asind(sind(alpha)-n*lm_B/d);

Dr1=[-sind(alpha),cosd(alpha)];
Dr2=[sind(beta),cosd(beta)];

plot([Dr1(1),0,Dr2(1)],[Dr1(2),0,Dr2(2)],[0,Dr2(1)],[0,Dr2(2)])
rectangle('Position',[-1,-0.1,2,0.1])
axis equal


%{
+[M函数](,验证计算)
%}
## end
#2890, 788:
%{
+[M函数](,验证计算)

Reflection_grating(M函数):...
例1:...
%}


physics_constant;
N=1200;
lm_B=800e-9;
n=1;

G1_pt=[0,0];
G1_angle=45;
pt0=[0,1];
angle0=-100;

[x1,y1]=intersection_lines_dir_pt(G1_pt,(G1_angle+90)/180*pi,pt0,angle0/180*pi);

alpha=angle0+180-G1_angle;
d=1/N*1e-3;
beta=asind(sind(alpha)-n*lm_B/d);
angle_out=G1_angle-beta;


Dr0=[cosd(G1_angle),sind(G1_angle)];
Dr01=[cosd(G1_angle+90),sind(G1_angle+90)];
Dr1=[cosd(angle0),sind(angle0)];
Dr2=[cosd(angle_out),sind(angle_out)];

clf
hold on
plot([pt0(1),x1],[pt0(2),y1],'*-')
plot([x1,x1+Dr2(1)],[y1,y1+Dr2(2)])
plot([G1_pt(1)-Dr01(1),G1_pt(1)+Dr01(1)],[G1_pt(2)-Dr01(2),G1_pt(2)+Dr01(2)],'k')
plot([x1,x1+Dr0(1)],[y1,y1+Dr0(2)],'k--')
%rectangle('Position',[-1,-0.1,2,0.1])
axis equal
axis([-2,2,-0.5,1])


%{
+[M函数](,验证计算)
%}
## end
#2892, 34:
Matlab\optics\Reflection_grating.m
## end
### 结束