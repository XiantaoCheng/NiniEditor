### 节点
地址, 的, parser, 目录, 的, 的, 节点数目统计, 20210805, 的, 的, python parser, 的, 公式parser, 的, 名词, 的, python程序, 的, 程序, 的, 语句, 的, def, 的, class, 的, try, 的, while, 的, for, 的, if, 的, 输入, 的, 运算, 的, 空格, 的, 变量, 的, 条件, 的, 范围, 的, 匹配模式_编程, 的, 缩进, 的, 测试, 的, 代码, 20210806, 的, 的, 问题测试, 的, 简单结构, 的, 输入结构, 的, 输出结构, 的, 星图, 的, 的, test2, test, 的, P代码, 的, 测试, 的, 保存, 20210807, 的, 20210812, 的, 20220305, 的, 20220306, 的, 20220311, 的, 的, 测试语句, 的, 测试if, 的, 输出结构, 的, 结构, 的, 缩进, 的, 增加缩进, 的, 保存, 20220313, 的, 的, P代码, P函数, 的, 模块结尾, 的, P代码, P函数, 的, 保存, 的, P代码, P函数, 的, 测试循环, 的, 显示code, 的, P代码, P函数, 的, 测试try, 的, 测试定义, 20220314, 的, 的, P代码, P函数, 20220315, 的, 的, 保存, 的, 保存2, 的, 保存2, 20220316, 的, 20220319, 的, 20220320, 的, 的, 操作, 的, 设置程序块位置, 的, 库, 的, 程序, 的, 语句, 的, if, 的, def, 的, class, 的, try, 的, while, 的, for, 的, 运算, 的, elif, 的, 结构场景, 的, 画结构, S函数, 的, 画结构, S函数, 的, P代码, P函数, 的, 画结构, S函数, 的, 画结构, S函数, 的, 画结构, 的, 画结构, S函数, 的, 画结构, S函数, 的, 画结构, S函数, 的, P代码, P函数, 的, P代码, P函数, 的, P代码, P函数, 的, P代码, P函数, 的, P代码, P函数, 的, P代码, P函数, 的, P代码, P函数, 的, 画结构, 20220321, 的, 的, P代码, P函数, 块尺寸, P函数, P代码, 的, 画结构, 的, elif, P函数, P代码, 的, S函数, 画结构, 的, 运算, P函数, P代码, 的, S函数, 画结构, 的, for, P函数, P代码, 的, S函数, 画结构, 的, while, P函数, P代码, 的, 画结构, 的, try, P函数, P代码, 的, S函数, 画结构, 的, class, P函数, P代码, 的, S函数, 画结构, 的, def, P函数, P代码, 的, S函数, 画结构, 的, if, 语句, P函数, P代码, 的, S函数, 画结构, 的, 程序, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 库, 的, 收集程序块尺寸, 的, 20220322, 的, 的, 保存, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 的, 删除场景结构, 的, 生成程序结构, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 的, 结构场景, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 20220325, 的, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 的, 保存, 的, 保存, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 的, 保存, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 的, 图形, 块尺寸, 块尺寸, 块尺寸, 块尺寸, 块尺寸, 块尺寸, 块尺寸, 块尺寸, 块尺寸, 块尺寸, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 块尺寸, 块尺寸, 块尺寸, 块尺寸, 块尺寸, 块尺寸, 块尺寸, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 组尺寸, 的, 的, 的, 模块, 尺寸, 组尺寸, 的, 的, 的, 模块, 尺寸, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 模块, 的, 的, 尺寸, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 组尺寸, 的, 的, 的, 模块, 尺寸, 模块, 的, 的, 尺寸, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 组尺寸, 的, 的, 的, 模块, 尺寸, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 组尺寸, 的, 的, 的, 模块, 尺寸, 组尺寸, 的, 的, 的, 模块, 尺寸, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 组尺寸, 的, 的, 的, 模块, 尺寸, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 组尺寸, 的, 的, 的, 模块, 尺寸, 组尺寸, 的, 的, 的, 模块, 尺寸, 组尺寸, 的, 的, 的, 模块, 尺寸, 组尺寸, 的, 的, 的, 模块, 尺寸, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 的, 的, 模块, 尺寸, 的, 的, 模块, 尺寸, 组尺寸, 的, 的, 的, 空间点, 在, 的, 的, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 空间点, 的, 的, 空间点, 在, 空间点, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 空间点, 空间点, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 空间点, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 空间点, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 空间点, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 空间点, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 空间点, 的, 的, 空间点, 在, 空间点, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 空间点, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 空间点, 空间点, 的, 时间间隔测试, 20220327, 的, 的, 测试1, 的, 时间1, 的, 结构场景, 的, 输出内容, 的, 记录时间, 的, 分析程序结构, 的, 测试2, 的, 时间2, 的, 测试3, 的, 时间3, 的, 测试4, 的, 时间4, 的, 统计时长, M函数, 的, 测试结果, 的, if时长, 的, while时长, 的, 重复单元, 的, python程序_代码, 的, P代码, M函数, 的, 函数定义, P函数, 的, 测试, P函数, 的, 保存func, 的, 保存op, 的, 保存class, 的, 保存循环, 的, 保存if, 的, Karma, 20220328, 的, 答案, 回答, 答案, 回答, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 20220506, 的, 20220507, 的, 的, 移除注释, 的, P代码, 的, 列举函数, 20220508, 的, 的, debug, 的, 20220513, 的, 输出结构, 的, 结构场景, 的, 代码, 20220513, 的, 的, 保存, 的, 图形, 答案, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 的, 尺寸, 的, 模块, 的, 的, 模块, 尺寸, 的, 的, 模块, 尺寸, 组尺寸, 的, 的, 的, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 20220514, 的, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 的, 测试代码, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 的, cond_python_token存档, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 块尺寸, 块尺寸, 块尺寸, 块尺寸, 块尺寸, 块尺寸, 块尺寸, 块尺寸, 块尺寸, 块尺寸, 块尺寸, 块尺寸, 块尺寸, 块尺寸, 块尺寸, 块尺寸, 块尺寸, 块尺寸, 块尺寸, 块尺寸, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 的, 尺寸, 的, 模块, 模块, 的, 的, 尺寸, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 组尺寸, 的, 的, 的, 模块, 尺寸, 模块, 的, 的, 尺寸, 的, 尺寸, 的, 模块, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 模块, 的, 的, 尺寸, 的, 尺寸, 的, 模块, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 组尺寸, 的, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 模块, 的, 的, 尺寸, 的, 尺寸, 的, 模块, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 模块, 的, 的, 尺寸, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 模块, 的, 的, 尺寸, 的, 尺寸, 的, 模块, 模块, 的, 的, 尺寸, 的, 尺寸, 的, 模块, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 模块, 的, 的, 尺寸, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 模块, 的, 的, 尺寸, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 模块, 的, 的, 尺寸, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 模块, 的, 的, 尺寸, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 模块, 的, 的, 尺寸, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 模块, 的, 的, 尺寸, 组尺寸, 的, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 的, 的, 模块, 尺寸, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 组尺寸, 的, 的, 的, 空间点, 在, 的, 的, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 空间点, 空间点, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 空间点, 的, 的, 空间点, 在, 空间点, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 空间点, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 空间点, 空间点, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 空间点, 的, 的, 空间点, 在, 空间点, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 空间点, 的, 的, 空间点, 在, 空间点, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 空间点, 空间点, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 空间点, 空间点, 空间点, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 空间点, 空间点, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 空间点, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 空间点, 的, 的, 空间点, 在, 空间点, 空间点, 空间点, 的, 的, 空间点, 在, 空间点, 20220625, 的, 20220626, 的, 20220921, 的, 20220922, 的, 的, 生成代码, 的, 代码内容, 的, 代码结构, 手, 的, 为, 解析, 的, 的, 为, 解析, 的, 标记, 的, 示意图, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 的, 尺寸, 的, 模块, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 尺寸, 的, 模块, 组尺寸, 的, 的, 的, 模块, 尺寸, 模块, 的, 的, 尺寸, 组尺寸, 的, 的, 的, 空间点, 在, 的, 的, 在, 空间点, 空间点, 的, 的, 空间点, 在, 空间点, 的, 的, 空间点, 在, 的, 的, 空间点, 在, 空间点, 空间点, 的, 输出代码, P代码, 的, 去结尾, P代码, 的, 增加缩进, 代码模板, 的, elif, P代码, 的, 运算, 代码模板, 的, for, 代码模板, 的, while, 代码模板, 的, try, 代码模板, 的, class, P代码, 代码模板, 的, 的, def, 代码模板, else模板, 的, 的, if, 语句, 程序, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 库, 的, 结构转代码, 的, 的, P模板1, 的, P模板2, 的, JS模板1, 的, JS模板2, 记忆, 的, 的, P模板, 的, JS模板, 的, JS模板, 的, P模板, 的, P模板, 的, JS模板, 的, P模板, 的, JS模板, 的, P模板, 的, JS模板, 的, P模板, 的, JS模板, 的, JS转换, 的, P转换, 的, M模板, 的, M模板, 的, M模板, 的, M模板, 的, M模板1, 的, M模板2, 20220923, 的, 手, 的, parser集合, 的, python, 的, 规则, 的, C, 的, 规则, 的, 代码, 的, 保存, 的, M程序_代码, 的, P代码, P函数, 的, 函数定义, P函数, 的, 结构, 的, 测试代码, 手, 的, 保存版本, 的, 默认定义, 的, 规则, 规则, 默认定义, P函数, 函数定义, 的, 的, 的, P函数, P代码, 的, JS程序_代码, 的, 的, Matlab, 的, 测试代码, 的, 结构, 手, P函数, 函数定义, 默认定义, 规则, P函数, 的, 的, 的, P代码, 的, C程序_代码, 的, 的, 规则, 的, Javacript, 的, 规则, 的, 测试代码, 的, 结构, 的, 版本1, 的, 版本2, 的, 结构示意图, 的, 代码, 的, 结构, 的, 观察代码结构, 的, 库, 的, 代码块, 的, 函数块, 的, 如果块, 的, 循环块, 的, 输出类型, 的, 输入变量, 的, 函数, 运算, 的, 命名空间, 的, 的, 如果, 的, 工具库, 的, 代码结构转流程图, 的, 召唤规则, 的, 降临规则, 的, 生成结构, 的, 描述结构, 手, 召唤规则, 的, 代码结构转文本描述, 的, 描述文本, 的, 收集块, 的, P代码, 的, P代码2, 的, 收集内容, 的, P代码1, 的, 整理结构, 的, 库, 的, 描述模块, 的, 写模块, 的, P代码, 的, P代码2, 的, P代码3, 整理文本, 整理文本, 整理文本, 整理文本, 整理文本, 整理文本, 整理文本, 整理文本, 整理文本, 整理文本, 整理文本, 整理文本, 整理文本, 整理文本, 的, 测试, 整理文本, 整理文本, 整理文本, 整理文本, 整理文本, 手, 整理文本, 整理文本, 整理文本, 整理文本, 整理文本, 整理文本, 整理文本, 整理文本, 整理文本, 整理文本, 整理文本, 整理文本, 整理文本, 整理文本, 整理文本, 整理文本, 的, P代码b, 整理文本, 整理文本, 整理文本, 整理文本, 整理文本, 整理文本, 整理文本, 整理文本, 整理文本, 整理文本, 整理文本, 整理文本, 的, 保存, 整理文本, 整理文本, 整理文本, 整理文本, 整理文本, 整理文本, 整理文本, 整理文本, 整理结构, P代码b, P代码3, 测试, 的, P代码2, P代码, 的, 的, 的, 的, 写模块, 的, 描述模块, 的, 库, 保存, 收集内容, 的, 的, 收集块, 的, 描述结构, 的, 的, 生成结构, 的, 的, 降临规则, 召唤规则, 的, 的, 代码结构转代码, 的, 的, 流程图, 手, 召唤规则, 的, 代码结构转流程图, 的, 模块连线, 的, 描述结构, 的, 库, 的, 绘制模块, 的, 结尾, 的, 保存, 的, 后处理, 的, P代码, 结构, 的, 的, 条件, 模块, 的, 的, 条件, 模块, 的, 的, 条件, 模块, 的, 的, 内容, 的, 模块, 的, 内容, 的, 模块, 保存, M代码3, M代码0, M代码2, M代码, 的, 的, 的, 的, 的, 绘制条件, M代码3, M代码0, M代码2, M代码, 的, 的, 的, 的, 绘制运算, M代码3, M代码, M代码2, M代码0, 的, 的, 的, 的, 绘制函数, 保存, M代码3, M代码, M代码2, M代码0, 的, 的, 的, 的, 的, 绘制否则, M代码3, M代码0, M代码2, M代码, 的, 的, 的, 的, 绘制如果, 的, 的, 的, 的, 的, 库, 模块类型, 的, 绘制模块, 的, 描述结构, 的, 的, 布置位置, 的, 的, 连线类型, 的, 画if结尾, 的, M代码, y, 的, x, 的, 的, 样式, 连线, y, 的, x, 的, 的, 样式, 连线, y, 的, x, 的, 的, 样式, 连线, y, 的, x, 的, 的, 样式, 连线, y, 的, x, 的, 的, 样式, 连线, y, 的, x, 的, 的, 样式, 连线, y, 的, x, 的, 的, 样式, 连线, y, 的, x, 的, 的, 样式, 连线, y, 的, x, 的, 的, 样式, 连线, y, 的, x, 的, 的, 样式, 连线, y, 的, x, 的, 的, 样式, 连线, y, 的, x, 的, 的, 样式, 连线, M代码, 的, 画顺序, 的, 手, M代码, 的, 画if开头, 的, 结构, 的, 的, 条件, 的, 模块, 的, 条件, 的, 模块, 的, 条件, 的, 模块, 的, 内容, 的, 模块, 的, 内容, 的, 模块, 的, 条件, 的, 模块, 的, 内容, 的, 模块, 的, 相邻, 的, 相邻, 的, 相邻, 的, 相邻, 的, 的, 空间点, 在, 文字位置, 的, 的, 的, 文字, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 样式, 的, 的, 空间点, 在, 函数模块, 的, 的, 的, 空间点, 在, 文字位置, 的, 的, 的, 文字, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 样式, 的, 的, 空间点, 在, 如果模块, 的, 的, 的, 空间点, 在, 文字位置, 的, 的, 的, 文字, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 样式, 的, 的, 空间点, 在, 运算模块, 的, 的, 的, 的, 是, 空间点, 在, 否则模块, 的, 的, 的, 空间点, 在, 文字位置, 的, 的, 的, 文字, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 样式, 的, 的, 空间点, 在, 运算模块, 的, 的, 的, 的, 是, 空间点, 在, 条件模块, 的, 的, 的, 空间点, 在, 文字位置, 的, 的, 的, 文字, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 样式, 的, 的, 空间点, 在, 如果模块, 的, 的, 的, 的, 是, 空间点, 在, 否则模块, 的, 的, 的, 空间点, 在, 文字位置, 的, 的, 的, 文字, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 样式, 的, 的, 空间点, 在, 如果模块, 的, 的, 的, 的, 是, 空间点, 在, 否则模块, 的, 的, 的, 空间点, 在, 文字位置, 的, 的, 的, 文字, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 样式, 的, 的, 空间点, 在, 运算模块, 的, 的, 的, 的, 是, 空间点, 在, 条件模块, 的, 的, 的, 空间点, 在, 文字位置, 的, 的, 的, 文字, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 样式, 的, 的, 空间点, 在, 运算模块, 的, 的, 的, 的, 是, 空间点, 在, 条件模块, 的, 的, 的, 空间点, 在, 文字位置, 的, 的, 的, 文字, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 样式, 的, 的, 空间点, 在, 运算模块, 的, 的, 的, 的, 是, 空间点, 在, 条件模块, 的, 的, 的, 空间点, 在, 文字位置, 的, 的, 的, 文字, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 样式, 的, 的, 空间点, 在, 运算模块, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, y, 的, x, 的, 的, 样式, 连线, 的, 的, H代码, 起点, 起点, 起点, 起点, 的, 保存cmd, 起点, 起点, 起点, 召唤规则, P代码, P代码2, 收集内容, P代码1, 保存, 的, 的, 的, 的, 的, 收集块, 的, 描述结构, P代码, 测试, 的, P代码2, P代码3, P代码b, 的, 的, 的, 的, 写模块, 的, 描述模块, 的, 库, 的, 的, 生成结构, 整理结构, 的, 的, 降临规则, 的, 的, 代码结构转文本描述, 的, 的, 测试代码, 的, 代码, 的, 结构, 的, 输出代码, 手, 的, 的, 的, 召唤规则, 的, 的, 的, 代码结构转代码, 的, 起点, 起点, 起点, 起点, 起点, 起点, 起点, 起点, 的, 代码模块, 的, 函数模块, 的, 一般模块, 起点, 缩进, 起点, 缩进, 缩进, 起点, 缩进, 缩进, 起点, 缩进, 缩进, 缩进, 起点, 缩进, 缩进, 缩进, 起点, 缩进, 缩进, 缩进, 起点, 缩进, 缩进, 缩进, 缩进, 缩进, 起点, 缩进, 缩进, 缩进, 缩进, 缩进, 起点, 缩进, 缩进, 缩进, 缩进, 缩进, 起点, 缩进, 缩进, 缩进, 缩进, 缩进, 的, P代码, 起点, 缩进, 缩进, 缩进, 缩进, 缩进, else模板, elif模板, if模板, 的, 的, 的, 如果模块, 的, 的, 模板, 起点, 起点, 起点, 起点, 起点, 起点, 缩进, 起点, 缩进, 缩进, 缩进, 起点, 缩进, 缩进, 缩进, 起点, 缩进, 缩进, 缩进, 起点, 模板, 的, for模块, 的, 起点, 缩进, 缩进, 缩进, 缩进, 起点, 缩进, 起点, 起点, 文本, 的, 结构, 的, 的, 内部, 的, 条件, 模块, 的, 的, 内部, 的, 条件, 模块, 的, 内容, 的, 模块, 的, 的, 内部, 的, 内部, 的, 内容, 的, 模块, 内容, 的, 模块, 的, 的, 内部, 内容, 的, 模块, 的, 的, 内部, 内容, 的, 模块, 的, 起点, 的, else, elif, 运算, 节点, 的, 的, 顺序, 缩进, 的, 的, 插入, 运算, else, elif, 运算, 节点, 的, 的, 顺序, 缩进, 的, 的, 插入, 节点, 的, 的, 顺序, 的, 的, 缩进, 的, 的, 插入, 节点, 的, 的, 顺序, 的, 的, 
### 关联
#, 2#0, #, #, 3#2, 3#6, #, #, 6#7, 2#10, #, 2#12, #, 2#14, #, 14#16, #, 14#18, #, 14#20, #, 14#22, #, 14#24, #, 14#26, #, 14#28, #, 14#30, #, 14#32, #, 14#34, #, 14#36, #, 14#38, #, 14#40, #, 14#42, #, 14#44, #, 14#46, #, 14#48, #, 10#50, #, 50#52, #, #, 6#53, 50#56, #, 14#58, #, 50#60, #, 50#62, #, 2#64, #, 50#67, 50#68, #, #, 36#70, #, 70#72, #, 50#74, #, #, 6#75, #, 6#77, #, 6#79, #, 6#81, #, 6#83, 50#86, #, 86#88, #, 86#90, #, 86#92, #, 86#94, #, 14#96, #, 70#98, #, #, 6#99, 46#102, #, 102#, 14#105, #, 48#107, #, 107#, 48#110, #, 18#112, #, 112#, 86#115, #, 14#117, #, 117#119, #, 119#, 86#122, #, 86#124, #, #, 6#125, 20#128, #, 128#, #, 6#130, 36#133, #, 70#135, #, 50#137, #, #, 6#138, #, 6#140, #, 6#142, 2#145, #, 145#147, #, 147#149, #, 149#151, #, 149#153, #, 149#155, #, 149#157, #, 149#159, #, 149#161, #, 149#163, #, 149#165, #, 149#167, #, 149#169, #, 86#171, #, 155#173, #, 173#, 167#176, #, 176#, 176#179, #, 179#, 165#182, #, 182#, 163#185, #, 185#, 161#188, #, 159#190, #, 190#, 157#193, #, 193#, 151#196, #, 196#, 196#199, #, 199#, 182#202, #, 202#, 185#205, #, 205#, 188#208, #, 208#, 190#211, #, 211#, 193#214, #, 214#, 173#217, #, 217#, 169#220, #, #, 6#221, 220#224, #, 224#, #, 228#, #, 230#228, #, 232#230, #, 234#, #, 237#234, 237#, #, 239#237, #, 241#, #, 244#241, 244#, #, 246#244, #, 248#, #, 251#248, 251#, #, 253#251, #, 255#, #, 257#255, #, 259#257, #, 261#, #, 264#261, 264#, #, 266#264, #, 268#, #, 271#268, 271#, #, 273#271, #, 275#, #, 278#275, 278#, #, 280#278, #, #, 283#, #, 286#283, 286#, #, 288#286, #, 300#226, 300#232, 300#239, 300#246, 300#253, 300#259, 300#266, 300#273, 300#280, 300#281, 300#288, #, 302#300, #, 145#302, #, 6#304, 196#307, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, 145#333, #, 145#335, #, #, #, #, #, #, #, #, #, 50#345, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, 6#638, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, 230#743, #, 278#745, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, 173#790, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, 345#826, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, 826#1147, #, 1147#1145, #, 826#1151, #, 1151#1149, #, #, 1151#1152, 826#1156, 1156#1157, #, #, 826#1161, #, 1161#1159, #, 826#1165, #, 1165#1163, #, 826#1169, #, 1169#1167, #, #, 1169#1170, 826#1174, 1174#1175, #, #, #, 1174#1176, 826#1180, 1180#1181, #, #, #, 1180#1182, 826#1186, 1186#1187, #, #, #, 1186#1188, 826#1192, 1192#1193, #, #, 826#1197, #, 1197#1195, #, #, 1197#1198, 826#1203, #, 1203#1201, #, #, 1203#1204, 826#1208, 1208#1209, #, #, 826#1213, #, 1213#1211, #, 826#1217, #, 1217#1215, #, #, 1217#1218, 826#1223, #, 1223#1221, #, #, 1223#1224, 826#1229, #, 1229#1227, #, 826#1233, #, 1233#1231, #, #, 1233#1234, 826#1239, #, 1239#1237, #, #, 1239#1240, 826#1244, 1244#1245, #, #, #, 1229#1246, 826#1251, #, 1251#1249, #, #, 1251#1252, 826#1257, #, 1257#1255, #, #, 1257#1258, 826#1262, 1262#1263, #, #, #, 826#1264, 1264#1267, #, #, 1264#1268, 826#1272, 1272#1273, #, #, 826#1277, #, 1277#1275, #, #, 1277#1278, 826#1283, #, 1283#1281, #, #, 1283#1284, 826#1288, 1288#1289, #, #, 826#1293, #, 1293#1291, #, #, 1293#1294, 826#1299, #, 1299#1297, #, #, 1299#1300, 826#1304, 1304#1305, #, #, #, 1304#1306, 826#1311, #, 1311#1309, #, #, 1311#1312, 826#1317, #, 1317#1315, #, #, 1317#1318, 826#1322, 1322#1323, #, #, #, 1322#1324, 826#1328, 1328#1329, #, #, #, 826#1330, 1330#1333, #, 826#1337, #, 1337#1335, #, #, 1337#1338, 826#1342, 1342#1343, #, #, #, 1288#1344, 826#1348, 1348#1349, #, #, 826#1353, #, 1353#1351, #, #, 1353#1354, 826#1358, 1358#1359, #, #, 826#1363, #, 1363#1361, #, 826#1367, #, 1367#1365, #, #, 1367#1368, 826#1373, #, 1373#1371, #, #, 1373#1374, 826#1379, #, 1379#1377, #, 826#1383, #, 1383#1381, #, #, 1383#1384, 826#1389, #, 1389#1387, #, #, 1389#1390, 826#1394, 1394#1395, #, #, #, 1379#1396, 826#1400, 1400#1401, #, #, #, 1400#1402, 826#1407, #, 1407#1405, #, #, 1407#1408, 826#1413, #, 1413#1411, #, 826#1417, #, 1417#1415, #, #, 1417#1418, 826#1423, #, 1423#1421, #, #, 1423#1424, 826#1428, 1428#1429, #, #, #, 1413#1430, 826#1434, 1434#1435, #, #, #, 1434#1436, 826#1440, 1440#1441, #, #, #, 1358#1442, 826#1447, #, 1447#1445, #, #, 1447#1448, 826#1453, #, 1453#1451, #, #, 1453#1454, 826#1459, #, 1459#1457, #, 826#1463, #, 1463#1461, #, #, 1463#1464, 826#1469, #, 1469#1467, #, #, 1469#1470, 826#1475, #, 1475#1473, #, 826#1479, #, 1479#1477, #, #, 1479#1480, 826#1485, #, 1485#1483, #, #, 1485#1486, 826#1490, 1490#1491, #, #, #, 1475#1492, 826#1496, 1496#1497, #, #, #, 1496#1498, 826#1503, #, 1503#1501, #, #, 1503#1504, 826#1509, #, 1509#1507, #, 826#1513, #, 1513#1511, #, #, 1513#1514, 826#1519, #, 1519#1517, #, #, 1519#1520, 826#1524, 1524#1525, #, #, #, 1509#1526, 826#1530, 1530#1531, #, #, #, 1530#1532, 826#1536, 1536#1537, #, #, #, 1459#1538, 826#1542, 1542#1543, #, #, #, 1542#1544, 826#1548, 1548#1549, #, #, #, 1548#1550, 826#1554, 1554#1555, #, #, 826#1559, #, 1559#1557, #, #, 1559#1560, 826#1564, 1564#1565, #, #, 826#1569, #, 1569#1567, #, #, 1569#1570, 826#1574, 1574#1575, #, #, 826#1579, #, 1579#1577, #, 826#1583, #, 1583#1581, #, #, 1583#1584, 826#1589, #, 1589#1587, #, #, 1589#1590, 826#1594, 1594#1595, #, #, #, 1564#1596, 826#1600, 1600#1601, #, #, 826#1605, #, 1605#1603, #, 826#1608, 1608#1609, #, #, 826#1612, 1612#1613, #, #, #, 1147#1614, 826#1618, 826#1619, #, 1156#1618, 826#1623, 826#1622, 1147#1623, #, 826#1626, 826#1627, #, 1161#1626, #, 826#1631, 826#1632, #, 1151#1631, #, 826#1636, 826#1637, #, 1612#1636, #, #, 826#1642, 826#1643, #, 1608#1642, #, 826#1647, 826#1648, #, 1165#1647, 826#1651, 826#1652, #, 1192#1651, #, 826#1656, 826#1657, #, 1272#1656, #, 826#1661, 826#1662, #, 1186#1661, #, 826#1666, 826#1667, #, 1180#1666, #, 826#1671, 826#1672, #, 1174#1671, #, 826#1676, 826#1677, #, 1169#1676, #, 826#1681, 826#1682, #, 1348#1681, #, 826#1686, 826#1687, #, 1264#1686, #, 826#1691, 826#1692, #, 1208#1691, 826#1695, 826#1696, #, 1213#1695, #, 826#1700, 826#1701, #, 1203#1700, 826#1704, 826#1705, #, 1197#1704, #, #, 826#1710, 826#1711, #, 1262#1710, #, #, 826#1716, 826#1717, #, 1257#1716, 826#1720, 826#1721, #, 1223#1720, 826#1724, 826#1725, #, 1217#1724, #, 826#1729, 826#1730, #, 1229#1729, #, 826#1734, 826#1735, #, 1251#1734, 826#1738, 826#1739, #, 1244#1738, #, #, 826#1744, 826#1745, #, 1239#1744, 826#1748, 826#1749, #, 1233#1748, #, #, #, #, 826#1756, 826#1757, #, 1554#1756, #, 826#1761, 826#1762, #, 1288#1761, 826#1765, 826#1766, #, 1330#1765, #, 826#1770, 826#1771, #, 1283#1770, 826#1774, 826#1775, #, 1277#1774, #, #, 826#1780, 826#1781, #, 1342#1780, #, 826#1785, 826#1786, #, 1328#1785, #, 826#1790, 826#1791, #, 1322#1790, 826#1794, 826#1795, #, 1304#1794, #, 826#1799, 826#1800, #, 1299#1799, 826#1803, 826#1804, #, 1293#1803, #, #, #, 826#1810, 826#1811, #, 1317#1810, 826#1814, 826#1815, #, 1311#1814, #, #, #, 826#1821, 826#1822, #, 1337#1821, #, 826#1826, 826#1827, #, 1600#1826, #, 826#1831, 826#1832, #, 1548#1831, #, 826#1836, 826#1837, #, 1542#1836, 826#1840, 826#1841, #, 1358#1840, 826#1844, 826#1845, #, 1363#1844, #, 826#1849, 826#1850, #, 1353#1849, #, 826#1854, 826#1855, #, 1440#1854, #, #, 826#1860, 826#1861, #, 1400#1860, 826#1864, 826#1865, #, 1367#1864, #, 826#1869, 826#1870, #, 1434#1869, #, 826#1874, 826#1875, #, 1379#1874, 826#1878, 826#1879, #, 1373#1878, #, 826#1883, 826#1884, #, 1394#1883, #, #, 826#1889, 826#1890, #, 1389#1889, 826#1893, 826#1894, #, 1383#1893, #, #, #, 826#1900, 826#1901, #, 1413#1900, 826#1904, 826#1905, #, 1407#1904, #, 826#1909, 826#1910, #, 1428#1909, #, #, 826#1915, 826#1916, #, 1423#1915, 826#1919, 826#1920, #, 1417#1919, #, #, #, 826#1926, 826#1927, #, 1459#1926, 826#1930, 826#1931, #, 1453#1930, 826#1934, 826#1935, #, 1447#1934, #, #, 826#1940, 826#1941, #, 1536#1940, #, #, 826#1946, 826#1947, #, 1496#1946, 826#1950, 826#1951, #, 1463#1950, #, 826#1955, 826#1956, #, 1530#1955, #, 826#1960, 826#1961, #, 1475#1960, 826#1964, 826#1965, #, 1469#1964, #, 826#1969, 826#1970, #, 1490#1969, #, #, 826#1975, 826#1976, #, 1485#1975, 826#1979, 826#1980, #, 1479#1979, #, #, #, 826#1986, 826#1987, #, 1509#1986, 826#1990, 826#1991, #, 1503#1990, #, 826#1995, 826#1996, #, 1524#1995, #, #, 826#2001, 826#2002, #, 1519#2001, 826#2005, 826#2006, #, 1513#2005, #, #, 826#2011, 826#2012, #, 1605#2011, #, 826#2016, 826#2017, #, 1564#2016, 826#2020, 826#2021, #, 1574#2020, #, 826#2025, 826#2026, #, 1559#2025, #, 826#2030, 826#2031, #, 1579#2030, #, 826#2035, 826#2036, #, 1569#2035, #, 826#2040, 826#2041, #, 1594#2040, #, #, 826#2046, 826#2047, #, 1589#2046, 826#2050, 826#2051, #, 1583#2050, #, #, #, 2#2056, #, #, 6#2057, 2056#2060, #, 2056#2062, #, 2056#2064, #, 2056#2066, #, 145#2068, #, 145#2070, #, 2056#2072, #, 2056#2074, #, 2056#2076, #, 2056#2078, #, 2056#2080, #, 2056#2082, #, 2056#2084, #, 2084#, 2084#2087, #, 2084#2089, #, 2084#2091, #, 2091#2093, #, 14#2095, #, 2095#2097, #, 2097#, 2097#2100, #, 2100#, 2100#2103, #, 2103#, 2103#2106, #, 2103#2108, #, 2103#2110, #, 2103#2112, #, 2103#2114, #, 2103#2116, #, #, 6#2117, #, 2103#, #, 2103#, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, 6#2150, #, 6#2152, 145#2155, #, 2155#2157, #, 145#2159, #, #, 6#2160, 2#2163, #, 2163#2165, #, 2165#2167, #, 2165#2169, #, 2165#2171, #, #, 6#2172, 2171#2175, #, 86#2177, #, #, #, #, #, #, #, #, #, #, #, #, 2177#2192, #, 2192#2190, #, 2177#2195, 2195#2196, #, #, 2177#2199, 2199#2200, #, #, #, 2199#2201, 2177#2206, 2177#2205, 2199#2206, #, 2177#2209, 2177#2210, #, 2195#2209, #, 2177#2214, 2177#2215, #, 2192#2214, #, #, 6#2217, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, 2165#2245, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, 2100#2437, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, 2169#2780, #, 2780#2778, #, #, 2169#2781, 2781#2784, #, 2169#2788, #, 2788#2786, #, 2169#2792, #, 2792#2790, #, #, 2792#2793, 2169#2798, #, 2798#2796, #, #, 2798#2799, 2169#2804, #, 2804#2802, #, #, 2804#2805, 2169#2810, #, 2810#2808, #, #, 2810#2811, 2169#2816, #, 2816#2814, #, #, 2816#2817, 2169#2821, 2821#2822, #, #, 2169#2826, #, 2826#2824, #, 2169#2829, 2829#2830, #, #, 2169#2834, #, 2834#2832, #, 2169#2838, #, 2838#2836, #, 2169#2842, #, 2842#2840, #, #, 2842#2843, 2169#2848, #, 2848#2846, #, #, 2848#2849, 2169#2854, #, 2854#2852, #, 2169#2858, #, 2858#2856, #, #, 2858#2859, 2169#2864, #, 2864#2862, #, #, 2864#2865, 2169#2869, 2869#2870, #, #, #, 2854#2871, 2169#2875, 2875#2876, #, #, #, 2169#2877, 2877#2880, #, 2169#2884, #, 2884#2882, #, 2169#2887, 2887#2888, #, #, 2169#2892, #, 2892#2890, #, 2169#2896, #, 2896#2894, #, #, 2896#2897, 2169#2902, #, 2902#2900, #, #, 2902#2903, 2169#2908, #, 2908#2906, #, #, 2908#2909, 2169#2913, 2913#2914, #, #, #, 2169#2915, 2915#2918, #, 2169#2922, #, 2922#2920, #, 2169#2925, 2925#2926, #, #, 2169#2930, #, 2930#2928, #, #, 2930#2931, 2169#2935, 2935#2936, #, #, 2169#2940, #, 2940#2938, #, 2169#2944, #, 2944#2942, #, #, 2944#2945, 2169#2949, 2949#2950, #, #, 2169#2954, #, 2954#2952, #, 2169#2958, #, 2958#2956, #, #, 2958#2959, 2169#2963, 2963#2964, #, #, 2169#2968, #, 2968#2966, #, 2169#2972, #, 2972#2970, #, #, 2972#2973, 2169#2978, #, 2978#2976, #, #, 2978#2979, 2169#2983, 2983#2984, #, #, #, 2968#2985, 2169#2990, #, 2990#2988, #, 2169#2994, #, 2994#2992, #, #, 2994#2995, 2169#3000, #, 3000#2998, #, #, 3000#3001, 2169#3005, 3005#3006, #, #, 2169#3010, #, 3010#3008, #, 2169#3014, #, 3014#3012, #, #, 3014#3015, 2169#3020, #, 3020#3018, #, #, 3020#3021, 2169#3025, 3025#3026, #, #, #, 3005#3027, 2169#3032, #, 3032#3030, #, #, 3032#3033, 2169#3037, 3037#3038, #, #, #, 2990#3039, 2169#3043, 3043#3044, #, #, 2169#3048, #, 3048#3046, #, 2169#3051, 3051#3052, #, #, 2169#3056, #, 3056#3054, #, 2169#3060, #, 3060#3058, #, #, 3060#3061, 2169#3065, 3065#3066, #, #, 2169#3070, #, 3070#3068, #, #, 3070#3071, 2169#3075, 3075#3076, #, #, #, 3075#3077, 2169#3081, 3081#3082, #, #, 2169#3086, #, 3086#3084, #, 2169#3090, #, 3090#3088, #, 2169#3094, #, 3094#3092, #, #, 3094#3095, 2169#3099, 3099#3100, #, #, 2169#3104, #, 3104#3102, #, #, 3090#3105, 2169#3109, 3109#3110, #, #, 2169#3114, #, 3114#3112, #, 2169#3118, #, 3118#3116, #, #, 3118#3119, 2169#3123, 3123#3124, #, #, 2169#3128, #, 3128#3126, #, 2169#3132, #, 3132#3130, #, #, 3132#3133, 2169#3137, 3137#3138, #, #, 2169#3142, #, 3142#3140, #, #, 3114#3143, 2169#3147, 3147#3148, #, #, 2169#3152, #, 3152#3150, #, #, 3152#3153, 2169#3157, 3157#3158, #, #, 2169#3162, #, 3162#3160, #, 2169#3166, #, 3166#3164, #, #, 3166#3167, 2169#3171, 3171#3172, #, #, 2169#3176, #, 3176#3174, #, 2169#3179, 3179#3180, #, #, 2169#3184, #, 3184#3182, #, 2169#3188, #, 3188#3186, #, #, 3188#3189, 2169#3194, #, 3194#3192, #, #, 3194#3195, 2169#3200, #, 3200#3198, #, #, 3200#3201, 2169#3206, #, 3206#3204, #, #, 3206#3207, 2169#3211, 3211#3212, #, #, 2169#3216, #, 3216#3214, #, #, 2169#3217, 3217#3220, #, 2169#3224, #, 3224#3222, #, 2169#3227, 3227#3228, #, #, 2169#3232, #, 3232#3230, #, #, 3232#3233, 2169#3238, #, 3238#3236, #, #, 3238#3239, 2169#3244, #, 3244#3242, #, #, 3244#3245, 2169#3250, #, 3250#3248, #, #, 3250#3251, 2169#3256, #, 3256#3254, #, #, 3256#3257, 2169#3261, 3261#3262, #, #, 2169#3266, #, 3266#3264, #, 2169#3269, 3269#3270, #, #, 2169#3274, #, 3274#3272, #, 2169#3278, #, 3278#3276, #, 2169#3282, #, 3282#3280, #, #, 3282#3283, 2169#3287, 3287#3288, #, #, 2169#3292, #, 3292#3290, #, #, 2169#3293, 3293#3296, #, 2169#3300, #, 3300#3298, #, 2169#3304, #, 3304#3302, #, 2169#3308, #, 3308#3306, #, #, 3308#3309, 2169#3314, #, 3314#3312, #, #, 3314#3315, 2169#3319, 3319#3320, #, #, #, 3304#3321, 2169#3325, 3325#3326, #, #, 2169#3330, #, 3330#3328, #, 2169#3334, #, 3334#3332, #, 2169#3338, #, 3338#3336, #, #, 3338#3339, 2169#3344, #, 3344#3342, #, #, 3344#3345, 2169#3349, 3349#3350, #, #, #, 3334#3351, 2169#3355, 3355#3356, #, #, 2169#3360, #, 3360#3358, #, #, 2169#3361, 3361#3364, #, 2169#3368, #, 3368#3366, #, #, 2169#3369, 3369#3372, #, 2169#3376, #, 3376#3374, #, 2169#3379, 3379#3380, #, #, 2169#3384, #, 3384#3382, #, 2169#3388, #, 3388#3386, #, #, 3388#3389, 2169#3393, 3393#3394, #, #, 2169#3398, #, 3398#3396, #, 2169#3402, #, 3402#3400, #, 2169#3406, #, 3406#3404, #, #, 3406#3407, 2169#3412, #, 3412#3410, #, #, 3412#3413, 2169#3417, 3417#3418, #, #, 2169#3422, #, 3422#3420, #, 2169#3426, #, 3426#3424, #, #, 3426#3427, 2169#3431, 3431#3432, #, #, 2169#3436, #, 3436#3434, #, #, 2169#3437, 3437#3440, #, 2169#3444, #, 3444#3442, #, 2169#3448, #, 3448#3446, #, #, 3448#3449, 2169#3453, 3453#3454, #, #, 2169#3458, #, 3458#3456, #, 2169#3462, #, 3462#3460, #, 2169#3466, #, 3466#3464, #, #, 3466#3467, 2169#3472, #, 3472#3470, #, #, 3472#3473, 2169#3477, 3477#3478, #, #, 2169#3482, #, 3482#3480, #, 2169#3486, #, 3486#3484, #, #, 3486#3487, 2169#3491, 3491#3492, #, #, 2169#3496, #, 3496#3494, #, 2169#3500, #, 3500#3498, #, #, 3500#3501, 2169#3505, 3505#3506, #, #, 2169#3510, #, 3510#3508, #, 2169#3514, #, 3514#3512, #, #, 3514#3515, 2169#3519, 3519#3520, #, #, 2169#3524, #, 3524#3522, #, 2169#3528, #, 3528#3526, #, 2169#3532, #, 3532#3530, #, #, 2169#3533, 3533#3536, #, #, 3533#3537, 2169#3541, 3541#3542, #, #, 2169#3546, #, 3546#3544, #, 2169#3550, #, 3550#3548, #, 2169#3554, #, 3554#3552, #, #, 2169#3555, 3555#3558, #, #, 3555#3559, 2169#3563, 3563#3564, #, #, 2169#3568, #, 3568#3566, #, #, 2169#3569, 3569#3572, #, 2169#3576, #, 3576#3574, #, 2169#3580, #, 3580#3578, #, #, 3580#3581, 2169#3585, 3585#3586, #, #, 2169#3590, #, 3590#3588, #, 2169#3594, #, 3594#3592, #, 2169#3598, #, 3598#3596, #, #, 3598#3599, 2169#3604, #, 3604#3602, #, #, 3604#3605, 2169#3609, 3609#3610, #, #, #, 3609#3611, 2169#3615, 3615#3616, #, #, 2169#3620, #, 3620#3618, #, 2169#3624, #, 3624#3622, #, #, 3624#3625, 2169#3629, 3629#3630, #, #, 2169#3634, #, 3634#3632, #, #, 2169#3635, 3635#3638, #, 2169#3642, #, 3642#3640, #, 2169#3646, #, 3646#3644, #, 2169#3650, #, 3650#3648, #, #, 2169#3651, 3651#3654, #, #, 3646#3655, 2169#3659, 3659#3660, #, #, 2169#3664, #, 3664#3662, #, 2169#3667, 3667#3668, #, #, 2169#3672, #, 3672#3670, #, #, 3672#3673, 2169#3677, 3677#3678, #, #, #, 2829#3679, 2169#3683, 2169#3684, #, 2887#3683, 2169#3688, 2169#3687, 2829#3688, #, 2169#3691, 2169#3692, #, 2781#3691, 2169#3695, 2169#3696, #, 2788#3695, #, 2169#3700, 2169#3701, #, 2780#3700, #, 2169#3705, 2169#3706, #, 2821#3705, #, 2169#3710, 2169#3711, #, 2826#3710, #, 2169#3715, 2169#3716, #, 2816#3715, 2169#3719, 2169#3720, #, 2798#3719, 2169#3723, 2169#3724, #, 2792#3723, #, 2169#3728, 2169#3729, #, 2804#3728, #, 2169#3733, 2169#3734, #, 2810#3733, #, #, #, #, 2169#3741, 2169#3742, #, 2925#3741, #, 2169#3746, 2169#3747, #, 2834#3746, 2169#3750, 2169#3751, #, 2877#3750, #, 2169#3755, 2169#3756, #, 2884#3755, #, 2169#3760, 2169#3761, #, 2838#3760, 2169#3764, 2169#3765, #, 2875#3764, #, #, 2169#3770, 2169#3771, #, 2854#3770, 2169#3774, 2169#3775, #, 2848#3774, 2169#3778, 2169#3779, #, 2842#3778, #, #, 2169#3784, 2169#3785, #, 2869#3784, #, #, 2169#3790, 2169#3791, #, 2864#3790, 2169#3794, 2169#3795, #, 2858#3794, #, #, #, 2169#3801, 2169#3802, #, 3051#3801, #, 2169#3806, 2169#3807, #, 2915#3806, 2169#3810, 2169#3811, #, 2922#3810, #, 2169#3815, 2169#3816, #, 2892#3815, 2169#3819, 2169#3820, #, 2913#3819, #, #, 2169#3825, 2169#3826, #, 2908#3825, 2169#3829, 2169#3830, #, 2902#3829, 2169#3833, 2169#3834, #, 2896#3833, #, #, #, #, 2169#3841, 2169#3842, #, 3179#3841, #, 2169#3846, 2169#3847, #, 2935#3846, 2169#3850, 2169#3851, #, 2940#3850, #, 2169#3855, 2169#3856, #, 2930#3855, #, 2169#3860, 2169#3861, #, 2949#3860, #, 2169#3865, 2169#3866, #, 2954#3865, #, 2169#3870, 2169#3871, #, 2944#3870, #, 2169#3875, 2169#3876, #, 2963#3875, #, 2169#3880, 2169#3881, #, 3043#3880, #, 2169#3885, 2169#3886, #, 2958#3885, #, 2169#3890, 2169#3891, #, 3048#3890, #, 2169#3895, 2169#3896, #, 2990#3895, 2169#3899, 2169#3900, #, 2968#3899, 2169#3903, 2169#3904, #, 2983#3903, #, #, 2169#3909, 2169#3910, #, 2978#3909, 2169#3913, 2169#3914, #, 2972#3913, #, #, 2169#3919, 2169#3920, #, 3037#3919, #, #, 2169#3925, 2169#3926, #, 3032#3925, 2169#3929, 2169#3930, #, 3005#3929, 2169#3933, 2169#3934, #, 3010#3933, #, 2169#3938, 2169#3939, #, 3000#3938, 2169#3942, 2169#3943, #, 2994#3942, #, #, 2169#3948, 2169#3949, #, 3025#3948, #, #, 2169#3954, 2169#3955, #, 3020#3954, 2169#3958, 2169#3959, #, 3014#3958, #, #, #, #, 2169#3966, 2169#3967, #, 3227#3966, #, 2169#3971, 2169#3972, #, 3056#3971, 2169#3975, 2169#3976, #, 3065#3975, #, 2169#3980, 2169#3981, #, 3081#3980, #, 2169#3985, 2169#3986, #, 3060#3985, #, 2169#3990, 2169#3991, #, 3086#3990, #, 2169#3995, 2169#3996, #, 3075#3995, #, 2169#4000, 2169#4001, #, 3070#4000, #, 2169#4005, 2169#4006, #, 3109#4005, #, 2169#4010, 2169#4011, #, 3147#4010, #, 2169#4015, 2169#4016, #, 3090#4015, 2169#4019, 2169#4020, #, 3099#4019, #, 2169#4024, 2169#4025, #, 3104#4024, #, 2169#4029, 2169#4030, #, 3094#4029, #, #, 2169#4035, 2169#4036, #, 3157#4035, #, 2169#4040, 2169#4041, #, 3114#4040, 2169#4044, 2169#4045, #, 3123#4044, #, 2169#4049, 2169#4050, #, 3128#4049, #, 2169#4054, 2169#4055, #, 3118#4054, #, 2169#4059, 2169#4060, #, 3137#4059, #, 2169#4064, 2169#4065, #, 3142#4064, #, 2169#4069, 2169#4070, #, 3132#4069, #, #, 2169#4075, 2169#4076, #, 3162#4075, #, 2169#4080, 2169#4081, #, 3152#4080, #, 2169#4085, 2169#4086, #, 3171#4085, #, 2169#4090, 2169#4091, #, 3176#4090, #, 2169#4095, 2169#4096, #, 3166#4095, #, #, 2169#4101, 2169#4102, #, 3269#4101, #, 2169#4106, 2169#4107, #, 3184#4106, 2169#4110, 2169#4111, #, 3217#4110, #, 2169#4115, 2169#4116, #, 3224#4115, #, 2169#4120, 2169#4121, #, 3211#4120, 2169#4124, 2169#4125, #, 3216#4124, #, 2169#4129, 2169#4130, #, 3206#4129, 2169#4133, 2169#4134, #, 3194#4133, 2169#4137, 2169#4138, #, 3188#4137, #, 2169#4142, 2169#4143, #, 3200#4142, #, #, #, #, #, 2169#4151, 2169#4152, #, 3379#4151, #, 2169#4156, 2169#4157, #, 3261#4156, 2169#4160, 2169#4161, #, 3266#4160, #, 2169#4165, 2169#4166, #, 3256#4165, 2169#4169, 2169#4170, #, 3238#4169, 2169#4173, 2169#4174, #, 3232#4173, #, 2169#4178, 2169#4179, #, 3244#4178, #, 2169#4183, 2169#4184, #, 3250#4183, #, #, #, #, 2169#4191, 2169#4192, #, 3667#4191, #, 2169#4196, 2169#4197, #, 3274#4196, 2169#4200, 2169#4201, #, 3293#4200, #, 2169#4205, 2169#4206, #, 3361#4205, #, 2169#4210, 2169#4211, #, 3278#4210, 2169#4214, 2169#4215, #, 3287#4214, #, 2169#4219, 2169#4220, #, 3292#4219, #, 2169#4224, 2169#4225, #, 3282#4224, #, #, 2169#4230, 2169#4231, #, 3369#4230, #, 2169#4235, 2169#4236, #, 3300#4235, 2169#4239, 2169#4240, #, 3325#4239, #, 2169#4244, 2169#4245, #, 3330#4244, #, 2169#4249, 2169#4250, #, 3304#4249, 2169#4253, 2169#4254, #, 3319#4253, #, #, 2169#4259, 2169#4260, #, 3314#4259, 2169#4263, 2169#4264, #, 3308#4263, #, #, 2169#4269, 2169#4270, #, 3355#4269, #, 2169#4274, 2169#4275, #, 3360#4274, #, 2169#4279, 2169#4280, #, 3334#4279, 2169#4283, 2169#4284, #, 3349#4283, #, #, 2169#4289, 2169#4290, #, 3344#4289, 2169#4293, 2169#4294, #, 3338#4293, #, #, #, 2169#4300, 2169#4301, #, 3376#4300, #, 2169#4305, 2169#4306, #, 3368#4305, #, #, 2169#4311, 2169#4312, #, 3677#4311, #, 2169#4316, 2169#4317, #, 3384#4316, 2169#4320, 2169#4321, #, 3393#4320, #, 2169#4325, 2169#4326, #, 3398#4325, #, 2169#4330, 2169#4331, #, 3388#4330, #, 2169#4335, 2169#4336, #, 3437#4335, #, 2169#4340, 2169#4341, #, 3444#4340, #, 2169#4345, 2169#4346, #, 3402#4345, 2169#4349, 2169#4350, #, 3417#4349, #, 2169#4354, 2169#4355, #, 3422#4354, #, 2169#4359, 2169#4360, #, 3412#4359, 2169#4363, 2169#4364, #, 3406#4363, #, #, 2169#4369, 2169#4370, #, 3431#4369, #, 2169#4374, 2169#4375, #, 3436#4374, #, 2169#4379, 2169#4380, #, 3426#4379, #, #, 2169#4385, 2169#4386, #, 3453#4385, #, 2169#4390, 2169#4391, #, 3458#4390, #, 2169#4395, 2169#4396, #, 3448#4395, #, 2169#4400, 2169#4401, #, 3569#4400, #, 2169#4405, 2169#4406, #, 3576#4405, #, 2169#4410, 2169#4411, #, 3462#4410, 2169#4414, 2169#4415, #, 3477#4414, #, 2169#4419, 2169#4420, #, 3482#4419, #, 2169#4424, 2169#4425, #, 3472#4424, 2169#4428, 2169#4429, #, 3466#4428, #, #, 2169#4434, 2169#4435, #, 3491#4434, #, 2169#4439, 2169#4440, #, 3496#4439, #, 2169#4444, 2169#4445, #, 3486#4444, #, 2169#4449, 2169#4450, #, 3505#4449, #, 2169#4454, 2169#4455, #, 3510#4454, #, 2169#4459, 2169#4460, #, 3500#4459, #, 2169#4464, 2169#4465, #, 3519#4464, #, 2169#4469, 2169#4470, #, 3524#4469, #, 2169#4474, 2169#4475, #, 3514#4474, #, 2169#4479, 2169#4480, #, 3541#4479, #, 2169#4484, 2169#4485, #, 3546#4484, #, 2169#4489, 2169#4490, #, 3533#4489, #, 2169#4494, 2169#4495, #, 3532#4494, 2169#4498, 2169#4499, #, 3528#4498, 2169#4502, 2169#4503, #, 3563#4502, #, 2169#4507, 2169#4508, #, 3568#4507, #, 2169#4512, 2169#4513, #, 3555#4512, #, 2169#4517, 2169#4518, #, 3554#4517, 2169#4521, 2169#4522, #, 3550#4521, #, 2169#4526, 2169#4527, #, 3585#4526, #, 2169#4531, 2169#4532, #, 3590#4531, #, 2169#4536, 2169#4537, #, 3580#4536, #, 2169#4541, 2169#4542, #, 3635#4541, #, 2169#4546, 2169#4547, #, 3642#4546, #, 2169#4551, 2169#4552, #, 3594#4551, 2169#4555, 2169#4556, #, 3615#4555, #, 2169#4560, 2169#4561, #, 3620#4560, #, 2169#4565, 2169#4566, #, 3609#4565, #, 2169#4570, 2169#4571, #, 3604#4570, 2169#4574, 2169#4575, #, 3598#4574, #, #, 2169#4580, 2169#4581, #, 3629#4580, #, 2169#4585, 2169#4586, #, 3634#4585, #, 2169#4590, 2169#4591, #, 3624#4590, #, #, 2169#4596, 2169#4597, #, 3659#4596, #, 2169#4601, 2169#4602, #, 3664#4601, #, 2169#4606, 2169#4607, #, 3646#4606, 2169#4610, 2169#4611, #, 3651#4610, #, #, 2169#4616, 2169#4617, #, 3650#4616, #, #, #, 2169#4623, 2169#4624, #, 3672#4623, #, #, 6#4626, #, 6#4628, #, 6#4630, #, 6#4632, 2#4635, #, 4635#4637, #, 4635#4639, #, #4635, 4635#4642, 4643#4639, #4637, 4635#4643, 4635#4646, 4647#4639, #4637, 4635#4647, #, 4635#4651, #, #, #, #, #, #, #, 4651#4661, #, 4661#4659, #, 4651#4665, #, 4665#4663, #, #, 4665#4666, 4651#4671, #, 4671#4669, #, #, 4671#4672, 4651#4676, 4676#4677, #, #, #, 4651#4678, 4678#4681, #, #, 4661#4682, 4651#4686, 4651#4687, #, 4678#4686, 4651#4691, 4651#4690, 4661#4691, #, #, 4651#4695, 4651#4696, #, 4676#4695, #, 4651#4700, 4651#4701, #, 4671#4700, 4651#4704, 4651#4705, #, 4665#4704, #, #, 4635#4709, #, #, 4712#4710, #, #, 4715#4713, #, #, 4718#4716, #, #, 4721#4719, #, #, 4724#4722, #, #, 4727#4725, #, #, 4730#4728, #, #, 4733#4731, #, #, #, 4738#4734, 4738#4735, #, #, #, 4743#4739, 4743#4740, #, #, #, 4758#4712, 4758#4715, 4758#4718, 4758#4721, 4758#4724, 4758#4727, 4758#4730, 4758#4733, 4758#4738, 4758#4743, 4758#4744, 4758#4745, #, 4760#4758, #, 145#4760, 4743#4763, #, 4743#4765, #, 4743#4767, #, 4743#4769, #, #, 4635#4770, 4718#4773, #, 4718#4775, #, 4738#4777, #, 4738#4779, #, 4733#4781, #, 4733#4783, #, 4730#4785, #, 4730#4787, #, 4727#4789, #, 4727#4791, #, 4724#4793, #, 4724#4795, #, 4721#4797, #, 4721#4799, #, 4718#4801, #, 4738#4803, #, 4727#4805, #, 4724#4807, #, 4743#4809, #, 4743#4811, #, #, 6#4812, #4635, 2#4816, #, 4816#4818, #, 4818#4820, #, 4816#4822, #, 4822#4824, #, 4822#4826, #, 2070#4828, #, 14#4830, #, 4830#4832, #, 4832#, 4832#4835, #, 4835#, 4822#4838, #, 4822#4840, #, #4822, 4822#4843, #, 4832#4845, #, 4832#4847, #, #, #, 4851#, #, 4856#4848, 4856#4849, 4856#4851, 4856#, #, 4858#4856, #, 14#4858, 4816#4861, #, 4861#4863, #, 4861#4865, #, #4858, 4868#, #, #, #, 4875#, 4875#4868, 4875#4869, 4875#4870, #, 4877#4875, #, 14#4877, 4861#4880, #, 4816#4882, #, 4882#4884, #, 4882#4886, #, 4882#4888, #, 4843#4890, #, 4843#4892, #, 2#4894, #, 4894#4896, #, 4894#4898, #, 14#4900, #, 4900#4902, #, 4902#4904, #, 4904#4906, #, 4904#4908, #, 4904#4910, #, 4906#4912, #, 4906#4914, #, 4906#4916, #, #, 4906#4917, #, 4906#4919, 4908#4922, #, 2#4924, #, 4924#4926, #, 4926#4928, #, 4926#4930, #, 4930#4932, #, 4932#4934, #, #4924, #, 4938#4936, #, 4894#4940, #, 4934#4942, #, 4942#4944, #, 4942#4946, #, 4942#4948, #, 4942#4950, #, 4930#4952, #, 4932#4954, #, 4954#4956, #, 4956#4958, #, 4958#4960, #, 4958#4962, #, 4958#4964, #, 4898#4940, 4898#4940, 4898#4940, 4898#4940, 4898#4940, 4898#4940, 4898#4940, 4898#4940, 4898#4940, 4898#4940, 4898#4940, 4898#4940, 4898#4940, 4898#4940, 4962#4980, #, 4898#4940, 4898#4940, 4898#4940, 4898#4940, 4898#4940, #4924, 4898#4940, 4898#4940, 4898#4940, 4898#4940, 4898#4940, 4898#4940, 4898#4940, 4898#4940, 4898#4940, 4898#4940, 4898#4940, 4898#4940, 4898#4940, 4898#4940, 4898#4940, 4898#4940, 4958#5004, #, 4898#4940, 4898#4940, 4898#4940, 4898#4940, 4898#4940, 4898#4940, 4898#4940, 4898#4940, 4898#4940, 4898#4940, 4898#4940, 4898#4940, 4942#5018, #, 4898#4940, 4898#4940, 4898#4940, 4898#4940, 4898#4940, 4898#4940, 4898#4940, 4898#4940, #, #, #, #, 5032#5030, #, #, 5038#5028, 5038#5029, 5038#5032, 5038#5033, #, 5040#5038, #, 5042#5040, #, #, #, 5047#5043, 5047#5044, #, 5049#5047, #, 5052#5042, 5052#5049, #, 5055#5027, 5055#5052, #, #, 5059#5055, 5059#5056, #, 4924#5059, 4894#5062, #, #4924, #, 5066#5064, #, 4930#5068, #, 5068#5070, #, 5068#5072, #, 5070#5074, #, #5076, #, 4948#5078, #, 4942#5080, #, 5080#5082, #, #, 4940#5083, 5083#5086, 5087#, #, 5083#5087, 5083#5090, 5091#, #, 5083#5091, 5083#5094, 5095#, #, 5083#5095, 5083#5098, 5100#, 5083#5100, #, 5083#5102, 5104#, 5083#5104, #, #, #, #, #, #, 5115#5105, 5115#5106, 5115#5107, 5115#5108, 5115#5109, #, #, #, #, #, 5124#5116, 5124#5117, 5124#5118, 5124#5119, #, #, #, #, #, 5133#5125, 5133#5126, 5133#5127, 5133#5128, #, #, #, #, #, #, 5144#5134, 5144#5135, 5144#5136, 5144#5137, 5144#5138, #, #, #, #, #, 5153#5145, 5153#5146, 5153#5147, 5153#5148, #, 5159#5115, 5159#5124, 5159#5133, 5159#5144, 5159#5153, #, #, 5162#5160, #, 5164#5162, #, 5167#5159, 5167#5164, #, 4930#5167, 5074#5170, #, 5072#5172, #, 5172#5174, #, #, 5181#5175, #, 5181#5177, 5181#5180, 5181#, #, #, 5188#5182, #, 5188#5184, 5188#5187, 5188#, #, #, 5195#5189, #, 5195#5191, 5195#5194, 5195#, #, #, 5202#5196, #, 5202#5198, 5202#5201, 5202#, #, #, 5209#5203, #, 5209#5205, 5209#5208, 5209#, #, #, 5216#5210, #, 5216#5212, 5216#5215, 5216#, #, #, 5223#5217, #, 5223#5219, 5223#5222, 5223#, #, #, 5230#5224, #, 5230#5226, 5230#5229, 5230#, #, #, 5237#5231, #, 5237#5233, 5237#5236, 5237#, #, #, 5244#5238, #, 5244#5240, 5244#5243, 5244#, #, #, 5251#5245, #, 5251#5247, 5251#5250, 5251#, #, #, 5258#5252, #, 5258#5254, 5258#5257, 5258#, #, #, 5261#5259, #, 5072#5261, #4924, #, 5266#5264, #, 5072#5266, #, 5062#5268, 5268#5271, 5273#, 5268#5273, #, 5268#5275, 5277#, 5268#5277, #, 5268#5279, 5281#, 5268#5281, #, 5268#5283, 5285#, 5268#5285, #, 5268#5287, 5289#, 5268#5289, #, 5268#5291, 5293#, 5268#5293, #, 5268#5295, 5297#, 5268#5297, #, 5268#5299, 5281#5285, 5268#5301, 5277#5289, 5268#5303, 5273#5293, 5268#5305, 5293#5297, 5314#5308, 5314#5309, #, 5314#5308, #, 5314#5310, 5329#5314, 5062#5314, #, #, 5329#5315, #, 5329#5317, #, 5329#5319, #, 5329#5321, 5329#5324, 5329#, 5329#5327, 5329#5328, #, 5329#5327, #, 5062#5329, 5339#5333, 5339#5334, #, 5339#5333, #, 5339#5335, 5354#5339, 5062#5339, #, #, 5354#5340, #, 5354#5342, #, 5354#5344, #, 5354#5346, 5354#5349, 5354#, 5354#5352, 5354#5353, #, 5354#5352, #, 5062#5354, 5364#5358, 5364#5359, #, 5364#5358, #, 5364#5360, 5379#5364, 5062#5364, #, #, 5379#5365, #, 5379#5367, #, 5379#5369, #, 5379#5371, 5379#5374, 5379#, 5379#5377, 5379#5378, #, 5379#5377, #, 5062#5379, 5297#5384, 5387#5385, 5387#5386, 5297#5387, #, 5387#5385, #, 5062#5387, 5397#5391, 5397#5392, #, 5397#5391, #, 5397#5393, 5412#5397, 5062#5397, #, #, 5412#5398, #, 5412#5400, #, 5412#5402, #, 5412#5404, 5412#5407, 5412#, 5412#5410, 5412#5411, #, 5412#5410, #, 5062#5412, 5293#5417, 5420#5418, 5420#5419, 5293#5420, #, 5420#5418, #, 5062#5420, 5430#5424, 5430#5425, #, 5430#5424, #, 5430#5426, 5445#5430, 5062#5430, #, #, 5445#5431, #, 5445#5433, #, 5445#5435, #, 5445#5437, 5445#5440, 5445#, 5445#5443, 5445#5444, #, 5445#5443, #, 5062#5445, 5289#5450, 5453#5451, 5453#5452, 5289#5453, #, 5453#5451, #, 5062#5453, 5463#5457, 5463#5458, #, 5463#5457, #, 5463#5459, 5478#5463, 5062#5463, #, #, 5478#5464, #, 5478#5466, #, 5478#5468, #, 5478#5470, 5478#5473, 5478#, 5478#5476, 5478#5477, #, 5478#5476, #, 5062#5478, 5285#5483, 5486#5484, 5486#5485, 5285#5486, #, 5486#5484, #, 5062#5486, 5496#5490, 5496#5491, #, 5496#5490, #, 5496#5492, 5511#5496, 5062#5496, #, #, 5511#5497, #, 5511#5499, #, 5511#5501, #, 5511#5503, 5511#5506, 5511#, 5511#5509, 5511#5510, #, 5511#5509, #, 5062#5511, 5281#5516, 5519#5517, 5519#5518, 5281#5519, #, 5519#5517, #, 5062#5519, 5529#5523, 5529#5524, #, 5529#5523, #, 5529#5525, 5544#5529, 5062#5529, #, #, 5544#5530, #, 5544#5532, #, 5544#5534, #, 5544#5536, 5544#5539, 5544#, 5544#5542, 5544#5543, #, 5544#5542, #, 5062#5544, 5277#5549, 5552#5550, 5552#5551, 5277#5552, #, 5552#5550, #, 5062#5552, 5562#5556, 5562#5557, #, 5562#5556, #, 5562#5558, 5577#5562, 5062#5562, #, #, 5577#5563, #, 5577#5565, #, 5577#5567, #, 5577#5569, 5577#5572, 5577#, 5577#5575, 5577#5576, #, 5577#5575, #, 5062#5577, 5273#5582, 5585#5583, 5585#5584, 5273#5585, #, 5585#5583, #, 5062#5585, 5595#5589, 5595#5590, #, 5595#5589, #, 5595#5591, 5610#5595, 5062#5595, #, #, 5610#5596, #, 5610#5598, #, 5610#5600, #, 5610#5602, 5610#5605, 5610#, 5610#5608, 5610#5609, #, 5610#5608, #, 5062#5610, #, 5618#5612, #, 5618#5614, 5618#5617, 5618#, 5354#5412, 5062#5618, #, 5626#5620, #, 5626#5622, 5626#5625, 5626#, 5354#5387, 5062#5626, #, 5634#5628, #, 5634#5630, 5634#5633, 5634#, 5354#5445, 5062#5634, #, 5642#5636, #, 5642#5638, 5642#5641, 5642#, 5354#5420, 5062#5642, #, 5650#5644, #, 5650#5646, 5650#5649, 5650#, 5354#5610, 5062#5650, #, 5658#5652, #, 5658#5654, 5658#5657, 5658#, 5354#5585, 5062#5658, #, 5666#5660, #, 5666#5662, 5666#5665, 5666#, 5354#5379, 5062#5666, #, 5674#5668, #, 5674#5670, 5674#5673, 5674#, 5387#5412, 5062#5674, #, 5682#5676, #, 5682#5678, 5682#5681, 5682#, 5420#5445, 5062#5682, #, 5690#5684, #, 5690#5686, 5690#5689, 5690#, 5445#5478, 5062#5690, #, 5698#5692, #, 5698#5694, 5698#5697, 5698#, 5445#5453, 5062#5698, #, 5706#5700, #, 5706#5702, 5706#5705, 5706#, 5445#5577, 5062#5706, #, 5714#5708, #, 5714#5710, 5714#5713, 5714#, 5445#5552, 5062#5714, #, 5722#5716, #, 5722#5718, 5722#5721, 5722#, 5453#5478, 5062#5722, #, 5730#5724, #, 5730#5726, 5730#5729, 5730#, 5478#5511, 5062#5730, #, 5738#5732, #, 5738#5734, 5738#5737, 5738#, 5478#5486, 5062#5738, #, 5746#5740, #, 5746#5742, 5746#5745, 5746#, 5478#5544, 5062#5746, #, 5754#5748, #, 5754#5750, 5754#5753, 5754#, 5478#5519, 5062#5754, #, 5762#5756, #, 5762#5758, 5762#5761, 5762#, 5486#5511, 5062#5762, #, 5770#5764, #, 5770#5766, 5770#5769, 5770#, 5519#5544, 5062#5770, #, 5778#5772, #, 5778#5774, 5778#5777, 5778#, 5552#5577, 5062#5778, #, 5786#5780, #, 5786#5782, 5786#5785, 5786#, 5585#5610, 5062#5786, 4894#5789, #, del#4868, del#4868, del#4868, del#4868, 4869#5795, #, del#4868, del#4868, del#4868, #, #, #, #, #, #, 5810#5800, 5810#5801, 5810#5802, 5810#5803, 5810#5804, #, 5812#5810, #, #, #, 5816#5814, #, #, #, 5823#5813, 5823#5816, 5823#5817, 5823#5818, #, 5825#5823, #, 5827#5825, #, 5830#5812, 5830#5827, #, #, 5834#5830, 5834#5831, #, 5837#5799, 5837#5834, #, 4924#5837, 2#5840, #, 5840#5842, #, 5840#5844, #, 5840#5846, #, #4924, del#5847, del#5852, del#5851, #, 5855#5851, del#5856, del#5855, #, del#5855, del#5846, del#5846, del#5846, del#5846, del#5846, del#5846, del#5846, del#5846, 5042#5866, #, 5042#5868, #, 5042#5870, #, del#5846, #, del#5846, #, #, del#5846, #, #, del#5846, #, #, #, del#5846, #, #, #, del#5846, #, #, #, del#5846, #, #, #, #, #, del#5846, #, #, #, #, #, del#5846, #, #, #, #, #, del#5846, #, #, #, #, #, 5870#5916, #, del#5846, #, #, #, #, #, #, #, #, 5929#5923, 5929#5924, 5929#5925, #, 5042#5929, 5868#5932, #, del#5846, del#5846, del#5846, del#5846, del#5846, del#5846, #, del#5846, #, #, #, del#5846, #, #, #, del#5846, #, #, #, del#5846, #, 5955#5953, #, 5042#5955, del#5846, #, #, #, #, del#5846, #, del#4868, del#5846, #, 5846#5966, #, 5846#5968, 5968#5971, 5974#6002, 5968#5973, 5974#, #, 5968#5974, 5968#5977, 5980#5984, 5968#5979, 5980#, #, 5968#5980, 5984#, 5968#5982, #del, 5968#5984, 5968#5987, 6002#5980, 5968#5989, 5993#5996, 5968#5991, 5993#, 5968#5993, #, 5996#, 5968#5994, #del, 5968#5996, 5968#5999, 6002#5993, 6002#, 5968#6000, #del, 5968#6002, 5968#6005, 6008#5974, 6008#, 5968#6006, #del, 5968#6008, 6008#, 5968#6010, #, #, #, #, 6018#6015, 5966#6018, 5966#, 6022#6014, 6022#6014, 6015#6022, 6015#, #, #, #, #, #, 6030#6027, 6014#6030, 6014#, 6034#6026, 6034#6026, 6027#6034, 6027#, #, 6038#6035, 6026#6038, 6026#, 6034#6025, 6034#6024, 6044#6023, 6044#6023, 6024#6044, 6024#, #, 6048#6045, 6023#6048, 6023#, 6022#6013, 6022#6012, 
### 内容
#0, 24:
文档\计算机问题\编程语言parser.ftxt
## end
#2, 486:
+[返回目录](,parser)
地址::文档\计算机问题\编程语言parser.ftxt

操作:...
+[设置动词](,操作)
名词:...
+[设置名词](,名词)
工具库:...
+[新建阅读窗口](,操作)
+[新建阅读窗口](,名词)
+[新建阅读窗口](,工具库)



Nini, 打开公式分析器(文件)
Nini, 导入PPT的库
Nini, 导入图形库的库. Nini, 导入平面测绘的库

Nini, 打开名词(库)
Nini, 打开核心(文件)
Nini, 打开JS编译器(文件)


parser集合:...
python parser:...
+[新建阅读窗口](,parser集合)
时间间隔测试:...
+[新建阅读窗口](,时间间隔测试)
(在只使用[程序]和[while]的情况下, 时间间隔依旧在增加, 所以这个问题恐怕无法解决)
(所以我改成用python在做parser了)
结构示意图:...
+[新建阅读窗口](,结构示意图)
debug:...

生成代码:...
测试代码:...
+[新建阅读窗口](,生成代码)



## end
#3, 50:
parser:...
创建于 20210805

节点数目统计::
+[设置结构](,节点数目统计)
## end
#7, 2:
61
## end
#10, 78:
+[返回目录](,python parser)

我想把程序的控制程序弄出来, 暂时不弄很细节的结构. 

测试:...
+[新建阅读窗口](,测试)



## end
#12, 17:
文档\S应用\公式分析器.ftxt
## end
#14, 867:
+[返回目录](,名词)

增加缩进:...
缩进:...
匹配模式_编程:...
+[del](,匹配模式)
+[修改标题]"匹配模式_编程"(,匹配模式)
匹配模式的"匹配模式"替换为"匹配模式_编程"
模块结尾:...
显示code:...
模块结尾的"运算"替换为"模块结尾"
+[新建阅读窗口](,匹配模式)


python程序_代码:...
C程序_代码:...
M程序_代码:...
JS程序_代码:...
将条目"C程序_代码"复制为条目"JS程序_代码"
+[新建阅读窗口](,python程序_代码)
+[新建阅读窗口](,C程序_代码)
+[新建阅读窗口](,M程序_代码)


python程序:[程序]...
程序:(( *n)[语句]\n)|[结束][程序]...
语句:[if]|[for]|[while]|[try]|[def]|[class]|[运算]|[空格]...
语句的"_语句"替换为"结构"

def:def [变量]\([输入]\):\n[程序]...
class:class [变量]\([输入]\):\n[程序]...
try:try:\n[程序]except([条件]):[程序]...
while:while [条件]:\n[程序]...
class的"def"替换为"class"
模块结尾的"匹配模式"替换为"匹配模式_编程"

for:for [变量] in [范围]:\n[程序]...
for的"if"替换为"for"
+[新建阅读窗口](,try)

if:if [条件]:\n[程序][else]?...
输入:[变量],?[输入]?...
+[新建阅读窗口](,if)

运算:~[\s\t\n]+\n...
+[新建阅读窗口](,if)

空格:[\s\t]*\n...
变量:[\w_\d]+...
条件:~:*...
范围:[条件]...


简单结构:...
+[复制结构](,简单结构)

观察代码结构:...
+[新建阅读窗口](,观察代码结构)


## end
#16, 246:
"""
+[返回目录](,python程序)

"""

+python程序(_程序,)->+[.]"code"([python],_程序)...
->[python]"
import re
text=code
i=0
state=True
"(Python,)->+缩进->[程序](+结构,+缩进)...
    ->的([程序],块#0)->+起点(,块#0)->+的(+结构,+起点)...

->[记录结构](+结构,)->[m_text]([记录结构],+python程序)



## end
#18, 248:
"""
+[返回目录](,程序)
P代码(P函数):...

"""
+程序(结构,缩进)...

->+模块"程序"...
->+块(+程序,)->+的(+程序,+块)->+的(结构,+块)...

=>块(+程序,)=>[]:
    ->+的([语句],块)->[语句](结构,缩进)...
        ->+块(+程序,)->+然后(块,+块)...
        ->+的(结构,+块)->+的(结构,+然后),
    ->+eof->[m_name](+eof,块)





## end
#20, 506:
"""
+[返回目录](,语句)
P代码(P函数):...
+[新建阅读窗口](,P代码)

"""
+语句(结构,缩进)->的(+语句,块)...
->的(语句,P代码)...

->+[.]"sp"([python],缩进)->+[code]([python],P代码)...
->[python](Python,+语句):
    ->[==]"if"(,+语句)->+的([if],块)->[if](结构,缩进),
    ->[==]"while"(,+语句)->+的([while],块)->[while](结构,缩进),
    ->[==]"for"(,+语句)->+的([for],块)->[for](结构,缩进),
    ->[==]"try"(,+语句)->+的([try],块)->[try](结构,缩进),
    ->[==]"def"(,+语句)->+的([def],块)->[def](结构,缩进),
    ->[==]"class"(,+语句)->+的([class],块)->[class](结构,缩进),
    ->+的([运算],块)->[运算](结构,缩进)



## end
#22, 278:
"""
+[返回目录](,def)

"""
+def#0(结构,缩进)...
->+模块"def"...

->[缩进](缩进,)...
->[匹配模式_编程]"def "(,+模块)->[条件](结构,缩进)...
->[匹配模式_编程]":[\n\s\t]*\n"(,+模块)...
    ->[增加缩进](缩进,+缩进)->[程序](结构,+缩进)...

->的(+def#0,块#0)->的([程序],块#f)...
    ->+func(块#0,块#f)->[m_text]([条件],+func)...
->+的(结构,+func)


## end
#24, 291:
"""
+[返回目录](,class)

"""
+class#0(结构,缩进)...
->+模块"class"...

->[缩进](缩进,)...
->[匹配模式_编程]"class "(,+模块)->[条件](结构,缩进)...
->[匹配模式_编程]":[\n\s\t]*\n"(,+模块)...
    ->[增加缩进](缩进,+缩进)->[程序](结构,+缩进)...

->的(+class#0,块#0)->的([程序],块#c)...
    ->+class(块#0,块#c)->[m_text]([条件],+class)...
->+的(结构,+class)


## end
#26, 341:
"""
+[返回目录](,try)

"""
+try#0(结构,缩进)...
->+模块"try"...

->[缩进](缩进,)...
->[匹配模式_编程]"try:[\n\s\t]*\n"(,+模块)...
    ->[增加缩进](缩进,+缩进)->[程序]#t(结构,+缩进)...
->[缩进](缩进,)...
    ->[匹配模式_编程]"except:\s*\n"(,+模块)->[程序]#e(结构,+缩进)...

->的(+try#0,块#0)->的([程序]#t,块#t)->的([程序]#e,块#e)...
    ->+try(块#0,块#t)->+except(+try,块#e)...
->+的(结构,+try)->+的(结构,+except)


## end
#28, 291:
"""
+[返回目录](,while)

"""
+while#0(结构,缩进)...
->+模块"while"...

->[缩进](缩进,)...
->[匹配模式_编程]"while "(,+模块)->[条件](结构,缩进)...
->[匹配模式_编程]":[\n\s\t]*\n"(,+模块)...
    ->[增加缩进](缩进,+缩进)->[程序](结构,+缩进)...

->的(+while#0,块#0)->的([程序],块#c)...
    ->+while(块#0,块#c)->[m_text]([条件],+while)...
->+的(结构,+while)


## end
#30, 363:
"""
+[返回目录](,for)

"""
+for#0(结构,缩进)...
->+模块"for"...

->[缩进](缩进,)...
->[匹配模式_编程]"for "(,+模块)->[变量](结构,缩进)...
->[匹配模式_编程]" in "(,+模块)->[条件](结构,缩进)...
->[匹配模式_编程]":[\n\s\t]*\n"(,+模块)...
->[增加缩进](缩进,+缩进)->[程序](结构,+缩进)...

->的(+for#0,块#0)->的([程序],块#c)...
    ->+for(块#0,块#c)->[m_text]([条件],+for)...
    ->+变量(+for,)->[m_text]([变量],+变量)...
->+的(结构,+for)->+的(结构,+变量)


## end
#32, 823:
"""
+[返回目录](,if)

"""
+if#0(结构,缩进)...
->+模块"if"...

->[缩进](缩进,)...
->[匹配模式_编程]"if "(,+模块)->[条件](结构,缩进)...
->[匹配模式_编程]":[\n\s\t]*\n"(,+模块)...
->[增加缩进](缩进,+缩进)->[程序](结构,+缩进)...

->的(+if#0,块#0)->的([程序],块#c)...
    ->+if(块#0,块#c)->[m_text]([条件],+if)...
->+的(结构,+if)...

->+模块#21"elif_1"...
->+模块#2"elif"...
->+模块#22"elif_2"...
->[]{
    +elif(+if#0,+if)=>elif(+if#0,_cond)->_cond=>[]:
    ->+elif(+if#0,+elif#1)->[缩进](缩进,)...
        ->[匹配模式_编程]"elif "(,+模块#2)->[条件](结构,缩进)...
        ->[匹配模式_编程]":\s*\n"(,+模块#22)->[程序](结构,+缩进)...
    ->的([程序],块#ci)...
        ->+elif#1(_cond,块#ci)->[m_text]([条件],+elif#1)...
    ->+的(结构,+elif#1),

    ->[]
}...

->+模块#3"else"...
->[]{
    []:->[缩进](缩进,)...
        ->[匹配模式_编程]"else:\s*\n"(,+模块#3)->[程序](结构,+缩进)...
    ->的([程序],块#ce)...
        ->+else(+if,块#ce)->+的(结构,+else),

    ->[]
}



## end
#34, 160:
"""
+[返回目录](,输入)

"""
+输入(_输入,):
->+的(_输入,+变量)...

->[变量]->[m_text]([变量],+变量)->[]{
    []:->[匹配模式_编程]", *"->[]{
        []:->[输入](_输入,),->[]
    },->[]
},->[]


## end
#36, 182:
"""
+[返回目录](,运算)
P代码:...

保存:...

"""
+运算(结构,缩进)...
->的(运算,P代码)...

->+[s]"sp_op"([python],缩进)...
->+[code]([python],P代码)->[python](Python,+代码)...

->的(+运算,块#0)->[m_text](+代码,块#0)



## end
#38, 49:
"""
+[返回目录](,空格)

"""
+空格->[匹配模式_编程]"[\s\t]*\n"


## end
#40, 107:
"""
+[返回目录](,变量)

"""
+变量(结构,缩进)...
->+模块"变量"...
    ->[匹配模式_编程]"[\w_\d]+"(,+模块)->[m_text]([匹配模式_编程],+变量)


## end
#42, 105:
"""
+[返回目录](,条件)

"""
+条件(结构,缩进)...
->+模块"条件"...
    ->[匹配模式_编程]"[^:]*"(,+模块)->[m_text]([匹配模式_编程],+条件)



## end
#44, 53:
"""
+[返回目录](,范围)

"""
+范围->[条件]->[m_text]([条件],+范围)


## end
#46, 268:
"""
+[返回目录](,匹配模式_编程)
P代码(P函数):...

"""

+匹配模式_编程(,_模块)...
->的(匹配模式_编程,P代码)...

->+[s]"pat"([python],+匹配模式_编程)->+[.]"block"([python],_模块)...

->+[o]"output_txt"([python],+匹配模式_编程)...
->+序号"-1"->+[o]"n"([python],+序号)...

->+[code]([python],P代码)->[python](Python,+不终止)


## end
#48, 203:
"""
+[返回目录](,缩进)

P代码(P函数):...
保存:...
Nini, 打开动词(库)

"""

+缩进(缩进,)...
->的(缩进#0,P代码)...

->+序号"-1"(,)...
->+[o]"n"([python],+序号)->+[s]"sp"([python],缩进)...

->+[code]([python],P代码)->[python](Python,+不终止)


## end
#50, 511:
+[返回目录](,测试)
Nini, 打开公式分析器(文件)

问题测试::
[m_name]"????"(代码,问题测试)
+[设置结构](,测试)

代码:...
保存:...
保存2:...
+[新建阅读窗口](,代码)
+[python]"
text=re.sub('#.*\n','\n',text)
text=re.sub('\n[\s\t\n]*\n','\n',text)
"(Python,)->+[o]"text"(+[python],代码)


输出结构:...
+[设置结构](,输出结构)
+[删除结构](,输出结构)
+[导入节点](,输出结构)->[m_text](输出结构,+[导入节点])
+[显示星图](,输出结构)

结构场景:...
+[新建阅读窗口](,结构场景)
[python程序_代码](代码,)...
->+[修改内容](,输出结构)->[m_text]([python程序_代码],+[修改内容])
+[删除结构](,结构场景)->+[导入节点](,结构场景)->[m_text](输出结构,+[导入节点])
+[显示星图]"1"(,结构场景)

测试语句:...



## end
#52, 6062:
import sys
import re
if __name__=='__main__':
    sys.path.append(sys.path[0]+'\\..')
from body.bone import NetP
change=True
class Karma():
    def Reason_oneStep(self,pool):
        list_new=[]
        areaType=self.areaType()
        change=False
        if self.m_stage==0:
            if self.m_cause!=None:
                if self in self.m_cause.m_clause:
                    if self.m_cause.m_stage==2:
                        self.m_stage=1
                        change=True
        if self.m_stage==1:
            while True:
                if self.stateSelf()!='blue':
                    self.newMap(pool,areaType,list_new)
                else:
                    self.m_interp=False
                change=True
                if self.stateRelation()==False:
                    continue
                elif self.stateSelf()=='red':
                    continue
                elif self.stateSelf()=='yellow':
                    self.m_stage=5
                    if self.m_no==False:
                        self.m_reState='dark yellow'
                        return [change,list_new]
                    else:
                        self.m_reState='dark green'
                        return [change,list_new]
                elif self.stateSelf()=='blue':
                    self.m_stage=1
                    return [change,list_new]
                else:
                    self.m_stage=2
                    break
        if self.m_stage==2:
            if self.m_clause==[]:
                self.m_choose=True
                self.m_stage=3
                change=True
            else:
                self.m_choose=self.m_clauseAnd
                keep=False
            for clause in self.m_clause:
                if self.m_clauseAnd==True:
                    if clause.m_reState=='dark yellow':
                        self.m_choose=False
                        self.m_stage=3
                        change=True
                        self.m_clauseOut=True
                        break
                    elif clause.m_reState=='':
                        keep=True
                else:
                    if clause.m_reState=='dark green':
                        self.m_choose=True
                        self.m_stage=3
                        change=True
                        self.m_clauseOut=True
                        break
                    elif clause.m_reState=='':
                        keep=True
            if self.m_clause!=[] and keep==False:
                self.m_stage=3
                change=True
                self.m_clauseOut=True
        if self.m_stage==3:
            if self.m_choose==False:
                if self.m_noe==[]:
                    self.m_stage=1
                    change=True
                    return [change,list_new]
                i=self.m_eoi
                end=self.m_noe[i]
                if end.m_stage==0:
                    end.m_stage=1
                    change=True
                elif end.m_reState=='dark yellow':
                    if self.m_noAnd==True:
                        self.m_stage=1
                        change=True
                    else:
                        i+=1
                        change=True
                        if i==len(self.m_noe):
                            self.m_stage=1
                            self.m_eoi=0
                        else:
                            self.m_eoi=i
                elif end.m_reState=='dark green':
                    if self.m_noAnd!=True:
                        self.m_stage=4
                        change=True
                    else:
                        i+=1
                        change=True
                        if i==len(self.m_noe):
                            self.m_stage=4
                            self.m_eoi=0
                        else:
                            self.m_eoi=i
            else:
                if self.m_yese==[] and self.m_noe==[]:
                    self.m_stage=4
                    change=True
                elif self.m_yese==[]:
                    self.m_stage=1
                    change=True
                    return [change,list_new]
                else:
                    i=self.m_eoi
                    end=self.m_yese[i]
                    if end.m_stage==0:
                        end.m_stage=1
                        change=True
                    elif end.m_reState=='dark yellow':
                        if self.m_yesAnd==True:
                            self.m_stage=1
                            change=True
                        else:
                            i+=1
                            change=True
                            if i==len(self.m_yese):
                                self.m_stage=1
                                self.m_eoi=0
                            else:
                                self.m_eoi=i
                    elif end.m_reState=='dark green':
                        if self.m_yesAnd!=True:
                            self.m_stage=4
                            change=True
                        else:
                            i+=1
                            change=True
                            if i==len(self.m_yese):
                                self.m_stage=4
                                self.m_eoi=0
                            else:
                                self.m_eoi=i
        if self.m_stage==4:
            if self.m_clauseNew!=[] or self.m_clauseOut==True:
                self.m_clauseCollect=True
            if (self.m_buildMode==True or self.isFunctionPoint()==1) and self.m_map!=None and self.m_map not in list_new:
                list_new.append(self.m_map)
            self.m_stage=5
            if self.m_no==True:
                self.m_reState='dark yellow'
                change=True
                return [change,list_new]
            else:
                self.m_reState='dark green'
                change=True
                return [change,list_new]
        return [change,list_new]

## end
#53, 2:
82
## end
#58, 108:
"""
+[返回目录](,简单结构)

"""

+简单结构(_入口,_收集)->+的(_收集,_入口)...
=>的(_入口,_)=>+的(_收集,的)->[is](_关联,的)->[简单结构](_,_收集)



## end
#62, 11589:
起点#0""(,块#1)[-1,-1]
块#1"import sys
import re
"(,)[-1,-1]
块#2""(,)[-1,-1]
然后#3""(块#1,块#2)[-1,-1]
块#4"sys.path.append(sys.path[0]+'\\..')
"(,)[-1,-1]
if#5"__name__=='__main__'"(块#2,块#4)[-1,-1]
eof#6""(,)[-1,-1]
然后#7""(块#4,eof#6)[-1,-1]
块#8""(,)[-1,-1]
elif#9""(if#5,块#8)[-1,-1]
块#10"from body.bone import NetP
change=True
"(,)[-1,-1]
然后#11""(块#2,块#10)[-1,-1]
块#12""(,)[-1,-1]
然后#13""(块#10,块#12)[-1,-1]
块#14""(,)[-1,-1]
class#15"Karma()"(块#12,块#14)[-1,-1]
块#16"list_new=[]
areaType=self.areaType()
change=False
"(,)[-1,-1]
func#17"Reason_oneStep(self,pool)"(class#15,块#16)[-1,-1]
块#18""(,)[-1,-1]
然后#19""(块#16,块#18)[-1,-1]
块#20""(,)[-1,-1]
if#21"self.m_stage==0"(块#18,块#20)[-1,-1]
块#22""(,)[-1,-1]
if#23"self.m_cause!=None"(块#20,块#22)[-1,-1]
块#24""(,)[-1,-1]
if#25"self in self.m_cause.m_clause"(块#22,块#24)[-1,-1]
块#26"self.m_stage=1
change=True
"(,)[-1,-1]
if#27"self.m_cause.m_stage==2"(块#24,块#26)[-1,-1]
eof#28""(,)[-1,-1]
然后#29""(块#26,eof#28)[-1,-1]
块#30""(,)[-1,-1]
elif#31""(if#27,块#30)[-1,-1]
eof#32""(,)[-1,-1]
然后#33""(块#24,eof#32)[-1,-1]
块#34""(,)[-1,-1]
elif#35""(if#25,块#34)[-1,-1]
eof#36""(,)[-1,-1]
然后#37""(块#22,eof#36)[-1,-1]
块#38""(,)[-1,-1]
elif#39""(if#23,块#38)[-1,-1]
eof#40""(,)[-1,-1]
然后#41""(块#20,eof#40)[-1,-1]
块#42""(,)[-1,-1]
elif#43""(if#21,块#42)[-1,-1]
块#44""(,)[-1,-1]
然后#45""(块#18,块#44)[-1,-1]
块#46""(,)[-1,-1]
if#47"self.m_stage==1"(块#44,块#46)[-1,-1]
块#48""(,)[-1,-1]
while#49"True"(块#46,块#48)[-1,-1]
块#50"self.newMap(pool,areaType,list_new)
"(,)[-1,-1]
if#51"self.stateSelf()!='blue'"(块#48,块#50)[-1,-1]
eof#52""(,)[-1,-1]
然后#53""(块#50,eof#52)[-1,-1]
块#54""(,)[-1,-1]
elif#55""(if#51,块#54)[-1,-1]
块#56"self.m_interp=False
"(,)[-1,-1]
else#57""(if#51,块#56)[-1,-1]
eof#58""(,)[-1,-1]
然后#59""(块#56,eof#58)[-1,-1]
块#60"change=True
"(,)[-1,-1]
然后#61""(块#48,块#60)[-1,-1]
块#62""(,)[-1,-1]
然后#63""(块#60,块#62)[-1,-1]
块#64"continue
"(,)[-1,-1]
if#65"self.stateRelation()==False"(块#62,块#64)[-1,-1]
eof#66""(,)[-1,-1]
然后#67""(块#64,eof#66)[-1,-1]
块#68"continue
"(,)[-1,-1]
elif#69"self.stateSelf()=='red'"(if#65,块#68)[-1,-1]
eof#70""(,)[-1,-1]
然后#71""(块#68,eof#70)[-1,-1]
块#72"self.m_stage=5
"(,)[-1,-1]
elif#73"self.stateSelf()=='yellow'"(elif#69,块#72)[-1,-1]
块#74""(,)[-1,-1]
然后#75""(块#72,块#74)[-1,-1]
块#76"self.m_reState='dark yellow'
return [change,list_new]
"(,)[-1,-1]
if#77"self.m_no==False"(块#74,块#76)[-1,-1]
eof#78""(,)[-1,-1]
然后#79""(块#76,eof#78)[-1,-1]
块#80""(,)[-1,-1]
elif#81""(if#77,块#80)[-1,-1]
块#82"self.m_reState='dark green'
return [change,list_new]
"(,)[-1,-1]
else#83""(if#77,块#82)[-1,-1]
eof#84""(,)[-1,-1]
然后#85""(块#82,eof#84)[-1,-1]
eof#86""(,)[-1,-1]
然后#87""(块#74,eof#86)[-1,-1]
块#88"self.m_stage=1
return [change,list_new]
"(,)[-1,-1]
elif#89"self.stateSelf()=='blue'"(elif#73,块#88)[-1,-1]
eof#90""(,)[-1,-1]
然后#91""(块#88,eof#90)[-1,-1]
块#92""(,)[-1,-1]
elif#93""(elif#89,块#92)[-1,-1]
块#94"self.m_stage=2
break
"(,)[-1,-1]
else#95""(if#65,块#94)[-1,-1]
eof#96""(,)[-1,-1]
然后#97""(块#94,eof#96)[-1,-1]
eof#98""(,)[-1,-1]
然后#99""(块#62,eof#98)[-1,-1]
eof#100""(,)[-1,-1]
然后#101""(块#46,eof#100)[-1,-1]
块#102""(,)[-1,-1]
elif#103""(if#47,块#102)[-1,-1]
块#104""(,)[-1,-1]
然后#105""(块#44,块#104)[-1,-1]
块#106""(,)[-1,-1]
if#107"self.m_stage==2"(块#104,块#106)[-1,-1]
块#108"self.m_choose=True
self.m_stage=3
change=True
"(,)[-1,-1]
if#109"self.m_clause==[]"(块#106,块#108)[-1,-1]
eof#110""(,)[-1,-1]
然后#111""(块#108,eof#110)[-1,-1]
块#112""(,)[-1,-1]
elif#113""(if#109,块#112)[-1,-1]
块#114"self.m_choose=self.m_clauseAnd
keep=False
"(,)[-1,-1]
else#115""(if#109,块#114)[-1,-1]
eof#116""(,)[-1,-1]
然后#117""(块#114,eof#116)[-1,-1]
块#118""(,)[-1,-1]
然后#119""(块#106,块#118)[-1,-1]
块#120""(,)[-1,-1]
for#121"self.m_clause"(块#118,块#120)[-1,-1]
变量#122"clause"(for#121,)[-1,-1]
块#123""(,)[-1,-1]
if#124"self.m_clauseAnd==True"(块#120,块#123)[-1,-1]
块#125"self.m_choose=False
self.m_stage=3
change=True
self.m_clauseOut=True
break
"(,)[-1,-1]
if#126"clause.m_reState=='dark yellow'"(块#123,块#125)[-1,-1]
eof#127""(,)[-1,-1]
然后#128""(块#125,eof#127)[-1,-1]
块#129"keep=True
"(,)[-1,-1]
elif#130"clause.m_reState==''"(if#126,块#129)[-1,-1]
eof#131""(,)[-1,-1]
然后#132""(块#129,eof#131)[-1,-1]
块#133""(,)[-1,-1]
elif#134""(elif#130,块#133)[-1,-1]
eof#135""(,)[-1,-1]
然后#136""(块#123,eof#135)[-1,-1]
块#137""(,)[-1,-1]
elif#138""(if#124,块#137)[-1,-1]
块#139""(,)[-1,-1]
else#140""(if#124,块#139)[-1,-1]
块#141"self.m_choose=True
self.m_stage=3
change=True
self.m_clauseOut=True
break
"(,)[-1,-1]
if#142"clause.m_reState=='dark green'"(块#139,块#141)[-1,-1]
eof#143""(,)[-1,-1]
然后#144""(块#141,eof#143)[-1,-1]
块#145"keep=True
"(,)[-1,-1]
elif#146"clause.m_reState==''"(if#142,块#145)[-1,-1]
eof#147""(,)[-1,-1]
然后#148""(块#145,eof#147)[-1,-1]
块#149""(,)[-1,-1]
elif#150""(elif#146,块#149)[-1,-1]
eof#151""(,)[-1,-1]
然后#152""(块#139,eof#151)[-1,-1]
eof#153""(,)[-1,-1]
然后#154""(块#120,eof#153)[-1,-1]
块#155""(,)[-1,-1]
然后#156""(块#118,块#155)[-1,-1]
块#157"self.m_stage=3
change=True
self.m_clauseOut=True
"(,)[-1,-1]
if#158"self.m_clause!=[] and keep==False"(块#155,块#157)[-1,-1]
eof#159""(,)[-1,-1]
然后#160""(块#157,eof#159)[-1,-1]
块#161""(,)[-1,-1]
elif#162""(if#158,块#161)[-1,-1]
eof#163""(,)[-1,-1]
然后#164""(块#155,eof#163)[-1,-1]
块#165""(,)[-1,-1]
elif#166""(if#107,块#165)[-1,-1]
块#167""(,)[-1,-1]
然后#168""(块#104,块#167)[-1,-1]
块#169""(,)[-1,-1]
if#170"self.m_stage==3"(块#167,块#169)[-1,-1]
块#171""(,)[-1,-1]
if#172"self.m_choose==False"(块#169,块#171)[-1,-1]
块#173"self.m_stage=1
change=True
return [change,list_new]
"(,)[-1,-1]
if#174"self.m_noe==[]"(块#171,块#173)[-1,-1]
eof#175""(,)[-1,-1]
然后#176""(块#173,eof#175)[-1,-1]
块#177""(,)[-1,-1]
elif#178""(if#174,块#177)[-1,-1]
块#179"i=self.m_eoi
end=self.m_noe[i]
"(,)[-1,-1]
然后#180""(块#171,块#179)[-1,-1]
块#181""(,)[-1,-1]
然后#182""(块#179,块#181)[-1,-1]
块#183"end.m_stage=1
change=True
"(,)[-1,-1]
if#184"end.m_stage==0"(块#181,块#183)[-1,-1]
eof#185""(,)[-1,-1]
然后#186""(块#183,eof#185)[-1,-1]
块#187""(,)[-1,-1]
elif#188"end.m_reState=='dark yellow'"(if#184,块#187)[-1,-1]
块#189"self.m_stage=1
change=True
"(,)[-1,-1]
if#190"self.m_noAnd==True"(块#187,块#189)[-1,-1]
eof#191""(,)[-1,-1]
然后#192""(块#189,eof#191)[-1,-1]
块#193""(,)[-1,-1]
elif#194""(if#190,块#193)[-1,-1]
块#195"i+=1
change=True
"(,)[-1,-1]
else#196""(if#190,块#195)[-1,-1]
块#197""(,)[-1,-1]
然后#198""(块#195,块#197)[-1,-1]
块#199"self.m_stage=1
self.m_eoi=0
"(,)[-1,-1]
if#200"i==len(self.m_noe)"(块#197,块#199)[-1,-1]
eof#201""(,)[-1,-1]
然后#202""(块#199,eof#201)[-1,-1]
块#203""(,)[-1,-1]
elif#204""(if#200,块#203)[-1,-1]
块#205"self.m_eoi=i
"(,)[-1,-1]
else#206""(if#200,块#205)[-1,-1]
eof#207""(,)[-1,-1]
然后#208""(块#205,eof#207)[-1,-1]
eof#209""(,)[-1,-1]
然后#210""(块#197,eof#209)[-1,-1]
eof#211""(,)[-1,-1]
然后#212""(块#187,eof#211)[-1,-1]
块#213""(,)[-1,-1]
elif#214"end.m_reState=='dark green'"(elif#188,块#213)[-1,-1]
块#215"self.m_stage=4
change=True
"(,)[-1,-1]
if#216"self.m_noAnd!=True"(块#213,块#215)[-1,-1]
eof#217""(,)[-1,-1]
然后#218""(块#215,eof#217)[-1,-1]
块#219""(,)[-1,-1]
elif#220""(if#216,块#219)[-1,-1]
块#221"i+=1
change=True
"(,)[-1,-1]
else#222""(if#216,块#221)[-1,-1]
块#223""(,)[-1,-1]
然后#224""(块#221,块#223)[-1,-1]
块#225"self.m_stage=4
self.m_eoi=0
"(,)[-1,-1]
if#226"i==len(self.m_noe)"(块#223,块#225)[-1,-1]
eof#227""(,)[-1,-1]
然后#228""(块#225,eof#227)[-1,-1]
块#229""(,)[-1,-1]
elif#230""(if#226,块#229)[-1,-1]
块#231"self.m_eoi=i
"(,)[-1,-1]
else#232""(if#226,块#231)[-1,-1]
eof#233""(,)[-1,-1]
然后#234""(块#231,eof#233)[-1,-1]
eof#235""(,)[-1,-1]
然后#236""(块#223,eof#235)[-1,-1]
eof#237""(,)[-1,-1]
然后#238""(块#213,eof#237)[-1,-1]
块#239""(,)[-1,-1]
elif#240""(elif#214,块#239)[-1,-1]
eof#241""(,)[-1,-1]
然后#242""(块#181,eof#241)[-1,-1]
块#243""(,)[-1,-1]
elif#244""(if#172,块#243)[-1,-1]
块#245""(,)[-1,-1]
else#246""(if#172,块#245)[-1,-1]
块#247"self.m_stage=4
change=True
"(,)[-1,-1]
if#248"self.m_yese==[] and self.m_noe==[]"(块#245,块#247)[-1,-1]
eof#249""(,)[-1,-1]
然后#250""(块#247,eof#249)[-1,-1]
块#251"self.m_stage=1
change=True
return [change,list_new]
"(,)[-1,-1]
elif#252"self.m_yese==[]"(if#248,块#251)[-1,-1]
eof#253""(,)[-1,-1]
然后#254""(块#251,eof#253)[-1,-1]
块#255""(,)[-1,-1]
elif#256""(elif#252,块#255)[-1,-1]
块#257"i=self.m_eoi
end=self.m_yese[i]
"(,)[-1,-1]
else#258""(if#248,块#257)[-1,-1]
块#259""(,)[-1,-1]
然后#260""(块#257,块#259)[-1,-1]
块#261"end.m_stage=1
change=True
"(,)[-1,-1]
if#262"end.m_stage==0"(块#259,块#261)[-1,-1]
eof#263""(,)[-1,-1]
然后#264""(块#261,eof#263)[-1,-1]
块#265""(,)[-1,-1]
elif#266"end.m_reState=='dark yellow'"(if#262,块#265)[-1,-1]
块#267"self.m_stage=1
change=True
"(,)[-1,-1]
if#268"self.m_yesAnd==True"(块#265,块#267)[-1,-1]
eof#269""(,)[-1,-1]
然后#270""(块#267,eof#269)[-1,-1]
块#271""(,)[-1,-1]
elif#272""(if#268,块#271)[-1,-1]
块#273"i+=1
change=True
"(,)[-1,-1]
else#274""(if#268,块#273)[-1,-1]
块#275""(,)[-1,-1]
然后#276""(块#273,块#275)[-1,-1]
块#277"self.m_stage=1
self.m_eoi=0
"(,)[-1,-1]
if#278"i==len(self.m_yese)"(块#275,块#277)[-1,-1]
eof#279""(,)[-1,-1]
然后#280""(块#277,eof#279)[-1,-1]
块#281""(,)[-1,-1]
elif#282""(if#278,块#281)[-1,-1]
块#283"self.m_eoi=i
"(,)[-1,-1]
else#284""(if#278,块#283)[-1,-1]
eof#285""(,)[-1,-1]
然后#286""(块#283,eof#285)[-1,-1]
eof#287""(,)[-1,-1]
然后#288""(块#275,eof#287)[-1,-1]
eof#289""(,)[-1,-1]
然后#290""(块#265,eof#289)[-1,-1]
块#291""(,)[-1,-1]
elif#292"end.m_reState=='dark green'"(elif#266,块#291)[-1,-1]
块#293"self.m_stage=4
change=True
"(,)[-1,-1]
if#294"self.m_yesAnd!=True"(块#291,块#293)[-1,-1]
eof#295""(,)[-1,-1]
然后#296""(块#293,eof#295)[-1,-1]
块#297""(,)[-1,-1]
elif#298""(if#294,块#297)[-1,-1]
块#299"i+=1
change=True
"(,)[-1,-1]
else#300""(if#294,块#299)[-1,-1]
块#301""(,)[-1,-1]
然后#302""(块#299,块#301)[-1,-1]
块#303"self.m_stage=4
self.m_eoi=0
"(,)[-1,-1]
if#304"i==len(self.m_yese)"(块#301,块#303)[-1,-1]
eof#305""(,)[-1,-1]
然后#306""(块#303,eof#305)[-1,-1]
块#307""(,)[-1,-1]
elif#308""(if#304,块#307)[-1,-1]
块#309"self.m_eoi=i
"(,)[-1,-1]
else#310""(if#304,块#309)[-1,-1]
eof#311""(,)[-1,-1]
然后#312""(块#309,eof#311)[-1,-1]
eof#313""(,)[-1,-1]
然后#314""(块#301,eof#313)[-1,-1]
eof#315""(,)[-1,-1]
然后#316""(块#291,eof#315)[-1,-1]
块#317""(,)[-1,-1]
elif#318""(elif#292,块#317)[-1,-1]
eof#319""(,)[-1,-1]
然后#320""(块#259,eof#319)[-1,-1]
eof#321""(,)[-1,-1]
然后#322""(块#245,eof#321)[-1,-1]
eof#323""(,)[-1,-1]
然后#324""(块#169,eof#323)[-1,-1]
块#325""(,)[-1,-1]
elif#326""(if#170,块#325)[-1,-1]
块#327""(,)[-1,-1]
然后#328""(块#167,块#327)[-1,-1]
块#329""(,)[-1,-1]
if#330"self.m_stage==4"(块#327,块#329)[-1,-1]
块#331"self.m_clauseCollect=True
"(,)[-1,-1]
if#332"self.m_clauseNew!=[] or self.m_clauseOut==True"(块#329,块#331)[-1,-1]
eof#333""(,)[-1,-1]
然后#334""(块#331,eof#333)[-1,-1]
块#335""(,)[-1,-1]
elif#336""(if#332,块#335)[-1,-1]
块#337""(,)[-1,-1]
然后#338""(块#329,块#337)[-1,-1]
块#339"list_new.append(self.m_map)
"(,)[-1,-1]
if#340"(self.m_buildMode==True or self.isFunctionPoint()==1) and self.m_map!=None and self.m_map not in list_new"(块#337,块#339)[-1,-1]
eof#341""(,)[-1,-1]
然后#342""(块#339,eof#341)[-1,-1]
块#343""(,)[-1,-1]
elif#344""(if#340,块#343)[-1,-1]
块#345"self.m_stage=5
"(,)[-1,-1]
然后#346""(块#337,块#345)[-1,-1]
块#347""(,)[-1,-1]
然后#348""(块#345,块#347)[-1,-1]
块#349"self.m_reState='dark yellow'
change=True
return [change,list_new]
"(,)[-1,-1]
if#350"self.m_no==True"(块#347,块#349)[-1,-1]
eof#351""(,)[-1,-1]
然后#352""(块#349,eof#351)[-1,-1]
块#353""(,)[-1,-1]
elif#354""(if#350,块#353)[-1,-1]
块#355"self.m_reState='dark green'
change=True
return [change,list_new]
"(,)[-1,-1]
else#356""(if#350,块#355)[-1,-1]
eof#357""(,)[-1,-1]
然后#358""(块#355,eof#357)[-1,-1]
eof#359""(,)[-1,-1]
然后#360""(块#347,eof#359)[-1,-1]
块#361""(,)[-1,-1]
elif#362""(if#330,块#361)[-1,-1]
块#363"return [change,list_new]
"(,)[-1,-1]
然后#364""(块#327,块#363)[-1,-1]
eof#365""(,)[-1,-1]
然后#366""(块#363,eof#365)[-1,-1]
eof#367""(,)[-1,-1]
然后#368""(class#15,eof#367)[-1,-1]
eof#369""(,)[-1,-1]
然后#370""(块#12,eof#369)[-1,-1]

## end
#64, 13:
文档\S应用\星图.txt
## end
#70, 725:
"""
+[P函数](,P代码)

测试:...
保存:...
保存2:...
记住"Python"

pat1='\s*\n'+sp_op+'(if|elif|else|for|while|def|class|try|except)'
a=re.match(pat1,text[i:])
print(len(sp_op))

"""

i0_op=i
txt_op=''
while True:
    a0=re.match('\s*\n',text[i:])
    if a0!=None:
        i+=a0.span()[1]
    a=re.match('.*',text[i:])
    if a==None:
        break
    txt_line=a.group()
    if len(txt_line)==0:
        break

    Dn=len(sp_op)
    if sp_op!=txt_line[0:Dn]:
        break
    
    b=re.match(sp_op+'(if|elif|else|for|while|def|class|try|except)',txt_line)
    if b!=None:
        break

    i+=len(txt_line)
    txt_op+=txt_line[Dn:]+'\n'

if i0_op==i:
    state=False
else:
    state=True

print('[运算]:',txt_op,len(sp_op))
ans=txt_op




## end
#72, 782:

text="""    import sys
    import re
    
    
    import sys1
    import re
    
    import sys2
    import re

import sys3
import re

    import sys4
    import re

"""

i=0
span='    '

j=i
while True:
    b=re.match('if|def|for|try|class|while',text[j:])
    if b!=None:
        print(3)
        break

    a=re.match('[^\n]*\n',text[j:])
    if a==None:
        if '\n' not in text[j:]:
            j=len(text)-1
        break
    
    dj=a.span()[1]
    j=j+dj

    d=re.match('[\s\t\n]*\n',text[j:])
    if d!=None:
        j=j+d.span()[1]

    c=re.match(span,text[j:])
    if c==None:
        print(1)
        break
    else:
        j=j+len(span)


print(text)
print(len(text))
print(text[i:j],j)

if i!=j:
    ans=text[i:j]
    i=j
    state=True
else:
    state=False


## end
#74, 33911:
import sys
import re
if __name__=='__main__':
    sys.path.append(sys.path[0]+'\\..')
from body.bone import NetP
def dictToList(dict_pt):
    list_pt=[]
    for term in dict_pt:
        list_pt+=dict_pt[term]
    return list_pt
class Karma():
    def __init__(self,symbol):
        self.m_symbol=symbol
        symbol.m_master=self
        self.m_creator=None
        self.m_map=None
        self.m_cause=None
        self.m_yese=[]
        self.m_noe=[]
        self.m_yesAnd=False
        self.m_noAnd=False
        self.m_eoi=0
        self.m_clause=[]
        self.m_clauseAnd=True
        self.m_clauseNew=[]
        self.m_clauseCollect=False
        self.m_clauseOut=False
        self.m_clauseIn=False
        self.m_not=False
        self.m_no=False
        self.m_buildMode=False
        self.m_listMP=None
        self.m_restricted=False
        self.m_ranger=None
        self.m_rangType=False                               
        self.m_stage=0
        self.m_reState='0'
        self.m_choose=True
        self.m_interp=False
    def stateSelf(self):
        if self.m_interp==True:
            return 'blue'
        if self.m_symbol==None or self.m_map==None:
            return 'yellow'
        if self.m_symbol.m_name=='[eq]' or self.m_symbol.m_name=='[同名]':
            return self.stateSelf_eq()
        elif self.m_symbol.m_name=='[is]' or self.m_symbol.m_name=='[是]':
            return self.stateSelf_is()
        elif self.m_symbol.m_name=='[那]':
            return 'green'
        if self.m_symbol.m_name=='_正则表达式' or self.m_symbol.m_name=='_re':
            try:
                pattern=re.compile(self.m_symbol.m_text)
            except:
                print('Invalid regular expression: '+self.m_symbol.m_text+'!')
                return 'red'
            match=self.m_map.m_name
            if pattern.findall(match)!=[]:
                return 'green'
            else:
                return 'red'
        if self.m_symbol.m_name!='' and self.m_symbol.m_name[0]=='_':
            name=self.m_symbol.m_name[1:]
            name_m=self.m_map.m_name
            if len(name)==0:
                return 'green'
            elif name[0]=='[' and name[-1]==']':
                if len(name_m)>=2 and name_m[0]=='[' and name_m[-1]==']':
                    return 'green'
                else:
                    return 'red'
            else:
                return 'green'
        if self.m_symbol.m_name!='' and self.m_symbol.m_name[0]=='[' and self.m_symbol.m_name[-1]==']':
            name1=self.m_symbol.m_name[1:-1]
            name2=self.m_symbol.m_name
            if self.m_interp==False and self.m_map.m_creator==None and self.m_buildMode==False:
                return 'red'
            if name1==self.m_map.m_name or name2==self.m_map.m_name:
                return 'green'
            else:
                return 'red'
        if self.m_symbol.m_name!='' and self.m_symbol.m_name[0]=='~':
            name=self.m_symbol.m_name[1:]
            if name==self.m_map.m_name:
                return 'red'
            else: 
                return 'green'
        else:
            name=self.m_map.m_name
            if name!='' and name[0]=='[' and name[-1]==']':
                name=name[1:-1]
            if name!=self.m_symbol.m_name:
                return 'red'
            elif self.m_symbol.m_text!='' and self.m_symbol.m_text!=self.m_map.m_text:
                return 'red'
            else:
                return 'green'
    def stateSelf_eq(self):
        if self.m_map==None:
            return 'yellow'
        if self.m_symbol.m_db[0]==None or self.m_symbol.m_db[1]==None:
            return 'red'
        karmaL=self.m_symbol.m_db[0].m_master
        karmaR=self.m_symbol.m_db[1].m_master
        if karmaL==None or karmaR==None:
            print('Error! [eq] doesn\'t have sbj or obj.')
            print('Sbj:',karmaL)
            print('Obj:',karmaR)
            return 'red'
        if karmaL.m_map==None or karmaR.m_map==None:
            return 'green'
        else:
            nameL=karmaL.m_map.m_name
            nameR=karmaR.m_map.m_name
            if len(karmaL.m_map.m_name)>1 and karmaL.m_map.m_name[0]=='[' and karmaL.m_map.m_name[-1]==']':
                nameL=karmaL.m_map.m_name[1:-1]
            if len(karmaR.m_map.m_name)>1 and karmaR.m_map.m_name[0]=='[' and karmaR.m_map.m_name[-1]==']':
                nameR=karmaR.m_map.m_name[1:-1]
            if nameL==nameR:
                return 'green'
            else:
                return 'red'
    def stateSelf_is(self):
        if self.m_map==None:
            return 'yellow'
        if self.m_symbol.m_db[0]==None or self.m_symbol.m_db[1]==None:
            return 'red'
        karmaL=self.m_symbol.m_db[0].m_master
        karmaR=self.m_symbol.m_db[1].m_master
        if karmaL.m_map==None or karmaR.m_map==None:
            return 'green'
        else:
            if karmaL.m_map==karmaR.m_map:
                return 'green'
            else:
                return 'red'
    def stateSelf_space(self):
        if self.m_map==None:
            return 'yellow'
        if self.m_symbol.m_db[0]==None or self.m_symbol.m_db[1]==None:
            return 'red'
        km_sbj=self.m_symbol.m_db[0].m_master
        km_obj=self.m_symbol.m_db[1].m_master
        if km_sbj.m_map==None or km_obj.m_map==None:
            return 'green'
        elif km_sbj.m_map==km_obj.m_map:
            return 'red'
        x1=km_sbj.m_map.m_pos[0]
        y1=km_sbj.m_map.m_pos[1]
        x2=km_obj.m_map.m_pos[0]
        y2=km_obj.m_map.m_pos[1]
        name=self.m_symbol.m_name
        if name=='[当地]' or name=='[here]':
            if x1==x2 and y1==y2:
                return 'green'
            else:
                return 'red'
        elif name=='[上面]' or name=='[up]':
            if y1>y2:
                return 'green'
            else:
                return 'red'
        elif name=='[正上面]' or name=='[Up]':
            if x1==x2 and y1>y2:
                return 'green'
            else:
                return 'red'
        elif name=='[下面]' or name=='[down]':
            if y1<y2:
                return 'green'
            else:
                return 'red'
        elif name=='[正下面]' or name=='[Down]':
            if x1==x2 and y1<y2:
                return 'green'
            else:
                return 'red'
        elif name=='[左面]' or name=='[left]':
            if x1>x2:
                return 'green'
            else:
                return 'red'
        elif name=='[正左面]' or name=='[Left]':
            if y1==y2 and x1>x2:
                return 'green'
            else:
                return 'red'
        elif name=='[右面]' or name=='[right]':
            if x1<x2:
                return 'green'
            else:
                return 'red'
        elif name=='[正右面]' or name=='[Right]':
            if y1==y2 and x1<x2:
                return 'green'
            else:
                return 'red'
    def stateRelation(self):
        if self.m_map==None or self.m_symbol==None:
            return True
        cause=self.m_cause
        while cause!=None:
            if cause.m_symbol==self.m_symbol.m_db[0]:
                if cause.m_map!=self.m_map.m_db[0]:
                    return False
            if cause.m_symbol==self.m_symbol.m_db[1]:
                if cause.m_map!=self.m_map.m_db[1]:
                    return False
            if cause.m_symbol.m_db[0]==self.m_symbol:
                if cause.m_map.m_db[0]!=self.m_map or cause.stateSelf()=='red':
                    return False
            if cause.m_symbol.m_db[1]==self.m_symbol:
                if cause.m_map.m_db[1]!=self.m_map or cause.stateSelf()=='red':
                    return False
            cause=cause.m_cause
        return True
    def mapListFromRange(self):
        list_map=[]
        if self.m_rangType==True:
            if self.m_ranger.m_map==None:
                list_map=[]
            else:
                list_map=self.m_ranger.m_map.m_con.copy()
        elif self.m_ranger.m_symbol.m_db[0]==self.m_symbol:
            if self.m_ranger.m_map.m_db[0]==None:
                list_map=[]
            else:
                list_map=[self.m_ranger.m_map.m_db[0]]
        elif self.m_ranger.m_symbol.m_db[1]==self.m_symbol:
            if self.m_ranger.m_map.m_db[1]==None:
                list_map=[]
            else:
                list_map=[self.m_ranger.m_map.m_db[1]]
        else:
            print('Warning! Undefined situation.')
        return list_map
    def mapListFromPool_normal(self,pool):
        name=self.m_symbol.m_name
        if len(name)>0 and (name[0]=='_' or name[0]=='~'):
            list_have=dictToList(pool)
            list_map=[]
            for point in list_have:
                if point.m_needed==None or (point.m_needed!=None and point.m_creator!=None):
                    list_map.append(point)
        else:
            list_map=pool.get(self.m_symbol.m_name,[])
        return list_map
    def mapList_is(self,ranger,pool):
        if ranger.m_symbol.m_db[0]==None or ranger.m_symbol.m_db[1]==None:
            return self.mapListFromPool_normal(pool)
        if ranger.m_symbol.m_db[0]==self.m_symbol and ranger.m_map.m_db[1]!=None:
            return [ranger.m_map.m_db[1]]
        if ranger.m_symbol.m_db[1]==self.m_symbol and ranger.m_map.m_db[0]!=None:
            return [ranger.m_map.m_db[0]]
        return self.mapListFromPool_normal(pool)
    def mapList_that(self,ranger):
        list_cause=ranger.allCauses()
        list_map=[]
        for cause in list_cause:
            pt_map=cause.m_map
            if pt_map!=None and pt_map not in list_map:
                list_map.append(pt_map)
        return list_map
    def rangeList(self,pool,areaType,list_new):
        if self.m_listMP!=None:
            return self.m_listMP
        elif self.m_ranger!=None:
            ranger=self.m_ranger
            nameR=self.m_ranger.m_symbol.m_name
            if nameR=='[is]':
                list_map=self.mapList_is(self.m_ranger,pool)
            elif nameR=='[那]':
                list_map=self.mapList_that(self.m_ranger)
            elif self.m_ranger.isType('回答') or self.m_ranger.isType('非新建'):
                list_map=self.mapListFromRange()
            elif self.m_buildMode==False:
                list_map=self.mapListFromPool_normal(pool)
            else:
                list_map=[]
        else:
            list_map=self.mapListFromPool_normal(pool)
        self.m_listMP=list_map
        return list_map
    def newMap(self,pool,areaType,list_new):
        list_map=self.rangeList(pool,areaType,list_new)
        if self.m_buildMode==False or areaType==False:
            name=self.m_symbol.m_name
            if self.isPreDefined():
                if self.m_map==None:
                    point=NetP(name,self.m_symbol.m_text)
                    point.m_pos=self.m_symbol.m_pos.copy()
                    point.m_needed=self
                    point.m_creator=self
                    self.map(point)
                else:
                    self.m_map.delete()
                    del self.m_map
                    self.map(None)
                return
            elif self.isFunctionPoint()==2:
                if self.m_map==None:
                    point=NetP(name,self.m_symbol.m_text)
                    point.m_pos=self.m_symbol.m_pos.copy()
                    point.m_needed=self
                    self.map(point)
                else:
                    self.map(self.m_map)
                self.m_interp=True
                return
            list_have=list_map
            mp=self.m_map
            self.map(self.nextInlist(mp,list_have))
            return
        else:
            name=self.m_symbol.m_name
            if name!='' and (name[0]!='[' or name[-1]!=']'):
                if self.m_map!=None:
                    self.m_map.m_creator=None
                    if self.m_map.m_needed==None:
                        self.m_map.delete()
                        self.map(None)
                        return
                    else:
                        self.m_map.m_name='['+self.m_map.m_name+']'
                list_need=[]
                for point in list_map:
                    if point.m_creator==None and point.m_needed!=None:
                        list_need.append(point)
                point=self.m_map
                self.map(self.nextInlist(point,list_need))
                if self.m_map==None:
                    if self.m_restricted==True:
                        self.map(None)
                        return
                    point=NetP(self.m_symbol.m_name,self.m_symbol.m_text)
                    point.m_pos=self.m_symbol.m_pos.copy()
                    point.m_building=True
                    self.map(point)
                else:
                    self.m_map.m_building=True
                    self.m_map.m_name=self.m_map.m_name[1:-1]
                self.m_map.m_creator=self
                return
            else:
                if self.m_map==None:
                    point=NetP(name,self.m_symbol.m_text)
                    point.m_pos=self.m_symbol.m_pos.copy()
                    point.m_building=True
                    point.m_needed=self
                    self.map(point)
                    return
                else:
                    self.m_map.m_needed=None
                    self.m_map.delete()
                    self.map(None)
                    return
        self.map(None)
    def nextInlist(self,point,list_pt):
        if list_pt==[]:
            return None
        if point==None:
            return list_pt[0]
        try:
            i=list_pt.index(point)
        except:
            return None
        if i+1>=len(list_pt):
            return None
        else:
            return list_pt[i+1]
    def clearAll(self):
        self.m_map=None
        self.m_stage=0
        self.m_interp=False
        self.m_reState=''
        self.m_choose=True
        self.m_eoi=0
        if self.m_restricted==False:
            del self.m_listMP
            self.m_listMP=None
        for clause in self.m_clause:
            clause.clearAll()
        for end in self.m_noe:
            end.clearAll()
        for end in self.m_yese:
            end.clearAll()
    def map(self,point):
        self.clearAll()
        self.m_map=point
        if self.m_map!=None:
            cause=self.m_cause
            while cause!=None:
                if cause.needBuildRelation():
                    if cause.m_map.m_needed==None or cause.m_map.m_needed==cause:
                        if cause.m_symbol.m_db[0]==self.m_symbol:
                            cause.m_map.connect(self.m_map,0)
                        if cause.m_symbol.m_db[1]==self.m_symbol:
                            cause.m_map.connect(self.m_map,1)
                if self.needBuildRelation():
                    if self.m_map.m_needed==None or self.m_map.m_needed==self:
                        if self.m_symbol.m_db[0]==cause.m_symbol:
                            self.m_map.connect(cause.m_map,0)
                        if self.m_symbol.m_db[1]==cause.m_symbol:
                            self.m_map.connect(cause.m_map,1)
                cause=cause.m_cause
    def buildingNewMap(self):
        if self.m_map==None:
            return False
        elif self.m_buildMode==False:
            return False
        else:
            if self.m_map.m_needed==None:
                return True
        return False
    def needBuildRelation(self):
        if self.buildingNewMap():
            return True
        elif self.isFunctionPoint()!=0:
            return True
        return False
    def selfType(self):
        name=self.m_symbol.m_name
        if name=='':
            return "实链节"
        elif name[0]=='_':
            return "实万用链节"
        elif name[0]=='~':
            return "实否定链节"
        elif name[0]=='[' and name[-1]==']':
            return "虚链节"
        return "实链节"
    def isVirtual(self):
        name=self.m_symbol.m_name
        if len(name)>1 and name[0]=='[' and name[-1]==']':
            return True
        elif self.isSpaceRelation():
            return True
        else:
            return False
    def isPreDefined(self):
        name=self.m_symbol.m_name
        if name=='[is]' or name=='[eq]' or name=='[那]' or name=='[]':
            return True
        elif self.isSpaceRelation():
            return True
        else:
            return False
    def isSpecialRanger(self):
        name=self.m_symbol.m_name
        if name=='[is]' or name=='[那]':
            return True
        return False
    def isType(self,str_type):
        name=self.m_symbol.m_name
        if infoInStr('引用',str_type):
            if not self.isVirtual() or self.m_buildMode==True:
                return False
        if infoInStr('新建',str_type):
            if infoInStr('非新建',str_type):
                if self.m_buildMode==True:
                    return False
            elif self.m_buildMode==False:
                return False
        if infoInStr('动作',str_type):
            if not self.isVirtual() or self.m_buildMode==False:
                return False
        if infoInStr('内置',str_type):
            if not self.isPreDefined():
                return False
        if infoInStr('特殊范围',str_type):
            if not self.isSpecialRanger():
                return False
        if infoInStr('否定',str_type):
            if name=='' or name[0]!='~':
                return False
        if infoInStr('通用',str_type):
            if name=='' or name[0]!='_':
                return False
        if infoInStr('普通',str_type):
            if self.isVirtual():
                return False
        if infoInStr('端点',str_type):
            if infoInStr('非端点',str_type):
                if self.m_ranger==None:
                    return False
            elif self.m_ranger!=None:
                return False
        if infoInStr('回答',str_type):
            if self.m_map==None or self.m_map.m_needed==self or self.m_map.m_needed==None:
                return False
        if infoInStr('限制',str_type):
            if self.m_restricted==False:
                return False
        return True
    def isFunctionPoint(self):
        if self.m_symbol.m_name=='':
            return 0
        elif self.m_symbol.m_name=='[eq]' or self.m_symbol.m_name=='[同名]':
            return 1
        elif self.m_symbol.m_name=='[is]' or self.m_symbol.m_name=='[是]':
            return 1
        elif self.m_symbol.m_name=='[那]':
            return 1
        elif self.m_symbol.m_name=='[]':
            return 1
        elif self.isSpaceRelation():
            return 1
        elif self.m_symbol.m_name[0]=='[' and self.m_symbol.m_name[-1]==']':
            return 2
        return 0
    def isSpaceRelation(self):
        if self.m_buildMode==True:
            return False
        name=self.m_symbol.m_name
        if name=='[上面]' or name=='[下面]' or name=='[左面]' or name=='[右面]':
            return True
        elif name=='[正上面]' or name=='[正下面]' or name=='[正左面]' or name=='[正右面]':
            return True
        elif name=='[当地]':
            return True
        elif name=='[up]' or name=='[down]' or name=='[left]' or name=='[right]':
            return True
        elif name=='[Up]' or name=='[Down]' or name=='[Left]' or name=='[Right]':
            return True
        elif name=='[here]':
            return True
        return False
    def Reason_iterative(self,pool,list_new=None):
        if list_new==None:
            list_new=[]
        while True:
            [change,list_pt]=self.Reason_oneStep(pool)
            if self.m_stage==2:
                for clause in self.m_clause:
                    clause.Reason_iterative(pool)
            elif self.m_stage==3:
                for end in self.m_noe:
                    end.Reason_iterative(pool)
                for end in self.m_yese:
                    end.Reason_iterative(pool)
            elif self.m_stage==5:
                break
        return [self.m_reState,list_new]
    def isChosen(self):
        if self.m_cause==None:
            return False
        if self.m_cause.m_choose==False:
            return self in self.m_cause.m_noe
        else:
            return self in self.m_cause.m_yese
    def Reason_oneStep(self,pool):
        list_new=[]
        areaType=self.areaType()
        change=False
        if self.m_stage==0:
            if self.m_cause!=None:
                if self in self.m_cause.m_clause:
                    if self.m_cause.m_stage==2:
                        self.m_stage=1
                        change=True
        if self.m_stage==1:
            while True:
                if self.stateSelf()!='blue':
                    self.newMap(pool,areaType,list_new)
                else:
                    self.m_interp=False
                change=True
                if self.stateRelation()==False:
                    continue
                elif self.stateSelf()=='red':
                    continue
                elif self.stateSelf()=='yellow':
                    self.m_stage=5
                    if self.m_no==False:
                        self.m_reState='dark yellow'
                        return [change,list_new]
                    else:
                        self.m_reState='dark green'
                        return [change,list_new]
                elif self.stateSelf()=='blue':
                    self.m_stage=1
                    return [change,list_new]
                else:
                    self.m_stage=2
                    break
        if self.m_stage==2:
            if self.m_clause==[]:
                self.m_choose=True
                self.m_stage=3
                change=True
            else:
                self.m_choose=self.m_clauseAnd
                keep=False
            for clause in self.m_clause:
                if self.m_clauseAnd==True:
                    if clause.m_reState=='dark yellow':
                        self.m_choose=False
                        self.m_stage=3
                        change=True
                        self.m_clauseOut=True
                        break
                    elif clause.m_reState=='':
                        keep=True
                else:
                    if clause.m_reState=='dark green':
                        self.m_choose=True
                        self.m_stage=3
                        change=True
                        self.m_clauseOut=True
                        break
                    elif clause.m_reState=='':
                        keep=True
            if self.m_clause!=[] and keep==False:
                self.m_stage=3
                change=True
                self.m_clauseOut=True
        if self.m_stage==3:
            if self.m_choose==False:
                if self.m_noe==[]:
                    self.m_stage=1
                    change=True
                    return [change,list_new]
                i=self.m_eoi
                end=self.m_noe[i]
                if end.m_stage==0:
                    end.m_stage=1
                    change=True
                elif end.m_reState=='dark yellow':
                    if self.m_noAnd==True:
                        self.m_stage=1
                        change=True
                    else:
                        i+=1
                        change=True
                        if i==len(self.m_noe):
                            self.m_stage=1
                            self.m_eoi=0
                        else:
                            self.m_eoi=i
                elif end.m_reState=='dark green':
                    if self.m_noAnd!=True:
                        self.m_stage=4
                        change=True
                    else:
                        i+=1
                        change=True
                        if i==len(self.m_noe):
                            self.m_stage=4
                            self.m_eoi=0
                        else:
                            self.m_eoi=i
            else:
                if self.m_yese==[] and self.m_noe==[]:
                    self.m_stage=4
                    change=True
                elif self.m_yese==[]:
                    self.m_stage=1
                    change=True
                    return [change,list_new]
                else:
                    i=self.m_eoi
                    end=self.m_yese[i]
                    if end.m_stage==0:
                        end.m_stage=1
                        change=True
                    elif end.m_reState=='dark yellow':
                        if self.m_yesAnd==True:
                            self.m_stage=1
                            change=True
                        else:
                            i+=1
                            change=True
                            if i==len(self.m_yese):
                                self.m_stage=1
                                self.m_eoi=0
                            else:
                                self.m_eoi=i
                    elif end.m_reState=='dark green':
                        if self.m_yesAnd!=True:
                            self.m_stage=4
                            change=True
                        else:
                            i+=1
                            change=True
                            if i==len(self.m_yese):
                                self.m_stage=4
                                self.m_eoi=0
                            else:
                                self.m_eoi=i
        if self.m_stage==4:
            if self.m_clauseNew!=[] or self.m_clauseOut==True:
                self.m_clauseCollect=True
            if (self.m_buildMode==True or self.isFunctionPoint()==1) and self.m_map!=None and self.m_map not in list_new:
                list_new.append(self.m_map)
            self.m_stage=5
            if self.m_no==True:
                self.m_reState='dark yellow'
                change=True
                return [change,list_new]
            else:
                self.m_reState='dark green'
                change=True
                return [change,list_new]
        return [change,list_new]
    def areaType(self):
        aType=True
        cause=self
        while True:
            if cause.m_no==True:
                aType=not aType
            if cause.m_cause==None:
                return aType
            else:
                cause=cause.m_cause
    def build(self,code,points):
        wait_list=[]
        last=self
        connection=None
        exp='(->>|=>>|->|=>|{[ \t\n]*|[ \t\n]*}|,[ \t\n]*|;[ \t\n]*|:[ \t\n]*)'
        units=re.split(exp,code)
        for unit in units:
            if unit=='':
                continue
            elif unit=='->' or unit=='=>' or unit=='->>' or unit=='=>>':
                connection=unit
            elif unit[0]=='{':
                wait_list.append(['clause_splitting',last])
            elif unit[0]==':':
                wait_list.append(['end_splitting',last])
            elif unit[0]==',':
                last=wait_list[-1][1]
            elif unit[0]==';':
                if wait_list[-1][0]=='end_splitting':
                    wait_list.pop()
                if wait_list!=[]:
                    last=wait_list[-1][1]
            elif unit[-1]=='}':
                last=wait_list[-1][1]
                wait_list.pop()
            else:
                current=Karma(points[int(unit)])
                current.m_cause=last
                if connection=='->':
                    current.m_no=False
                    last.m_yese.append(current)
                elif connection=='->>':
                    current.m_no=False
                    last.m_noe.append(current)
                elif connection=='=>':
                    current.m_no=True
                    last.m_yese.append(current)
                elif connection=='=>>':
                    current.m_no=True
                    last.m_noe.append(current)
                else:
                    last.m_clause.append(current)
                connection=''
                last=current
    def info_cause(self):
        info=''
        karma=self
        while True:
            if karma.m_symbol!=None:
                info=karma.m_symbol.m_name+info
            if karma.m_cause==None:
                break
            if karma in karma.m_cause.m_yese:
                if karma.m_no==True:
                    info='=>'+info
                else:
                    info='->'+info
            elif karma in karma.m_cause.m_noe:
                if karma.m_no==True:
                    info='=>>'+info
                else:
                    info='->>'+info
            elif karma in karma.m_cause.m_clause:
                info='=='+info
            karma=karma.m_cause
        print(info)
        return info
    def allEffects(self):
        list_effects=[self]
        for karma in self.m_clause:
            list_effects+=karma.allEffects()
        for karma in self.m_noe:
            list_effects+=karma.allEffects()
        for karma in self.m_yese:
            list_effects+=karma.allEffects()
        return list_effects
    def setRangers(self,causes=None):
        connecting=None
        connected=None
        caseNo=100
        if causes==None:
            causes=[]
        elif self.isType('非新建普通链节'):
            for cause in causes:
                if cause.m_symbol.m_db[0]==self.m_symbol or cause.m_symbol.m_db[1]==self.m_symbol:
                    if cause.isType('特殊范围'):
                        connected=cause
                        break
                    elif cause.isType('普通非新建') and caseNo>3:
                        connected=cause
                        caseNo=3
                    elif cause.isType('新建') and caseNo>5:
                        connected=cause
                        caseNo=5
                elif self.m_symbol.m_db[0]==cause.m_symbol or self.m_symbol.m_db[1]==cause.m_symbol:
                    if cause.isType('引用') and caseNo>2:
                        connecting=cause
                        caseNo=2
                    elif cause.isType('普通非新建') and caseNo>4:
                        connecting=cause
                        caseNo=4
                    elif cause.isType('新建') and caseNo>6:
                        connecting=cause
                        caseNo=6
            if connected!=None:
                self.m_ranger=connected
            elif connecting!=None:
                self.m_ranger=connecting
                self.m_rangType=True
        causes=causes[:]+[self]
        for con in self.m_clause:
            con.setRangers(causes)
        for end in self.m_yese:
            end.setRangers(causes)
        for end in self.m_noe:
            end.setRangers(causes)
    def causeEnd(self):
        cause=self
        while cause.m_cause!=None:
            cause=cause.m_cause
        return cause
    def allCauses(self):
        cause=self
        list_km=[]
        while cause.m_cause!=None:
            cause=cause.m_cause
            list_km.append(cause)
        return list_km
    def addKarma(self,karma,con_type='肯定'):
        while karma.m_cause!=None:
            karma=karma.m_cause
        if con_type=="clause" or con_type=="从句":
            self.m_clause.append(karma)
        elif con_type=="no" or con_type=="否定":
            self.m_noe.append(karma)
        else:
            self.m_yese.append(karma)
        karma.m_cause=self
    def __str__(self) -> str:
        return self.info_karma()
    def info_karma(self,info='',head=0,type_info=0):
        if info=='' and self.m_no==True:
            info='[]=>'
        if self.m_ranger!=None and type_info==0:
            ranger=self.m_ranger.m_symbol.info("不显示位置不显示内容")
            info+='['+ranger+']'
            head+=len(ranger)+2
        info+=self.m_symbol.info("不显示位置不显示内容")
        head+=len(self.m_symbol.info("不显示位置不显示内容"))
        if self.m_clause!=[]:
            info+='{'
            head+=1
            for clause in self.m_clause:
                info+='\n'+''.rjust(head)
                info=clause.info_karma(info,head,type_info)
                if clause!=self.m_clause[-1]:
                    info+=','
            info+='\n'+'}'.rjust(head-1)
        n=0
        if len(self.m_noe)+len(self.m_yese)>1:
            info+=':'
        for end in self.m_yese:
            if n==0:
                if end.m_no==False:
                    info+='->'
                else:
                    info+='=>'
                info=end.info_karma(info,head+2,type_info)
                n+=1
            else:
                if end.m_no==False:
                    info+='\n'+'->'.rjust(head+2)
                else:
                    info+='\n'+'=>'.rjust(head+2)
                info=end.info_karma(info,head,type_info)
            if end!=self.m_yese[-1] or self.m_noe!=[]:
                info+=','
        for end in self.m_noe:
            if n==0:
                if end.m_no==False:
                    info+='->>'
                else:
                    info+='=>>'
                info=end.info_karma(info,head+3,type_info)
                n+=1
            else:
                if end.m_no==False:
                    info+='\n'+'->>'.rjust(head+3)
                else:
                    info+='\n'+'=>>'.rjust(head+3)
                info=end.info_karma(info,head,type_info)
            if end!=self.m_noe[-1]:
                info+=','
        return info
def printPtList(list_pt):
    info_pt='['
    for pt in list_pt:
        info_pt+=pt.info(show_info='不显示文本')
        if pt!=list_pt[-1]:
            info_pt+=', '
        else:
            info_pt+=';'
    info_pt+=']'
    print(info_pt)
def infoInStr(string,str_info):
    a=str_info.find(string)
    return a!=-1
if __name__=='__main__':
    result=infoInStr('新建','新建')
    print(result)
## end
#75, 2:
82
## end
#77, 2:
81
## end
#79, 2:
86
## end
#81, 2:
89
## end
#83, 3:
106
## end
#86, 657:
Nini, 打开公式分析器(文件)

测试if:...
测试循环:...
测试try:...
测试定义:...
+[新建阅读窗口](,测试if)

结构::
缩进::
输出结构:...
结构场景:...
+[新建阅读窗口](,结构场景)

图形::
在图形中, 显示结构场景为程序流程图
在图形中, 将结构场景的类"NetP"显示为程序流程图
+[调用词典动词](+[做],+显示)->+[做](,+[类]#9)...
->+在(+[做],图形#1)->+[del](,+在)...
    ->+中(+在,)->+[del](,+中)...
->+[程序流程图]#10->+为(+[做],+[程序流程图]#10)...
    ->+[del](,+为)->[]->[]->+[.](结构场景#8,+[类]#9)->+[类]#9"NetP"


[python程序](测试定义,)->+[修改内容](,输出结构)->[m_text]([python程序],+[修改内容])
+[删除结构](,结构场景)->+[导入节点](,结构场景)->[m_text](输出结构,+[导入节点])
+[显示星图]"1"(,结构场景)


[python程序_代码](测试定义,)->+[修改内容](,输出结构)->[m_text]([python程序_代码],+[修改内容])
+[删除结构](,结构场景)->+[导入节点](,结构场景)->[m_text](输出结构,+[导入节点])
+[显示星图]"3"(,结构场景)


## end
#88, 372:
if a==b:
    a
    if 1:
        a
    elif 2:
        b
elif a!=b:
    pass
    if 1:
        a
    elif 2:
        b
elif a!=b:
    b=a+1
    c=b+1
    if 1:
        a
    elif 2:
        b
elif a!=b:
    b=a+1
    c=b+1
else:
    if 1:
        a
        while 1:
            c
            while 1:
                c
    elif 2:
        b
    print('b')
    print('a')


## end
#90, 491:
块#0""(程序,)[-1,-1]
块#1"b=a+1
c=d+1
"(程序,)[-1,-1]
eof#2""(程序,)[-1,-1]
然后#3""(块#1,eof#2)[-1,-1]
func#4"a(c,d)"(块#0,块#1)[-1,-1]
块#5"d=a+b
"(程序,)[-1,-1]
然后#6""(块#0,块#5)[-1,-1]
块#7""(程序,)[-1,-1]
然后#8""(块#5,块#7)[-1,-1]
块#9""(程序,)[-1,-1]
块#10"a=1
"(程序,)[-1,-1]
eof#11""(程序,)[-1,-1]
然后#12""(块#10,eof#11)[-1,-1]
func#13"__init__(self)"(块#9,块#10)[-1,-1]
eof#14""(程序,)[-1,-1]
然后#15""(块#9,eof#14)[-1,-1]
class#16"NetP"(块#7,块#9)[-1,-1]
eof#17""(程序,)[-1,-1]
然后#18""(块#7,eof#17)[-1,-1]
起点#19""(,块#0)[-1,-1]

## end
#96, 93:
"""


"""

+增加缩进(缩进,缩进#1)...
->+[s]"sp"([python],缩进)->[python]"ans=sp+'    '"(Python,缩进#1)



## end
#98, 646:
"""
+[P函数](,P代码)

测试:...
保存:

"""

j=i
while True:
    b=re.match('if|def|for|try|class|while',text[j:])
    if b!=None:
        j-=len(span)
        break

    a=re.match('[^\n]*\n',text[j:])
    if a==None:
        if '\n' not in text[j:]:
            j=len(text)
        break
    
    dj=a.span()[1]
    j=j+dj

    d=re.match('[\s\t\n]*\n',text[j:])
    if d!=None:
        dj=d.span()[1]
        j=j+dj

    c=re.match(span,text[j:])
    if c==None:
        break
    else:
        j=j+len(span)


# print('空格:',len(span))
# print(text[i:j])
# print(i,j,len(span),dj)
if i<j:
    ans=text[i:j]
    i=j
    state=True
else:
    state=False


## end
#99, 3:
131
## end
#102, 434:

try:
    if n[0]==-1:
        n=i
        a=re.match(pat,text[i:])
        if a==None:
            print('Stop in [%s]'%(block))
            state=False
        else:
            di=a.span()[1]
            print('[%s]: '%(block),text[i:i+di])
            output_txt=text[i:i+di]
            i+=di
            state=True
    else:
        i=int(n[0])
        state=False
except:
    state=False

if state==False:
    output_txt=pat



## end
#105, 261:
"""
+[返回目录](,模块结尾)
P代码:...

"""
+模块结尾(结构,缩进)...
->的(模块结尾,P代码)...

->+模块"结尾"...
->[]:
    ->[匹配模式_编程]"[\s]*.+"(,+模块)->+句子(结构,)...
    ->+[s]"sp_op"([python],缩进)->+[s]"sent_op"([python],[匹配模式_编程])...
        ->+[code]([python],P代码)->[python](Python,),
    ->[]



## end
#107, 536:
"""
+[P函数](,P代码)
记住"Python"
print(a1)

"""

di=len(sp)
pat1='\s*\n'+sp
pat2=sp
try:
    if n[0]==-1:
        n=i
        a1=re.match(pat1,text[i:])
        a2=re.match(pat2,text[i:])
        if a1==None and a2==None:
            state=False
        elif a1!=None:
            di=a1.span()[1]
            output_txt=text[i:i+di]
            i+=di
            state=True
        else:
            output_txt=text[i:i+di]
            i+=di
            state=True
    else:
        i=int(n[0])
        state=False
except:
    state=False



## end
#110, 452:
"""
+[返回目录](,缩进)

P代码(P函数):
保存:

"""

+缩进(缩进,)...
->+保存状态"off"(,)...
->+[o]"out_state"([python],+保存状态)->+[s]"pat"([python],缩进)->[python]"
print(i,out_state)
if out_state=='on':
    i-=len(pat)
    state=False
else:
    out_state='on'
    try:
        a=re.match(pat,text[i:])
        if a==None:
            state=False
        else:
            di=a.span()[1]
            i+=di
            state=True
    except:
        state=False
"(Python,+[不终止])


## end
#115, 77:
a=a+1
c=c+1
while True:
    a=c+a
    for a in range(5):
        v=v+dv






## end
#117, 101:
"""
P代码(P函数):...

"""

+显示code(,)...
->的(显示code,P代码)...

->+[code]([python],P代码)->[python](Python,)


## end
#119, 49:
"""


"""

print('Current:',text[i:])
state=True

## end
#122, 32:

try:
    a=1
except:
    pass


## end
#124, 89:
def a(c,d):
    b=a+1
    c=d+1

d=a+b

class NetP:
    def __init__(self):
        a=1


## end
#125, 3:
132
## end
#128, 415:
"""
+[P函数](,P代码)
记住"Python"

"""
import re

Dn=len(sp)
a=re.match('\s*\n',text[i:])
if a!=None:
    Di=a.span()[1]
    j=i+Dn+Di
else:
    j=i+Dn

if text[j:j+2]=='if':
    ans='if'
elif text[j:j+5]=='while':
    ans='while'
elif text[j:j+3]=='for':
    ans='for'
elif text[j:j+3]=='try':
    ans='try'
elif text[j:j+3]=='def':
    ans='def'
elif text[j:j+5]=='class':
    ans='class'
else:
    ans=''

state=True


## end
#130, 3:
144
## end
#133, 431:
"""
+[返回目录](,运算)
P代码:...

保存:...

"""
+运算(结构,缩进)...
->的(运算,P代码)...

->+模块"句子"...
->[匹配模式]"[\s]*.+"(,+模块)->+句子(+运算,)...
    ->+[s]"sp_op"([python],缩进)->+[s]"sent_op"([python],[匹配模式])...
    ->+[code]([python],P代码)->[python](Python,)...

=>句子(+运算,)=>[]:
    ->[匹配模式]"[\s]*.+"(,+模块)->+句子(+运算,)...
    ->+[s]"sp_op"([python]#1,缩进)->+[s]"sent_op"([python]#1,[匹配模式])...
        ->+[code]([python]#1,P代码)->[python]#1(Python,),
    ->[]



## end
#135, 559:
"""
+[P函数](,P代码)

测试:...
保存:...
保存2:...
记住"Python"

"""

a=re.search('([ \t]*)(.*)$',sent_op)
sp1=a.group(1)
sent1=a.group(2)

state=False
try:
    if len(sp1)<len(sp_op):
        state=False
    elif len(sent1)==0:
        state=False
    elif sent1[0:2]=='if' or sent1[0:4]=='else' or sent1[0:4]=='elif'\
         or sent1[0:3]=='try' or sent1[0:6]=='except'\
         or sent1[0:3]=='for' or sent1[0:5]=='while'\
         or sent1[0:3]=='def' or sent1[0:5]=='class':
        state=False
    else:
        state=True
except:
    pass

# print(sent1,state)


## end
#137, 6062:
import sys
import re
if __name__=='__main__':
    sys.path.append(sys.path[0]+'\\..')
from body.bone import NetP
change=True
class Karma():
    def Reason_oneStep(self,pool):
        list_new=[]
        areaType=self.areaType()
        change=False
        if self.m_stage==0:
            if self.m_cause!=None:
                if self in self.m_cause.m_clause:
                    if self.m_cause.m_stage==2:
                        self.m_stage=1
                        change=True
        if self.m_stage==1:
            while True:
                if self.stateSelf()!='blue':
                    self.newMap(pool,areaType,list_new)
                else:
                    self.m_interp=False
                change=True
                if self.stateRelation()==False:
                    continue
                elif self.stateSelf()=='red':
                    continue
                elif self.stateSelf()=='yellow':
                    self.m_stage=5
                    if self.m_no==False:
                        self.m_reState='dark yellow'
                        return [change,list_new]
                    else:
                        self.m_reState='dark green'
                        return [change,list_new]
                elif self.stateSelf()=='blue':
                    self.m_stage=1
                    return [change,list_new]
                else:
                    self.m_stage=2
                    break
        if self.m_stage==2:
            if self.m_clause==[]:
                self.m_choose=True
                self.m_stage=3
                change=True
            else:
                self.m_choose=self.m_clauseAnd
                keep=False
            for clause in self.m_clause:
                if self.m_clauseAnd==True:
                    if clause.m_reState=='dark yellow':
                        self.m_choose=False
                        self.m_stage=3
                        change=True
                        self.m_clauseOut=True
                        break
                    elif clause.m_reState=='':
                        keep=True
                else:
                    if clause.m_reState=='dark green':
                        self.m_choose=True
                        self.m_stage=3
                        change=True
                        self.m_clauseOut=True
                        break
                    elif clause.m_reState=='':
                        keep=True
            if self.m_clause!=[] and keep==False:
                self.m_stage=3
                change=True
                self.m_clauseOut=True
        if self.m_stage==3:
            if self.m_choose==False:
                if self.m_noe==[]:
                    self.m_stage=1
                    change=True
                    return [change,list_new]
                i=self.m_eoi
                end=self.m_noe[i]
                if end.m_stage==0:
                    end.m_stage=1
                    change=True
                elif end.m_reState=='dark yellow':
                    if self.m_noAnd==True:
                        self.m_stage=1
                        change=True
                    else:
                        i+=1
                        change=True
                        if i==len(self.m_noe):
                            self.m_stage=1
                            self.m_eoi=0
                        else:
                            self.m_eoi=i
                elif end.m_reState=='dark green':
                    if self.m_noAnd!=True:
                        self.m_stage=4
                        change=True
                    else:
                        i+=1
                        change=True
                        if i==len(self.m_noe):
                            self.m_stage=4
                            self.m_eoi=0
                        else:
                            self.m_eoi=i
            else:
                if self.m_yese==[] and self.m_noe==[]:
                    self.m_stage=4
                    change=True
                elif self.m_yese==[]:
                    self.m_stage=1
                    change=True
                    return [change,list_new]
                else:
                    i=self.m_eoi
                    end=self.m_yese[i]
                    if end.m_stage==0:
                        end.m_stage=1
                        change=True
                    elif end.m_reState=='dark yellow':
                        if self.m_yesAnd==True:
                            self.m_stage=1
                            change=True
                        else:
                            i+=1
                            change=True
                            if i==len(self.m_yese):
                                self.m_stage=1
                                self.m_eoi=0
                            else:
                                self.m_eoi=i
                    elif end.m_reState=='dark green':
                        if self.m_yesAnd!=True:
                            self.m_stage=4
                            change=True
                        else:
                            i+=1
                            change=True
                            if i==len(self.m_yese):
                                self.m_stage=4
                                self.m_eoi=0
                            else:
                                self.m_eoi=i
        if self.m_stage==4:
            if self.m_clauseNew!=[] or self.m_clauseOut==True:
                self.m_clauseCollect=True
            if (self.m_buildMode==True or self.isFunctionPoint()==1) and self.m_map!=None and self.m_map not in list_new:
                list_new.append(self.m_map)
            self.m_stage=5
            if self.m_no==True:
                self.m_reState='dark yellow'
                change=True
                return [change,list_new]
            else:
                self.m_reState='dark green'
                change=True
                return [change,list_new]
        return [change,list_new]

## end
#138, 3:
142
## end
#140, 3:
147
## end
#142, 3:
292
## end
#145, 220:
+[粘贴](,操作)

收集程序块尺寸:...
设置程序块位置:...
设置程序块位置的"收集程序块尺寸"替换为"设置程序块位置"
+[复制结构](,收集程序块尺寸)
->+[粘贴](,操作)->+[修改标题]"设置程序块位置"(,收集程序块尺寸)

生成程序结构:...
删除场景结构:...

记录时间:...
分析程序结构:...

移除注释:...
列举函数:...
移除注释的"去结尾"替换为"移除注释"

结构转代码:...


## end
#147, 150:
"""
库:...
+[新建阅读窗口](,库)

"""

+设置程序块位置(,做)->+[del](,+设置程序块位置)...
->的(设置程序块位置,库)->的(库,_段落)...
->[标题](_段落,)->[==](+设置程序块位置,[标题])...
    ->+code(做,_段落)


## end
#149, 146:


程序:...
语句:...
语句的"程序"替换为"语句"
运算的"收集程序块尺寸"替换为"设置程序块位置"

if:...
elif:...
+[新建阅读窗口](,elif)

def:...
class:...
try:...
while:...
for:...

运算:...




## end
#151, 239:
"""
画结构(S函数):...

"""

+程序(_结构,块)->+[del](,+程序)...
->的(程序,画结构)...

->+[做]#0(_结构,块)->+[code](+[做]#0,画结构)...

->+[设置程序块位置]"语句"(,+[做])->+[做](_结构,块)...
->[]{
    []:->然后(块,块#1)->块#1->+[设置程序块位置]"程序"(,+[做]#1)->+[做]#1(_结构,块#1),
        ->[]
}




## end
#153, 437:
"""


"""

+语句(_结构,块)->+[del](,+语句)...

->[]:
    ->if(块,)->+[设置程序块位置]"if"(,+[做]#0)->+[做]#0(_结构,块),
    ->func(块,)->+[设置程序块位置]"def"(,+[做]#1)->+[做]#1(_结构,块),
    ->while(块,)->+[设置程序块位置]"while"(,+[做]#2)->+[做]#2(_结构,块),
    ->for(块,)->+[设置程序块位置]"for"(,+[做]#3)->+[做]#3(_结构,块),
    ->try(块,)->+[设置程序块位置]"try"(,+[做]#4)->+[做]#4(_结构,块),
    ->class(块,)->+[设置程序块位置]"class"(,+[做]#5)->+[做]#5(_结构,块),
    ->+[设置程序块位置]"运算"(,+[做]#6)->+[做]#6(_结构,块)




## end
#155, 379:
"""
画结构(S函数):...

"""

+if(_结构,块)->+[del](,+if)...
->的(if#0,画结构)...

->+[做](_结构,块)->+[code](+[做],画结构)...

->if(块,块#0)...
->+[设置程序块位置]"程序"(,+[做]#0)->+[做]#0(_结构,块#0)...
->[]{
    []:->elif(if,)...
            ->+[设置程序块位置]"elif"(,+[做]#1)->+[做]#1(_结构,elif),
        ->[]
}...
->[]{
    []:->else(if,块#2)->块#2(,)...
        ->+[设置程序块位置]"程序"(,+[做]#2)->+[做]#2(_结构,块#2),
    ->[]
}






## end
#157, 173:
"""
画结构(S函数):...

"""

+def(_结构,块)->+[del](,+def)...
->的(def#0,画结构)...

->+[做](_结构,块)->+[code](+[做],画结构)...

->func(块,块#0)...
->+[设置程序块位置]"程序"(,+[做]#0)->+[做]#0(_结构,块#0)





## end
#159, 178:
"""
画结构(S函数):...

"""

+class(_结构,块)->+[del](,+class)...
->的(class#0,画结构)...

->+[做](_结构,块)->+[code](+[做],画结构)...

->class(块,块#0)...
->+[设置程序块位置]"程序"(,+[做]#0)->+[做]#0(_结构,块#0)



## end
#161, 232:
"""
画结构:...

"""

+try(_结构,块)->+[del](,+try)...
->的(try#0,画结构)...

->+[做](_结构,块)->+[code](+[做],画结构)

->try(块,块#0)...
->+[设置程序块位置]"程序"(,+[做]#0)->+[做]#0(_结构,块#0)...

->except(try,块#1)...
->+[设置程序块位置]"程序"(,+[做]#1)->+[做]#1(_结构,块#1)





## end
#163, 178:
"""
画结构(S函数):...

"""

+while(_结构,块)->+[del](,+while)...
->的(while#0,画结构)...

->+[做](_结构,块)->+[code](+[做],画结构)...

->while(块,块#0)...
->+[设置程序块位置]"程序"(,+[做]#0)->+[做]#0(_结构,块#0)



## end
#165, 171:
"""
画结构(S函数):...

"""

+for(_结构,块)->+[del](,+for)...
->的(for#0,画结构)...

->+[做](_结构,块)->+[code](+[做],画结构)...

->for(块,块#0)...
->+[设置程序块位置]"程序"(,+[做]#0)->+[做]#0(_结构,块#0)




## end
#167, 104:
"""
画结构(S函数):...

"""

+运算(_结构,块)->+[del](,+运算)...
->的(运算,画结构)...

->+[做](_结构,块)->+[code](+[做],画结构)





## end
#169, 298:
"""
画结构:...
+[新建阅读窗口](,画结构)

"""

+elif(_结构,elif)->+[del](,+elif)...
->的(elif#0,画结构)...

->elif(,块#0)...
->+[做](_结构,elif)->+[code](+[做],画结构)...

->+[设置程序块位置]"程序"(,+[做]#0)->+[做]#0(_结构,块#0)...
->[]{
    []:->elif#1(elif,)...
        ->+[设置程序块位置]"elif"(,+[做]#1)->+[做]#1(_结构,elif#1),
        ->[]
}




## end
#171, 332:
+[显示星图]"1"(,结构场景)
+[显示PPT场景]"2"(,图形)

图形::
+[设置结构](,图形)
+[删除场景结构](,图形)

起点(,块)->+[生成程序结构](块,图形)->+[显示PPT场景]"2"(,图形)

[]=>块=>+[显示](,块)
图形=>的(图形,模块)->在(模块,空间点)=>+[显示](,空间点)
图形=>的(图形,模块)->的(模块,尺寸)=>+[消息窗口](,模块)->+[消息窗口](,尺寸)
[]=>try=>+[显示](,try)
[]=>class=>+[显示](,class)

[]=>elif->的(elif,块尺寸)=>+[消息窗口](,块尺寸)

记住"Python"
print(siz)




## end
#173, 1388:
"""
P代码(P函数):...
+[新建阅读窗口](,P代码)

保存:...

"""

+画结构(_结构,块)->+[del](,+画结构)...
->的(画结构,P代码)...

->if(块,块#0)->匹配(模块,块)->模块->的(_结构,模块)...
    ->在(模块,空间点)->的(模块,尺寸)...

->+[python](Python,)->+[code](+[python],P代码)...
->+[.]"pt"(+[python],空间点)->+[.]"siz"(+[python],尺寸)...

->[]{
    匹配(模块#0,块#0)->模块#0->的(_结构,模块#0)...
        ->的(模块#0,尺寸#0)->+[.]"siz00"(+[python],尺寸#0)...
        ->的(模块#0,组尺寸#0)->+[.]"siz0"(+[python],组尺寸#0):
            ->在(模块#0,空间点#0)->+[o]"pt0"(+[python],空间点#0),
        ->+在(模块#0,+空间点#0)->+[o]"pt0"(+[python],+空间点#0)...
            ->+的(_结构,+在)->+的(_结构,+空间点#0)
}...

->[]{
    []:->[]{
    elif(if,块#1)->块#1->匹配(模块#1,块#1)->模块#1->的(_结构,模块#1)...
        ->的(模块#1,尺寸#1)->+[.]"siz11"(+[python],尺寸#1)...
        ->的(模块#1,组尺寸#1)->+[.]"siz1"(+[python],组尺寸#1):
            ->在(模块#1,空间点#1)->+[o]"pt1"(+[python],空间点#1),
        ->+在(模块#1,+空间点#1)->+[o]"pt1"(+[python],+空间点#1)...
            ->+的(_结构,+在)->+的(_结构,+空间点#1)
    },->+[.]"siz1"(+[python],+[临时文本]#1)->+[临时文本]#1"0,0"
}...

->[]{
    []:->[]{
    else(if,块#2)->块#2->匹配(模块#2,块#2)->模块#2->的(_结构,模块#2)...
        ->的(模块#2,尺寸#2)->+[.]"siz22"(+[python],尺寸#2)...
        ->的(模块#2,组尺寸#2)->+[.]"siz2"(+[python],组尺寸#2):
            ->在(模块#2,空间点#2)->+[o]"pt2"(+[python],空间点#2),
        ->+在(模块#2,+空间点#2)->+[o]"pt2"(+[python],+空间点#2)...
            ->+的(_结构,+在)->+的(_结构,+空间点#2)
    },->+[.]"siz2"(+[python],+[临时文本]#2)->+[临时文本]#2"0,0"
}


## end
#176, 200:
"""
P代码(P函数):...

"""

+画结构(_结构,块)->+[del](,+画结构)...
->的(画结构,P代码)...

->[]{
    []:->匹配(模块,块)->模块->的(_结构,模块),
        ->+匹配(+模块,块)->+的(+模块,+尺寸)->+尺寸"2,1"...
            ->+的(_结构,+模块)->+的(_结构,+匹配)
}



## end
#182, 500:
"""
P代码(P函数):...

"""

+画结构(_结构,块)->+[del](,+画结构)...
->的(画结构,P代码)...

->for(块,块#0)->匹配(模块,块)->模块->的(_结构,模块)...
    ->在(模块,空间点)->的(模块,尺寸)...

->+[python](Python,)->+[code](+[python],P代码)...
->+[.]"pt"(+[python],空间点)->+[.]"siz"(+[python],尺寸)...

->[]{
    匹配(模块#0,块#0)->模块#0->的(_结构,模块#0)...
        ->的(模块#0,尺寸#0)->+[.]"siz0"(+[python],尺寸#0):
            ->在(模块#0,空间点#0)->+[o]"pt0"(+[python],空间点#0),
        ->+在(模块#0,+空间点#0)->+[o]"pt0"(+[python],+空间点#0)...
            ->+的(_结构,+在)->+的(_结构,+空间点#0)
}


## end
#185, 502:
"""
P代码(P函数):...

"""

+画结构(_结构,块)->+[del](,+画结构)...
->的(画结构,P代码)...

->while(块,块#0)->匹配(模块,块)->模块->的(_结构,模块)...
    ->在(模块,空间点)->的(模块,尺寸)...

->+[python](Python,)->+[code](+[python],P代码)...
->+[.]"pt"(+[python],空间点)->+[.]"siz"(+[python],尺寸)...

->[]{
    匹配(模块#0,块#0)->模块#0->的(_结构,模块#0)...
        ->的(模块#0,尺寸#0)->+[.]"siz0"(+[python],尺寸#0):
            ->在(模块#0,空间点#0)->+[o]"pt0"(+[python],空间点#0),
        ->+在(模块#0,+空间点#0)->+[o]"pt0"(+[python],+空间点#0)...
            ->+的(_结构,+在)->+的(_结构,+空间点#0)
}


## end
#188, 778:
"""
P代码(P函数):

"""

+画结构(_结构,块)->+[del](,+画结构)...
->的(画结构,P代码)...

->try(块,块#0)->except(try,块#1)...
->匹配(模块,块)->模块->的(_结构,模块)...
    ->在(模块,空间点)->的(模块,尺寸)...

->+[python](Python,)->+[code](+[python],P代码)...
->+[.]"pt"(+[python],空间点)->+[.]"siz"(+[python],尺寸)...

->[]{
    匹配(模块#0,块#0)->模块#0->的(_结构,模块#0)...
        ->的(模块#0,尺寸#0)->+[.]"siz0"(+[python],尺寸#0):
            ->在(模块#0,空间点#0)->+[o]"pt0"(+[python],空间点#0),
        ->+在(模块#0,+空间点#0)->+[o]"pt0"(+[python],+空间点#0)...
            ->+的(_结构,+在)->+的(_结构,+空间点#0)
}...

->[]{
    匹配(模块#1,块#1)->模块#1->的(_结构,模块#1)...
        ->的(模块#1,尺寸#1)->+[.]"siz1"(+[python],尺寸#1):
            ->在(模块#1,空间点#1)->+[o]"pt1"(+[python],空间点#1),
        ->+在(模块#1,+空间点#1)->+[o]"pt1"(+[python],+空间点#1)...
            ->+的(_结构,+在)->+的(_结构,+空间点#1)
}



## end
#190, 499:
"""
P代码(P函数):

"""

+画结构(_结构,块)->+[del](,+画结构)...
->的(画结构,P代码)...

->class(块,块#0)->匹配(模块,块)->模块->的(_结构,模块)...
    ->在(模块,空间点)->的(模块,尺寸)...

->+[python](Python,)->+[code](+[python],P代码)...
->+[.]"pt"(+[python],空间点)->+[.]"siz"(+[python],尺寸)...

->[]{
    匹配(模块#0,块#0)->模块#0->的(_结构,模块#0)...
        ->的(模块#0,尺寸#0)->+[.]"siz0"(+[python],尺寸#0):
            ->在(模块#0,空间点#0)->+[o]"pt0"(+[python],空间点#0),
        ->+在(模块#0,+空间点#0)->+[o]"pt0"(+[python],+空间点#0)...
            ->+的(_结构,+在)->+的(_结构,+空间点#0)
}


## end
#193, 501:
"""
P代码(P函数):...

"""

+画结构(_结构,块)->+[del](,+画结构)...
->的(画结构,P代码)...

->func(块,块#0)->匹配(模块,块)->模块->的(_结构,模块)...
    ->的(模块,尺寸)->在(模块,空间点)...

->+[python](Python,)->+[code](+[python],P代码)...
->+[.]"pt"(+[python],空间点)->+[.]"siz"(+[python],尺寸)...

->[]{
    匹配(模块#0,块#0)->模块#0->的(_结构,模块#0)...
        ->的(模块#0,尺寸#0)->+[.]"siz0"(+[python],尺寸#0):
            ->在(模块#0,空间点#0)->+[o]"pt0"(+[python],空间点#0),
        ->+在(模块#0,+空间点#0)->+[o]"pt0"(+[python],+空间点#0)...
            ->+的(_结构,+在)->+的(_结构,+空间点#0)
}


## end
#196, 826:
"""
P代码(P函数):...
+[新建阅读窗口](,P代码)

保存:...

->匹配(模块,块)->模块->的(_结构,模块)...
    ->的(模块,尺寸)

"""

+画结构(_结构,块)->+[del](,+画结构)...
->的(画结构,P代码)...

->然后(块,_块#0)...

->+[python](Python,+空间点)->+[code](+[python],P代码)...

->[]{
    匹配(模块,块)->模块->的(_结构,模块)...
        ->的(模块,尺寸)->+[.]"siz"(+[python],尺寸):
            ->在(模块,空间点)->+[o]"pt"(+[python],空间点),
        ->+在(模块,+空间点)->+[o]"pt"(+[python],+空间点)...
            ->+的(_结构,+在)->+的(_结构,+空间点)
}:

->[is](_块#0,eof)...
    ->+[.]"pt0"(+[python],+[临时文本]#0)->+[临时文本]#0"0,0"...
    ->+[.]"siz0"(+[python],+[临时文本]#0)->+[临时文本]#0"0,0",

->[]{
    匹配(模块#0,_块#0)->模块#0->的(_结构,模块#0)...
        ->的(模块#0,尺寸#0)->+[.]"siz0"(+[python],尺寸#0):
            ->在(模块#0,空间点#0)->+[o]"pt0"(+[python],空间点#0),
        ->+在(模块#0,+空间点#0)->+[o]"pt0"(+[python],+空间点#0)...
            ->+的(_结构,+在)->+的(_结构,+空间点#0)
}




## end
#199, 121:
"""
记住"Python"

print(max(1,2))

"""
d=0.1
if len(pt)==0:
    pt=[0,0]
    print('????')

pt0=[pt[0],pt[1]-siz0[1]-d]




## end
#202, 65:
"""
+[P函数](,P代码)

"""

d=0.1
pt0=[pt[0]+d,pt[1]-d+siz[1]-siz0[1]]
## end
#205, 65:
"""
+[P函数](,P代码)

"""

d=0.1
pt0=[pt[0]+d,pt[1]-d+siz[1]-siz0[1]]
## end
#208, 87:
"""


"""
d=0.1
pt0=[pt[0]+d,pt[1]-d+siz[1]-siz0[1]]

pt1=[pt0[0]+siz0[0]+d,pt0[1]]




## end
#211, 67:
"""
+[P函数](,P代码)

"""

d=0.1
pt0=[pt[0]+d,pt[1]-d+siz[1]-siz0[1]]


## end
#214, 67:
"""
+[P函数](,P代码)

"""

d=0.1
pt0=[pt[0]+d,pt[1]-d+siz[1]-siz0[1]]


## end
#217, 213:
"""
+[P函数](,P代码)

"""

d=0.1
pt0=[pt[0]+d,pt[1]-d+siz[1]-siz00[1]]

if siz1[0]!=0:
    pt1=[pt0[0]+siz0[0]+d,pt0[1]-siz11[1]+siz00[1]]

if siz2[0]!=0:
    pt2=[pt0[0]+siz[0]-siz2[0]-2*d,pt0[1]-siz22[1]+siz00[1]]


## end
#220, 693:
"""
P代码(P函数):...
+[新建阅读窗口](,P代码)

"""

+画结构(_结构,elif#0)->+[del](,+画结构)...
->的(画结构,P代码)...

->elif#0(,块#0)->匹配(模块#0,块#0)->模块#0->的(_结构,模块#0)...
    ->在(模块#0,空间点#0)...

->+[python](Python,)->+[code](+[python],P代码)...
->+[.]"pt0"(+[python],空间点#0)...

->的(模块#0,尺寸#0)->尺寸#0->+[.]"siz00"(+[python],尺寸#0)...
->的(模块#0,组尺寸#0)->组尺寸#0->+[.]"siz0"(+[python],组尺寸#0)...

->[]{
    elif(elif#0,块#1)->块#1->匹配(模块#1,块#1)->模块#1->的(_结构,模块#1)...
        ->的(模块#1,尺寸#1)->+[.]"siz11"(+[python],尺寸#1)...
        ->的(模块#1,组尺寸#1)->+[.]"siz1"(+[python],组尺寸#1):
            ->在(模块#1,空间点#1)->+[o]"pt1"(+[python],空间点#1),
        ->+在(模块#1,+空间点#1)->+[o]"pt1"(+[python],+空间点#1)...
            ->+的(_结构,+在)->+的(_结构,+空间点#1)
}



## end
#221, 3:
488
## end
#224, 88:
"""
print(max(1,2,3))

"""

d=0.1

pt1=[pt0[0]+siz0[0]+d,pt0[1]-siz11[1]+siz00[1]]






## end
#226, 54:
"""


"""

+块尺寸(_结构,块)->+[del](,+块尺寸)...
->+[显示](,块)


## end
#228, 88:
"""
print(max(1,2,3))

"""

Dx=siz0[0]+siz1[0]+0.1
Dy=max(siz0[1],siz1[1])
siz=[Dx,Dy]


## end
#230, 508:
"""
P代码(P函数):
保存:...

"""

+画结构(_结构,elif#0)->+[del](,+画结构)...
->的(画结构,P代码)...

->elif#0(,块#0)->匹配(模块#0,块#0)->模块#0->的(_结构,模块#0)...
    ->的(模块#0,组尺寸)...

->+[python](Python,)->+[code](+[python],P代码)...
->+[.]"siz0"(+[python],组尺寸)...

->[]{
    []:->的(elif#0,块尺寸)->块尺寸->+[o]"siz"(+[python],块尺寸),
        ->+的(elif#0,+块尺寸)->+块尺寸->+[o]"siz"(+[python],+块尺寸)
}...

->[]{
    []:->elif(elif#0,)->的(elif,块尺寸#1)->块尺寸#1(,)...
        ->+[.]"siz1"(+[python],块尺寸#1),
    ->+[.]"siz1"(+[python],+[临时文本])->+[临时文本]"0,0"
}



## end
#232, 286:
"""
画结构:...

"""

+elif(_结构,elif)->+[del](,+elif)...
->的(elif#0,画结构)...

->elif(,块#0)...
->+[收集程序块尺寸]"程序"(,+[做]#0)->+[做]#0(_结构,块#0)...
->[]{
    []:->elif#1(elif,)...
            ->+[收集程序块尺寸]"elif"(,+[做]#1)->+[做]#1(_结构,elif#1),
        ->[]
}...

->+[做](_结构,elif)->+[code](+[做],画结构)




## end
#237, 247:
"""
P代码(P函数):...

"""

+画结构(_结构,块)->+[del](,+画结构)...
->的(画结构,P代码)...

->[]{
    []:->匹配(模块,块)->模块->的(_结构,模块)->+[修改内容](块,模块),
        ->+匹配(+模块,块)->+[修改内容](块,+模块)...
            ->+的(+模块,+尺寸)->+尺寸"2,1"...
            ->+的(_结构,+模块)->+的(_结构,+匹配)
}



## end
#239, 104:
"""
画结构(S函数):...

"""

+运算(_结构,块)->+[del](,+运算)...
->的(运算,画结构)...

->+[做](_结构,块)->+[code](+[做],画结构)





## end
#241, 55:
"""


"""
d=0.1
Dx=siz0[0]+d
Dy=siz0[1]+d
ans=[Dx,Dy]


## end
#244, 480:
"""
P代码(P函数):...

"""

+画结构(_结构,块)->+[del](,+画结构)...
->的(画结构,P代码)...

->for(块,块#0)->匹配(模块#0,块#0)->模块#0->的(_结构,模块#0)...
    ->的(模块#0,组尺寸)...

->+[python](Python,+尺寸)->+[code](+[python],P代码)...
    ->+[.]"siz0"(+[python],组尺寸)...

->[]{
    []:->匹配(模块,块)->模块->的(_结构,模块)->的(模块,尺寸)...
            ->+[修改内容]"for"(,模块)...
            ->+[修改内容](+尺寸,尺寸)->+[del](,+尺寸),
        ->+匹配(+模块,块)->+的(+模块,+尺寸)...
        ->+的(_结构,+模块)->+的(_结构,+匹配)...
            ->+模块"for"
}...

->+[del](,组尺寸)


## end
#246, 171:
"""
画结构(S函数):...

"""

+for(_结构,块)->+[del](,+for)...
->的(for#0,画结构)...

->for(块,块#0)...
->+[收集程序块尺寸]"程序"(,+[做]#0)->+[做]#0(_结构,块#0)...

->+[做](_结构,块)->+[code](+[做],画结构)




## end
#248, 57:
"""


"""
d=0.1
Dx=siz0[0]+2*d
Dy=siz0[1]+d
ans=[Dx,Dy]


## end
#251, 486:
"""
P代码(P函数):...

"""

+画结构(_结构,块)->+[del](,+画结构)...
->的(画结构,P代码)...

->while(块,块#0)->匹配(模块#0,块#0)->模块#0->的(_结构,模块#0)...
    ->的(模块#0,组尺寸)...

->+[python](Python,+尺寸)->+[code](+[python],P代码)...
    ->+[.]"siz0"(+[python],组尺寸)...

->[]{
    []:->匹配(模块,块)->模块->的(_结构,模块)->的(模块,尺寸)...
            ->+[修改内容]"while"(,模块)...
            ->+[修改内容](+尺寸,尺寸)->+[del](,+尺寸),
        ->+匹配(+模块,块)->+的(+模块,+尺寸)...
        ->+的(_结构,+模块)->+的(_结构,+匹配)...
            ->+模块"while"
}...

->+[del](,组尺寸)


## end
#253, 178:
"""
画结构(S函数):...

"""

+while(_结构,块)->+[del](,+while)...
->的(while#0,画结构)...

->while(块,块#0)...
->+[收集程序块尺寸]"程序"(,+[做]#0)->+[做]#0(_结构,块#0)...

->+[做](_结构,块)->+[code](+[做],画结构)



## end
#255, 73:
"""


"""

Dx=siz0[0]+siz1[0]+0.1
Dy=max(siz0[1],siz1[1])
ans=[Dx,Dy]




## end
#257, 601:
"""
P代码(P函数):

"""

+画结构(_结构,块)->+[del](,+画结构)...
->的(画结构,P代码)...

->try(块,块#0)->匹配(模块#0,块#0)->模块#0->的(_结构,模块#0)...
    ->的(模块#0,组尺寸#0)...
->except(try,块#1)->匹配(模块#1,块#1)->模块#1->的(_结构,模块#1)...
    ->的(模块#1,组尺寸#1)...

->+[python](Python,+尺寸)->+[code](+[python],P代码)...
->+[.]"siz0"(+[python],组尺寸#0)->+[.]"siz1"(+[python],组尺寸#1)...

->[]{
    []:->匹配(模块,块)->模块->的(_结构,模块)->的(模块,尺寸)...
            ->+[修改内容]"try"(,模块)...
            ->+[修改内容](+尺寸,尺寸)->+[del](,+尺寸),
        ->+匹配(+模块,块)->+的(+模块,+尺寸)...
        ->+的(_结构,+模块)->+的(_结构,+匹配)...
            ->+模块"try"
}...

->+[del](,组尺寸#0)->+[del](,组尺寸#1)


## end
#259, 234:
"""
画结构:...

"""

+try(_结构,块)->+[del](,+try)...
->的(try#0,画结构)...

->try(块,块#0)...
->+[收集程序块尺寸]"程序"(,+[做]#0)->+[做]#0(_结构,块#0)...

->except(try,块#1)...
->+[收集程序块尺寸]"程序"(,+[做]#1)->+[做]#1(_结构,块#1)...

->+[做](_结构,块)->+[code](+[做],画结构)




## end
#261, 56:
"""


"""
d=0.1
Dx=siz0[0]+2*d
Dy=siz0[1]+d
ans=[Dx,Dy]

## end
#264, 506:
"""
P代码(P函数):...

"""

+画结构(_结构,块)->+[del](,+画结构)...
->的(画结构,P代码)...

->class(块,块#0)->匹配(模块#0,块#0)->模块#0->的(_结构,模块#0)...
    ->的(模块#0,组尺寸)...

->+[python](Python,+尺寸)->+[code](+[python],P代码)...
    ->+[.]"siz0"(+[python],组尺寸)...

->[]{
    []:->匹配(模块,块)->模块->的(_结构,模块)->的(模块,尺寸)...
            ->+[修改内容](class,模块)...
            ->+[修改内容](+尺寸,尺寸)->+[消息窗口](,尺寸)->+[del](,+尺寸),
        ->+匹配(+模块,块)->+的(+模块,+尺寸)...
        ->+的(_结构,+模块)->+的(_结构,+匹配)...
            ->+[修改内容](class,+模块)
}...

->+[del](,组尺寸)


## end
#266, 178:
"""
画结构(S函数):...

"""

+class(_结构,块)->+[del](,+class)...
->的(class#0,画结构)...

->class(块,块#0)...
->+[收集程序块尺寸]"程序"(,+[做]#0)->+[做]#0(_结构,块#0)...

->+[做](_结构,块)->+[code](+[做],画结构)



## end
#268, 55:
"""


"""
d=0.1
Dx=siz0[0]+d
Dy=siz0[1]+d
ans=[Dx,Dy]


## end
#271, 489:
"""
P代码(P函数):...

"""

+画结构(_结构,块)->+[del](,+画结构)...
->的(画结构,P代码)...

->func(块,块#0)->匹配(模块#0,块#0)->模块#0->的(_结构,模块#0)...
    ->的(模块#0,组尺寸)...

->+[python](Python,+尺寸)->+[code](+[python],P代码)...
    ->+[.]"siz0"(+[python],组尺寸)...

->[]{
    []:->匹配(模块,块)->模块->的(_结构,模块)->的(模块,尺寸)...
            ->+[修改内容](func,模块)...
            ->+[修改内容](+尺寸,尺寸)->+[del](,+尺寸),
        ->+匹配(+模块,块)->+的(+模块,+尺寸)...
        ->+的(_结构,+模块)->+的(_结构,+匹配)...
            ->+[修改内容](func,+模块)
}...

->+[del](,组尺寸)


## end
#273, 172:
"""
画结构(S函数):...

"""

+def(_结构,块)->+[del](,+def)...
->的(def#0,画结构)...

->func(块,块#0)...
->+[收集程序块尺寸]"程序"(,+[做]#0)->+[做]#0(_结构,块#0)...

->+[做](_结构,块)->+[code](+[做],画结构)




## end
#275, 104:
"""
print(max(1,2,3))

"""

Dx=siz0[0]+siz1[0]+siz2[0]+0.2
Dy=max(siz0[1],siz1[1],siz2[1])
ans=[Dx,Dy]


## end
#278, 746:
"""
P代码(P函数):...
保存:...

"""

+画结构(_结构,块)->+[del](,+画结构)...
->的(画结构,P代码)...

->if(块,块#0)->匹配(模块#0,块#0)->模块#0->的(_结构,模块#0)...
    ->的(模块#0,组尺寸)...

->+[python](Python,+尺寸)->+[code](+[python],P代码)...
->+[.]"siz0"(+[python],组尺寸)...

->[]{
    []:->elif(if,)->的(elif,块尺寸#1)->块尺寸#1(,)...
        ->+[.]"siz1"(+[python],块尺寸#1),
    ->+[.]"siz1"(+[python],+[临时文本])->+[临时文本]"0,0"
}...

->[]{
    []:->else(if,块#2)->块#2->匹配(模块#2,块#2)->模块#2->的(_结构,模块#2)...
        ->的(模块#2,组尺寸#2)...
        ->+[.]"siz2"(+[python],组尺寸#2),
    ->+[.]"siz2"(+[python],+[临时文本])->+[临时文本]"0,0"
}...

->[]{
    []:->匹配(模块,块)->模块->的(_结构,模块)...
        ->+[修改内容]"if"(,模块)...
        ->+[del](,+尺寸),
    ->+匹配(+模块,块)->+模块"if"->+的(+模块,+尺寸)...
        ->+的(_结构,+模块)->+的(_结构,+匹配)
}



## end
#280, 393:
"""
画结构(S函数):...
+[新建阅读窗口](,画结构)

"""

+if(_结构,块)->+[del](,+if)...
->的(if#0,画结构)...

->if(块,块#0)...
->+[收集程序块尺寸]"程序"(,+[做]#0)->+[做]#0(_结构,块#0)...
->[]{
    []:->elif(if,)...
            ->+[收集程序块尺寸]"elif"(,+[做]#1)->+[做]#1(_结构,elif),
        ->[]
}...
->[]{
    []:->else(if,块#2)->块#2(,)...
        ->+[收集程序块尺寸]"程序"(,+[做]#2)->+[做]#2(_结构,块#2),
    ->[]
}...

->+[做](_结构,块)->+[code](+[做],画结构)




## end
#281, 437:
"""


"""

+语句(_结构,块)->+[del](,+语句)...

->[]:
    ->if(块,)->+[收集程序块尺寸]"if"(,+[做]#0)->+[做]#0(_结构,块),
    ->func(块,)->+[收集程序块尺寸]"def"(,+[做]#1)->+[做]#1(_结构,块),
    ->while(块,)->+[收集程序块尺寸]"while"(,+[做]#2)->+[做]#2(_结构,块),
    ->for(块,)->+[收集程序块尺寸]"for"(,+[做]#3)->+[做]#3(_结构,块),
    ->try(块,)->+[收集程序块尺寸]"try"(,+[做]#4)->+[做]#4(_结构,块),
    ->class(块,)->+[收集程序块尺寸]"class"(,+[做]#5)->+[做]#5(_结构,块),
    ->+[收集程序块尺寸]"运算"(,+[做]#6)->+[做]#6(_结构,块)




## end
#283, 99:
"""
记住"Python"

print(max(1,2))

"""

Dx=max(siz0[0],siz1[0])
Dy=siz0[1]+siz1[1]+0.1
ans=[Dx,Dy]



## end
#286, 494:
"""
P代码(P函数):...

"""

+画结构(_结构,块)->+[del](,+画结构)...
->的(画结构,P代码)...

->匹配(模块,块)->模块->的(_结构,模块)->的(模块,尺寸)...
->+的(模块,+组尺寸)...
    ->+[python](Python,+组尺寸)->+[code](+[python],P代码)...
    ->+[.]"siz1"(+[python],尺寸)...

->[]:
->然后(块,块#0)->匹配(模块#0,块#0)->模块#0->的(_结构,模块#0)...
    ->[]{
        []:->的(模块#0,组尺寸)->组尺寸->+[.]"siz0"(+[python],组尺寸)->+[del](,组尺寸),
            ->的(模块#0,尺寸#0)->尺寸#0->+[.]"siz0"(+[python],尺寸#0)
        },
    ->然后(块,eof)->+[.]"siz0"(+[python],+[临时文本])->+[临时文本]"2.1,0.05"




## end
#288, 233:
"""
画结构(S函数):...

"""

+程序(_结构,块)->+[del](,+程序)...
->的(程序,画结构)...

->+[收集程序块尺寸]"语句"(,+[做])->+[做](_结构,块)...
->[]{
    []:->然后(块,块#1)->块#1->+[收集程序块尺寸]"程序"(,+[做]#1)->+[做]#1(_结构,块#1),
        ->[]
}...

->+[做](_结构,块)->+[code](+[做],画结构)


## end
#300, 147:


块尺寸:...

程序:...
语句:...
语句的"程序"替换为"语句"

if:...
elif:...
+[新建阅读窗口](,if)

def:...
class:...
+[新建阅读窗口](,class)

try:...
while:...
for:...

运算:...




## end
#302, 150:
"""
库:...
+[新建阅读窗口](,库)

"""

+收集程序块尺寸(,做)->+[del](,+收集程序块尺寸)...
->的(收集程序块尺寸,库)->的(库,_段落)...
->[标题](_段落,)->[==](+收集程序块尺寸,[标题])...
    ->+code(做,_段落)


## end
#304, 4:
1613
## end
#307, 522:
"""
P代码(P函数):...
+[新建阅读窗口](,P代码)

保存:...

"""

+画结构(_结构,块)->+[del](,+画结构)...
->的(画结构,P代码)...

->匹配(模块,块)->模块->的(_结构,模块)->的(模块,尺寸)...
->在(模块,空间点)...
    ->+[python](Python,+空间点)->+[code](+[python],P代码)...
    ->+[.]"siz"(+[python],尺寸)->+[.]"pt"(+[python],空间点)...

->然后(块,块#0)->匹配(模块#0,块#0)->模块#0->的(_结构,模块#0)...
    ->的(模块#0,尺寸#0)->+[.]"siz0"(+[python],尺寸#0)->[]{
        []:->在(模块#0,空间点)->空间点(,)...
            ->+[修改内容](+空间点,空间点)->+[del](,+空间点),
        ->+在(模块#0,+空间点)...
            ->+的(_结构,+在)->+的(_结构,+空间点)
    }




## end
#308, 8:
0.0, 1.0
## end
#309, 8:
0.0, 1.0
## end
#310, 8:
0.0, 1.0
## end
#311, 8:
0.0, 1.0
## end
#312, 8:
0.0, 1.0
## end
#313, 8:
0.0, 1.0
## end
#314, 8:
0.0, 1.0
## end
#315, 8:
0.0, 1.0
## end
#316, 8:
0.0, 1.0
## end
#317, 8:
0.0, 1.0
## end
#318, 8:
0.0, 1.0
## end
#319, 8:
0.0, 1.0
## end
#320, 38:
13.399999999999999, 2.5500000000000003
## end
#321, 38:
13.399999999999999, 2.5500000000000003
## end
#322, 38:
13.399999999999999, 2.5500000000000003
## end
#323, 38:
13.399999999999999, 2.5500000000000003
## end
#324, 38:
13.399999999999999, 2.5500000000000003
## end
#325, 38:
13.399999999999999, 2.5500000000000003
## end
#326, 38:
13.399999999999999, 2.5500000000000003
## end
#327, 38:
13.399999999999999, 2.5500000000000003
## end
#328, 38:
13.399999999999999, 2.5500000000000003
## end
#329, 38:
13.399999999999999, 2.5500000000000003
## end
#330, 38:
13.399999999999999, 2.5500000000000003
## end
#331, 38:
13.399999999999999, 2.5500000000000003
## end
#333, 181:
"""


"""
+删除场景结构(,_结构)->+[del](,+删除场景结构)...
=>的(_结构,_图形)=>+[del](,_图形)&:
    =>的(_图形,_性质)=>+[del](,_性质),
    =>匹配(_图形,)=>+[del](,匹配),
    =>在(_图形,空间点)=>+[del](,在)->+[del](,空间点)




## end
#335, 132:
"""


"""

+生成程序结构(_块,_图形)->+[del](,+生成程序结构)...

->+[收集程序块尺寸]"程序"(,+[做])->+[做](_图形,_块)...
->+[设置程序块位置]"程序"(,+[做]#1)->+[做]#1(_图形,_块)

## end
#336, 38:
13.399999999999999, 2.5500000000000003
## end
#337, 38:
13.399999999999999, 2.5500000000000003
## end
#338, 38:
13.399999999999999, 2.5500000000000003
## end
#339, 38:
13.399999999999999, 2.5500000000000003
## end
#340, 38:
13.399999999999999, 2.5500000000000003
## end
#341, 38:
13.399999999999999, 2.5500000000000003
## end
#342, 38:
13.399999999999999, 2.5500000000000003
## end
#343, 38:
13.399999999999999, 2.5500000000000003
## end
#345, 117:
+[显示星图](,结构场景)
+[显示PPT场景]"2"(,图形)

图形::
+[设置结构](,图形)
+[删除场景结构](,图形)

起点(,块)->+[生成程序结构](块,图形)->+[显示PPT场景]"1"(,图形)





## end
#346, 24:
36.7, 27.350000000000012
## end
#347, 24:
36.7, 27.350000000000012
## end
#348, 24:
36.7, 27.350000000000012
## end
#349, 24:
36.7, 27.350000000000012
## end
#350, 24:
36.7, 23.600000000000005
## end
#351, 8:
2.0, 1.0
## end
#352, 8:
2.0, 1.0
## end
#353, 8:
2.0, 1.0
## end
#354, 8:
2.0, 1.0
## end
#355, 8:
2.0, 1.0
## end
#356, 8:
2.0, 1.0
## end
#357, 8:
2.0, 1.0
## end
#358, 8:
2.0, 1.0
## end
#359, 23:
4.4, 1.1500000000000001
## end
#360, 23:
4.4, 1.1500000000000001
## end
#361, 23:
4.4, 1.1500000000000001
## end
#362, 23:
4.4, 1.1500000000000001
## end
#363, 23:
4.4, 1.1500000000000001
## end
#364, 23:
4.4, 1.1500000000000001
## end
#365, 23:
4.4, 1.1500000000000001
## end
#366, 23:
4.4, 1.1500000000000001
## end
#367, 23:
4.4, 1.1500000000000001
## end
#368, 23:
4.4, 1.1500000000000001
## end
#369, 23:
4.4, 1.1500000000000001
## end
#370, 23:
4.4, 1.1500000000000001
## end
#371, 23:
4.4, 1.1500000000000001
## end
#372, 23:
4.4, 1.1500000000000001
## end
#373, 23:
4.4, 1.1500000000000001
## end
#374, 23:
4.4, 1.1500000000000001
## end
#375, 23:
4.4, 1.1500000000000001
## end
#376, 23:
4.4, 1.1500000000000001
## end
#377, 37:
9.200000000000001, 1.3000000000000003
## end
#378, 37:
9.200000000000001, 1.3000000000000003
## end
#379, 37:
9.200000000000001, 1.3000000000000003
## end
#380, 37:
9.200000000000001, 1.3000000000000003
## end
#381, 37:
9.200000000000001, 1.3000000000000003
## end
#382, 37:
9.200000000000001, 1.3000000000000003
## end
#383, 37:
9.200000000000001, 1.3000000000000003
## end
#384, 37:
9.200000000000001, 1.3000000000000003
## end
#385, 37:
9.200000000000001, 1.3000000000000003
## end
#386, 37:
9.200000000000001, 1.3000000000000003
## end
#387, 37:
9.200000000000001, 1.3000000000000003
## end
#388, 37:
9.200000000000001, 1.3000000000000003
## end
#389, 37:
9.200000000000001, 1.3000000000000003
## end
#390, 37:
9.200000000000001, 1.3000000000000003
## end
#391, 37:
9.200000000000001, 1.3000000000000003
## end
#392, 37:
9.200000000000001, 1.3000000000000003
## end
#393, 37:
9.200000000000001, 1.3000000000000003
## end
#394, 37:
9.200000000000001, 1.3000000000000003
## end
#395, 37:
9.200000000000001, 1.3000000000000003
## end
#396, 37:
9.200000000000001, 1.3000000000000003
## end
#397, 37:
9.200000000000001, 1.3000000000000003
## end
#398, 37:
9.200000000000001, 1.3000000000000003
## end
#399, 37:
9.200000000000001, 1.3000000000000003
## end
#400, 37:
9.200000000000001, 1.3000000000000003
## end
#401, 37:
9.200000000000001, 1.3000000000000003
## end
#402, 37:
9.200000000000001, 1.3000000000000003
## end
#403, 37:
9.200000000000001, 1.3000000000000003
## end
#404, 37:
9.200000000000001, 1.3000000000000003
## end
#405, 37:
9.200000000000001, 1.3000000000000003
## end
#406, 37:
9.200000000000001, 1.3000000000000003
## end
#407, 37:
9.200000000000001, 1.3000000000000003
## end
#408, 37:
9.200000000000001, 1.3000000000000003
## end
#409, 37:
9.200000000000001, 1.3000000000000003
## end
#410, 37:
9.200000000000001, 1.3000000000000003
## end
#411, 37:
9.200000000000001, 1.3000000000000003
## end
#412, 37:
9.200000000000001, 1.3000000000000003
## end
#413, 37:
9.200000000000001, 1.3000000000000003
## end
#414, 37:
9.200000000000001, 1.3000000000000003
## end
#415, 37:
9.200000000000001, 1.3000000000000003
## end
#416, 37:
9.200000000000001, 1.3000000000000003
## end
#417, 37:
9.200000000000001, 1.3000000000000003
## end
#418, 37:
9.200000000000001, 1.3000000000000003
## end
#419, 37:
9.200000000000001, 1.3000000000000003
## end
#420, 37:
9.200000000000001, 1.3000000000000003
## end
#421, 37:
9.200000000000001, 1.3000000000000003
## end
#422, 37:
9.200000000000001, 1.3000000000000003
## end
#423, 37:
9.200000000000001, 1.3000000000000003
## end
#424, 37:
9.200000000000001, 1.3000000000000003
## end
#425, 37:
9.200000000000001, 1.3000000000000003
## end
#426, 37:
9.200000000000001, 1.3000000000000003
## end
#427, 37:
9.200000000000001, 1.3000000000000003
## end
#428, 37:
9.200000000000001, 1.3000000000000003
## end
#429, 37:
9.200000000000001, 1.3000000000000003
## end
#430, 37:
9.200000000000001, 1.3000000000000003
## end
#431, 37:
9.200000000000001, 1.3000000000000003
## end
#432, 37:
9.200000000000001, 1.3000000000000003
## end
#433, 8:
2.0, 1.0
## end
#434, 8:
2.0, 1.0
## end
#435, 8:
2.0, 1.0
## end
#436, 23:
2.1, 1.1500000000000001
## end
#437, 8:
2.0, 1.0
## end
#438, 23:
2.1, 3.8000000000000003
## end
#439, 23:
2.1, 3.8000000000000003
## end
#440, 23:
2.1, 3.8000000000000003
## end
#441, 23:
2.1, 3.8000000000000003
## end
#442, 23:
2.1, 3.8000000000000003
## end
#443, 23:
2.1, 3.8000000000000003
## end
#444, 23:
2.1, 3.8000000000000003
## end
#445, 23:
2.1, 3.8000000000000003
## end
#446, 23:
2.1, 3.8000000000000003
## end
#447, 23:
2.1, 3.8000000000000003
## end
#448, 23:
2.1, 3.8000000000000003
## end
#449, 23:
2.1, 3.8000000000000003
## end
#450, 23:
2.1, 3.8000000000000003
## end
#451, 23:
2.1, 3.8000000000000003
## end
#452, 23:
2.1, 3.8000000000000003
## end
#453, 23:
2.1, 3.8000000000000003
## end
#454, 23:
2.1, 3.8000000000000003
## end
#455, 23:
2.1, 3.8000000000000003
## end
#456, 23:
2.1, 3.8000000000000003
## end
#457, 23:
2.1, 3.8000000000000003
## end
#458, 23:
2.1, 3.8000000000000003
## end
#459, 23:
2.1, 3.8000000000000003
## end
#460, 23:
2.1, 3.8000000000000003
## end
#461, 23:
2.1, 3.8000000000000003
## end
#462, 23:
2.1, 3.8000000000000003
## end
#463, 23:
2.1, 3.8000000000000003
## end
#464, 23:
2.1, 3.8000000000000003
## end
#465, 23:
2.1, 3.8000000000000003
## end
#466, 23:
2.1, 3.8000000000000003
## end
#467, 23:
2.1, 3.8000000000000003
## end
#468, 23:
2.3000000000000003, 4.0
## end
#469, 23:
2.3000000000000003, 4.0
## end
#470, 23:
2.3000000000000003, 4.0
## end
#471, 23:
2.3000000000000003, 4.0
## end
#472, 23:
2.3000000000000003, 4.0
## end
#473, 23:
2.3000000000000003, 4.0
## end
#474, 23:
2.3000000000000003, 4.0
## end
#475, 23:
2.3000000000000003, 4.0
## end
#476, 23:
2.3000000000000003, 4.0
## end
#477, 23:
2.3000000000000003, 4.0
## end
#478, 23:
2.3000000000000003, 4.0
## end
#479, 23:
2.3000000000000003, 4.0
## end
#480, 23:
2.3000000000000003, 4.0
## end
#481, 23:
2.3000000000000003, 4.0
## end
#482, 23:
2.3000000000000003, 4.0
## end
#483, 23:
2.3000000000000003, 4.0
## end
#484, 23:
2.3000000000000003, 4.0
## end
#485, 23:
2.5000000000000004, 4.4
## end
#486, 23:
2.5000000000000004, 4.4
## end
#487, 23:
2.5000000000000004, 4.4
## end
#488, 23:
2.5000000000000004, 4.4
## end
#489, 23:
2.5000000000000004, 4.4
## end
#490, 24:
2.3000000000000003, 1.75
## end
#491, 24:
2.3000000000000003, 1.75
## end
#492, 24:
2.3000000000000003, 1.75
## end
#493, 24:
2.3000000000000003, 1.75
## end
#494, 24:
2.3000000000000003, 1.75
## end
#495, 24:
2.3000000000000003, 1.75
## end
#496, 24:
2.3000000000000003, 1.75
## end
#497, 24:
2.3000000000000003, 1.75
## end
#498, 24:
2.3000000000000003, 1.75
## end
#499, 24:
2.3000000000000003, 1.75
## end
#500, 24:
2.3000000000000003, 1.75
## end
#501, 24:
2.3000000000000003, 1.75
## end
#502, 23:
2.4000000000000004, 4.2
## end
#503, 23:
2.4000000000000004, 4.2
## end
#504, 23:
2.4000000000000004, 4.2
## end
#505, 23:
2.4000000000000004, 4.2
## end
#506, 23:
2.4000000000000004, 4.2
## end
#507, 38:
2.4000000000000004, 4.1000000000000005
## end
#508, 38:
2.4000000000000004, 4.1000000000000005
## end
#509, 38:
2.4000000000000004, 4.1000000000000005
## end
#510, 38:
2.4000000000000004, 4.1000000000000005
## end
#511, 38:
2.4000000000000004, 4.1000000000000005
## end
#512, 23:
2.1, 3.6500000000000004
## end
#513, 8:
2.0, 1.0
## end
#514, 8:
2.0, 1.0
## end
#515, 8:
2.0, 1.0
## end
#516, 23:
2.1, 3.6500000000000004
## end
#517, 8:
2.0, 1.0
## end
#518, 8:
2.0, 1.0
## end
#519, 8:
2.0, 1.0
## end
#520, 23:
2.1, 3.6500000000000004
## end
#521, 8:
2.0, 1.0
## end
#522, 8:
2.0, 1.0
## end
#523, 8:
2.0, 1.0
## end
#524, 23:
2.1, 3.6500000000000004
## end
#525, 23:
2.1, 3.6500000000000004
## end
#526, 23:
2.1, 3.6500000000000004
## end
#527, 23:
2.1, 3.6500000000000004
## end
#528, 8:
2.0, 1.0
## end
#529, 23:
2.1, 3.6500000000000004
## end
#530, 23:
2.1, 3.6500000000000004
## end
#531, 23:
2.1, 3.6500000000000004
## end
#532, 23:
2.1, 3.6500000000000004
## end
#533, 23:
2.1, 3.6500000000000004
## end
#534, 23:
2.1, 3.6500000000000004
## end
#535, 23:
2.1, 3.6500000000000004
## end
#536, 23:
2.1, 3.6500000000000004
## end
#537, 23:
2.1, 3.6500000000000004
## end
#538, 23:
2.1, 3.6500000000000004
## end
#539, 23:
2.2, 3.7500000000000004
## end
#540, 23:
2.2, 3.7500000000000004
## end
#541, 23:
2.2, 3.7500000000000004
## end
#542, 23:
2.2, 3.7500000000000004
## end
#543, 38:
2.3000000000000003, 3.8500000000000005
## end
#544, 38:
2.3000000000000003, 3.8500000000000005
## end
#545, 38:
2.3000000000000003, 3.8500000000000005
## end
#546, 38:
2.3000000000000003, 3.8500000000000005
## end
#547, 38:
2.4000000000000004, 3.8500000000000005
## end
#548, 38:
2.4000000000000004, 3.8500000000000005
## end
#549, 38:
2.4000000000000004, 3.8500000000000005
## end
#550, 38:
2.4000000000000004, 3.8500000000000005
## end
#551, 37:
37.00000000000001, 27.750000000000014
## end
#552, 37:
37.00000000000001, 27.750000000000014
## end
#553, 37:
37.00000000000001, 27.750000000000014
## end
#554, 37:
37.00000000000001, 27.750000000000014
## end
#555, 37:
37.00000000000001, 27.750000000000014
## end
#556, 37:
37.00000000000001, 27.750000000000014
## end
#557, 37:
37.00000000000001, 27.750000000000014
## end
#558, 37:
37.00000000000001, 27.750000000000014
## end
#559, 37:
37.00000000000001, 27.750000000000014
## end
#560, 37:
37.00000000000001, 27.750000000000014
## end
#561, 37:
37.00000000000001, 27.750000000000014
## end
#562, 37:
37.00000000000001, 27.750000000000014
## end
#563, 37:
37.00000000000001, 27.750000000000014
## end
#564, 37:
37.00000000000001, 27.750000000000014
## end
#565, 37:
37.00000000000001, 27.750000000000014
## end
#566, 37:
37.00000000000001, 27.750000000000014
## end
#567, 37:
37.00000000000001, 27.750000000000014
## end
#568, 37:
37.00000000000001, 27.750000000000014
## end
#569, 37:
37.00000000000001, 27.750000000000014
## end
#570, 37:
37.00000000000001, 27.750000000000014
## end
#571, 37:
37.00000000000001, 27.750000000000014
## end
#572, 37:
37.00000000000001, 27.750000000000014
## end
#573, 37:
37.00000000000001, 27.750000000000014
## end
#574, 37:
37.00000000000001, 27.750000000000014
## end
#575, 37:
37.00000000000001, 27.750000000000014
## end
#576, 37:
37.00000000000001, 27.750000000000014
## end
#577, 37:
37.00000000000001, 27.750000000000014
## end
#578, 37:
37.00000000000001, 27.750000000000014
## end
#579, 37:
37.00000000000001, 27.750000000000014
## end
#580, 37:
37.00000000000001, 27.750000000000014
## end
#581, 37:
37.00000000000001, 27.750000000000014
## end
#582, 37:
37.00000000000001, 27.750000000000014
## end
#583, 37:
37.00000000000001, 27.750000000000014
## end
#584, 37:
37.00000000000001, 27.750000000000014
## end
#585, 37:
37.00000000000001, 27.750000000000014
## end
#586, 37:
37.00000000000001, 27.750000000000014
## end
#587, 37:
37.00000000000001, 27.750000000000014
## end
#588, 37:
37.00000000000001, 27.750000000000014
## end
#589, 37:
37.00000000000001, 27.750000000000014
## end
#590, 37:
37.00000000000001, 27.750000000000014
## end
#591, 37:
37.00000000000001, 27.750000000000014
## end
#592, 37:
37.00000000000001, 27.750000000000014
## end
#593, 37:
37.00000000000001, 27.750000000000014
## end
#594, 37:
37.00000000000001, 27.750000000000014
## end
#595, 37:
37.00000000000001, 27.750000000000014
## end
#596, 37:
37.00000000000001, 27.750000000000014
## end
#597, 37:
37.00000000000001, 27.750000000000014
## end
#598, 37:
37.00000000000001, 27.750000000000014
## end
#599, 37:
37.00000000000001, 27.750000000000014
## end
#600, 37:
37.00000000000001, 27.750000000000014
## end
#601, 37:
37.00000000000001, 27.750000000000014
## end
#602, 37:
37.00000000000001, 27.750000000000014
## end
#603, 37:
37.00000000000001, 27.750000000000014
## end
#604, 37:
37.00000000000001, 27.750000000000014
## end
#605, 37:
37.00000000000001, 27.750000000000014
## end
#606, 37:
37.00000000000001, 27.750000000000014
## end
#607, 37:
37.00000000000001, 27.750000000000014
## end
#608, 37:
37.00000000000001, 27.750000000000014
## end
#609, 37:
37.00000000000001, 27.750000000000014
## end
#610, 37:
37.00000000000001, 27.750000000000014
## end
#611, 37:
37.00000000000001, 27.750000000000014
## end
#612, 37:
37.00000000000001, 27.750000000000014
## end
#613, 37:
37.00000000000001, 27.750000000000014
## end
#614, 37:
37.00000000000001, 27.750000000000014
## end
#615, 37:
37.00000000000001, 27.750000000000014
## end
#616, 37:
37.00000000000001, 27.750000000000014
## end
#617, 37:
37.00000000000001, 27.750000000000014
## end
#618, 37:
37.00000000000001, 27.750000000000014
## end
#619, 37:
37.00000000000001, 27.750000000000014
## end
#620, 37:
37.00000000000001, 27.750000000000014
## end
#621, 37:
37.00000000000001, 27.750000000000014
## end
#622, 37:
37.00000000000001, 27.750000000000014
## end
#623, 37:
37.00000000000001, 27.750000000000014
## end
#624, 37:
37.00000000000001, 27.750000000000014
## end
#625, 37:
37.00000000000001, 27.750000000000014
## end
#626, 37:
37.00000000000001, 27.750000000000014
## end
#627, 37:
37.00000000000001, 27.750000000000014
## end
#628, 37:
37.00000000000001, 27.750000000000014
## end
#629, 37:
37.00000000000001, 27.750000000000014
## end
#630, 37:
37.00000000000001, 27.750000000000014
## end
#631, 37:
37.00000000000001, 27.750000000000014
## end
#632, 37:
37.00000000000001, 27.750000000000014
## end
#633, 37:
37.00000000000001, 27.750000000000014
## end
#634, 37:
37.00000000000001, 27.750000000000014
## end
#635, 37:
37.00000000000001, 27.750000000000014
## end
#636, 37:
37.00000000000001, 27.750000000000014
## end
#637, 37:
37.00000000000001, 27.750000000000014
## end
#638, 4:
2509
## end
#640, 38:
13.399999999999999, 2.5500000000000003
## end
#641, 38:
13.399999999999999, 2.5500000000000003
## end
#642, 38:
13.399999999999999, 2.5500000000000003
## end
#643, 38:
13.399999999999999, 2.5500000000000003
## end
#644, 38:
13.399999999999999, 2.5500000000000003
## end
#645, 38:
13.399999999999999, 2.5500000000000003
## end
#646, 38:
13.399999999999999, 2.5500000000000003
## end
#647, 38:
13.399999999999999, 2.5500000000000003
## end
#648, 23:
20.099999999999998, 2.7
## end
#649, 23:
20.099999999999998, 2.7
## end
#650, 23:
20.099999999999998, 2.7
## end
#651, 23:
20.099999999999998, 2.7
## end
#652, 23:
20.099999999999998, 2.7
## end
#653, 23:
20.099999999999998, 2.7
## end
#654, 23:
20.099999999999998, 2.7
## end
#655, 23:
20.099999999999998, 2.7
## end
#656, 23:
20.099999999999998, 2.7
## end
#657, 23:
20.099999999999998, 2.7
## end
#658, 23:
20.099999999999998, 2.7
## end
#659, 23:
20.099999999999998, 2.7
## end
#660, 9:
22.3, 2.7
## end
#661, 9:
22.3, 2.7
## end
#662, 9:
22.3, 2.7
## end
#663, 9:
22.3, 2.7
## end
#664, 9:
22.3, 2.7
## end
#665, 9:
22.3, 2.7
## end
#666, 9:
22.3, 2.7
## end
#667, 9:
22.3, 2.7
## end
#668, 9:
22.3, 2.7
## end
#669, 9:
22.3, 2.7
## end
#670, 9:
22.3, 2.7
## end
#671, 9:
22.3, 2.7
## end
#672, 9:
22.3, 2.7
## end
#673, 9:
24.7, 2.7
## end
#674, 9:
24.7, 2.7
## end
#675, 9:
24.7, 2.7
## end
#676, 9:
24.7, 2.7
## end
#677, 9:
24.7, 2.7
## end
#678, 9:
24.7, 2.7
## end
#679, 9:
24.7, 2.7
## end
#680, 9:
24.7, 2.7
## end
#681, 9:
24.7, 2.7
## end
#682, 9:
24.7, 2.7
## end
#683, 9:
24.7, 2.7
## end
#684, 9:
24.7, 2.7
## end
#685, 9:
24.7, 2.7
## end
#686, 9:
24.7, 2.7
## end
#687, 9:
24.7, 2.7
## end
#688, 9:
24.7, 2.7
## end
#689, 9:
24.7, 2.7
## end
#690, 9:
24.7, 2.7
## end
#691, 9:
24.7, 2.7
## end
#692, 9:
24.7, 2.7
## end
#693, 9:
24.7, 2.7
## end
#694, 9:
24.7, 2.7
## end
#695, 9:
24.7, 2.7
## end
#696, 9:
24.7, 2.7
## end
#697, 9:
24.7, 2.7
## end
#698, 9:
24.7, 2.7
## end
#699, 9:
24.7, 2.7
## end
#700, 9:
24.7, 2.7
## end
#701, 9:
24.7, 2.7
## end
#702, 9:
24.7, 2.7
## end
#703, 9:
24.7, 2.7
## end
#704, 9:
24.7, 2.7
## end
#705, 9:
24.7, 2.7
## end
#706, 9:
24.7, 2.7
## end
#707, 9:
24.7, 2.7
## end
#708, 9:
24.7, 2.7
## end
#709, 9:
24.7, 2.7
## end
#710, 9:
24.7, 2.7
## end
#711, 9:
24.7, 2.7
## end
#712, 9:
24.7, 2.7
## end
#713, 9:
24.7, 2.7
## end
#714, 9:
24.7, 2.7
## end
#715, 9:
24.7, 2.7
## end
#716, 9:
24.7, 2.7
## end
#717, 9:
24.7, 2.7
## end
#718, 9:
24.7, 2.7
## end
#719, 9:
24.7, 2.7
## end
#720, 9:
24.7, 2.7
## end
#721, 9:
24.7, 2.7
## end
#722, 9:
24.7, 2.7
## end
#723, 9:
24.7, 2.7
## end
#724, 9:
24.7, 2.7
## end
#725, 9:
24.7, 2.7
## end
#726, 9:
24.7, 2.7
## end
#727, 9:
24.7, 2.7
## end
#728, 9:
24.7, 2.7
## end
#729, 9:
24.7, 2.7
## end
#730, 9:
24.7, 2.7
## end
#731, 9:
24.7, 2.7
## end
#732, 9:
24.7, 2.7
## end
#733, 9:
24.7, 2.7
## end
#734, 9:
24.7, 2.7
## end
#735, 9:
24.7, 2.7
## end
#736, 9:
24.7, 2.7
## end
#737, 38:
10.999999999999998, 1.3000000000000003
## end
#738, 38:
10.999999999999998, 1.3000000000000003
## end
#739, 38:
10.999999999999998, 1.3000000000000003
## end
#740, 38:
10.999999999999998, 1.3000000000000003
## end
#741, 38:
10.999999999999998, 1.3000000000000003
## end
#743, 425:
"""
P代码(P函数):
保存:...

"""

+画结构(_结构,elif#0)->+[del](,+画结构)...
->的(画结构,P代码)...

->elif#0(,块#0)->匹配(模块#0,块#0)->模块#0->的(_结构,模块#0)...
    ->的(模块#0,组尺寸)...

->+[python](Python,)->+[code](+[python],P代码)...
->+[.]"siz0"(+[python],组尺寸)...

->[]{
    []:->elif(elif#0,块#1)->块#1->匹配(模块#1,块#1)->模块#1->的(_结构,模块#1)...
        ->的(模块#1,组尺寸#1)...
        ->+[.]"siz1"(+[python],组尺寸#1),
    ->+[.]"siz1"(+[python],+[临时文本])->+[临时文本]"0,0"
}



## end
#745, 807:
"""
P代码(P函数):...
保存:...

"""

+画结构(_结构,块)->+[del](,+画结构)...
->的(画结构,P代码)...

->if(块,块#0)->匹配(模块#0,块#0)->模块#0->的(_结构,模块#0)...
    ->的(模块#0,组尺寸)...

->+[python](Python,+尺寸)->+[code](+[python],P代码)...
->+[.]"siz0"(+[python],组尺寸)...

->[]{
    []:->elif(if,块#1)->块#1->匹配(模块#1,块#1)->模块#1->的(_结构,模块#1)...
        ->的(模块#1,组尺寸#1)...
        ->+[.]"siz1"(+[python],组尺寸#1),
    ->+[.]"siz1"(+[python],+[临时文本])->+[临时文本]"0,0"
}...

->[]{
    []:->else(if,块#2)->块#2->匹配(模块#2,块#2)->模块#2->的(_结构,模块#2)...
        ->的(模块#2,组尺寸#2)...
        ->+[.]"siz2"(+[python],组尺寸#2),
    ->+[.]"siz2"(+[python],+[临时文本])->+[临时文本]"0,0"
}...

->[]{
    []:->匹配(模块,块)->模块->的(_结构,模块)...
        ->+[修改内容]"if"(,模块)...
        ->+[del](,+尺寸),
    ->+匹配(+模块,块)->+模块"if"->+的(+模块,+尺寸)...
        ->+的(_结构,+模块)->+的(_结构,+匹配)
}...

->+[del](,组尺寸)


## end
#746, 38:
10.999999999999998, 1.3000000000000003
## end
#747, 38:
10.999999999999998, 1.3000000000000003
## end
#748, 38:
10.999999999999998, 1.3000000000000003
## end
#749, 38:
10.999999999999998, 1.3000000000000003
## end
#750, 38:
10.999999999999998, 1.3000000000000003
## end
#751, 38:
10.999999999999998, 1.3000000000000003
## end
#752, 23:
4.4, 1.3000000000000003
## end
#753, 23:
4.4, 1.3000000000000003
## end
#754, 23:
4.4, 1.3000000000000003
## end
#755, 23:
4.4, 1.3000000000000003
## end
#756, 23:
4.4, 1.3000000000000003
## end
#757, 23:
4.4, 1.3000000000000003
## end
#758, 23:
4.4, 1.3000000000000003
## end
#759, 23:
4.4, 1.3000000000000003
## end
#760, 23:
4.4, 1.3000000000000003
## end
#761, 23:
4.4, 1.3000000000000003
## end
#762, 38:
10.999999999999998, 1.3000000000000003
## end
#763, 38:
10.999999999999998, 1.3000000000000003
## end
#764, 38:
10.999999999999998, 1.3000000000000003
## end
#765, 38:
10.999999999999998, 1.3000000000000003
## end
#766, 38:
10.999999999999998, 1.3000000000000003
## end
#767, 38:
15.799999999999999, 2.5500000000000003
## end
#768, 38:
15.799999999999999, 2.5500000000000003
## end
#769, 38:
15.799999999999999, 2.5500000000000003
## end
#770, 38:
15.799999999999999, 2.5500000000000003
## end
#771, 38:
15.799999999999999, 2.5500000000000003
## end
#772, 38:
15.799999999999999, 2.5500000000000003
## end
#773, 38:
15.799999999999999, 2.5500000000000003
## end
#774, 38:
15.799999999999999, 2.5500000000000003
## end
#775, 38:
15.799999999999999, 2.5500000000000003
## end
#776, 38:
15.799999999999999, 2.5500000000000003
## end
#777, 38:
15.799999999999999, 2.5500000000000003
## end
#778, 38:
15.799999999999999, 2.5500000000000003
## end
#779, 38:
15.799999999999999, 2.5500000000000003
## end
#780, 38:
15.799999999999999, 2.5500000000000003
## end
#781, 38:
15.799999999999999, 2.5500000000000003
## end
#782, 38:
15.799999999999999, 2.5500000000000003
## end
#783, 38:
15.799999999999999, 2.5500000000000003
## end
#784, 38:
15.799999999999999, 2.5500000000000003
## end
#785, 38:
15.799999999999999, 2.5500000000000003
## end
#786, 38:
15.799999999999999, 2.5500000000000003
## end
#787, 38:
15.799999999999999, 2.5500000000000003
## end
#788, 38:
15.799999999999999, 2.5500000000000003
## end
#790, 1209:
"""
P代码(P函数):...
+[新建阅读窗口](,P代码)

"""

+画结构(_结构,块)->+[del](,+画结构)...
->的(画结构,P代码)...

->if(块,块#0)->匹配(模块,块)->模块->的(_结构,模块)...
    ->在(模块,空间点)->的(模块,尺寸)...

->+[python](Python,)->+[code](+[python],P代码)...
->+[.]"pt"(+[python],空间点)->+[.]"siz"(+[python],尺寸)...

->[]{
    匹配(模块#0,块#0)->模块#0->的(_结构,模块#0)...
        ->的(模块#0,尺寸#0)->+[.]"siz0"(+[python],尺寸#0):
            ->在(模块#0,空间点#0)->+[o]"pt0"(+[python],空间点#0),
        ->+在(模块#0,+空间点#0)->+[o]"pt0"(+[python],+空间点#0)...
            ->+的(_结构,+在)->+的(_结构,+空间点#0)
}...

->[]{
    []:->[]{
    elif(if,块#1)->块#1->匹配(模块#1,块#1)->模块#1->的(_结构,模块#1)...
        ->的(模块#1,尺寸#1)->+[.]"siz1"(+[python],尺寸#1):
            ->在(模块#1,空间点#1)->+[o]"pt1"(+[python],空间点#1),
        ->+在(模块#1,+空间点#1)->+[o]"pt1"(+[python],+空间点#1)...
            ->+的(_结构,+在)->+的(_结构,+空间点#1)
    },->+[.]"siz1"(+[python],+[临时文本]#1)->+[临时文本]#1"0,0"
}...

->[]{
    []:->[]{
    else(if,块#2)->块#2->匹配(模块#2,块#2)->模块#2->的(_结构,模块#2)...
        ->的(模块#2,尺寸#2)->+[.]"siz2"(+[python],尺寸#2):
            ->在(模块#2,空间点#2)->+[o]"pt2"(+[python],空间点#2),
        ->+在(模块#2,+空间点#2)->+[o]"pt2"(+[python],+空间点#2)...
            ->+的(_结构,+在)->+的(_结构,+空间点#2)
    },->+[.]"siz2"(+[python],+[临时文本]#2)->+[临时文本]#2"0,0"
}


## end
#791, 24:
20.6, 2.5500000000000003
## end
#792, 24:
20.6, 2.5500000000000003
## end
#793, 24:
20.6, 2.5500000000000003
## end
#794, 24:
20.6, 2.5500000000000003
## end
#795, 24:
20.6, 2.5500000000000003
## end
#796, 24:
20.6, 2.5500000000000003
## end
#797, 24:
20.6, 2.5500000000000003
## end
#798, 24:
20.6, 2.5500000000000003
## end
#799, 24:
20.6, 2.5500000000000003
## end
#800, 24:
20.6, 2.5500000000000003
## end
#801, 24:
20.6, 2.5500000000000003
## end
#802, 24:
20.6, 2.5500000000000003
## end
#803, 24:
20.6, 2.5500000000000003
## end
#804, 24:
20.6, 2.5500000000000003
## end
#805, 24:
20.6, 2.5500000000000003
## end
#806, 24:
20.6, 2.5500000000000003
## end
#807, 24:
20.6, 2.5500000000000003
## end
#808, 24:
20.6, 2.5500000000000003
## end
#809, 24:
20.6, 2.5500000000000003
## end
#810, 24:
20.6, 2.5500000000000003
## end
#811, 24:
20.6, 2.5500000000000003
## end
#812, 24:
20.6, 2.5500000000000003
## end
#813, 24:
20.6, 2.5500000000000003
## end
#814, 24:
20.6, 2.5500000000000003
## end
#815, 24:
20.6, 2.5500000000000003
## end
#816, 24:
20.6, 2.5500000000000003
## end
#817, 24:
20.6, 2.5500000000000003
## end
#818, 24:
20.6, 2.5500000000000003
## end
#819, 24:
20.6, 2.5500000000000003
## end
#820, 24:
20.6, 2.5500000000000003
## end
#821, 24:
20.6, 2.5500000000000003
## end
#822, 24:
20.6, 2.5500000000000003
## end
#823, 24:
20.6, 2.5500000000000003
## end
#824, 24:
20.6, 2.5500000000000003
## end
#827, 23:
2.2, 1.1500000000000001
## end
#828, 23:
6.7, 2.4000000000000004
## end
#829, 23:
8.9, 2.4000000000000004
## end
#830, 23:
2.2, 1.1500000000000001
## end
#831, 23:
2.2, 1.1500000000000001
## end
#832, 23:
6.8, 2.5500000000000003
## end
#833, 24:
13.6, 2.5500000000000003
## end
#834, 23:
2.2, 1.1500000000000001
## end
#835, 23:
6.8, 2.5500000000000003
## end
#836, 24:
13.6, 2.5500000000000003
## end
#837, 37:
37.00000000000001, 27.750000000000014
## end
#838, 37:
37.00000000000001, 27.750000000000014
## end
#839, 37:
37.00000000000001, 27.750000000000014
## end
#840, 37:
37.00000000000001, 27.750000000000014
## end
#841, 37:
37.00000000000001, 27.750000000000014
## end
#842, 37:
37.00000000000001, 27.750000000000014
## end
#843, 37:
37.00000000000001, 27.750000000000014
## end
#844, 37:
37.00000000000001, 27.750000000000014
## end
#845, 37:
37.00000000000001, 27.750000000000014
## end
#846, 37:
37.00000000000001, 27.750000000000014
## end
#847, 37:
37.00000000000001, 27.750000000000014
## end
#848, 37:
37.00000000000001, 27.750000000000014
## end
#849, 37:
37.00000000000001, 27.750000000000014
## end
#850, 37:
37.00000000000001, 27.750000000000014
## end
#851, 37:
37.00000000000001, 27.750000000000014
## end
#852, 37:
37.00000000000001, 27.750000000000014
## end
#853, 37:
37.00000000000001, 27.750000000000014
## end
#854, 37:
37.00000000000001, 27.750000000000014
## end
#855, 37:
37.00000000000001, 27.750000000000014
## end
#856, 37:
37.00000000000001, 27.750000000000014
## end
#857, 37:
37.00000000000001, 27.750000000000014
## end
#858, 37:
37.00000000000001, 27.750000000000014
## end
#859, 37:
37.00000000000001, 27.750000000000014
## end
#860, 37:
37.00000000000001, 27.750000000000014
## end
#861, 37:
37.00000000000001, 27.750000000000014
## end
#862, 37:
37.00000000000001, 27.750000000000014
## end
#863, 37:
37.00000000000001, 27.750000000000014
## end
#864, 37:
37.00000000000001, 27.750000000000014
## end
#865, 37:
37.00000000000001, 27.750000000000014
## end
#866, 37:
37.00000000000001, 27.750000000000014
## end
#867, 37:
37.00000000000001, 27.750000000000014
## end
#868, 37:
37.00000000000001, 27.750000000000014
## end
#869, 37:
37.00000000000001, 27.750000000000014
## end
#870, 37:
37.00000000000001, 27.750000000000014
## end
#871, 37:
37.00000000000001, 27.750000000000014
## end
#872, 37:
37.00000000000001, 27.750000000000014
## end
#873, 37:
37.00000000000001, 27.750000000000014
## end
#874, 37:
37.00000000000001, 27.750000000000014
## end
#875, 37:
37.00000000000001, 27.750000000000014
## end
#876, 37:
37.00000000000001, 27.750000000000014
## end
#877, 37:
37.00000000000001, 27.750000000000014
## end
#878, 37:
37.00000000000001, 27.750000000000014
## end
#879, 37:
37.00000000000001, 27.750000000000014
## end
#880, 37:
37.00000000000001, 27.750000000000014
## end
#881, 37:
37.00000000000001, 27.750000000000014
## end
#882, 37:
37.00000000000001, 27.750000000000014
## end
#883, 37:
37.00000000000001, 27.750000000000014
## end
#884, 37:
37.00000000000001, 27.750000000000014
## end
#885, 37:
37.00000000000001, 27.750000000000014
## end
#886, 37:
37.00000000000001, 27.750000000000014
## end
#887, 37:
37.00000000000001, 27.750000000000014
## end
#888, 37:
37.00000000000001, 27.750000000000014
## end
#889, 37:
37.00000000000001, 27.750000000000014
## end
#890, 37:
37.00000000000001, 27.750000000000014
## end
#891, 37:
37.00000000000001, 27.750000000000014
## end
#892, 37:
37.00000000000001, 27.750000000000014
## end
#893, 37:
37.00000000000001, 27.750000000000014
## end
#894, 37:
37.00000000000001, 27.750000000000014
## end
#895, 37:
37.00000000000001, 27.750000000000014
## end
#896, 37:
37.00000000000001, 27.750000000000014
## end
#897, 37:
37.00000000000001, 27.750000000000014
## end
#898, 37:
37.00000000000001, 27.750000000000014
## end
#899, 37:
37.00000000000001, 27.750000000000014
## end
#900, 37:
37.00000000000001, 27.750000000000014
## end
#901, 37:
37.00000000000001, 27.750000000000014
## end
#902, 37:
37.00000000000001, 27.750000000000014
## end
#903, 37:
37.00000000000001, 27.750000000000014
## end
#904, 37:
37.00000000000001, 27.750000000000014
## end
#905, 37:
37.00000000000001, 27.750000000000014
## end
#906, 37:
37.00000000000001, 27.750000000000014
## end
#907, 37:
37.00000000000001, 27.750000000000014
## end
#908, 37:
37.00000000000001, 27.750000000000014
## end
#909, 37:
37.00000000000001, 27.750000000000014
## end
#910, 37:
37.00000000000001, 27.750000000000014
## end
#911, 37:
37.00000000000001, 27.750000000000014
## end
#912, 37:
37.00000000000001, 27.750000000000014
## end
#913, 37:
37.00000000000001, 27.750000000000014
## end
#914, 37:
37.00000000000001, 27.750000000000014
## end
#915, 37:
37.00000000000001, 27.750000000000014
## end
#916, 37:
37.00000000000001, 27.750000000000014
## end
#917, 37:
37.00000000000001, 27.750000000000014
## end
#918, 37:
37.00000000000001, 27.750000000000014
## end
#919, 37:
37.00000000000001, 27.750000000000014
## end
#920, 37:
37.00000000000001, 27.750000000000014
## end
#921, 37:
37.00000000000001, 27.750000000000014
## end
#922, 37:
37.00000000000001, 27.750000000000014
## end
#923, 37:
37.00000000000001, 27.750000000000014
## end
#924, 37:
37.00000000000001, 27.750000000000014
## end
#925, 37:
37.00000000000001, 27.750000000000014
## end
#926, 37:
37.00000000000001, 27.750000000000014
## end
#927, 37:
37.00000000000001, 27.750000000000014
## end
#928, 37:
37.00000000000001, 27.750000000000014
## end
#929, 37:
37.00000000000001, 27.750000000000014
## end
#930, 37:
37.00000000000001, 27.750000000000014
## end
#931, 37:
37.00000000000001, 27.750000000000014
## end
#932, 37:
37.00000000000001, 27.750000000000014
## end
#933, 37:
37.00000000000001, 27.750000000000014
## end
#934, 37:
37.00000000000001, 27.750000000000014
## end
#935, 37:
37.00000000000001, 27.750000000000014
## end
#936, 37:
37.00000000000001, 27.750000000000014
## end
#937, 37:
37.00000000000001, 27.750000000000014
## end
#938, 37:
37.00000000000001, 27.750000000000014
## end
#939, 37:
37.00000000000001, 27.750000000000014
## end
#940, 37:
37.00000000000001, 27.750000000000014
## end
#941, 37:
37.00000000000001, 27.750000000000014
## end
#942, 37:
37.00000000000001, 27.750000000000014
## end
#943, 37:
37.00000000000001, 27.750000000000014
## end
#944, 37:
37.00000000000001, 27.750000000000014
## end
#945, 37:
37.00000000000001, 27.750000000000014
## end
#946, 37:
37.00000000000001, 27.750000000000014
## end
#947, 37:
37.00000000000001, 27.750000000000014
## end
#948, 37:
37.00000000000001, 27.750000000000014
## end
#949, 37:
37.00000000000001, 27.750000000000014
## end
#950, 37:
37.00000000000001, 27.750000000000014
## end
#951, 37:
37.00000000000001, 27.750000000000014
## end
#952, 37:
37.00000000000001, 27.750000000000014
## end
#953, 37:
37.00000000000001, 27.750000000000014
## end
#954, 37:
37.00000000000001, 27.750000000000014
## end
#955, 37:
37.00000000000001, 27.750000000000014
## end
#956, 37:
37.00000000000001, 27.750000000000014
## end
#957, 37:
37.00000000000001, 27.750000000000014
## end
#958, 37:
37.00000000000001, 27.750000000000014
## end
#959, 37:
37.00000000000001, 27.750000000000014
## end
#960, 37:
37.00000000000001, 27.750000000000014
## end
#961, 37:
37.00000000000001, 27.750000000000014
## end
#962, 37:
37.00000000000001, 27.750000000000014
## end
#963, 37:
37.00000000000001, 27.750000000000014
## end
#964, 37:
37.00000000000001, 27.750000000000014
## end
#965, 37:
37.00000000000001, 27.750000000000014
## end
#966, 37:
37.00000000000001, 27.750000000000014
## end
#967, 37:
37.00000000000001, 27.750000000000014
## end
#968, 37:
37.00000000000001, 27.750000000000014
## end
#969, 37:
37.00000000000001, 27.750000000000014
## end
#970, 37:
37.00000000000001, 27.750000000000014
## end
#971, 37:
37.00000000000001, 27.750000000000014
## end
#972, 37:
37.00000000000001, 27.750000000000014
## end
#973, 37:
37.00000000000001, 27.750000000000014
## end
#974, 37:
37.00000000000001, 27.750000000000014
## end
#975, 37:
37.00000000000001, 27.750000000000014
## end
#976, 37:
37.00000000000001, 27.750000000000014
## end
#977, 37:
37.00000000000001, 27.750000000000014
## end
#978, 37:
37.00000000000001, 27.750000000000014
## end
#979, 37:
37.00000000000001, 27.750000000000014
## end
#980, 37:
37.00000000000001, 27.750000000000014
## end
#981, 37:
37.00000000000001, 27.750000000000014
## end
#982, 37:
37.00000000000001, 27.750000000000014
## end
#983, 37:
37.00000000000001, 27.750000000000014
## end
#984, 37:
37.00000000000001, 27.750000000000014
## end
#985, 37:
37.00000000000001, 27.750000000000014
## end
#986, 37:
37.00000000000001, 27.750000000000014
## end
#987, 37:
37.00000000000001, 27.750000000000014
## end
#988, 37:
37.00000000000001, 27.750000000000014
## end
#989, 37:
37.00000000000001, 27.750000000000014
## end
#990, 37:
37.00000000000001, 27.750000000000014
## end
#991, 37:
37.00000000000001, 27.750000000000014
## end
#992, 37:
37.00000000000001, 27.750000000000014
## end
#993, 37:
37.00000000000001, 27.750000000000014
## end
#994, 37:
37.00000000000001, 27.750000000000014
## end
#995, 37:
37.00000000000001, 27.750000000000014
## end
#996, 37:
37.00000000000001, 27.750000000000014
## end
#997, 37:
37.00000000000001, 27.750000000000014
## end
#998, 37:
37.00000000000001, 27.750000000000014
## end
#999, 37:
37.00000000000001, 27.750000000000014
## end
#1000, 37:
37.00000000000001, 27.750000000000014
## end
#1001, 37:
37.00000000000001, 27.750000000000014
## end
#1002, 37:
37.00000000000001, 27.750000000000014
## end
#1003, 37:
37.00000000000001, 27.750000000000014
## end
#1004, 37:
37.00000000000001, 27.750000000000014
## end
#1005, 37:
37.00000000000001, 27.750000000000014
## end
#1006, 37:
37.00000000000001, 27.750000000000014
## end
#1007, 37:
37.00000000000001, 27.750000000000014
## end
#1008, 37:
37.00000000000001, 27.750000000000014
## end
#1009, 37:
37.00000000000001, 27.750000000000014
## end
#1010, 37:
37.00000000000001, 27.750000000000014
## end
#1011, 23:
2.2, 1.1500000000000001
## end
#1012, 23:
2.2, 1.1500000000000001
## end
#1013, 23:
2.2, 1.1500000000000001
## end
#1014, 23:
2.2, 1.1500000000000001
## end
#1015, 37:
6.800000000000001, 2.4000000000000004
## end
#1016, 24:
11.4, 2.4000000000000004
## end
#1017, 23:
2.2, 1.1500000000000001
## end
#1018, 24:
21.000000000000004, 5.25
## end
#1019, 24:
21.000000000000004, 5.25
## end
#1020, 24:
21.000000000000004, 5.25
## end
#1021, 24:
21.000000000000004, 5.25
## end
#1022, 24:
21.000000000000004, 5.25
## end
#1023, 24:
21.000000000000004, 5.25
## end
#1024, 24:
21.000000000000004, 5.25
## end
#1025, 24:
21.000000000000004, 5.25
## end
#1026, 24:
21.000000000000004, 5.25
## end
#1027, 24:
21.000000000000004, 5.25
## end
#1028, 24:
21.000000000000004, 5.25
## end
#1029, 24:
21.000000000000004, 5.25
## end
#1030, 24:
21.000000000000004, 5.25
## end
#1031, 24:
21.000000000000004, 5.25
## end
#1032, 24:
21.000000000000004, 5.25
## end
#1033, 24:
21.000000000000004, 5.25
## end
#1034, 24:
21.000000000000004, 5.25
## end
#1035, 24:
21.000000000000004, 5.25
## end
#1036, 24:
21.000000000000004, 5.25
## end
#1037, 24:
21.000000000000004, 5.25
## end
#1038, 24:
21.000000000000004, 5.25
## end
#1039, 24:
21.000000000000004, 5.25
## end
#1040, 24:
21.000000000000004, 5.25
## end
#1041, 24:
21.000000000000004, 5.25
## end
#1042, 24:
21.000000000000004, 5.25
## end
#1043, 24:
21.000000000000004, 5.25
## end
#1044, 24:
21.000000000000004, 5.25
## end
#1045, 24:
21.000000000000004, 5.25
## end
#1046, 24:
21.000000000000004, 5.25
## end
#1047, 24:
21.000000000000004, 5.25
## end
#1048, 24:
21.000000000000004, 5.25
## end
#1049, 24:
21.000000000000004, 5.25
## end
#1050, 24:
21.000000000000004, 5.25
## end
#1051, 24:
21.000000000000004, 5.25
## end
#1052, 24:
21.000000000000004, 5.25
## end
#1053, 24:
21.000000000000004, 5.25
## end
#1054, 24:
21.000000000000004, 5.25
## end
#1055, 24:
21.000000000000004, 5.25
## end
#1056, 24:
21.000000000000004, 5.25
## end
#1057, 24:
21.000000000000004, 5.25
## end
#1058, 24:
21.000000000000004, 5.25
## end
#1059, 24:
21.000000000000004, 5.25
## end
#1060, 24:
21.000000000000004, 5.25
## end
#1061, 24:
21.000000000000004, 5.25
## end
#1062, 24:
21.000000000000004, 5.25
## end
#1063, 24:
21.000000000000004, 5.25
## end
#1064, 24:
21.000000000000004, 5.25
## end
#1065, 24:
21.000000000000004, 5.25
## end
#1066, 24:
21.000000000000004, 5.25
## end
#1067, 24:
21.000000000000004, 5.25
## end
#1068, 24:
21.000000000000004, 5.25
## end
#1069, 24:
21.000000000000004, 5.25
## end
#1070, 24:
21.000000000000004, 5.25
## end
#1071, 24:
21.000000000000004, 5.25
## end
#1072, 24:
21.000000000000004, 5.25
## end
#1073, 24:
21.000000000000004, 5.25
## end
#1074, 24:
21.000000000000004, 5.25
## end
#1075, 24:
21.000000000000004, 5.25
## end
#1076, 24:
21.000000000000004, 5.25
## end
#1077, 24:
21.000000000000004, 5.25
## end
#1078, 24:
21.000000000000004, 5.25
## end
#1079, 24:
21.000000000000004, 5.25
## end
#1080, 24:
21.000000000000004, 5.25
## end
#1081, 24:
21.000000000000004, 5.25
## end
#1082, 24:
21.000000000000004, 5.25
## end
#1083, 24:
21.000000000000004, 5.25
## end
#1084, 24:
21.000000000000004, 5.25
## end
#1085, 24:
21.000000000000004, 5.25
## end
#1086, 24:
21.000000000000004, 5.25
## end
#1087, 24:
21.000000000000004, 5.25
## end
#1088, 24:
21.000000000000004, 5.25
## end
#1089, 24:
21.000000000000004, 5.25
## end
#1090, 24:
21.000000000000004, 5.25
## end
#1091, 24:
21.000000000000004, 5.25
## end
#1092, 24:
21.000000000000004, 5.25
## end
#1093, 24:
21.000000000000004, 5.25
## end
#1094, 24:
21.000000000000004, 5.25
## end
#1095, 24:
21.000000000000004, 5.25
## end
#1096, 24:
21.000000000000004, 5.25
## end
#1097, 24:
21.000000000000004, 5.25
## end
#1098, 24:
21.000000000000004, 5.25
## end
#1099, 24:
21.000000000000004, 5.25
## end
#1100, 24:
21.000000000000004, 5.25
## end
#1101, 24:
21.000000000000004, 5.25
## end
#1102, 24:
21.000000000000004, 5.25
## end
#1103, 24:
21.000000000000004, 5.25
## end
#1104, 24:
21.000000000000004, 5.25
## end
#1105, 24:
21.000000000000004, 5.25
## end
#1106, 24:
21.000000000000004, 5.25
## end
#1107, 24:
21.000000000000004, 5.25
## end
#1108, 24:
21.000000000000004, 5.25
## end
#1109, 24:
21.000000000000004, 5.25
## end
#1110, 24:
21.000000000000004, 5.25
## end
#1111, 24:
21.000000000000004, 5.25
## end
#1112, 24:
21.000000000000004, 5.25
## end
#1113, 24:
21.000000000000004, 5.25
## end
#1114, 24:
21.000000000000004, 5.25
## end
#1115, 24:
21.000000000000004, 5.25
## end
#1116, 24:
21.000000000000004, 5.25
## end
#1117, 24:
21.000000000000004, 5.25
## end
#1118, 24:
21.000000000000004, 5.25
## end
#1119, 24:
21.000000000000004, 5.25
## end
#1120, 24:
21.000000000000004, 5.25
## end
#1121, 24:
21.000000000000004, 5.25
## end
#1122, 24:
21.000000000000004, 5.25
## end
#1123, 24:
21.000000000000004, 5.25
## end
#1124, 24:
21.000000000000004, 5.25
## end
#1125, 24:
21.000000000000004, 5.25
## end
#1126, 24:
21.000000000000004, 5.25
## end
#1127, 24:
21.000000000000004, 5.25
## end
#1128, 24:
21.000000000000004, 5.25
## end
#1129, 24:
21.000000000000004, 5.25
## end
#1130, 24:
21.000000000000004, 5.25
## end
#1131, 24:
21.000000000000004, 5.25
## end
#1132, 24:
21.000000000000004, 5.25
## end
#1133, 24:
21.000000000000004, 5.25
## end
#1134, 24:
21.000000000000004, 5.25
## end
#1135, 24:
21.000000000000004, 5.25
## end
#1136, 24:
21.000000000000004, 5.25
## end
#1137, 24:
21.000000000000004, 5.25
## end
#1138, 24:
21.000000000000004, 5.25
## end
#1139, 24:
21.000000000000004, 5.25
## end
#1140, 24:
21.000000000000004, 5.25
## end
#1141, 24:
21.000000000000004, 5.25
## end
#1142, 24:
21.000000000000004, 5.25
## end
#1143, 24:
21.000000000000004, 5.25
## end
#1145, 3:
2,1
## end
#1147, 21:
import sys
import re

## end
#1149, 3:
2,1
## end
#1151, 36:
sys.path.append(sys.path[0]+'\\..')

## end
#1152, 23:
2.1, 1.1500000000000001
## end
#1156, 2:
if
## end
#1157, 38:
2.3000000000000003, 1.1500000000000001
## end
#1159, 3:
2,1
## end
#1161, 39:
from body.bone import NetP
change=True

## end
#1163, 3:
2,1
## end
#1165, 50:
list_new=[]
areaType=self.areaType()
change=False

## end
#1167, 3:
2,1
## end
#1169, 27:
self.m_stage=1
change=True

## end
#1170, 23:
2.1, 1.1500000000000001
## end
#1174, 2:
if
## end
#1175, 38:
2.3000000000000003, 1.1500000000000001
## end
#1176, 38:
2.3000000000000003, 1.3000000000000003
## end
#1180, 2:
if
## end
#1181, 38:
2.5000000000000004, 1.3000000000000003
## end
#1182, 38:
2.5000000000000004, 1.4500000000000004
## end
#1186, 2:
if
## end
#1187, 38:
2.7000000000000006, 1.4500000000000004
## end
#1188, 38:
2.7000000000000006, 1.6000000000000005
## end
#1192, 2:
if
## end
#1193, 37:
2.900000000000001, 1.6000000000000005
## end
#1195, 3:
2,1
## end
#1197, 36:
self.newMap(pool,areaType,list_new)

## end
#1198, 23:
2.1, 1.1500000000000001
## end
#1201, 3:
2,1
## end
#1203, 20:
self.m_interp=False

## end
#1204, 23:
2.1, 1.1500000000000001
## end
#1208, 2:
if
## end
#1209, 23:
4.4, 1.1500000000000001
## end
#1211, 3:
2,1
## end
#1213, 12:
change=True

## end
#1215, 3:
2,1
## end
#1217, 9:
continue

## end
#1218, 23:
2.1, 1.1500000000000001
## end
#1221, 3:
2,1
## end
#1223, 9:
continue

## end
#1224, 23:
2.1, 1.1500000000000001
## end
#1227, 3:
2,1
## end
#1229, 15:
self.m_stage=5

## end
#1231, 3:
2,1
## end
#1233, 54:
self.m_reState='dark yellow'
return [change,list_new]

## end
#1234, 23:
2.1, 1.1500000000000001
## end
#1237, 3:
2,1
## end
#1239, 53:
self.m_reState='dark green'
return [change,list_new]

## end
#1240, 23:
2.1, 1.1500000000000001
## end
#1244, 2:
if
## end
#1245, 23:
4.4, 1.1500000000000001
## end
#1246, 23:
4.4, 2.4000000000000004
## end
#1249, 3:
2,1
## end
#1251, 40:
self.m_stage=1
return [change,list_new]

## end
#1252, 23:
2.1, 1.1500000000000001
## end
#1255, 3:
2,1
## end
#1257, 21:
self.m_stage=2
break

## end
#1258, 23:
2.1, 1.1500000000000001
## end
#1262, 2:
if
## end
#1263, 38:
13.299999999999999, 2.4000000000000004
## end
#1264, 5:
while
## end
#1267, 23:
13.499999999999998, 5.0
## end
#1268, 38:
13.499999999999998, 5.1499999999999995
## end
#1272, 2:
if
## end
#1273, 38:
13.699999999999998, 5.1499999999999995
## end
#1275, 3:
2,1
## end
#1277, 46:
self.m_choose=True
self.m_stage=3
change=True

## end
#1278, 23:
2.1, 1.1500000000000001
## end
#1281, 3:
2,1
## end
#1283, 42:
self.m_choose=self.m_clauseAnd
keep=False

## end
#1284, 23:
2.1, 1.1500000000000001
## end
#1288, 2:
if
## end
#1289, 23:
4.4, 1.1500000000000001
## end
#1291, 3:
2,1
## end
#1293, 75:
self.m_choose=False
self.m_stage=3
change=True
self.m_clauseOut=True
break

## end
#1294, 23:
2.1, 1.1500000000000001
## end
#1297, 3:
2,1
## end
#1299, 10:
keep=True

## end
#1300, 23:
2.1, 1.1500000000000001
## end
#1304, 2:
if
## end
#1305, 37:
4.500000000000001, 1.1500000000000001
## end
#1306, 37:
4.500000000000001, 1.3000000000000003
## end
#1309, 3:
2,1
## end
#1311, 74:
self.m_choose=True
self.m_stage=3
change=True
self.m_clauseOut=True
break

## end
#1312, 23:
2.1, 1.1500000000000001
## end
#1315, 3:
2,1
## end
#1317, 10:
keep=True

## end
#1318, 23:
2.1, 1.1500000000000001
## end
#1322, 2:
if
## end
#1323, 37:
4.500000000000001, 1.1500000000000001
## end
#1324, 37:
4.500000000000001, 1.3000000000000003
## end
#1328, 2:
if
## end
#1329, 37:
9.200000000000001, 1.3000000000000003
## end
#1330, 3:
for
## end
#1333, 23:
9.3, 1.5500000000000005
## end
#1335, 3:
2,1
## end
#1337, 49:
self.m_stage=3
change=True
self.m_clauseOut=True

## end
#1338, 23:
2.1, 1.1500000000000001
## end
#1342, 2:
if
## end
#1343, 38:
2.3000000000000003, 1.1500000000000001
## end
#1344, 8:
9.3, 4.2
## end
#1348, 2:
if
## end
#1349, 8:
9.5, 4.2
## end
#1351, 3:
2,1
## end
#1353, 52:
self.m_stage=1
change=True
return [change,list_new]

## end
#1354, 23:
2.1, 1.1500000000000001
## end
#1358, 2:
if
## end
#1359, 38:
2.3000000000000003, 1.1500000000000001
## end
#1361, 3:
2,1
## end
#1363, 31:
i=self.m_eoi
end=self.m_noe[i]

## end
#1365, 3:
2,1
## end
#1367, 26:
end.m_stage=1
change=True

## end
#1368, 23:
2.1, 1.1500000000000001
## end
#1371, 3:
2,1
## end
#1373, 27:
self.m_stage=1
change=True

## end
#1374, 23:
2.1, 1.1500000000000001
## end
#1377, 3:
2,1
## end
#1379, 17:
i+=1
change=True

## end
#1381, 3:
2,1
## end
#1383, 28:
self.m_stage=1
self.m_eoi=0

## end
#1384, 23:
2.1, 1.1500000000000001
## end
#1387, 3:
2,1
## end
#1389, 13:
self.m_eoi=i

## end
#1390, 23:
2.1, 1.1500000000000001
## end
#1394, 2:
if
## end
#1395, 23:
4.4, 1.1500000000000001
## end
#1396, 23:
4.4, 2.4000000000000004
## end
#1400, 2:
if
## end
#1401, 23:
6.7, 2.4000000000000004
## end
#1402, 23:
6.7, 2.5500000000000003
## end
#1405, 3:
2,1
## end
#1407, 27:
self.m_stage=4
change=True

## end
#1408, 23:
2.1, 1.1500000000000001
## end
#1411, 3:
2,1
## end
#1413, 17:
i+=1
change=True

## end
#1415, 3:
2,1
## end
#1417, 28:
self.m_stage=4
self.m_eoi=0

## end
#1418, 23:
2.1, 1.1500000000000001
## end
#1421, 3:
2,1
## end
#1423, 13:
self.m_eoi=i

## end
#1424, 23:
2.1, 1.1500000000000001
## end
#1428, 2:
if
## end
#1429, 23:
4.4, 1.1500000000000001
## end
#1430, 23:
4.4, 2.4000000000000004
## end
#1434, 2:
if
## end
#1435, 23:
6.7, 2.4000000000000004
## end
#1436, 23:
6.7, 2.5500000000000003
## end
#1440, 2:
if
## end
#1441, 38:
15.899999999999999, 2.5500000000000003
## end
#1442, 24:
15.899999999999999, 5.05
## end
#1445, 3:
2,1
## end
#1447, 27:
self.m_stage=4
change=True

## end
#1448, 23:
2.1, 1.1500000000000001
## end
#1451, 3:
2,1
## end
#1453, 52:
self.m_stage=1
change=True
return [change,list_new]

## end
#1454, 23:
2.1, 1.1500000000000001
## end
#1457, 3:
2,1
## end
#1459, 32:
i=self.m_eoi
end=self.m_yese[i]

## end
#1461, 3:
2,1
## end
#1463, 26:
end.m_stage=1
change=True

## end
#1464, 23:
2.1, 1.1500000000000001
## end
#1467, 3:
2,1
## end
#1469, 27:
self.m_stage=1
change=True

## end
#1470, 23:
2.1, 1.1500000000000001
## end
#1473, 3:
2,1
## end
#1475, 17:
i+=1
change=True

## end
#1477, 3:
2,1
## end
#1479, 28:
self.m_stage=1
self.m_eoi=0

## end
#1480, 23:
2.1, 1.1500000000000001
## end
#1483, 3:
2,1
## end
#1485, 13:
self.m_eoi=i

## end
#1486, 23:
2.1, 1.1500000000000001
## end
#1490, 2:
if
## end
#1491, 23:
4.4, 1.1500000000000001
## end
#1492, 23:
4.4, 2.4000000000000004
## end
#1496, 2:
if
## end
#1497, 23:
6.7, 2.4000000000000004
## end
#1498, 23:
6.7, 2.5500000000000003
## end
#1501, 3:
2,1
## end
#1503, 27:
self.m_stage=4
change=True

## end
#1504, 23:
2.1, 1.1500000000000001
## end
#1507, 3:
2,1
## end
#1509, 17:
i+=1
change=True

## end
#1511, 3:
2,1
## end
#1513, 28:
self.m_stage=4
self.m_eoi=0

## end
#1514, 23:
2.1, 1.1500000000000001
## end
#1517, 3:
2,1
## end
#1519, 13:
self.m_eoi=i

## end
#1520, 23:
2.1, 1.1500000000000001
## end
#1524, 2:
if
## end
#1525, 23:
4.4, 1.1500000000000001
## end
#1526, 23:
4.4, 2.4000000000000004
## end
#1530, 2:
if
## end
#1531, 23:
6.7, 2.4000000000000004
## end
#1532, 23:
6.7, 2.5500000000000003
## end
#1536, 2:
if
## end
#1537, 38:
15.899999999999999, 2.5500000000000003
## end
#1538, 38:
15.899999999999999, 3.8000000000000003
## end
#1542, 2:
if
## end
#1543, 24:
20.4, 3.8000000000000003
## end
#1544, 10:
20.4, 3.95
## end
#1548, 2:
if
## end
#1549, 10:
36.5, 5.05
## end
#1550, 23:
36.5, 5.199999999999999
## end
#1554, 2:
if
## end
#1555, 23:
36.7, 5.199999999999999
## end
#1557, 3:
2,1
## end
#1559, 26:
self.m_clauseCollect=True

## end
#1560, 23:
2.1, 1.1500000000000001
## end
#1564, 2:
if
## end
#1565, 38:
2.3000000000000003, 1.1500000000000001
## end
#1567, 3:
2,1
## end
#1569, 28:
list_new.append(self.m_map)

## end
#1570, 23:
2.1, 1.1500000000000001
## end
#1574, 2:
if
## end
#1575, 38:
2.3000000000000003, 1.1500000000000001
## end
#1577, 3:
2,1
## end
#1579, 15:
self.m_stage=5

## end
#1581, 3:
2,1
## end
#1583, 66:
self.m_reState='dark yellow'
change=True
return [change,list_new]

## end
#1584, 23:
2.1, 1.1500000000000001
## end
#1587, 3:
2,1
## end
#1589, 65:
self.m_reState='dark green'
change=True
return [change,list_new]

## end
#1590, 23:
2.1, 1.1500000000000001
## end
#1594, 2:
if
## end
#1595, 23:
4.4, 1.1500000000000001
## end
#1596, 8:
4.4, 4.9
## end
#1600, 2:
if
## end
#1601, 23:
4.6000000000000005, 4.9
## end
#1603, 3:
2,1
## end
#1605, 25:
return [change,list_new]

## end
#1608, 25:
Reason_oneStep(self,pool)
## end
#1609, 38:
36.800000000000004, 23.900000000000006
## end
#1612, 7:
Karma()
## end
#1613, 36:
37.00000000000001, 24.15000000000001
## end
#1614, 37:
37.00000000000001, 27.750000000000014
## end
#1618, 24:
0.0, -1.2500000000000002
## end
#1623, 4:
0, 0
## end
#1626, 10:
0.0, -2.35
## end
#1628, 37:
37.00000000000001, 27.750000000000014
## end
#1631, 24:
0.1, -1.2000000000000002
## end
#1633, 37:
37.00000000000001, 27.750000000000014
## end
#1636, 24:
0.0, -26.600000000000012
## end
#1638, 37:
37.00000000000001, 27.750000000000014
## end
#1639, 37:
37.00000000000001, 27.750000000000014
## end
#1642, 23:
0.1, -26.45000000000001
## end
#1644, 37:
37.00000000000001, 27.750000000000014
## end
#1647, 24:
0.2, -3.6500000000000057
## end
#1651, 23:
0.2, -5.350000000000006
## end
#1653, 37:
37.00000000000001, 27.750000000000014
## end
#1656, 24:
0.2, -10.600000000000005
## end
#1658, 37:
37.00000000000001, 27.750000000000014
## end
#1661, 39:
0.30000000000000004, -5.300000000000005
## end
#1663, 37:
37.00000000000001, 27.750000000000014
## end
#1666, 23:
0.4, -5.250000000000005
## end
#1668, 37:
37.00000000000001, 27.750000000000014
## end
#1671, 23:
0.5, -5.200000000000005
## end
#1673, 37:
37.00000000000001, 27.750000000000014
## end
#1676, 23:
0.6, -5.150000000000004
## end
#1678, 37:
37.00000000000001, 27.750000000000014
## end
#1681, 24:
0.2, -14.900000000000004
## end
#1683, 37:
37.00000000000001, 27.750000000000014
## end
#1686, 40:
0.30000000000000004, -10.550000000000004
## end
#1688, 37:
37.00000000000001, 27.750000000000014
## end
#1691, 23:
0.4, -6.800000000000004
## end
#1695, 23:
0.4, -7.900000000000004
## end
#1697, 37:
37.00000000000001, 27.750000000000014
## end
#1700, 24:
2.6, -6.7500000000000036
## end
#1704, 24:
0.5, -6.7500000000000036
## end
#1706, 37:
37.00000000000001, 27.750000000000014
## end
#1707, 37:
37.00000000000001, 27.750000000000014
## end
#1710, 24:
0.4, -10.400000000000004
## end
#1712, 37:
37.00000000000001, 27.750000000000014
## end
#1713, 37:
37.00000000000001, 27.750000000000014
## end
#1716, 24:
11.5, -9.100000000000003
## end
#1720, 23:
2.7, -9.100000000000003
## end
#1724, 23:
0.5, -9.100000000000003
## end
#1726, 37:
37.00000000000001, 27.750000000000014
## end
#1729, 23:
4.9, -9.100000000000003
## end
#1731, 37:
37.00000000000001, 27.750000000000014
## end
#1734, 23:
9.4, -9.100000000000003
## end
#1738, 24:
4.9, -10.350000000000003
## end
#1740, 37:
37.00000000000001, 27.750000000000014
## end
#1741, 37:
37.00000000000001, 27.750000000000014
## end
#1744, 39:
7.1000000000000005, -10.300000000000002
## end
#1748, 24:
5.0, -10.300000000000002
## end
#1750, 37:
37.00000000000001, 27.750000000000014
## end
#1751, 37:
37.00000000000001, 27.750000000000014
## end
#1752, 37:
37.00000000000001, 27.750000000000014
## end
#1753, 37:
37.00000000000001, 27.750000000000014
## end
#1756, 24:
0.2, -20.200000000000003
## end
#1758, 37:
37.00000000000001, 27.750000000000014
## end
#1761, 40:
0.30000000000000004, -11.950000000000005
## end
#1765, 40:
0.30000000000000004, -13.600000000000005
## end
#1767, 37:
37.00000000000001, 27.750000000000014
## end
#1770, 39:
2.5000000000000004, -11.900000000000004
## end
#1774, 24:
0.4, -11.900000000000004
## end
#1776, 37:
37.00000000000001, 27.750000000000014
## end
#1777, 37:
37.00000000000001, 27.750000000000014
## end
#1780, 40:
0.30000000000000004, -14.850000000000005
## end
#1782, 37:
37.00000000000001, 27.750000000000014
## end
#1785, 24:
0.4, -13.450000000000005
## end
#1787, 37:
37.00000000000001, 27.750000000000014
## end
#1790, 24:
5.0, -13.400000000000004
## end
#1794, 24:
0.5, -13.400000000000004
## end
#1796, 37:
37.00000000000001, 27.750000000000014
## end
#1799, 39:
2.8000000000000003, -13.350000000000003
## end
#1803, 24:
0.6, -13.350000000000003
## end
#1805, 37:
37.00000000000001, 27.750000000000014
## end
#1806, 37:
37.00000000000001, 27.750000000000014
## end
#1807, 37:
37.00000000000001, 27.750000000000014
## end
#1810, 38:
7.299999999999999, -13.350000000000003
## end
#1814, 24:
5.1, -13.350000000000003
## end
#1816, 37:
37.00000000000001, 27.750000000000014
## end
#1817, 37:
37.00000000000001, 27.750000000000014
## end
#1818, 37:
37.00000000000001, 27.750000000000014
## end
#1821, 24:
0.4, -14.800000000000004
## end
#1823, 37:
37.00000000000001, 27.750000000000014
## end
#1826, 24:
0.2, -25.200000000000003
## end
#1828, 37:
37.00000000000001, 27.750000000000014
## end
#1831, 40:
0.30000000000000004, -20.150000000000006
## end
#1833, 37:
37.00000000000001, 27.750000000000014
## end
#1836, 25:
16.3, -19.000000000000007
## end
#1840, 24:
0.4, -16.350000000000005
## end
#1844, 24:
0.4, -17.450000000000006
## end
#1846, 37:
37.00000000000001, 27.750000000000014
## end
#1849, 24:
0.5, -16.300000000000004
## end
#1851, 37:
37.00000000000001, 27.750000000000014
## end
#1854, 23:
0.4, -20.10000000000001
## end
#1856, 37:
37.00000000000001, 27.750000000000014
## end
#1857, 37:
37.00000000000001, 27.750000000000014
## end
#1860, 23:
2.7, -20.05000000000001
## end
#1864, 23:
0.5, -18.65000000000001
## end
#1866, 37:
37.00000000000001, 27.750000000000014
## end
#1869, 23:
9.5, -20.05000000000001
## end
#1871, 37:
37.00000000000001, 27.750000000000014
## end
#1874, 39:
4.8999999999999995, -18.750000000000014
## end
#1878, 39:
2.8000000000000003, -18.750000000000014
## end
#1880, 37:
37.00000000000001, 27.750000000000014
## end
#1883, 39:
4.8999999999999995, -20.000000000000014
## end
#1885, 37:
37.00000000000001, 27.750000000000014
## end
#1886, 37:
37.00000000000001, 27.750000000000014
## end
#1889, 38:
7.099999999999999, -19.950000000000017
## end
#1893, 38:
4.999999999999999, -19.950000000000017
## end
#1895, 37:
37.00000000000001, 27.750000000000014
## end
#1896, 37:
37.00000000000001, 27.750000000000014
## end
#1897, 37:
37.00000000000001, 27.750000000000014
## end
#1900, 39:
11.700000000000001, -18.750000000000014
## end
#1904, 24:
9.6, -18.750000000000014
## end
#1906, 37:
37.00000000000001, 27.750000000000014
## end
#1909, 39:
11.700000000000001, -20.000000000000014
## end
#1911, 37:
37.00000000000001, 27.750000000000014
## end
#1912, 37:
37.00000000000001, 27.750000000000014
## end
#1915, 39:
13.900000000000004, -19.950000000000017
## end
#1919, 25:
11.8, -19.950000000000017
## end
#1921, 37:
37.00000000000001, 27.750000000000014
## end
#1922, 37:
37.00000000000001, 27.750000000000014
## end
#1923, 37:
37.00000000000001, 27.750000000000014
## end
#1926, 25:
20.7, -16.300000000000008
## end
#1930, 39:
18.600000000000005, -16.300000000000008
## end
#1934, 39:
16.400000000000002, -16.300000000000008
## end
#1936, 37:
37.00000000000001, 27.750000000000014
## end
#1937, 37:
37.00000000000001, 27.750000000000014
## end
#1940, 24:
20.7, -18.95000000000001
## end
#1942, 37:
37.00000000000001, 27.750000000000014
## end
#1943, 37:
37.00000000000001, 27.750000000000014
## end
#1946, 39:
23.000000000000004, -18.900000000000013
## end
#1950, 24:
20.8, -17.50000000000001
## end
#1952, 37:
37.00000000000001, 27.750000000000014
## end
#1955, 39:
29.800000000000004, -18.900000000000013
## end
#1957, 37:
37.00000000000001, 27.750000000000014
## end
#1960, 39:
25.200000000000006, -17.600000000000016
## end
#1964, 39:
23.100000000000005, -17.600000000000016
## end
#1966, 37:
37.00000000000001, 27.750000000000014
## end
#1969, 39:
25.200000000000006, -18.850000000000016
## end
#1971, 37:
37.00000000000001, 27.750000000000014
## end
#1972, 37:
37.00000000000001, 27.750000000000014
## end
#1975, 37:
27.40000000000001, -18.80000000000002
## end
#1979, 38:
25.300000000000008, -18.80000000000002
## end
#1981, 37:
37.00000000000001, 27.750000000000014
## end
#1982, 37:
37.00000000000001, 27.750000000000014
## end
#1983, 37:
37.00000000000001, 27.750000000000014
## end
#1986, 38:
32.00000000000001, -17.600000000000016
## end
#1990, 39:
29.900000000000006, -17.600000000000016
## end
#1992, 37:
37.00000000000001, 27.750000000000014
## end
#1995, 38:
32.00000000000001, -18.850000000000016
## end
#1997, 37:
37.00000000000001, 27.750000000000014
## end
#1998, 37:
37.00000000000001, 27.750000000000014
## end
#2001, 24:
34.2, -18.80000000000002
## end
#2005, 37:
32.10000000000001, -18.80000000000002
## end
#2007, 37:
37.00000000000001, 27.750000000000014
## end
#2008, 37:
37.00000000000001, 27.750000000000014
## end
#2011, 24:
0.2, -26.300000000000004
## end
#2013, 37:
37.00000000000001, 27.750000000000014
## end
#2016, 40:
0.30000000000000004, -21.550000000000004
## end
#2020, 40:
0.30000000000000004, -22.800000000000004
## end
#2022, 37:
37.00000000000001, 27.750000000000014
## end
#2025, 24:
0.4, -21.500000000000007
## end
#2027, 37:
37.00000000000001, 27.750000000000014
## end
#2030, 40:
0.30000000000000004, -23.900000000000006
## end
#2032, 37:
37.00000000000001, 27.750000000000014
## end
#2035, 24:
0.4, -22.750000000000007
## end
#2037, 37:
37.00000000000001, 27.750000000000014
## end
#2040, 40:
0.30000000000000004, -25.150000000000006
## end
#2042, 37:
37.00000000000001, 27.750000000000014
## end
#2043, 37:
37.00000000000001, 27.750000000000014
## end
#2046, 38:
2.5000000000000004, -25.10000000000001
## end
#2050, 23:
0.4, -25.10000000000001
## end
#2052, 37:
37.00000000000001, 27.750000000000014
## end
#2053, 37:
37.00000000000001, 27.750000000000014
## end
#2054, 37:
37.00000000000001, 27.750000000000014
## end
#2056, 707:

测试1:
时间1::
测试2:
时间2::3.42
测试3:
时间3::6.60
测试4:
时间4::10.19
+[新建阅读窗口](,测试1)

统计时长(M函数):...
+[新建阅读窗口](,统计时长)

输出内容:...
结构场景:...
[python程序](测试1,)->+[修改内容](,输出内容)->[m_text]([python程序],+[修改内容])
+[删除结构](,结构场景)->+[导入节点](,结构场景)->[m_text](输出内容,+[导入节点])


时间1::
+[记录时间](,时间1)->+[分析程序结构](测试1,输出内容)->+[记录时间](,时间1)
+[python]"ans=t[1]-t[0]"(Python,+[显示])->+[.]"t"(+[python],时间1)
+[记录时间](,时间2)->+[分析程序结构](测试2,输出内容)->+[记录时间](,时间2)
+[python]"ans=t[1]-t[0]"(Python,+[显示])->+[.]"t"(+[python],时间2)

+[记录时间](,时间3)->+[分析程序结构](测试3,输出内容)->+[记录时间](,时间3)
+[python]"ans=t[1]-t[0]"(Python,+[显示])->+[.]"t"(+[python],时间3)
+[记录时间](,时间4)->+[分析程序结构](测试4,输出内容)->+[记录时间](,时间4)
+[python]"ans=t[1]-t[0]"(Python,+[显示])->+[.]"t"(+[python],时间4)




## end
#2057, 4:
2330
## end
#2060, 172:
a
while 1:
    b
a
while 1:
    b
a
while 1:
    b
a
while 1:
    b
a
while 1:
    b
a
while 1:
    b
a
while 1:
    b
a
while 1:
    b
a
while 1:
    b
a
while 1:
    b



## end
#2062, 28:
12201.4916943, 12252.1664319
## end
#2066, 1942:
块#0"a
"(程序,)[-1,-1]
块#1""(程序,)[-1,-1]
然后#2""(块#0,块#1)[-1,-1]
块#3"b
"(程序,)[-1,-1]
eof#4""(程序,)[-1,-1]
然后#5""(块#3,eof#4)[-1,-1]
while#6"1"(块#1,块#3)[-1,-1]
块#7"a
"(程序,)[-1,-1]
然后#8""(块#1,块#7)[-1,-1]
块#9""(程序,)[-1,-1]
然后#10""(块#7,块#9)[-1,-1]
块#11"b
"(程序,)[-1,-1]
eof#12""(程序,)[-1,-1]
然后#13""(块#11,eof#12)[-1,-1]
while#14"1"(块#9,块#11)[-1,-1]
块#15"a
"(程序,)[-1,-1]
然后#16""(块#9,块#15)[-1,-1]
块#17""(程序,)[-1,-1]
然后#18""(块#15,块#17)[-1,-1]
块#19"b
"(程序,)[-1,-1]
eof#20""(程序,)[-1,-1]
然后#21""(块#19,eof#20)[-1,-1]
while#22"1"(块#17,块#19)[-1,-1]
块#23"a
"(程序,)[-1,-1]
然后#24""(块#17,块#23)[-1,-1]
块#25""(程序,)[-1,-1]
然后#26""(块#23,块#25)[-1,-1]
块#27"b
"(程序,)[-1,-1]
eof#28""(程序,)[-1,-1]
然后#29""(块#27,eof#28)[-1,-1]
while#30"1"(块#25,块#27)[-1,-1]
块#31"a
"(程序,)[-1,-1]
然后#32""(块#25,块#31)[-1,-1]
块#33""(程序,)[-1,-1]
然后#34""(块#31,块#33)[-1,-1]
块#35"b
"(程序,)[-1,-1]
eof#36""(程序,)[-1,-1]
然后#37""(块#35,eof#36)[-1,-1]
while#38"1"(块#33,块#35)[-1,-1]
块#39"a
"(程序,)[-1,-1]
然后#40""(块#33,块#39)[-1,-1]
块#41""(程序,)[-1,-1]
然后#42""(块#39,块#41)[-1,-1]
块#43"b
"(程序,)[-1,-1]
eof#44""(程序,)[-1,-1]
然后#45""(块#43,eof#44)[-1,-1]
while#46"1"(块#41,块#43)[-1,-1]
块#47"a
"(程序,)[-1,-1]
然后#48""(块#41,块#47)[-1,-1]
块#49""(程序,)[-1,-1]
然后#50""(块#47,块#49)[-1,-1]
块#51"b
"(程序,)[-1,-1]
eof#52""(程序,)[-1,-1]
然后#53""(块#51,eof#52)[-1,-1]
while#54"1"(块#49,块#51)[-1,-1]
块#55"a
"(程序,)[-1,-1]
然后#56""(块#49,块#55)[-1,-1]
块#57""(程序,)[-1,-1]
然后#58""(块#55,块#57)[-1,-1]
块#59"b
"(程序,)[-1,-1]
eof#60""(程序,)[-1,-1]
然后#61""(块#59,eof#60)[-1,-1]
while#62"1"(块#57,块#59)[-1,-1]
块#63"a
"(程序,)[-1,-1]
然后#64""(块#57,块#63)[-1,-1]
块#65""(程序,)[-1,-1]
然后#66""(块#63,块#65)[-1,-1]
块#67"b
"(程序,)[-1,-1]
eof#68""(程序,)[-1,-1]
然后#69""(块#67,eof#68)[-1,-1]
while#70"1"(块#65,块#67)[-1,-1]
块#71"a
"(程序,)[-1,-1]
然后#72""(块#65,块#71)[-1,-1]
块#73""(程序,)[-1,-1]
然后#74""(块#71,块#73)[-1,-1]
块#75"b
"(程序,)[-1,-1]
eof#76""(程序,)[-1,-1]
然后#77""(块#75,eof#76)[-1,-1]
while#78"1"(块#73,块#75)[-1,-1]
eof#79""(程序,)[-1,-1]
然后#80""(块#73,eof#79)[-1,-1]
起点#81""(,块#0)[-1,-1]

## end
#2068, 79:
"""


"""

+记录时间(,_输出)->+[del](,+记录时间)...

->+[修改内容](,_输出)->[计时](_输出,+[修改内容])


## end
#2070, 523:
"""
Nini, 打开公式分析器(文件)
保存:...

"""

+分析程序结构(_代码,_输出)->+[del](,+分析程序结构)...

->[]{
    []:->[==]"M"(,+分析程序结构)->[M程序_代码](_代码,)...
        ->+[修改内容](,_输出)->[m_text]([M程序_代码],+[修改内容])...
        ->+[导入节点](,_输出)->[m_text]([M程序_代码],+[导入节点]),

    ->[==]"JS"(,+分析程序结构)->[JS程序_代码](_代码,)...
        ->+[修改内容](,_输出)->[m_text]([JS程序_代码],+[修改内容])...
        ->+[导入节点](,_输出)->[m_text]([JS程序_代码],+[导入节点]),

    ->[C程序_代码](_代码,)...
        ->+[修改内容](,_输出)->[m_text]([C程序_代码],+[修改内容])...
        ->+[导入节点](,_输出)->[m_text]([C程序_代码],+[导入节点])
}
## end
#2072, 33:
a
while 1:
    b
a
while 1:
    b
## end
#2074, 27:
11406.6595657, 11410.077962
## end
#2076, 50:
a
while 1:
    b
a
while 1:
    b
a
while 1:
    b
## end
#2078, 28:
11410.1091741, 11416.7056908
## end
#2080, 67:
a
while 1:
    b
a
while 1:
    b
a
while 1:
    b
a
while 1:
    b
## end
#2082, 28:
11416.7408281, 11426.9339212
## end
#2084, 161:
%{
记住"Matlab"

测试结果:...
if时长:...
while时长:...
%}

t=[1.42, 3.42, 6.60, 10.19, 13.47, 18.42, 24.37, 31.57, 41.70, 50.67];
t/t(1)
plot(t/t(1))

%{
+[M函数](,统计时长)
%}

## end
#2087, 71:

测试1:
时间1:73.487
测试2:
时间2:340.217
测试3:
时间3:855.432
测试4:
时间4:1730.369



## end
#2089, 100:
%{
记住"Matlab"

%}

t=[73.487, 340.217, 855.432, 1730.369];
t/t(1)
plot(t/t(1))

%{
+[M函数](,统计时长)
%}

## end
#2091, 148:
%{
记住"Matlab"

重复单元:...
%}

t=[1.42, 3.42, 6.60, 10.19, 13.47, 18.42, 24.37, 31.57, 41.70, 50.67];
t/t(1)
plot(t/t(1),'o-')

%{
+[M函数](,while时长)
%}

## end
#2093, 16:
a
while 1:
    b
## end
#2095, 221:
"""
P代码(P函数):...

"""

+python程序_代码(_程序,)...
->的(python程序_代码,P代码)->的(P代码,函数定义)...

->+[code]([python]#0,函数定义)->[python]#0(Python,)...

->+[code]([python],P代码)->+[.]"code"([python],_程序)...
->[python](Python,+python程序_代码)


## end
#2097, 60:
"""
函数定义(P函数):...

"""

ans=python_parser(code)
state=True


## end
#2100, 10928:
"""
+[P函数](,函数定义)
测试(P函数):...
+[新建阅读窗口](,测试)

def if_python_token

"""

import re
from body.bone import NetP
from tools import tools_basic


def python_parser(code):
    list_pt=[]
    [state,i]=code_python_token(code,0,'',list_pt)
    if state==False:
        return ''
    text=tools_basic.writeStdCode([],list_pt)
    return text

def removeComment(code0,i0):
    code=code0[i0:]
    i=i0

    if len(code)==0:
        return code,False
    elif code[0]=='#':
        code=re.sub(r'^#.*','',code)
    elif code[0:3]=='"""':
        code=code[3:]
        while True:
            if len(code)<3:
                code=''
                break
            elif code[0:3]=='"""':
                break
            else:
                code=re.sub(r'^.*\n?','',code)
        code=code[3:]
    else:
        return i,False
    for i in range(i0,len(code0)):
        if code0[i:]==code:
            return i,True
    return i0,False

def add_space(space):
    space+='    '
    return space

def code_python_token(code,i,sp,list_pt=None,pt=None):
    state=True
    final=False
    if list_pt==None:
        list_pt=[]
    if pt==None:
        pt=NetP('块')
        if list_pt==[]:
            pt_start=NetP('起点').con(None,pt)
            list_pt.append(pt_start)
        list_pt.append(pt)

    while state:
        #code=re.sub(r'^\s*\n','',code)
        #print(code[i:i+40])
        #i,result=removeComment(code,i)

        pt0=pt
        [state,i]=block_python_token(code,i,sp,list_pt,pt0)
        if state==True:
            final=True
            pt=NetP('块')
            pt_then=NetP('然后').con(pt0,pt)
            list_pt.append(pt)
            list_pt.append(pt_then)
        else:
            pt0.m_name='eof'
    return [final,i]

def block_python_token(code,i,sp,list_pt,pt0):
    Dn=len(sp)
    a=re.match('\s*\n',code[i:])
    if a!=None:
        Di=a.span()[1]
        j=i+Dn+Di
    else:
        j=i+Dn
    
    if code[j:j+2]=='if':
        [state,i]=if_python_token(code,i,sp,list_pt,pt0)
    elif code[j:j+5]=='while':
        [state,i]=while_python_token(code,i,sp,list_pt,pt0)
    elif code[j:j+3]=='for':
        [state,i]=for_python_token(code,i,sp,list_pt,pt0)
    elif code[j:j+3]=='try':
        [state,i]=try_python_token(code,i,sp,list_pt,pt0)
    elif code[j:j+3]=='def':
        [state,i]=func_python_token(code,i,sp,list_pt,pt0)
    elif code[j:j+5]=='class':
        [state,i]=class_python_token(code,i,sp,list_pt,pt0)
    else:
        [state,i]=op_python_token(code,i,sp,pt0)

    return [state,i]

"""
+[P函数](,函数定义)

def cond_python_token

"""


def if_python_token(code,i,sp,list_pt,pt0):
    sp1=add_space(sp)

    pt=NetP('块')
    pt_if=NetP('if').con(pt0,pt)
    pt_if00=pt_if
    list_pt.append(pt)
    list_pt.append(pt_if)

    i0=i
    [state,i]=sp_python_token(code,i,sp)
    if state==False:
        return [False,i0]
    [state,i,text]=word_python_token(code,i,'if ')
    if state==False:
        return [False,i0]
    [state,i,text]=cond_python_token(code,i)
    pt_if.m_text=text
    if state==False:
        return [False,i0]
    [state,i,text]=word_python_token(code,i,':[\n\s\t]*\n')
    if state==False:
        return [False,i0]
    [state,i]=code_python_token(code,i,sp1,list_pt,pt)
    if state==False:
        return [False,i0]


    while state:
        pt_if0=pt_if
        pt=NetP('块')
        pt_if=NetP('elif')

        i1=i
        [state,i]=sp_python_token(code,i,sp)
        if state==False:
            i=i1
            pt_if=pt_if0
            break
        [state,i,text]=word_python_token(code,i,'elif ')
        if state==False:
            i=i1
            pt_if=pt_if0
            break
        [state,i,text]=cond_python_token(code,i)
        pt_if.m_text=text
        if state==False:
            return [False,i1]
        [state,i,text]=word_python_token(code,i,':[\n\s\t]*\n')
        if state==False:
            return [False,i1]
        [state,i]=code_python_token(code,i,sp1,list_pt,pt)
        if state==False:
            return [False,i1]

        pt_if.con(pt_if0,pt)
        list_pt.append(pt)
        list_pt.append(pt_if)


    i2=i
    [state,i]=sp_python_token(code,i,sp)
    if state==False:
        i=i2
        return [True,i]
    [state,i,text]=word_python_token(code,i,'else:[\n\s\t]*\n')
    if state==False:
        i=i2
        return [True,i]

    pt_if0=pt_if
    pt=NetP('块')
    pt_else=NetP('else').con(pt_if00,pt)
    list_pt.append(pt)
    list_pt.append(pt_else)

    sp1=add_space(sp)
    [state,i]=code_python_token(code,i,sp1,list_pt,pt)
    if state==False:
        return [False,i2]
    return [state,i]


def while_python_token(code,i,sp,list_pt,pt0):
    sp1=add_space(sp)

    pt=NetP('块')
    pt_while=NetP('while').con(pt0,pt)
    list_pt.append(pt)
    list_pt.append(pt_while)

    i0=i
    [state,i]=sp_python_token(code,i,sp)
    if state==False:
        return [False,i0]
    [state,i,text]=word_python_token(code,i,'while ')
    if state==False:
        return [False,i0]
    [state,i,text]=cond_python_token(code,i)
    pt_while.m_text=text
    if state==False:
        return [False,i0]
    [state,i,text]=word_python_token(code,i,':[\n\s\t]*\n')
    if state==False:
        return [False,i0]

    [state,i]=code_python_token(code,i,sp1,list_pt,pt)
    if state==False:
        return [False,i0]

    return [state,i]

def for_python_token(code,i,sp,list_pt,pt0):
    sp1=add_space(sp)

    pt=NetP('块')
    pt_for=NetP('for').con(pt0,pt)
    pt_var=NetP('变量').con(pt_for,None)
    list_pt.append(pt)
    list_pt.append(pt_for)
    list_pt.append(pt_var)

    i0=i
    [state,i]=sp_python_token(code,i,sp)
    if state==False:
        return [False,i0]
    [state,i,text]=word_python_token(code,i,'for ')
    if state==False:
        return [False,i0]
    [state,i,text_var]=var_python_token(code,i)
    pt_var.m_text=text_var
    if state==False:
        return [False,i0]

    [state,i,text]=word_python_token(code,i,' in ')
    if state==False:
        return [False,i0]
    [state,i,text]=cond_python_token(code,i)
    pt_for.m_text=text
    if state==False:
        return [False,i0]
    [state,i,text]=word_python_token(code,i,':[\n\s\t]*\n')
    if state==False:
        return [False,i0]

    [state,i]=code_python_token(code,i,sp1,list_pt,pt)
    if state==False:
        return [False,i0]
    return [state,i]

def try_python_token(code,i,sp,list_pt,pt0):
    sp1=add_space(sp)

    pt1=NetP('块')
    pt2=NetP('块')
    pt_try=NetP('try').con(pt0,pt1)
    pt_except=NetP('except').con(pt_try,pt2)
    list_pt.append(pt1)
    list_pt.append(pt2)
    list_pt.append(pt_try)
    list_pt.append(pt_except)

    i0=i
    [state,i]=sp_python_token(code,i,sp)
    if state==False:
        return [False,i0]

    [state,i,text]=word_python_token(code,i,'try:\s*\n')
    if state==False:
        return [False,i0]
    [state,i]=code_python_token(code,i,sp1,list_pt,pt1)
    if state==False:
        return [False,i0]

    [state,i]=sp_python_token(code,i,sp)
    if state==False:
        return [False,i0]
    [state,i,text]=word_python_token(code,i,'except *')
    if state==False:
        return [False,i0]

    [state,i,text]=cond_python_token(code,i)
    pt_except.m_text=text

    [state,i,text]=word_python_token(code,i,':\s*\n')
    if state==False:
        return [False,i0]

    [state,i]=code_python_token(code,i,sp1,list_pt,pt2)
    if state==False:
        return [False,i0]
    return [state,i]

"""
+[P函数](,函数定义)

"""

def func_python_token(code,i,sp,list_pt,pt0):
    sp1=add_space(sp)

    pt=NetP('块')
    pt_def=NetP('func').con(pt0,pt)
    list_pt.append(pt)
    list_pt.append(pt_def)

    i0=i
    [state,i]=sp_python_token(code,i,sp)
    if state==False:
        return [False,i0]
    [state,i,text]=word_python_token(code,i,'def ')
    if state==False:
        return [False,i0]
    [state,i,text]=cond_python_token(code,i)
    pt_def.m_text=text

    if state==False:
        return [False,i0]
    [state,i,text]=word_python_token(code,i,':[\n\s\t]*\n')
    if state==False:
        return [False,i0]

    [state,i]=code_python_token(code,i,sp1,list_pt,pt)

    if state==False:
        return [False,i0]
    return [state,i]

def class_python_token(code,i,sp,list_pt,pt0):
    sp1=add_space(sp)

    pt=NetP('块')
    pt_class=NetP('class').con(pt0,pt)
    list_pt.append(pt)
    list_pt.append(pt_class)

    i0=i
    [state,i]=sp_python_token(code,i,sp)
    if state==False:
        return [False,i0]
    [state,i,text]=word_python_token(code,i,'class ')
    if state==False:
        return [False,i0]
    [state,i,text]=cond_python_token(code,i)
    pt_class.m_text=text
    if state==False:
        return [False,i0]

    [state,i,text]=word_python_token(code,i,':[\n\s\t]*\n')
    if state==False:
        return [False,i0]
    [state,i]=code_python_token(code,i,sp1,list_pt,pt)
    if state==False:
        return [False,i0]
    return [state,i]

def op_python_token(code,i,sp,pt0):
    i0_op=i
    txt_op=''
    sp_op=sp
    while True:
        a0=re.match('\s*\n',code[i:])
        if a0!=None:
            i+=a0.span()[1]
        a=re.match('.*',code[i:])
        if a==None:
            break
        txt_line=a.group()
        if len(txt_line)==0:
            break
    
        Dn=len(sp_op)
        if sp_op!=txt_line[0:Dn]:
            break
        
        b=re.match(sp_op+'(if|elif|else|for|while|def|class|try|except)',txt_line)
        if b!=None:
            break
    
        i+=len(txt_line)
        txt_op+=txt_line[Dn:]+'\n'
    
    if i0_op==i:
        state=False
    else:
        state=True

    pt0.m_text=txt_op
    return [state,i]


def word_python_token(code,i,pat):
    text=''
    try:
        n=i
        a=re.match(pat,code[i:])
        print(a)
        if a==None:
            state=False
        else:
            di=a.span()[1]
            output_txt=code[i:i+di]
            i+=di
            state=True
            text=output_txt
    except:
        state=False
    
    return [state,i,text]


"""
cond_python_token存档:...
记住"Python"
text1='remove[1:2]:\n'
print(text1.rfind(':'),text1[0:8])

"""
def cond_python_token(code,i):
    [state,i1,text]=word_python_token(code,i,'.*:[\t ]*\n')
    ni=text.rfind(':')
    text=text[0:ni]
    i=i+ni
    return [state,i,text]

#def cond_python_token(code,i):
#    return word_python_token(code,i,'[^:]*')

def var_python_token(code,i):
    return word_python_token(code,i,'[\w_\d]+')

def sp_python_token(code,i,sp):
    di=len(sp)
    pat1='\s*\n'+sp
    pat2=sp
    try:
        n=i
        a1=re.match(pat1,code[i:])
        a2=re.match(pat2,code[i:])
        if a1==None and a2==None:
            state=False
        elif a1!=None:
            di=a1.span()[1]
            output_txt=code[i:i+di]
            i+=di
            state=True
        else:
            output_txt=code[i:i+di]
            i+=di
            state=True
    except:
        state=False
    return [state,i]



state=True

## end
#2103, 347:
"""
测试->的(函数定义,测试)->+[P函数](,函数定义)
+[P函数](,测试)
记住"Python"

保存func:...
保存class:...
保存循环:...
保存if:...
保存op:...

Karma:...

执行测试(P函数)


"""

code="""
%Karma

"""
i=0
sp=''
list_pt=[]
# [state,i]=word_python_token(code,i,'def ')
[state,i]=code_python_token(code,i,sp,list_pt)
print(len(list_pt))
txt=python_parser(code)
print(txt)

"""
+[P函数](,测试)

"""
## end
#2106, 253:
"""
测试->的(函数定义,测试)->+[P函数](,函数定义)
+[P函数](,测试)
记住"Python"

保存func:...
保存op:...

"""

code="""
def func():
    a+b
"""
i=0
sp=''
# [state,i]=word_python_token(code,i,'def ')
[state,i]=func_python_token(code,i,sp)
print(state,code,i)


"""
+[P函数](,测试)

"""
## end
#2108, 272:
"""
测试->的(函数定义,测试)->+[P函数](,函数定义)
+[P函数](,测试)
记住"Python"

保存func:...
保存op:...

"""

code="""
def func():
    a+b
"""
i=13
sp='    '
# [state,i]=word_python_token(code,i,'def ')
[state,i]=op_python_token(code,i,sp)
print(state,code,i)
sp1=add_space(sp)
print(sp1,'111')




## end
#2110, 289:
"""
测试->的(函数定义,测试)->+[P函数](,函数定义)
+[P函数](,测试)
记住"Python"

保存func:...
保存class:
保存op:...

"""

code="""
class NetP():
    def __init__():
        a+b
"""
i=0
sp=''
# [state,i]=word_python_token(code,i,'def ')
[state,i]=class_python_token(code,i,sp)
print(state,code,i)


"""
+[P函数](,测试)

"""
## end
#2112, 287:
"""
测试->的(函数定义,测试)->+[P函数](,函数定义)
+[P函数](,测试)
记住"Python"

保存func:...
保存class:...
保存循环:
保存op:...

"""

code="""
for i in range(5):
    a+b
    c+d

"""
i=0
sp=''
# [state,i]=word_python_token(code,i,'def ')
[state,i]=code_python_token(code,i,sp)
print(state,code,i)


"""
+[P函数](,测试)

"""
## end
#2114, 353:
"""
测试->的(函数定义,测试)->+[P函数](,函数定义)
+[P函数](,测试)
记住"Python"

保存func:...
保存class:...
保存循环:...
保存if:
保存op:...

"""

code="""
if a==1:
    a+b
    c+d
elif a==2:
    a=2+1
elif a==3:
    a=2+1
else:
    a=4+2

"""
i=0
sp=''
# [state,i]=word_python_token(code,i,'def ')
[state,i]=code_python_token(code,i,sp)
print(state,code,i,code[i:])


"""
+[P函数](,测试)

"""
## end
#2116, 52513:

import sys
import re
if __name__=='__main__':
    sys.path.append(sys.path[0]+'\\..')
from body.bone import NetP


def dictToList(dict_pt):
    list_pt=[]
    for term in dict_pt:
        list_pt+=dict_pt[term]
    return list_pt


class Karma:
    def __init__(self,symbol):
        self.m_symbol=symbol
        symbol.m_master=self
        self.m_creator=None


        self.m_map=None


        self.m_cause=None
        self.m_yese=[]
        self.m_noe=[]
        self.m_yesAnd=False
        self.m_noAnd=False
        self.m_eoi=0


        self.m_clause=[]
        self.m_clauseAnd=True
        # To reorder actions generated inside a clause. All new points generated in clauses will be stored in
        # m_clauseNew until the whole sentence completes the map.
        # It's a kind of stack.
        self.m_clauseNew=[]
        self.m_clauseCollect=False
        self.m_clauseOut=False
        self.m_clauseIn=False


        self.m_not=False
        self.m_no=False
        
        self.m_buildMode=False


        self.m_listMP=None
        self.m_restricted=False


        self.m_ranger=None
        self.m_rangType=False                               # connecting[self(,ranger)]---True, connected[ranger(,self)]---False


        # one step
        self.m_stage=0
        self.m_reState='0'
        self.m_choose=True
        self.m_interp=False


    def stateSelf(self):
        if self.m_interp==True:
            return 'blue'
        if self.m_symbol==None or self.m_map==None:
            return 'yellow'


        # [eq](,) and [is](,) function points
        if self.m_symbol.m_name=='[eq]' or self.m_symbol.m_name=='[同名]':
            return self.stateSelf_eq()
        elif self.m_symbol.m_name=='[is]' or self.m_symbol.m_name=='[是]':
            return self.stateSelf_is()
        elif self.m_symbol.m_name=='[那]':
            return 'green'
        # elif self.isSpaceRelation():
        #     return self.stateSelf_space()


        # _re"^.*"(,) regular expression
        if self.m_symbol.m_name=='_正则表达式' or self.m_symbol.m_name=='_re':
            try:
                pattern=re.compile(self.m_symbol.m_text)
            except:
                print('Invalid regular expression: '+self.m_symbol.m_text+'!')
                return 'red'
            match=self.m_map.m_name
            if pattern.findall(match)!=[]:
                return 'green'
            else:
                return 'red'


        # _word(,) or _[word](,)
        if self.m_symbol.m_name!='' and self.m_symbol.m_name[0]=='_':
            name=self.m_symbol.m_name[1:]
            name_m=self.m_map.m_name
            if len(name)==0:
                return 'green'
            elif name[0]=='[' and name[-1]==']':
                if len(name_m)>=2 and name_m[0]=='[' and name_m[-1]==']':
                    return 'green'
                else:
                    return 'red'
            else:
                return 'green'
                # if len(name_m)<2 or name_m[0]!='[' or name_m[-1]!=']':
                #     return 'green'
                # else:
                #     return 'red'



        # [word](,)/+[word](,)
        if self.m_symbol.m_name!='' and self.m_symbol.m_name[0]=='[' and self.m_symbol.m_name[-1]==']':
            name1=self.m_symbol.m_name[1:-1]
            name2=self.m_symbol.m_name
            if self.m_interp==False and self.m_map.m_creator==None and self.m_buildMode==False:
                return 'red'
            if name1==self.m_map.m_name or name2==self.m_map.m_name:
                return 'green'
            else:
                return 'red'


        # ~word(,)
        if self.m_symbol.m_name!='' and self.m_symbol.m_name[0]=='~':
            name=self.m_symbol.m_name[1:]
            if name==self.m_map.m_name:
                return 'red'
            else: 
                return 'green'
        # word(,)
        else:
            name=self.m_map.m_name
            if name!='' and name[0]=='[' and name[-1]==']':
                name=name[1:-1]
            if name!=self.m_symbol.m_name:
                return 'red'
            elif self.m_symbol.m_text!='' and self.m_symbol.m_text!=self.m_map.m_text:
                return 'red'
            else:
                return 'green'


    def stateSelf_eq(self):
        if self.m_map==None:
            return 'yellow'
        if self.m_symbol.m_db[0]==None or self.m_symbol.m_db[1]==None:
            return 'red'
        
        karmaL=self.m_symbol.m_db[0].m_master
        karmaR=self.m_symbol.m_db[1].m_master
        if karmaL==None or karmaR==None:
            print('Error! [eq] doesn\'t have sbj or obj.')
            print('Sbj:',karmaL)
            print('Obj:',karmaR)
            return 'red'
        if karmaL.m_map==None or karmaR.m_map==None:
            return 'green'
        else:
            nameL=karmaL.m_map.m_name
            nameR=karmaR.m_map.m_name
            # I don't remember why I removed it
            # if len(karmaL.m_map.m_name)>1 and karmaL.m_map.m_name[0]=='[' and karmaL.m_map.m_name[-1]==']':
            #     nameL=karmaL.m_map.m_name[1:-1]
            # if len(karmaR.m_map.m_name)>1 and karmaR.m_map.m_name[0]=='[' and karmaR.m_map.m_name[-1]==']':
            #     nameR=karmaR.m_map.m_name[1:-1]
            
            if len(karmaL.m_map.m_name)>1 and karmaL.m_map.m_name[0]=='[' and karmaL.m_map.m_name[-1]==']':
                nameL=karmaL.m_map.m_name[1:-1]
            if len(karmaR.m_map.m_name)>1 and karmaR.m_map.m_name[0]=='[' and karmaR.m_map.m_name[-1]==']':
                nameR=karmaR.m_map.m_name[1:-1]


            if nameL==nameR:
                return 'green'
            else:
                return 'red'


    def stateSelf_is(self):
        if self.m_map==None:
            return 'yellow'
        if self.m_symbol.m_db[0]==None or self.m_symbol.m_db[1]==None:
            return 'red'
        
        karmaL=self.m_symbol.m_db[0].m_master
        karmaR=self.m_symbol.m_db[1].m_master
        if karmaL.m_map==None or karmaR.m_map==None:
            return 'green'
        else:
            if karmaL.m_map==karmaR.m_map:
                return 'green'
            else:
                return 'red'


    def stateSelf_space(self):
        if self.m_map==None:
            return 'yellow'
        if self.m_symbol.m_db[0]==None or self.m_symbol.m_db[1]==None:
            return 'red'


        km_sbj=self.m_symbol.m_db[0].m_master
        km_obj=self.m_symbol.m_db[1].m_master
        if km_sbj.m_map==None or km_obj.m_map==None:
            return 'green'
        elif km_sbj.m_map==km_obj.m_map:
            return 'red'
        x1=km_sbj.m_map.m_pos[0]
        y1=km_sbj.m_map.m_pos[1]
        x2=km_obj.m_map.m_pos[0]
        y2=km_obj.m_map.m_pos[1]
        name=self.m_symbol.m_name
        if name=='[当地]' or name=='[here]':
            if x1==x2 and y1==y2:
                return 'green'
            else:
                return 'red'
        elif name=='[上面]' or name=='[up]':
            if y1>y2:
                return 'green'
            else:
                return 'red'
        elif name=='[正上面]' or name=='[Up]':
            if x1==x2 and y1>y2:
                return 'green'
            else:
                return 'red'
        elif name=='[下面]' or name=='[down]':
            if y1<y2:
                return 'green'
            else:
                return 'red'
        elif name=='[正下面]' or name=='[Down]':
            if x1==x2 and y1<y2:
                return 'green'
            else:
                return 'red'
        elif name=='[左面]' or name=='[left]':
            if x1>x2:
                return 'green'
            else:
                return 'red'
        elif name=='[正左面]' or name=='[Left]':
            if y1==y2 and x1>x2:
                return 'green'
            else:
                return 'red'
        elif name=='[右面]' or name=='[right]':
            if x1<x2:
                return 'green'
            else:
                return 'red'
        elif name=='[正右面]' or name=='[Right]':
            if y1==y2 and x1<x2:
                return 'green'
            else:
                return 'red'



    
    def stateRelation(self):
        if self.m_map==None or self.m_symbol==None:
            return True
            
        cause=self.m_cause
        while cause!=None:
            if cause.m_symbol==self.m_symbol.m_db[0]:
                if cause.m_map!=self.m_map.m_db[0]:
                    return False
            if cause.m_symbol==self.m_symbol.m_db[1]:
                if cause.m_map!=self.m_map.m_db[1]:
                    return False


            # For a function point, you should check the relation between the point through the function point selfstate()
            if cause.m_symbol.m_db[0]==self.m_symbol:
                if cause.m_map.m_db[0]!=self.m_map or cause.stateSelf()=='red':
                    return False
            if cause.m_symbol.m_db[1]==self.m_symbol:
                if cause.m_map.m_db[1]!=self.m_map or cause.stateSelf()=='red':
                    return False


            cause=cause.m_cause
        
        return True


    # def rangeList(self,pool,areaType,list_new):
    #     # restrict the map pool by m_listMP
    #     if self.m_listMP!=[]:
    #         list_map=self.m_listMP
    #     # self(+ranger,) or others
    #     elif self.m_ranger!=None and (self.m_ranger.buildingNewMap()==False or self.m_rangType==True):
    #         # restrict the map pool by m_cause
    #         # self(+ranger,) or self(ranger,)
    #         if self.m_rangType==True:
    #             if self.m_ranger.m_map==None or self.m_ranger.m_map.m_con==[]:
    #                 list_map=[]
    #             else:
    #                 list_map=self.m_ranger.m_map.m_con.copy()
    #         # ranger(self,)
    #         elif self.m_ranger.m_symbol.m_db[0]==self.m_symbol:
    #             if self.m_ranger.m_map.m_db[0]==None:
    #                 list_map=[]
    #             else:
    #                 list_map=[self.m_ranger.m_map.m_db[0]]
    #         # ranger(,self)
    #         elif self.m_ranger.m_symbol.m_db[1]==self.m_symbol:
    #             if self.m_ranger.m_map.m_db[1]==None:
    #                 list_map=dictToList(pool)
    #             else:
    #                 list_map=[self.m_ranger.m_map.m_db[1]]
    #         else:
    #             print('Warning! Undefined situation.')
    #     # _point(,) or ~point(,)
    #     elif self.selfType()=='实万用链节' or self.selfType()=='实否定链节':                  # '_point' and '' aren't restricted
    #         list_map=dictToList(pool)
    #         if len(self.m_symbol.m_name)>2 and self.m_symbol.m_name[1]=='_':
    #             for mp in list_map:
    #                 if mp in list_new:
    #                     list_map.remove(mp)
    #     # noraml(,)
    #     else:
    #         # list_map=dictToList(pool)
    #         list_map=pool.get(self.m_symbol.m_name,[])
    #         list_map+=pool.get('['+self.m_symbol.m_name+']',[])


    #     return list_map


    def mapListFromRange(self):
        list_map=[]
        if self.m_rangType==True:
            if self.m_ranger.m_map==None:
                list_map=[]
            else:
                list_map=self.m_ranger.m_map.m_con.copy()
        # ranger(self,)
        elif self.m_ranger.m_symbol.m_db[0]==self.m_symbol:
            if self.m_ranger.m_map.m_db[0]==None:
                list_map=[]
            else:
                list_map=[self.m_ranger.m_map.m_db[0]]
        # ranger(,self)
        elif self.m_ranger.m_symbol.m_db[1]==self.m_symbol:
            if self.m_ranger.m_map.m_db[1]==None:
                list_map=[]
            else:
                list_map=[self.m_ranger.m_map.m_db[1]]
        else:
            print('Warning! Undefined situation.')
        return list_map
    
    def mapListFromPool_normal(self,pool):
        name=self.m_symbol.m_name
        # if self.isType('通用') or self.isType('否定'):
        if len(name)>0 and (name[0]=='_' or name[0]=='~'):
            list_have=dictToList(pool)
            list_map=[]
            for point in list_have:
                if point.m_needed==None or (point.m_needed!=None and point.m_creator!=None):
                    list_map.append(point)
        else:
            list_map=pool.get(self.m_symbol.m_name,[])
            # list_map+=pool.get('['+self.m_symbol.m_name+']',[])
        return list_map


    def mapList_is(self,ranger,pool):
        if ranger.m_symbol.m_db[0]==None or ranger.m_symbol.m_db[1]==None:
            return self.mapListFromPool_normal(pool)
        if ranger.m_symbol.m_db[0]==self.m_symbol and ranger.m_map.m_db[1]!=None:
            return [ranger.m_map.m_db[1]]
        if ranger.m_symbol.m_db[1]==self.m_symbol and ranger.m_map.m_db[0]!=None:
            return [ranger.m_map.m_db[0]]
        return self.mapListFromPool_normal(pool)


    def mapList_that(self,ranger):
        list_cause=ranger.allCauses()
        list_map=[]
        for cause in list_cause:
            pt_map=cause.m_map
            if pt_map!=None and pt_map not in list_map:
                list_map.append(pt_map)
        return list_map


    def rangeList(self,pool,areaType,list_new):
        # restrict the map pool by m_listMP
        if self.m_listMP!=None:
            return self.m_listMP
        # elif self.isType('非端点'):
        elif self.m_ranger!=None:
            ranger=self.m_ranger
            # print('范围',ranger.m_symbol.info())
            nameR=self.m_ranger.m_symbol.m_name
            if nameR=='[is]':
                list_map=self.mapList_is(self.m_ranger,pool)
            elif nameR=='[那]':
                list_map=self.mapList_that(self.m_ranger)
            elif self.m_ranger.isType('非回答新建') and self.m_ranger.m_symbol in self.m_symbol.m_con:
                list_map=self.mapListFromPool_normal(pool)
            else:
                list_map=self.mapListFromRange()
            # elif self.m_ranger.isType('回答') or self.m_ranger.isType('非新建'):
            #     list_map=self.mapListFromRange()
            # elif self.m_buildMode==False:
            #     list_map=self.mapListFromPool_normal(pool)
            # else:
            #     list_map=[]
        else:
            list_map=self.mapListFromPool_normal(pool)


        self.m_listMP=list_map


        return list_map



    def newMap(self,pool,areaType,list_new):
        list_map=self.rangeList(pool,areaType,list_new)
        # if self.m_symbol.m_name=='的':
        #     printPtList(list_map)


        if self.m_buildMode==False or areaType==False:
            name=self.m_symbol.m_name
            # [noun]:
            # function points
            # if self.isFunctionPoint()==1:
            # if self.isType('内置'):
            if self.isPreDefined():
                if self.m_map==None:
                    point=NetP(name,self.m_symbol.m_text)
                    point.m_pos=self.m_symbol.m_pos.copy()
                    point.m_needed=self
                    point.m_creator=self
                    self.map(point)
                else:
                    self.m_map.delete()
                    del self.m_map
                    self.map(None)
                return
            elif self.isFunctionPoint()==2:
                # function points [P] don't find map from pool
                if self.m_map==None:
                    point=NetP(name,self.m_symbol.m_text)
                    point.m_pos=self.m_symbol.m_pos.copy()
                    point.m_needed=self
                    self.map(point)
                else:
                    self.map(self.m_map)
                self.m_interp=True
                # else:
                #     self.m_map.delete()
                #     self.m_map.m_needed=None
                #     self.map(None)
                return


            # printPtList(list_map)


            # only take real points when karma is start with _ and ~
            # list_have=[]
            # for point in list_map:
            #     if self.selfType()=='实万用链节' or self.selfType()=='实否定链节':
            #         # if point.m_creator!=None or point.m_needed==None:
            #         if point.m_needed==None or (point.m_needed!=None and point.m_creator!=None):
            #             # point.print()
            #             list_have.append(point)
            #         # else:
            #         #     pass
            #             # print('Erased from map_list:',point.info(),', it should be an imagine point.')
            #     else:
            #         list_have.append(point)
            list_have=list_map
            mp=self.m_map
            self.map(self.nextInlist(mp,list_have))
            # if self.m_map!=None:
            #     print(self.m_symbol.m_name+':',self.m_map.m_name)
            #     printPtList(self.m_map.m_con)
            return
        else:
            name=self.m_symbol.m_name
            # answer questions
            # +word(,)
            if name!='' and (name[0]!='[' or name[-1]!=']'):
                if self.m_map!=None:
                    self.m_map.m_creator=None
                    # ???
                    if self.m_map.m_needed==None:
                        self.m_map.delete()
                        self.map(None)
                        return
                    else:
                        self.m_map.m_name='['+self.m_map.m_name+']'
                        # self.m_map.m_building=False
                list_need=[]
                for point in list_map:
                    if point.m_creator==None and point.m_needed!=None:
                        list_need.append(point)
                point=self.m_map
                # printPtList(list_need)
                # if point==None:
                #     print(self.m_symbol.m_name+":",point,-1)
                # else:
                #     try:
                #         print(self.m_symbol.m_name+":",list_need,point,list_need.index(point))
                #         # print(self.m_symbol.m_name+":",pool)
                #     except:
                #         print(self.m_symbol.m_name+":",list_need,point.info(),-1)
                self.map(self.nextInlist(point,list_need))
                if self.m_map==None:
                    if self.m_restricted==True:
                        self.map(None)
                        return
                    point=NetP(self.m_symbol.m_name,self.m_symbol.m_text)
                    point.m_pos=self.m_symbol.m_pos.copy()
                    point.m_building=True
                    self.map(point)
                else:
                    self.m_map.m_building=True
                    self.m_map.m_name=self.m_map.m_name[1:-1]
                self.m_map.m_creator=self
                return
            # +[word](,)
            else:
                if self.m_map==None:
                    point=NetP(name,self.m_symbol.m_text)
                    point.m_pos=self.m_symbol.m_pos.copy()
                    point.m_building=True
                    point.m_needed=self
                    self.map(point)
                    return
                else:
                    self.m_map.m_needed=None
                    self.m_map.delete()
                    self.map(None)
                    return


        self.map(None)



    def nextInlist(self,point,list_pt):
        if list_pt==[]:
            return None
        if point==None:
            return list_pt[0]
        
        try:
            i=list_pt.index(point)
        except:
            return None
        
        if i+1>=len(list_pt):
            return None
        else:
            return list_pt[i+1]


    def clearAll(self):
        self.m_map=None
        self.m_stage=0
        self.m_interp=False
        self.m_reState=''
        self.m_choose=True
        self.m_eoi=0
        if self.m_restricted==False:
            del self.m_listMP
            self.m_listMP=None
        for clause in self.m_clause:
            clause.clearAll()
        for end in self.m_noe:
            end.clearAll()
        for end in self.m_yese:
            end.clearAll()



    def map(self,point):
        self.clearAll()
        # self.m_stage=0
        # self.m_interp=False
        # self.m_reState=''
        # self.m_choose=True
        # for clause in self.m_clause:
        #     clause.map(None)
        # for end in self.m_noe:
        #     end.map(None)
        # for end in self.m_yese:
        #     end.map(None)


        self.m_map=point
        if self.m_map!=None:
            cause=self.m_cause
            while cause!=None:
                # function relation points
                # print('当前链节:',self.m_symbol.m_name)
                # print('因链节:',cause.m_symbol.m_name)
                if cause.needBuildRelation():
                    # To allow +[a]: +a(,_obj)->_obj, _obj can find map from pool.
                    if cause.m_map.m_needed==None or cause.m_map.m_needed==cause:
                        if cause.m_symbol.m_db[0]==self.m_symbol:
                            cause.m_map.connect(self.m_map,0)
                        if cause.m_symbol.m_db[1]==self.m_symbol:
                            cause.m_map.connect(self.m_map,1)
                if self.needBuildRelation():
                    if self.m_map.m_needed==None or self.m_map.m_needed==self:
                        if self.m_symbol.m_db[0]==cause.m_symbol:
                            self.m_map.connect(cause.m_map,0)
                        if self.m_symbol.m_db[1]==cause.m_symbol:
                            self.m_map.connect(cause.m_map,1)
                cause=cause.m_cause


    def buildingNewMap(self):
        if self.m_map==None:
            return False
        elif self.m_buildMode==False:
            return False
        else:
            # +[a]: +a(,_obj)->_obj
            if self.m_map.m_needed==None:
                return True
            # return True
        return False


    def needBuildRelation(self):
        if self.buildingNewMap():
            return True
        elif self.isFunctionPoint()!=0:
            return True
        return False
    
    def selfType(self):
        name=self.m_symbol.m_name
        if name=='':
            return "实链节"
        elif name[0]=='_':
            return "实万用链节"
        elif name[0]=='~':
            return "实否定链节"
        elif name[0]=='[' and name[-1]==']':
            return "虚链节"
        return "实链节"


    def isVirtual(self):
        name=self.m_symbol.m_name
        if len(name)>1 and name[0]=='[' and name[-1]==']':
            return True
        elif self.isSpaceRelation():
            return True
        else:
            return False


    def isPreDefined(self):
        name=self.m_symbol.m_name
        if name=='[is]' or name=='[eq]' or name=='[那]' or name=='[]':
            return True
        elif self.isSpaceRelation():
            return True
        else:
            return False


    def isSpecialRanger(self):
        name=self.m_symbol.m_name
        if name=='[is]' or name=='[那]':
            return True
        return False



    def isType(self,str_type):
        name=self.m_symbol.m_name
        if infoInStr('引用',str_type):
            if not self.isVirtual() or self.m_buildMode==True:
                return False
        if infoInStr('新建',str_type):
            if infoInStr('非新建',str_type):
                if self.m_buildMode==True:
                    return False
            elif self.m_buildMode==False:
                return False
        if infoInStr('动作',str_type):
            if not self.isVirtual() or self.m_buildMode==False:
                return False
        if infoInStr('内置',str_type):
            if not self.isPreDefined():
                return False
        if infoInStr('特殊范围',str_type):
            if not self.isSpecialRanger():
                return False
        if infoInStr('否定',str_type):
            if name=='' or name[0]!='~':
                return False
        if infoInStr('通用',str_type):
            if name=='' or name[0]!='_':
                return False
        if infoInStr('普通',str_type):
            # if name!='' and (name[0]=='~' or name[0]=='_'):
            #     return False
            if self.isVirtual():
                return False
        if infoInStr('端点',str_type):
            if infoInStr('非端点',str_type):
                if self.m_ranger==None:
                    return False
            elif self.m_ranger!=None:
                return False
        if infoInStr('回答',str_type):
            an_type=True
            if self.m_map==None or self.m_map.m_needed==self or self.m_map.m_needed==None:
                an_type=False
            if infoInStr('非回答',str_type):
                if an_type:
                    return False
            elif not an_type:
                return False
        if infoInStr('限制',str_type):
            if self.m_restricted==False:
                return False
        return True
        



    def isFunctionPoint(self):
        if self.m_symbol.m_name=='':
            return 0
        elif self.m_symbol.m_name=='[eq]' or self.m_symbol.m_name=='[同名]':
            return 1
        elif self.m_symbol.m_name=='[is]' or self.m_symbol.m_name=='[是]':
            return 1
        elif self.m_symbol.m_name=='[那]':
            return 1
        elif self.m_symbol.m_name=='[]':
            return 1
        elif self.isSpaceRelation():
            return 1
        elif self.m_symbol.m_name[0]=='[' and self.m_symbol.m_name[-1]==']':
            return 2
        return 0


    def isSpaceRelation(self):
        if self.m_buildMode==True:
            return False
        name=self.m_symbol.m_name
        if name=='[上面]' or name=='[下面]' or name=='[左面]' or name=='[右面]':
            return True
        elif name=='[正上面]' or name=='[正下面]' or name=='[正左面]' or name=='[正右面]':
            return True
        elif name=='[当地]':
            return True
        elif name=='[up]' or name=='[down]' or name=='[left]' or name=='[right]':
            return True
        elif name=='[Up]' or name=='[Down]' or name=='[Left]' or name=='[Right]':
            return True
        elif name=='[here]':
            return True
        return False


                
    def Reason_iterative(self,pool,list_new=None):
        if list_new==None:
            list_new=[]
        while True:
            [change,list_pt]=self.Reason_oneStep(pool)
            if self.m_stage==2:
                for clause in self.m_clause:
                    clause.Reason_iterative(pool)
            elif self.m_stage==3:
                for end in self.m_noe:
                    end.Reason_iterative(pool)
                for end in self.m_yese:
                    end.Reason_iterative(pool)
            elif self.m_stage==5:
                break
        return [self.m_reState,list_new]




    def isChosen(self):
        if self.m_cause==None:
            return False
        if self.m_cause.m_choose==False:
            return self in self.m_cause.m_noe
        else:
            return self in self.m_cause.m_yese


    def Reason_oneStep(self,pool):
        list_new=[]
        areaType=self.areaType()
        change=False
        
        if self.m_stage==0:
            if self.m_cause!=None:
                if self in self.m_cause.m_clause:
                    if self.m_cause.m_stage==2:
                        self.m_stage=1
                        change=True
                # else:
                #     if self.m_cause.m_stage==3 and self.isChosen():
                #         self.m_stage=1
                #         change=True
                #         # print(self.m_symbol.info(),'start!','The choose of the cause is:',self.m_cause.m_choose)


        if self.m_stage==1:
            while True:
                if self.stateSelf()!='blue':
                    self.newMap(pool,areaType,list_new)
                else:
                    self.m_interp=False
                # if self.m_map!=None:
                #     print('Map:',self.m_map.info(),self.stateSelf())
                change=True
                if self.stateRelation()==False:
                    continue
                elif self.stateSelf()=='red':
                    continue
                elif self.stateSelf()=='yellow':
                    self.m_stage=5
                    if self.m_no==False:
                        self.m_reState='dark yellow'
                        return [change,list_new]
                    else:
                        self.m_reState='dark green'
                        return [change,list_new]
                elif self.stateSelf()=='blue':
                    self.m_stage=1
                    return [change,list_new]
                else:
                    self.m_stage=2
                    break


        if self.m_stage==2:
            if self.m_clause==[]:
                self.m_choose=True
                self.m_stage=3
                change=True
            else:
                self.m_choose=self.m_clauseAnd
                keep=False
            for clause in self.m_clause:
                if self.m_clauseAnd==True:
                    if clause.m_reState=='dark yellow':
                        self.m_choose=False
                        self.m_stage=3
                        change=True
                        self.m_clauseOut=True
                        break
                    elif clause.m_reState=='':
                        keep=True
                else:
                    if clause.m_reState=='dark green':
                        self.m_choose=True
                        self.m_stage=3
                        change=True
                        self.m_clauseOut=True
                        break
                    elif clause.m_reState=='':
                        keep=True
            if self.m_clause!=[] and keep==False:
                self.m_stage=3
                change=True
                self.m_clauseOut=True


        if self.m_stage==3:
            # print(self.m_symbol.info(),'End type:',self.m_yesAnd)
            if self.m_choose==False:
                if self.m_noe==[]:
                    self.m_stage=1
                    change=True
                    return [change,list_new]


                i=self.m_eoi
                end=self.m_noe[i]
                if end.m_stage==0:
                    end.m_stage=1
                    change=True
                elif end.m_reState=='dark yellow':
                    if self.m_noAnd==True:
                        self.m_stage=1
                        change=True
                    else:
                        i+=1
                        change=True
                        if i==len(self.m_noe):
                            self.m_stage=1
                            self.m_eoi=0
                        else:
                            self.m_eoi=i
                elif end.m_reState=='dark green':
                    if self.m_noAnd!=True:
                        self.m_stage=4
                        change=True
                    else:
                        i+=1
                        change=True
                        if i==len(self.m_noe):
                            self.m_stage=4
                            self.m_eoi=0
                        else:
                            self.m_eoi=i



                # keep=False
                # for end in self.m_noe:
                #     if end.m_reState=='':
                #         keep=True
                #     elif self.m_noAnd==True:
                #         if end.m_reState=='dark yellow':
                #             self.m_stage=1
                #             change=True
                #             return [change,list_new]
                #     else:
                #         if end.m_reState=='dark green':
                #             self.m_stage=4
                #             change=True
                #             break
                # if self.m_stage==3 and keep==False:
                #     if self.m_noAnd==True:
                #         self.m_stage=4
                #         change=True
                #     else:
                #         self.m_stage=1
                #         change=True
                #         return [change,list_new]
            else:
                if self.m_yese==[] and self.m_noe==[]:
                    self.m_stage=4
                    change=True
                elif self.m_yese==[]:
                    self.m_stage=1
                    change=True
                    return [change,list_new]
                else:
                    i=self.m_eoi
                    end=self.m_yese[i]
                    if end.m_stage==0:
                        end.m_stage=1
                        change=True
                    elif end.m_reState=='dark yellow':
                        if self.m_yesAnd==True:
                            self.m_stage=1
                            change=True
                        else:
                            i+=1
                            change=True
                            if i==len(self.m_yese):
                                self.m_stage=1
                                self.m_eoi=0
                            else:
                                self.m_eoi=i
                    elif end.m_reState=='dark green':
                        if self.m_yesAnd!=True:
                            self.m_stage=4
                            change=True
                        else:
                            i+=1
                            change=True
                            if i==len(self.m_yese):
                                self.m_stage=4
                                self.m_eoi=0
                            else:
                                self.m_eoi=i



                    # keep=False
                    # for end in self.m_yese:
                    #     if end.m_reState=='':
                    #         keep=True
                    #     elif self.m_yesAnd==True:
                    #         if end.m_reState=='dark yellow':
                    #             self.m_stage=1
                    #             change=True
                    #             return [change,list_new]
                    #     else:
                    #         if end.m_reState=='dark green':
                    #             self.m_stage=4
                    #             change=True
                    #             break
                    # if keep==False and self.m_stage==3:
                    #     if self.m_yesAnd:
                    #         self.m_stage=4
                    #         change=True
                    #     else:
                    #         self.m_stage=1
                    #         change=True
                    #         return [change,list_new]


        if self.m_stage==4:
            # If clause isn't empty, collect them first
            if self.m_clauseNew!=[] or self.m_clauseOut==True:
                self.m_clauseCollect=True
            # the function points are collected, because they will be deleted after running as tmp points
            if (self.m_buildMode==True or self.isFunctionPoint()==1) and self.m_map!=None and self.m_map not in list_new:
                list_new.append(self.m_map)
            self.m_stage=5
            if self.m_no==True:
                self.m_reState='dark yellow'
                change=True
                return [change,list_new]
            else:
                self.m_reState='dark green'
                change=True
                return [change,list_new]


        return [change,list_new]





    def areaType(self):
        aType=True
        cause=self
        while True:
            if cause.m_no==True:
                aType=not aType
            if cause.m_cause==None:
                return aType
            else:
                cause=cause.m_cause
        



    # def Reason_oneStep(self,pool):
    #     list_new=[]
    #     areaType=self.areaType()
    #     change=False
        
    #     if self.m_stage==0:
    #         if self.m_cause!=None:
    #             if self in self.m_cause.m_clause:
    #                 if self.m_cause.m_stage==2:
    #                     self.m_stage=1
    #                     change=True
    #             else:
    #                 if self.m_cause.m_stage==3 and self.isChosen():
    #                     self.m_stage=1
    #                     change=True
    #                     # print(self.m_symbol.info(),'start!','The choose of the cause is:',self.m_cause.m_choose)


    #     if self.m_stage==1:
    #         while True:
    #             if self.stateSelf()!='blue':
    #                 self.newMap(pool,areaType,list_new)
    #             else:
    #                 self.m_interp=False
    #             # if self.m_map!=None:
    #             #     print('Map:',self.m_map.info(),self.stateSelf())
    #             change=True
    #             if self.stateRelation()==False:
    #                 continue
    #             elif self.stateSelf()=='red':
    #                 continue
    #             elif self.stateSelf()=='yellow':
    #                 self.m_stage=5
    #                 if self.m_no==False:
    #                     self.m_reState='dark yellow'
    #                     return [change,list_new]
    #                 else:
    #                     self.m_reState='dark green'
    #                     return [change,list_new]
    #             elif self.stateSelf()=='blue':
    #                 self.m_stage=1
    #                 return [change,list_new]
    #             else:
    #                 self.m_stage=2
    #                 break


    #     if self.m_stage==2:
    #         if self.m_clause==[]:
    #             self.m_choose=True
    #             self.m_stage=3
    #             change=True
    #         else:
    #             self.m_choose=self.m_clauseAnd
    #             keep=False
    #         for clause in self.m_clause:
    #             if self.m_clauseAnd==True:
    #                 if clause.m_reState=='dark yellow':
    #                     self.m_choose=False
    #                     self.m_stage=3
    #                     change=True
    #                     self.m_clauseOut=True
    #                     break
    #                 elif clause.m_reState=='':
    #                     keep=True
    #             else:
    #                 if clause.m_reState=='dark green':
    #                     self.m_choose=True
    #                     self.m_stage=3
    #                     change=True
    #                     self.m_clauseOut=True
    #                     break
    #                 elif clause.m_reState=='':
    #                     keep=True
    #         if self.m_clause!=[] and keep==False:
    #             self.m_stage=3
    #             change=True
    #             self.m_clauseOut=True


    #     if self.m_stage==3:
    #         # print(self.m_symbol.info(),'End type:',self.m_yesAnd)
    #         if self.m_choose==False:
    #             if self.m_noe==[]:
    #                 self.m_stage=1
    #                 change=True
    #                 return [change,list_new]
    #             keep=False
    #             for end in self.m_noe:
    #                 if end.m_reState=='':
    #                     keep=True
    #                 elif self.m_noAnd==True:
    #                     if end.m_reState=='dark yellow':
    #                         self.m_stage=1
    #                         change=True
    #                         return [change,list_new]
    #                 else:
    #                     if end.m_reState=='dark green':
    #                         self.m_stage=4
    #                         change=True
    #                         break
    #             if self.m_stage==3 and keep==False:
    #                 if self.m_noAnd==True:
    #                     self.m_stage==4
    #                     change=True
    #                 else:
    #                     self.m_stage=1
    #                     change=True
    #                     return [change,list_new]
    #         else:
    #             if self.m_yese==[] and self.m_noe==[]:
    #                 self.m_stage=4
    #                 change=True
    #             elif self.m_yese==[]:
    #                 self.m_stage=1
    #                 change=True
    #                 return [change,list_new]
    #             else:
    #                 keep=False
    #                 for end in self.m_yese:
    #                     if end.m_reState=='':
    #                         keep=True
    #                     elif self.m_yesAnd==True:
    #                         if end.m_reState=='dark yellow':
    #                             self.m_stage=1
    #                             change=True
    #                             return [change,list_new]
    #                     else:
    #                         if end.m_reState=='dark green':
    #                             self.m_stage=4
    #                             change=True
    #                             break
    #                 if keep==False and self.m_stage==3:
    #                     if self.m_yesAnd:
    #                         self.m_stage=4
    #                         change=True
    #                     else:
    #                         self.m_stage=1
    #                         change=True
    #                         return [change,list_new]


    #     if self.m_stage==4:
    #         # If clause isn't empty, collect them first
    #         if self.m_clauseNew!=[] or self.m_clauseOut==True:
    #             self.m_clauseCollect=True
    #         # the function points are collected, because they will be deleted after running as tmp points
    #         if (self.m_buildMode==True or self.isFunctionPoint()==1) and self.m_map!=None:
    #             list_new.append(self.m_map)
    #         self.m_stage=5
    #         if self.m_no==True:
    #             self.m_reState='dark yellow'
    #             change=True
    #             return [change,list_new]
    #         else:
    #             self.m_reState='dark green'
    #             change=True
    #             return [change,list_new]


    #     return [change,list_new]



        




    def build(self,code,points):
        wait_list=[]
        last=self
        connection=None
        exp='(->>|=>>|->|=>|{[ \t\n]*|[ \t\n]*}|,[ \t\n]*|;[ \t\n]*|:[ \t\n]*)'
        units=re.split(exp,code)
        for unit in units:
            if unit=='':
                continue
            elif unit=='->' or unit=='=>' or unit=='->>' or unit=='=>>':
                connection=unit
            elif unit[0]=='{':
                wait_list.append(['clause_splitting',last])
            elif unit[0]==':':
                wait_list.append(['end_splitting',last])
            elif unit[0]==',':
                last=wait_list[-1][1]
            elif unit[0]==';':
                if wait_list[-1][0]=='end_splitting':
                    wait_list.pop()
                if wait_list!=[]:
                    last=wait_list[-1][1]
            elif unit[-1]=='}':
                last=wait_list[-1][1]
                wait_list.pop()
            else:
                current=Karma(points[int(unit)])
                current.m_cause=last
                if connection=='->':
                    current.m_no=False
                    last.m_yese.append(current)
                elif connection=='->>':
                    current.m_no=False
                    last.m_noe.append(current)
                elif connection=='=>':
                    current.m_no=True
                    last.m_yese.append(current)
                elif connection=='=>>':
                    current.m_no=True
                    last.m_noe.append(current)
                else:
                    last.m_clause.append(current)
                connection=''
                last=current
            # print(wait_list)


    def info_cause(self):
        info=''
        karma=self
        while True:
            if karma.m_symbol!=None:
                info=karma.m_symbol.m_name+info
            if karma.m_cause==None:
                break
            if karma in karma.m_cause.m_yese:
                if karma.m_no==True:
                    info='=>'+info
                else:
                    info='->'+info
            elif karma in karma.m_cause.m_noe:
                if karma.m_no==True:
                    info='=>>'+info
                else:
                    info='->>'+info
            elif karma in karma.m_cause.m_clause:
                info='=='+info
            karma=karma.m_cause
        print(info)
        return info


    def allEffects(self):
        list_effects=[self]
        for karma in self.m_clause:
            list_effects+=karma.allEffects()
        for karma in self.m_noe:
            list_effects+=karma.allEffects()
        for karma in self.m_yese:
            list_effects+=karma.allEffects()
        # list_effects.append(self)
        return list_effects


    # def setAllBuildMode(self,mode,list_km):
    #     self.m_buildMode=mode
    #     for point in self.m_symbol.m_con:
    #         for karma in list_km:
    #             if karma.m_symbol==point:
    #                 karma.setAllBuildMode(mode,list_km)


    # one of causes provides map pool for this karma
    def setRangers(self,causes=None):
        connecting=None
        connected=None
        caseNo=100
        if causes==None:
            causes=[]
        # # word(,)
        # elif self.m_buildMode!=True and self.isFunctionPoint()==0:
        #     for cause in causes:
        #         # [pt]->word
        #         if cause.isFunctionPoint()!=0:
        #             # [pt]->word([pt],)
        #             # Why?
        #             if self.m_symbol.m_db[0]==cause.m_symbol or self.m_symbol.m_db[1]==cause.m_symbol:
        #                 connecting=cause
        #                 connected=None
        #                 break
        #             # elif cause.m_symbol.m_db[0]==self.m_symbol or cause.m_symbol.m_db[1]==self.m_symbol:
        #             #     connected=cause
        #             #     break
        #         elif cause.m_buildMode==True and order<1:
        #             # +cause(,self)->self(,)
        #             if cause.m_symbol.m_db[0]==self.m_symbol or cause.m_symbol.m_db[1]==self.m_symbol:
        #                 connected=cause
        #                 order=1
        #             # +cause(,)->self(,+cause)
        #             elif self.m_symbol.m_db[0]==cause.m_symbol or self.m_symbol.m_db[1]==cause.m_symbol:
        #                 connecting=cause
        #         # cause->self
        #         elif order<2:
        #             # cause(,self)
        #             if cause.m_symbol.m_db[0]==self.m_symbol or cause.m_symbol.m_db[1]==self.m_symbol:
        #                 connected=cause
        #                 order=2
        #             # self(,cause)
        #             elif self.m_symbol.m_db[0]==cause.m_symbol or self.m_symbol.m_db[1]==cause.m_symbol:
        #                 connecting=cause
        # word(,)
        elif self.isType('非新建普通链节'):
            for cause in causes:
                # cause(,self)
                if cause.m_symbol.m_db[0]==self.m_symbol or cause.m_symbol.m_db[1]==self.m_symbol:
                    if cause.isType('特殊范围'):
                        connected=cause
                        break
                    elif cause.isType('普通非新建') and caseNo>3:
                        connected=cause
                        caseNo=3
                    elif cause.isType('新建') and caseNo>5:
                        connected=cause
                        caseNo=5
                # self(cause,)
                elif self.m_symbol.m_db[0]==cause.m_symbol or self.m_symbol.m_db[1]==cause.m_symbol:
                    if cause.isType('引用') and caseNo>2:
                        connecting=cause
                        caseNo=2
                    elif cause.isType('普通非新建') and caseNo>4:
                        connecting=cause
                        caseNo=4
                    elif cause.isType('新建') and caseNo>6:
                        connecting=cause
                        caseNo=6
            if connected!=None:
                self.m_ranger=connected
            elif connecting!=None:
                self.m_ranger=connecting
                self.m_rangType=True
        
        # set next one except for [eq], and buildMode==True
        # if self.m_buildMode!=True and self.m_symbol.m_name!='' and self.m_symbol.m_name!='[eq]' and self.m_symbol.m_name!='[同名]':
        # if self.isFunctionPoint()==0 and self.m_buildMode!=True:
        # if self.isFunctionPoint()==0:                                       # a building point can be a ranger of an another point(Why?)(May because of new point can be a answer point)
        causes=causes[:]+[self]


        for con in self.m_clause:
            # for cause in causes:
            #     cause.m_symbol.print()
            con.setRangers(causes)
        for end in self.m_yese:
            end.setRangers(causes)
        for end in self.m_noe:
            end.setRangers(causes)


    def causeEnd(self):
        cause=self
        while cause.m_cause!=None:
            cause=cause.m_cause
        return cause


    def allCauses(self):
        cause=self
        list_km=[]
        while cause.m_cause!=None:
            cause=cause.m_cause
            list_km.append(cause)
        return list_km


    def addKarma(self,karma,con_type='肯定'):
        while karma.m_cause!=None:
            karma=karma.m_cause
        if con_type=="clause" or con_type=="从句":
            self.m_clause.append(karma)
        elif con_type=="no" or con_type=="否定":
            self.m_noe.append(karma)
        else:
            self.m_yese.append(karma)
        karma.m_cause=self


    def __str__(self) -> str:
        return self.info_karma()


    def info_karma(self,info='',head=0,type_info=0):
        if info=='' and self.m_no==True:
            info='[]=>'
        if self.m_ranger!=None and type_info==0:
            ranger=self.m_ranger.m_symbol.info("不显示位置不显示内容")
            info+='['+ranger+']'
            head+=len(ranger)+2
        # if self.m_buildMode==True:
        #     info+='+'
        #     head+=1
            
        info+=self.m_symbol.info("不显示位置不显示内容")
        head+=len(self.m_symbol.info("不显示位置不显示内容"))


        if self.m_clause!=[]:
            info+='{'
            head+=1
            for clause in self.m_clause:
                info+='\n'+''.rjust(head)
                info=clause.info_karma(info,head,type_info)
                if clause!=self.m_clause[-1]:
                    info+=','
            info+='\n'+'}'.rjust(head-1)
        n=0
        if len(self.m_noe)+len(self.m_yese)>1:
            info+=':'
        for end in self.m_yese:
            if n==0:
                if end.m_no==False:
                    info+='->'
                else:
                    info+='=>'
                info=end.info_karma(info,head+2,type_info)
                n+=1
            else:
                if end.m_no==False:
                    info+='\n'+'->'.rjust(head+2)
                else:
                    info+='\n'+'=>'.rjust(head+2)
                info=end.info_karma(info,head,type_info)
            if end!=self.m_yese[-1] or self.m_noe!=[]:
                info+=','
        for end in self.m_noe:
            if n==0:
                if end.m_no==False:
                    info+='->>'
                else:
                    info+='=>>'
                info=end.info_karma(info,head+3,type_info)
                n+=1
            else:
                if end.m_no==False:
                    info+='\n'+'->>'.rjust(head+3)
                else:
                    info+='\n'+'=>>'.rjust(head+3)
                info=end.info_karma(info,head,type_info)
            if end!=self.m_noe[-1]:
                info+=','


        return info
                


        
        
def printPtList(list_pt):
    info_pt='['
    for pt in list_pt:
        info_pt+=pt.info(show_info='不显示文本')
        if pt!=list_pt[-1]:
            info_pt+=', '
        else:
            info_pt+=';'
    info_pt+=']'
    print(info_pt)





def infoInStr(string,str_info):
    a=str_info.find(string)
    return a!=-1





if __name__=='__main__':
    result=infoInStr('新建','新建')
    print(result)
## end
#2117, 4:
2222
## end
#2120, 9:
执行测试(P函数)
## end
#2122, 9:
执行测试(P函数)
## end
#2123, 24:
21.000000000000004, 5.25
## end
#2124, 24:
21.000000000000004, 5.25
## end
#2125, 24:
21.000000000000004, 5.25
## end
#2126, 24:
21.000000000000004, 5.25
## end
#2127, 24:
21.000000000000004, 5.25
## end
#2128, 24:
21.000000000000004, 5.25
## end
#2129, 24:
21.000000000000004, 5.25
## end
#2130, 24:
21.000000000000004, 5.25
## end
#2131, 24:
21.000000000000004, 5.25
## end
#2132, 24:
21.000000000000004, 5.25
## end
#2133, 24:
21.000000000000004, 5.25
## end
#2134, 24:
21.000000000000004, 5.25
## end
#2135, 24:
21.000000000000004, 5.25
## end
#2136, 24:
21.000000000000004, 5.25
## end
#2137, 24:
21.000000000000004, 5.25
## end
#2138, 24:
21.000000000000004, 5.25
## end
#2139, 24:
21.000000000000004, 5.25
## end
#2140, 24:
21.000000000000004, 5.25
## end
#2141, 24:
21.000000000000004, 5.25
## end
#2142, 24:
21.000000000000004, 5.25
## end
#2143, 24:
21.000000000000004, 5.25
## end
#2144, 9:
2.2, 2.35
## end
#2145, 38:
2.4000000000000004, 4.1000000000000005
## end
#2146, 38:
2.4000000000000004, 4.1000000000000005
## end
#2147, 38:
2.4000000000000004, 4.1000000000000005
## end
#2148, 38:
2.4000000000000004, 4.1000000000000005
## end
#2149, 38:
2.4000000000000004, 4.1000000000000005
## end
#2150, 4:
2204
## end
#2152, 4:
2212
## end
#2155, 285:
"""
P代码:...

"""

+移除注释(_文本,_输出)->+[del](,+移除注释)...
->的(移除注释,P代码)...

->+[记住](,_文本)...
->+[python](Python,_输出)->+[code](+[python],P代码)...
->+[.]"text1"(+[python],_文本)...
->+[.]"pro_type"(+[python],+[临时文本])->[m_text](+移除注释,+[临时文本])...

=>m_readPtr(,_输出)->的(_b,m_readPtr)=>+[更新文本](_b,)


## end
#2157, 207:
"""
记住"Python"

"""

import re

if pro_type=="C":
    text=re.sub('\s*//.*','',text1)
    text=re.sub('\n\s*\*.*','',text)
    ans=re.sub('\n\s*/\*.*','',text)
else:
    ans=re.sub('\n\s*#.*','',text1)






## end
#2159, 152:
"""


"""

+列举函数(块,_输出)->+[del](,+列举函数)...

->[]{
    []:->func(块,)->+[增加内容]"
"(func,_输出),
        ->[]
}:
    ->然后(块,块#1)->+[列举函数](块#1,_输出),
    ->[]


## end
#2160, 4:
2214
## end
#2163, 17:


20220513:...



## end
#2165, 622:
记住"自然语言"

代码:...
测试代码:...
+[新建阅读窗口](,代码)
输出结构:...
结构场景:...

将测试代码解析为输出结构
+[调用词典动词](+[做],+解析)->+[做](,测试代码#7)...
->输出结构#8->+为(+[做],输出结构#8)...
    ->+[del](,+为)->[]->[]->测试代码#7

+[调用词典动词](+[做],+解析)->+[做](,代码#7)...
->输出结构#8->+为(+[做],输出结构#8)...
    ->+[del](,+为)->[]->[]->代码#7
查看输出结构
查看输出结构的类"NetPStack"
+[调用词典动词](+[做],+查看)->+[做](,输出结构#9)->[]->[]->输出结构#9
在结构场景中, 将输出结构的函数"conToken"显示为程序流程图

+[显示PPT场景](,结构场景)
+[显示星图](,输出结构)

[python程序_代码](代码,)...
->+[修改内容](,输出结构)->[m_text]([python程序_代码],+[修改内容])
+[删除结构](,结构场景)->+[导入节点](,结构场景)->[m_text](输出结构,+[导入节点])
+[显示星图]"1"(,结构场景)

Nini, 打开花园(文件)

首先是try的模式不完整
然后是remove#的时候, 去掉了过多的东西




## end
#2167, 34330:
起点#0""(,块#1)[-1,-1]
块#1"\"\"\"
\"\"\"
"(,)[-1,-1]
块#2""(,)[-1,-1]
然后#3""(块#1,块#2)[-1,-1]
块#4""(,)[-1,-1]
func#5"removeComment(code)"(块#2,块#4)[-1,-1]
块#6"return code,False
"(,)[-1,-1]
if#7"len(code)==0"(块#4,块#6)[-1,-1]
eof#8""(,)[-1,-1]
然后#9""(块#6,eof#8)[-1,-1]
eof#10""(,)[-1,-1]
然后#11""(块#12,eof#10)[-1,-1]
块#12"code=re.sub(r'^#.*','',code)
"(,)[-1,-1]
elif#13"code[0]=='#'"(if#7,块#12)[-1,-1]
块#14""(,)[-1,-1]
然后#15""(块#36,块#14)[-1,-1]
块#16""(,)[-1,-1]
while#17"True"(块#14,块#16)[-1,-1]
块#18"code=''
break
"(,)[-1,-1]
if#19"len(code)<3"(块#16,块#18)[-1,-1]
eof#20""(,)[-1,-1]
然后#21""(块#18,eof#20)[-1,-1]
eof#22""(,)[-1,-1]
然后#23""(块#24,eof#22)[-1,-1]
块#24"break
"(,)[-1,-1]
elif#25"code[0:3]=='\"\"\"'"(if#19,块#24)[-1,-1]
块#26"code=re.sub(r'^.*\n?','',code)
"(,)[-1,-1]
else#27""(if#19,块#26)[-1,-1]
eof#28""(,)[-1,-1]
然后#29""(块#26,eof#28)[-1,-1]
eof#30""(,)[-1,-1]
然后#31""(块#16,eof#30)[-1,-1]
块#32"code=code[3:]
"(,)[-1,-1]
然后#33""(块#14,块#32)[-1,-1]
eof#34""(,)[-1,-1]
然后#35""(块#32,eof#34)[-1,-1]
块#36"code=code[3:]
"(,)[-1,-1]
elif#37"code[0:3]=='\"\"\"'"(elif#13,块#36)[-1,-1]
块#38"return code,False
"(,)[-1,-1]
else#39""(if#7,块#38)[-1,-1]
eof#40""(,)[-1,-1]
然后#41""(块#38,eof#40)[-1,-1]
块#42"return code,True
"(,)[-1,-1]
然后#43""(块#4,块#42)[-1,-1]
eof#44""(,)[-1,-1]
然后#45""(块#42,eof#44)[-1,-1]
块#46""(,)[-1,-1]
然后#47""(块#2,块#46)[-1,-1]
块#48"list_pt=[]
dict_con={}
list_del=[]
code=re.sub(r'^[ \t\n]*','',code)
L=len(code)
progress=0
N=0
"(,)[-1,-1]
func#49"buildPoints_quick(code)"(块#46,块#48)[-1,-1]
块#50""(,)[-1,-1]
然后#51""(块#48,块#50)[-1,-1]
块#52"code,netP,n0,n1,del_flag=netPToken_quick(code)
list_pt.append(netP)
progress=(L-len(code))/L*100
"(,)[-1,-1]
while#53"code!=''"(块#50,块#52)[-1,-1]
块#54""(,)[-1,-1]
然后#55""(块#52,块#54)[-1,-1]
块#56"print(\"进度: %.2f\"%(progress)+\"%\")
N+=10
"(,)[-1,-1]
if#57"progress >= N"(块#54,块#56)[-1,-1]
eof#58""(,)[-1,-1]
然后#59""(块#56,eof#58)[-1,-1]
块#60"code=re.sub(r'^[ \t\n;]*','',code)
"(,)[-1,-1]
然后#61""(块#54,块#60)[-1,-1]
块#62""(,)[-1,-1]
然后#63""(块#60,块#62)[-1,-1]
块#64"dict_con.update({netP:[n0,n1]})
"(,)[-1,-1]
if#65"n0!=None or n1!=None"(块#62,块#64)[-1,-1]
eof#66""(,)[-1,-1]
然后#67""(块#64,eof#66)[-1,-1]
块#68""(,)[-1,-1]
然后#69""(块#62,块#68)[-1,-1]
块#70"list_del.append(len(list_pt)-1)
"(,)[-1,-1]
if#71"del_flag"(块#68,块#70)[-1,-1]
eof#72""(,)[-1,-1]
然后#73""(块#70,eof#72)[-1,-1]
eof#74""(,)[-1,-1]
然后#75""(块#68,eof#74)[-1,-1]
块#76""(,)[-1,-1]
然后#77""(块#50,块#76)[-1,-1]
块#78"n0,n1=dict_con[pt]
"(,)[-1,-1]
for#79"dict_con"(块#76,块#78)[-1,-1]
变量#80"pt"(for#79,)[-1,-1]
块#81""(,)[-1,-1]
然后#82""(块#78,块#81)[-1,-1]
块#83"pt0=list_pt[n0]
pt.con(pt0,0)
"(,)[-1,-1]
if#84"n0!=None"(块#81,块#83)[-1,-1]
eof#85""(,)[-1,-1]
然后#86""(块#83,eof#85)[-1,-1]
块#87""(,)[-1,-1]
然后#88""(块#81,块#87)[-1,-1]
块#89"pt1=list_pt[n1]
pt.con(0,pt1)
"(,)[-1,-1]
if#90"n1!=None"(块#87,块#89)[-1,-1]
eof#91""(,)[-1,-1]
然后#92""(块#89,eof#91)[-1,-1]
eof#93""(,)[-1,-1]
然后#94""(块#87,eof#93)[-1,-1]
块#95""(,)[-1,-1]
然后#96""(块#76,块#95)[-1,-1]
块#97"print('There are %d invalid points!'%(len(list_del)))
list_del.reverse()
"(,)[-1,-1]
if#98"len(list_del)>0"(块#95,块#97)[-1,-1]
块#99""(,)[-1,-1]
然后#100""(块#97,块#99)[-1,-1]
块#101"print('Deleting %s...'%(list_pt[i].info()))
list_pt.pop(i)
"(,)[-1,-1]
for#102"list_del"(块#99,块#101)[-1,-1]
变量#103"i"(for#102,)[-1,-1]
eof#104""(,)[-1,-1]
然后#105""(块#101,eof#104)[-1,-1]
eof#106""(,)[-1,-1]
然后#107""(块#99,eof#106)[-1,-1]
块#108"return list_pt
"(,)[-1,-1]
然后#109""(块#95,块#108)[-1,-1]
eof#110""(,)[-1,-1]
然后#111""(块#108,eof#110)[-1,-1]
块#112""(,)[-1,-1]
然后#113""(块#46,块#112)[-1,-1]
块#114"title=r'^[\w \[\]~#.+=\-^/*\\!<\']*|^\[>=?\]'
order=r'#.*$'
name=re.match(title,code).group()
code=re.sub(title,'',code)
"(,)[-1,-1]
func#115"netPToken_quick(code)"(块#112,块#114)[-1,-1]
块#116""(,)[-1,-1]
然后#117""(块#114,块#116)[-1,-1]
块#118"print('\n\n\nError! Invalid name.\nCode:',code)
raise Exception('Error! Invalid name.')
"(,)[-1,-1]
if#119"name==''"(块#116,块#118)[-1,-1]
eof#120""(,)[-1,-1]
然后#121""(块#118,eof#120)[-1,-1]
块#122""(,)[-1,-1]
然后#123""(块#116,块#122)[-1,-1]
块#124""(,)[-1,-1]
if#125"name[-1]=='=' or name[-1]=='-'"(块#122,块#124)[-1,-1]
块#126"code=name[-1]+code
name=name[0:-1]
"(,)[-1,-1]
if#127"len(code)>0 and code[0]=='>'"(块#124,块#126)[-1,-1]
eof#128""(,)[-1,-1]
然后#129""(块#126,eof#128)[-1,-1]
eof#130""(,)[-1,-1]
然后#131""(块#124,eof#130)[-1,-1]
块#132"con0_name=''
con1_name=''
text=''
"(,)[-1,-1]
然后#133""(块#122,块#132)[-1,-1]
块#134""(,)[-1,-1]
然后#135""(块#132,块#134)[-1,-1]
块#136"code=code[1:]
[code,text]=textToken(code)
"(,)[-1,-1]
if#137"code!='' and code[0]=='\\"'"(块#134,块#136)[-1,-1]
块#138""(,)[-1,-1]
然后#139""(块#136,块#138)[-1,-1]
块#140"print(code)
raise Exception('Error! Unbalanced quote!')
"(,)[-1,-1]
if#141"code=='' or code[0]!='\\"'"(块#138,块#140)[-1,-1]
eof#142""(,)[-1,-1]
然后#143""(块#140,eof#142)[-1,-1]
块#144"code=code[1:]
"(,)[-1,-1]
然后#145""(块#138,块#144)[-1,-1]
eof#146""(,)[-1,-1]
然后#147""(块#144,eof#146)[-1,-1]
块#148""(,)[-1,-1]
然后#149""(块#134,块#148)[-1,-1]
块#150"code=code[1:]
con0_name=re.match(title,code).group()
code=re.sub(title,'',code)
"(,)[-1,-1]
if#151"code!='' and code[0]=='('"(块#148,块#150)[-1,-1]
块#152""(,)[-1,-1]
然后#153""(块#150,块#152)[-1,-1]
块#154"print(code)
raise Exception('Error! Ilegal net point format. A net point must be title\"text\"(title,title)')
"(,)[-1,-1]
if#155"code=='' or code[0]!=','"(块#152,块#154)[-1,-1]
eof#156""(,)[-1,-1]
然后#157""(块#154,eof#156)[-1,-1]
块#158"code=code[1:]
con1_name=re.match(title,code).group()
code=re.sub(title,'',code)
"(,)[-1,-1]
然后#159""(块#152,块#158)[-1,-1]
块#160""(,)[-1,-1]
然后#161""(块#158,块#160)[-1,-1]
块#162"raise Exception('Error! Unbalanced bracket in a net point format!')
"(,)[-1,-1]
if#163"code=='' or code[0]!=')'"(块#160,块#162)[-1,-1]
eof#164""(,)[-1,-1]
然后#165""(块#162,eof#164)[-1,-1]
块#166"code=code[1:]
"(,)[-1,-1]
然后#167""(块#160,块#166)[-1,-1]
eof#168""(,)[-1,-1]
然后#169""(块#166,eof#168)[-1,-1]
块#170""(,)[-1,-1]
然后#171""(块#148,块#170)[-1,-1]
块#172"print('Warning! There is a point without a name!')
"(,)[-1,-1]
if#173"name==''"(块#170,块#172)[-1,-1]
eof#174""(,)[-1,-1]
然后#175""(块#172,eof#174)[-1,-1]
块#176"n=re.search(order,name)
"(,)[-1,-1]
然后#177""(块#170,块#176)[-1,-1]
块#178""(,)[-1,-1]
然后#179""(块#176,块#178)[-1,-1]
块#180"raise Exception('Error! It\'s not a TOP.')
"(,)[-1,-1]
if#181"n==None"(块#178,块#180)[-1,-1]
eof#182""(,)[-1,-1]
然后#183""(块#180,eof#182)[-1,-1]
块#184"n=n.group()[1:]
int(n)
"(,)[-1,-1]
else#185""(if#181,块#184)[-1,-1]
eof#186""(,)[-1,-1]
然后#187""(块#184,eof#186)[-1,-1]
块#188"name=re.sub(order,'',name)
netP=NetP(name,text)
posFormat=r'^\[(-?\d+), *(-?\d+)\]'
pos=re.findall(posFormat,code)
"(,)[-1,-1]
然后#189""(块#178,块#188)[-1,-1]
块#190""(,)[-1,-1]
然后#191""(块#188,块#190)[-1,-1]
块#192"x=int(pos[0][0])
y=int(pos[0][1])
netP.m_pos=[x,y]
code=re.sub(r'^\[-?\d+, *-?\d+\]','',code)
"(,)[-1,-1]
if#193"pos!=[]"(块#190,块#192)[-1,-1]
eof#194""(,)[-1,-1]
然后#195""(块#192,eof#194)[-1,-1]
块#196"del_flag=False
n0=None
"(,)[-1,-1]
然后#197""(块#190,块#196)[-1,-1]
块#198""(,)[-1,-1]
然后#199""(块#196,块#198)[-1,-1]
块#200""(,)[-1,-1]
块#201"print('Warning! The %s(%s,%s) connects an invalid point'%(name,con0_name,con1_name))
del_flag=True
"(,)[-1,-1]
try#202""(块#198,块#200)[-1,-1]
except#203""(try#202,块#201)[-1,-1]
块#204"str_n0=re.search(order,con0_name).group()
"(,)[-1,-1]
if#205"con0_name!=''"(块#200,块#204)[-1,-1]
块#206""(,)[-1,-1]
然后#207""(块#204,块#206)[-1,-1]
块#208"n0=int(str_n0[1:])
"(,)[-1,-1]
if#209"len(str_n0)>1"(块#206,块#208)[-1,-1]
eof#210""(,)[-1,-1]
然后#211""(块#208,eof#210)[-1,-1]
eof#212""(,)[-1,-1]
然后#213""(块#206,eof#212)[-1,-1]
eof#214""(,)[-1,-1]
然后#215""(块#200,eof#214)[-1,-1]
eof#216""(,)[-1,-1]
然后#217""(块#201,eof#216)[-1,-1]
块#218"n1=None
"(,)[-1,-1]
然后#219""(块#198,块#218)[-1,-1]
块#220""(,)[-1,-1]
然后#221""(块#218,块#220)[-1,-1]
块#222""(,)[-1,-1]
块#223"print('Warning! The %s(%s,%s) connects an invalid point'%(name,con0_name,con1_name))
del_flag=True
"(,)[-1,-1]
try#224""(块#220,块#222)[-1,-1]
except#225""(try#224,块#223)[-1,-1]
块#226"str_n1=re.search(order,con1_name).group()
"(,)[-1,-1]
if#227"con1_name!=''"(块#222,块#226)[-1,-1]
块#228""(,)[-1,-1]
然后#229""(块#226,块#228)[-1,-1]
块#230"n1=int(str_n1[1:])
"(,)[-1,-1]
if#231"len(str_n1)>1"(块#228,块#230)[-1,-1]
eof#232""(,)[-1,-1]
然后#233""(块#230,eof#232)[-1,-1]
eof#234""(,)[-1,-1]
然后#235""(块#228,eof#234)[-1,-1]
eof#236""(,)[-1,-1]
然后#237""(块#222,eof#236)[-1,-1]
eof#238""(,)[-1,-1]
然后#239""(块#223,eof#238)[-1,-1]
块#240"return [code,netP,n0,n1,del_flag]
"(,)[-1,-1]
然后#241""(块#220,块#240)[-1,-1]
eof#242""(,)[-1,-1]
然后#243""(块#240,eof#242)[-1,-1]
块#244""(,)[-1,-1]
然后#245""(块#112,块#244)[-1,-1]
块#246"list_karma=[]
"(,)[-1,-1]
func#247"readSubCode_tokener(code)"(块#244,块#246)[-1,-1]
块#248""(,)[-1,-1]
然后#249""(块#246,块#248)[-1,-1]
块#250"code=re.sub(r'^[ \t\n]*','',code)
"(,)[-1,-1]
while#251"code!=''"(块#248,块#250)[-1,-1]
块#252""(,)[-1,-1]
然后#253""(块#250,块#252)[-1,-1]
块#254"break
"(,)[-1,-1]
if#255"code==''"(块#252,块#254)[-1,-1]
eof#256""(,)[-1,-1]
然后#257""(块#254,eof#256)[-1,-1]
块#258"code,result=removeComment(code)
"(,)[-1,-1]
然后#259""(块#252,块#258)[-1,-1]
块#260""(,)[-1,-1]
然后#261""(块#258,块#260)[-1,-1]
块#262"continue
"(,)[-1,-1]
if#263"result==True"(块#260,块#262)[-1,-1]
eof#264""(,)[-1,-1]
然后#265""(块#262,eof#264)[-1,-1]
块#266"[code,karma,pointStack]=chainToken(code)
pointStack.leaveClause()
karma=karma.causeEnd()
karma.setRangers()
list_karma.append(karma)
"(,)[-1,-1]
else#267""(if#263,块#266)[-1,-1]
块#268""(,)[-1,-1]
然后#269""(块#266,块#268)[-1,-1]
块#270"code=code[1:]
"(,)[-1,-1]
if#271"code!='' and code[0]==';'"(块#268,块#270)[-1,-1]
eof#272""(,)[-1,-1]
然后#273""(块#270,eof#272)[-1,-1]
eof#274""(,)[-1,-1]
然后#275""(块#268,eof#274)[-1,-1]
eof#276""(,)[-1,-1]
然后#277""(块#260,eof#276)[-1,-1]
块#278"return list_karma
"(,)[-1,-1]
然后#279""(块#248,块#278)[-1,-1]
eof#280""(,)[-1,-1]
然后#281""(块#278,eof#280)[-1,-1]
块#282""(,)[-1,-1]
然后#283""(块#244,块#282)[-1,-1]
块#284"list_pt=[]
code=re.sub(r'^[ \t\n]*','',code)
pointStack=NetPStack()
L=len(code)
progress=0
N=0
"(,)[-1,-1]
func#285"buildPoints_tokener(code)"(块#282,块#284)[-1,-1]
块#286""(,)[-1,-1]
然后#287""(块#284,块#286)[-1,-1]
块#288"code,netP,pointStack=netPToken(code,pointStack)
list_pt.append(netP)
progress=(L-len(code))/L*100
"(,)[-1,-1]
while#289"code!=''"(块#286,块#288)[-1,-1]
块#290""(,)[-1,-1]
然后#291""(块#288,块#290)[-1,-1]
块#292"print(\"进度: %.2f\"%(progress)+\"%\")
N+=10
"(,)[-1,-1]
if#293"progress >= N"(块#290,块#292)[-1,-1]
eof#294""(,)[-1,-1]
然后#295""(块#292,eof#294)[-1,-1]
块#296"code=re.sub(r'^[ \t\n;]*','',code)
"(,)[-1,-1]
然后#297""(块#290,块#296)[-1,-1]
eof#298""(,)[-1,-1]
然后#299""(块#296,eof#298)[-1,-1]
块#300"return list_pt
"(,)[-1,-1]
然后#301""(块#286,块#300)[-1,-1]
eof#302""(,)[-1,-1]
然后#303""(块#300,eof#302)[-1,-1]
块#304""(,)[-1,-1]
然后#305""(块#282,块#304)[-1,-1]
块#306"list_sent=[]
"(,)[-1,-1]
func#307"divideSents_tokener(code)"(块#304,块#306)[-1,-1]
块#308""(,)[-1,-1]
然后#309""(块#306,块#308)[-1,-1]
块#310"code=re.sub(r'^[ \t\n]*','',code)
"(,)[-1,-1]
while#311"code!=''"(块#308,块#310)[-1,-1]
块#312""(,)[-1,-1]
然后#313""(块#310,块#312)[-1,-1]
块#314"break
"(,)[-1,-1]
if#315"code==''"(块#312,块#314)[-1,-1]
eof#316""(,)[-1,-1]
然后#317""(块#314,eof#316)[-1,-1]
块#318"code,result=removeComment(code)
"(,)[-1,-1]
然后#319""(块#312,块#318)[-1,-1]
块#320""(,)[-1,-1]
然后#321""(块#318,块#320)[-1,-1]
块#322"continue
"(,)[-1,-1]
if#323"result==True"(块#320,块#322)[-1,-1]
eof#324""(,)[-1,-1]
然后#325""(块#322,eof#324)[-1,-1]
块#326"code_keep=code
[code,karma,pointStack]=chainToken(code)
si=code_keep.rfind(code)
text=code_keep[0:si]
"(,)[-1,-1]
然后#327""(块#320,块#326)[-1,-1]
块#328""(,)[-1,-1]
然后#329""(块#326,块#328)[-1,-1]
块#330"code=code[1:]
"(,)[-1,-1]
if#331"code!='' and code[0]==';'"(块#328,块#330)[-1,-1]
eof#332""(,)[-1,-1]
然后#333""(块#330,eof#332)[-1,-1]
块#334"sent=NetP(karma.m_symbol.m_name,text)
list_sent.append(sent)
"(,)[-1,-1]
然后#335""(块#328,块#334)[-1,-1]
eof#336""(,)[-1,-1]
然后#337""(块#334,eof#336)[-1,-1]
块#338"return list_sent
"(,)[-1,-1]
然后#339""(块#308,块#338)[-1,-1]
eof#340""(,)[-1,-1]
然后#341""(块#338,eof#340)[-1,-1]
块#342""(,)[-1,-1]
然后#343""(块#304,块#342)[-1,-1]
块#344""(,)[-1,-1]
func#345"chainToken(code,pointStack=None)"(块#342,块#344)[-1,-1]
块#346"pointStack=NetPStack()
"(,)[-1,-1]
if#347"pointStack==None"(块#344,块#346)[-1,-1]
eof#348""(,)[-1,-1]
然后#349""(块#346,eof#348)[-1,-1]
块#350"[code,karma,pointStack]=karmaToken(code,pointStack)
"(,)[-1,-1]
然后#351""(块#344,块#350)[-1,-1]
块#352""(,)[-1,-1]
然后#353""(块#350,块#352)[-1,-1]
块#354"return [code,karma,pointStack]
"(,)[-1,-1]
if#355"code=='' or code[0]==';' or code[0]=='\n' or code[0]=='}'"(块#352,块#354)[-1,-1]
eof#356""(,)[-1,-1]
然后#357""(块#354,eof#356)[-1,-1]
eof#358""(,)[-1,-1]
然后#359""(块#360,eof#358)[-1,-1]
块#360"return [code,karma,pointStack]
"(,)[-1,-1]
elif#361"code[0]==','"(if#355,块#360)[-1,-1]
eof#362""(,)[-1,-1]
然后#363""(块#364,eof#362)[-1,-1]
块#364"code=code[1:]
[code,karma,pointStack]=splitToken(code,karma,pointStack)
"(,)[-1,-1]
elif#365"code[0]==':'"(elif#361,块#364)[-1,-1]
块#366""(,)[-1,-1]
然后#367""(块#384,块#366)[-1,-1]
块#368""(,)[-1,-1]
if#369"code!='' and code[0]==':'"(块#366,块#368)[-1,-1]
块#370"karma.m_noAnd=False
karma.m_yesAnd=False
"(,)[-1,-1]
if#371"typeSub=='|'"(块#368,块#370)[-1,-1]
eof#372""(,)[-1,-1]
然后#373""(块#370,eof#372)[-1,-1]
块#374"karma.m_noAnd=True
karma.m_yesAnd=True
"(,)[-1,-1]
else#375""(if#371,块#374)[-1,-1]
eof#376""(,)[-1,-1]
然后#377""(块#374,eof#376)[-1,-1]
块#378"code=code[1:]
[code,karma,pointStack]=splitToken(code,karma,pointStack)
"(,)[-1,-1]
然后#379""(块#368,块#378)[-1,-1]
eof#380""(,)[-1,-1]
然后#381""(块#378,eof#380)[-1,-1]
eof#382""(,)[-1,-1]
然后#383""(块#366,eof#382)[-1,-1]
块#384"typeSub=code[0]
code=code[1:]
"(,)[-1,-1]
elif#385"code[0]=='|' or code[0]=='&'"(elif#365,块#384)[-1,-1]
块#386"[code,typeCon]=conToken(code)
[code,effect,pointStack]=chainToken(code,pointStack)
buildRelation(karma,typeCon,effect)
"(,)[-1,-1]
else#387""(if#355,块#386)[-1,-1]
eof#388""(,)[-1,-1]
然后#389""(块#386,eof#388)[-1,-1]
块#390"return [code,karma,pointStack]
"(,)[-1,-1]
然后#391""(块#352,块#390)[-1,-1]
eof#392""(,)[-1,-1]
然后#393""(块#390,eof#392)[-1,-1]
块#394""(,)[-1,-1]
然后#395""(块#342,块#394)[-1,-1]
块#396""(,)[-1,-1]
func#397"conToken(code)"(块#394,块#396)[-1,-1]
块#398"code=re.sub(r'^\.\.\..*[\n\t ]*','',code)
"(,)[-1,-1]
while#399"len(code)>3 and code[0:3]=='...'"(块#396,块#398)[-1,-1]
eof#400""(,)[-1,-1]
然后#401""(块#398,eof#400)[-1,-1]
块#402"code=re.sub(r'^[ \t]*','',code)
"(,)[-1,-1]
然后#403""(块#396,块#402)[-1,-1]
块#404""(,)[-1,-1]
然后#405""(块#402,块#404)[-1,-1]
块#406"typeCon=code[0:3]
code=code[3:]
"(,)[-1,-1]
if#407"len(code)>2 and code[0:3]=='->>'"(块#404,块#406)[-1,-1]
eof#408""(,)[-1,-1]
然后#409""(块#406,eof#408)[-1,-1]
eof#410""(,)[-1,-1]
然后#411""(块#412,eof#410)[-1,-1]
块#412"typeCon=code[0:3]
code=code[3:]
"(,)[-1,-1]
elif#413"len(code)>2 and code[0:3]=='=>>'"(if#407,块#412)[-1,-1]
eof#414""(,)[-1,-1]
然后#415""(块#416,eof#414)[-1,-1]
块#416"typeCon=code[0:2]
code=code[2:]
"(,)[-1,-1]
elif#417"len(code)>1 and code[0:2]=='->'"(elif#413,块#416)[-1,-1]
eof#418""(,)[-1,-1]
然后#419""(块#420,eof#418)[-1,-1]
块#420"typeCon=code[0:2]
code=code[2:]
"(,)[-1,-1]
elif#421"len(code)>1 and code[0:2]=='=>'"(elif#417,块#420)[-1,-1]
块#422"print('\n\n\nIllegal connection symbol!\nCode:',code)
raise Exception('Illegal connection symbol!')
"(,)[-1,-1]
else#423""(if#407,块#422)[-1,-1]
eof#424""(,)[-1,-1]
然后#425""(块#422,eof#424)[-1,-1]
块#426"code=re.sub(r'^[ \t]*','',code)
return [code,typeCon]
"(,)[-1,-1]
然后#427""(块#404,块#426)[-1,-1]
eof#428""(,)[-1,-1]
然后#429""(块#426,eof#428)[-1,-1]
块#430""(,)[-1,-1]
然后#431""(块#394,块#430)[-1,-1]
块#432"pointStack.enterClause()
"(,)[-1,-1]
func#433"clauseToken(code,karma,pointStack)"(块#430,块#432)[-1,-1]
块#434""(,)[-1,-1]
然后#435""(块#432,块#434)[-1,-1]
块#436"code=re.sub(r'^[ \t\n]*','',code)
"(,)[-1,-1]
while#437"True"(块#434,块#436)[-1,-1]
块#438""(,)[-1,-1]
然后#439""(块#436,块#438)[-1,-1]
块#440"raise Exception('Error! Unbalanced bracket!')
"(,)[-1,-1]
if#441"code==''"(块#438,块#440)[-1,-1]
eof#442""(,)[-1,-1]
然后#443""(块#440,eof#442)[-1,-1]
eof#444""(,)[-1,-1]
然后#445""(块#446,eof#444)[-1,-1]
块#446"break
"(,)[-1,-1]
elif#447"code[0]=='}'"(if#441,块#446)[-1,-1]
块#448"[code,clause,pointStack]=chainToken(code,pointStack)
karma.m_clause.append(clause)
clause.m_cause=karma
"(,)[-1,-1]
else#449""(if#441,块#448)[-1,-1]
块#450""(,)[-1,-1]
然后#451""(块#448,块#450)[-1,-1]
块#452"break
"(,)[-1,-1]
if#453"code!='' and code[0]!=','"(块#450,块#452)[-1,-1]
eof#454""(,)[-1,-1]
然后#455""(块#452,eof#454)[-1,-1]
eof#456""(,)[-1,-1]
然后#457""(块#458,eof#456)[-1,-1]
块#458"code=code[1:]
"(,)[-1,-1]
elif#459"code!=''"(if#453,块#458)[-1,-1]
eof#460""(,)[-1,-1]
然后#461""(块#450,eof#460)[-1,-1]
eof#462""(,)[-1,-1]
然后#463""(块#438,eof#462)[-1,-1]
块#464"pointStack.leaveClause()
return [code,karma,pointStack]
"(,)[-1,-1]
然后#465""(块#434,块#464)[-1,-1]
eof#466""(,)[-1,-1]
然后#467""(块#464,eof#466)[-1,-1]
块#468""(,)[-1,-1]
然后#469""(块#430,块#468)[-1,-1]
块#470""(,)[-1,-1]
func#471"splitToken(code,karma,pointStack)"(块#468,块#470)[-1,-1]
块#472"code=re.sub(r'^[ \t\n]*','',code)
[code,typeCon]=conToken(code)
[code,effect,pointStack]=chainToken(code,pointStack)
buildRelation(karma,typeCon,effect)
code=re.sub(r'^[ \t\n]*','',code)
"(,)[-1,-1]
while#473"True"(块#470,块#472)[-1,-1]
块#474""(,)[-1,-1]
然后#475""(块#472,块#474)[-1,-1]
块#476"break
"(,)[-1,-1]
if#477"code=='' or code[0]==';' or code[0]=='}'"(块#474,块#476)[-1,-1]
eof#478""(,)[-1,-1]
然后#479""(块#476,eof#478)[-1,-1]
eof#480""(,)[-1,-1]
然后#481""(块#482,eof#480)[-1,-1]
块#482"print('\n\n\n\nError! Ilegal splitting type!\nCode:',code)
raise Exception('Error! Ilegal splitting type!')
"(,)[-1,-1]
elif#483"code[0]!=','"(if#477,块#482)[-1,-1]
块#484"code=code[1:]
"(,)[-1,-1]
else#485""(if#477,块#484)[-1,-1]
eof#486""(,)[-1,-1]
然后#487""(块#484,eof#486)[-1,-1]
eof#488""(,)[-1,-1]
然后#489""(块#474,eof#488)[-1,-1]
块#490"return [code,karma,pointStack]
"(,)[-1,-1]
然后#491""(块#470,块#490)[-1,-1]
eof#492""(,)[-1,-1]
然后#493""(块#490,eof#492)[-1,-1]
块#494""(,)[-1,-1]
然后#495""(块#468,块#494)[-1,-1]
块#496""(,)[-1,-1]
func#497"karmaToken(code,pointStack)"(块#494,块#496)[-1,-1]
块#498"raise Exception('Error! Invalid karma detected!')
"(,)[-1,-1]
if#499"code==''"(块#496,块#498)[-1,-1]
eof#500""(,)[-1,-1]
然后#501""(块#498,eof#500)[-1,-1]
块#502"buildType=False
karma=None
"(,)[-1,-1]
然后#503""(块#496,块#502)[-1,-1]
块#504""(,)[-1,-1]
然后#505""(块#502,块#504)[-1,-1]
块#506"buildType=True
"(,)[-1,-1]
if#507"code[0]=='+'"(块#504,块#506)[-1,-1]
eof#508""(,)[-1,-1]
然后#509""(块#506,eof#508)[-1,-1]
块#510"[code,netP,pointStack]=netPToken(code,pointStack)
karma=Karma(netP)
"(,)[-1,-1]
然后#511""(块#504,块#510)[-1,-1]
块#512""(,)[-1,-1]
然后#513""(块#510,块#512)[-1,-1]
块#514"netP.m_name=netP.m_name[1:]
karma.m_buildMode=True
"(,)[-1,-1]
if#515"buildType==True and netP.m_name!='+'"(块#512,块#514)[-1,-1]
eof#516""(,)[-1,-1]
然后#517""(块#514,eof#516)[-1,-1]
块#518""(,)[-1,-1]
然后#519""(块#512,块#518)[-1,-1]
块#520"code=code[1:]
[code,karma,pointStack]=clauseToken(code,karma,pointStack)
code=re.sub(r'^[\n\t ]*','',code)
"(,)[-1,-1]
if#521"code!='' and code[0]=='{'"(块#518,块#520)[-1,-1]
块#522""(,)[-1,-1]
然后#523""(块#520,块#522)[-1,-1]
块#524"print('\n\n\nError! Unbalanced bracket.\nCode:',code)
raise Exception('Error! Unbalanced bracket.')
"(,)[-1,-1]
if#525"code=='' or code[0]!='}'"(块#522,块#524)[-1,-1]
eof#526""(,)[-1,-1]
然后#527""(块#524,eof#526)[-1,-1]
块#528"code=code[1:]
"(,)[-1,-1]
else#529""(if#525,块#528)[-1,-1]
eof#530""(,)[-1,-1]
然后#531""(块#528,eof#530)[-1,-1]
eof#532""(,)[-1,-1]
然后#533""(块#522,eof#532)[-1,-1]
块#534""(,)[-1,-1]
然后#535""(块#566,块#534)[-1,-1]
块#536""(,)[-1,-1]
if#537"code!='' and code[0]=='{'"(块#534,块#536)[-1,-1]
块#538"karma.m_clauseAnd=False
"(,)[-1,-1]
if#539"typeSub=='|'"(块#536,块#538)[-1,-1]
eof#540""(,)[-1,-1]
然后#541""(块#538,eof#540)[-1,-1]
块#542"karma.m_clauseAnd=True
"(,)[-1,-1]
else#543""(if#539,块#542)[-1,-1]
eof#544""(,)[-1,-1]
然后#545""(块#542,eof#544)[-1,-1]
块#546"code=code[1:]
[code,karma,pointStack]=clauseToken(code,karma,pointStack)
code=re.sub(r'^[\n\t ]*','',code)
"(,)[-1,-1]
然后#547""(块#536,块#546)[-1,-1]
块#548""(,)[-1,-1]
然后#549""(块#546,块#548)[-1,-1]
块#550"raise Exception('Error! Unbalanced bracket.')
"(,)[-1,-1]
if#551"code=='' or code[0]!='}'"(块#548,块#550)[-1,-1]
eof#552""(,)[-1,-1]
然后#553""(块#550,eof#552)[-1,-1]
块#554"code=code[1:]
"(,)[-1,-1]
else#555""(if#551,块#554)[-1,-1]
eof#556""(,)[-1,-1]
然后#557""(块#554,eof#556)[-1,-1]
eof#558""(,)[-1,-1]
然后#559""(块#548,eof#558)[-1,-1]
块#560"code=typeSub+code
"(,)[-1,-1]
else#561""(if#537,块#560)[-1,-1]
eof#562""(,)[-1,-1]
然后#563""(块#560,eof#562)[-1,-1]
eof#564""(,)[-1,-1]
然后#565""(块#534,eof#564)[-1,-1]
块#566"typeSub=code[0]
code=code[1:]
"(,)[-1,-1]
elif#567"code!='' and (code[0]=='|' or code[0]=='&')"(if#521,块#566)[-1,-1]
块#568"return [code,karma,pointStack]
"(,)[-1,-1]
然后#569""(块#518,块#568)[-1,-1]
eof#570""(,)[-1,-1]
然后#571""(块#568,eof#570)[-1,-1]
块#572""(,)[-1,-1]
然后#573""(块#494,块#572)[-1,-1]
块#574"title=r'^[\w \[\]~#.+=\-^/*\\!<\']*|^\[>=?\]'
name=re.match(title,code).group()
code=re.sub(title,'',code)
"(,)[-1,-1]
func#575"netPToken(code,pointStack)"(块#572,块#574)[-1,-1]
块#576""(,)[-1,-1]
然后#577""(块#574,块#576)[-1,-1]
块#578"print('\n\n\nError! Invalid name.\nCode:',code)
raise Exception('Error! Invalid name.')
"(,)[-1,-1]
if#579"name==''"(块#576,块#578)[-1,-1]
eof#580""(,)[-1,-1]
然后#581""(块#578,eof#580)[-1,-1]
块#582""(,)[-1,-1]
然后#583""(块#576,块#582)[-1,-1]
块#584""(,)[-1,-1]
if#585"name[-1]=='=' or name[-1]=='-'"(块#582,块#584)[-1,-1]
块#586"code=name[-1]+code
name=name[0:-1]
"(,)[-1,-1]
if#587"len(code)>0 and code[0]=='>'"(块#584,块#586)[-1,-1]
eof#588""(,)[-1,-1]
然后#589""(块#586,eof#588)[-1,-1]
eof#590""(,)[-1,-1]
然后#591""(块#584,eof#590)[-1,-1]
块#592"con0_name=''
con1_name=''
text=''
"(,)[-1,-1]
然后#593""(块#582,块#592)[-1,-1]
块#594""(,)[-1,-1]
然后#595""(块#592,块#594)[-1,-1]
块#596"code=code[1:]
[code,text]=textToken(code)
"(,)[-1,-1]
if#597"code!='' and code[0]=='\\"'"(块#594,块#596)[-1,-1]
块#598""(,)[-1,-1]
然后#599""(块#596,块#598)[-1,-1]
块#600"print(code)
raise Exception('Error! Unbalanced quote!')
"(,)[-1,-1]
if#601"code=='' or code[0]!='\\"'"(块#598,块#600)[-1,-1]
eof#602""(,)[-1,-1]
然后#603""(块#600,eof#602)[-1,-1]
块#604"code=code[1:]
"(,)[-1,-1]
然后#605""(块#598,块#604)[-1,-1]
eof#606""(,)[-1,-1]
然后#607""(块#604,eof#606)[-1,-1]
块#608""(,)[-1,-1]
然后#609""(块#594,块#608)[-1,-1]
块#610"code=code[1:]
con0_name=re.match(title,code).group()
code=re.sub(title,'',code)
"(,)[-1,-1]
if#611"code!='' and code[0]=='('"(块#608,块#610)[-1,-1]
块#612""(,)[-1,-1]
然后#613""(块#610,块#612)[-1,-1]
块#614"print(code)
raise Exception('Error! Ilegal net point format. A net point must be title\"text\"(title,title)')
"(,)[-1,-1]
if#615"code=='' or code[0]!=','"(块#612,块#614)[-1,-1]
eof#616""(,)[-1,-1]
然后#617""(块#614,eof#616)[-1,-1]
块#618"code=code[1:]
con1_name=re.match(title,code).group()
code=re.sub(title,'',code)
"(,)[-1,-1]
然后#619""(块#612,块#618)[-1,-1]
块#620""(,)[-1,-1]
然后#621""(块#618,块#620)[-1,-1]
块#622"raise Exception('Error! Unbalanced bracket in a net point format!')
"(,)[-1,-1]
if#623"code=='' or code[0]!=')'"(块#620,块#622)[-1,-1]
eof#624""(,)[-1,-1]
然后#625""(块#622,eof#624)[-1,-1]
块#626"code=code[1:]
"(,)[-1,-1]
然后#627""(块#620,块#626)[-1,-1]
eof#628""(,)[-1,-1]
然后#629""(块#626,eof#628)[-1,-1]
块#630""(,)[-1,-1]
然后#631""(块#608,块#630)[-1,-1]
块#632"print('Warning! There is a point without a name!')
"(,)[-1,-1]
if#633"name==''"(块#630,块#632)[-1,-1]
eof#634""(,)[-1,-1]
然后#635""(块#632,eof#634)[-1,-1]
块#636"netP=pointStack.buildNetP(name,con0_name,con1_name)
posFormat=r'^\[(-?\d+), *(-?\d+)\]'
pos=re.findall(posFormat,code)
"(,)[-1,-1]
然后#637""(块#630,块#636)[-1,-1]
块#638""(,)[-1,-1]
然后#639""(块#636,块#638)[-1,-1]
块#640"x=int(pos[0][0])
y=int(pos[0][1])
netP.m_pos=[x,y]
code=re.sub(r'^\[-?\d+, *-?\d+\]','',code)
"(,)[-1,-1]
if#641"pos!=[]"(块#638,块#640)[-1,-1]
eof#642""(,)[-1,-1]
然后#643""(块#640,eof#642)[-1,-1]
块#644"netP.m_text=text
return [code,netP,pointStack]
"(,)[-1,-1]
然后#645""(块#638,块#644)[-1,-1]
eof#646""(,)[-1,-1]
然后#647""(块#644,eof#646)[-1,-1]
块#648""(,)[-1,-1]
然后#649""(块#572,块#648)[-1,-1]
块#650"text=''
preEnd=True
"(,)[-1,-1]
func#651"textToken(code)"(块#648,块#650)[-1,-1]
块#652""(,)[-1,-1]
然后#653""(块#650,块#652)[-1,-1]
块#654""(,)[-1,-1]
while#655"True"(块#652,块#654)[-1,-1]
块#656"break
"(,)[-1,-1]
if#657"code==''"(块#654,块#656)[-1,-1]
eof#658""(,)[-1,-1]
然后#659""(块#656,eof#658)[-1,-1]
eof#660""(,)[-1,-1]
然后#661""(块#662,eof#660)[-1,-1]
块#662"preEnd=False
"(,)[-1,-1]
elif#663"len(code)>1 and code[0:2]=='\\\"'"(if#657,块#662)[-1,-1]
eof#664""(,)[-1,-1]
然后#665""(块#666,eof#664)[-1,-1]
块#666"break
"(,)[-1,-1]
elif#667"code[0]=='\\"' and preEnd==True"(elif#663,块#666)[-1,-1]
块#668"text+=code[0]
preEnd=True
"(,)[-1,-1]
else#669""(if#657,块#668)[-1,-1]
eof#670""(,)[-1,-1]
然后#671""(块#668,eof#670)[-1,-1]
块#672"code=code[1:]
"(,)[-1,-1]
然后#673""(块#654,块#672)[-1,-1]
eof#674""(,)[-1,-1]
然后#675""(块#672,eof#674)[-1,-1]
块#676"return [code,text]
"(,)[-1,-1]
然后#677""(块#652,块#676)[-1,-1]
eof#678""(,)[-1,-1]
然后#679""(块#676,eof#678)[-1,-1]
块#680""(,)[-1,-1]
然后#681""(块#648,块#680)[-1,-1]
块#682""(,)[-1,-1]
func#683"buildRelation(karma,typeCon,effect)"(块#680,块#682)[-1,-1]
块#684"karma.m_yese.append(effect)
"(,)[-1,-1]
if#685"typeCon=='->'"(块#682,块#684)[-1,-1]
eof#686""(,)[-1,-1]
然后#687""(块#684,eof#686)[-1,-1]
eof#688""(,)[-1,-1]
然后#689""(块#690,eof#688)[-1,-1]
块#690"karma.m_noe.append(effect)
"(,)[-1,-1]
elif#691"typeCon=='->>'"(if#685,块#690)[-1,-1]
eof#692""(,)[-1,-1]
然后#693""(块#694,eof#692)[-1,-1]
块#694"karma.m_yese.append(effect)
effect.m_no=True
"(,)[-1,-1]
elif#695"typeCon=='=>'"(elif#691,块#694)[-1,-1]
eof#696""(,)[-1,-1]
然后#697""(块#698,eof#696)[-1,-1]
块#698"karma.m_noe.append(effect)
effect.m_no=True
"(,)[-1,-1]
elif#699"typeCon=='=>>'"(elif#695,块#698)[-1,-1]
块#700"raise Exception('Error! Ilegal connection type!')
"(,)[-1,-1]
else#701""(if#685,块#700)[-1,-1]
eof#702""(,)[-1,-1]
然后#703""(块#700,eof#702)[-1,-1]
块#704"effect.m_cause=karma
"(,)[-1,-1]
然后#705""(块#682,块#704)[-1,-1]
eof#706""(,)[-1,-1]
然后#707""(块#704,eof#706)[-1,-1]
块#708""(,)[-1,-1]
然后#709""(块#680,块#708)[-1,-1]
块#710"fcode_pt=\"### 节点\n\"
fcode_con=\"### 关联\n\"
fcode_text=\"### 内容\n\"
i=0
"(,)[-1,-1]
func#711"genFCode(list_pt)"(块#708,块#710)[-1,-1]
块#712""(,)[-1,-1]
然后#713""(块#710,块#712)[-1,-1]
块#714"fcode_pt+=pt.m_name+\", \"
pt.m_name+=\"#%d\"%(i)
length=len(pt.m_text)
"(,)[-1,-1]
for#715"list_pt"(块#712,块#714)[-1,-1]
变量#716"pt"(for#715,)[-1,-1]
块#717""(,)[-1,-1]
然后#718""(块#714,块#717)[-1,-1]
块#719"fcode_text+=\"#%d, %d:\n%s\n## end\n\"%(i,length,pt.m_text)
"(,)[-1,-1]
if#720"length!=0"(块#717,块#719)[-1,-1]
eof#721""(,)[-1,-1]
然后#722""(块#719,eof#721)[-1,-1]
块#723"i+=1
"(,)[-1,-1]
然后#724""(块#717,块#723)[-1,-1]
eof#725""(,)[-1,-1]
然后#726""(块#723,eof#725)[-1,-1]
块#727""(,)[-1,-1]
然后#728""(块#712,块#727)[-1,-1]
块#729"con1=\"\"
"(,)[-1,-1]
for#730"list_pt"(块#727,块#729)[-1,-1]
变量#731"pt"(for#730,)[-1,-1]
块#732""(,)[-1,-1]
然后#733""(块#729,块#732)[-1,-1]
块#734"i=pt.m_db[0].m_name.rfind('#')
"(,)[-1,-1]
if#735"pt.m_db[0]!=None"(块#732,块#734)[-1,-1]
块#736""(,)[-1,-1]
然后#737""(块#734,块#736)[-1,-1]
块#738"con1=pt.m_db[0].m_name[i+1:]
"(,)[-1,-1]
if#739"i!=-1"(块#736,块#738)[-1,-1]
eof#740""(,)[-1,-1]
然后#741""(块#738,eof#740)[-1,-1]
块#742"con1=\"del\"
"(,)[-1,-1]
else#743""(if#739,块#742)[-1,-1]
eof#744""(,)[-1,-1]
然后#745""(块#742,eof#744)[-1,-1]
eof#746""(,)[-1,-1]
然后#747""(块#736,eof#746)[-1,-1]
块#748"con2=\"#\"
"(,)[-1,-1]
然后#749""(块#732,块#748)[-1,-1]
块#750""(,)[-1,-1]
然后#751""(块#748,块#750)[-1,-1]
块#752"i=pt.m_db[1].m_name.rfind('#')
"(,)[-1,-1]
if#753"pt.m_db[1]!=None"(块#750,块#752)[-1,-1]
块#754""(,)[-1,-1]
然后#755""(块#752,块#754)[-1,-1]
块#756"con2=pt.m_db[1].m_name[i:]
"(,)[-1,-1]
if#757"i!=-1"(块#754,块#756)[-1,-1]
eof#758""(,)[-1,-1]
然后#759""(块#756,eof#758)[-1,-1]
块#760"con2=\"#del\"
"(,)[-1,-1]
else#761""(if#757,块#760)[-1,-1]
eof#762""(,)[-1,-1]
然后#763""(块#760,eof#762)[-1,-1]
eof#764""(,)[-1,-1]
然后#765""(块#754,eof#764)[-1,-1]
块#766"fcode_con+=\"%s%s, \"%(con1,con2)
"(,)[-1,-1]
然后#767""(块#750,块#766)[-1,-1]
eof#768""(,)[-1,-1]
然后#769""(块#766,eof#768)[-1,-1]
块#770""(,)[-1,-1]
然后#771""(块#727,块#770)[-1,-1]
块#772"i=pt.m_name.find('#')
pt.m_name=pt.m_name[0:i]
"(,)[-1,-1]
for#773"list_pt"(块#770,块#772)[-1,-1]
变量#774"pt"(for#773,)[-1,-1]
eof#775""(,)[-1,-1]
然后#776""(块#772,eof#775)[-1,-1]
块#777"fcode=fcode_pt+\"\n\"+fcode_con+\"\n\"+fcode_text+\"### 结束\"
return fcode
"(,)[-1,-1]
然后#778""(块#770,块#777)[-1,-1]
eof#779""(,)[-1,-1]
然后#780""(块#777,eof#779)[-1,-1]
块#781""(,)[-1,-1]
然后#782""(块#708,块#781)[-1,-1]
块#783"list_pt=[]
list_del=[]
code=fcode
"(,)[-1,-1]
func#784"loadFCode(fcode)"(块#781,块#783)[-1,-1]
块#785""(,)[-1,-1]
然后#786""(块#783,块#785)[-1,-1]
块#787"raise(\"错误! 没有检测到节点段落. \")
"(,)[-1,-1]
if#788"code[0:7]!=\"### 节点\n\""(块#785,块#787)[-1,-1]
eof#789""(,)[-1,-1]
然后#790""(块#787,eof#789)[-1,-1]
块#791"code=code[7:]
print(\"开始输入节点... \")
i=-2
"(,)[-1,-1]
然后#792""(块#785,块#791)[-1,-1]
块#793""(,)[-1,-1]
然后#794""(块#791,块#793)[-1,-1]
块#795"code=code[i+2:]
"(,)[-1,-1]
while#796"True"(块#793,块#795)[-1,-1]
块#797""(,)[-1,-1]
然后#798""(块#795,块#797)[-1,-1]
块#799"break
"(,)[-1,-1]
if#800"code==''"(块#797,块#799)[-1,-1]
eof#801""(,)[-1,-1]
然后#802""(块#799,eof#801)[-1,-1]
eof#803""(,)[-1,-1]
然后#804""(块#805,eof#803)[-1,-1]
块#805"code=code[1:]
break
"(,)[-1,-1]
elif#806"code[0]=='\n'"(if#800,块#805)[-1,-1]
块#807"i=code.find(\", \")
"(,)[-1,-1]
然后#808""(块#797,块#807)[-1,-1]
块#809""(,)[-1,-1]
然后#810""(块#807,块#809)[-1,-1]
块#811"raise(\"错误! 节点段落没有恰当地终止! \")
"(,)[-1,-1]
if#812"i==-1"(块#809,块#811)[-1,-1]
eof#813""(,)[-1,-1]
然后#814""(块#811,eof#813)[-1,-1]
块#815"list_pt.append(NetP(code[0:i]))
"(,)[-1,-1]
然后#816""(块#809,块#815)[-1,-1]
eof#817""(,)[-1,-1]
然后#818""(块#815,eof#817)[-1,-1]
块#819"print(\"完成节点输入! \")
print(\"开始构建关联... \")
"(,)[-1,-1]
然后#820""(块#793,块#819)[-1,-1]
块#821""(,)[-1,-1]
然后#822""(块#819,块#821)[-1,-1]
块#823"raise(\"错误! 没有检测到关联段落. \")
"(,)[-1,-1]
if#824"code[0:7]!=\"### 关联\n\""(块#821,块#823)[-1,-1]
eof#825""(,)[-1,-1]
然后#826""(块#823,eof#825)[-1,-1]
块#827"code=code[7:]
i=-2
n=-1
"(,)[-1,-1]
然后#828""(块#821,块#827)[-1,-1]
块#829""(,)[-1,-1]
然后#830""(块#827,块#829)[-1,-1]
块#831"n+=1
code=code[i+2:]
"(,)[-1,-1]
while#832"True"(块#829,块#831)[-1,-1]
块#833""(,)[-1,-1]
然后#834""(块#831,块#833)[-1,-1]
块#835"break
"(,)[-1,-1]
if#836"code==''"(块#833,块#835)[-1,-1]
eof#837""(,)[-1,-1]
然后#838""(块#835,eof#837)[-1,-1]
eof#839""(,)[-1,-1]
然后#840""(块#841,eof#839)[-1,-1]
块#841"code=code[1:]
break
"(,)[-1,-1]
elif#842"code[0]=='\n'"(if#836,块#841)[-1,-1]
块#843"i=code.find(\", \")
"(,)[-1,-1]
然后#844""(块#833,块#843)[-1,-1]
块#845""(,)[-1,-1]
然后#846""(块#843,块#845)[-1,-1]
块#847"raise(\"错误! 关联段落没有恰当地终止! \")
"(,)[-1,-1]
if#848"i==-1"(块#845,块#847)[-1,-1]
eof#849""(,)[-1,-1]
然后#850""(块#847,eof#849)[-1,-1]
块#851"con=code[:i]
j=con.find('#')
"(,)[-1,-1]
然后#852""(块#845,块#851)[-1,-1]
块#853""(,)[-1,-1]
然后#854""(块#851,块#853)[-1,-1]
块#855"print(\"警告! 第%d个节点关联的格式有误, 该节点将被删除! \"%(n))
list_del.append(n)
continue
"(,)[-1,-1]
if#856"j==-1"(块#853,块#855)[-1,-1]
eof#857""(,)[-1,-1]
然后#858""(块#855,eof#857)[-1,-1]
块#859"num0=con[0:j]
num1=con[j+1:]
"(,)[-1,-1]
然后#860""(块#853,块#859)[-1,-1]
块#861""(,)[-1,-1]
然后#862""(块#859,块#861)[-1,-1]
块#863"list_del.append(n)
continue
"(,)[-1,-1]
if#864"num0==\"del\" or num1==\"del\""(块#861,块#863)[-1,-1]
eof#865""(,)[-1,-1]
然后#866""(块#863,eof#865)[-1,-1]
块#867"con0=None
"(,)[-1,-1]
然后#868""(块#861,块#867)[-1,-1]
块#869""(,)[-1,-1]
然后#870""(块#867,块#869)[-1,-1]
块#871""(,)[-1,-1]
if#872"num0!=''"(块#869,块#871)[-1,-1]
块#873"con0=list_pt[int(num0)]
"(,)[-1,-1]
块#874"list_del.append(n)
continue
"(,)[-1,-1]
try#875""(块#871,块#873)[-1,-1]
except#876""(try#875,块#874)[-1,-1]
eof#877""(,)[-1,-1]
然后#878""(块#873,eof#877)[-1,-1]
eof#879""(,)[-1,-1]
然后#880""(块#874,eof#879)[-1,-1]
eof#881""(,)[-1,-1]
然后#882""(块#871,eof#881)[-1,-1]
块#883"con1=None
"(,)[-1,-1]
然后#884""(块#869,块#883)[-1,-1]
块#885""(,)[-1,-1]
然后#886""(块#883,块#885)[-1,-1]
块#887""(,)[-1,-1]
if#888"num1!=''"(块#885,块#887)[-1,-1]
块#889"con1=list_pt[int(num1)]
"(,)[-1,-1]
块#890"list_del.append(n)
continue
"(,)[-1,-1]
try#891""(块#887,块#889)[-1,-1]
except#892""(try#891,块#890)[-1,-1]
eof#893""(,)[-1,-1]
然后#894""(块#889,eof#893)[-1,-1]
eof#895""(,)[-1,-1]
然后#896""(块#890,eof#895)[-1,-1]
eof#897""(,)[-1,-1]
然后#898""(块#887,eof#897)[-1,-1]
块#899"list_pt[n].con(con0,con1)
"(,)[-1,-1]
然后#900""(块#885,块#899)[-1,-1]
eof#901""(,)[-1,-1]
然后#902""(块#899,eof#901)[-1,-1]
块#903"print(\"构建关联完成! \")
print(\"开始读取内容... \")
"(,)[-1,-1]
然后#904""(块#829,块#903)[-1,-1]
块#905""(,)[-1,-1]
然后#906""(块#903,块#905)[-1,-1]
块#907"raise(\"错误! 没有检测到内容段落. \")
"(,)[-1,-1]
if#908"code[0:7]!=\"### 内容\n\""(块#905,块#907)[-1,-1]
eof#909""(,)[-1,-1]
然后#910""(块#907,eof#909)[-1,-1]
块#911"code=code[7:]
"(,)[-1,-1]
然后#912""(块#905,块#911)[-1,-1]
块#913""(,)[-1,-1]
然后#914""(块#911,块#913)[-1,-1]
块#915"result=re.match(r'#([\d]*), ([\d]*):\n',code)
"(,)[-1,-1]
while#916"True"(块#913,块#915)[-1,-1]
块#917""(,)[-1,-1]
然后#918""(块#915,块#917)[-1,-1]
块#919""(,)[-1,-1]
if#920"result==None"(块#917,块#919)[-1,-1]
块#921"break
"(,)[-1,-1]
if#922"code!='' and code==\"### 结束\""(块#919,块#921)[-1,-1]
eof#923""(,)[-1,-1]
然后#924""(块#921,eof#923)[-1,-1]
块#925"raise(\"错误! 内容的格式不正确. \")
"(,)[-1,-1]
else#926""(if#922,块#925)[-1,-1]
eof#927""(,)[-1,-1]
然后#928""(块#925,eof#927)[-1,-1]
eof#929""(,)[-1,-1]
然后#930""(块#919,eof#929)[-1,-1]
块#931"n=int(result.group(1))
length=int(result.group(2))
i=result.span()[1]
code=code[i:]
text=code[0:length]
list_pt[n].m_text=text
code=code[length:]
"(,)[-1,-1]
然后#932""(块#917,块#931)[-1,-1]
块#933""(,)[-1,-1]
然后#934""(块#931,块#933)[-1,-1]
块#935"raise(\"错误! 内容的格式不正确\")
"(,)[-1,-1]
if#936"code[0:8]!='\n## end\n'"(块#933,块#935)[-1,-1]
eof#937""(,)[-1,-1]
然后#938""(块#935,eof#937)[-1,-1]
块#939"code=code[8:]
"(,)[-1,-1]
然后#940""(块#933,块#939)[-1,-1]
eof#941""(,)[-1,-1]
然后#942""(块#939,eof#941)[-1,-1]
块#943"print(\"内容读取完成! \")
"(,)[-1,-1]
然后#944""(块#913,块#943)[-1,-1]
块#945""(,)[-1,-1]
然后#946""(块#943,块#945)[-1,-1]
块#947"print('There are %d invalid points!'%(len(list_del)))
list_del.reverse()
"(,)[-1,-1]
if#948"len(list_del)>0"(块#945,块#947)[-1,-1]
块#949""(,)[-1,-1]
然后#950""(块#947,块#949)[-1,-1]
块#951"print('Deleting %s...'%(list_pt[i].info()))
list_pt.pop(i)
"(,)[-1,-1]
for#952"list_del"(块#949,块#951)[-1,-1]
变量#953"i"(for#952,)[-1,-1]
eof#954""(,)[-1,-1]
然后#955""(块#951,eof#954)[-1,-1]
eof#956""(,)[-1,-1]
然后#957""(块#949,eof#956)[-1,-1]
块#958"return list_pt
"(,)[-1,-1]
然后#959""(块#945,块#958)[-1,-1]
eof#960""(,)[-1,-1]
然后#961""(块#958,eof#960)[-1,-1]
块#962""(,)[-1,-1]
然后#963""(块#781,块#962)[-1,-1]
块#964"list_km=readSubCode_tokener('test(,_a)->_a')
karma=list_km[0].causeEnd()
karma.setRangers()
list_km[0].m_symbol.print()
print(karma.info_karma())
"(,)[-1,-1]
if#965"__name__=='__main__'"(块#962,块#964)[-1,-1]
eof#966""(,)[-1,-1]
然后#967""(块#964,eof#966)[-1,-1]
eof#968""(,)[-1,-1]
然后#969""(块#962,eof#968)[-1,-1]

## end
#2169, 30:
起点
+[显示](,起点)
+[显示](,func)




## end
#2171, 15802:
"""

"""

def removeComment(code):
    if len(code)==0:
        return code,False
    elif code[0]=='#':
        code=re.sub(r'^#.*','',code)
    elif code[0:3]=='"""':
        code=code[3:]
        while True:
            if len(code)<3:
                code=''
                break
            elif code[0:3]=='"""':
                break
            else:
                code=re.sub(r'^.*\n?','',code)
        code=code[3:]
    else:
        return code,False
    return code,True
def buildPoints_quick(code):
    list_pt=[]
    dict_con={}
    list_del=[]


    code=re.sub(r'^[ \t\n]*','',code)
    L=len(code)
    progress=0
    N=0
    while code!='':
        code,netP,n0,n1,del_flag=netPToken_quick(code)
        list_pt.append(netP)
        progress=(L-len(code))/L*100
        if progress >= N:
            print("进度: %.2f"%(progress)+"%")
            N+=10
        code=re.sub(r'^[ \t\n;]*','',code)
        if n0!=None or n1!=None:
            dict_con.update({netP:[n0,n1]})
        if del_flag:
            list_del.append(len(list_pt)-1)
    
    for pt in dict_con:
        n0,n1=dict_con[pt]
        if n0!=None:
            pt0=list_pt[n0]
            pt.con(pt0,0)
        if n1!=None:
            pt1=list_pt[n1]
            pt.con(0,pt1)


    if len(list_del)>0:
        print('There are %d invalid points!'%(len(list_del)))
        list_del.reverse()
        for i in list_del:
            print('Deleting %s...'%(list_pt[i].info()))
            list_pt.pop(i)
    return list_pt



def netPToken_quick(code):
    title=r'^[\w \[\]~#.+=\-^/*\\!<\']*|^\[>=?\]'
    order=r'#.*$'


    name=re.match(title,code).group()
    code=re.sub(title,'',code)
    if name=='':
        print('\n\n\nError! Invalid name.\nCode:',code)
        raise Exception('Error! Invalid name.')
    if name[-1]=='=' or name[-1]=='-':
        if len(code)>0 and code[0]=='>':
            code=name[-1]+code
            name=name[0:-1]
    con0_name=''
    con1_name=''
    text=''
    if code!='' and code[0]=='\"':
        code=code[1:]
        [code,text]=textToken(code)
        if code=='' or code[0]!='\"':
            print(code)
            raise Exception('Error! Unbalanced quote!')
        code=code[1:]
    if code!='' and code[0]=='(':
        code=code[1:]
        con0_name=re.match(title,code).group()
        code=re.sub(title,'',code)
        if code=='' or code[0]!=',':
            print(code)
            raise Exception('Error! Ilegal net point format. A net point must be title"text"(title,title)')
        code=code[1:]
        con1_name=re.match(title,code).group()
        code=re.sub(title,'',code)
        if code=='' or code[0]!=')':
            raise Exception('Error! Unbalanced bracket in a net point format!')
        code=code[1:]
    if name=='':
        print('Warning! There is a point without a name!')
    n=re.search(order,name)
    if n==None:
        raise Exception('Error! It\'s not a TOP.')
    else:
        n=n.group()[1:]
        int(n)


    name=re.sub(order,'',name)
    netP=NetP(name,text)


    posFormat=r'^\[(-?\d+), *(-?\d+)\]'
    pos=re.findall(posFormat,code)
    if pos!=[]:
        x=int(pos[0][0])
        y=int(pos[0][1])
        netP.m_pos=[x,y]
        code=re.sub(r'^\[-?\d+, *-?\d+\]','',code)


    del_flag=False


    n0=None
    try:
        if con0_name!='':
            str_n0=re.search(order,con0_name).group()
            if len(str_n0)>1:
                n0=int(str_n0[1:])
    except:
        print('Warning! The %s(%s,%s) connects an invalid point'%(name,con0_name,con1_name))
        del_flag=True


    n1=None
    try:
        if con1_name!='':
            str_n1=re.search(order,con1_name).group()
            if len(str_n1)>1:
                n1=int(str_n1[1:])
    except:
        print('Warning! The %s(%s,%s) connects an invalid point'%(name,con0_name,con1_name))
        del_flag=True


    return [code,netP,n0,n1,del_flag]
def readSubCode_tokener(code):
    list_karma=[]
    while code!='':
        code=re.sub(r'^[ \t\n]*','',code)
        if code=='':
            break
        code,result=removeComment(code)
        if result==True:
            continue
        else:
            [code,karma,pointStack]=chainToken(code)
            pointStack.leaveClause()
            karma=karma.causeEnd()
            karma.setRangers()
            list_karma.append(karma)
            if code!='' and code[0]==';':
                code=code[1:]
    return list_karma


def buildPoints_tokener(code):
    list_pt=[]
    code=re.sub(r'^[ \t\n]*','',code)
    pointStack=NetPStack()
    L=len(code)
    progress=0
    N=0
    while code!='':
        code,netP,pointStack=netPToken(code,pointStack)
        list_pt.append(netP)
        progress=(L-len(code))/L*100
        if progress >= N:
            print("进度: %.2f"%(progress)+"%")
            N+=10
        code=re.sub(r'^[ \t\n;]*','',code)
    return list_pt


def divideSents_tokener(code):
    list_sent=[]
    while code!='':
        code=re.sub(r'^[ \t\n]*','',code)
        if code=='':
            break
        code,result=removeComment(code)
        if result==True:
            continue
        
        code_keep=code
        [code,karma,pointStack]=chainToken(code)
        si=code_keep.rfind(code)
        text=code_keep[0:si]
        if code!='' and code[0]==';':
            code=code[1:]
        sent=NetP(karma.m_symbol.m_name,text)
        list_sent.append(sent)
    return list_sent


def chainToken(code,pointStack=None):
    if pointStack==None:
        pointStack=NetPStack()
    [code,karma,pointStack]=karmaToken(code,pointStack)
    if code=='' or code[0]==';' or code[0]=='\n' or code[0]=='}':
        return [code,karma,pointStack]
    elif code[0]==',':
        return [code,karma,pointStack]
    elif code[0]==':':
        code=code[1:]
        [code,karma,pointStack]=splitToken(code,karma,pointStack)
    elif code[0]=='|' or code[0]=='&':
        typeSub=code[0]
        code=code[1:]
        if code!='' and code[0]==':':
            if typeSub=='|':
                karma.m_noAnd=False
                karma.m_yesAnd=False
            else:
                karma.m_noAnd=True
                karma.m_yesAnd=True
            code=code[1:]
            [code,karma,pointStack]=splitToken(code,karma,pointStack)
    else:
        [code,typeCon]=conToken(code)
        [code,effect,pointStack]=chainToken(code,pointStack)
        buildRelation(karma,typeCon,effect)
    return [code,karma,pointStack]



def conToken(code):
    while len(code)>3 and code[0:3]=='...':
        code=re.sub(r'^\.\.\..*[\n\t ]*','',code)
    code=re.sub(r'^[ \t]*','',code)
    if len(code)>2 and code[0:3]=='->>':
        typeCon=code[0:3]
        code=code[3:]
    elif len(code)>2 and code[0:3]=='=>>':
        typeCon=code[0:3]
        code=code[3:]
    elif len(code)>1 and code[0:2]=='->':
        typeCon=code[0:2]
        code=code[2:]
    elif len(code)>1 and code[0:2]=='=>':
        typeCon=code[0:2]
        code=code[2:]
    else:
        print('\n\n\nIllegal connection symbol!\nCode:',code)
        raise Exception('Illegal connection symbol!')
    code=re.sub(r'^[ \t]*','',code)
    return [code,typeCon]


def clauseToken(code,karma,pointStack):
    pointStack.enterClause()
    while True:
        code=re.sub(r'^[ \t\n]*','',code)
        if code=='':
            raise Exception('Error! Unbalanced bracket!')
        elif code[0]=='}':
            break
        else:
            [code,clause,pointStack]=chainToken(code,pointStack)
            karma.m_clause.append(clause)
            clause.m_cause=karma
            if code!='' and code[0]!=',':
                break
            elif code!='':
                code=code[1:]
    pointStack.leaveClause()
    return [code,karma,pointStack]


def splitToken(code,karma,pointStack):
    while True:
        code=re.sub(r'^[ \t\n]*','',code)
        [code,typeCon]=conToken(code)
        [code,effect,pointStack]=chainToken(code,pointStack)
        buildRelation(karma,typeCon,effect)
        code=re.sub(r'^[ \t\n]*','',code)
        if code=='' or code[0]==';' or code[0]=='}':
            break
        elif code[0]!=',':
            print('\n\n\n\nError! Ilegal splitting type!\nCode:',code)
            raise Exception('Error! Ilegal splitting type!')
        else:
            code=code[1:]
    return [code,karma,pointStack]


def karmaToken(code,pointStack):
    if code=='':
        raise Exception('Error! Invalid karma detected!')
    buildType=False
    karma=None
    if code[0]=='+':
        buildType=True
    [code,netP,pointStack]=netPToken(code,pointStack)
    karma=Karma(netP)
    if buildType==True and netP.m_name!='+':
        netP.m_name=netP.m_name[1:]
        karma.m_buildMode=True
    if code!='' and code[0]=='{':
        code=code[1:]
        [code,karma,pointStack]=clauseToken(code,karma,pointStack)
        code=re.sub(r'^[\n\t ]*','',code)
        if code=='' or code[0]!='}':
            print('\n\n\nError! Unbalanced bracket.\nCode:',code)
            raise Exception('Error! Unbalanced bracket.')
        else:
            code=code[1:]
    elif code!='' and (code[0]=='|' or code[0]=='&'):
        typeSub=code[0]
        code=code[1:]
        if code!='' and code[0]=='{':
            if typeSub=='|':
                karma.m_clauseAnd=False
            else:
                karma.m_clauseAnd=True
            code=code[1:]
            [code,karma,pointStack]=clauseToken(code,karma,pointStack)
            code=re.sub(r'^[\n\t ]*','',code)
            if code=='' or code[0]!='}':
                raise Exception('Error! Unbalanced bracket.')
            else:
                code=code[1:]
        else:
            code=typeSub+code
    return [code,karma,pointStack]


def netPToken(code,pointStack):
    title=r'^[\w \[\]~#.+=\-^/*\\!<\']*|^\[>=?\]'
    name=re.match(title,code).group()
    code=re.sub(title,'',code)
    if name=='':
        print('\n\n\nError! Invalid name.\nCode:',code)
        raise Exception('Error! Invalid name.')
    if name[-1]=='=' or name[-1]=='-':
        if len(code)>0 and code[0]=='>':
            code=name[-1]+code
            name=name[0:-1]
    con0_name=''
    con1_name=''
    text=''
    if code!='' and code[0]=='\"':
        code=code[1:]
        [code,text]=textToken(code)
        if code=='' or code[0]!='\"':
            print(code)
            raise Exception('Error! Unbalanced quote!')
        code=code[1:]
    if code!='' and code[0]=='(':
        code=code[1:]
        con0_name=re.match(title,code).group()
        code=re.sub(title,'',code)
        if code=='' or code[0]!=',':
            print(code)
            raise Exception('Error! Ilegal net point format. A net point must be title"text"(title,title)')
        code=code[1:]
        con1_name=re.match(title,code).group()
        code=re.sub(title,'',code)
        if code=='' or code[0]!=')':
            raise Exception('Error! Unbalanced bracket in a net point format!')
        code=code[1:]
    if name=='':
        print('Warning! There is a point without a name!')
    netP=pointStack.buildNetP(name,con0_name,con1_name)
    posFormat=r'^\[(-?\d+), *(-?\d+)\]'
    pos=re.findall(posFormat,code)
    if pos!=[]:
        x=int(pos[0][0])
        y=int(pos[0][1])
        netP.m_pos=[x,y]
        code=re.sub(r'^\[-?\d+, *-?\d+\]','',code)
    netP.m_text=text
    return [code,netP,pointStack]


def textToken(code):
    text=''
    preEnd=True
    while True:
        if code=='':
            break
        elif len(code)>1 and code[0:2]=='\\"':
            preEnd=False
        elif code[0]=='\"' and preEnd==True:
            break
        else:
            text+=code[0]
            preEnd=True
        code=code[1:]
    return [code,text]


def buildRelation(karma,typeCon,effect):
    if typeCon=='->':
        karma.m_yese.append(effect)
    elif typeCon=='->>':
        karma.m_noe.append(effect)
    elif typeCon=='=>':
        karma.m_yese.append(effect)
        effect.m_no=True
    elif typeCon=='=>>':
        karma.m_noe.append(effect)
        effect.m_no=True
    else:
        raise Exception('Error! Ilegal connection type!')
    effect.m_cause=karma
def genFCode(list_pt):
    fcode_pt="### 节点\n"
    fcode_con="### 关联\n"
    fcode_text="### 内容\n"


    i=0
    for pt in list_pt:
        fcode_pt+=pt.m_name+", "
        pt.m_name+="#%d"%(i)
        length=len(pt.m_text)
        if length!=0:
            fcode_text+="#%d, %d:\n%s\n## end\n"%(i,length,pt.m_text)
        i+=1


    for pt in list_pt:
        con1=""
        if pt.m_db[0]!=None:
            i=pt.m_db[0].m_name.rfind('#')
            if i!=-1:
                con1=pt.m_db[0].m_name[i+1:]
            else:
                con1="del"


        con2="#"
        if pt.m_db[1]!=None:
            i=pt.m_db[1].m_name.rfind('#')
            if i!=-1:
                con2=pt.m_db[1].m_name[i:]
            else:
                con2="#del"
        
        fcode_con+="%s%s, "%(con1,con2)


    for pt in list_pt:
        i=pt.m_name.find('#')
        pt.m_name=pt.m_name[0:i]


    fcode=fcode_pt+"\n"+fcode_con+"\n"+fcode_text+"### 结束"
    return fcode



def loadFCode(fcode):
    list_pt=[]
    list_del=[]


    code=fcode
    if code[0:7]!="### 节点\n":
        raise("错误! 没有检测到节点段落. ")
    code=code[7:]


    print("开始输入节点... ")
    i=-2
    while True:
        code=code[i+2:]
        if code=='':
            break
        elif code[0]=='\n':
            code=code[1:]
            break
        i=code.find(", ")
        if i==-1:
            raise("错误! 节点段落没有恰当地终止! ")
        list_pt.append(NetP(code[0:i]))


    print("完成节点输入! ")
    print("开始构建关联... ")


    if code[0:7]!="### 关联\n":
        raise("错误! 没有检测到关联段落. ")
    code=code[7:]


    i=-2
    n=-1
    while True:
        n+=1
        code=code[i+2:]
        if code=='':
            break
        elif code[0]=='\n':
            code=code[1:]
            break
        i=code.find(", ")
        if i==-1:
            raise("错误! 关联段落没有恰当地终止! ")
        con=code[:i]
        j=con.find('#')
        if j==-1:
            print("警告! 第%d个节点关联的格式有误, 该节点将被删除! "%(n))
            list_del.append(n)
            continue
        num0=con[0:j]
        num1=con[j+1:]
        if num0=="del" or num1=="del":
            list_del.append(n)
            continue


        con0=None
        if num0!='':
            try:
                con0=list_pt[int(num0)]
            except:
                list_del.append(n)
                continue
        con1=None
        if num1!='':
            try:
                con1=list_pt[int(num1)]
            except:
                list_del.append(n)
                continue
        list_pt[n].con(con0,con1)


        
    print("构建关联完成! ")
    print("开始读取内容... ")


    if code[0:7]!="### 内容\n":
        raise("错误! 没有检测到内容段落. ")
    code=code[7:]


    while True:
        result=re.match(r'#([\d]*), ([\d]*):\n',code)
        if result==None:
            if code!='' and code=="### 结束":
                break
            else:
                raise("错误! 内容的格式不正确. ")
        n=int(result.group(1))
        length=int(result.group(2))
        i=result.span()[1]
        code=code[i:]
        text=code[0:length]
        list_pt[n].m_text=text


        code=code[length:]
        if code[0:8]!='\n## end\n':
            raise("错误! 内容的格式不正确")
        code=code[8:]


    print("内容读取完成! ")
        
    if len(list_del)>0:
        print('There are %d invalid points!'%(len(list_del)))
        list_del.reverse()
        for i in list_del:
            print('Deleting %s...'%(list_pt[i].info()))
            list_pt.pop(i)


    return list_pt





if __name__=='__main__':
    list_km=readSubCode_tokener('test(,_a)->_a')
    karma=list_km[0].causeEnd()
    karma.setRangers()
    list_km[0].m_symbol.print()
    print(karma.info_karma())



## end
#2172, 4:
2252
## end
#2175, 33121:
"""


"""

import sys, re, logging
if __name__=='__main__':
    sys.path.append(sys.path[0]+'\\..')
from body.bone import NetP
from body.soul import Karma



def printNList(list_pt):
    string=''
    n=0
    print(list_pt)
    for point in list_pt:
        string=string+str(n)+'.'+point.info()+'\n'
        n=n+1
    print(string)
        


def writeStdCode(karmas,list_pt):
    code=''
    i=0
    for point in list_pt:
        point.m_name+='
        i=i+1
    for point in list_pt:
        code+=point.info_saving()+'\n'
    for karma in karmas:
        code+='\n_____________________________\n'
        [text,list_pt]=writeStdCode_karma(karma,list_pt)
        code+=text
    for point in list_pt:
        point.m_name=re.sub(r'
    return code


def writeStdCode_karma(karma,list_pt):
    karma_code=''


    if karma==None:
        return [karma_code,list_pt]
    
    if karma.m_symbol not in list_pt:
        list_pt.append(karma.m_symbol)
    if karma.m_buildMode==True:
        karma_code+='+'
    karma_code+=str(list_pt.index(karma.m_symbol))


    if karma.m_clause!=[]:
        if karma.m_clauseAnd==False:
            karma_code+='|'
        karma_code+='{'
        for clause in karma.m_clause:
            [text,list_pt]=writeStdCode_karma(clause,list_pt)
            karma_code+=text
            if clause!=karma.m_clause[-1]:
                karma_code+=','
        karma_code+='}'


    if len(karma.m_yese)+len(karma.m_noe)>1:
        if karma.m_yesAnd==True:
            karma_code+='&'
        karma_code+=':'
    for end in karma.m_yese:
        if end.m_no==False:
            karma_code+='->'
        else:
            karma_code+='=>'
        [text,list_pt]=writeStdCode_karma(end,list_pt)
        karma_code+=text
        if end!=karma.m_yese[-1]:
            karma_code+=','
    for end in karma.m_noe:
        if end.m_no==False:
            karma_code+='->>'
        else:
            karma_code+='=>>'
        [text,list_pt]=writeStdCode_karma(end,list_pt)
        karma_code+=text
        if end!=karma.m_noe[-1]:
            karma_code+=','
    if len(karma.m_yese)+len(karma.m_noe)>1:
        karma_code+=';'


    return [karma_code,list_pt]



def listToDict(list_pt):
    dict_pt={}
    for point in list_pt:
        name=point.m_name
        if len(name)>2 and name[0]=='[' and name[-1]==']':
            name=name[1:-1]
        term=dict_pt.get(name,[])
        term.append(point)
        dict_pt.update({name:term})
    return dict_pt
    
def listToKeyDict(list_pt):
    dict_pt={}
    for point in list_pt:
        dict_pt.update({point.m_name:point})
    return dict_pt


def dictToList(dict_pt):
    list_pt=[]
    for term in dict_pt:
        list_pt+=dict_pt[term]
    return list_pt


def ptToDict(point):
    dict_con={}
    for con in point.m_con:
        if con.m_db[0]==point:
            dict_con.update({con.m_name:con})
    return dict_con


def ptDeToDict(point):
    dict_de={}
    for con in point.m_con:
        if con.m_name=='的' and con.m_db[0]==point and con.m_db[1]!=None:
            dict_de.update({con.m_db[1].m_name:con.m_db[1]})
    return dict_de


            
def runKarmaByOneStep(karma,pool,n=1):
    head=karma
    list_km=karma.allEffects()
    if karma.m_stage==0:
        karma.m_stage=1
    for i in range(n):
        for km in list_km:
            change,list_new=km.Reason_oneStep(pool)
            if change:
                break
        showKarmaState(karma)
        print('__________')


def showKarmaState(karma):
    list_km=karma.allEffects()
    for km in list_km:
        print(km.m_symbol.m_name,km.m_stage)


def pointsInChain(karma):
    list_km=karma.allEffects()
    list_pt=[]
    for km in list_km:
        list_pt.append(km.m_symbol)
    return list_pt



def pt2Var(point,device=None):
    if point.m_name=='list':
        device=getPointByFormat(point,'list')
        point.m_dev=device
        return device
    for con in point.m_con:
        if con.m_db[0]!=point or con.m_db[1]==None:
            continue
        elif con.m_name[0:2]=='m_':
            if device==None:
                device=empty()
                device.m_self=point
            dev_next=pt2Var(con.m_db[1],con.m_db[1].m_dev)
            if dev_next==None:
                setattr(device,con.m_name,con.m_db[1])
            else:
                setattr(device,con.m_name,dev_next)
        elif con.m_db[1].m_name=='function':
            eng={}
            pythonCodeEval(eng,con.m_db[1].m_text)
            f=eng.get(con.m_name,None)
            if f==None:
                continue
            if device==None:
                device=empty()
                device.m_self=point
            setattr(device,con.m_name,f)
    point.m_dev=device
    return device



def getAllSystemPt(point,list_pt=None):
    if list_pt==None:
        list_pt=[]
    list_pt+=[point]
    for con in point.m_con:
        if con.m_permission==0 and con.m_db[0]==point:
            list_pt.append(con)
            if con.m_db[1]!=None and con.m_db[1] not in list_pt:
                if con.m_db[1].m_permission==0:
                    getAllSystemPt(con.m_db[1],list_pt)
                else:
                    list_pt+=[con.m_db[1]]
    return list_pt


def getPoint(point,key,default='',con_permission=0,pt_permission=-1):
    dict_pt=ptToDict(point)
    con=dict_pt.get(key,None)
    if con==None:
        if default!=None:
            con=NetP(key).con(point,NetP(default))
        else:
            return None
    con.m_permission=con_permission
    pt=con.m_db[1]
    if pt_permission==-1:
        pass
    else:
        pt.m_permission=pt_permission
    return pt


def getVarFromPt(point,key,list_pt=None):
    dict_pt=ptDeToDict(point)
    con=dict_pt.get(key,None)
    if con==None:
        de=NetP('的').con(point,NetP(key))
        con=de.m_db[1]
        de.m_permission=0
        con.m_permission=0
        if list_pt!=None:
            list_pt.append(de)
            list_pt.append(con)
    return con



def setPoint(point,key,value):
    for con in point.m_con:
        if con.m_db[0]==point and con.m_name==key:
            if value!=0:
                con.con(point,value)
            else:
                con.delete()
                del con
            return
    if value!=0:
        connect=NetP(key).con(point,value)
        connect.m_permission=0


def getPointByFormat(point,type_pt):
    list_pt=[]
    set_pt=set()
    if point==None:
        return list_pt
    if type_pt=='list':
        for con in point.m_con:
            if con.m_name=='的' and con.m_db[0]==point:
                if  con.m_db[1]!=None:
                    list_pt.append(con.m_db[1])
                else:
                    con.delete()
    elif type_pt=='set':
        for con in point.m_con:
            if con.m_name=='的' and con.m_db[0]==point:
                if  con.m_db[1]!=None:
                    set_pt.update([con.m_db[1]])
                else:
                    con.delete()
        list_pt=list(set_pt)
    return list_pt


def setPointByFormat(point,type_pt,value=None):
    if type_pt=='list.append':
        con=NetP('的').con(point,value)
        con.m_permission=0
    elif type_pt=='list.insertHead':
        con=NetP('的').con(point,value)
        con.m_permission=0
        point.m_con.remove(con)
        point.m_con.insert(0,con)
    elif type_pt=='list.+=':
        for pt in value:
            con=NetP('的').con(point,pt)
            con.m_permission=0
    elif type_pt=='list.clear':
        list_del=[]
        for con in point.m_con:
            if con.m_name=='的' and con.m_db[0]==point and con.m_db[1]!=None:
                list_del.append(con)
        for pt in list_del:
            pt.delete()
        del list_del[:]
    elif type_pt=='list.pop':
        list_pt=getPointByFormat(point,'list')
        pt=list_pt[-1]
        for con in pt.m_con:
            if con.m_name=='的' and con.m_db[0]==point and con .m_db[1]==pt:
                con.delete()
                del con
        del pt
    elif type_pt=='list.remove':
        list_pt=getPointByFormat(point,'list')
        if value in list_pt:
            for con in value.m_con:
                if con.m_name=='的' and con.m_db[0]==point and con .m_db[1]==value:
                    con.delete()
                    del con
    elif type_pt=='list.removeByName':
        list_pt=getPointByFormat(point,'list')
        for pt in list_pt:
            if pt.m_name==value:
                setPointByFormat(point,'list.remove',pt)
                break
    elif type_pt=='list.replace':
        list_pt=getPointByFormat(point,'list')
        for pt in list_pt:
            if pt.m_name==value.m_name:
                setPointByFormat(point,'list.remove',pt)
                break
        setPointByFormat(point,'list.append',value)


def checkPointByFormat(point,type_pt,value=None):
    if type_pt=='list.isempty':
        list_pt=getPointByFormat(point,'list')
        return list_pt==[]
    elif type_pt=='list.in':
        list_pt=getPointByFormat(point,'list')
        return value in list_pt
    return True


def checkPtsRelation(pt,relationship,value):
    dict_pt=ptToDict(pt)
    if relationship=='property':
        return value in dict_pt
    


def printPointByFormat(point,type_pt):
    if type_pt=='list':
        list_pt=getPointByFormat(point,type_pt)
        print([pt.info() for pt in list_pt])


def printPoint(point):
    print(point.info(),'{')
    for con in point.m_con:
        if con.m_db[0]==point:
            print(con.m_name+':',con.m_db[1].info())
    print('}')


def printPtList(list_pt):
    info_pt='['
    for pt in list_pt:
        info_pt+=pt.info("不显示文本")
        if pt!=list_pt[-1]:
            info_pt+=', '
    info_pt+=']'
    print(info_pt)


def readFile(fileName):
    f=open(fileName,encoding='utf-8')
    try:
        textUtf=f.read()
        f.close()
        return textUtf
    except:
        f.close()
    f=open(fileName,encoding='gbk')
    try:
        textGbk=f.read()
        f.close()
        return textGbk
    except:
        f.close()
        return ''


def writeFile(fileName,text,cover=True):
    if fileName==None:
        return
    try:
        text_old=readFile(fileName)
    except Exception as e:
        logging.exception(e)
        text_old=''
    try:
        if cover:
            f=open(fileName,'w',encoding='utf-8')
        else:
            f=open(fileName,'a',encoding='utf-8')
    except:
        print('Error! Invalid file address!')
        return
    try:
        f.write(text)
    except Exception as e:
        f.write(text_old)
        print("Save failed!")
        logging.exception(e)
    f.close()



def copyKarma(karma):
    list_km=karma.allEffects()
    i=0
    for km in list_km:
        km.m_symbol.m_name+='
        i+=1
    info_str=karma.info_karma(type_info=1)
    for km in list_km:
        j=km.m_symbol.m_name.rfind('
        km.m_symbol.m_name=km.m_symbol.m_name[0:j]
    karmas_copy=readSubCode_tokener(info_str)
    return karmas_copy[0]


def karmaToStr(karma):
    list_km=karma.allEffects()
    i=0
    for km in list_km:
        km.m_symbol.m_name+='
        i+=1
        if km.m_buildMode==True:
            km.m_symbol.m_name='+'+km.m_symbol.m_name
    info_str=karma.info_karma(type_info=1)
    for km in list_km:
        j=km.m_symbol.m_name.rfind('
        km.m_symbol.m_name=km.m_symbol.m_name[0:j]
        if km.m_buildMode==True:
            km.m_symbol.m_name=km.m_symbol.m_name[1:]
    return info_str



def newKarmaOnPts(list_pt,type_new=False):
    list_km=[]
    for pt in list_pt:
        km=Karma(pt)
        if list_km!=[]:
            list_km[-1].m_yese.append(km)
            km.m_cause=list_km[-1]
        list_km.append(km)
        km.m_buildMode=type_new
    return list_km


def insertPtIntotKarma_back(km0,netP):
    km_new=Karma(netP)
    if len(netP.m_name)>1 and netP.m_name[0]=='+':
        netP.m_name=netP.m_name[1:]
        km_new.m_buildMode=True
    for km in km0.m_clause:
        km.m_cause=km_new
    for km in km0.m_yese:
        km.m_cause=km_new
    for km in km0.m_noe:
        km.m_cause=km_new
    km_new.m_clause=km0.m_clause
    km_new.m_yese=km0.m_yese
    km_new.m_noe=km0.m_noe
    km0.m_yese=[km_new]
    km0.m_noe=[]
    km_new.m_cause=km0


def insertPtIntotKarma_front(km0,netP):
    km_new=Karma(netP)
    if len(netP.m_name)>1 and netP.m_name[0]=='+':
        netP.m_name=netP.m_name[1:]
        km_new.m_buildMode=True
    if km0.m_cause!=None:
        cause=km0.m_cause
        km_new.m_cause=cause
        if km0 in cause.m_clause:
            cause.m_clause.remove(km0)
            cause.m_clause.append(km_new)
        elif km0 in cause.m_yese:
            cause.m_yese.remove(km0)
            cause.m_yese.append(km_new)
        elif km0 in cause.m_noe:
            cause.m_noe.remove(km0)
            cause.m_noe.append(km_new)
        else:
            print("Warning! The karma:"+km0.m_symbol.info()+", has a weird cause karma.")
    km0.m_cause=km_new
    km_new.m_yese=[km0]
    if km0.m_no==True:
        km0.m_no=False
        km_new.m_no=True
    
def insertPtIntotKarma(km0,netP):
    if km0.m_symbol.m_db[0]==netP:
        otherP=km0.m_symbol.m_db[1]
    elif km0.m_symbol.m_db[1]==netP:
        otherP=km0.m_symbol.m_db[0]
    else:
        return
    if km0.isType('新建') or km0.m_symbol.m_name=='[那]':
        insertPtIntotKarma_back(km0,netP)
    elif km0.isType('普通非新建') or km0.m_symbol.m_name=='[is]':
        if otherP==None or otherP.m_master==None:
            insertPtIntotKarma_back(km0,netP)
        elif otherP.m_master in km0.allCauses():
            insertPtIntotKarma_back(km0,netP)
        else:
            insertPtIntotKarma_front(km0,netP)
    elif km0.isType('引用'):
        insertPtIntotKarma_front(km0,netP)
    





def runCode(code,list_pt):
    try:
        karmas=readSubCode_tokener(code)
    except:
        return []
    pool=listToDict(list_pt)
    results=[]
    for karma in karmas:
        karma.m_stage=1
        result,list_new=karma.Reason_iterative(pool)
        results.append(result)
    return [results,karmas]
    
def runKarma(karma,list_pt):
    pool=listToDict(list_pt)
    karma.m_stage=1
    result,list_new=karma.Reason_iterative(pool)
    return result



def codeBlock(code):
    try:
        print(code)
        var={}
        exec(code,{},var)
        return var['result']
    except Exception as e:
        print("Error! Something is wrong when compiling the code.")
        logging.exception(e)
    return None


def pythonCodeEval(eng,code):
    try:
        exec(code,eng)
    except Exception as e:
        logging.exception(e)
        return False
    return True


def karma2Pts(karma,list_pt):
    pt_km=NetP('链节')
    list_pt.append(pt_km)
    km=karma
    pt_con=NetP('m_symbol').con(pt_km,km.m_symbol)
    list_pt.append(pt_con)
    list_pt.append(km.m_symbol)
    for clause in km.m_clause:
        pt_cla=karma2Pts(clause,list_pt)
        pt_con1=NetP('从句').con(pt_km,pt_cla)
        list_pt.append(pt_con1)
    list_end=km.m_yese+km.m_noe
    for end in list_end:
        pt_end=karma2Pts(end,list_pt)
        pt_con2=NetP('因果').con(pt_km,pt_end)
        list_pt.append(pt_con2)
    return pt_km

class NetPStack:
    def __init__(self):
        self.m_builtStack=[{}]
        self.m_undefinedStack=[{}]


    def popBuilt(self):
        return self.m_builtStack.pop()


    def popUndefined(self):
        return self.m_undefinedStack.pop()


    def pushBuilt(self,built):
        self.m_builtStack.append(built)


    def pushUndefined(self,undefined):
        self.m_undefinedStack.append(undefined)


    def enterClause(self):
        self.m_builtStack.append(self.m_builtStack[-1].copy())
        self.m_undefinedStack.append(self.m_undefinedStack[-1].copy())


    def leaveClause(self):
        if len(self.m_undefinedStack)==1:
            if self.m_undefinedStack[-1]!={}:
                for term in self.m_undefinedStack[-1]:
                    pt=self.m_undefinedStack[-1][term]
                    if pt.m_master==None:
                        km_head=pt.m_con[0].m_master
                        insertPtIntotKarma(km_head,pt)
        elif len(self.m_undefinedStack[-1])>len(self.m_undefinedStack[-2]):
            for term in self.m_undefinedStack[-1]:
                if term not in self.m_undefinedStack[-2]:
                    pt=self.m_undefinedStack[-1][term]
                    if pt.m_master==None:
                        km_head=pt.m_con[0].m_master
                        insertPtIntotKarma(km_head,pt)
        self.m_builtStack.pop()
        self.m_undefinedStack.pop()


    def popUndefinedName(self,name):
        for stack in self.m_undefinedStack:
            stack.pop(name)


    def buildNetP(self,name,con0_name='',con1_name=''):
        recent=self.m_builtStack[-1]
        undefined=self.m_undefinedStack[-1]


        point=undefined.get(name,None)
        if point==None:
            point=NetP(re.sub(r'
            recent.update({name:point})
        else:
            undefined.pop(name)


        if con1_name!='':
            con1=recent.get(con1_name,None)
            if con1==None:
                con1=NetP(re.sub(r'
                recent.update({con1_name:con1})
                undefined.update({con1_name:con1})
            point.connect(con1,1)
        if con0_name!='':
            con0=recent.get(con0_name,None)
            if con0==None:
                con0=NetP(re.sub(r'
                recent.update({con0_name:con0})
                undefined.update({con0_name:con0})
            point.connect(con0,0)
        return point


def removeComment(code):
    if len(code)==0:
        return code,False
    elif code[0]=='
        code=re.sub(r'^
    elif code[0:3]=='"""':
        code=code[3:]
        while True:
            if len(code)<3:
                code=''
                break
            elif code[0:3]=='"""':
                break
            else:
                code=re.sub(r'^.*\n?','',code)
        code=code[3:]
    else:
        return code,False
    return code,True
def buildPoints_quick(code):
    list_pt=[]
    dict_con={}
    list_del=[]


    code=re.sub(r'^[ \t\n]*','',code)
    L=len(code)
    progress=0
    N=0
    while code!='':
        code,netP,n0,n1,del_flag=netPToken_quick(code)
        list_pt.append(netP)
        progress=(L-len(code))/L*100
        if progress >= N:
            print("进度: %.2f"%(progress)+"%")
            N+=10
        code=re.sub(r'^[ \t\n;]*','',code)
        if n0!=None or n1!=None:
            dict_con.update({netP:[n0,n1]})
        if del_flag:
            list_del.append(len(list_pt)-1)
    
    for pt in dict_con:
        n0,n1=dict_con[pt]
        if n0!=None:
            pt0=list_pt[n0]
            pt.con(pt0,0)
        if n1!=None:
            pt1=list_pt[n1]
            pt.con(0,pt1)


    if len(list_del)>0:
        print('There are %d invalid points!'%(len(list_del)))
        list_del.reverse()
        for i in list_del:
            print('Deleting %s...'%(list_pt[i].info()))
            list_pt.pop(i)
    return list_pt



def netPToken_quick(code):
    title=r'^[\w \[\]~
    order=r'


    name=re.match(title,code).group()
    code=re.sub(title,'',code)
    if name=='':
        print('\n\n\nError! Invalid name.\nCode:',code)
        raise Exception('Error! Invalid name.')
    if name[-1]=='=' or name[-1]=='-':
        if len(code)>0 and code[0]=='>':
            code=name[-1]+code
            name=name[0:-1]
    con0_name=''
    con1_name=''
    text=''
    if code!='' and code[0]=='\"':
        code=code[1:]
        [code,text]=textToken(code)
        if code=='' or code[0]!='\"':
            print(code)
            raise Exception('Error! Unbalanced quote!')
        code=code[1:]
    if code!='' and code[0]=='(':
        code=code[1:]
        con0_name=re.match(title,code).group()
        code=re.sub(title,'',code)
        if code=='' or code[0]!=',':
            print(code)
            raise Exception('Error! Ilegal net point format. A net point must be title"text"(title,title)')
        code=code[1:]
        con1_name=re.match(title,code).group()
        code=re.sub(title,'',code)
        if code=='' or code[0]!=')':
            raise Exception('Error! Unbalanced bracket in a net point format!')
        code=code[1:]
    if name=='':
        print('Warning! There is a point without a name!')
    n=re.search(order,name)
    if n==None:
        raise Exception('Error! It\'s not a TOP.')
    else:
        n=n.group()[1:]
        int(n)


    name=re.sub(order,'',name)
    netP=NetP(name,text)


    posFormat=r'^\[(-?\d+), *(-?\d+)\]'
    pos=re.findall(posFormat,code)
    if pos!=[]:
        x=int(pos[0][0])
        y=int(pos[0][1])
        netP.m_pos=[x,y]
        code=re.sub(r'^\[-?\d+, *-?\d+\]','',code)


    del_flag=False


    n0=None
    try:
        if con0_name!='':
            str_n0=re.search(order,con0_name).group()
            if len(str_n0)>1:
                n0=int(str_n0[1:])
    except:
        print('Warning! The %s(%s,%s) connects an invalid point'%(name,con0_name,con1_name))
        del_flag=True


    n1=None
    try:
        if con1_name!='':
            str_n1=re.search(order,con1_name).group()
            if len(str_n1)>1:
                n1=int(str_n1[1:])
    except:
        print('Warning! The %s(%s,%s) connects an invalid point'%(name,con0_name,con1_name))
        del_flag=True


    return [code,netP,n0,n1,del_flag]
def readSubCode_tokener(code):
    list_karma=[]
    while code!='':
        code=re.sub(r'^[ \t\n]*','',code)
        if code=='':
            break
        code,result=removeComment(code)
        if result==True:
            continue
        else:
            [code,karma,pointStack]=chainToken(code)
            pointStack.leaveClause()
            karma=karma.causeEnd()
            karma.setRangers()
            list_karma.append(karma)
            if code!='' and code[0]==';':
                code=code[1:]
    return list_karma


def buildPoints_tokener(code):
    list_pt=[]
    code=re.sub(r'^[ \t\n]*','',code)
    pointStack=NetPStack()
    L=len(code)
    progress=0
    N=0
    while code!='':
        code,netP,pointStack=netPToken(code,pointStack)
        list_pt.append(netP)
        progress=(L-len(code))/L*100
        if progress >= N:
            print("进度: %.2f"%(progress)+"%")
            N+=10
        code=re.sub(r'^[ \t\n;]*','',code)
    return list_pt


def divideSents_tokener(code):
    list_sent=[]
    while code!='':
        code=re.sub(r'^[ \t\n]*','',code)
        if code=='':
            break
        code,result=removeComment(code)
        if result==True:
            continue
        
        code_keep=code
        [code,karma,pointStack]=chainToken(code)
        si=code_keep.rfind(code)
        text=code_keep[0:si]
        if code!='' and code[0]==';':
            code=code[1:]
        sent=NetP(karma.m_symbol.m_name,text)
        list_sent.append(sent)
    return list_sent


def chainToken(code,pointStack=None):
    if pointStack==None:
        pointStack=NetPStack()
    [code,karma,pointStack]=karmaToken(code,pointStack)
    if code=='' or code[0]==';' or code[0]=='\n' or code[0]=='}':
        return [code,karma,pointStack]
    elif code[0]==',':
        return [code,karma,pointStack]
    elif code[0]==':':
        code=code[1:]
        [code,karma,pointStack]=splitToken(code,karma,pointStack)
    elif code[0]=='|' or code[0]=='&':
        typeSub=code[0]
        code=code[1:]
        if code!='' and code[0]==':':
            if typeSub=='|':
                karma.m_noAnd=False
                karma.m_yesAnd=False
            else:
                karma.m_noAnd=True
                karma.m_yesAnd=True
            code=code[1:]
            [code,karma,pointStack]=splitToken(code,karma,pointStack)
    else:
        [code,typeCon]=conToken(code)
        [code,effect,pointStack]=chainToken(code,pointStack)
        buildRelation(karma,typeCon,effect)
    return [code,karma,pointStack]



def conToken(code):
    while len(code)>3 and code[0:3]=='...':
        code=re.sub(r'^\.\.\..*[\n\t ]*','',code)
    code=re.sub(r'^[ \t]*','',code)
    if len(code)>2 and code[0:3]=='->>':
        typeCon=code[0:3]
        code=code[3:]
    elif len(code)>2 and code[0:3]=='=>>':
        typeCon=code[0:3]
        code=code[3:]
    elif len(code)>1 and code[0:2]=='->':
        typeCon=code[0:2]
        code=code[2:]
    elif len(code)>1 and code[0:2]=='=>':
        typeCon=code[0:2]
        code=code[2:]
    else:
        print('\n\n\nIllegal connection symbol!\nCode:',code)
        raise Exception('Illegal connection symbol!')
    code=re.sub(r'^[ \t]*','',code)
    return [code,typeCon]


def clauseToken(code,karma,pointStack):
    pointStack.enterClause()
    while True:
        code=re.sub(r'^[ \t\n]*','',code)
        if code=='':
            raise Exception('Error! Unbalanced bracket!')
        elif code[0]=='}':
            break
        else:
            [code,clause,pointStack]=chainToken(code,pointStack)
            karma.m_clause.append(clause)
            clause.m_cause=karma
            if code!='' and code[0]!=',':
                break
            elif code!='':
                code=code[1:]
    pointStack.leaveClause()
    return [code,karma,pointStack]


def splitToken(code,karma,pointStack):
    while True:
        code=re.sub(r'^[ \t\n]*','',code)
        [code,typeCon]=conToken(code)
        [code,effect,pointStack]=chainToken(code,pointStack)
        buildRelation(karma,typeCon,effect)
        code=re.sub(r'^[ \t\n]*','',code)
        if code=='' or code[0]==';' or code[0]=='}':
            break
        elif code[0]!=',':
            print('\n\n\n\nError! Ilegal splitting type!\nCode:',code)
            raise Exception('Error! Ilegal splitting type!')
        else:
            code=code[1:]
    return [code,karma,pointStack]


def karmaToken(code,pointStack):
    if code=='':
        raise Exception('Error! Invalid karma detected!')
    buildType=False
    karma=None
    if code[0]=='+':
        buildType=True
    [code,netP,pointStack]=netPToken(code,pointStack)
    karma=Karma(netP)
    if buildType==True and netP.m_name!='+':
        netP.m_name=netP.m_name[1:]
        karma.m_buildMode=True
    if code!='' and code[0]=='{':
        code=code[1:]
        [code,karma,pointStack]=clauseToken(code,karma,pointStack)
        code=re.sub(r'^[\n\t ]*','',code)
        if code=='' or code[0]!='}':
            print('\n\n\nError! Unbalanced bracket.\nCode:',code)
            raise Exception('Error! Unbalanced bracket.')
        else:
            code=code[1:]
    elif code!='' and (code[0]=='|' or code[0]=='&'):
        typeSub=code[0]
        code=code[1:]
        if code!='' and code[0]=='{':
            if typeSub=='|':
                karma.m_clauseAnd=False
            else:
                karma.m_clauseAnd=True
            code=code[1:]
            [code,karma,pointStack]=clauseToken(code,karma,pointStack)
            code=re.sub(r'^[\n\t ]*','',code)
            if code=='' or code[0]!='}':
                raise Exception('Error! Unbalanced bracket.')
            else:
                code=code[1:]
        else:
            code=typeSub+code
    return [code,karma,pointStack]


def netPToken(code,pointStack):
    title=r'^[\w \[\]~
    name=re.match(title,code).group()
    code=re.sub(title,'',code)
    if name=='':
        print('\n\n\nError! Invalid name.\nCode:',code)
        raise Exception('Error! Invalid name.')
    if name[-1]=='=' or name[-1]=='-':
        if len(code)>0 and code[0]=='>':
            code=name[-1]+code
            name=name[0:-1]
    con0_name=''
    con1_name=''
    text=''
    if code!='' and code[0]=='\"':
        code=code[1:]
        [code,text]=textToken(code)
        if code=='' or code[0]!='\"':
            print(code)
            raise Exception('Error! Unbalanced quote!')
        code=code[1:]
    if code!='' and code[0]=='(':
        code=code[1:]
        con0_name=re.match(title,code).group()
        code=re.sub(title,'',code)
        if code=='' or code[0]!=',':
            print(code)
            raise Exception('Error! Ilegal net point format. A net point must be title"text"(title,title)')
        code=code[1:]
        con1_name=re.match(title,code).group()
        code=re.sub(title,'',code)
        if code=='' or code[0]!=')':
            raise Exception('Error! Unbalanced bracket in a net point format!')
        code=code[1:]
    if name=='':
        print('Warning! There is a point without a name!')
    netP=pointStack.buildNetP(name,con0_name,con1_name)
    posFormat=r'^\[(-?\d+), *(-?\d+)\]'
    pos=re.findall(posFormat,code)
    if pos!=[]:
        x=int(pos[0][0])
        y=int(pos[0][1])
        netP.m_pos=[x,y]
        code=re.sub(r'^\[-?\d+, *-?\d+\]','',code)
    netP.m_text=text
    return [code,netP,pointStack]


def textToken(code):
    text=''
    preEnd=True
    while True:
        if code=='':
            break
        elif len(code)>1 and code[0:2]=='\\"':
            preEnd=False
        elif code[0]=='\"' and preEnd==True:
            break
        else:
            text+=code[0]
            preEnd=True
        code=code[1:]
    return [code,text]


def buildRelation(karma,typeCon,effect):
    if typeCon=='->':
        karma.m_yese.append(effect)
    elif typeCon=='->>':
        karma.m_noe.append(effect)
    elif typeCon=='=>':
        karma.m_yese.append(effect)
        effect.m_no=True
    elif typeCon=='=>>':
        karma.m_noe.append(effect)
        effect.m_no=True
    else:
        raise Exception('Error! Ilegal connection type!')
    effect.m_cause=karma
def genFCode(list_pt):
    fcode_pt="
    fcode_con="
    fcode_text="


    i=0
    for pt in list_pt:
        fcode_pt+=pt.m_name+", "
        pt.m_name+="
        length=len(pt.m_text)
        if length!=0:
            fcode_text+="
        i+=1


    for pt in list_pt:
        con1=""
        if pt.m_db[0]!=None:
            i=pt.m_db[0].m_name.rfind('
            if i!=-1:
                con1=pt.m_db[0].m_name[i+1:]
            else:
                con1="del"


        con2="
        if pt.m_db[1]!=None:
            i=pt.m_db[1].m_name.rfind('
            if i!=-1:
                con2=pt.m_db[1].m_name[i:]
            else:
                con2="
        
        fcode_con+="%s%s, "%(con1,con2)


    for pt in list_pt:
        i=pt.m_name.find('
        pt.m_name=pt.m_name[0:i]


    fcode=fcode_pt+"\n"+fcode_con+"\n"+fcode_text+"
    return fcode



def loadFCode(fcode):
    list_pt=[]
    list_del=[]


    code=fcode
    if code[0:7]!="
        raise("错误! 没有检测到节点段落. ")
    code=code[7:]


    print("开始输入节点... ")
    i=-2
    while True:
        code=code[i+2:]
        if code=='':
            break
        elif code[0]=='\n':
            code=code[1:]
            break
        i=code.find(", ")
        if i==-1:
            raise("错误! 节点段落没有恰当地终止! ")
        list_pt.append(NetP(code[0:i]))


    print("完成节点输入! ")
    print("开始构建关联... ")


    if code[0:7]!="
        raise("错误! 没有检测到关联段落. ")
    code=code[7:]


    i=-2
    n=-1
    while True:
        n+=1
        code=code[i+2:]
        if code=='':
            break
        elif code[0]=='\n':
            code=code[1:]
            break
        i=code.find(", ")
        if i==-1:
            raise("错误! 关联段落没有恰当地终止! ")
        con=code[:i]
        j=con.find('
        if j==-1:
            print("警告! 第%d个节点关联的格式有误, 该节点将被删除! "%(n))
            list_del.append(n)
            continue
        num0=con[0:j]
        num1=con[j+1:]
        if num0=="del" or num1=="del":
            list_del.append(n)
            continue


        con0=None
        if num0!='':
            try:
                con0=list_pt[int(num0)]
            except:
                list_del.append(n)
                continue
        con1=None
        if num1!='':
            try:
                con1=list_pt[int(num1)]
            except:
                list_del.append(n)
                continue
        list_pt[n].con(con0,con1)


        
    print("构建关联完成! ")
    print("开始读取内容... ")


    if code[0:7]!="
        raise("错误! 没有检测到内容段落. ")
    code=code[7:]


    while True:
        result=re.match(r'
        if result==None:
            if code!='' and code=="
                break
            else:
                raise("错误! 内容的格式不正确. ")
        n=int(result.group(1))
        length=int(result.group(2))
        i=result.span()[1]
        code=code[i:]
        text=code[0:length]
        list_pt[n].m_text=text


        code=code[length:]
        if code[0:8]!='\n
            raise("错误! 内容的格式不正确")
        code=code[8:]


    print("内容读取完成! ")
        
    if len(list_del)>0:
        print('There are %d invalid points!'%(len(list_del)))
        list_del.reverse()
        for i in list_del:
            print('Deleting %s...'%(list_pt[i].info()))
            list_pt.pop(i)


    return list_pt





if __name__=='__main__':
    list_km=readSubCode_tokener('test(,_a)->_a')
    karma=list_km[0].causeEnd()
    karma.setRangers()
    list_km[0].m_symbol.print()
    print(karma.info_karma())


## end
#2178, 174:
+[调用词典动词](+[做],+显示)->+[做](,结构场景#13)...
->+在(+[做],图形#4)->+[del](,+在)...
    ->+中(+在,)->+[del](,+中)...
->+[程序流程图]#14->+为(+[做],+[程序流程图]#14)...
    ->+[del](,+为)->[]->[]->结构场景#13
## end
#2179, 38:
2.4000000000000004, 4.1000000000000005
## end
#2180, 38:
2.4000000000000004, 4.1000000000000005
## end
#2181, 38:
2.4000000000000004, 4.1000000000000005
## end
#2182, 38:
2.4000000000000004, 4.1000000000000005
## end
#2183, 38:
2.4000000000000004, 4.1000000000000005
## end
#2184, 38:
2.4000000000000004, 4.1000000000000005
## end
#2185, 38:
2.4000000000000004, 4.1000000000000005
## end
#2186, 38:
2.4000000000000004, 4.1000000000000005
## end
#2187, 38:
2.4000000000000004, 4.1000000000000005
## end
#2188, 38:
2.4000000000000004, 4.1000000000000005
## end
#2190, 3:
2,1
## end
#2192, 4:
a=1

## end
#2195, 14:
__init__(self)
## end
#2196, 23:
2.2, 1.2500000000000002
## end
#2199, 4:
NetP
## end
#2200, 38:
2.4000000000000004, 1.5000000000000004
## end
#2201, 38:
2.4000000000000004, 1.6500000000000006
## end
#2206, 4:
0, 0
## end
#2209, 24:
0.1, 0.15000000000000013
## end
#2211, 38:
2.4000000000000004, 1.6500000000000006
## end
#2214, 24:
0.2, 0.30000000000000027
## end
#2216, 38:
2.4000000000000004, 1.6500000000000006
## end
#2217, 4:
6238
## end
#2219, 37:
11.299999999999999, 4.050000000000001
## end
#2220, 37:
11.299999999999999, 4.050000000000001
## end
#2221, 37:
11.299999999999999, 4.050000000000001
## end
#2222, 37:
11.299999999999999, 4.050000000000001
## end
#2223, 37:
11.299999999999999, 4.050000000000001
## end
#2224, 37:
11.299999999999999, 4.050000000000001
## end
#2225, 37:
11.299999999999999, 4.050000000000001
## end
#2226, 37:
11.299999999999999, 4.050000000000001
## end
#2227, 37:
11.299999999999999, 4.050000000000001
## end
#2228, 37:
11.299999999999999, 4.050000000000001
## end
#2229, 37:
11.299999999999999, 4.050000000000001
## end
#2230, 37:
11.299999999999999, 4.050000000000001
## end
#2231, 24:
11.299999999999999, 5.15
## end
#2232, 24:
11.299999999999999, 5.15
## end
#2233, 24:
11.299999999999999, 5.15
## end
#2234, 24:
11.299999999999999, 5.15
## end
#2235, 24:
11.299999999999999, 5.15
## end
#2236, 24:
11.299999999999999, 5.15
## end
#2237, 24:
11.299999999999999, 5.15
## end
#2238, 24:
11.299999999999999, 5.15
## end
#2239, 24:
11.299999999999999, 5.15
## end
#2240, 24:
11.299999999999999, 5.15
## end
#2241, 24:
11.299999999999999, 5.15
## end
#2242, 24:
11.299999999999999, 5.15
## end
#2243, 24:
11.299999999999999, 5.15
## end
#2245, 480:

def removeComment(code):
    if len(code)==0:
        return code,False
    elif code[0]=='#':
        code=re.sub(r'^#.*','',code)
    elif code[0:3]=='"""':
        code=code[3:]
        while True:
            if len(code)<3:
                code=''
                break
            elif code[0:3]=='"""':
                break
            else:
                code=re.sub(r'^.*\n?','',code)
        code=code[3:]
    else:
        return code,False
    return code,True




## end
#2246, 37:
11.299999999999999, 4.050000000000001
## end
#2247, 37:
11.299999999999999, 4.050000000000001
## end
#2248, 37:
11.299999999999999, 4.050000000000001
## end
#2249, 37:
11.299999999999999, 4.050000000000001
## end
#2250, 37:
11.299999999999999, 4.050000000000001
## end
#2251, 37:
11.299999999999999, 4.050000000000001
## end
#2252, 37:
11.299999999999999, 4.050000000000001
## end
#2253, 37:
11.299999999999999, 4.050000000000001
## end
#2254, 37:
11.299999999999999, 4.050000000000001
## end
#2255, 37:
11.299999999999999, 4.050000000000001
## end
#2256, 37:
11.299999999999999, 4.050000000000001
## end
#2257, 37:
11.299999999999999, 4.050000000000001
## end
#2258, 22:
6.7, 2.650000000000001
## end
#2259, 22:
6.7, 2.650000000000001
## end
#2260, 22:
6.7, 2.650000000000001
## end
#2261, 22:
6.7, 2.650000000000001
## end
#2262, 22:
6.7, 2.650000000000001
## end
#2263, 22:
6.7, 2.650000000000001
## end
#2264, 22:
6.7, 2.650000000000001
## end
#2265, 22:
6.7, 2.650000000000001
## end
#2266, 22:
6.7, 2.650000000000001
## end
#2267, 22:
6.7, 2.650000000000001
## end
#2268, 23:
6.7, 3.7500000000000004
## end
#2269, 23:
6.7, 3.7500000000000004
## end
#2270, 23:
6.7, 3.7500000000000004
## end
#2271, 23:
6.7, 3.7500000000000004
## end
#2272, 23:
6.7, 3.7500000000000004
## end
#2273, 23:
6.7, 3.7500000000000004
## end
#2274, 23:
2.2, 2.5000000000000004
## end
#2275, 23:
2.2, 2.5000000000000004
## end
#2276, 23:
2.2, 1.4000000000000004
## end
#2277, 23:
2.2, 1.4000000000000004
## end
#2278, 23:
2.2, 2.7500000000000004
## end
#2279, 23:
2.2, 2.7500000000000004
## end
#2280, 23:
2.2, 2.7500000000000004
## end
#2281, 22:
4.3, 2.650000000000001
## end
#2282, 22:
4.3, 2.650000000000001
## end
#2283, 23:
4.3, 5.1000000000000005
## end
#2284, 23:
4.3, 5.1000000000000005
## end
#2285, 23:
4.3, 5.1000000000000005
## end
#2286, 23:
4.3, 5.1000000000000005
## end
#2287, 23:
4.3, 5.1000000000000005
## end
#2288, 25:
11.299999999999999, 11.55
## end
#2289, 25:
11.299999999999999, 11.55
## end
#2290, 25:
11.299999999999999, 11.55
## end
#2291, 25:
11.299999999999999, 11.55
## end
#2292, 25:
11.299999999999999, 11.55
## end
#2293, 25:
11.299999999999999, 11.55
## end
#2294, 25:
11.299999999999999, 11.55
## end
#2295, 25:
11.299999999999999, 11.55
## end
#2296, 25:
11.299999999999999, 11.55
## end
#2297, 25:
11.299999999999999, 11.55
## end
#2298, 25:
11.299999999999999, 11.55
## end
#2299, 25:
11.299999999999999, 11.55
## end
#2300, 25:
11.299999999999999, 11.55
## end
#2301, 25:
11.299999999999999, 11.55
## end
#2302, 25:
11.299999999999999, 11.55
## end
#2303, 25:
11.299999999999999, 11.55
## end
#2304, 25:
11.299999999999999, 11.55
## end
#2305, 25:
11.299999999999999, 11.55
## end
#2306, 25:
11.299999999999999, 11.55
## end
#2307, 25:
11.299999999999999, 11.55
## end
#2308, 25:
11.299999999999999, 11.55
## end
#2309, 37:
11.299999999999999, 48.10000000000002
## end
#2310, 37:
11.299999999999999, 48.10000000000002
## end
#2311, 37:
11.299999999999999, 48.10000000000002
## end
#2312, 37:
11.299999999999999, 48.10000000000002
## end
#2313, 37:
11.299999999999999, 48.10000000000002
## end
#2314, 37:
11.299999999999999, 48.10000000000002
## end
#2315, 37:
11.299999999999999, 48.10000000000002
## end
#2316, 37:
11.299999999999999, 48.10000000000002
## end
#2317, 37:
11.299999999999999, 48.10000000000002
## end
#2318, 37:
11.299999999999999, 48.10000000000002
## end
#2319, 37:
11.299999999999999, 48.10000000000002
## end
#2320, 37:
11.299999999999999, 48.10000000000002
## end
#2321, 37:
11.299999999999999, 48.10000000000002
## end
#2322, 37:
11.299999999999999, 48.10000000000002
## end
#2323, 37:
11.299999999999999, 48.10000000000002
## end
#2324, 37:
11.299999999999999, 48.10000000000002
## end
#2325, 37:
11.299999999999999, 48.10000000000002
## end
#2326, 37:
11.299999999999999, 48.10000000000002
## end
#2327, 37:
11.299999999999999, 48.10000000000002
## end
#2328, 37:
11.299999999999999, 48.10000000000002
## end
#2329, 37:
11.299999999999999, 48.10000000000002
## end
#2330, 37:
11.299999999999999, 48.10000000000002
## end
#2331, 37:
11.299999999999999, 48.10000000000002
## end
#2332, 37:
11.299999999999999, 48.10000000000002
## end
#2333, 37:
11.299999999999999, 48.10000000000002
## end
#2334, 37:
11.299999999999999, 48.10000000000002
## end
#2335, 37:
11.299999999999999, 48.10000000000002
## end
#2336, 37:
11.299999999999999, 48.10000000000002
## end
#2337, 37:
11.299999999999999, 48.10000000000002
## end
#2338, 37:
11.299999999999999, 48.10000000000002
## end
#2339, 37:
11.299999999999999, 48.10000000000002
## end
#2340, 37:
11.299999999999999, 48.10000000000002
## end
#2341, 37:
11.299999999999999, 48.10000000000002
## end
#2342, 37:
11.299999999999999, 48.10000000000002
## end
#2343, 37:
11.299999999999999, 48.10000000000002
## end
#2344, 37:
11.299999999999999, 48.10000000000002
## end
#2345, 37:
11.299999999999999, 48.10000000000002
## end
#2346, 37:
11.299999999999999, 48.10000000000002
## end
#2347, 37:
11.299999999999999, 48.10000000000002
## end
#2348, 37:
11.299999999999999, 48.10000000000002
## end
#2349, 37:
11.299999999999999, 48.10000000000002
## end
#2350, 37:
11.299999999999999, 48.10000000000002
## end
#2351, 37:
11.299999999999999, 48.10000000000002
## end
#2352, 37:
11.299999999999999, 48.10000000000002
## end
#2353, 37:
11.299999999999999, 48.10000000000002
## end
#2354, 37:
11.299999999999999, 48.10000000000002
## end
#2355, 37:
11.299999999999999, 48.10000000000002
## end
#2356, 37:
11.299999999999999, 48.10000000000002
## end
#2357, 37:
11.299999999999999, 48.10000000000002
## end
#2358, 37:
11.299999999999999, 48.10000000000002
## end
#2359, 37:
11.299999999999999, 48.10000000000002
## end
#2360, 37:
11.299999999999999, 48.10000000000002
## end
#2361, 37:
11.299999999999999, 48.10000000000002
## end
#2362, 37:
11.299999999999999, 48.10000000000002
## end
#2363, 37:
11.299999999999999, 48.10000000000002
## end
#2364, 37:
11.299999999999999, 48.10000000000002
## end
#2365, 37:
11.299999999999999, 48.10000000000002
## end
#2366, 37:
11.299999999999999, 48.10000000000002
## end
#2367, 37:
11.299999999999999, 48.10000000000002
## end
#2368, 37:
11.299999999999999, 48.10000000000002
## end
#2369, 37:
11.299999999999999, 48.10000000000002
## end
#2370, 37:
11.299999999999999, 48.10000000000002
## end
#2371, 37:
11.299999999999999, 48.10000000000002
## end
#2372, 37:
11.299999999999999, 48.10000000000002
## end
#2373, 37:
11.299999999999999, 48.10000000000002
## end
#2374, 37:
11.299999999999999, 48.10000000000002
## end
#2375, 37:
11.299999999999999, 48.10000000000002
## end
#2376, 37:
11.299999999999999, 48.10000000000002
## end
#2377, 37:
11.299999999999999, 48.10000000000002
## end
#2378, 37:
11.299999999999999, 48.10000000000002
## end
#2379, 37:
11.299999999999999, 48.10000000000002
## end
#2380, 37:
11.299999999999999, 48.10000000000002
## end
#2381, 37:
11.299999999999999, 48.10000000000002
## end
#2382, 37:
11.299999999999999, 48.10000000000002
## end
#2383, 37:
11.299999999999999, 48.10000000000002
## end
#2384, 37:
11.299999999999999, 48.10000000000002
## end
#2385, 37:
11.299999999999999, 48.10000000000002
## end
#2386, 37:
11.299999999999999, 48.10000000000002
## end
#2387, 37:
11.299999999999999, 48.10000000000002
## end
#2388, 37:
11.299999999999999, 48.10000000000002
## end
#2389, 37:
5.800000000000001, 27.600000000000016
## end
#2390, 37:
5.800000000000001, 27.600000000000016
## end
#2391, 37:
5.800000000000001, 27.600000000000016
## end
#2392, 37:
5.800000000000001, 27.600000000000016
## end
#2393, 37:
5.800000000000001, 27.600000000000016
## end
#2394, 37:
5.800000000000001, 27.600000000000016
## end
#2395, 37:
5.800000000000001, 27.600000000000016
## end
#2396, 37:
5.800000000000001, 27.600000000000016
## end
#2397, 37:
5.800000000000001, 27.600000000000016
## end
#2398, 37:
5.800000000000001, 27.600000000000016
## end
#2399, 37:
5.800000000000001, 27.600000000000016
## end
#2400, 37:
5.800000000000001, 27.600000000000016
## end
#2401, 37:
5.800000000000001, 27.600000000000016
## end
#2402, 37:
5.800000000000001, 27.600000000000016
## end
#2403, 37:
5.800000000000001, 27.600000000000016
## end
#2404, 37:
5.800000000000001, 27.600000000000016
## end
#2405, 37:
5.800000000000001, 27.600000000000016
## end
#2406, 37:
5.800000000000001, 27.600000000000016
## end
#2407, 37:
5.800000000000001, 27.600000000000016
## end
#2408, 37:
5.800000000000001, 27.600000000000016
## end
#2409, 37:
5.800000000000001, 27.600000000000016
## end
#2410, 37:
5.800000000000001, 27.600000000000016
## end
#2411, 37:
5.800000000000001, 27.600000000000016
## end
#2412, 37:
5.800000000000001, 27.600000000000016
## end
#2413, 37:
5.800000000000001, 27.600000000000016
## end
#2414, 37:
5.800000000000001, 27.600000000000016
## end
#2415, 37:
5.800000000000001, 27.600000000000016
## end
#2416, 37:
5.800000000000001, 27.600000000000016
## end
#2417, 37:
5.800000000000001, 27.600000000000016
## end
#2418, 37:
5.800000000000001, 27.600000000000016
## end
#2419, 37:
5.800000000000001, 27.600000000000016
## end
#2420, 37:
5.800000000000001, 27.600000000000016
## end
#2421, 37:
5.800000000000001, 27.600000000000016
## end
#2422, 37:
5.800000000000001, 27.600000000000016
## end
#2423, 37:
5.800000000000001, 27.600000000000016
## end
#2424, 37:
5.800000000000001, 27.600000000000016
## end
#2425, 37:
5.800000000000001, 27.600000000000016
## end
#2426, 37:
5.800000000000001, 27.600000000000016
## end
#2427, 37:
5.800000000000001, 27.600000000000016
## end
#2428, 37:
5.800000000000001, 27.600000000000016
## end
#2429, 37:
5.800000000000001, 27.600000000000016
## end
#2430, 37:
5.800000000000001, 27.600000000000016
## end
#2431, 37:
5.800000000000001, 27.600000000000016
## end
#2432, 37:
5.800000000000001, 27.600000000000016
## end
#2433, 37:
5.800000000000001, 27.600000000000016
## end
#2434, 37:
5.800000000000001, 27.600000000000016
## end
#2435, 37:
5.800000000000001, 27.600000000000016
## end
#2437, 75:
def cond_python_token(code,i):
    return word_python_token(code,i,'[^:]*')
## end
#2438, 24:
13.599999999999998, 5.25
## end
#2439, 24:
13.599999999999998, 5.25
## end
#2440, 24:
13.599999999999998, 5.25
## end
#2441, 24:
13.599999999999998, 5.25
## end
#2442, 24:
13.599999999999998, 5.25
## end
#2443, 24:
13.599999999999998, 5.25
## end
#2444, 24:
13.599999999999998, 5.25
## end
#2445, 24:
13.599999999999998, 5.25
## end
#2446, 24:
13.599999999999998, 5.25
## end
#2447, 24:
13.599999999999998, 5.25
## end
#2448, 24:
13.599999999999998, 5.25
## end
#2449, 24:
13.599999999999998, 5.25
## end
#2450, 23:
2.2, 1.1500000000000001
## end
#2451, 22:
6.9, 3.750000000000001
## end
#2452, 22:
9.1, 3.750000000000001
## end
#2453, 23:
4.7, 3.6500000000000004
## end
#2454, 23:
6.9, 3.6500000000000004
## end
#2455, 23:
9.1, 3.6500000000000004
## end
#2456, 23:
2.2, 1.1500000000000001
## end
#2457, 23:
4.4, 1.1500000000000001
## end
#2458, 23:
6.6, 1.1500000000000001
## end
#2459, 23:
2.2, 1.1500000000000001
## end
#2460, 23:
2.2, 1.1500000000000001
## end
#2461, 23:
2.2, 1.1500000000000001
## end
#2462, 8:
6.8, 4.9
## end
#2463, 23:
2.2, 1.1500000000000001
## end
#2464, 23:
4.4, 1.1500000000000001
## end
#2465, 23:
2.2, 1.1500000000000001
## end
#2466, 23:
4.4, 1.1500000000000001
## end
#2467, 23:
6.6, 1.1500000000000001
## end
#2468, 23:
2.2, 1.1500000000000001
## end
#2469, 23:
2.2, 1.1500000000000001
## end
#2470, 38:
13.599999999999998, 199.04999999999993
## end
#2471, 38:
13.599999999999998, 199.04999999999993
## end
#2472, 38:
13.599999999999998, 199.04999999999993
## end
#2473, 38:
13.599999999999998, 199.04999999999993
## end
#2474, 38:
13.599999999999998, 199.04999999999993
## end
#2475, 38:
13.599999999999998, 199.04999999999993
## end
#2476, 38:
13.599999999999998, 199.04999999999993
## end
#2477, 38:
13.599999999999998, 199.04999999999993
## end
#2478, 38:
13.599999999999998, 199.04999999999993
## end
#2479, 38:
13.599999999999998, 199.04999999999993
## end
#2480, 38:
13.599999999999998, 199.04999999999993
## end
#2481, 38:
13.599999999999998, 199.04999999999993
## end
#2482, 38:
13.599999999999998, 199.04999999999993
## end
#2483, 38:
13.599999999999998, 199.04999999999993
## end
#2484, 38:
13.599999999999998, 199.04999999999993
## end
#2485, 38:
13.599999999999998, 199.04999999999993
## end
#2486, 38:
13.599999999999998, 199.04999999999993
## end
#2487, 38:
13.599999999999998, 199.04999999999993
## end
#2488, 38:
13.599999999999998, 199.04999999999993
## end
#2489, 38:
13.599999999999998, 199.04999999999993
## end
#2490, 38:
13.599999999999998, 199.04999999999993
## end
#2491, 38:
13.599999999999998, 199.04999999999993
## end
#2492, 38:
13.599999999999998, 199.04999999999993
## end
#2493, 38:
13.599999999999998, 199.04999999999993
## end
#2494, 38:
13.599999999999998, 199.04999999999993
## end
#2495, 38:
13.599999999999998, 199.04999999999993
## end
#2496, 38:
13.599999999999998, 199.04999999999993
## end
#2497, 38:
13.599999999999998, 199.04999999999993
## end
#2498, 38:
13.599999999999998, 199.04999999999993
## end
#2499, 38:
13.599999999999998, 199.04999999999993
## end
#2500, 38:
13.599999999999998, 199.04999999999993
## end
#2501, 38:
13.599999999999998, 199.04999999999993
## end
#2502, 38:
13.599999999999998, 199.04999999999993
## end
#2503, 38:
13.599999999999998, 199.04999999999993
## end
#2504, 38:
13.599999999999998, 199.04999999999993
## end
#2505, 38:
13.599999999999998, 199.04999999999993
## end
#2506, 38:
13.599999999999998, 199.04999999999993
## end
#2507, 38:
13.599999999999998, 199.04999999999993
## end
#2508, 38:
13.599999999999998, 199.04999999999993
## end
#2509, 38:
13.599999999999998, 199.04999999999993
## end
#2510, 38:
13.599999999999998, 199.04999999999993
## end
#2511, 38:
13.599999999999998, 199.04999999999993
## end
#2512, 38:
13.599999999999998, 199.04999999999993
## end
#2513, 38:
13.599999999999998, 199.04999999999993
## end
#2514, 38:
13.599999999999998, 199.04999999999993
## end
#2515, 38:
13.599999999999998, 199.04999999999993
## end
#2516, 38:
13.599999999999998, 199.04999999999993
## end
#2517, 38:
13.599999999999998, 199.04999999999993
## end
#2518, 38:
13.599999999999998, 199.04999999999993
## end
#2519, 38:
13.599999999999998, 199.04999999999993
## end
#2520, 38:
13.599999999999998, 199.04999999999993
## end
#2521, 38:
13.599999999999998, 199.04999999999993
## end
#2522, 38:
13.599999999999998, 199.04999999999993
## end
#2523, 38:
13.599999999999998, 199.04999999999993
## end
#2524, 38:
13.599999999999998, 199.04999999999993
## end
#2525, 38:
13.599999999999998, 199.04999999999993
## end
#2526, 38:
13.599999999999998, 199.04999999999993
## end
#2527, 38:
13.599999999999998, 199.04999999999993
## end
#2528, 38:
13.599999999999998, 199.04999999999993
## end
#2529, 38:
13.599999999999998, 199.04999999999993
## end
#2530, 38:
13.599999999999998, 199.04999999999993
## end
#2531, 38:
13.599999999999998, 199.04999999999993
## end
#2532, 38:
13.599999999999998, 199.04999999999993
## end
#2533, 38:
13.599999999999998, 199.04999999999993
## end
#2534, 38:
13.599999999999998, 199.04999999999993
## end
#2535, 38:
13.599999999999998, 199.04999999999993
## end
#2536, 38:
13.599999999999998, 199.04999999999993
## end
#2537, 38:
13.599999999999998, 199.04999999999993
## end
#2538, 38:
13.599999999999998, 199.04999999999993
## end
#2539, 38:
13.599999999999998, 199.04999999999993
## end
#2540, 38:
13.599999999999998, 199.04999999999993
## end
#2541, 38:
13.599999999999998, 199.04999999999993
## end
#2542, 38:
13.599999999999998, 199.04999999999993
## end
#2543, 38:
13.599999999999998, 199.04999999999993
## end
#2544, 38:
13.599999999999998, 199.04999999999993
## end
#2545, 38:
13.599999999999998, 199.04999999999993
## end
#2546, 38:
13.599999999999998, 199.04999999999993
## end
#2547, 38:
13.599999999999998, 199.04999999999993
## end
#2548, 38:
13.599999999999998, 199.04999999999993
## end
#2549, 38:
13.599999999999998, 199.04999999999993
## end
#2550, 38:
13.599999999999998, 199.04999999999993
## end
#2551, 38:
13.599999999999998, 199.04999999999993
## end
#2552, 38:
13.599999999999998, 199.04999999999993
## end
#2553, 38:
13.599999999999998, 199.04999999999993
## end
#2554, 38:
13.599999999999998, 199.04999999999993
## end
#2555, 38:
13.599999999999998, 199.04999999999993
## end
#2556, 38:
13.599999999999998, 199.04999999999993
## end
#2557, 38:
13.599999999999998, 199.04999999999993
## end
#2558, 38:
13.599999999999998, 199.04999999999993
## end
#2559, 38:
13.599999999999998, 199.04999999999993
## end
#2560, 38:
13.599999999999998, 199.04999999999993
## end
#2561, 38:
13.599999999999998, 199.04999999999993
## end
#2562, 38:
13.599999999999998, 199.04999999999993
## end
#2563, 38:
13.599999999999998, 199.04999999999993
## end
#2564, 38:
13.599999999999998, 199.04999999999993
## end
#2565, 38:
13.599999999999998, 199.04999999999993
## end
#2566, 38:
13.599999999999998, 199.04999999999993
## end
#2567, 38:
13.599999999999998, 199.04999999999993
## end
#2568, 38:
13.599999999999998, 199.04999999999993
## end
#2569, 38:
13.599999999999998, 199.04999999999993
## end
#2570, 38:
13.599999999999998, 199.04999999999993
## end
#2571, 38:
13.599999999999998, 199.04999999999993
## end
#2572, 38:
13.599999999999998, 199.04999999999993
## end
#2573, 38:
13.599999999999998, 199.04999999999993
## end
#2574, 38:
13.599999999999998, 199.04999999999993
## end
#2575, 38:
13.599999999999998, 199.04999999999993
## end
#2576, 38:
13.599999999999998, 199.04999999999993
## end
#2577, 38:
13.599999999999998, 199.04999999999993
## end
#2578, 38:
13.599999999999998, 199.04999999999993
## end
#2579, 38:
13.599999999999998, 199.04999999999993
## end
#2580, 38:
13.599999999999998, 199.04999999999993
## end
#2581, 38:
13.599999999999998, 199.04999999999993
## end
#2582, 38:
13.599999999999998, 199.04999999999993
## end
#2583, 38:
13.599999999999998, 199.04999999999993
## end
#2584, 38:
13.599999999999998, 199.04999999999993
## end
#2585, 38:
13.599999999999998, 199.04999999999993
## end
#2586, 38:
13.599999999999998, 199.04999999999993
## end
#2587, 38:
13.599999999999998, 199.04999999999993
## end
#2588, 38:
13.599999999999998, 199.04999999999993
## end
#2589, 38:
13.599999999999998, 199.04999999999993
## end
#2590, 38:
13.599999999999998, 199.04999999999993
## end
#2591, 38:
13.599999999999998, 199.04999999999993
## end
#2592, 38:
13.599999999999998, 199.04999999999993
## end
#2593, 38:
13.599999999999998, 199.04999999999993
## end
#2594, 38:
13.599999999999998, 199.04999999999993
## end
#2595, 38:
13.599999999999998, 199.04999999999993
## end
#2596, 38:
13.599999999999998, 199.04999999999993
## end
#2597, 38:
13.599999999999998, 199.04999999999993
## end
#2598, 38:
13.599999999999998, 199.04999999999993
## end
#2599, 38:
13.599999999999998, 199.04999999999993
## end
#2600, 38:
13.599999999999998, 199.04999999999993
## end
#2601, 38:
13.599999999999998, 199.04999999999993
## end
#2602, 38:
13.599999999999998, 199.04999999999993
## end
#2603, 38:
13.599999999999998, 199.04999999999993
## end
#2604, 38:
13.599999999999998, 199.04999999999993
## end
#2605, 38:
13.599999999999998, 199.04999999999993
## end
#2606, 38:
13.599999999999998, 199.04999999999993
## end
#2607, 38:
13.599999999999998, 199.04999999999993
## end
#2608, 38:
13.599999999999998, 199.04999999999993
## end
#2609, 38:
13.599999999999998, 199.04999999999993
## end
#2610, 38:
13.599999999999998, 199.04999999999993
## end
#2611, 38:
13.599999999999998, 199.04999999999993
## end
#2612, 38:
13.599999999999998, 199.04999999999993
## end
#2613, 38:
13.599999999999998, 199.04999999999993
## end
#2614, 38:
13.599999999999998, 199.04999999999993
## end
#2615, 38:
13.599999999999998, 199.04999999999993
## end
#2616, 38:
13.599999999999998, 199.04999999999993
## end
#2617, 38:
13.599999999999998, 199.04999999999993
## end
#2618, 38:
13.599999999999998, 199.04999999999993
## end
#2619, 38:
13.599999999999998, 199.04999999999993
## end
#2620, 38:
13.599999999999998, 199.04999999999993
## end
#2621, 38:
13.599999999999998, 199.04999999999993
## end
#2622, 38:
13.599999999999998, 199.04999999999993
## end
#2623, 38:
13.599999999999998, 199.04999999999993
## end
#2624, 38:
13.599999999999998, 199.04999999999993
## end
#2625, 38:
13.599999999999998, 199.04999999999993
## end
#2626, 38:
13.599999999999998, 199.04999999999993
## end
#2627, 38:
13.599999999999998, 199.04999999999993
## end
#2628, 38:
13.599999999999998, 199.04999999999993
## end
#2629, 38:
13.599999999999998, 199.04999999999993
## end
#2630, 38:
13.599999999999998, 199.04999999999993
## end
#2631, 38:
13.599999999999998, 199.04999999999993
## end
#2632, 38:
13.599999999999998, 199.04999999999993
## end
#2633, 38:
13.599999999999998, 199.04999999999993
## end
#2634, 38:
13.599999999999998, 199.04999999999993
## end
#2635, 38:
13.599999999999998, 199.04999999999993
## end
#2636, 38:
13.599999999999998, 199.04999999999993
## end
#2637, 38:
13.599999999999998, 199.04999999999993
## end
#2638, 38:
13.599999999999998, 199.04999999999993
## end
#2639, 38:
13.599999999999998, 199.04999999999993
## end
#2640, 38:
13.599999999999998, 199.04999999999993
## end
#2641, 38:
13.599999999999998, 199.04999999999993
## end
#2642, 38:
13.599999999999998, 199.04999999999993
## end
#2643, 38:
13.599999999999998, 199.04999999999993
## end
#2644, 38:
13.599999999999998, 199.04999999999993
## end
#2645, 38:
13.599999999999998, 199.04999999999993
## end
#2646, 38:
13.599999999999998, 199.04999999999993
## end
#2647, 38:
13.599999999999998, 199.04999999999993
## end
#2648, 38:
13.599999999999998, 199.04999999999993
## end
#2649, 38:
13.599999999999998, 199.04999999999993
## end
#2650, 38:
13.599999999999998, 199.04999999999993
## end
#2651, 38:
13.599999999999998, 199.04999999999993
## end
#2652, 38:
13.599999999999998, 199.04999999999993
## end
#2653, 38:
13.599999999999998, 199.04999999999993
## end
#2654, 38:
13.599999999999998, 199.04999999999993
## end
#2655, 38:
13.599999999999998, 199.04999999999993
## end
#2656, 38:
13.599999999999998, 199.04999999999993
## end
#2657, 38:
13.599999999999998, 199.04999999999993
## end
#2658, 38:
13.599999999999998, 199.04999999999993
## end
#2659, 38:
13.599999999999998, 199.04999999999993
## end
#2660, 38:
13.599999999999998, 199.04999999999993
## end
#2661, 38:
13.599999999999998, 199.04999999999993
## end
#2662, 38:
13.599999999999998, 199.04999999999993
## end
#2663, 38:
13.599999999999998, 199.04999999999993
## end
#2664, 38:
13.599999999999998, 199.04999999999993
## end
#2665, 38:
13.599999999999998, 199.04999999999993
## end
#2666, 38:
13.599999999999998, 199.04999999999993
## end
#2667, 38:
13.599999999999998, 199.04999999999993
## end
#2668, 38:
13.599999999999998, 199.04999999999993
## end
#2669, 38:
13.599999999999998, 199.04999999999993
## end
#2670, 38:
13.599999999999998, 199.04999999999993
## end
#2671, 38:
13.599999999999998, 199.04999999999993
## end
#2672, 38:
13.599999999999998, 199.04999999999993
## end
#2673, 38:
13.599999999999998, 199.04999999999993
## end
#2674, 38:
13.599999999999998, 199.04999999999993
## end
#2675, 38:
13.599999999999998, 199.04999999999993
## end
#2676, 38:
13.599999999999998, 199.04999999999993
## end
#2677, 38:
13.599999999999998, 199.04999999999993
## end
#2678, 38:
13.599999999999998, 199.04999999999993
## end
#2679, 38:
13.599999999999998, 199.04999999999993
## end
#2680, 38:
13.599999999999998, 199.04999999999993
## end
#2681, 38:
13.599999999999998, 199.04999999999993
## end
#2682, 38:
13.599999999999998, 199.04999999999993
## end
#2683, 38:
13.599999999999998, 199.04999999999993
## end
#2684, 38:
13.599999999999998, 199.04999999999993
## end
#2685, 38:
13.599999999999998, 199.04999999999993
## end
#2686, 38:
13.599999999999998, 199.04999999999993
## end
#2687, 38:
13.599999999999998, 199.04999999999993
## end
#2688, 38:
13.599999999999998, 199.04999999999993
## end
#2689, 38:
13.599999999999998, 199.04999999999993
## end
#2690, 38:
13.599999999999998, 199.04999999999993
## end
#2691, 38:
13.599999999999998, 199.04999999999993
## end
#2692, 38:
13.599999999999998, 199.04999999999993
## end
#2693, 38:
13.599999999999998, 199.04999999999993
## end
#2694, 38:
13.599999999999998, 199.04999999999993
## end
#2695, 38:
13.599999999999998, 199.04999999999993
## end
#2696, 38:
13.599999999999998, 199.04999999999993
## end
#2697, 38:
13.599999999999998, 199.04999999999993
## end
#2698, 38:
13.599999999999998, 199.04999999999993
## end
#2699, 38:
13.599999999999998, 199.04999999999993
## end
#2700, 38:
13.599999999999998, 199.04999999999993
## end
#2701, 38:
13.599999999999998, 199.04999999999993
## end
#2702, 38:
13.599999999999998, 199.04999999999993
## end
#2703, 38:
13.599999999999998, 199.04999999999993
## end
#2704, 38:
13.599999999999998, 199.04999999999993
## end
#2705, 38:
13.599999999999998, 199.04999999999993
## end
#2706, 38:
13.599999999999998, 199.04999999999993
## end
#2707, 38:
13.599999999999998, 199.04999999999993
## end
#2708, 38:
13.599999999999998, 199.04999999999993
## end
#2709, 38:
13.599999999999998, 199.04999999999993
## end
#2710, 38:
13.599999999999998, 199.04999999999993
## end
#2711, 38:
13.599999999999998, 199.04999999999993
## end
#2712, 38:
13.599999999999998, 199.04999999999993
## end
#2713, 38:
13.599999999999998, 199.04999999999993
## end
#2714, 38:
13.599999999999998, 199.04999999999993
## end
#2715, 38:
13.599999999999998, 199.04999999999993
## end
#2716, 38:
13.599999999999998, 199.04999999999993
## end
#2717, 38:
13.599999999999998, 199.04999999999993
## end
#2718, 38:
13.599999999999998, 199.04999999999993
## end
#2719, 38:
13.599999999999998, 199.04999999999993
## end
#2720, 38:
13.599999999999998, 199.04999999999993
## end
#2721, 38:
13.599999999999998, 199.04999999999993
## end
#2722, 38:
13.599999999999998, 199.04999999999993
## end
#2723, 38:
13.599999999999998, 199.04999999999993
## end
#2724, 38:
13.599999999999998, 199.04999999999993
## end
#2725, 38:
13.599999999999998, 199.04999999999993
## end
#2726, 38:
13.599999999999998, 199.04999999999993
## end
#2727, 38:
13.599999999999998, 199.04999999999993
## end
#2728, 38:
13.599999999999998, 199.04999999999993
## end
#2729, 38:
13.599999999999998, 199.04999999999993
## end
#2730, 38:
13.599999999999998, 199.04999999999993
## end
#2731, 38:
13.599999999999998, 199.04999999999993
## end
#2732, 38:
13.599999999999998, 199.04999999999993
## end
#2733, 38:
13.599999999999998, 199.04999999999993
## end
#2734, 38:
13.599999999999998, 199.04999999999993
## end
#2735, 38:
13.599999999999998, 199.04999999999993
## end
#2736, 38:
13.599999999999998, 199.04999999999993
## end
#2737, 38:
13.599999999999998, 199.04999999999993
## end
#2738, 38:
13.599999999999998, 199.04999999999993
## end
#2739, 38:
13.599999999999998, 199.04999999999993
## end
#2740, 38:
13.599999999999998, 199.04999999999993
## end
#2741, 38:
13.599999999999998, 199.04999999999993
## end
#2742, 38:
13.599999999999998, 199.04999999999993
## end
#2743, 38:
13.599999999999998, 199.04999999999993
## end
#2744, 38:
13.599999999999998, 199.04999999999993
## end
#2745, 38:
13.599999999999998, 199.04999999999993
## end
#2746, 38:
13.599999999999998, 199.04999999999993
## end
#2747, 38:
13.599999999999998, 199.04999999999993
## end
#2748, 38:
13.599999999999998, 199.04999999999993
## end
#2749, 38:
13.599999999999998, 199.04999999999993
## end
#2750, 38:
13.599999999999998, 199.04999999999993
## end
#2751, 38:
13.599999999999998, 199.04999999999993
## end
#2752, 38:
13.599999999999998, 199.04999999999993
## end
#2753, 38:
13.599999999999998, 199.04999999999993
## end
#2754, 38:
13.599999999999998, 199.04999999999993
## end
#2755, 38:
13.599999999999998, 199.04999999999993
## end
#2756, 38:
13.599999999999998, 199.04999999999993
## end
#2757, 38:
13.599999999999998, 199.04999999999993
## end
#2758, 38:
13.599999999999998, 199.04999999999993
## end
#2759, 38:
13.599999999999998, 199.04999999999993
## end
#2760, 38:
13.599999999999998, 199.04999999999993
## end
#2761, 38:
13.599999999999998, 199.04999999999993
## end
#2762, 38:
13.599999999999998, 199.04999999999993
## end
#2763, 38:
13.599999999999998, 199.04999999999993
## end
#2764, 38:
13.599999999999998, 199.04999999999993
## end
#2765, 38:
13.599999999999998, 199.04999999999993
## end
#2766, 38:
13.599999999999998, 199.04999999999993
## end
#2767, 38:
13.599999999999998, 199.04999999999993
## end
#2768, 38:
13.599999999999998, 199.04999999999993
## end
#2769, 38:
13.599999999999998, 199.04999999999993
## end
#2770, 38:
13.599999999999998, 199.04999999999993
## end
#2771, 38:
13.599999999999998, 199.04999999999993
## end
#2772, 38:
13.599999999999998, 199.04999999999993
## end
#2773, 38:
13.599999999999998, 199.04999999999993
## end
#2774, 38:
13.599999999999998, 199.04999999999993
## end
#2775, 38:
13.599999999999998, 199.04999999999993
## end
#2776, 38:
13.599999999999998, 199.04999999999993
## end
#2778, 3:
2,1
## end
#2780, 42:
code=re.sub(r'^\.\.\..*[\n\t ]*','',code)

## end
#2781, 5:
while
## end
#2784, 38:
2.3000000000000003, 1.2500000000000002
## end
#2786, 3:
2,1
## end
#2788, 32:
code=re.sub(r'^[ \t]*','',code)

## end
#2790, 3:
2,1
## end
#2792, 32:
typeCon=code[0:3]
code=code[3:]

## end
#2793, 23:
2.1, 1.1500000000000001
## end
#2796, 3:
2,1
## end
#2798, 32:
typeCon=code[0:3]
code=code[3:]

## end
#2799, 23:
2.1, 1.1500000000000001
## end
#2802, 3:
2,1
## end
#2804, 32:
typeCon=code[0:2]
code=code[2:]

## end
#2805, 23:
2.1, 1.1500000000000001
## end
#2808, 3:
2,1
## end
#2810, 32:
typeCon=code[0:2]
code=code[2:]

## end
#2811, 23:
2.1, 1.1500000000000001
## end
#2814, 3:
2,1
## end
#2816, 100:
print('\n\n\nIllegal connection symbol!\nCode:',code)
raise Exception('Illegal connection symbol!')

## end
#2817, 23:
2.1, 1.1500000000000001
## end
#2821, 2:
if
## end
#2822, 38:
10.999999999999998, 1.1500000000000001
## end
#2824, 3:
2,1
## end
#2826, 54:
code=re.sub(r'^[ \t]*','',code)
return [code,typeCon]

## end
#2829, 14:
conToken(code)
## end
#2830, 24:
11.099999999999998, 4.95
## end
#2832, 3:
2,1
## end
#2834, 25:
pointStack.enterClause()

## end
#2836, 3:
2,1
## end
#2838, 34:
code=re.sub(r'^[ \t\n]*','',code)

## end
#2840, 3:
2,1
## end
#2842, 46:
raise Exception('Error! Unbalanced bracket!')

## end
#2843, 23:
2.1, 1.1500000000000001
## end
#2846, 3:
2,1
## end
#2848, 6:
break

## end
#2849, 23:
2.1, 1.1500000000000001
## end
#2852, 3:
2,1
## end
#2854, 104:
[code,clause,pointStack]=chainToken(code,pointStack)
karma.m_clause.append(clause)
clause.m_cause=karma

## end
#2856, 3:
2,1
## end
#2858, 6:
break

## end
#2859, 23:
2.1, 1.1500000000000001
## end
#2862, 3:
2,1
## end
#2864, 14:
code=code[1:]

## end
#2865, 23:
2.1, 1.1500000000000001
## end
#2869, 2:
if
## end
#2870, 37:
4.500000000000001, 1.1500000000000001
## end
#2871, 37:
4.500000000000001, 2.4000000000000004
## end
#2875, 2:
if
## end
#2876, 23:
9.0, 2.4000000000000004
## end
#2877, 5:
while
## end
#2880, 23:
9.2, 3.7500000000000004
## end
#2882, 3:
2,1
## end
#2884, 56:
pointStack.leaveClause()
return [code,karma,pointStack]

## end
#2887, 34:
clauseToken(code,karma,pointStack)
## end
#2888, 36:
9.299999999999999, 6.199999999999999
## end
#2890, 3:
2,1
## end
#2892, 187:
code=re.sub(r'^[ \t\n]*','',code)
[code,typeCon]=conToken(code)
[code,effect,pointStack]=chainToken(code,pointStack)
buildRelation(karma,typeCon,effect)
code=re.sub(r'^[ \t\n]*','',code)

## end
#2894, 3:
2,1
## end
#2896, 6:
break

## end
#2897, 23:
2.1, 1.1500000000000001
## end
#2900, 3:
2,1
## end
#2902, 108:
print('\n\n\n\nError! Ilegal splitting type!\nCode:',code)
raise Exception('Error! Ilegal splitting type!')

## end
#2903, 23:
2.1, 1.1500000000000001
## end
#2906, 3:
2,1
## end
#2908, 14:
code=code[1:]

## end
#2909, 23:
2.1, 1.1500000000000001
## end
#2913, 2:
if
## end
#2914, 38:
6.6000000000000005, 1.1500000000000001
## end
#2915, 5:
while
## end
#2918, 37:
6.800000000000001, 2.5000000000000004
## end
#2920, 3:
2,1
## end
#2922, 31:
return [code,karma,pointStack]

## end
#2925, 33:
splitToken(code,karma,pointStack)
## end
#2926, 23:
6.9, 3.8500000000000005
## end
#2928, 3:
2,1
## end
#2930, 50:
raise Exception('Error! Invalid karma detected!')

## end
#2931, 23:
2.1, 1.1500000000000001
## end
#2935, 2:
if
## end
#2936, 38:
2.3000000000000003, 1.1500000000000001
## end
#2938, 3:
2,1
## end
#2940, 27:
buildType=False
karma=None

## end
#2942, 3:
2,1
## end
#2944, 15:
buildType=True

## end
#2945, 23:
2.1, 1.1500000000000001
## end
#2949, 2:
if
## end
#2950, 38:
2.3000000000000003, 1.1500000000000001
## end
#2952, 3:
2,1
## end
#2954, 68:
[code,netP,pointStack]=netPToken(code,pointStack)
karma=Karma(netP)

## end
#2956, 3:
2,1
## end
#2958, 51:
netP.m_name=netP.m_name[1:]
karma.m_buildMode=True

## end
#2959, 23:
2.1, 1.1500000000000001
## end
#2963, 2:
if
## end
#2964, 38:
2.3000000000000003, 1.1500000000000001
## end
#2966, 3:
2,1
## end
#2968, 107:
code=code[1:]
[code,karma,pointStack]=clauseToken(code,karma,pointStack)
code=re.sub(r'^[\n\t ]*','',code)

## end
#2970, 3:
2,1
## end
#2972, 100:
print('\n\n\nError! Unbalanced bracket.\nCode:',code)
raise Exception('Error! Unbalanced bracket.')

## end
#2973, 23:
2.1, 1.1500000000000001
## end
#2976, 3:
2,1
## end
#2978, 14:
code=code[1:]

## end
#2979, 23:
2.1, 1.1500000000000001
## end
#2983, 2:
if
## end
#2984, 23:
4.4, 1.1500000000000001
## end
#2985, 23:
4.4, 2.4000000000000004
## end
#2988, 3:
2,1
## end
#2990, 30:
typeSub=code[0]
code=code[1:]

## end
#2992, 3:
2,1
## end
#2994, 24:
karma.m_clauseAnd=False

## end
#2995, 23:
2.1, 1.1500000000000001
## end
#2998, 3:
2,1
## end
#3000, 23:
karma.m_clauseAnd=True

## end
#3001, 23:
2.1, 1.1500000000000001
## end
#3005, 2:
if
## end
#3006, 23:
4.4, 1.1500000000000001
## end
#3008, 3:
2,1
## end
#3010, 107:
code=code[1:]
[code,karma,pointStack]=clauseToken(code,karma,pointStack)
code=re.sub(r'^[\n\t ]*','',code)

## end
#3012, 3:
2,1
## end
#3014, 46:
raise Exception('Error! Unbalanced bracket.')

## end
#3015, 23:
2.1, 1.1500000000000001
## end
#3018, 3:
2,1
## end
#3020, 14:
code=code[1:]

## end
#3021, 23:
2.1, 1.1500000000000001
## end
#3025, 2:
if
## end
#3026, 23:
4.4, 1.1500000000000001
## end
#3027, 22:
4.4, 3.650000000000001
## end
#3030, 3:
2,1
## end
#3032, 18:
code=typeSub+code

## end
#3033, 23:
2.1, 1.1500000000000001
## end
#3037, 2:
if
## end
#3038, 22:
6.7, 3.650000000000001
## end
#3039, 8:
6.7, 4.9
## end
#3043, 2:
if
## end
#3044, 23:
11.399999999999999, 4.9
## end
#3046, 3:
2,1
## end
#3048, 31:
return [code,karma,pointStack]

## end
#3051, 27:
karmaToken(code,pointStack)
## end
#3052, 24:
11.499999999999998, 12.2
## end
#3054, 3:
2,1
## end
#3056, 107:
title=r'^[\w \[\]~#.+=\-^/*\\!<\']*|^\[>=?\]'
name=re.match(title,code).group()
code=re.sub(title,'',code)

## end
#3058, 3:
2,1
## end
#3060, 88:
print('\n\n\nError! Invalid name.\nCode:',code)
raise Exception('Error! Invalid name.')

## end
#3061, 23:
2.1, 1.1500000000000001
## end
#3065, 2:
if
## end
#3066, 38:
2.3000000000000003, 1.1500000000000001
## end
#3068, 3:
2,1
## end
#3070, 35:
code=name[-1]+code
name=name[0:-1]

## end
#3071, 23:
2.1, 1.1500000000000001
## end
#3075, 2:
if
## end
#3076, 38:
2.3000000000000003, 1.1500000000000001
## end
#3077, 38:
2.3000000000000003, 1.3000000000000003
## end
#3081, 2:
if
## end
#3082, 38:
2.5000000000000004, 1.3000000000000003
## end
#3084, 3:
2,1
## end
#3086, 34:
con0_name=''
con1_name=''
text=''

## end
#3088, 3:
2,1
## end
#3090, 42:
code=code[1:]
[code,text]=textToken(code)

## end
#3092, 3:
2,1
## end
#3094, 56:
print(code)
raise Exception('Error! Unbalanced quote!')

## end
#3095, 23:
2.1, 1.1500000000000001
## end
#3099, 2:
if
## end
#3100, 38:
2.3000000000000003, 1.1500000000000001
## end
#3102, 3:
2,1
## end
#3104, 14:
code=code[1:]

## end
#3105, 38:
2.3000000000000003, 3.5000000000000004
## end
#3109, 2:
if
## end
#3110, 38:
2.5000000000000004, 3.5000000000000004
## end
#3112, 3:
2,1
## end
#3114, 80:
code=code[1:]
con0_name=re.match(title,code).group()
code=re.sub(title,'',code)

## end
#3116, 3:
2,1
## end
#3118, 108:
print(code)
raise Exception('Error! Ilegal net point format. A net point must be title"text"(title,title)')

## end
#3119, 23:
2.1, 1.1500000000000001
## end
#3123, 2:
if
## end
#3124, 38:
2.3000000000000003, 1.1500000000000001
## end
#3126, 3:
2,1
## end
#3128, 80:
code=code[1:]
con1_name=re.match(title,code).group()
code=re.sub(title,'',code)

## end
#3130, 3:
2,1
## end
#3132, 68:
raise Exception('Error! Unbalanced bracket in a net point format!')

## end
#3133, 23:
2.1, 1.1500000000000001
## end
#3137, 2:
if
## end
#3138, 38:
2.3000000000000003, 1.1500000000000001
## end
#3140, 3:
2,1
## end
#3142, 14:
code=code[1:]

## end
#3143, 24:
2.3000000000000003, 5.85
## end
#3147, 2:
if
## end
#3148, 24:
2.5000000000000004, 5.85
## end
#3150, 3:
2,1
## end
#3152, 51:
print('Warning! There is a point without a name!')

## end
#3153, 23:
2.1, 1.1500000000000001
## end
#3157, 2:
if
## end
#3158, 38:
2.3000000000000003, 1.1500000000000001
## end
#3160, 3:
2,1
## end
#3162, 119:
netP=pointStack.buildNetP(name,con0_name,con1_name)
posFormat=r'^\[(-?\d+), *(-?\d+)\]'
pos=re.findall(posFormat,code)

## end
#3164, 3:
2,1
## end
#3166, 94:
x=int(pos[0][0])
y=int(pos[0][1])
netP.m_pos=[x,y]
code=re.sub(r'^\[-?\d+, *-?\d+\]','',code)

## end
#3167, 23:
2.1, 1.1500000000000001
## end
#3171, 2:
if
## end
#3172, 38:
2.3000000000000003, 1.1500000000000001
## end
#3174, 3:
2,1
## end
#3176, 47:
netP.m_text=text
return [code,netP,pointStack]

## end
#3179, 26:
netPToken(code,pointStack)
## end
#3180, 38:
2.6000000000000005, 19.250000000000004
## end
#3182, 3:
2,1
## end
#3184, 20:
text=''
preEnd=True

## end
#3186, 3:
2,1
## end
#3188, 6:
break

## end
#3189, 23:
2.1, 1.1500000000000001
## end
#3192, 3:
2,1
## end
#3194, 13:
preEnd=False

## end
#3195, 23:
2.1, 1.1500000000000001
## end
#3198, 3:
2,1
## end
#3200, 6:
break

## end
#3201, 23:
2.1, 1.1500000000000001
## end
#3204, 3:
2,1
## end
#3206, 26:
text+=code[0]
preEnd=True

## end
#3207, 23:
2.1, 1.1500000000000001
## end
#3211, 2:
if
## end
#3212, 37:
8.799999999999999, 1.1500000000000001
## end
#3214, 3:
2,1
## end
#3216, 14:
code=code[1:]

## end
#3217, 5:
while
## end
#3220, 37:
8.999999999999998, 2.5000000000000004
## end
#3222, 3:
2,1
## end
#3224, 19:
return [code,text]

## end
#3227, 15:
textToken(code)
## end
#3228, 36:
9.099999999999998, 4.949999999999999
## end
#3230, 3:
2,1
## end
#3232, 28:
karma.m_yese.append(effect)

## end
#3233, 23:
2.1, 1.1500000000000001
## end
#3236, 3:
2,1
## end
#3238, 27:
karma.m_noe.append(effect)

## end
#3239, 23:
2.1, 1.1500000000000001
## end
#3242, 3:
2,1
## end
#3244, 45:
karma.m_yese.append(effect)
effect.m_no=True

## end
#3245, 23:
2.1, 1.1500000000000001
## end
#3248, 3:
2,1
## end
#3250, 44:
karma.m_noe.append(effect)
effect.m_no=True

## end
#3251, 23:
2.1, 1.1500000000000001
## end
#3254, 3:
2,1
## end
#3256, 50:
raise Exception('Error! Ilegal connection type!')

## end
#3257, 23:
2.1, 1.1500000000000001
## end
#3261, 2:
if
## end
#3262, 38:
10.999999999999998, 1.1500000000000001
## end
#3264, 3:
2,1
## end
#3266, 21:
effect.m_cause=karma

## end
#3269, 35:
buildRelation(karma,typeCon,effect)
## end
#3270, 38:
11.099999999999998, 2.5000000000000004
## end
#3272, 3:
2,1
## end
#3274, 67:
fcode_pt="### 节点\n"
fcode_con="### 关联\n"
fcode_text="### 内容\n"
i=0

## end
#3276, 3:
2,1
## end
#3278, 68:
fcode_pt+=pt.m_name+", "
pt.m_name+="#%d"%(i)
length=len(pt.m_text)

## end
#3280, 3:
2,1
## end
#3282, 58:
fcode_text+="#%d, %d:\n%s\n## end\n"%(i,length,pt.m_text)

## end
#3283, 23:
2.1, 1.1500000000000001
## end
#3287, 2:
if
## end
#3288, 38:
2.3000000000000003, 1.1500000000000001
## end
#3290, 3:
2,1
## end
#3292, 5:
i+=1

## end
#3293, 3:
for
## end
#3296, 38:
2.4000000000000004, 3.6000000000000005
## end
#3298, 3:
2,1
## end
#3300, 8:
con1=""

## end
#3302, 3:
2,1
## end
#3304, 31:
i=pt.m_db[0].m_name.rfind('#')

## end
#3306, 3:
2,1
## end
#3308, 29:
con1=pt.m_db[0].m_name[i+1:]

## end
#3309, 23:
2.1, 1.1500000000000001
## end
#3312, 3:
2,1
## end
#3314, 11:
con1="del"

## end
#3315, 23:
2.1, 1.1500000000000001
## end
#3319, 2:
if
## end
#3320, 23:
4.4, 1.1500000000000001
## end
#3321, 23:
4.4, 2.4000000000000004
## end
#3325, 2:
if
## end
#3326, 38:
4.6000000000000005, 2.4000000000000004
## end
#3328, 3:
2,1
## end
#3330, 9:
con2="#"

## end
#3332, 3:
2,1
## end
#3334, 31:
i=pt.m_db[1].m_name.rfind('#')

## end
#3336, 3:
2,1
## end
#3338, 27:
con2=pt.m_db[1].m_name[i:]

## end
#3339, 23:
2.1, 1.1500000000000001
## end
#3342, 3:
2,1
## end
#3344, 12:
con2="#del"

## end
#3345, 23:
2.1, 1.1500000000000001
## end
#3349, 2:
if
## end
#3350, 23:
4.4, 1.1500000000000001
## end
#3351, 23:
4.4, 2.4000000000000004
## end
#3355, 2:
if
## end
#3356, 38:
4.6000000000000005, 2.4000000000000004
## end
#3358, 3:
2,1
## end
#3360, 32:
fcode_con+="%s%s, "%(con1,con2)

## end
#3361, 3:
for
## end
#3364, 9:
4.7, 8.45
## end
#3366, 3:
2,1
## end
#3368, 47:
i=pt.m_name.find('#')
pt.m_name=pt.m_name[0:i]

## end
#3369, 3:
for
## end
#3372, 23:
2.2, 1.2500000000000002
## end
#3374, 3:
2,1
## end
#3376, 68:
fcode=fcode_pt+"\n"+fcode_con+"\n"+fcode_text+"### 结束"
return fcode

## end
#3379, 17:
genFCode(list_pt)
## end
#3380, 23:
4.8, 15.949999999999998
## end
#3382, 3:
2,1
## end
#3384, 34:
list_pt=[]
list_del=[]
code=fcode

## end
#3386, 3:
2,1
## end
#3388, 25:
raise("错误! 没有检测到节点段落. ")

## end
#3389, 23:
2.1, 1.1500000000000001
## end
#3393, 2:
if
## end
#3394, 38:
2.3000000000000003, 1.1500000000000001
## end
#3396, 3:
2,1
## end
#3398, 39:
code=code[7:]
print("开始输入节点... ")
i=-2

## end
#3400, 3:
2,1
## end
#3402, 16:
code=code[i+2:]

## end
#3404, 3:
2,1
## end
#3406, 6:
break

## end
#3407, 23:
2.1, 1.1500000000000001
## end
#3410, 3:
2,1
## end
#3412, 20:
code=code[1:]
break

## end
#3413, 23:
2.1, 1.1500000000000001
## end
#3417, 2:
if
## end
#3418, 37:
4.500000000000001, 1.1500000000000001
## end
#3420, 3:
2,1
## end
#3422, 18:
i=code.find(", ")

## end
#3424, 3:
2,1
## end
#3426, 27:
raise("错误! 节点段落没有恰当地终止! ")

## end
#3427, 23:
2.1, 1.1500000000000001
## end
#3431, 2:
if
## end
#3432, 38:
2.3000000000000003, 1.1500000000000001
## end
#3434, 3:
2,1
## end
#3436, 32:
list_pt.append(NetP(code[0:i]))

## end
#3437, 5:
while
## end
#3440, 36:
4.700000000000001, 5.949999999999999
## end
#3442, 3:
2,1
## end
#3444, 38:
print("完成节点输入! ")
print("开始构建关联... ")

## end
#3446, 3:
2,1
## end
#3448, 25:
raise("错误! 没有检测到关联段落. ")

## end
#3449, 23:
2.1, 1.1500000000000001
## end
#3453, 2:
if
## end
#3454, 38:
2.3000000000000003, 1.1500000000000001
## end
#3456, 3:
2,1
## end
#3458, 24:
code=code[7:]
i=-2
n=-1

## end
#3460, 3:
2,1
## end
#3462, 21:
n+=1
code=code[i+2:]

## end
#3464, 3:
2,1
## end
#3466, 6:
break

## end
#3467, 23:
2.1, 1.1500000000000001
## end
#3470, 3:
2,1
## end
#3472, 20:
code=code[1:]
break

## end
#3473, 23:
2.1, 1.1500000000000001
## end
#3477, 2:
if
## end
#3478, 37:
4.500000000000001, 1.1500000000000001
## end
#3480, 3:
2,1
## end
#3482, 18:
i=code.find(", ")

## end
#3484, 3:
2,1
## end
#3486, 27:
raise("错误! 关联段落没有恰当地终止! ")

## end
#3487, 23:
2.1, 1.1500000000000001
## end
#3491, 2:
if
## end
#3492, 38:
2.3000000000000003, 1.1500000000000001
## end
#3494, 3:
2,1
## end
#3496, 29:
con=code[:i]
j=con.find('#')

## end
#3498, 3:
2,1
## end
#3500, 70:
print("警告! 第%d个节点关联的格式有误, 该节点将被删除! "%(n))
list_del.append(n)
continue

## end
#3501, 23:
2.1, 1.1500000000000001
## end
#3505, 2:
if
## end
#3506, 38:
2.3000000000000003, 1.1500000000000001
## end
#3508, 3:
2,1
## end
#3510, 29:
num0=con[0:j]
num1=con[j+1:]

## end
#3512, 3:
2,1
## end
#3514, 28:
list_del.append(n)
continue

## end
#3515, 23:
2.1, 1.1500000000000001
## end
#3519, 2:
if
## end
#3520, 38:
2.3000000000000003, 1.1500000000000001
## end
#3522, 3:
2,1
## end
#3524, 10:
con0=None

## end
#3526, 3:
2,1
## end
#3528, 24:
con0=list_pt[int(num0)]

## end
#3530, 3:
2,1
## end
#3532, 28:
list_del.append(n)
continue

## end
#3533, 3:
try
## end
#3536, 23:
4.3, 1.1500000000000001
## end
#3537, 23:
4.3, 1.3000000000000003
## end
#3541, 2:
if
## end
#3542, 23:
4.5, 1.3000000000000003
## end
#3544, 3:
2,1
## end
#3546, 10:
con1=None

## end
#3548, 3:
2,1
## end
#3550, 24:
con1=list_pt[int(num1)]

## end
#3552, 3:
2,1
## end
#3554, 28:
list_del.append(n)
continue

## end
#3555, 3:
try
## end
#3558, 23:
4.3, 1.1500000000000001
## end
#3559, 23:
4.3, 1.3000000000000003
## end
#3563, 2:
if
## end
#3564, 23:
4.5, 1.3000000000000003
## end
#3566, 3:
2,1
## end
#3568, 26:
list_pt[n].con(con0,con1)

## end
#3569, 5:
while
## end
#3572, 37:
4.700000000000001, 15.649999999999999
## end
#3574, 3:
2,1
## end
#3576, 38:
print("构建关联完成! ")
print("开始读取内容... ")

## end
#3578, 3:
2,1
## end
#3580, 25:
raise("错误! 没有检测到内容段落. ")

## end
#3581, 23:
2.1, 1.1500000000000001
## end
#3585, 2:
if
## end
#3586, 38:
2.3000000000000003, 1.1500000000000001
## end
#3588, 3:
2,1
## end
#3590, 14:
code=code[7:]

## end
#3592, 3:
2,1
## end
#3594, 46:
result=re.match(r'#([\d]*), ([\d]*):\n',code)

## end
#3596, 3:
2,1
## end
#3598, 6:
break

## end
#3599, 23:
2.1, 1.1500000000000001
## end
#3602, 3:
2,1
## end
#3604, 24:
raise("错误! 内容的格式不正确. ")

## end
#3605, 23:
2.1, 1.1500000000000001
## end
#3609, 2:
if
## end
#3610, 23:
4.4, 1.1500000000000001
## end
#3611, 23:
4.4, 1.3000000000000003
## end
#3615, 2:
if
## end
#3616, 38:
4.6000000000000005, 1.3000000000000003
## end
#3618, 3:
2,1
## end
#3620, 146:
n=int(result.group(1))
length=int(result.group(2))
i=result.span()[1]
code=code[i:]
text=code[0:length]
list_pt[n].m_text=text
code=code[length:]

## end
#3622, 3:
2,1
## end
#3624, 22:
raise("错误! 内容的格式不正确")

## end
#3625, 23:
2.1, 1.1500000000000001
## end
#3629, 2:
if
## end
#3630, 38:
2.3000000000000003, 1.1500000000000001
## end
#3632, 3:
2,1
## end
#3634, 14:
code=code[8:]

## end
#3635, 5:
while
## end
#3638, 22:
4.800000000000001, 6.1
## end
#3640, 3:
2,1
## end
#3642, 18:
print("内容读取完成! ")

## end
#3644, 3:
2,1
## end
#3646, 73:
print('There are %d invalid points!'%(len(list_del)))
list_del.reverse()

## end
#3648, 3:
2,1
## end
#3650, 59:
print('Deleting %s...'%(list_pt[i].info()))
list_pt.pop(i)

## end
#3651, 3:
for
## end
#3654, 23:
2.2, 1.2500000000000002
## end
#3655, 23:
2.2, 2.5000000000000004
## end
#3659, 2:
if
## end
#3660, 38:
2.4000000000000004, 2.5000000000000004
## end
#3662, 3:
2,1
## end
#3664, 15:
return list_pt

## end
#3667, 16:
loadFCode(fcode)
## end
#3668, 22:
4.9, 43.30000000000001
## end
#3670, 3:
2,1
## end
#3672, 146:
list_km=readSubCode_tokener('test(,_a)->_a')
karma=list_km[0].causeEnd()
karma.setRangers()
list_km[0].m_symbol.print()
print(karma.info_karma())

## end
#3673, 23:
2.1, 1.1500000000000001
## end
#3677, 2:
if
## end
#3678, 38:
2.3000000000000003, 1.1500000000000001
## end
#3679, 38:
11.499999999999998, 115.34999999999998
## end
#3683, 23:
0.0, -6.299999999999999
## end
#3688, 4:
0, 0
## end
#3691, 23:
0.1, 3.6000000000000005
## end
#3695, 23:
0.1, 2.5000000000000004
## end
#3697, 38:
11.499999999999998, 115.34999999999998
## end
#3700, 22:
0.2, 3.750000000000001
## end
#3702, 38:
11.499999999999998, 115.34999999999998
## end
#3705, 23:
0.1, 1.2500000000000002
## end
#3707, 38:
11.499999999999998, 115.34999999999998
## end
#3710, 24:
0.1, 0.15000000000000022
## end
#3712, 38:
11.499999999999998, 115.34999999999998
## end
#3715, 37:
8.899999999999999, 1.3000000000000003
## end
#3719, 38:
2.4000000000000004, 1.3000000000000003
## end
#3723, 23:
0.2, 1.3000000000000003
## end
#3725, 38:
11.499999999999998, 115.34999999999998
## end
#3728, 23:
4.6, 1.3000000000000003
## end
#3730, 38:
11.499999999999998, 115.34999999999998
## end
#3733, 37:
6.799999999999999, 1.3000000000000003
## end
#3735, 38:
11.499999999999998, 115.34999999999998
## end
#3736, 38:
11.499999999999998, 115.34999999999998
## end
#3737, 38:
11.499999999999998, 115.34999999999998
## end
#3738, 38:
11.499999999999998, 115.34999999999998
## end
#3741, 24:
0.0, -10.249999999999998
## end
#3743, 38:
11.499999999999998, 115.34999999999998
## end
#3746, 24:
0.1, -1.1999999999999993
## end
#3750, 23:
0.1, -5.049999999999999
## end
#3752, 38:
11.499999999999998, 115.34999999999998
## end
#3755, 23:
0.1, -6.149999999999999
## end
#3757, 38:
11.499999999999998, 115.34999999999998
## end
#3760, 23:
0.2, -2.399999999999998
## end
#3764, 23:
0.2, -4.899999999999999
## end
#3766, 38:
11.499999999999998, 115.34999999999998
## end
#3767, 38:
11.499999999999998, 115.34999999999998
## end
#3770, 23:
4.6, -3.599999999999998
## end
#3774, 38:
2.5000000000000004, -3.599999999999998
## end
#3778, 39:
0.30000000000000004, -3.599999999999998
## end
#3780, 38:
11.499999999999998, 115.34999999999998
## end
#3781, 38:
11.499999999999998, 115.34999999999998
## end
#3784, 23:
4.6, -4.849999999999998
## end
#3786, 38:
11.499999999999998, 115.34999999999998
## end
#3787, 38:
11.499999999999998, 115.34999999999998
## end
#3790, 37:
6.899999999999999, -4.799999999999997
## end
#3794, 37:
4.699999999999999, -4.799999999999997
## end
#3796, 38:
11.499999999999998, 115.34999999999998
## end
#3797, 38:
11.499999999999998, 115.34999999999998
## end
#3798, 38:
11.499999999999998, 115.34999999999998
## end
#3801, 24:
0.0, -22.549999999999997
## end
#3803, 38:
11.499999999999998, 115.34999999999998
## end
#3806, 23:
0.1, -8.999999999999998
## end
#3810, 24:
0.1, -10.099999999999998
## end
#3812, 38:
11.499999999999998, 115.34999999999998
## end
#3815, 23:
0.2, -7.599999999999998
## end
#3819, 23:
0.2, -8.849999999999998
## end
#3821, 38:
11.499999999999998, 115.34999999999998
## end
#3822, 38:
11.499999999999998, 115.34999999999998
## end
#3825, 38:
4.6000000000000005, -8.799999999999997
## end
#3829, 38:
2.5000000000000004, -8.799999999999997
## end
#3833, 39:
0.30000000000000004, -8.799999999999997
## end
#3835, 38:
11.499999999999998, 115.34999999999998
## end
#3836, 38:
11.499999999999998, 115.34999999999998
## end
#3837, 38:
11.499999999999998, 115.34999999999998
## end
#3838, 38:
11.499999999999998, 115.34999999999998
## end
#3841, 10:
0.0, -41.9
## end
#3843, 38:
11.499999999999998, 115.34999999999998
## end
#3846, 10:
0.1, -11.6
## end
#3850, 10:
0.1, -12.7
## end
#3852, 38:
11.499999999999998, 115.34999999999998
## end
#3855, 24:
0.2, -11.549999999999999
## end
#3857, 38:
11.499999999999998, 115.34999999999998
## end
#3860, 11:
0.1, -13.95
## end
#3862, 38:
11.499999999999998, 115.34999999999998
## end
#3865, 24:
0.1, -15.049999999999999
## end
#3867, 38:
11.499999999999998, 115.34999999999998
## end
#3870, 24:
0.2, -13.899999999999999
## end
#3872, 38:
11.499999999999998, 115.34999999999998
## end
#3875, 10:
0.1, -16.3
## end
#3877, 38:
11.499999999999998, 115.34999999999998
## end
#3880, 24:
0.1, -21.300000000000004
## end
#3882, 38:
11.499999999999998, 115.34999999999998
## end
#3885, 11:
0.2, -16.25
## end
#3887, 38:
11.499999999999998, 115.34999999999998
## end
#3890, 24:
0.1, -22.400000000000006
## end
#3892, 38:
11.499999999999998, 115.34999999999998
## end
#3895, 24:
4.7, -17.500000000000007
## end
#3899, 24:
0.2, -17.500000000000007
## end
#3903, 24:
0.2, -18.750000000000007
## end
#3905, 38:
11.499999999999998, 115.34999999999998
## end
#3906, 38:
11.499999999999998, 115.34999999999998
## end
#3909, 23:
2.4, -18.70000000000001
## end
#3913, 39:
0.30000000000000004, -18.70000000000001
## end
#3915, 38:
11.499999999999998, 115.34999999999998
## end
#3916, 38:
11.499999999999998, 115.34999999999998
## end
#3919, 23:
4.7, -21.25000000000001
## end
#3921, 38:
11.499999999999998, 115.34999999999998
## end
#3922, 38:
11.499999999999998, 115.34999999999998
## end
#3925, 37:
9.200000000000001, -18.70000000000001
## end
#3929, 23:
4.8, -18.85000000000001
## end
#3933, 23:
4.8, -19.95000000000001
## end
#3935, 38:
11.499999999999998, 115.34999999999998
## end
#3938, 37:
7.000000000000001, -18.80000000000001
## end
#3942, 38:
4.8999999999999995, -18.80000000000001
## end
#3944, 38:
11.499999999999998, 115.34999999999998
## end
#3945, 38:
11.499999999999998, 115.34999999999998
## end
#3948, 23:
4.8, -21.20000000000001
## end
#3950, 38:
11.499999999999998, 115.34999999999998
## end
#3951, 38:
11.499999999999998, 115.34999999999998
## end
#3954, 38:
7.000000000000001, -21.150000000000013
## end
#3958, 39:
4.8999999999999995, -21.150000000000013
## end
#3960, 38:
11.499999999999998, 115.34999999999998
## end
#3961, 38:
11.499999999999998, 115.34999999999998
## end
#3962, 38:
11.499999999999998, 115.34999999999998
## end
#3963, 38:
11.499999999999998, 115.34999999999998
## end
#3966, 24:
0.0, -46.949999999999996
## end
#3968, 38:
11.499999999999998, 115.34999999999998
## end
#3971, 24:
0.1, -23.749999999999996
## end
#3975, 24:
0.1, -24.999999999999996
## end
#3977, 38:
11.499999999999998, 115.34999999999998
## end
#3980, 10:
0.1, -26.4
## end
#3982, 38:
11.499999999999998, 115.34999999999998
## end
#3985, 11:
0.2, -24.95
## end
#3987, 38:
11.499999999999998, 115.34999999999998
## end
#3990, 10:
0.1, -27.5
## end
#3992, 38:
11.499999999999998, 115.34999999999998
## end
#3995, 24:
0.2, -26.349999999999998
## end
#3997, 38:
11.499999999999998, 115.34999999999998
## end
#4000, 26:
0.30000000000000004, -26.3
## end
#4002, 38:
11.499999999999998, 115.34999999999998
## end
#4005, 10:
0.1, -31.1
## end
#4007, 38:
11.499999999999998, 115.34999999999998
## end
#4010, 24:
0.1, -37.050000000000004
## end
#4012, 38:
11.499999999999998, 115.34999999999998
## end
#4015, 24:
0.2, -28.700000000000003
## end
#4019, 24:
0.2, -29.950000000000003
## end
#4021, 38:
11.499999999999998, 115.34999999999998
## end
#4024, 24:
0.2, -31.050000000000004
## end
#4026, 38:
11.499999999999998, 115.34999999999998
## end
#4029, 40:
0.30000000000000004, -29.900000000000006
## end
#4031, 38:
11.499999999999998, 115.34999999999998
## end
#4032, 38:
11.499999999999998, 115.34999999999998
## end
#4035, 24:
0.1, -38.300000000000004
## end
#4037, 38:
11.499999999999998, 115.34999999999998
## end
#4040, 24:
0.2, -32.300000000000004
## end
#4044, 24:
0.2, -33.550000000000004
## end
#4046, 38:
11.499999999999998, 115.34999999999998
## end
#4049, 24:
0.2, -34.650000000000006
## end
#4051, 38:
11.499999999999998, 115.34999999999998
## end
#4054, 39:
0.30000000000000004, -33.50000000000001
## end
#4056, 38:
11.499999999999998, 115.34999999999998
## end
#4059, 24:
0.2, -35.900000000000006
## end
#4061, 38:
11.499999999999998, 115.34999999999998
## end
#4064, 23:
0.2, -37.00000000000001
## end
#4066, 38:
11.499999999999998, 115.34999999999998
## end
#4069, 39:
0.30000000000000004, -35.85000000000001
## end
#4071, 38:
11.499999999999998, 115.34999999999998
## end
#4072, 38:
11.499999999999998, 115.34999999999998
## end
#4075, 24:
0.1, -39.400000000000006
## end
#4077, 38:
11.499999999999998, 115.34999999999998
## end
#4080, 23:
0.2, -38.25000000000001
## end
#4082, 38:
11.499999999999998, 115.34999999999998
## end
#4085, 24:
0.1, -40.650000000000006
## end
#4087, 38:
11.499999999999998, 115.34999999999998
## end
#4090, 23:
0.1, -41.75000000000001
## end
#4092, 38:
11.499999999999998, 115.34999999999998
## end
#4095, 23:
0.2, -40.60000000000001
## end
#4097, 38:
11.499999999999998, 115.34999999999998
## end
#4098, 38:
11.499999999999998, 115.34999999999998
## end
#4101, 11:
0.0, -49.55
## end
#4103, 38:
11.499999999999998, 115.34999999999998
## end
#4106, 24:
0.1, -43.099999999999994
## end
#4110, 24:
0.1, -45.699999999999996
## end
#4112, 38:
11.499999999999998, 115.34999999999998
## end
#4115, 10:
0.1, -46.8
## end
#4117, 38:
11.499999999999998, 115.34999999999998
## end
#4120, 24:
0.2, -44.449999999999996
## end
#4124, 11:
0.2, -45.55
## end
#4126, 38:
11.499999999999998, 115.34999999999998
## end
#4129, 10:
6.8, -44.4
## end
#4133, 25:
2.5000000000000004, -44.4
## end
#4137, 26:
0.30000000000000004, -44.4
## end
#4139, 38:
11.499999999999998, 115.34999999999998
## end
#4142, 10:
4.7, -44.4
## end
#4144, 38:
11.499999999999998, 115.34999999999998
## end
#4145, 38:
11.499999999999998, 115.34999999999998
## end
#4146, 38:
11.499999999999998, 115.34999999999998
## end
#4147, 38:
11.499999999999998, 115.34999999999998
## end
#4148, 38:
11.499999999999998, 115.34999999999998
## end
#4151, 10:
0.0, -65.6
## end
#4153, 38:
11.499999999999998, 115.34999999999998
## end
#4156, 10:
0.1, -48.3
## end
#4160, 10:
0.1, -49.4
## end
#4162, 38:
11.499999999999998, 115.34999999999998
## end
#4165, 25:
8.899999999999999, -48.25
## end
#4169, 26:
2.4000000000000004, -48.25
## end
#4173, 11:
0.2, -48.25
## end
#4175, 38:
11.499999999999998, 115.34999999999998
## end
#4178, 11:
4.6, -48.25
## end
#4180, 38:
11.499999999999998, 115.34999999999998
## end
#4183, 25:
6.799999999999999, -48.25
## end
#4185, 38:
11.499999999999998, 115.34999999999998
## end
#4186, 38:
11.499999999999998, 115.34999999999998
## end
#4187, 38:
11.499999999999998, 115.34999999999998
## end
#4188, 38:
11.499999999999998, 115.34999999999998
## end
#4191, 11:
0.0, -109.0
## end
#4193, 38:
11.499999999999998, 115.34999999999998
## end
#4196, 23:
0.1, -50.74999999999999
## end
#4200, 24:
0.1, -54.449999999999996
## end
#4202, 38:
11.499999999999998, 115.34999999999998
## end
#4205, 23:
0.1, -62.99999999999999
## end
#4207, 38:
11.499999999999998, 115.34999999999998
## end
#4210, 24:
0.2, -51.949999999999996
## end
#4214, 24:
0.2, -53.199999999999996
## end
#4216, 38:
11.499999999999998, 115.34999999999998
## end
#4219, 10:
0.2, -54.3
## end
#4221, 38:
11.499999999999998, 115.34999999999998
## end
#4224, 27:
0.30000000000000004, -53.15
## end
#4226, 38:
11.499999999999998, 115.34999999999998
## end
#4227, 38:
11.499999999999998, 115.34999999999998
## end
#4230, 11:
0.1, -64.35
## end
#4232, 38:
11.499999999999998, 115.34999999999998
## end
#4235, 23:
0.2, -55.64999999999999
## end
#4239, 23:
0.2, -58.14999999999999
## end
#4241, 38:
11.499999999999998, 115.34999999999998
## end
#4244, 23:
0.2, -59.24999999999999
## end
#4246, 38:
11.499999999999998, 115.34999999999998
## end
#4249, 40:
0.30000000000000004, -56.849999999999994
## end
#4253, 40:
0.30000000000000004, -58.099999999999994
## end
#4255, 38:
11.499999999999998, 115.34999999999998
## end
#4256, 38:
11.499999999999998, 115.34999999999998
## end
#4259, 26:
2.5000000000000004, -58.05
## end
#4263, 11:
0.4, -58.05
## end
#4265, 38:
11.499999999999998, 115.34999999999998
## end
#4266, 38:
11.499999999999998, 115.34999999999998
## end
#4269, 23:
0.2, -61.74999999999999
## end
#4271, 38:
11.499999999999998, 115.34999999999998
## end
#4274, 24:
0.2, -62.849999999999994
## end
#4276, 38:
11.499999999999998, 115.34999999999998
## end
#4279, 40:
0.30000000000000004, -60.449999999999996
## end
#4283, 40:
0.30000000000000004, -61.699999999999996
## end
#4285, 38:
11.499999999999998, 115.34999999999998
## end
#4286, 38:
11.499999999999998, 115.34999999999998
## end
#4289, 26:
2.5000000000000004, -61.65
## end
#4293, 11:
0.4, -61.65
## end
#4295, 38:
11.499999999999998, 115.34999999999998
## end
#4296, 38:
11.499999999999998, 115.34999999999998
## end
#4297, 38:
11.499999999999998, 115.34999999999998
## end
#4300, 23:
0.1, -65.44999999999999
## end
#4302, 38:
11.499999999999998, 115.34999999999998
## end
#4305, 23:
0.2, -64.19999999999999
## end
#4307, 38:
11.499999999999998, 115.34999999999998
## end
#4308, 38:
11.499999999999998, 115.34999999999998
## end
#4311, 12:
0.0, -110.25
## end
#4313, 38:
11.499999999999998, 115.34999999999998
## end
#4316, 23:
0.1, -66.79999999999998
## end
#4320, 23:
0.1, -68.04999999999998
## end
#4322, 38:
11.499999999999998, 115.34999999999998
## end
#4325, 23:
0.1, -69.14999999999998
## end
#4327, 38:
11.499999999999998, 115.34999999999998
## end
#4330, 23:
0.2, -67.99999999999997
## end
#4332, 38:
11.499999999999998, 115.34999999999998
## end
#4335, 23:
0.1, -75.19999999999997
## end
#4337, 38:
11.499999999999998, 115.34999999999998
## end
#4340, 23:
0.1, -76.29999999999997
## end
#4342, 38:
11.499999999999998, 115.34999999999998
## end
#4345, 23:
0.2, -70.34999999999997
## end
#4349, 23:
0.2, -71.59999999999997
## end
#4351, 38:
11.499999999999998, 115.34999999999998
## end
#4354, 23:
0.2, -72.69999999999996
## end
#4356, 38:
11.499999999999998, 115.34999999999998
## end
#4359, 38:
2.5000000000000004, -71.54999999999995
## end
#4363, 39:
0.30000000000000004, -71.54999999999995
## end
#4365, 38:
11.499999999999998, 115.34999999999998
## end
#4366, 38:
11.499999999999998, 115.34999999999998
## end
#4369, 23:
0.2, -73.94999999999996
## end
#4371, 38:
11.499999999999998, 115.34999999999998
## end
#4374, 23:
0.2, -75.04999999999995
## end
#4376, 38:
11.499999999999998, 115.34999999999998
## end
#4379, 39:
0.30000000000000004, -73.89999999999995
## end
#4381, 38:
11.499999999999998, 115.34999999999998
## end
#4382, 38:
11.499999999999998, 115.34999999999998
## end
#4385, 23:
0.1, -77.54999999999997
## end
#4387, 38:
11.499999999999998, 115.34999999999998
## end
#4390, 23:
0.1, -78.64999999999996
## end
#4392, 38:
11.499999999999998, 115.34999999999998
## end
#4395, 23:
0.2, -77.49999999999996
## end
#4397, 38:
11.499999999999998, 115.34999999999998
## end
#4400, 23:
0.1, -94.39999999999995
## end
#4402, 38:
11.499999999999998, 115.34999999999998
## end
#4405, 23:
0.1, -95.49999999999994
## end
#4407, 38:
11.499999999999998, 115.34999999999998
## end
#4410, 23:
0.2, -79.84999999999994
## end
#4414, 23:
0.2, -81.09999999999994
## end
#4416, 38:
11.499999999999998, 115.34999999999998
## end
#4419, 23:
0.2, -82.19999999999993
## end
#4421, 38:
11.499999999999998, 115.34999999999998
## end
#4424, 38:
2.5000000000000004, -81.04999999999993
## end
#4428, 39:
0.30000000000000004, -81.04999999999993
## end
#4430, 38:
11.499999999999998, 115.34999999999998
## end
#4431, 38:
11.499999999999998, 115.34999999999998
## end
#4434, 23:
0.2, -83.44999999999993
## end
#4436, 38:
11.499999999999998, 115.34999999999998
## end
#4439, 23:
0.2, -84.54999999999993
## end
#4441, 38:
11.499999999999998, 115.34999999999998
## end
#4444, 39:
0.30000000000000004, -83.39999999999992
## end
#4446, 38:
11.499999999999998, 115.34999999999998
## end
#4449, 23:
0.2, -85.79999999999993
## end
#4451, 38:
11.499999999999998, 115.34999999999998
## end
#4454, 23:
0.2, -86.89999999999992
## end
#4456, 38:
11.499999999999998, 115.34999999999998
## end
#4459, 39:
0.30000000000000004, -85.74999999999991
## end
#4461, 38:
11.499999999999998, 115.34999999999998
## end
#4464, 23:
0.2, -88.14999999999992
## end
#4466, 38:
11.499999999999998, 115.34999999999998
## end
#4469, 23:
0.2, -89.24999999999991
## end
#4471, 38:
11.499999999999998, 115.34999999999998
## end
#4474, 39:
0.30000000000000004, -88.09999999999991
## end
#4476, 38:
11.499999999999998, 115.34999999999998
## end
#4479, 22:
0.2, -90.6499999999999
## end
#4481, 38:
11.499999999999998, 115.34999999999998
## end
#4484, 22:
0.2, -91.7499999999999
## end
#4486, 38:
11.499999999999998, 115.34999999999998
## end
#4489, 39:
0.30000000000000004, -90.59999999999991
## end
#4491, 38:
11.499999999999998, 115.34999999999998
## end
#4494, 22:
2.5, -90.5499999999999
## end
#4498, 22:
0.4, -90.5499999999999
## end
#4502, 23:
0.2, -93.14999999999989
## end
#4504, 38:
11.499999999999998, 115.34999999999998
## end
#4507, 23:
0.2, -94.24999999999989
## end
#4509, 38:
11.499999999999998, 115.34999999999998
## end
#4512, 38:
0.30000000000000004, -93.0999999999999
## end
#4514, 38:
11.499999999999998, 115.34999999999998
## end
#4517, 23:
2.5, -93.04999999999988
## end
#4521, 23:
0.4, -93.04999999999988
## end
#4523, 38:
11.499999999999998, 115.34999999999998
## end
#4526, 23:
0.1, -96.74999999999994
## end
#4528, 38:
11.499999999999998, 115.34999999999998
## end
#4531, 23:
0.1, -97.84999999999994
## end
#4533, 38:
11.499999999999998, 115.34999999999998
## end
#4536, 23:
0.2, -96.69999999999993
## end
#4538, 38:
11.499999999999998, 115.34999999999998
## end
#4541, 24:
0.1, -104.04999999999993
## end
#4543, 38:
11.499999999999998, 115.34999999999998
## end
#4546, 24:
0.1, -105.14999999999992
## end
#4548, 38:
11.499999999999998, 115.34999999999998
## end
#4551, 23:
0.2, -99.04999999999993
## end
#4555, 24:
0.2, -100.44999999999992
## end
#4557, 38:
11.499999999999998, 115.34999999999998
## end
#4560, 24:
0.2, -101.54999999999991
## end
#4562, 38:
11.499999999999998, 115.34999999999998
## end
#4565, 40:
0.30000000000000004, -100.39999999999992
## end
#4567, 38:
11.499999999999998, 115.34999999999998
## end
#4570, 39:
2.5000000000000004, -100.34999999999991
## end
#4574, 24:
0.4, -100.34999999999991
## end
#4576, 38:
11.499999999999998, 115.34999999999998
## end
#4577, 38:
11.499999999999998, 115.34999999999998
## end
#4580, 24:
0.2, -102.79999999999991
## end
#4582, 38:
11.499999999999998, 115.34999999999998
## end
#4585, 23:
0.2, -103.8999999999999
## end
#4587, 38:
11.499999999999998, 115.34999999999998
## end
#4590, 39:
0.30000000000000004, -102.7499999999999
## end
#4592, 38:
11.499999999999998, 115.34999999999998
## end
#4593, 38:
11.499999999999998, 115.34999999999998
## end
#4596, 24:
0.1, -107.74999999999991
## end
#4598, 38:
11.499999999999998, 115.34999999999998
## end
#4601, 24:
0.1, -108.84999999999991
## end
#4603, 38:
11.499999999999998, 115.34999999999998
## end
#4606, 24:
0.2, -106.34999999999991
## end
#4610, 23:
0.2, -107.6999999999999
## end
#4612, 38:
11.499999999999998, 115.34999999999998
## end
#4613, 38:
11.499999999999998, 115.34999999999998
## end
#4616, 39:
0.30000000000000004, -107.5499999999999
## end
#4618, 38:
11.499999999999998, 115.34999999999998
## end
#4619, 38:
11.499999999999998, 115.34999999999998
## end
#4620, 38:
11.499999999999998, 115.34999999999998
## end
#4623, 24:
0.1, -110.19999999999999
## end
#4625, 38:
11.499999999999998, 115.34999999999998
## end
#4626, 4:
4818
## end
#4628, 4:
4630
## end
#4630, 4:
4641
## end
#4632, 4:
4830
## end
#4635, 222:
Nini, 打开词典的条目(节点)
+[修改天使]

代码内容:...
代码结构:...
输出代码:...
+[设置结构](,代码结构)
+[新建阅读窗口](,代码内容)

将代码内容解析为代码结构
在示意图中, 将代码结构显示为程序流程图
按照"Python", 将代码结构转换为输出代码


+[显示星图](,代码结构)

示意图:...
+[显示PPT场景](,示意图)

代码结构=>的(代码结构,块)=>+[消息窗口](,块)




## end
#4637, 76:

a=1
for i in range(4):
    if a>1:
        a=a+1
    else:
        a=a-1



## end
#4639, 299:
起点#0""(,块#1)
块#1"a=1
"(,)
块#2""(,)
然后#3""(块#1,块#2)
块#4""(,)
for#5"range(4)"(块#2,块#4)
变量#6"i"(for#5,)
块#7"a=a+1
"(,)
if#8"a>1"(块#4,块#7)
eof#9""(,)
然后#10""(块#7,eof#9)
块#11"a=a-1
"(,)
else#12""(if#8,块#11)
eof#13""(,)
然后#14""(块#11,eof#13)
eof#15""(,)
然后#16""(块#4,eof#15)
eof#17""(,)
然后#18""(块#2,eof#17)

## end
#4652, 23:
4.4, 1.3000000000000003
## end
#4653, 23:
4.4, 1.3000000000000003
## end
#4654, 23:
4.4, 1.3000000000000003
## end
#4655, 23:
4.4, 1.3000000000000003
## end
#4656, 23:
4.4, 1.3000000000000003
## end
#4657, 23:
4.4, 1.3000000000000003
## end
#4659, 3:
2,1
## end
#4661, 4:
a=1

## end
#4663, 3:
2,1
## end
#4665, 6:
a=a+1

## end
#4666, 23:
2.1, 1.1500000000000001
## end
#4669, 3:
2,1
## end
#4671, 6:
a=a-1

## end
#4672, 23:
2.1, 1.1500000000000001
## end
#4676, 2:
if
## end
#4677, 23:
4.4, 1.1500000000000001
## end
#4678, 3:
for
## end
#4681, 23:
4.5, 1.4000000000000004
## end
#4682, 22:
4.5, 2.650000000000001
## end
#4686, 24:
0.0, -1.5000000000000004
## end
#4691, 4:
0, 0
## end
#4692, 22:
4.5, 2.650000000000001
## end
#4695, 24:
0.1, -1.3500000000000003
## end
#4697, 22:
4.5, 2.650000000000001
## end
#4700, 39:
2.3000000000000003, -1.3000000000000003
## end
#4704, 24:
0.2, -1.3000000000000003
## end
#4706, 22:
4.5, 2.650000000000001
## end
#4707, 22:
4.5, 2.650000000000001
## end
#4709, 73:
a=1
for i in range(4):
    if a>1:
        a=a+1
    else:
        a=a-1

## end
#4710, 61:
"""
记住"Python"

"""

import re
ans=re.sub('\s*$','',text1)



## end
#4712, 145:
"""
P代码:...

"""

+去结尾(,_文本)->+[del](,+去结尾)...
->的(去结尾,P代码)...

->+[python](Python,_文本)->+[code](+[python],P代码)...
->+[.]"text1"(+[python],_文本)


## end
#4713, 52:
"""


"""

ans='    '+text.replace('\n','\n    ')



## end
#4715, 147:
"""
P代码:...

"""

+增加缩进(,_文本)->+[del](,+增加缩进)...
->的(增加缩进,P代码)...

->+[python](Python,_文本)->+[code](+[python],P代码)...
->+[.]"text"(+[python],_文本)


## end
#4716, 27:

else if(%条件) {
%语句
}
%elif
## end
#4718, 837:
"""
代码模板:...
P模板:...
JS模板:...
M模板:...

Nini, 打开动作(库)

"""

+elif(elif,_代码)->+[del](,+elif)...
->的(elif#0,代码模板)...
->的(elif#0,P模板)->的(elif#0,JS模板)->的(elif#0,M模板)...

->记忆->[]{
    []:->[==]"Javascript"(,记忆)->+[修改内容](JS模板,代码模板),
    ->[==]"Python"(,记忆)->+[修改内容](P模板,代码模板),
    ->[==]"Matlab"(,记忆)->+[修改内容](M模板,代码模板),
    ->+[修改内容](P模板,代码模板)
}...

->elif(,块#0)...
->+[结构转代码]"程序"(,+[做]#0)->+[做]#0(块#0,+语句#0)...
->+[结构转代码]"增加缩进"(,+[做])->+[做](,+语句#0)...
->+[结构转代码]"去结尾"(,+[做]#01)->+[做]#01(,+语句#0)...
    ->+[结构转代码]"运算"(,+[做]#02)->+[做]#02(elif,+条件)...

->+elif#2->[]{
    []:->elif#1(elif,块#1)->块#1->[]{[]=>[==](,elif#1)}...
        ->+[结构转代码]"elif"(,+[做]#1)->+[做]#1(elif#1,+elif#2),
    ->[]
}...

->+[模板文本](代码模板,_代码)...
->+[.](+[模板文本],+语句#0)->+[del](,+语句#0)...
->+[.](+[模板文本],+elif#2)->+[del](,+elif#2)...
->+[.](+[模板文本],+条件)->+[del](,+条件)



## end
#4719, 524:
"""
+[P函数](,P代码)

记住"Python"

code_text='!=None) None'
print(ans)

"""

import re
text1=re.sub('\n\s*\n','\n\n',code_text)
text1=re.sub('\n',';\n',text1)
text1=re.sub('\n;','\n',text1)

text1=re.sub('None','\'\'',text1)
text1=re.sub('self',"this",text1)

text1=re.sub(' or '," | ",text1)
text1=re.sub(' and '," & ",text1)

text1=re.sub('append','push',text1)
text1=re.sub('False','false',text1)
text1=re.sub('True','true',text1)

text1=re.sub('==\[\]','.length==0',text1)
text1=re.sub('!=\[\]','.length!=0',text1)

ans=text1
## end
#4721, 370:
"""
P代码:...
P转换:...
JS转换:...

"""

+运算(_块,_代码)->+[del](,+运算)...
->的(运算,P代码)...
->的(运算,P转换)->的(运算,JS转换)...

->记忆->[]{
    []:->[==]"Javascript"(,记忆)->+[修改内容](JS转换,P代码),
    ->[==]"Python"(,记忆)->+[修改内容](P转换,P代码),
    ->[==]"Matlab"(,记忆)->+[修改内容](JS转换,P代码),
    ->+[修改内容](P转换,P代码)
}...

->+[python](Python,_代码)->+[code](+[python],P代码)...
->+[.]"code_text"(+[python],_块)




## end
#4722, 48:
for i=1:length(%list)
    %变量=%list(i);
%语句
end

## end
#4724, 661:
"""
代码模板:...
P模板:...
JS模板:...
M模板:...

"""

+for(块,_代码)->+[del](,+for)...
->的(for#0,代码模板)...
->的(for#0,P模板)->的(for#0,JS模板)->的(for#0,M模板)...

->记忆->[]{
    []:->[==]"Javascript"(,记忆)->+[修改内容](JS模板,代码模板),
    ->[==]"Python"(,记忆)->+[修改内容](P模板,代码模板),
    ->[==]"Matlab"(,记忆)->+[修改内容](M模板,代码模板),
    ->+[修改内容](P模板,代码模板)
}...

->for(块,块#0)->变量(for,)...
->+[结构转代码]"程序"(,+[做]#0)->+[做]#0(块#0,+语句#0)...
->+[结构转代码]"增加缩进"(,+[做])->+[做](,+语句#0)...
->+[结构转代码]"去结尾"(,+[做]#01)->+[做]#01(,+语句#0)...
    ->+[结构转代码]"运算"(,+[做]#02)->+[做]#02(for,+list)...

->+[模板文本](代码模板,_代码)...
->+[.](+[模板文本],+语句#0)->+[del](,+语句#0)...
->+[.](+[模板文本],+list)->+[del](,+list)...
->+[.](+[模板文本],变量)





## end
#4725, 19:

while(%条件) {
%语句
}
## end
#4727, 639:
"""
代码模板:...
P模板:...
JS模板:...
M模板:...

"""

+while(块,_代码)->+[del](,+while)...
->的(while#0,代码模板)...
->的(while#0,P模板)->的(while#0,JS模板)->的(while#0,M模板)...

->记忆->[]{
    []:->[==]"Javascript"(,记忆)->+[修改内容](JS模板,代码模板),
    ->[==]"Python"(,记忆)->+[修改内容](P模板,代码模板),
    ->[==]"Matlab"(,记忆)->+[修改内容](M模板,代码模板),
    ->+[修改内容](P模板,代码模板)
}...

->while(块,块#0)...
->+[结构转代码]"程序"(,+[做]#0)->+[做]#0(块#0,+语句#0)...
->+[结构转代码]"增加缩进"(,+[做])->+[做](,+语句#0)...
->+[结构转代码]"去结尾"(,+[做]#01)->+[做]#01(,+语句#0)...
    ->+[结构转代码]"运算"(,+[做]#02)->+[做]#02(while,+条件)...

->+[模板文本](代码模板,_代码)...
->+[.](+[模板文本],+语句#0)->+[del](,+语句#0)...
->+[.](+[模板文本],+条件)->+[del](,+条件)





## end
#4728, 31:

try {
%语句0
} catch(e) {
%语句1
}
## end
#4730, 684:
"""
代码模板:...
P模板:...
JS模板:...

"""

+try(块,_代码)->+[del](,+try)...
->的(try#0,代码模板)...
->的(try#0,P模板)->的(try#0,JS模板)...

->记忆->[]{
    []:->[==]"Javascript"(,记忆)->+[修改内容](JS模板,代码模板),
    ->[==]"Python"(,记忆)->+[修改内容](P模板,代码模板),
    ->+[修改内容](P模板,代码模板)
}...

->try(块,块#0)...
->+[结构转代码]"程序"(,+[做]#0)->+[做]#0(块#0,+语句0)...
    ->+[结构转代码]"增加缩进"(,+[做]#01)->+[做]#01(,+语句0)...
    ->+[结构转代码]"去结尾"(,+[做]#02)->+[做]#02(,+语句0)...

->except(try,块#1)...
->+[结构转代码]"程序"(,+[做]#1)->+[做]#1(块#1,+语句1)...
    ->+[结构转代码]"增加缩进"(,+[做]#10)->+[做]#10(,+语句1)...
    ->+[结构转代码]"去结尾"(,+[做]#11)->+[做]#11(,+语句1)...

->+[模板文本](代码模板,_代码)...
->+[.](+[模板文本],+语句0)->+[del](,+语句0)...
->+[.](+[模板文本],+语句1)->+[del](,+语句1)





## end
#4731, 21:

class %class {
%语句
}
## end
#4733, 507:
"""
代码模板:...
P模板:...
JS模板:...

"""

+class(块,_代码)->+[del](,+class)...
->的(class#0,代码模板)...
->的(class#0,P模板)->的(class#0,JS模板)...

->记忆->[]{
    []:->[==]"Javascript"(,记忆)->+[修改内容](JS模板,代码模板),
    ->[==]"Python"(,记忆)->+[修改内容](P模板,代码模板),
    ->+[修改内容](P模板,代码模板)
}...

->class(块,块#0)...
->+[结构转代码]"程序"(,+[做]#0)->+[做]#0(块#0,+语句#0)...
->+[结构转代码]"增加缩进"(,+[做])->+[做](,+语句#0)...
->+[结构转代码]"去结尾"(,+[做]#01)->+[做]#01(,+语句#0)...

->+[模板文本](代码模板,_代码)...
->+[.](+[模板文本],+语句#0)->+[del](,+语句#0)...
->+[.](+[模板文本],class)





## end
#4734, 429:
"""
记住"Python"
Nini, 打开动词(库)
+[P函数](,P代码)

"""

import re
result=re.match(r'([\w_]*) *\((.*)\)',text_func)

func_name=result.group(1)
func_vars=result.group(2)

if len(func_vars)>3 and func_vars[0:4]=='self':
    if func_name=='__init__':
        func_name='constructor'
    func_vars=re.sub('self *,?','',func_vars)

    ans='{0}({1})'.format(func_name,func_vars)
else:
    ans='function {0}({1})'.format(func_name,func_vars)



## end
#4735, 14:

%func {
%语句
}
## end
#4738, 690:
"""
代码模板:...
P模板:...
JS模板:...
M模板:...

P代码:...

"""

+def(块,_代码)->+[del](,+def)...
->的(def#0,P代码)...
->的(def#0,代码模板)...
->的(def#0,P模板)->的(def#0,JS模板)->的(def#0,M模板)...

->记忆->[]{
    []:->[==]"Javascript"(,记忆)->+[修改内容](JS模板,代码模板),
    ->[==]"Python"(,记忆)->+[修改内容](P模板,代码模板),
    ->[==]"Matlab"(,记忆)->+[修改内容](M模板,代码模板),
    ->+[修改内容](P模板,代码模板)
}...

->func(块,块#0)...
->+[结构转代码]"程序"(,+[做]#0)->+[做]#0(块#0,+语句#0)...
->+[结构转代码]"增加缩进"(,+[做])->+[做](,+语句#0)...
->+[结构转代码]"去结尾"(,+[做]#01)->+[做]#01(,+语句#0)...

->+[python](Python,+[临时文本])->+[code](+[python],P代码)...
->+[.]"text_func"(+[python],func)...

->+[模板文本](代码模板,_代码)...
->+[.](+[模板文本],+语句#0)->+[del](,+语句#0)...
->+[.]"func"(+[模板文本],+[临时文本])





## end
#4739, 28:
if(%条件) {
%语句
}
%elif
%else

## end
#4740, 13:
else {
%语句
}

## end
#4743, 1293:
"""
代码模板:...
else模板:...

P模板1:...
P模板2:...
JS模板1:...
JS模板2:...
M模板1:...
M模板2:...


"""

+if(块,_代码)->+[del](,+if)...
->的(if#0,代码模板)->的(if#0,else模板)...
->的(if#0,M模板1)->的(if#0,M模板2)...
->的(if#0,P模板1)->的(if#0,P模板2)->的(if#0,JS模板1)->的(if#0,JS模板2)...

->记忆->[]{
    []:->[==]"Javascript"(,记忆)...
        ->+[修改内容](JS模板1,代码模板)->+[修改内容](JS模板2,else模板),
    ->[==]"Python"(,记忆)...
        ->+[修改内容](P模板1,代码模板)->+[修改内容](P模板2,else模板),
    ->[==]"Matlab"(,记忆)...
        ->+[修改内容](M模板1,代码模板)->+[修改内容](M模板2,else模板),
    ->+[修改内容](P模板1,代码模板)->+[修改内容](P模板2,else模板)
}...

->if(块,块#0)...
->+[结构转代码]"程序"(,+[做]#0)->+[做]#0(块#0,+语句#0)...
->+[结构转代码]"增加缩进"(,+[做])->+[做](,+语句#0)...
->+[结构转代码]"去结尾"(,+[做]#01)->+[做]#01(,+语句#0)...
    ->+[结构转代码]"运算"(,+[做]#02)->+[做]#02(if,+条件)...

->+elif->[]{
    []:->elif(if,)...
        ->+[结构转代码]"elif"(,+[做]#1)->+[做]#1(elif,+elif),
    ->[]
}...

->+else->[]{
    []:->else(if,块#2)->块#2(,)...
        ->+[结构转代码]"程序"(,+[做]#2)->+[做]#2(块#2,+语句#2)...
            ->+[结构转代码]"增加缩进"(,+[做]#3)->+[做]#3(,+语句#2)...
        ->+[模板文本](else模板,+else)...
        ->+[.](+[模板文本],+语句#2)->+[del](,+语句#2),
    ->[]
}...

->+[模板文本](代码模板,_代码)...
->+[.](+[模板文本],+语句#0)->+[del](,+语句#0)...
->+[.](+[模板文本],+elif)->+[del](,+elif)...
->+[.](+[模板文本],+else)->+[del](,+else)...
->+[.](+[模板文本],+条件)->+[del](,+条件)



## end
#4744, 423:
"""


"""

+语句(块,_代码)->+[del](,+语句)...

->[]:
    ->if(块,)->+[结构转代码]"if"(,+[做]#0)->+[做]#0(块,_代码),
    ->func(块,)->+[结构转代码]"def"(,+[做]#1)->+[做]#1(块,_代码),
    ->while(块,)->+[结构转代码]"while"(,+[做]#2)->+[做]#2(块,_代码),
    ->for(块,)->+[结构转代码]"for"(,+[做]#3)->+[做]#3(块,_代码),
    ->try(块,)->+[结构转代码]"try"(,+[做]#4)->+[做]#4(块,_代码),
    ->class(块,)->+[结构转代码]"class"(,+[做]#5)->+[做]#5(块,_代码),
    ->+[结构转代码]"运算"(,+[做]#6)->+[做]#6(块,_代码)




## end
#4745, 326:
"""


"""

+程序(块,_代码)->+[del](,+程序)...

->+[结构转代码]"语句"(,+[做])->+[做](块,_代码)...
    ->+[结构转代码]"去结尾"(,+[做]#01)->+[做]#01(,_代码)...

->[]{
    []:->然后(块,块#1)->块#1(,)...
        ->+[结构转代码]"程序"(,+[做]#1)->+[做]#1(块#1,+[临时文本])...
            ->+[结构转代码]"去结尾"(,+[做]#11)->+[做]#11(,+[临时文本])...
        ->+[增加内容]"
"(+[临时文本],_代码),
    ->[]
}


## end
#4758, 418:
Nini, 打开编程语言parser(文件)


增加缩进:...
去结尾:...
去结尾的"增加缩进"替换为"去结尾"

程序:...
语句:...
语句的"_结构,块"替换为"块,_代码"

class的"结构转JS代码"替换为"结构转代码"

if:...
elif:...
+[新建阅读窗口](,if)

def:...
(有一个self or this的问题)
class:...
+[新建阅读窗口](,class)

运算的"收集程序块尺寸"替换为"结构转JS代码"

try:...
while:...
for:...

运算:...

结构转JS代码的"收集程序块尺寸"替换为"结构转JS代码"



库=>的(库,_块)=>+[替换](+[临时文本]#2,+[临时文本]#1)->+在(+[替换],_块)->+[del](,+在)...
->+[临时文本]#1"结构转JS代码"->+[临时文本]#2"结构转代码"


## end
#4760, 142:
"""
库:...
+[新建阅读窗口](,库)

"""

+结构转代码(,做)->+[del](,+结构转代码)...
->的(结构转代码,库)->的(库,_段落)...
->[标题](_段落,)->[==](+结构转代码,[标题])...
    ->+code(做,_段落)


## end
#4763, 24:
if %条件:
%语句
%elif
%else

## end
#4765, 10:
else:
%语句

## end
#4767, 28:
if(%条件) {
%语句
}
%elif
%else

## end
#4769, 13:
else {
%语句
}

## end
#4773, 21:
elif %条件:
%语句

%elif

## end
#4775, 27:
else if(%条件) {
%语句
}
%elif

## end
#4777, 14:
%func {
%语句
}

## end
#4779, 11:
%func:
%语句

## end
#4781, 18:
class %class:
%语句

## end
#4783, 21:
class %class {
%语句
}

## end
#4785, 23:
try:
%语句0
except:
%语句1

## end
#4787, 30:
try {
%语句0
} catch(e) {
%语句1
}
## end
#4789, 16:
while %条件:
%语句


## end
#4791, 18:
while(%条件) {
%语句
}
## end
#4793, 22:
for %变量 in %list:
%语句

## end
#4795, 62:
for(var i=0;i<%list.length;i++) {
    var %变量=%list[i];
%语句
}

## end
#4797, 524:
"""
+[P函数](,P代码)

记住"Python"

code_text='!=None) None'
print(ans)

"""

import re
text1=re.sub('\n\s*\n','\n\n',code_text)
text1=re.sub('\n',';\n',text1)
text1=re.sub('\n;','\n',text1)

text1=re.sub('None','\'\'',text1)
text1=re.sub('self',"this",text1)

text1=re.sub(' or '," | ",text1)
text1=re.sub(' and '," & ",text1)

text1=re.sub('append','push',text1)
text1=re.sub('False','false',text1)
text1=re.sub('True','true',text1)

text1=re.sub('==\[\]','.length==0',text1)
text1=re.sub('!=\[\]','.length!=0',text1)

ans=text1
## end
#4799, 15:
ans=code_text


## end
#4801, 22:
elseif %条件
%语句

%elif

## end
#4803, 14:
%func
%语句
end

## end
#4805, 20:
while (%条件)
%语句
end

## end
#4807, 48:
for i=1:length(%list)
    %变量=%list(i);
%语句
end

## end
#4809, 27:
if %条件
%语句
%elif
%else
end

## end
#4811, 9:
else
%语句

## end
#4812, 4:
4822
## end
#4816, 57:
Nini, 打开词典(文件)

python:...
C:...
Matlab:...
Javacript:...
## end
#4818, 9:
规则:...



## end
#4820, 100:
program:[code]
code:[block] [code]?
block:[cond]| [loop]| [try]| [func]| [class]| [normal]
func:def 
## end
#4822, 261:
参考::

保存版本:...

规则:...
代码:...
将代码的"\) \*"替换为"\\) *"
将规则的"\\\)"替换为"\\\)"
+[召唤星辰]"生成Parser代码_快速"(规则,代码)
+[召唤星辰]"生成Parser代码"(规则,代码)
+[新建阅读窗口](,规则)
+[新建阅读窗口](,代码)

测试代码:...
结构:...
+[分析程序结构](测试代码,结构)
+[删除结构](,结构)->+[分析程序结构](测试代码,结构)->+[显示星图](,结构)
+[新建阅读窗口](,测试代码)



## end
#4824, 1102:
program:[code]
code:[block]{块} [code]?
block:\\s* ([cond]| [loop]| [class]| [func]| [comm]| [normal]) \\s*
class:class{类} \ * [name]{类名} (: [name]){父类}? \ * (\{ [codeCl] \})? ;?
codeCl:\\s* public\|private\|protected{成员类型} \ *:\\s* [normal] [codeCl]?
func:[func1]| [func2]
func1:[type]{输出类型} [field]{命名空间}? [name]{函数} \\\( [input]{输入变量}? \\\) [parent]{父函数}? (;| \\s*\{ [code]{运算}? \})
func2:[field]{命名空间} [name]{函数} \\\( [input]{输入变量}? \\\) [parent]{父函数}? (;| \\s*\{ [code]{运算}? \})
cond:if{如果} \ *\\\(\ * [cmd]{条件} \ *\\\)\\s* ([cmd] ;| \{ [code] \}){运算} \\s* [cond2]?
cond2:else\  [cond]| else\ *\{ [code]{运算} \}
loop:[loop1]| [loop2]| [loop3]
loop1:for{循环} \ *\\\( [cmd]{条件} \\\)\ *\{ [code]{运算} \}
loop2:while{循环} \ *\\\( [cmd]{条件} \\\)\ *\{ [code]{运算} \}
loop3:do{循环} \ *\{ [code]{运算} \}\* while\ *\\\( [cmd]{条件} \\\)\ *;
comm://.*\\n{comm} (\\s* [comm])?
comm1:/\\* [.\\s]* \\*/{comm}
normal:\\s* [cmd] ;\\s*\\n [normal]?
type:[name] \ *
field:[name] \\s*::\\s*
parent:\\s*:\\s* [name] \\s*\\\( [input]? \\\)\\s*
input:\ * [cmd] \ * (,\ * [input])?
name:\[\\w\\d_\\~\]+{name}
cmd:\[\\*\\w\]+{cmd}
## end
#4826, 18795:
"""
+[P函数](,代码)
print('2'.replace('2','333'))
pt2

"""

import re
from body.bone import NetP
from tools import tools_basic

def word_pat_token(code,i,pat):
    text=''

#    pat=pat.replace('\\','\\\\')
    a=re.match(pat,code[i:])
    if a==None:
        state=False
    else:
        di=a.span()[1]
        output_txt=code[i:i+di]
        i+=di
        state=True
        text=output_txt
    
    return [state,i,text]


def parser_token_cmd(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'\w+')
    
    list_pt+=list_new

    if state==False:
        print("cmd:",state)
        return [False,i0,None]
    else:
        print("cmd:",state,pt0.info())
        return [True,i,pt0]

def parser_token_name(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'\w+')
    
    list_pt+=list_new

    if state==False:
        print("name:",state)
        return [False,i0,None]
    else:
        print("name:",state,pt0.info())
        return [True,i,pt0]

def parser_token_input(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r' *')
    if state==True:
        [state,i,pt0]=parser_token_cmd(code,i,list_new)
        if state==True:
            [state,i,text]=word_pat_token(code,i,r' *')
            if state==True:
                i1=i
                state1=True
                list_new1=list_new[:]
                # list_new=[]
                [state,i,text]=word_pat_token(code,i,r', *')
                if state==True:
                    [state,i,pt1]=parser_token_cmd(code,i,list_new)
                    if state==True:
                        pt1.con(pt0,0)
                    else:
                        pt1=pt0
                
                if state==False:
                    i=i1
                    list_new=list_new1
                    state=True
                    state1=False
                # else:
                #     list_new=list_new1+list_new
    
    list_pt+=list_new

    if state==False:
        print("input:",state)
        return [False,i0,None]
    else:
        print("input:",state,pt0.info())
        return [True,i,pt0]

def parser_token_field(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,pt0]=parser_token_name(code,i,list_new)
    if state==True:
        [state,i,text]=word_pat_token(code,i,r' *:: *')
    
    list_pt+=list_new

    if state==False:
        print("field:",state)
        return [False,i0,None]
    else:
        print("field:",state,pt0.info())
        return [True,i,pt0]

def parser_token_type(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,pt0]=parser_token_name(code,i,list_new)
    if state==True:
        [state,i,text]=word_pat_token(code,i,r' *')
    
    list_pt+=list_new

    if state==False:
        print("type:",state)
        return [False,i0,None]
    else:
        print("type:",state,pt0.info())
        return [True,i,pt0]

def parser_token_normal(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'\s*')
    if state==True:
        [state,i,pt0]=parser_token_cmd(code,i,list_new)
        if state==True:
            [state,i,text]=word_pat_token(code,i,r';\s*n')
            if state==True:
                i1=i
                state1=True
                list_new1=list_new[:]
                # list_new=[]
                [state,i,pt1]=parser_token_normal(code,i,list_new)
                if state==True:
                    pt1.con(pt0,0)
                else:
                    pt1=pt0
                if state==False:
                    i=i1
                    list_new=list_new1
                    state=True
                    state1=False
                # else:
                #     list_new=list_new1+list_new
    
    list_pt+=list_new

    if state==False:
        print("normal:",state)
        return [False,i0,None]
    else:
        print("normal:",state,pt0.info())
        return [True,i,pt0]

def parser_token_comm(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'/\*')
    if state==True:
        [state,i,text]=word_pat_token(code,i,r'.*')
        if state==True:
            [state,i,text]=word_pat_token(code,i,r'\*/')
    
    list_pt+=list_new

    if state==False:
        print("comm:",state)
        return [False,i0,None]
    else:
        print("comm:",state,pt0.info())
        return [True,i,pt0]

def parser_token_loop3(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'do *{')
    if state==True:
        [state,i,pt0]=parser_token_block(code,i,list_new)
        if state==True:
            [state,i,text]=word_pat_token(code,i,r'}*')
            if state==True:
                [state,i,text]=word_pat_token(code,i,r'while *\(')
                if state==True:
                    [state,i,pt1]=parser_token_cmd(code,i,list_new)
                    if state==True:
                        pt1.con(pt0,0)
                    else:
                        pt1=pt0
                    if state==True:
                        [state,i,text]=word_pat_token(code,i,r'\) *;')
    
    list_pt+=list_new

    if state==False:
        print("loop3:",state)
        return [False,i0,None]
    else:
        print("loop3:",state,pt0.info())
        return [True,i,pt0]

def parser_token_loop2(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'while *\(')
    if state==True:
        [state,i,pt0]=parser_token_cmd(code,i,list_new)
        if state==True:
            [state,i,text]=word_pat_token(code,i,r'\) *{')
            if state==True:
                [state,i,pt1]=parser_token_block(code,i,list_new)
                if state==True:
                    pt1.con(pt0,0)
                else:
                    pt1=pt0
                if state==True:
                    [state,i,text]=word_pat_token(code,i,r'}')
    
    list_pt+=list_new

    if state==False:
        print("loop2:",state)
        return [False,i0,None]
    else:
        print("loop2:",state,pt0.info())
        return [True,i,pt0]

def parser_token_loop1(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'for *\(')
    if state==True:
        [state,i,pt0]=parser_token_cmd(code,i,list_new)
        if state==True:
            [state,i,text]=word_pat_token(code,i,r'\) *{')
            if state==True:
                [state,i,pt1]=parser_token_block(code,i,list_new)
                if state==True:
                    pt1.con(pt0,0)
                else:
                    pt1=pt0
                if state==True:
                    [state,i,text]=word_pat_token(code,i,r'}')
    
    list_pt+=list_new

    if state==False:
        print("loop1:",state)
        return [False,i0,None]
    else:
        print("loop1:",state,pt0.info())
        return [True,i,pt0]

def parser_token_loop(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,pt0]=parser_token_loop1(code,i,list_new)
    if state==False:
        i=i0
        list_new=list_new0
        [state,i,pt0]=parser_token_loop2(code,i,list_new)
    if state==False:
        i=i0
        list_new=list_new0
        [state,i,pt0]=parser_token_loop3(code,i,list_new)
    
    list_pt+=list_new

    if state==False:
        print("loop:",state)
        return [False,i0,None]
    else:
        print("loop:",state,pt0.info())
        return [True,i,pt0]

def parser_token_cond2(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'else ')
    if state==True:
        [state,i,pt0]=parser_token_cond(code,i,list_new)
    if state==False:
        i=i0
        list_new=list_new0
        [state,i,text]=word_pat_token(code,i,r'else *{')
        if state==True:
            [state,i,pt0]=parser_token_block(code,i,list_new)
            if state==True:
                [state,i,text]=word_pat_token(code,i,r'}')
    
    list_pt+=list_new

    if state==False:
        print("cond2:",state)
        return [False,i0,None]
    else:
        print("cond2:",state,pt0.info())
        return [True,i,pt0]

def parser_token_cond(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'if *\( *[cmd] *\)\s*{')
    if state==True:
        [state,i,pt0]=parser_token_block(code,i,list_new)
        if state==True:
            [state,i,text]=word_pat_token(code,i,r'}\s*')
            if state==True:
                i1=i
                state1=True
                list_new1=list_new[:]
                # list_new=[]
                [state,i,pt1]=parser_token_cond2(code,i,list_new)
                if state==True:
                    pt1.con(pt0,0)
                else:
                    pt1=pt0
                if state==False:
                    i=i1
                    list_new=list_new1
                    state=True
                    state1=False
                # else:
                #     list_new=list_new1+list_new
    
    list_pt+=list_new

    if state==False:
        print("cond:",state)
        return [False,i0,None]
    else:
        print("cond:",state,pt0.info())
        return [True,i,pt0]

def parser_token_codeCl(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'\s*')
    if state==True:
        i0=i
        list_new0=list_new[:]
        [state,i,text]=word_pat_token(code,i,r'public')
        if state==False:
            i=i0
            list_new=list_new0
            [state,i,text]=word_pat_token(code,i,r'private')
        if state==False:
            i=i0
            list_new=list_new0
            [state,i,text]=word_pat_token(code,i,r'protected')
        
        if state==True:
            [state,i,text]=word_pat_token(code,i,r' *:\s*')
            if state==True:
                [state,i,pt1]=parser_token_normal(code,i,list_new)
                if state==True:
                    pt1.con(pt0,0)
                else:
                    pt1=pt0
                if state==True:
                    [state,i,text]=word_pat_token(code,i,r'\n')
                    if state==True:
                        i2=i
                        state2=True
                        list_new2=list_new[:]
                        # list_new=[]
                        [state,i,pt2]=parser_token_codeCl(code,i,list_new)
                        if state==True:
                            pt2.con(pt1,0)
                        else:
                            pt2=pt1
                        if state==False:
                            i=i2
                            list_new=list_new2
                            state=True
                            state2=False
                        # else:
                        #     list_new=list_new2+list_new
    
    list_pt+=list_new

    if state==False:
        print("codeCl:",state)
        return [False,i0,None]
    else:
        print("codeCl:",state,pt0.info())
        return [True,i,pt0]

def parser_token_class(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'class ')
    if state==True:
        [state,i,pt0]=parser_token_name(code,i,list_new)
        if state==True:
            i1=i
            state1=True
            list_new1=list_new[:]
            # list_new=[]
            [state,i,text]=word_pat_token(code,i,r':')
            if state==True:
                [state,i,pt1]=parser_token_name(code,i,list_new)
                if state==True:
                    pt1.con(pt0,0)
                else:
                    pt1=pt0
            
            if state==False:
                i=i1
                list_new=list_new1
                state=True
                state1=False
            # else:
            #     list_new=list_new1+list_new
            if state==True:
                i2=i
                list_new2=list_new[:]
                [state,i,text]=word_pat_token(code,i,r';')
                if state==False:
                    i=i2
                    list_new=list_new2
                    [state,i,text]=word_pat_token(code,i,r'{')
                    if state==True:
                        [state,i,pt2]=parser_token_codeCl(code,i,list_new)
                        if state==True:
                            pt2.con(pt1,0)
                        else:
                            pt2=pt1
                        if state==True:
                            [state,i,text]=word_pat_token(code,i,r'};')
                
            if state1==False:
                pt1=pt2
    
    list_pt+=list_new

    if state==False:
        print("class:",state)
        return [False,i0,None]
    else:
        print("class:",state,pt0.info())
        return [True,i,pt0]

def parser_token_func(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,pt0]=parser_token_type(code,i,list_new)
    if state==True:
        i1=i
        state1=True
        list_new1=list_new[:]
        # list_new=[]
        [state,i,pt1]=parser_token_field(code,i,list_new)
        if state==True:
            pt1.con(pt0,0)
        else:
            pt1=pt0
        if state==False:
            i=i1
            list_new=list_new1
            state=True
            state1=False
        # else:
        #     list_new=list_new1+list_new
        if state==True:
            [state,i,pt2]=parser_token_name(code,i,list_new)
            if state==True:
                pt2.con(pt1,0)
            else:
                pt2=pt1
            if state==True:
                [state,i,text]=word_pat_token(code,i,r'\(')
                if state==True:
                    [state,i,pt3]=parser_token_input(code,i,list_new)
                    if state==True:
                        pt3.con(pt2,0)
                    else:
                        pt3=pt2
                    if state==True:
                        [state,i,text]=word_pat_token(code,i,r'\)')
                        if state==True:
                            i4=i
                            list_new4=list_new[:]
                            [state,i,text]=word_pat_token(code,i,r';')
                            if state==False:
                                i=i4
                                list_new=list_new4
                                [state,i,text]=word_pat_token(code,i,r'{')
                                if state==True:
                                    [state,i,pt4]=parser_token_block(code,i,list_new)
                                    if state==True:
                                        pt4.con(pt3,0)
                                    else:
                                        pt4=pt3
                                    if state==True:
                                        [state,i,text]=word_pat_token(code,i,r'}')
                            
        if state1==False:
            pt1=pt2
    
    list_pt+=list_new

    if state==False:
        print("func:",state)
        return [False,i0,None]
    else:
        print("func:",state,pt0.info())
        return [True,i,pt0]

def parser_token_block(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'\s*')
    if state==True:
        i0=i
        list_new0=list_new[:]
        [state,i,pt0]=parser_token_cond(code,i,list_new)
        if state==False:
            i=i0
            list_new=list_new0
            [state,i,pt0]=parser_token_loop(code,i,list_new)
        if state==False:
            i=i0
            list_new=list_new0
            [state,i,pt0]=parser_token_func(code,i,list_new)
        if state==False:
            i=i0
            list_new=list_new0
            [state,i,pt0]=parser_token_class(code,i,list_new)
        if state==False:
            i=i0
            list_new=list_new0
            [state,i,pt0]=parser_token_normal(code,i,list_new)
        if state==False:
            i=i0
            list_new=list_new0
            [state,i,pt0]=parser_token_comm(code,i,list_new)
        
    
    list_pt+=list_new

    if state==False:
        print("block:",state)
        return [False,i0,None]
    else:
        print("block:",state,pt0.info())
        return [True,i,pt0]

def parser_token_code(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,pt0]=parser_token_block(code,i,list_new)
    if state==True:
        i1=i
        state1=True
        list_new1=list_new[:]
        # list_new=[]
        [state,i,pt1]=parser_token_code(code,i,list_new)
        if state==True:
            pt1.con(pt0,0)
        else:
            pt1=pt0
        if state==False:
            i=i1
            list_new=list_new1
            state=True
            state1=False
        # else:
        #     list_new=list_new1+list_new
    
    list_pt+=list_new

    if state==False:
        print("code:",state)
        return [False,i0,None]
    else:
        print("code:",state,pt0.info())
        return [True,i,pt0]

def parser_token_program(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,pt0]=parser_token_code(code,i,list_new)
    
    list_pt+=list_new

    if state==False:
        print("program:",state)
        return [False,i0,None]
    else:
        print("program:",state,pt0.info())
        return [True,i,pt0]


def parser_text2pts(code):
    list_pt0=[]
    [state,i,pt]=parser_token_program(code,0,list_pt0)
    list_pt=[]
    for pt in list_pt0:
        if pt!=None:
                list_pt.append(pt)
    if state==False:
        return ''
    text=tools_basic.writeStdCode([],list_pt)
    return text

#text=parser_text2pts('A:B')
#print(text)



"""
+[P函数](,代码)

"""
## end
#4828, 115:
"""


"""

+分析程序结构(_代码,_输出)->+[del](,+分析程序结构)...

->[python程序](_代码,)->+[修改内容](,_输出)->[m_text]([python程序],+[修改内容])


## end
#4830, 341:
"""
P代码(P函数):...
M程序_代码=>M程序_代码#0(M程序_代码,)=>[说]"1"

"""

+M程序_代码(_程序,)...
->的(M程序_代码,P代码)->的(P代码,函数定义)->的(P代码,默认定义)...

->[python]#3"state=True"(Python,)...
->+[code]([python]#0,函数定义)->[python]#0(Python,)...
->+[code]([python]#1,默认定义)->[python]#1(Python,)...

->+[code]([python],P代码)->+[.]"code"([python],_程序)...
->[python](Python,+M程序_代码)


## end
#4832, 212:
"""
规则:...
规则=>想(规则,)=>[说]"1"
函数定义(P函数):...
默认定义(P函数):...
+[召唤星辰]"生成Parser代码_快速"(规则,函数定义)
+[召唤星辰]"生成Parser代码"(规则,函数定义)
+[新建阅读窗口](,规则)
+[新建阅读窗口](,函数定义)
+[新建阅读窗口](,默认定义)

"""

ans=parser_text2pts(code)
state=True


## end
#4835, 28006:
"""
+[P函数](,函数定义)
print('2'.replace('2','333'))
func

"""

import re
from body.bone import NetP
from tools import tools_basic

def word_pat_token(code,i,pat):
    text=''

#    pat=pat.replace('\\','\\\\')
    a=re.match(pat,code[i:])
    if a==None:
        state=False
    else:
        di=a.span()[1]
        output_txt=code[i:i+di]
        i+=di
        state=True
        text=output_txt
    
    return [state,i,text]


def parser_token_cmd(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'[\*\w]+')
    pt0=NetP("cmd",text)
    if state==True:
        list_new.append(pt0)
    

    if state==False:
        print("cmd:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("cmd:",state,pt0.info())
        return [True,i,pt0]

def parser_token_name(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'[\w\d_\~]+')
    pt0=NetP("name",text)
    if state==True:
        list_new.append(pt0)
    

    if state==False:
        print("name:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("name:",state,pt0.info())
        return [True,i,pt0]

def parser_token_input(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r' *')
    if state==True:
        [state,i,pt0]=parser_token_name(code,i,list_new)
        if state==True:
            [state,i,text]=word_pat_token(code,i,r' *')
            if state==True:
                i1=i
                state1=True
                list_new1=list_new[:]
                # list_new=[]
                [state,i,text]=word_pat_token(code,i,r', *')
                if state==True:
                    [state,i,pt1]=parser_token_input(code,i,list_new)
                    if state==True:
                        pt1.con(pt0,0)
                    else:
                        pt1=pt0
                
                if state==False:
                    i=i1
                    list_new=list_new1
                    state=True
                    state1=False
                # else:
                #     list_new=list_new1+list_new
    

    if state==False:
        print("input:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("input:",state,pt0.info())
        return [True,i,pt0]

def parser_token_normal(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'\s*')
    if state==True:
        [state,i,pt0]=parser_token_cmd(code,i,list_new)
        if state==True:
            [state,i,text]=word_pat_token(code,i,r';\s*\n')
            if state==True:
                i1=i
                state1=True
                list_new1=list_new[:]
                # list_new=[]
                [state,i,pt1]=parser_token_normal(code,i,list_new)
                if state==True:
                    pt1.con(pt0,0)
                else:
                    pt1=pt0
                if state==False:
                    i=i1
                    list_new=list_new1
                    state=True
                    state1=False
                # else:
                #     list_new=list_new1+list_new
    

    if state==False:
        print("normal:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("normal:",state,pt0.info())
        return [True,i,pt0]

def parser_token_comm1(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'%{')
    if state==True:
        [state,i,text]=word_pat_token(code,i,r'[.\s]*')
        if state==True:
            [state,i,text]=word_pat_token(code,i,r'%}')
            pt0=NetP("comm",text)
            if state==True:
                list_new.append(pt0)
    

    if state==False:
        print("comm1:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("comm1:",state,pt0.info())
        return [True,i,pt0]

def parser_token_comm(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'%.*\n')
    pt0=NetP("comm",text)
    if state==True:
        i1=i
        state1=True
        list_new1=list_new[:]
        # list_new=[]
        [state,i,text]=word_pat_token(code,i,r'\s*')
        if state==True:
            [state,i,pt1]=parser_token_comm(code,i,list_new)
            if state==True:
                pt1.con(pt0,0)
            else:
                pt1=pt0
        
        if state==False:
            i=i1
            list_new=list_new1
            state=True
            state1=False
        # else:
        #     list_new=list_new1+list_new
    if state==True:
        list_new.append(pt0)
    

    if state==False:
        print("comm:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("comm:",state,pt0.info())
        return [True,i,pt0]

def parser_token_loop2(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'while')
    pt0=NetP("循环",text)
    if state==True:
        [state,i,text]=word_pat_token(code,i,r' *')
        if state==True:
            [state,i,pt1]=parser_token_cmd(code,i,list_new)
            if state==True:
                pt1=NetP("条件").con(0,pt1)
            if state==True:
                pt1.con(pt0,0)
            else:
                pt1=pt0
            if state==True:
                [state,i,text]=word_pat_token(code,i,r' *\n\s*')
                if state==True:
                    [state,i,pt2]=parser_token_code(code,i,list_new)
                    if state==True:
                        pt2=NetP("运算").con(0,pt2)
                    if state==True:
                        pt2.con(pt1,0)
                    else:
                        pt2=pt1
                    if state==True:
                        [state,i,text]=word_pat_token(code,i,r'\s*end')
                    if state==True:
                        list_new.append(pt2)
            if state==True:
                list_new.append(pt1)
    if state==True:
        list_new.append(pt0)
    

    if state==False:
        print("loop2:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("loop2:",state,pt0.info())
        return [True,i,pt0]

def parser_token_loop1(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'for')
    pt0=NetP("循环",text)
    if state==True:
        [state,i,text]=word_pat_token(code,i,r' *')
        if state==True:
            [state,i,pt1]=parser_token_cmd(code,i,list_new)
            if state==True:
                pt1=NetP("条件").con(0,pt1)
            if state==True:
                pt1.con(pt0,0)
            else:
                pt1=pt0
            if state==True:
                [state,i,text]=word_pat_token(code,i,r' *\n\s*')
                if state==True:
                    [state,i,pt2]=parser_token_code(code,i,list_new)
                    if state==True:
                        pt2=NetP("运算").con(0,pt2)
                    if state==True:
                        pt2.con(pt1,0)
                    else:
                        pt2=pt1
                    if state==True:
                        [state,i,text]=word_pat_token(code,i,r'\s*end')
                    if state==True:
                        list_new.append(pt2)
            if state==True:
                list_new.append(pt1)
    if state==True:
        list_new.append(pt0)
    

    if state==False:
        print("loop1:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("loop1:",state,pt0.info())
        return [True,i,pt0]

def parser_token_loop(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,pt0]=parser_token_loop1(code,i,list_new)
    if state==False:
        i=i0
        list_new=list_new0
        [state,i,pt0]=parser_token_loop2(code,i,list_new)
    

    if state==False:
        print("loop:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("loop:",state,pt0.info())
        return [True,i,pt0]

def parser_token_cond2(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'else')
    if state==True:
        [state,i,pt0]=parser_token_cond(code,i,list_new)
    if state==False:
        i=i0
        list_new=list_new0
        [state,i,text]=word_pat_token(code,i,r'else *\n\s*')
        if state==True:
            [state,i,pt0]=parser_token_code(code,i,list_new)
            if state==True:
                pt0=NetP("运算").con(0,pt0)
            if state==True:
                [state,i,text]=word_pat_token(code,i,r'\s*end')
            if state==True:
                list_new.append(pt0)
    

    if state==False:
        print("cond2:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("cond2:",state,pt0.info())
        return [True,i,pt0]

def parser_token_cond(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'if')
    pt0=NetP("如果",text)
    if state==True:
        [state,i,text]=word_pat_token(code,i,r' *')
        if state==True:
            [state,i,pt1]=parser_token_cmd(code,i,list_new)
            if state==True:
                pt1=NetP("条件").con(0,pt1)
            if state==True:
                pt1.con(pt0,0)
            else:
                pt1=pt0
            if state==True:
                [state,i,text]=word_pat_token(code,i,r' *\n\s*')
                if state==True:
                    [state,i,pt2]=parser_token_code(code,i,list_new)
                    if state==True:
                        pt2=NetP("运算").con(0,pt2)
                    if state==True:
                        pt2.con(pt1,0)
                    else:
                        pt2=pt1
                    if state==True:
                        [state,i,text]=word_pat_token(code,i,r'\s*')
                        if state==True:
                            i3=i
                            list_new3=list_new[:]
                            [state,i,pt3]=parser_token_cond2(code,i,list_new)
                            if state==True:
                                pt3.con(pt2,0)
                            else:
                                pt3=pt2
                            if state==False:
                                i=i3
                                list_new=list_new3
                                [state,i,text]=word_pat_token(code,i,r'end')
                            
                    if state==True:
                        list_new.append(pt2)
            if state==True:
                list_new.append(pt1)
    if state==True:
        list_new.append(pt0)
    

    if state==False:
        print("cond:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("cond:",state,pt0.info())
        return [True,i,pt0]

def parser_token_func2(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'function +\[')
    if state==True:
        [state,i,pt0]=parser_token_input(code,i,list_new)
        if state==True:
            pt0=NetP("输出变量").con(0,pt0)
        if state==True:
            [state,i,text]=word_pat_token(code,i,r'\]=')
            if state==True:
                [state,i,pt1]=parser_token_name(code,i,list_new)
                if state==True:
                    pt1=NetP("函数名").con(0,pt1)
                if state==True:
                    pt1.con(pt0,0)
                else:
                    pt1=pt0
                if state==True:
                    [state,i,text]=word_pat_token(code,i,r'\(')
                    if state==True:
                        i2=i
                        state2=True
                        list_new2=list_new[:]
                        # list_new=[]
                        [state,i,pt2]=parser_token_input(code,i,list_new)
                        if state==True:
                            pt2=NetP("输入变量").con(0,pt2)
                        if state==True:
                            pt2.con(pt1,0)
                        else:
                            pt2=pt1
                        if state==False:
                            i=i2
                            list_new=list_new2
                            state=True
                            state2=False
                        # else:
                        #     list_new=list_new2+list_new
                            pt2=pt1
                        if state==True:
                            [state,i,text]=word_pat_token(code,i,r'\)')
                            if state==True:
                                i3=i
                                state3=True
                                list_new3=list_new[:]
                                # list_new=[]
                                [state,i,pt3]=parser_token_code(code,i,list_new)
                                if state==True:
                                    pt3=NetP("运算").con(0,pt3)
                                if state==True:
                                    pt3.con(pt2,0)
                                else:
                                    pt3=pt2
                                if state==False:
                                    i=i3
                                    list_new=list_new3
                                    state=True
                                    state3=False
                                # else:
                                #     list_new=list_new3+list_new
                                    pt3=pt2
                                if state==True:
                                    [state,i,text]=word_pat_token(code,i,r'end')
                                #if state3==False:
                                #    try:
                                #        pt3=pt4
                                #    except:
                                #        pt3=None
                                if state3==True:
                                    list_new.append(pt3)
                        #if state2==False:
                        #    try:
                        #        pt2=pt3
                        #    except:
                        #        pt2=None
                        if state2==True:
                            list_new.append(pt2)
                if state==True:
                    list_new.append(pt1)
        if state==True:
            list_new.append(pt0)
    

    if state==False:
        print("func2:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("func2:",state,pt0.info())
        return [True,i,pt0]

def parser_token_func1(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'function +')
    if state==True:
        i0=i
        state0=True
        list_new0=list_new[:]
        # list_new=[]
        [state,i,pt0]=parser_token_name(code,i,list_new)
        if state==True:
            [state,i,text]=word_pat_token(code,i,r'=')
        
        if state==True:
            pt0=NetP("输出变量").con(0,pt0)
        if state==False:
            i=i0
            list_new=list_new0
            state=True
            state0=False
        # else:
        #     list_new=list_new0+list_new
        if state==True:
            [state,i,pt1]=parser_token_name(code,i,list_new)
            if state==True:
                pt1=NetP("函数名").con(0,pt1)
            if state==True:
                pt1.con(pt0,0)
            else:
                pt1=pt0
            if state==True:
                [state,i,text]=word_pat_token(code,i,r'\(')
                if state==True:
                    i2=i
                    state2=True
                    list_new2=list_new[:]
                    # list_new=[]
                    [state,i,pt2]=parser_token_input(code,i,list_new)
                    if state==True:
                        pt2=NetP("输入变量").con(0,pt2)
                    if state==True:
                        pt2.con(pt1,0)
                    else:
                        pt2=pt1
                    if state==False:
                        i=i2
                        list_new=list_new2
                        state=True
                        state2=False
                    # else:
                    #     list_new=list_new2+list_new
                        pt2=pt1
                    if state==True:
                        [state,i,text]=word_pat_token(code,i,r'\)')
                        if state==True:
                            i3=i
                            state3=True
                            list_new3=list_new[:]
                            # list_new=[]
                            [state,i,pt3]=parser_token_code(code,i,list_new)
                            if state==True:
                                pt3=NetP("运算").con(0,pt3)
                            if state==True:
                                pt3.con(pt2,0)
                            else:
                                pt3=pt2
                            if state==False:
                                i=i3
                                list_new=list_new3
                                state=True
                                state3=False
                            # else:
                            #     list_new=list_new3+list_new
                                pt3=pt2
                            if state==True:
                                [state,i,text]=word_pat_token(code,i,r'end')
                            #if state3==False:
                            #    try:
                            #        pt3=pt4
                            #    except:
                            #        pt3=None
                            if state3==True:
                                list_new.append(pt3)
                    #if state2==False:
                    #    try:
                    #        pt2=pt3
                    #    except:
                    #        pt2=None
                    if state2==True:
                        list_new.append(pt2)
            if state==True:
                list_new.append(pt1)
        #if state0==False:
        #    try:
        #        pt0=pt1
        #    except:
        #        pt0=None
        if state0==True:
            list_new.append(pt0)
    

    if state==False:
        print("func1:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("func1:",state,pt0.info())
        return [True,i,pt0]

def parser_token_func(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,pt0]=parser_token_func1(code,i,list_new)
    if state==True:
        pt0=NetP("函数").con(0,pt0)
    if state==True:
        list_new.append(pt0)
    if state==False:
        i=i0
        list_new=list_new0
        [state,i,pt0]=parser_token_func2(code,i,list_new)
        if state==True:
            pt0=NetP("函数").con(0,pt0)
        if state==True:
            list_new.append(pt0)
    

    if state==False:
        print("func:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("func:",state,pt0.info())
        return [True,i,pt0]

def parser_token_codeCl(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'\s*')
    if state==True:
        [state,i,text]=word_pat_token(code,i,r'public|private|protected')
        pt0=NetP("成员类型",text)
        if state==True:
            [state,i,text]=word_pat_token(code,i,r' *:\s*')
            if state==True:
                [state,i,pt1]=parser_token_normal(code,i,list_new)
                if state==True:
                    pt1.con(pt0,0)
                else:
                    pt1=pt0
                if state==True:
                    i2=i
                    state2=True
                    list_new2=list_new[:]
                    # list_new=[]
                    [state,i,pt2]=parser_token_codeCl(code,i,list_new)
                    if state==True:
                        pt2.con(pt1,0)
                    else:
                        pt2=pt1
                    if state==False:
                        i=i2
                        list_new=list_new2
                        state=True
                        state2=False
                    # else:
                    #     list_new=list_new2+list_new
        if state==True:
            list_new.append(pt0)
    

    if state==False:
        print("codeCl:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("codeCl:",state,pt0.info())
        return [True,i,pt0]

def parser_token_class(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'class')
    pt0=NetP("类",text)
    if state==True:
        [state,i,text]=word_pat_token(code,i,r' *')
        if state==True:
            [state,i,pt1]=parser_token_name(code,i,list_new)
            if state==True:
                pt1=NetP("类名").con(0,pt1)
            if state==True:
                pt1.con(pt0,0)
            else:
                pt1=pt0
            if state==True:
                i2=i
                state2=True
                list_new2=list_new[:]
                # list_new=[]
                [state,i,text]=word_pat_token(code,i,r':')
                if state==True:
                    [state,i,pt2]=parser_token_name(code,i,list_new)
                    if state==True:
                        pt2.con(pt1,0)
                    else:
                        pt2=pt1
                
                if state==True:
                    pt2=NetP("父类").con(0,pt2)
                if state==False:
                    i=i2
                    list_new=list_new2
                    state=True
                    state2=False
                # else:
                #     list_new=list_new2+list_new
                    pt2=pt1
                if state==True:
                    [state,i,text]=word_pat_token(code,i,r' *')
                    if state==True:
                        i3=i
                        state3=True
                        list_new3=list_new[:]
                        # list_new=[]
                        [state,i,text]=word_pat_token(code,i,r'{')
                        if state==True:
                            [state,i,pt3]=parser_token_codeCl(code,i,list_new)
                            if state==True:
                                pt3.con(pt2,0)
                            else:
                                pt3=pt2
                            if state==True:
                                [state,i,text]=word_pat_token(code,i,r'}')
                        
                        if state==False:
                            i=i3
                            list_new=list_new3
                            state=True
                            state3=False
                        # else:
                        #     list_new=list_new3+list_new
                        if state==True:
                            i3=i
                            state3=True
                            list_new3=list_new[:]
                            # list_new=[]
                            [state,i,text]=word_pat_token(code,i,r';')
                            if state==False:
                                i=i3
                                list_new=list_new3
                                state=True
                                state3=False
                            # else:
                            #     list_new=list_new3+list_new
                #if state2==False:
                #    try:
                #        pt2=pt3
                #    except:
                #        pt2=None
                if state2==True:
                    list_new.append(pt2)
            if state==True:
                list_new.append(pt1)
    if state==True:
        list_new.append(pt0)
    

    if state==False:
        print("class:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("class:",state,pt0.info())
        return [True,i,pt0]

def parser_token_block(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'\s*')
    if state==True:
        i0=i
        list_new0=list_new[:]
        [state,i,pt0]=parser_token_cond(code,i,list_new)
        if state==False:
            i=i0
            list_new=list_new0
            [state,i,pt0]=parser_token_loop(code,i,list_new)
        if state==False:
            i=i0
            list_new=list_new0
            [state,i,pt0]=parser_token_class(code,i,list_new)
        if state==False:
            i=i0
            list_new=list_new0
            [state,i,pt0]=parser_token_func(code,i,list_new)
        if state==False:
            i=i0
            list_new=list_new0
            [state,i,pt0]=parser_token_comm(code,i,list_new)
        if state==False:
            i=i0
            list_new=list_new0
            [state,i,pt0]=parser_token_normal(code,i,list_new)
        
        if state==True:
            [state,i,text]=word_pat_token(code,i,r'\s*')
    

    if state==False:
        print("block:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("block:",state,pt0.info())
        return [True,i,pt0]

def parser_token_code(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,pt0]=parser_token_block(code,i,list_new)
    if state==True:
        pt0=NetP("块").con(0,pt0)
    if state==True:
        i1=i
        state1=True
        list_new1=list_new[:]
        # list_new=[]
        [state,i,pt1]=parser_token_code(code,i,list_new)
        if state==True:
            pt1.con(pt0,0)
        else:
            pt1=pt0
        if state==False:
            i=i1
            list_new=list_new1
            state=True
            state1=False
        # else:
        #     list_new=list_new1+list_new
    if state==True:
        list_new.append(pt0)
    

    if state==False:
        print("code:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("code:",state,pt0.info())
        return [True,i,pt0]

def parser_token_program(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,pt0]=parser_token_code(code,i,list_new)
    

    if state==False:
        print("program:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("program:",state,pt0.info())
        return [True,i,pt0]


def parser_text2pts(code):
    list_pt0=[]
    [state,i,pt]=parser_token_program(code,0,list_pt0)
    list_pt=[]
    for pt in list_pt0:
        if pt!=None:
                list_pt.append(pt)
    if state==False:
        return ''
    text=tools_basic.writeStdCode([],list_pt)
    return text

#text=parser_text2pts('A:B')
#print(text)



"""
+[P函数](,函数定义)

"""
## end
#4838, 2686:
name#0"void"(,)
name#1"G4ConstRK4"(,)
name#2"Stepper"(,)
cmd#3"const G4double yInput[]"(,)
cmd#4" const G4double dydx[]"(cmd#3,)
cmd#5" G4double hstep"(cmd#4,)
cmd#6" G4double yOutput[]"(cmd#5,)
cmd#7" G4double yError [] "(cmd#6,)
normal#8"const G4int nvar = 6;
const G4int maxvar = GetNumberOfStateVariables();
G4double  correction = 1. / ( (1 << IntegratorOrder()) -1 );
G4int i;
"(,)
cmd#9"i=0"(,)
cmd#10"    i<maxvar"(初始化#14,)
cmd#11" ++i"(结束条件#13,)
循环运算#12""(,cmd#11)
结束条件#13""(,cmd#10)
初始化#14""(,cmd#9)
normal#15"yInitial[i]= yInput[i]; "(,)
块#16""(,normal#15)
运算#17""(条件#18,块#16)
条件#18""(循环#19,初始化#14)
循环#19"for"(,)
cmd#20"i=nvar"(,)
cmd#21" i<maxvar"(初始化#25,)
cmd#22" ++i"(结束条件#24,)
循环运算#23""(,cmd#22)
结束条件#24""(,cmd#21)
初始化#25""(,cmd#20)
normal#26"yOutput[i]=  yInput[i]; "(,)
块#27""(,normal#26)
运算#28""(条件#29,块#27)
条件#29""(循环#30,初始化#25)
循环#30"for"(,)
normal#31"yMiddle[7]  = yInput[7];
yOneStep[7] = yInput[7];
yError[7] = 0.0;         
G4double halfStep = hstep * 0.5;
GetConstField(yInitial,Field);
DumbStepper  (yInitial,  dydx,   halfStep, yMiddle);
RightHandSideConst(yMiddle, dydxMid);    
DumbStepper  (yMiddle, dydxMid, halfStep, yOutput);
fMidPoint = G4ThreeVector( yMiddle[0],  yMiddle[1],  yMiddle[2]);
DumbStepper(yInitial, dydx, hstep, yOneStep);
"(,)
cmd#32"i=0"(,)
cmd#33" i<nvar"(初始化#37,)
cmd#34" ++i"(结束条件#36,)
循环运算#35""(,cmd#34)
结束条件#36""(,cmd#33)
初始化#37""(,cmd#32)
normal#38"yError [i] = yOutput[i] - yOneStep[i] ;
yOutput[i] += yError[i]*correction ;
"(,)
块#39""(,normal#38)
运算#40""(条件#41,块#39)
条件#41""(循环#42,初始化#37)
循环#42"for"(,)
normal#43"fInitialPoint = G4ThreeVector( yInitial[0], yInitial[1], yInitial[2]); 
fFinalPoint   = G4ThreeVector( yOutput[0],  yOutput[1],  yOutput[2]); 
return;
"(,)
块#44""(块#45,normal#43)
块#45""(块#46,循环#42)
块#46""(块#47,normal#31)
块#47""(块#48,循环#30)
块#48""(块#49,循环#19)
块#49""(,normal#8)
运算#50""(输入变量#51,块#49)
输入变量#51""(函数#52,cmd#3)
函数#52""(命名空间#53,name#2)
命名空间#53""(输出类型#54,name#1)
输出类型#54""(,name#0)
name#55"G4double"(,)
name#56"G4ConstRK4"(,)
name#57"DistChord"(,)
const#58"const"(函数#75,)
normal#59"G4double distLine, distChord; 
"(,)
cmd#60"fInitialPoint != fFinalPoint"(,)
normal#61"distLine= G4LineSection::Distline( fMidPoint, fInitialPoint, fFinalPoint );
distChord = distLine;
"(,)
块#62""(,normal#61)
运算#63""(条件#68,块#62)
normal#64"distChord = (fMidPoint-fInitialPoint).mag();
"(,)
块#65""(,normal#64)
运算#66""(否则#67,块#65)
否则#67"else"(运算#63,)
条件#68""(如果#69,cmd#60)
如果#69"if"(,)
normal#70"return distChord;
"(,)
块#71""(块#72,normal#70)
块#72""(块#73,如果#69)
块#73""(,normal#59)
运算#74""(const#58,块#73)
函数#75""(命名空间#76,name#57)
命名空间#76""(输出类型#77,name#56)
输出类型#77""(,name#55)
块#78""(块#79,输出类型#77)
块#79""(,输出类型#54)
起点#80""(,块#79)

## end
#4840, 2741:


void G4ConstRK4::Stepper( const G4double yInput[],
                     const G4double dydx[],
                           G4double hstep,
                           G4double yOutput[],
                           G4double yError [] )
{
   const G4int nvar = 6;  // number of variables integrated
   const G4int maxvar = GetNumberOfStateVariables();

   // Correction for Richardson extrapolation
   G4double  correction = 1. / ( (1 << IntegratorOrder()) -1 );

   G4int i;
   
   // Saving yInput because yInput and yOutput can be aliases for same array
   for (i=0;    i<maxvar; ++i) { yInitial[i]= yInput[i]; }
 
   // Must copy the part of the state *not* integrated to the output
   for (i=nvar; i<maxvar; ++i) { yOutput[i]=  yInput[i]; }

   // yInitial[7]= yInput[7];  //  The time is typically needed
   yMiddle[7]  = yInput[7];   // Copy the time from initial value 
   yOneStep[7] = yInput[7];   // As it contributes to final value of yOutput ?
   // yOutput[7] = yInput[7];  // -> dumb stepper does it too for RK4
   yError[7] = 0.0;         

   G4double halfStep = hstep * 0.5; 

   // Do two half steps
   //
   GetConstField(yInitial,Field);
   DumbStepper  (yInitial,  dydx,   halfStep, yMiddle);
   RightHandSideConst(yMiddle, dydxMid);    
   DumbStepper  (yMiddle, dydxMid, halfStep, yOutput); 

   // Store midpoint, chord calculation
   //
   fMidPoint = G4ThreeVector( yMiddle[0],  yMiddle[1],  yMiddle[2]); 

   // Do a full Step
   //
   DumbStepper(yInitial, dydx, hstep, yOneStep);
   for(i=0; i<nvar; ++i)
   {
      yError [i] = yOutput[i] - yOneStep[i] ;
      yOutput[i] += yError[i]*correction ;
        // Provides accuracy increased by 1 order via the 
        // Richardson extrapolation  
   }

   fInitialPoint = G4ThreeVector( yInitial[0], yInitial[1], yInitial[2]); 
   fFinalPoint   = G4ThreeVector( yOutput[0],  yOutput[1],  yOutput[2]); 

   return;
}

////////////////////////////////////////////////////////////////
//
// Estimate the maximum distance from the curve to the chord
//
// We estimate this using the distance of the midpoint to chord.
// The method below is good only for angle deviations < 2 pi;
// this restriction should not be a problem for the Runge Kutta methods, 
// which generally cannot integrate accurately for large angle deviations
//
G4double G4ConstRK4::DistChord() const 
{
  G4double distLine, distChord; 

  if (fInitialPoint != fFinalPoint)
  {
     distLine= G4LineSection::Distline( fMidPoint, fInitialPoint, fFinalPoint );
       // This is a class method that gives distance of Mid 
       // from the Chord between the Initial and Final points
     distChord = distLine;
  }
  else
  {
     distChord = (fMidPoint-fInitialPoint).mag();
  }
  return distChord;
}
## end
#4843, 16:
版本1:...
版本2:...

## end
#4845, 2850:
"""
记住"Python"

result=re.match(r"(a*)","aaaabba")
print(len(result.group(1)))

"""
def parser_token_normal(code,i,list_pt=None):
    i0=i
    text=""
    pat=r"[{}]|//|/\*"
    pat1=r"if[\s]+|elseif[\s]+|else[\s]+|while[\s]+|for[\s]+|end[\s]+|end$"
#    pat1=r"if[\s]+|while[\s\(]+|for[\s]+|end[\s]+"
    while i<len(code):
        if re.match(pat,code[i:]):
            break
        elif re.match(pat1,code[i:]):
            if i==0:
                break
            elif code[i-1]==" " or code[i-1]=="\n" or code[i-1]=="\t":
                break
        elif code[i]=="\n":
            result=re.match(r"(\s*)",code[i:])
            text+=code[i]
            i+=len(result.group(1))
        else:
            text+=code[i]
            i+=1

    if text=="":
        return [False,i0,None]
    else:
        pt0=NetP('normal',text)
        list_pt.append(pt0)
        return [True,i,pt0]


def parser_token_cmd(code,i,list_pt=None):
    i0=i
    text=""
    pat=r"[{};,\n]|//|/\*"
    pat1=r"if[\s]+|elseif[\s]+|else[\s]+|while[\s]+|for[\s]+|end[\s]+|end$"
    b_n=0

    while i<len(code):
        if re.match(pat,code[i:]):
            break
        elif re.match(pat1,code[i:]):
            if i==0:
                break
            elif code[i-1]==" " or code[i-1]=="\n" or code[i-1]=="\t":
                break
        elif code[i]=="\n":
            result=re.match(r"(\s*)",code[i:])
            i+=len(result.group(1))-1
        elif code[i]=="(":
            b_n+=1
        elif code[i]==")":
            b_n-=1
        if b_n<0:
            break
        text+=code[i]
        i+=1

    if text=="":
        return [False,i0,None]
    else:
        pt0=NetP('cmd',text)
        list_pt.append(pt0)
        return [True,i,pt0]


def parser_token_comm(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'//.*\n')
    pt0=NetP("comm",text)
    if state==True:
        i1=i
        state1=True
        list_new1=list_new[:]
        # list_new=[]
        [state,i,text]=word_pat_token(code,i,r'\s*')
        if state==True:
            [state,i,pt1]=parser_token_comm(code,i,list_new)
            if state==True:
                pt0.m_text+=pt1.m_text
        state=True
    
    if state==False:
        return [False,i0,None]
    else:
        list_pt.append(pt0)
        return [True,i,pt0]

def parser_token_name(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'[\w\d_\~]+')
    
    pt0=NetP('name',text)
    list_new.append(pt0)
    list_pt+=list_new

    if state==False:
        print("name:",state)
        return [False,i0,None]
    else:
        print("name:",state,pt0.info())
        return [True,i,pt0]

state=True

## end
#4847, 907:
program:[code]
code:[block]{块} [code]?
block:\\s* ([cond]| [loop]| [class]| [func]| [comm]| [normal]) \\s*
class:class{类} \ * [name]{类名} (: [name]){父类}? \ * (\{ [codeCl] \})? ;?
codeCl:\\s* public\|private\|protected{成员类型} \ *:\\s* [normal] [codeCl]?
func:[func1]{函数}| [func2]{函数}
func1:function\ + ([name] =){输出变量}? [name]{函数名} \\\( [input]{输入变量}? \\\) [code]{运算}? end
func2:function\ +\\\[ [input]{输出变量} \\\]= [name]{函数名} \\\( [input]{输入变量}? \\\) [code]{运算}? end
cond:if{如果} \ + [cmd]{条件} \ *\\n\\s* [code]{运算} \\s* ([cond2]| end)
cond2:else [cond]| else\ *\\n\\s* [code]{运算} \\s*end
loop:[loop1]| [loop2]
loop1:for{循环} \ * [cmd]{条件} \ *\\n\\s* [code]{运算} \\s*end
loop2:while{循环} \ * [cmd]{条件} \ *\\n\\s* [code]{运算} \\s*end
comm:%.*\\n{comm} (\\s* [comm])?
comm1:%\{ [.\\s]* %}{comm}
normal:\\s* [cmd] ;\\s*\\n [normal]?
input:\ * [name] \ * (,\ * [input])?
name:\[\\w\\d_\\~\]+{name}
cmd:\[\\*\\w\]+{cmd}
## end
#4848, 862:
program:[code]
code:[block]{块} [code]?
block:\\s* ([cond]| [loop]| [class]| [func]| [comm]| [normal]) \\s*
class:class{类} \ * [name]{类名} (: [name]){父类}? \ * (\{ [codeCl] \})? ;?
codeCl:\\s* public\|private\|protected{成员类型} \ *:\\s* [normal] [codeCl]?
func:function\ + [name]{函数} \\\( [input]{输入变量}? \\\) (;| \\s*\{ [code]{运算}? \})
cond:if{如果} \ *\\\(\ * [cmd]{条件} \ *\\\)\\s* ([cmd] ;| \{ [code] \}){运算} \\s* [cond2]?
cond2:else\  [cond]| else\ *\{ [code]{运算} \}
loop:[loop1]| [loop2]| [loop3]
loop1:for{循环} \ +\\\( [normal]{条件} \\\)\ +\{ [code]{运算} \}
loop2:while{循环} \ *\\\( [cmd]{条件} \\\)\ *\{ [code]{运算} \}
loop3:do{循环} \ *\{ [code]{运算} \}\* while\ *\\\( [cmd]{条件} \\\)\ *;
comm://.*\\n{comm} (\\s* [comm])?
comm1:/\\* [.\\s]* \\*/{comm}
normal:\\s* [cmd] ;\\s*\\n [normal]?
input:\ * [cmd] \ * (,\ * [input])?
name:\[\\w\\d_\\~\]+{name}
cmd:\[\\*\\w\]+{cmd}
## end
#4849, 2602:
"""
记住"Python"

result=re.match(r"(a*)","aaaabba")
print(len(result.group(1)))

"""
def parser_token_normal(code,i,list_pt=None):
    i0=i
    text=""
    pat=r"[{}]|//|/\*"
    pat1=r"if[\s\(]+|while[\s\(]+|for[\s\(]+|do[\s\{]+"
    b_n=0

    while i<len(code):
        if re.match(pat,code[i:]) or re.match(pat1,code[i:]):
            break
        elif code[i]=="\n":
            result=re.match(r"(\s*)",code[i:])
            text+=code[i]
            i+=len(result.group(1))
        elif code[i]=="(":
            b_n+=1
        elif code[i]==")":
            b_n-=1
        else:
            text+=code[i]
            i+=1

        if b_n<0:
            break

    if text=="":
        return [False,i0,None]
    else:
        pt0=NetP('normal',text)
        list_pt.append(pt0)
        return [True,i,pt0]


def parser_token_cmd(code,i,list_pt=None):
    i0=i
    text=""
    pat=r"[{};,]|//|/\*"
    pat1=r"if[\s\(]+|while[\s\(]+|for[\s\(]+|do[\s\{]+"
    b_n=0

    while i<len(code):
        if re.match(pat,code[i:]) or re.match(pat1,code[i:]):
            break
        elif code[i]=="\n":
            result=re.match(r"(\s*)",code[i:])
            i+=len(result.group(1))-1
        elif code[i]=="(":
            b_n+=1
        elif code[i]==")":
            b_n-=1
        if b_n<0:
            break
        text+=code[i]
        i+=1

    if text=="":
        return [False,i0,None]
    else:
        pt0=NetP('cmd',text)
        list_pt.append(pt0)
        return [True,i,pt0]


def parser_token_comm(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'//.*\n')
    pt0=NetP("comm",text)
    if state==True:
        i1=i
        state1=True
        list_new1=list_new[:]
        # list_new=[]
        [state,i,text]=word_pat_token(code,i,r'\s*')
        if state==True:
            [state,i,pt1]=parser_token_comm(code,i,list_new)
            if state==True:
                pt0.m_text+=pt1.m_text
        state=True
    
    if state==False:
        return [False,i0,None]
    else:
        list_pt.append(pt0)
        return [True,i,pt0]

def parser_token_name(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'[\w\d_\~]+')
    
    pt0=NetP('name',text)
    list_new.append(pt0)
    list_pt+=list_new

    if state==False:
        print("name:",state)
        return [False,i0,None]
    else:
        print("name:",state,pt0.info())
        return [True,i,pt0]

state=True

## end
#4851, 25691:
"""
+[P函数](,函数定义)
print('2'.replace('2','333'))
loop1

"""

import re
from body.bone import NetP
from tools import tools_basic

def word_pat_token(code,i,pat):
    text=''

#    pat=pat.replace('\\','\\\\')
    a=re.match(pat,code[i:])
    if a==None:
        state=False
    else:
        di=a.span()[1]
        output_txt=code[i:i+di]
        i+=di
        state=True
        text=output_txt
    
    return [state,i,text]


def parser_token_cmd(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'[\*\w]+')
    pt0=NetP("cmd",text)
    if state==True:
        list_new.append(pt0)
    

    if state==False:
        print("cmd:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("cmd:",state,pt0.info())
        return [True,i,pt0]

def parser_token_name(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'[\w\d_\~]+')
    pt0=NetP("name",text)
    if state==True:
        list_new.append(pt0)
    

    if state==False:
        print("name:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("name:",state,pt0.info())
        return [True,i,pt0]

def parser_token_input(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r' *')
    if state==True:
        [state,i,pt0]=parser_token_cmd(code,i,list_new)
        if state==True:
            [state,i,text]=word_pat_token(code,i,r' *')
            if state==True:
                i1=i
                state1=True
                list_new1=list_new[:]
                # list_new=[]
                [state,i,text]=word_pat_token(code,i,r', *')
                if state==True:
                    [state,i,pt1]=parser_token_input(code,i,list_new)
                    if state==True:
                        pt1.con(pt0,0)
                    else:
                        pt1=pt0
                
                if state==False:
                    i=i1
                    list_new=list_new1
                    state=True
                    state1=False
                # else:
                #     list_new=list_new1+list_new
    

    if state==False:
        print("input:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("input:",state,pt0.info())
        return [True,i,pt0]

def parser_token_normal(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'\s*')
    if state==True:
        [state,i,pt0]=parser_token_cmd(code,i,list_new)
        if state==True:
            [state,i,text]=word_pat_token(code,i,r';\s*\n')
            if state==True:
                i1=i
                state1=True
                list_new1=list_new[:]
                # list_new=[]
                [state,i,pt1]=parser_token_normal(code,i,list_new)
                if state==True:
                    pt1.con(pt0,0)
                else:
                    pt1=pt0
                if state==False:
                    i=i1
                    list_new=list_new1
                    state=True
                    state1=False
                # else:
                #     list_new=list_new1+list_new
    

    if state==False:
        print("normal:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("normal:",state,pt0.info())
        return [True,i,pt0]

def parser_token_comm1(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'/\*')
    if state==True:
        [state,i,text]=word_pat_token(code,i,r'[.\s]*')
        if state==True:
            [state,i,text]=word_pat_token(code,i,r'\*/')
            pt0=NetP("comm",text)
            if state==True:
                list_new.append(pt0)
    

    if state==False:
        print("comm1:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("comm1:",state,pt0.info())
        return [True,i,pt0]

def parser_token_comm(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'//.*\n')
    pt0=NetP("comm",text)
    if state==True:
        i1=i
        state1=True
        list_new1=list_new[:]
        # list_new=[]
        [state,i,text]=word_pat_token(code,i,r'\s*')
        if state==True:
            [state,i,pt1]=parser_token_comm(code,i,list_new)
            if state==True:
                pt1.con(pt0,0)
            else:
                pt1=pt0
        
        if state==False:
            i=i1
            list_new=list_new1
            state=True
            state1=False
        # else:
        #     list_new=list_new1+list_new
    if state==True:
        list_new.append(pt0)
    

    if state==False:
        print("comm:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("comm:",state,pt0.info())
        return [True,i,pt0]

def parser_token_loop3(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'do')
    pt0=NetP("循环",text)
    if state==True:
        [state,i,text]=word_pat_token(code,i,r' *{')
        if state==True:
            [state,i,pt1]=parser_token_code(code,i,list_new)
            if state==True:
                pt1=NetP("运算").con(0,pt1)
            if state==True:
                pt1.con(pt0,0)
            else:
                pt1=pt0
            if state==True:
                [state,i,text]=word_pat_token(code,i,r'}*')
                if state==True:
                    [state,i,text]=word_pat_token(code,i,r'while *\(')
                    if state==True:
                        [state,i,pt2]=parser_token_cmd(code,i,list_new)
                        if state==True:
                            pt2=NetP("条件").con(0,pt2)
                        if state==True:
                            pt2.con(pt1,0)
                        else:
                            pt2=pt1
                        if state==True:
                            [state,i,text]=word_pat_token(code,i,r'\) *;')
                        if state==True:
                            list_new.append(pt2)
            if state==True:
                list_new.append(pt1)
    if state==True:
        list_new.append(pt0)
    

    if state==False:
        print("loop3:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("loop3:",state,pt0.info())
        return [True,i,pt0]

def parser_token_loop2(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'while')
    pt0=NetP("循环",text)
    if state==True:
        [state,i,text]=word_pat_token(code,i,r' *\(')
        if state==True:
            [state,i,pt1]=parser_token_cmd(code,i,list_new)
            if state==True:
                pt1=NetP("条件").con(0,pt1)
            if state==True:
                pt1.con(pt0,0)
            else:
                pt1=pt0
            if state==True:
                [state,i,text]=word_pat_token(code,i,r'\) *{')
                if state==True:
                    [state,i,pt2]=parser_token_code(code,i,list_new)
                    if state==True:
                        pt2=NetP("运算").con(0,pt2)
                    if state==True:
                        pt2.con(pt1,0)
                    else:
                        pt2=pt1
                    if state==True:
                        [state,i,text]=word_pat_token(code,i,r'}')
                    if state==True:
                        list_new.append(pt2)
            if state==True:
                list_new.append(pt1)
    if state==True:
        list_new.append(pt0)
    

    if state==False:
        print("loop2:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("loop2:",state,pt0.info())
        return [True,i,pt0]

def parser_token_loop1(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'for')
    pt0=NetP("循环",text)
    if state==True:
        [state,i,text]=word_pat_token(code,i,r' *\(')
        if state==True:
            [state,i,pt1]=parser_token_normal(code,i,list_new)
            if state==True:
                pt1=NetP("条件").con(0,pt1)
            if state==True:
                pt1.con(pt0,0)
            else:
                pt1=pt0
            if state==True:
                [state,i,text]=word_pat_token(code,i,r'\) *{')
                if state==True:
                    [state,i,pt2]=parser_token_code(code,i,list_new)
                    if state==True:
                        pt2=NetP("运算").con(0,pt2)
                    if state==True:
                        pt2.con(pt1,0)
                    else:
                        pt2=pt1
                    if state==True:
                        [state,i,text]=word_pat_token(code,i,r'}')
                    if state==True:
                        list_new.append(pt2)
            if state==True:
                list_new.append(pt1)
    if state==True:
        list_new.append(pt0)
    

    if state==False:
        print("loop1:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("loop1:",state,pt0.info())
        return [True,i,pt0]

def parser_token_loop(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,pt0]=parser_token_loop1(code,i,list_new)
    if state==False:
        i=i0
        list_new=list_new0
        [state,i,pt0]=parser_token_loop2(code,i,list_new)
    if state==False:
        i=i0
        list_new=list_new0
        [state,i,pt0]=parser_token_loop3(code,i,list_new)
    

    if state==False:
        print("loop:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("loop:",state,pt0.info())
        return [True,i,pt0]

def parser_token_cond2(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'else ')
    if state==True:
        [state,i,pt0]=parser_token_cond(code,i,list_new)
    if state==False:
        i=i0
        list_new=list_new0
        [state,i,text]=word_pat_token(code,i,r'else *{')
        if state==True:
            [state,i,pt0]=parser_token_code(code,i,list_new)
            if state==True:
                pt0=NetP("运算").con(0,pt0)
            if state==True:
                [state,i,text]=word_pat_token(code,i,r'}')
            if state==True:
                list_new.append(pt0)
    

    if state==False:
        print("cond2:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("cond2:",state,pt0.info())
        return [True,i,pt0]

def parser_token_cond(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'if')
    pt0=NetP("如果",text)
    if state==True:
        [state,i,text]=word_pat_token(code,i,r' *\( *')
        if state==True:
            [state,i,pt1]=parser_token_cmd(code,i,list_new)
            if state==True:
                pt1=NetP("条件").con(0,pt1)
            if state==True:
                pt1.con(pt0,0)
            else:
                pt1=pt0
            if state==True:
                [state,i,text]=word_pat_token(code,i,r' *\)\s*')
                if state==True:
                    i2=i
                    list_new2=list_new[:]
                    [state,i,pt2]=parser_token_cmd(code,i,list_new)
                    if state==True:
                        pt2.con(pt1,0)
                    else:
                        pt2=pt1
                    if state==True:
                        [state,i,text]=word_pat_token(code,i,r';')
                    if state==False:
                        i=i2
                        list_new=list_new2
                        [state,i,text]=word_pat_token(code,i,r'{')
                        if state==True:
                            [state,i,pt2]=parser_token_code(code,i,list_new)
                            if state==True:
                                pt2.con(pt1,0)
                            else:
                                pt2=pt1
                            if state==True:
                                [state,i,text]=word_pat_token(code,i,r'}')
                    
                    if state==True:
                        pt2=NetP("运算").con(0,pt2)
                    if state==True:
                        [state,i,text]=word_pat_token(code,i,r'\s*')
                        if state==True:
                            i3=i
                            state3=True
                            list_new3=list_new[:]
                            # list_new=[]
                            [state,i,pt3]=parser_token_cond2(code,i,list_new)
                            if state==True:
                                pt3.con(pt2,0)
                            else:
                                pt3=pt2
                            if state==False:
                                i=i3
                                list_new=list_new3
                                state=True
                                state3=False
                            # else:
                            #     list_new=list_new3+list_new
                    if state==True:
                        list_new.append(pt2)
            if state==True:
                list_new.append(pt1)
    if state==True:
        list_new.append(pt0)
    

    if state==False:
        print("cond:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("cond:",state,pt0.info())
        return [True,i,pt0]

def parser_token_func(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'function +')
    if state==True:
        [state,i,pt0]=parser_token_name(code,i,list_new)
        if state==True:
            pt0=NetP("函数").con(0,pt0)
        if state==True:
            [state,i,text]=word_pat_token(code,i,r'\(')
            if state==True:
                i1=i
                state1=True
                list_new1=list_new[:]
                # list_new=[]
                [state,i,pt1]=parser_token_input(code,i,list_new)
                if state==True:
                    pt1=NetP("输入变量").con(0,pt1)
                if state==True:
                    pt1.con(pt0,0)
                else:
                    pt1=pt0
                if state==False:
                    i=i1
                    list_new=list_new1
                    state=True
                    state1=False
                # else:
                #     list_new=list_new1+list_new
                    pt1=pt0
                if state==True:
                    [state,i,text]=word_pat_token(code,i,r'\)')
                    if state==True:
                        i2=i
                        list_new2=list_new[:]
                        [state,i,text]=word_pat_token(code,i,r';')
                        if state==False:
                            i=i2
                            list_new=list_new2
                            [state,i,text]=word_pat_token(code,i,r'\s*{')
                            if state==True:
                                i2=i
                                state2=True
                                list_new2=list_new[:]
                                # list_new=[]
                                [state,i,pt2]=parser_token_code(code,i,list_new)
                                if state==True:
                                    pt2=NetP("运算").con(0,pt2)
                                if state==True:
                                    pt2.con(pt1,0)
                                else:
                                    pt2=pt1
                                if state==False:
                                    i=i2
                                    list_new=list_new2
                                    state=True
                                    state2=False
                                # else:
                                #     list_new=list_new2+list_new
                                    pt2=pt1
                                if state==True:
                                    [state,i,text]=word_pat_token(code,i,r'}')
                                #if state2==False:
                                #    try:
                                #        pt2=pt3
                                #    except:
                                #        pt2=None
                                if state2==True:
                                    list_new.append(pt2)
                        
                #if state1==False:
                #    try:
                #        pt1=pt2
                #    except:
                #        pt1=None
                if state1==True:
                    list_new.append(pt1)
        if state==True:
            list_new.append(pt0)
    

    if state==False:
        print("func:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("func:",state,pt0.info())
        return [True,i,pt0]

def parser_token_codeCl(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'\s*')
    if state==True:
        [state,i,text]=word_pat_token(code,i,r'public|private|protected')
        pt0=NetP("成员类型",text)
        if state==True:
            [state,i,text]=word_pat_token(code,i,r' *:\s*')
            if state==True:
                [state,i,pt1]=parser_token_normal(code,i,list_new)
                if state==True:
                    pt1.con(pt0,0)
                else:
                    pt1=pt0
                if state==True:
                    i2=i
                    state2=True
                    list_new2=list_new[:]
                    # list_new=[]
                    [state,i,pt2]=parser_token_codeCl(code,i,list_new)
                    if state==True:
                        pt2.con(pt1,0)
                    else:
                        pt2=pt1
                    if state==False:
                        i=i2
                        list_new=list_new2
                        state=True
                        state2=False
                    # else:
                    #     list_new=list_new2+list_new
        if state==True:
            list_new.append(pt0)
    

    if state==False:
        print("codeCl:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("codeCl:",state,pt0.info())
        return [True,i,pt0]

def parser_token_class(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'class')
    pt0=NetP("类",text)
    if state==True:
        [state,i,text]=word_pat_token(code,i,r' *')
        if state==True:
            [state,i,pt1]=parser_token_name(code,i,list_new)
            if state==True:
                pt1=NetP("类名").con(0,pt1)
            if state==True:
                pt1.con(pt0,0)
            else:
                pt1=pt0
            if state==True:
                i2=i
                state2=True
                list_new2=list_new[:]
                # list_new=[]
                [state,i,text]=word_pat_token(code,i,r':')
                if state==True:
                    [state,i,pt2]=parser_token_name(code,i,list_new)
                    if state==True:
                        pt2.con(pt1,0)
                    else:
                        pt2=pt1
                
                if state==True:
                    pt2=NetP("父类").con(0,pt2)
                if state==False:
                    i=i2
                    list_new=list_new2
                    state=True
                    state2=False
                # else:
                #     list_new=list_new2+list_new
                    pt2=pt1
                if state==True:
                    [state,i,text]=word_pat_token(code,i,r' *')
                    if state==True:
                        i3=i
                        state3=True
                        list_new3=list_new[:]
                        # list_new=[]
                        [state,i,text]=word_pat_token(code,i,r'{')
                        if state==True:
                            [state,i,pt3]=parser_token_codeCl(code,i,list_new)
                            if state==True:
                                pt3.con(pt2,0)
                            else:
                                pt3=pt2
                            if state==True:
                                [state,i,text]=word_pat_token(code,i,r'}')
                        
                        if state==False:
                            i=i3
                            list_new=list_new3
                            state=True
                            state3=False
                        # else:
                        #     list_new=list_new3+list_new
                        if state==True:
                            i3=i
                            state3=True
                            list_new3=list_new[:]
                            # list_new=[]
                            [state,i,text]=word_pat_token(code,i,r';')
                            if state==False:
                                i=i3
                                list_new=list_new3
                                state=True
                                state3=False
                            # else:
                            #     list_new=list_new3+list_new
                #if state2==False:
                #    try:
                #        pt2=pt3
                #    except:
                #        pt2=None
                if state2==True:
                    list_new.append(pt2)
            if state==True:
                list_new.append(pt1)
    if state==True:
        list_new.append(pt0)
    

    if state==False:
        print("class:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("class:",state,pt0.info())
        return [True,i,pt0]

def parser_token_block(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'\s*')
    if state==True:
        i0=i
        list_new0=list_new[:]
        [state,i,pt0]=parser_token_cond(code,i,list_new)
        if state==False:
            i=i0
            list_new=list_new0
            [state,i,pt0]=parser_token_loop(code,i,list_new)
        if state==False:
            i=i0
            list_new=list_new0
            [state,i,pt0]=parser_token_class(code,i,list_new)
        if state==False:
            i=i0
            list_new=list_new0
            [state,i,pt0]=parser_token_func(code,i,list_new)
        if state==False:
            i=i0
            list_new=list_new0
            [state,i,pt0]=parser_token_comm(code,i,list_new)
        if state==False:
            i=i0
            list_new=list_new0
            [state,i,pt0]=parser_token_normal(code,i,list_new)
        
        if state==True:
            [state,i,text]=word_pat_token(code,i,r'\s*')
    

    if state==False:
        print("block:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("block:",state,pt0.info())
        return [True,i,pt0]

def parser_token_code(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,pt0]=parser_token_block(code,i,list_new)
    if state==True:
        pt0=NetP("块").con(0,pt0)
    if state==True:
        i1=i
        state1=True
        list_new1=list_new[:]
        # list_new=[]
        [state,i,pt1]=parser_token_code(code,i,list_new)
        if state==True:
            pt1.con(pt0,0)
        else:
            pt1=pt0
        if state==False:
            i=i1
            list_new=list_new1
            state=True
            state1=False
        # else:
        #     list_new=list_new1+list_new
    if state==True:
        list_new.append(pt0)
    

    if state==False:
        print("code:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("code:",state,pt0.info())
        return [True,i,pt0]

def parser_token_program(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,pt0]=parser_token_code(code,i,list_new)
    

    if state==False:
        print("program:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("program:",state,pt0.info())
        return [True,i,pt0]


def parser_text2pts(code):
    list_pt0=[]
    [state,i,pt]=parser_token_program(code,0,list_pt0)
    list_pt=[]
    for pt in list_pt0:
        if pt!=None:
                list_pt.append(pt)
    if state==False:
        return ''
    text=tools_basic.writeStdCode([],list_pt)
    return text

#text=parser_text2pts('A:B')
#print(text)



"""
+[P函数](,函数定义)

"""
## end
#4856, 224:
"""
规则:...
规则=>想(规则,)=>+[del](,想)
函数定义(P函数):...
默认定义(P函数):...
+[召唤星辰]"生成Parser代码_快速"(规则,函数定义)
+[召唤星辰]"生成Parser代码"(规则,函数定义)
+[新建阅读窗口](,规则)
+[新建阅读窗口](,函数定义)
+[新建阅读窗口](,默认定义)
'规则'有什么

"""

ans=parser_text2pts(code)
state=True


## end
#4858, 366:
"""
P代码(P函数):...
P代码有什么
JS程序_代码=>JS程序_代码#0(JS程序_代码,)=>+[del](,JS程序_代码#0)

"""

+JS程序_代码(_程序,)...
->的(JS程序_代码,P代码)->的(P代码,函数定义)->的(P代码,默认定义)...

->[python]#3"state=True"(Python,)...
->+[code]([python]#0,函数定义)->[python]#0(Python,)...
->+[code]([python]#1,默认定义)->[python]#1(Python,)...

->+[code]([python],P代码)->+[.]"code"([python],_程序)...
->[python](Python,+JS程序_代码)


## end
#4861, 127:
参考::

保存版本:...
规则:...

测试代码:...
结构:...
+[分析程序结构](测试代码,结构)
+[删除结构](,结构)->+[分析程序结构]"M"(测试代码,结构)->+[显示星图](,结构)
+[新建阅读窗口](,测试代码)



## end
#4863, 158:
function y=f(x)

if x==0
    y=1;
    while 1
        y=y+1;
        if y>10
            break;
        end
    end
elseif x>1
    y=2;
else
    y=0;
end

end
## end
#4865, 709:
name#0"y"(,)
name#1"f"(,)
name#2"x"(,)
cmd#3"x==0"(,)
normal#4"y=1;
"(,)
cmd#5"1"(,)
normal#6"y=y+1;
"(,)
cmd#7"y>10"(,)
normal#8"break;
"(,)
块#9""(,normal#8)
运算#10""(条件#11,块#9)
条件#11""(如果#12,cmd#7)
如果#12"if"(,)
块#13""(块#14,如果#12)
块#14""(,normal#6)
运算#15""(条件#16,块#14)
条件#16""(循环#17,cmd#5)
循环#17"while"(,)
块#18""(块#19,循环#17)
块#19""(,normal#4)
cmd#20"x>1"(,)
normal#21"y=2;
"(,)
块#22""(,normal#21)
normal#23"y=0;
"(,)
块#24""(,normal#23)
运算#25""(运算#26,块#24)
运算#26""(条件#27,块#22)
条件#27""(如果#28,cmd#20)
如果#28"if"(运算#29,)
运算#29""(条件#30,块#19)
条件#30""(如果#31,cmd#3)
如果#31"if"(,)
块#32""(,如果#31)
运算#33""(输入变量#34,块#32)
输入变量#34""(函数名#35,name#2)
函数名#35""(输出变量#36,name#1)
输出变量#36""(,name#0)
函数#37""(,输出变量#36)
块#38""(,函数#37)

## end
#4868, 45959:
"""
+[P函数](,函数定义)
print('2'.replace('2','333'))

"""

import re
from body.bone import NetP
from tools import tools_basic

def word_pat_token(code,i,pat):
    text=''

#    pat=pat.replace('\\','\\\\')
    a=re.match(pat,code[i:])
    if a==None:
        state=False
    else:
        di=a.span()[1]
        output_txt=code[i:i+di]
        i+=di
        state=True
        text=output_txt
    
    return [state,i,text]


def parser_token_cmd(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'[\*\w]+')
    pt0=NetP("cmd",text)
    if state==True:
        list_new.append(pt0)
    

    if state==False:
        print("cmd:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("cmd:",state,pt0.info())
        return [True,i,pt0]

def parser_token_name(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'[\w\d_\~]+')
    pt0=NetP("name",text)
    if state==True:
        list_new.append(pt0)
    

    if state==False:
        print("name:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("name:",state,pt0.info())
        return [True,i,pt0]

def parser_token_input(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r' *')
    if state==True:
        [state,i,pt0]=parser_token_cmd(code,i,list_new)
        if state==True:
            [state,i,text]=word_pat_token(code,i,r' *')
            if state==True:
                i1=i
                state1=True
                list_new1=list_new[:]
                # list_new=[]
                [state,i,text]=word_pat_token(code,i,r', *')
                if state==True:
                    [state,i,pt1]=parser_token_input(code,i,list_new)
                    if state==True:
                        pt1.con(pt0,0)
                    else:
                        pt1=pt0
                
                if state==False:
                    i=i1
                    list_new=list_new1
                    state=True
                    state1=False
                # else:
                #     list_new=list_new1+list_new
    

    if state==False:
        print("input:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("input:",state,pt0.info())
        return [True,i,pt0]

def parser_token_const(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'\s*')
    if state==True:
        [state,i,text]=word_pat_token(code,i,r'const')
        pt0=NetP("const",text)
        if state==True:
            [state,i,text]=word_pat_token(code,i,r'\s*')
        if state==True:
            list_new.append(pt0)
    

    if state==False:
        print("const:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("const:",state,pt0.info())
        return [True,i,pt0]

def parser_token_fun_name(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'operator *')
    if state==True:
        [state,i,text]=word_pat_token(code,i,r'[=\-+*/!]+')
        pt0=NetP("运算符号",text)
        if state==True:
            list_new.append(pt0)
    if state==False:
        i=i0
        list_new=list_new0
        [state,i,pt0]=parser_token_name(code,i,list_new)
    

    if state==False:
        print("fun_name:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("fun_name:",state,pt0.info())
        return [True,i,pt0]

def parser_token_fun_prnt(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,pt0]=parser_token_name(code,i,list_new)
    if state==True:
        [state,i,text]=word_pat_token(code,i,r'\s*\(')
        if state==True:
            i1=i
            state1=True
            list_new1=list_new[:]
            # list_new=[]
            [state,i,pt1]=parser_token_input(code,i,list_new)
            if state==True:
                pt1.con(pt0,0)
            else:
                pt1=pt0
            if state==False:
                i=i1
                list_new=list_new1
                state=True
                state1=False
            # else:
            #     list_new=list_new1+list_new
            if state==True:
                [state,i,text]=word_pat_token(code,i,r'\)\s*')
                if state==True:
                    i2=i
                    state2=True
                    list_new2=list_new[:]
                    # list_new=[]
                    [state,i,text]=word_pat_token(code,i,r',\s*')
                    if state==True:
                        [state,i,pt2]=parser_token_fun_prnt(code,i,list_new)
                        if state==True:
                            pt2.con(pt1,0)
                        else:
                            pt2=pt1
                    
                    if state==False:
                        i=i2
                        list_new=list_new2
                        state=True
                        state2=False
                    # else:
                    #     list_new=list_new2+list_new
    

    if state==False:
        print("fun_prnt:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("fun_prnt:",state,pt0.info())
        return [True,i,pt0]

def parser_token_parent(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'\s*:\s*')
    if state==True:
        [state,i,pt0]=parser_token_fun_prnt(code,i,list_new)
    

    if state==False:
        print("parent:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("parent:",state,pt0.info())
        return [True,i,pt0]

def parser_token_field(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,pt0]=parser_token_name(code,i,list_new)
    if state==True:
        [state,i,text]=word_pat_token(code,i,r'\s*::\s*')
    

    if state==False:
        print("field:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("field:",state,pt0.info())
        return [True,i,pt0]

def parser_token_type(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,pt0]=parser_token_field(code,i,list_new)
    if state==True:
        pt0=NetP("命名空间").con(0,pt0)
    if state==True:
        [state,i,pt1]=parser_token_name(code,i,list_new)
        if state==True:
            pt1.con(pt0,0)
        else:
            pt1=pt0
        if state==True:
            [state,i,text]=word_pat_token(code,i,r' *')
    if state==True:
        list_new.append(pt0)
    if state==False:
        i=i0
        list_new=list_new0
        [state,i,pt0]=parser_token_name(code,i,list_new)
        if state==True:
            [state,i,text]=word_pat_token(code,i,r' *')
    

    if state==False:
        print("type:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("type:",state,pt0.info())
        return [True,i,pt0]

def parser_token_normal(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'\s*')
    if state==True:
        [state,i,pt0]=parser_token_cmd(code,i,list_new)
        if state==True:
            [state,i,text]=word_pat_token(code,i,r';\s*\n')
            if state==True:
                i1=i
                state1=True
                list_new1=list_new[:]
                # list_new=[]
                [state,i,pt1]=parser_token_normal(code,i,list_new)
                if state==True:
                    pt1.con(pt0,0)
                else:
                    pt1=pt0
                if state==False:
                    i=i1
                    list_new=list_new1
                    state=True
                    state1=False
                # else:
                #     list_new=list_new1+list_new
    

    if state==False:
        print("normal:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("normal:",state,pt0.info())
        return [True,i,pt0]

def parser_token_define(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'#.*\n')
    pt0=NetP("define",text)
    if state==True:
        i1=i
        state1=True
        list_new1=list_new[:]
        # list_new=[]
        [state,i,text]=word_pat_token(code,i,r'\s*')
        if state==True:
            [state,i,pt1]=parser_token_define(code,i,list_new)
            if state==True:
                pt1.con(pt0,0)
            else:
                pt1=pt0
        
        if state==False:
            i=i1
            list_new=list_new1
            state=True
            state1=False
        # else:
        #     list_new=list_new1+list_new
    if state==True:
        list_new.append(pt0)
    

    if state==False:
        print("define:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("define:",state,pt0.info())
        return [True,i,pt0]

def parser_token_comm1(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'/\*')
    if state==True:
        [state,i,text]=word_pat_token(code,i,r'[.\s]*')
        if state==True:
            [state,i,text]=word_pat_token(code,i,r'\*/')
            pt0=NetP("comm",text)
            if state==True:
                list_new.append(pt0)
    

    if state==False:
        print("comm1:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("comm1:",state,pt0.info())
        return [True,i,pt0]

def parser_token_comm(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'//.*\n')
    pt0=NetP("comm",text)
    if state==True:
        i1=i
        state1=True
        list_new1=list_new[:]
        # list_new=[]
        [state,i,text]=word_pat_token(code,i,r'\s*')
        if state==True:
            [state,i,pt1]=parser_token_comm(code,i,list_new)
            if state==True:
                pt1.con(pt0,0)
            else:
                pt1=pt0
        
        if state==False:
            i=i1
            list_new=list_new1
            state=True
            state1=False
        # else:
        #     list_new=list_new1+list_new
    if state==True:
        list_new.append(pt0)
    

    if state==False:
        print("comm:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("comm:",state,pt0.info())
        return [True,i,pt0]

def parser_token_for_cmd(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    i0=i
    list_new0=list_new[:]
    [state,i,pt0]=parser_token_cmd(code,i,list_new)
    if state==False:
        i=i0
        list_new=list_new0
        [state,i,text]=word_pat_token(code,i,r'\s*')
    
    if state==True:
        pt0=NetP("初始化").con(0,pt0)
    if state==True:
        [state,i,text]=word_pat_token(code,i,r';')
        if state==True:
            i1=i
            list_new1=list_new[:]
            [state,i,pt1]=parser_token_cmd(code,i,list_new)
            if state==True:
                pt1.con(pt0,0)
            else:
                pt1=pt0
            if state==False:
                i=i1
                list_new=list_new1
                [state,i,text]=word_pat_token(code,i,r'\s*')
            
            if state==True:
                pt1=NetP("结束条件").con(0,pt1)
            if state==True:
                [state,i,text]=word_pat_token(code,i,r';')
                if state==True:
                    i2=i
                    list_new2=list_new[:]
                    [state,i,pt2]=parser_token_cmd(code,i,list_new)
                    if state==True:
                        pt2.con(pt1,0)
                    else:
                        pt2=pt1
                    if state==False:
                        i=i2
                        list_new=list_new2
                        [state,i,text]=word_pat_token(code,i,r'\s*')
                    
                    if state==True:
                        pt2=NetP("循环运算").con(0,pt2)
                    if state==True:
                        list_new.append(pt2)
            if state==True:
                list_new.append(pt1)
    if state==True:
        list_new.append(pt0)
    if state==False:
        i=i0
        list_new=list_new0
        [state,i,pt0]=parser_token_cmd(code,i,list_new)
    

    if state==False:
        print("for_cmd:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("for_cmd:",state,pt0.info())
        return [True,i,pt0]

def parser_token_loop3(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'do')
    pt0=NetP("循环",text)
    if state==True:
        [state,i,text]=word_pat_token(code,i,r'\s*{\s*')
        if state==True:
            [state,i,pt1]=parser_token_code(code,i,list_new)
            if state==True:
                pt1=NetP("运算").con(0,pt1)
            if state==True:
                pt1.con(pt0,0)
            else:
                pt1=pt0
            if state==True:
                [state,i,text]=word_pat_token(code,i,r'} *')
                if state==True:
                    [state,i,text]=word_pat_token(code,i,r'while *\(')
                    if state==True:
                        [state,i,pt2]=parser_token_cmd(code,i,list_new)
                        if state==True:
                            pt2=NetP("条件").con(0,pt2)
                        if state==True:
                            pt2.con(pt1,0)
                        else:
                            pt2=pt1
                        if state==True:
                            [state,i,text]=word_pat_token(code,i,r'\) *;')
                        if state==True:
                            list_new.append(pt2)
            if state==True:
                list_new.append(pt1)
    if state==True:
        list_new.append(pt0)
    

    if state==False:
        print("loop3:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("loop3:",state,pt0.info())
        return [True,i,pt0]

def parser_token_loop2(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'while')
    pt0=NetP("循环",text)
    if state==True:
        [state,i,text]=word_pat_token(code,i,r' *\(')
        if state==True:
            [state,i,pt1]=parser_token_cmd(code,i,list_new)
            if state==True:
                pt1=NetP("条件").con(0,pt1)
            if state==True:
                pt1.con(pt0,0)
            else:
                pt1=pt0
            if state==True:
                [state,i,text]=word_pat_token(code,i,r'\)\s*{\s*')
                if state==True:
                    [state,i,pt2]=parser_token_code(code,i,list_new)
                    if state==True:
                        pt2=NetP("运算").con(0,pt2)
                    if state==True:
                        pt2.con(pt1,0)
                    else:
                        pt2=pt1
                    if state==True:
                        [state,i,text]=word_pat_token(code,i,r'}')
                    if state==True:
                        list_new.append(pt2)
            if state==True:
                list_new.append(pt1)
    if state==True:
        list_new.append(pt0)
    

    if state==False:
        print("loop2:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("loop2:",state,pt0.info())
        return [True,i,pt0]

def parser_token_loop1(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'for')
    pt0=NetP("循环",text)
    if state==True:
        [state,i,text]=word_pat_token(code,i,r' *\(')
        if state==True:
            [state,i,pt1]=parser_token_for_cmd(code,i,list_new)
            if state==True:
                pt1=NetP("条件").con(0,pt1)
            if state==True:
                pt1.con(pt0,0)
            else:
                pt1=pt0
            if state==True:
                [state,i,text]=word_pat_token(code,i,r' *\)')
                if state==True:
                    [state,i,pt2]=parser_token_cond_code(code,i,list_new)
                    if state==True:
                        pt2.con(pt1,0)
                    else:
                        pt2=pt1
            if state==True:
                list_new.append(pt1)
    if state==True:
        list_new.append(pt0)
    

    if state==False:
        print("loop1:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("loop1:",state,pt0.info())
        return [True,i,pt0]

def parser_token_loop(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,pt0]=parser_token_loop1(code,i,list_new)
    if state==False:
        i=i0
        list_new=list_new0
        [state,i,pt0]=parser_token_loop2(code,i,list_new)
    if state==False:
        i=i0
        list_new=list_new0
        [state,i,pt0]=parser_token_loop3(code,i,list_new)
    

    if state==False:
        print("loop:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("loop:",state,pt0.info())
        return [True,i,pt0]

def parser_token_block_line(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'\s*')
    if state==True:
        i0=i
        list_new0=list_new[:]
        [state,i,pt0]=parser_token_cond(code,i,list_new)
        if state==False:
            i=i0
            list_new=list_new0
            [state,i,pt0]=parser_token_loop(code,i,list_new)
        if state==False:
            i=i0
            list_new=list_new0
            [state,i,pt0]=parser_token_cmd(code,i,list_new)
            if state==True:
                [state,i,text]=word_pat_token(code,i,r';')
        
        if state==True:
            [state,i,text]=word_pat_token(code,i,r'\s*')
    

    if state==False:
        print("block_line:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("block_line:",state,pt0.info())
        return [True,i,pt0]

def parser_token_code_line(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,pt0]=parser_token_block_line(code,i,list_new)
    if state==True:
        pt0=NetP("块").con(0,pt0)
    if state==True:
        list_new.append(pt0)
    

    if state==False:
        print("code_line:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("code_line:",state,pt0.info())
        return [True,i,pt0]

def parser_token_cond_code(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'\s*{\s*')
    if state==True:
        [state,i,pt0]=parser_token_code(code,i,list_new)
        if state==True:
            pt0=NetP("运算").con(0,pt0)
        if state==True:
            [state,i,text]=word_pat_token(code,i,r'}\s*')
        if state==True:
            list_new.append(pt0)
    if state==False:
        i=i0
        list_new=list_new0
        [state,i,text]=word_pat_token(code,i,r'\s+')
        if state==True:
            [state,i,pt0]=parser_token_code_line(code,i,list_new)
            if state==True:
                pt0=NetP("运算").con(0,pt0)
            if state==True:
                [state,i,text]=word_pat_token(code,i,r'\s*')
            if state==True:
                list_new.append(pt0)
    

    if state==False:
        print("cond_code:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("cond_code:",state,pt0.info())
        return [True,i,pt0]

def parser_token_cond2(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'else ')
    if state==True:
        [state,i,pt0]=parser_token_cond(code,i,list_new)
    if state==False:
        i=i0
        list_new=list_new0
        [state,i,text]=word_pat_token(code,i,r'else')
        pt0=NetP("否则",text)
        if state==True:
            [state,i,pt1]=parser_token_cond_code(code,i,list_new)
            if state==True:
                pt1.con(pt0,0)
            else:
                pt1=pt0
        if state==True:
            list_new.append(pt0)
    

    if state==False:
        print("cond2:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("cond2:",state,pt0.info())
        return [True,i,pt0]

def parser_token_cond(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'if')
    pt0=NetP("如果",text)
    if state==True:
        [state,i,text]=word_pat_token(code,i,r' *\( *')
        if state==True:
            [state,i,pt1]=parser_token_cmd(code,i,list_new)
            if state==True:
                pt1=NetP("条件").con(0,pt1)
            if state==True:
                pt1.con(pt0,0)
            else:
                pt1=pt0
            if state==True:
                [state,i,text]=word_pat_token(code,i,r' *\)')
                if state==True:
                    [state,i,pt2]=parser_token_cond_code(code,i,list_new)
                    if state==True:
                        pt2.con(pt1,0)
                    else:
                        pt2=pt1
                    if state==True:
                        i3=i
                        state3=True
                        list_new3=list_new[:]
                        # list_new=[]
                        [state,i,pt3]=parser_token_cond2(code,i,list_new)
                        if state==True:
                            pt3.con(pt2,0)
                        else:
                            pt3=pt2
                        if state==False:
                            i=i3
                            list_new=list_new3
                            state=True
                            state3=False
                        # else:
                        #     list_new=list_new3+list_new
            if state==True:
                list_new.append(pt1)
    if state==True:
        list_new.append(pt0)
    

    if state==False:
        print("cond:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("cond:",state,pt0.info())
        return [True,i,pt0]

def parser_token_func2(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,pt0]=parser_token_field(code,i,list_new)
    if state==True:
        pt0=NetP("命名空间").con(0,pt0)
    if state==True:
        [state,i,pt1]=parser_token_fun_name(code,i,list_new)
        if state==True:
            pt1=NetP("函数").con(0,pt1)
        if state==True:
            pt1.con(pt0,0)
        else:
            pt1=pt0
        if state==True:
            [state,i,text]=word_pat_token(code,i,r' *\(')
            if state==True:
                i2=i
                state2=True
                list_new2=list_new[:]
                # list_new=[]
                [state,i,pt2]=parser_token_input(code,i,list_new)
                if state==True:
                    pt2=NetP("输入变量").con(0,pt2)
                if state==True:
                    pt2.con(pt1,0)
                else:
                    pt2=pt1
                if state==False:
                    i=i2
                    list_new=list_new2
                    state=True
                    state2=False
                # else:
                #     list_new=list_new2+list_new
                    pt2=pt1
                if state==True:
                    [state,i,text]=word_pat_token(code,i,r'\)')
                    if state==True:
                        i3=i
                        state3=True
                        list_new3=list_new[:]
                        # list_new=[]
                        [state,i,pt3]=parser_token_const(code,i,list_new)
                        if state==True:
                            pt3.con(pt2,0)
                        else:
                            pt3=pt2
                        if state==False:
                            i=i3
                            list_new=list_new3
                            state=True
                            state3=False
                        # else:
                        #     list_new=list_new3+list_new
                        if state==True:
                            i4=i
                            state4=True
                            list_new4=list_new[:]
                            # list_new=[]
                            [state,i,pt4]=parser_token_parent(code,i,list_new)
                            if state==True:
                                pt4=NetP("父函数").con(0,pt4)
                            if state==True:
                                pt4.con(pt3,0)
                            else:
                                pt4=pt3
                            if state==False:
                                i=i4
                                list_new=list_new4
                                state=True
                                state4=False
                            # else:
                            #     list_new=list_new4+list_new
                                pt4=pt3
                            if state==True:
                                i5=i
                                list_new5=list_new[:]
                                [state,i,text]=word_pat_token(code,i,r';')
                                if state==False:
                                    i=i5
                                    list_new=list_new5
                                    [state,i,text]=word_pat_token(code,i,r'\s*{\s*')
                                    if state==True:
                                        i5=i
                                        state5=True
                                        list_new5=list_new[:]
                                        # list_new=[]
                                        [state,i,pt5]=parser_token_code(code,i,list_new)
                                        if state==True:
                                            pt5=NetP("运算").con(0,pt5)
                                        if state==True:
                                            pt5.con(pt4,0)
                                        else:
                                            pt5=pt4
                                        if state==False:
                                            i=i5
                                            list_new=list_new5
                                            state=True
                                            state5=False
                                        # else:
                                        #     list_new=list_new5+list_new
                                            pt5=pt4
                                        if state==True:
                                            [state,i,text]=word_pat_token(code,i,r'}')
                                        #if state5==False:
                                        #    try:
                                        #        pt5=pt6
                                        #    except:
                                        #        pt5=None
                                        if state5==True:
                                            list_new.append(pt5)
                                
                            #if state4==False:
                            #    try:
                            #        pt4=pt5
                            #    except:
                            #        pt4=None
                            if state4==True:
                                list_new.append(pt4)
                #if state2==False:
                #    try:
                #        pt2=pt3
                #    except:
                #        pt2=None
                if state2==True:
                    list_new.append(pt2)
        if state==True:
            list_new.append(pt1)
    if state==True:
        list_new.append(pt0)
    

    if state==False:
        print("func2:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("func2:",state,pt0.info())
        return [True,i,pt0]

def parser_token_func1(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,pt0]=parser_token_type(code,i,list_new)
    if state==True:
        pt0=NetP("输出类型").con(0,pt0)
    if state==True:
        i1=i
        state1=True
        list_new1=list_new[:]
        # list_new=[]
        [state,i,pt1]=parser_token_field(code,i,list_new)
        if state==True:
            pt1=NetP("命名空间").con(0,pt1)
        if state==True:
            pt1.con(pt0,0)
        else:
            pt1=pt0
        if state==False:
            i=i1
            list_new=list_new1
            state=True
            state1=False
        # else:
        #     list_new=list_new1+list_new
            pt1=pt0
        if state==True:
            [state,i,pt2]=parser_token_fun_name(code,i,list_new)
            if state==True:
                pt2=NetP("函数").con(0,pt2)
            if state==True:
                pt2.con(pt1,0)
            else:
                pt2=pt1
            if state==True:
                [state,i,text]=word_pat_token(code,i,r' *\(')
                if state==True:
                    i3=i
                    state3=True
                    list_new3=list_new[:]
                    # list_new=[]
                    [state,i,pt3]=parser_token_input(code,i,list_new)
                    if state==True:
                        pt3=NetP("输入变量").con(0,pt3)
                    if state==True:
                        pt3.con(pt2,0)
                    else:
                        pt3=pt2
                    if state==False:
                        i=i3
                        list_new=list_new3
                        state=True
                        state3=False
                    # else:
                    #     list_new=list_new3+list_new
                        pt3=pt2
                    if state==True:
                        [state,i,text]=word_pat_token(code,i,r'\)')
                        if state==True:
                            i4=i
                            state4=True
                            list_new4=list_new[:]
                            # list_new=[]
                            [state,i,pt4]=parser_token_const(code,i,list_new)
                            if state==True:
                                pt4.con(pt3,0)
                            else:
                                pt4=pt3
                            if state==False:
                                i=i4
                                list_new=list_new4
                                state=True
                                state4=False
                            # else:
                            #     list_new=list_new4+list_new
                            if state==True:
                                i5=i
                                state5=True
                                list_new5=list_new[:]
                                # list_new=[]
                                [state,i,pt5]=parser_token_parent(code,i,list_new)
                                if state==True:
                                    pt5=NetP("父函数").con(0,pt5)
                                if state==True:
                                    pt5.con(pt4,0)
                                else:
                                    pt5=pt4
                                if state==False:
                                    i=i5
                                    list_new=list_new5
                                    state=True
                                    state5=False
                                # else:
                                #     list_new=list_new5+list_new
                                    pt5=pt4
                                if state==True:
                                    i6=i
                                    list_new6=list_new[:]
                                    [state,i,text]=word_pat_token(code,i,r';')
                                    if state==False:
                                        i=i6
                                        list_new=list_new6
                                        [state,i,text]=word_pat_token(code,i,r'\s*{\s*')
                                        if state==True:
                                            i6=i
                                            state6=True
                                            list_new6=list_new[:]
                                            # list_new=[]
                                            [state,i,pt6]=parser_token_code(code,i,list_new)
                                            if state==True:
                                                pt6=NetP("运算").con(0,pt6)
                                            if state==True:
                                                pt6.con(pt5,0)
                                            else:
                                                pt6=pt5
                                            if state==False:
                                                i=i6
                                                list_new=list_new6
                                                state=True
                                                state6=False
                                            # else:
                                            #     list_new=list_new6+list_new
                                                pt6=pt5
                                            if state==True:
                                                [state,i,text]=word_pat_token(code,i,r'}')
                                            #if state6==False:
                                            #    try:
                                            #        pt6=pt7
                                            #    except:
                                            #        pt6=None
                                            if state6==True:
                                                list_new.append(pt6)
                                    
                                #if state5==False:
                                #    try:
                                #        pt5=pt6
                                #    except:
                                #        pt5=None
                                if state5==True:
                                    list_new.append(pt5)
                    #if state3==False:
                    #    try:
                    #        pt3=pt4
                    #    except:
                    #        pt3=None
                    if state3==True:
                        list_new.append(pt3)
            if state==True:
                list_new.append(pt2)
        #if state1==False:
        #    try:
        #        pt1=pt2
        #    except:
        #        pt1=None
        if state1==True:
            list_new.append(pt1)
    if state==True:
        list_new.append(pt0)
    

    if state==False:
        print("func1:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("func1:",state,pt0.info())
        return [True,i,pt0]

def parser_token_func(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,pt0]=parser_token_func1(code,i,list_new)
    if state==False:
        i=i0
        list_new=list_new0
        [state,i,pt0]=parser_token_func2(code,i,list_new)
    if state==False:
        i=i0
        list_new=list_new0
        [state,i,text]=word_pat_token(code,i,r'inline +')
        pt0=NetP("inline",text)
        if state==True:
            i1=i
            list_new1=list_new[:]
            [state,i,pt1]=parser_token_func1(code,i,list_new)
            if state==True:
                pt1.con(pt0,0)
            else:
                pt1=pt0
            if state==False:
                i=i1
                list_new=list_new1
                [state,i,pt1]=parser_token_func2(code,i,list_new)
                if state==True:
                    pt1.con(pt0,0)
                else:
                    pt1=pt0
            
        if state==True:
            list_new.append(pt0)
    

    if state==False:
        print("func:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("func:",state,pt0.info())
        return [True,i,pt0]

def parser_token_codeCl(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'\s*')
    if state==True:
        [state,i,text]=word_pat_token(code,i,r'public|private|protected')
        pt0=NetP("成员类型",text)
        if state==True:
            [state,i,text]=word_pat_token(code,i,r' *:\s*')
            if state==True:
                [state,i,pt1]=parser_token_normal(code,i,list_new)
                if state==True:
                    pt1.con(pt0,0)
                else:
                    pt1=pt0
                if state==True:
                    i2=i
                    state2=True
                    list_new2=list_new[:]
                    # list_new=[]
                    [state,i,pt2]=parser_token_codeCl(code,i,list_new)
                    if state==True:
                        pt2.con(pt1,0)
                    else:
                        pt2=pt1
                    if state==False:
                        i=i2
                        list_new=list_new2
                        state=True
                        state2=False
                    # else:
                    #     list_new=list_new2+list_new
        if state==True:
            list_new.append(pt0)
    

    if state==False:
        print("codeCl:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("codeCl:",state,pt0.info())
        return [True,i,pt0]

def parser_token_class(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'class')
    pt0=NetP("类",text)
    if state==True:
        [state,i,text]=word_pat_token(code,i,r' *')
        if state==True:
            [state,i,pt1]=parser_token_name(code,i,list_new)
            if state==True:
                pt1=NetP("类名").con(0,pt1)
            if state==True:
                pt1.con(pt0,0)
            else:
                pt1=pt0
            if state==True:
                i2=i
                state2=True
                list_new2=list_new[:]
                # list_new=[]
                [state,i,text]=word_pat_token(code,i,r':')
                if state==True:
                    [state,i,pt2]=parser_token_name(code,i,list_new)
                    if state==True:
                        pt2.con(pt1,0)
                    else:
                        pt2=pt1
                
                if state==True:
                    pt2=NetP("父类").con(0,pt2)
                if state==False:
                    i=i2
                    list_new=list_new2
                    state=True
                    state2=False
                # else:
                #     list_new=list_new2+list_new
                    pt2=pt1
                if state==True:
                    [state,i,text]=word_pat_token(code,i,r' *')
                    if state==True:
                        i3=i
                        state3=True
                        list_new3=list_new[:]
                        # list_new=[]
                        [state,i,text]=word_pat_token(code,i,r'{\s*')
                        if state==True:
                            [state,i,pt3]=parser_token_codeCl(code,i,list_new)
                            if state==True:
                                pt3.con(pt2,0)
                            else:
                                pt3=pt2
                            if state==True:
                                [state,i,text]=word_pat_token(code,i,r'}')
                        
                        if state==False:
                            i=i3
                            list_new=list_new3
                            state=True
                            state3=False
                        # else:
                        #     list_new=list_new3+list_new
                        if state==True:
                            i3=i
                            state3=True
                            list_new3=list_new[:]
                            # list_new=[]
                            [state,i,text]=word_pat_token(code,i,r';')
                            if state==False:
                                i=i3
                                list_new=list_new3
                                state=True
                                state3=False
                            # else:
                            #     list_new=list_new3+list_new
                #if state2==False:
                #    try:
                #        pt2=pt3
                #    except:
                #        pt2=None
                if state2==True:
                    list_new.append(pt2)
            if state==True:
                list_new.append(pt1)
    if state==True:
        list_new.append(pt0)
    

    if state==False:
        print("class:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("class:",state,pt0.info())
        return [True,i,pt0]

def parser_token_block(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'\s*')
    if state==True:
        i0=i
        list_new0=list_new[:]
        [state,i,pt0]=parser_token_cond(code,i,list_new)
        if state==False:
            i=i0
            list_new=list_new0
            [state,i,pt0]=parser_token_loop(code,i,list_new)
        if state==False:
            i=i0
            list_new=list_new0
            [state,i,pt0]=parser_token_class(code,i,list_new)
        if state==False:
            i=i0
            list_new=list_new0
            [state,i,pt0]=parser_token_func(code,i,list_new)
        if state==False:
            i=i0
            list_new=list_new0
            [state,i,pt0]=parser_token_comm(code,i,list_new)
        if state==False:
            i=i0
            list_new=list_new0
            [state,i,pt0]=parser_token_define(code,i,list_new)
        if state==False:
            i=i0
            list_new=list_new0
            [state,i,pt0]=parser_token_normal(code,i,list_new)
        
        if state==True:
            [state,i,text]=word_pat_token(code,i,r'\s*')
    

    if state==False:
        print("block:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("block:",state,pt0.info())
        return [True,i,pt0]

def parser_token_code(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,pt0]=parser_token_block(code,i,list_new)
    if state==True:
        pt0=NetP("块").con(0,pt0)
    if state==True:
        i1=i
        state1=True
        list_new1=list_new[:]
        # list_new=[]
        [state,i,pt1]=parser_token_code(code,i,list_new)
        if state==True:
            pt1.con(pt0,0)
        else:
            pt1=pt0
        if state==False:
            i=i1
            list_new=list_new1
            state=True
            state1=False
        # else:
        #     list_new=list_new1+list_new
    if state==True:
        list_new.append(pt0)
    

    if state==False:
        print("code:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("code:",state,pt0.info())
        return [True,i,pt0]

def parser_token_program(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,pt0]=parser_token_code(code,i,list_new)
    if state==True:
        pt0=NetP("起点").con(0,pt0)
    if state==True:
        list_new.append(pt0)
    

    if state==False:
        print("program:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("program:",state,pt0.info())
        return [True,i,pt0]


def parser_text2pts(code):
    list_pt0=[]
    [state,i,pt]=parser_token_program(code,0,list_pt0)
    list_pt=[]
    for pt in list_pt0:
        if pt!=None:
                list_pt.append(pt)
    if state==False:
        return ''
    text=tools_basic.writeStdCode([],list_pt)
    return text

#text=parser_text2pts('A:B')
#print(text)



"""
+[P函数](,函数定义)

"""
## end
#4869, 4491:
"""
记住"Python"

result=re.match(r"(a*)","aaaabba")
print(len(result.group(1)))

"""
def parser_token_normal(code,i,list_pt=None):
    i0=i
    text=""
    pat=r"[#]|//|/\*"
    pat1=r"if[\s\(]+|while[\s\(]+|for[\s\(]+|do[\s\{]+"

    n_bb=0;
    n_quote=0;
    while i<len(code):
        if n_quote>0:
            if code[i]=="\"":
                n_quote=0
            elif code[i]=="\\" and i+1<len(code):
                text+=code[i]
                i+=1
        elif n_bb>0:
            if code[i]=="}":
                n_bb=n_bb-1;
            elif code[i]=="{":
                n_bb+=1
        elif code[i]=="\"":
            n_quote=1
        elif re.match(pat,code[i:]) or re.match(pat1,code[i:]):
            break
        elif code[i]=="\n":
            text+=code[i]
            result=re.match(r"(\s*)",code[i:])
            i+=len(result.group(1))
            continue
        elif code[i]=="{":
            n_bb+=1
        elif code[i]=="}":
            n_bb-=1
        if n_bb<0:
            break
        text+=code[i]
        i+=1

    if text=="":
        return [False,i0,None]
    else:
        pt0=NetP('normal',text)
        list_pt.append(pt0)
        return [True,i,pt0]

"""
保存cmd:...

"""

def parser_token_cmd(code,i,list_pt=None):
    i0=i
    text=""
    pat=r"[;]|//|/\*"
    pat1=r"if[\s\(]+|while[\s\(]+|for[\s\(]+|do[\s\{]+"

    b_n=0
    n_quote=0;
    while i<len(code):
        if n_quote>0:
            if code[i]=="\"":
                n_quote=0
            elif code[i]=="\\" and i+1<len(code):
                i+=1
        elif b_n>0:
            if code[i]==")" or code[i]=="}":
                b_n=b_n-1;
            elif code[i]=="(" or code[i]=="{":
                b_n+=1
        elif code[i]=="\"":
            n_quote=1
        elif re.match(pat,code[i:]) or re.match(pat1,code[i:]):
            break
        elif code[i]=="\n":
            result=re.match(r"(\s*)",code[i:])
            i+=len(result.group(1))-1
        elif code[i]=="(" or code[i]=="{":
            b_n+=1
        elif code[i]==")" or code[i]=="}":
            b_n=b_n-1;
        if b_n<0:
            break
        text+=code[i]
        i+=1

    if text=="":
        return [False,i0,None]
    else:
        print("cmd:",text)
        pt0=NetP('cmd',text)
        list_pt.append(pt0)
        return [True,i,pt0]


def parser_token_comm(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'//.*\n')
    pt0=NetP("comm",text)
    if state==True:
        i1=i
        state1=True
        list_new1=list_new[:]
        # list_new=[]
        [state,i,text]=word_pat_token(code,i,r'\s*')
        if state==True:
            [state,i,pt1]=parser_token_comm(code,i,list_new)
            if state==True:
                pt0.m_text+=pt1.m_text
        state=True
    
    if state==False:
        return [False,i0,None]
    else:
        list_pt.append(pt0)
        return [True,i,pt0]


def parser_token_define(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'#.*\n')
    pt0=NetP("define",text)
    if state==True:
        i1=i
        state1=True
        list_new1=list_new[:]
        # list_new=[]
        [state,i,text]=word_pat_token(code,i,r'\s*')
        if state==True:
            [state,i,pt1]=parser_token_define(code,i,list_new)
            if state==True:
                pt0.m_text+=pt1.m_text
        state=True
    
    if state==False:
        return [False,i0,None]
    else:
        list_pt.append(pt0)
        return [True,i,pt0]

def parser_token_name(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'[\w\d_\~&\*]+')
    
    pt0=NetP('name',text)
    list_new.append(pt0)
    list_pt+=list_new

    if state==False:
        print("name:",state)
        return [False,i0,None]
    else:
        print("name:",state,pt0.info())
        return [True,i,pt0]


def parser_text2pts(code):
    list_pt0=[]
    # code=re.sub('[ \t]+//.*','',code)
    # code=re.sub('\s*//.*','',code)

    [state,i,pt]=parser_token_program(code,0,list_pt0)
    list_pt=[]
    for pt in list_pt0:
        if pt!=None:
                list_pt.append(pt)
    if state==False:
        return ''
    text=tools_basic.writeStdCode([],list_pt)
    return text



state=True

## end
#4870, 1582:
program:[code]{起点}
code:[block]{块} [code]?
block:\\s* ([cond]| [loop]| [class]| [func]| [comm]| [define]| [normal]) \\s*
class:class{类} \ * [name]{类名} (: [name]){父类}? \ * (\{\\s* [codeCl] \})? ;?
codeCl:\\s* public\|private\|protected{成员类型} \ *:\\s* [normal] [codeCl]?
func:[func1]| [func2]| inline\ +{inline} ([func1]| [func2])
func1:[type]{输出类型} [field]{命名空间}? [fun_name]{函数} \ *\\\( [input]{输入变量}? \\\) [const]? [parent]{父函数}? (;| \\s*\{\\s* [code]{运算}? \})
func2:[field]{命名空间} [fun_name]{函数} \ *\\\( [input]{输入变量}? \\\) [const]? [parent]{父函数}? (;| \\s*\{\\s* [code]{运算}? \})
cond:if{如果} \ *\\\(\ * [cmd]{条件} \ *\\\) [cond_code] [cond2]?
cond2:else\  [cond]| else{否则} [cond_code]
cond_code:\\s*\{\\s* [code]{运算} \}\\s*| \\s+ [code_line]{运算} \\s*
code_line:[block_line]{块}
block_line:\\s* ([cond]| [loop]| [cmd] ;) \\s*
loop:[loop1]| [loop2]| [loop3]
loop1:for{循环} \ *\\\( [for_cmd]{条件} \ *\\\) [cond_code]
loop2:while{循环} \ *\\\( [cmd]{条件} \\\)\\s*\{\\s* [code]{运算} \}
loop3:do{循环} \\s*\{\\s* [code]{运算} \}\ * while\ *\\\( [cmd]{条件} \\\)\ *;
for_cmd:([cmd]| \\s*){初始化} ; ([cmd]| \\s*){结束条件} ; ([cmd]| \\s*){循环运算}| [cmd]
comm://.*\\n{comm} (\\s* [comm])?
comm1:/\\* [.\\s]* \\*/{comm}
define:#.*\\n{define} (\\s* [define])?
normal:\\s* [cmd] ;\\s*\\n [normal]?
type:[field]{命名空间} [name] \ *| [name] \ *
field:[name] \\s*::\\s*
parent:\\s*:\\s* [fun_prnt]
fun_prnt:[name] \\s*\\\( [input]? \\\)\\s* (,\\s* [fun_prnt])?
fun_name:operator\ * \[=\\-+\*/\!]+{运算符号}| [name]
const:\\s* const{const} \\s*
input:\ * [cmd] \ * (,\ * [input])?
name:\[\\w\\d_\\~\]+{name}
cmd:\[\\*\\w\]+{cmd}
## end
#4875, 224:
"""
规则:...
规则=>想(规则,)=>+[del](,想)
函数定义(P函数):...
默认定义(P函数):...
+[召唤星辰]"生成Parser代码_快速"(规则,函数定义)
+[召唤星辰]"生成Parser代码"(规则,函数定义)
+[新建阅读窗口](,规则)
+[新建阅读窗口](,函数定义)
+[新建阅读窗口](,默认定义)
'规则'有什么

"""

ans=parser_text2pts(code)
state=True


## end
#4877, 359:
"""
P代码(P函数):...
P代码有什么
C程序_代码=>C程序_代码#0(C程序_代码,)=>+[del](,C程序_代码#0)

"""

+C程序_代码(_程序,)...
->的(C程序_代码,P代码)->的(P代码,函数定义)->的(P代码,默认定义)...

->[python]#3"state=True"(Python,)...
->+[code]([python]#0,函数定义)->[python]#0(Python,)...
->+[code]([python]#1,默认定义)->[python]#1(Python,)...

->+[code]([python],P代码)->+[.]"code"([python],_程序)...
->[python](Python,+C程序_代码)


## end
#4880, 907:
program:[code]
code:[block]{块} [code]?
block:\\s* ([cond]| [loop]| [class]| [func]| [comm]| [normal]) \\s*
class:class{类} \ * [name]{类名} (: [name]){父类}? \ * (\{ [codeCl] \})? ;?
codeCl:\\s* public\|private\|protected{成员类型} \ *:\\s* [normal] [codeCl]?
func:[func1]{函数}| [func2]{函数}
func1:function\ + ([name] =){输出变量}? [name]{函数名} \\\( [input]{输入变量}? \\\) [code]{运算}? end
func2:function\ +\\\[ [input]{输出变量} \\\]= [name]{函数名} \\\( [input]{输入变量}? \\\) [code]{运算}? end
cond:if{如果} \ + [cmd]{条件} \ *\\n\\s* [code]{运算} \\s* ([cond2]| end)
cond2:else [cond]| else\ *\\n\\s* [code]{运算} \\s*end
loop:[loop1]| [loop2]
loop1:for{循环} \ * [cmd]{条件} \ *\\n\\s* [code]{运算} \\s*end
loop2:while{循环} \ * [cmd]{条件} \ *\\n\\s* [code]{运算} \\s*end
comm:%.*\\n{comm} (\\s* [comm])?
comm1:%\{ [.\\s]* %}{comm}
normal:\\s* [cmd] ;\\s*\\n [normal]?
input:\ * [name] \ * (,\ * [input])?
name:\[\\w\\d_\\~\]+{name}
cmd:\[\\*\\w\]+{cmd}
## end
#4882, 128:
参考::

保存版本:...
规则:...

测试代码:...
结构:...
+[分析程序结构](测试代码,结构)
+[删除结构](,结构)->+[分析程序结构]"JS"(测试代码,结构)->+[显示星图](,结构)
+[新建阅读窗口](,测试代码)



## end
#4884, 1102:
program:[code]
code:[block]{块} [code]?
block:\\s* ([cond]| [loop]| [class]| [func]| [comm]| [normal]) \\s*
class:class{类} \ * [name]{类名} (: [name]){父类}? \ * (\{ [codeCl] \})? ;?
codeCl:\\s* public\|private\|protected{成员类型} \ *:\\s* [normal] [codeCl]?
func:[func1]| [func2]
func1:[type]{输出类型} [field]{命名空间}? [name]{函数} \\\( [input]{输入变量}? \\\) [parent]{父函数}? (;| \\s*\{ [code]{运算}? \})
func2:[field]{命名空间} [name]{函数} \\\( [input]{输入变量}? \\\) [parent]{父函数}? (;| \\s*\{ [code]{运算}? \})
cond:if{如果} \ *\\\(\ * [cmd]{条件} \ *\\\)\\s* ([cmd] ;| \{ [code] \}){运算} \\s* [cond2]?
cond2:else\  [cond]| else\ *\{ [code]{运算} \}
loop:[loop1]| [loop2]| [loop3]
loop1:for{循环} \ *\\\( [cmd]{条件} \\\)\ *\{ [code]{运算} \}
loop2:while{循环} \ *\\\( [cmd]{条件} \\\)\ *\{ [code]{运算} \}
loop3:do{循环} \ *\{ [code]{运算} \}\* while\ *\\\( [cmd]{条件} \\\)\ *;
comm://.*\\n{comm} (\\s* [comm])?
comm1:/\\* [.\\s]* \\*/{comm}
normal:\\s* [cmd] ;\\s*\\n [normal]?
type:[name] \ *
field:[name] \\s*::\\s*
parent:\\s*:\\s* [name] \\s*\\\( [input]? \\\)\\s*
input:\ * [cmd] \ * (,\ * [input])?
name:\[\\w\\d_\\~\]+{name}
cmd:\[\\*\\w\]+{cmd}
## end
#4886, 136:

function fun(x) {
    var a=1;
    if (x==1) {
        return 2;
        for (var i=1;i<10;i++) {
            x++;
        }
    }
}



## end
#4888, 414:
name#0"fun"(,)
cmd#1"x"(,)
normal#2"var a=1;
"(,)
cmd#3"x==1"(,)
normal#4"return 2;
"(,)
normal#5"var i=1;i<10;i++"(,)
normal#6"x++;
"(,)
块#7""(,normal#6)
运算#8""(条件#9,块#7)
条件#9""(循环#10,normal#5)
循环#10"for"(,)
块#11""(块#12,循环#10)
块#12""(条件#14,normal#4)
运算#13""(,块#12)
条件#14""(如果#15,cmd#3)
如果#15"if"(,)
块#16""(块#17,如果#15)
块#17""(,normal#2)
运算#18""(输入变量#19,块#17)
输入变量#19""(函数#20,cmd#1)
函数#20""(,name#0)
块#21""(,函数#20)

## end
#4890, 713:
program:[code]
code:[block] [code]?
block:\\s* ([cond]| [loop]| [func]| [class]| [normal]| [comm])
class:class\  [name] (: [name])? (;| \{ [codeCl] \};)
codeCl:\\s* (public| private| protected) \ *:\\s* [normal] \\n [codeCl]?
func:[type] [field]? [name] \\\( [input] \\\) (;| \{ [block] \})
cond:if\ *\\\(\ *[cmd]\ *\\\)\\s*\{ [block] \}\\s* [cond2]?
cond2:else\  [cond]| else\ *\{ [block] \}
loop:[loop1]| [loop2]| [loop3]
loop1:for\ *\\\( [cmd] \\\)\ *\{ [block] \}
loop2:while\ *\\\( [cmd] \\\)\ *\{ [block] \}
loop3:do\ *\{ [block] \}\* while\ *\\\( [cmd] \\\)\ *;
comm:/\\* .* \\*/
normal:\\s* [cmd] ;\\s*\n [normal]?
type:[name] \ *
field:[name] \ *::\ *
input:\ * [cmd] \ * (,\ * [cmd])?
name:\\w+
cmd:\\w+
## end
#4892, 1362:
program:[code]{起点}
code:[block]{块} [code]?
block:\\s* ([cond]| [loop]| [class]| [func]| [comm]| [define]| [normal]) \\s*
class:class{类} \ * [name]{类名} (: [name]){父类}? \ * (\{\\s* [codeCl] \})? ;?
codeCl:\\s* public\|private\|protected{成员类型} \ *:\\s* [normal] [codeCl]?
func:[func1]| [func2]
func1:[type]{输出类型} [field]{命名空间}? [fun_name]{函数} \ *\\\( [input]{输入变量}? \\\) [const]? [parent]{父函数}? (;| \\s*\{\\s* [code]{运算}? \})
func2:[field]{命名空间} [fun_name]{函数} \ *\\\( [input]{输入变量}? \\\) [const]? [parent]{父函数}? (;| \\s*\{\\s* [code]{运算}? \})
cond:if{如果} \ *\\\(\ * [cmd]{条件} \ *\\\) [cond_code] [cond2]?
cond2:else\  [cond]| else{否则} [cond_code]
cond_code:\\s*\{\\s* [code]{运算} \} \\s*| \\s+ [cmd]{运算} ;\\s*
loop:[loop1]| [loop2]| [loop3]
loop1:for{循环} \ *\\\( [cmd]{条件} \\\)\ *\{\\s* [code]{运算} \}
loop2:while{循环} \ *\\\( [cmd]{条件} \\\)\ *\{\\s* [code]{运算} \}
loop3:do{循环} \ *\{\\s* [code]{运算} \}\* while\ *\\\( [cmd]{条件} \\\)\ *;
comm://.*\\n{comm} (\\s* [comm])?
comm1:/\\* [.\\s]* \\*/{comm}
define:#.*\\n{define} (\\s* [define])?
normal:\\s* [cmd] ;\\s*\\n [normal]?
type:[name] \ *
field:[name] \\s*::\\s*
parent:\\s*:\\s* [fun_prnt]
fun_prnt:[name] \\s*\\\( [input]? \\\)\\s* (,\\s* [fun_prnt])?
fun_name:operator\ + \[=\\-+\*/\]{运算符号}| [name]
const:\\s* const{const} \\s*
input:\ * [cmd] \ * (,\ * [input])?
name:\[\\w\\d_\\~\]+{name}
cmd:\[\\*\\w\]+{cmd}
## end
#4894, 399:
+[修改天使]

代码:...
+[新建阅读窗口](,代码)

结构:...
+[删除结构](,结构)->+[分析程序结构](代码,结构)->+[显示星图](,结构)
+[显示星图](,结构)
的(结构,起点)->起点(,块)->+观察(+代码块,块)...
    ->[观察代码结构](结构,+观察)->+[del](,+观察)

描述文本:...
+[删除结构](,描述文本)->+[召唤星辰]"代码结构转文本描述"(结构,描述文本)
的(描述文本,结构)->+[显示星图](,结构)
+[显示](,描述文本)

流程图:...
H代码:...
+[PPT场景转H代码](流程图,H代码)
+[H函数](,H代码)
+[删除结构](,流程图)->+[召唤星辰]"代码结构转流程图"(结构,流程图)
的(流程图,结构)->+[显示星图](,结构)
+[显示PPT场景]"1"(,流程图)




## end
#4896, 307:

int main (a) {
    if (a==1) {
        b=1;
    }
    else if (a==2) {
        if(b==2) {
            b=1;
        }
        else {
            if(b==2) {
                b=1;
            }
            else {
                b=2;
            }
        }
    }
    else {
        b=2;
    }
    return b;
}

## end
#4898, 846:
name#0"int"(,)
name#1"main"(,)
cmd#2"a"(,)
cmd#3"a==1"(,)
normal#4"b=1;
"(,)
块#5""(,normal#4)
运算#6""(条件#35,块#5)
cmd#7"a==2"(,)
cmd#8"b==2"(,)
normal#9"b=1;
"(,)
块#10""(,normal#9)
运算#11""(条件#25,块#10)
cmd#12"b==2"(,)
normal#13"b=1;
"(,)
块#14""(,normal#13)
运算#15""(条件#20,块#14)
normal#16"b=2;
"(,)
块#17""(,normal#16)
运算#18""(否则#19,块#17)
否则#19"else"(运算#15,)
条件#20""(如果#21,cmd#12)
如果#21"if"(,)
块#22""(,如果#21)
运算#23""(否则#24,块#22)
否则#24"else"(运算#11,)
条件#25""(如果#26,cmd#8)
如果#26"if"(,)
块#27""(,如果#26)
运算#28""(条件#33,块#27)
normal#29"b=2;
"(,)
块#30""(,normal#29)
运算#31""(否则#32,块#30)
否则#32"else"(运算#28,)
条件#33""(如果#34,cmd#7)
如果#34"if"(运算#6,)
条件#35""(如果#36,cmd#3)
如果#36"if"(,)
normal#37"return b;
"(,)
块#38""(块#39,normal#37)
块#39""(,如果#36)
运算#40""(输入变量#41,块#39)
输入变量#41""(函数#42,cmd#2)
函数#42""(输出类型#43,name#1)
输出类型#43""(,name#0)
块#44""(,输出类型#43)
起点#45""(,块#44)

## end
#4900, 219:
"""
库:...
+[新建阅读窗口](,库)

"""
+观察代码结构(_题目,_动作)...
->的(观察代码结构,库)...

->[]{
    []:->[is](_动作,观察)->观察(_类型,_节点)->_类型->_节点(,)->[说]"观察: "(,_节点)...
        ->的(库,_条目)->[eq](_条目,_类型)->+[code]([想],_条目)->[想](_题目,观察),
    ->[]
}


## end
#4902, 12:


代码块:...



## end
#4904, 422:
"""
函数块:...
如果块:...
循环块:...
+[新建阅读窗口](,函数块)

"""
+代码块(_题目,观察)...

->观察(,_节点)->_节点(,_特征)...
->函数块->[]{
    []:->[is](_特征,输出类型)->输出类型->+[code]([想]#1,函数块)...
        ->[想]#1(_题目,观察),
    ->[is](_特征,如果)->如果->+[code]([想]#2,如果块)...
        ->[想]#2(_题目,观察),
    ->[is](_特征,循环)->循环->+[code]([想]#3,循环块)...
        ->[想]#3(_题目,观察),
    ->[]
}...
->[]{
    []=>块(_节点,)=>+观察(+代码块,块)->[观察代码结构](_题目,+观察)...
        ->+然后"顺序"(观察,+观察)
}


## end
#4906, 476:
"""
输出类型:...
命名空间:...
函数:...
输入变量:...
运算:...
将条目"命名空间"复制为条目"运算"

"""
+函数块(_题目,观察)...

->观察(,块)->块(,_模块)...
    ->+[code]([想]#1,输出类型)->[想]#1(观察,_模块)->o([想]#1,_模块1)...
    ->+[code]([想]#2,命名空间)->[想]#2(观察,_模块1)->o([想]#2,_模块2)...
    ->+[code]([想]#3,函数)->[想]#3(观察,_模块2)->o([想]#3,_模块3)...
    ->+[code]([想]#4,输入变量)->[想]#4(观察,_模块3)->o([想]#4,_模块4)...
    ->+[code]([想]#5,运算)->[想]#5(观察,_模块4)->o([想]#5,_模块5)...

->+观察(+代码块,_模块5)->[观察代码结构](_题目,+观察)...
    ->+然后"运算"(观察,+观察)->+函数(观察,)



## end
#4908, 154:
"""
如果:...

"""
+如果块(_题目,观察)...

->观察(,块)->块(,_模块)...
    ->+[code]([想]#1,如果)->+[.]"题目"([想]#1,_题目)->+[.]"如果"([想]#1,观察)...
    ->[想]#1(观察,_模块)->+如果(观察,)



## end
#4910, 261:
"""


"""
+循环块(_题目,观察)...

->观察(,块)->块(,循环)...
->[]{
    []:->条件(循环,)->运算(条件,_块)->+观察(+代码块#1,_块)...
        ->[观察代码结构](_题目,+观察)->+然后"运算"(观察,+观察)->+循环(观察,),
    ->运算(循环,_块2)->条件(运算,)->+观察(+代码块#2,_块2)...
        ->[观察代码结构](_题目,+观察)->+然后"运算"(观察,+观察)->+循环(观察,)
}



## end
#4912, 152:
"""


"""
+输出类型(观察,_模块)...

->[]{
    []:->[is](_模块,输出类型)->输出类型->_模块1(_模块,)...
        ->+[o](+输出类型,_模块1)->+[.]"输出类型"(观察,_模块),
    ->+[o](+输出类型,_模块)
}


## end
#4914, 152:
"""


"""
+输入变量(观察,_模块)...

->[]{
    []:->[is](_模块,输入变量)->输入变量->_模块1(_模块,)...
        ->+[o](+输入变量,_模块1)->+[.]"输入变量"(观察,_模块),
    ->+[o](+输入变量,_模块)
}


## end
#4916, 124:
"""


"""
+函数(观察,_模块)...

->_模块->[]{
    []:->[is](_模块,函数)->函数->_模块1(_模块,)...
        ->+[o](+函数,_模块1)->+[.]"函数"(观察,_模块)
}


## end
#4917, 131:
"""


"""
+运算(观察,_模块)...

->[]{
    []:->[is](_模块,运算)->运算(,_块)...
        ->+[.]"运算"(观察,_模块)->+[o](+运算,_块),
    ->+[o](+运算,_模块)
}


## end
#4919, 152:
"""


"""
+命名空间(观察,_模块)...

->[]{
    []:->[is](_模块,命名空间)->命名空间->_模块1(_模块,)...
        ->+[o](+命名空间,_模块1)->+[.]"命名空间"(观察,_模块),
    ->+[o](+命名空间,_模块)
}


## end
#4922, 391:
"""


"""
+如果(观察,如果)->."题目"(+如果,_题目)->."如果"(+如果,观察#0)...

->条件(如果,)->运算(条件,_块)->+观察(+代码块,_块)...
    ->[观察代码结构](_题目,+观察)->+然后"运算"(观察,+观察)->+条件(+观察,条件)...
->[]{
    []:->如果#1(运算,)...
        ->+[code]([想],如果#0)->+[.]"题目"([想],_题目)->+[.]"如果"([想],观察#0)...
        ->[想](观察,如果#1),
    ->否则(运算,)->运算(否则,_块2)->+观察(+代码块,_块2)...
        ->[观察代码结构](_题目,+观察)->+然后"运算"(观察#0,+观察)->+否则(+观察,),
    ->[]
}



## end
#4924, 172:

代码结构转文本描述:...
代码结构转流程图:...
封印'代码结构转文本描述'
封印'代码结构转流程图'
+[新建阅读窗口](,代码结构转文本描述)
+[新建阅读窗口](,代码结构转流程图)

代码结构转代码:...
封印'代码结构转代码'
+[新建阅读窗口](,代码结构转代码)
将条目"代码结构转文本描述"复制为条目"代码结构转代码"

## end
#4926, 23:


召唤规则:...
降临规则:...




## end
#4928, 222:
"""

"""

+召唤规则(_题目,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_代码)...

->[==]"代码结构转流程图"(,召唤星辰)...

->+整理结构(_题目,_代码)->+的(操作,+整理结构)...
->+模块连线(_题目,_代码)->+的(操作,+模块连线)...
->+布置位置(_题目,_代码)->+的(操作,+布置位置)...
->+生成结构(_题目,_代码)->+的(操作,+生成结构)



## end
#4930, 73:


生成结构:...
布置位置:...
模块连线:...
整理结构:...
+[新建阅读窗口](,生成结构)
+[新建阅读窗口](,模块连线)


## end
#4932, 363:
"""
描述结构:...
库:...

"""

+生成结构(_媒介,_凭依)->+[del](,+生成结构)...
->的(生成结构,描述结构)->的(生成结构,库)...

->[]{
    []:->的(_凭依,结构)->结构->+[删除结构](,结构),
    ->+的(_凭依,+结构)
}->的(_凭依,结构)...

->+[code]([想],描述结构)->[想](_媒介,结构)...
->操作([想],)->[]{
    []=>的(操作,_操作)->_操作(,_模块)->_模块=>[说]"操作: "(,_操作)...
        ->的(库,_条目)->_条目->[eq](_条目,_操作)...
        ->+[做](_凭依,_模块)->+[code](+[做],_条目)
}



## end
#4934, 228:
"""
收集块:...

"""
+描述结构(_媒介,结构)->+操作(+描述结构,)...

->的(_媒介,起点)->起点(,块)->+观察(+代码块,块)->[观察代码结构](_媒介,+观察)...
->+[code]([想],收集块)->[想](结构,+观察)->o([想],模块)...
->+起点(,模块)->+的(结构,+起点)->[投影](,+起点)->[投影](,+的)...

->+描述模块(,模块)->+的(+操作,+描述模块)


## end
#4936, 189:
"""

"""

+召唤规则(_题目,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_代码)...

->[==]"代码结构转文本描述"(,召唤星辰)...

->+整理结构(_题目,_代码)->+的(操作,+整理结构)...
->+整理文本(_题目,_代码)->+的(操作,+整理文本)...
->+生成结构(_题目,_代码)->+的(操作,+生成结构)



## end
#4938, 5492:
代码结构转文本描述#0"

召唤规则:...
降临规则:...



"(,)
的#1""(代码结构转文本描述#0,召唤规则#2)
召唤规则#2"\"\"\"

\"\"\"

+召唤规则(_题目,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_代码)...

->[==]\"代码结构转文本描述\"(,召唤星辰)...

->+整理结构(_题目,_代码)->+的(操作,+整理结构)...
->+整理文本(_题目,_代码)->+的(操作,+整理文本)...
->+生成结构(_题目,_代码)->+的(操作,+生成结构)


"(,)
的#3""(代码结构转文本描述#0,降临规则#4)
降临规则#4"

生成结构:...
整理文本:...
整理结构:...

"(,)
的#5""(降临规则#4,整理文本#6)
整理文本#6"\"\"\"


\"\"\"
+整理文本

"(,)
的#7""(降临规则#4,生成结构#8)
生成结构#8"\"\"\"
描述结构:...
库:...

\"\"\"

+生成结构(_媒介,_凭依)->+[del](,+生成结构)...
->的(生成结构,描述结构)->的(生成结构,库)...

->[]{
    []:->的(_凭依,结构)->结构->+[删除结构](,结构),
    ->+的(_凭依,+结构)
}->的(_凭依,结构)...

->+[code]([想],描述结构)->[想](_媒介,结构)...
->操作([想],)->[]{
    []=>的(操作,_操作)->_操作(,_模块)->_模块=>[说]\"操作: \"(,_操作)...
        ->的(库,_条目)->_条目->[eq](_条目,_操作)...
        ->+[做](_凭依,_模块)->+[code](+[做],_条目)
}


"(,)
的#9""(生成结构#8,描述结构#10)
描述结构#10"\"\"\"
收集块:...

\"\"\"
+描述结构(_媒介,结构)->+操作(+描述结构,)...

->的(_媒介,起点)->起点(,块)->+观察(+代码块,块)->[观察代码结构](_媒介,+观察)...
->+[code]([想],收集块)->[想](结构,+观察)->o([想],模块)...

->+描述模块(,模块)->+的(+操作,+描述模块)

"(,)
的#11""(描述结构#10,收集块#12)
收集块#12"\"\"\"
P代码:...
P代码1:...
P代码2:...
收集内容:...
+[新建阅读窗口](,P代码)

\"\"\"
+收集块(结构,观察)...

->观察(,_块)->+的(结构,+模块)->+模块\"1,1,1\"(,_块)->+[o](+收集块,+模块)...
    ->+的#2(结构,+内容)->+内容(+模块,)...
        ->+[code]([想]#0,收集内容)->[想]#0(观察,+内容)...
    ->[投影](,+的)->[投影](,+模块)->[投影](,+的#2)->[投影](,+内容)...

->+[code]([python]#0,P代码1)...
    ->+[.]\"func_name\"([python]#0,+内容)->+[.]\"bk1\"([python]#0,+模块)...
    ->[python]#0(Python,+模块)...
->[]{
    []=>然后\"运算\"(观察,观察#2)->观察#2=>+[code]([想],收集块)...
        ->[想](结构,观察#2)->o([想],模块#2)...
        ->+内部(+模块,模块#2)->+的(结构,+内部)->[投影](,+的)->[投影](,+内部)...
        ->+[code]([python],P代码)...
        ->+[.]\"bk1\"([python],+模块)->+[.]\"bk2\"([python],模块#2)...
        ->[python](Python,+模块)
}...
->[]{
    []=>然后\"顺序\"(观察,观察#2)->观察#2=>+[code]([想],收集块)...
        ->[想](结构,观察#2)->o([想],模块#2)...
        ->+顺序(+模块,模块#2)->+的(结构,+顺序)->[投影](,+的)->[投影](,+顺序)...
        ->+[code]([python],P代码2)...
        ->+[.]\"bk1\"([python],+模块)->+[.]\"bk2\"([python],模块#2)...
        ->[python](Python,+模块)
}

"(,)
的#13""(收集块#12,P代码#14)
P代码#14"\"\"\"
记住\"Python\"
print(np.max([1,2]))
print(func_name)

\"\"\"

bk1[0]+=1
bk1[1]=np.max([bk1[2],bk2[2]])
bk1[2]=bk1[1]
ans=bk1
"(,)
的#15""(收集块#12,P代码2#16)
P代码2#16"\"\"\"


\"\"\"

bk1[2]+=bk2[2]+1
ans=bk1
"(,)
的#17""(收集块#12,收集内容#18)
收集内容#18"\"\"\"


\"\"\"
+收集内容(观察,内容)...

->[]{
    []:->如果(观察,)->[m_text]\"if\"(,内容),
    ->条件(观察,条件#1)->条件#1(,_cond)...
        ->[m_text](_cond,内容)->[m_name](+条件,内容),
    ->否则(观察,)->[m_text]\"else\"(,内容),
    ->循环(观察,)->[m_text]\"loop\"(,内容),
    ->函数(观察,)->.\"函数\"(观察,_模块)->_模块(,name)...
        ->[m_text](name,内容)->[m_name](+函数,内容),
    ->[m_text]\"代码\"(,内容)
}


"(,)
的#19""(收集块#12,P代码1#20)
P代码1#20"\"\"\"


\"\"\"

# print(\"!!!!\",func_name,len(func_name))
bk1[0]=len(func_name)
ans=bk1

"(,)
的#21""(生成结构#8,库#22)
库#22"
描述模块:...


"(,)
的#23""(库#22,描述模块#24)
描述模块#24"\"\"\"
写模块:...

\"\"\"
+描述模块(_凭依,_模块)->+[del](,+描述模块)...
->的(描述模块,写模块)...

->+[做](_凭依,_模块)->+[code](+[做],写模块)

"(,)
的#25""(描述模块#24,写模块#26)
写模块#26"\"\"\"
P代码:...
P代码2:...
P代码3:...

\"\"\"
+写模块(_文本,_模块)->+[del](,+写模块)...
->的(写模块,P代码)->的(写模块,P代码2)->的(写模块,P代码3)...

->+[临时文本]#内部->[]{
    []=>内部(_模块,_模块1)->_模块1=>+[做](+[临时文本]#a,_模块1)...
        ->+[code](+[做],写模块)...
        ->+[python](Python,+[临时文本]#内部)->+[code](+[python],P代码2)...
        ->+[s]\"text_a\"(+[python],+[临时文本]#a)...
        ->+[s]\"text_0\"(+[python],+[临时文本]#内部)
}...

->_re\"函数|内容|条件\"(_模块,)->+[标题](_re,)...
->+[python](Python,_文本)->+[code](+[python],P代码)...
    ->+[s]\"var_name\"(+[python],_re)->+[s]\"pt_name\"(+[python],+[标题])...
    ->+[s]\"text_0\"(+[python],+[临时文本]#内部)...

->[]{
    []=>顺序(_模块,_模块1)->_模块1=>+[做](+[临时文本]#a,_模块1)...
        ->+[code](+[做],写模块)...
        ->+[python](Python,_文本)->+[code](+[python],P代码3)...
        ->+[s]\"text_a\"(+[python],+[临时文本]#a)...
        ->+[s]\"text_0\"(+[python],_文本)
}



"(,)
的#27""(写模块#26,P代码#28)
P代码#28"\"\"\"


\"\"\"
# print(var_name,pt_name)
if text_0==\"\":
    ans=var_name
else:
    str_a=\"|\"
    text_0=str_a+text_0.replace(\"\n\",\"\n\"+str_a)
    ans=var_name+\"\n\"+text_0

"(,)
的#29""(写模块#26,P代码2#30)
P代码2#30"\"\"\"
+[P函数](,P代码2)
str_a=\"|\"
text_a=str_a+text_a.replace(\"\n\",\"\n\"+str_a)
ans=text_a+\"\n\"+text_0
测试:...
print(l_0)

\"\"\"
import numpy as np

ans=\"\"
if text_0!=\"\":
    list_line_0=text_0.split(\"\n\")
    n_0=np.max([len(line) for line in list_line_0])
    l_0=len(list_line_0)
    list_line_a=text_a.split(\"\n\")
    n_a=np.max([len(line) for line in list_line_a])
    l_a=len(list_line_a)

    for i in range(np.max([l_a,l_0])):
        print(i)
        if i>=l_a:
            line_a=f'{\"\": <n_a}'
        else:
            line_a=f'{\"%s\": <n_a}'%(list_line_a[i])
        
        if i>=l_0:
            line_0=f'{\"\": <n_0}'
        else:
            line_0=f'{\"%s\": <n_0}'%(list_line_0[i])
        ans=line_a+\" --- \"+line_0+\"\n\"

else:
    ans=text_a

"(,)
的#31""(P代码2#30,测试#32)
测试#32"\"\"\"
+[P函数](,测试)

\"\"\"
text_a=\"\"\"
aaa
c
v
\"\"\"
text_0=text_a

list_line=text_0.split(\"\n\")
list_ns=[len(line) for line in list_line]
print(list_ns)




\"\"\"
+[P函数](,测试)
print(f'{\"dog\": <10}'+'1')
print(f'{\"%s\":X<10}'%(\"AAA\"))

\"\"\""(,)
的#33""(写模块#26,P代码3#34)
P代码3#34"\"\"\"


\"\"\"

ans=text_0+\"\n\"+text_a
"(,)
的#35""(降临规则#4,整理结构#36)
整理结构#36"\"\"\"


\"\"\"
+整理结构(_媒介,_凭依)->+[del](,+整理结构)...

->的(_凭依,召唤规则)->+[删除结构](,召唤规则)->+[del](,召唤规则)...
->的(_凭依,降临规则)->+[删除结构](,降临规则)->+[del](,降临规则)...
->+[记住](,_凭依)
"(,)

## end
#4940, 162:
main
├if
|└a==1─────a==2────────────────else 
| └code    └if                 └code
|           └b==2─────else          
|            └code    └code         
└code
## end
#4942, 1085:
"""
P代码:...
P代码1:...
P代码2:...
+[新建阅读窗口](,P代码)

收集内容:...
后处理:...

保存:...
+[新建阅读窗口](,保存)

"""
+收集块(结构,观察)...

->观察(,_块)->+的(结构,+模块)->+模块"0,1,0,1"(,_块)...
    ->+的#2(结构,+内容)->+内容(+模块,)...
        ->+[code]([想]#0,收集内容)->+[.]([想]#0,+类型)->[想]#0(观察,+内容)...
    ->[投影](,+的)->[投影](,+模块)->[投影](,+的#2)->[投影](,+内容)...

->[]{
    []=>然后"运算"(观察,观察#2)->观察#2=>+[code]([想],收集块)...
        ->[想](结构,观察#2)->o([想],模块#2)...
        ->+内部(+模块,模块#2)->+的(结构,+内部)->[投影](,+的)->[投影](,+内部)...
        ->+[code]([python],P代码)...
        ->+[.]"bk1"([python],+模块)->+[.]"bk2"([python],模块#2)...
        ->[python](Python,+模块)
}...

->+[code]([python]#0,P代码1)->+[s]"func_type"([python]#0,+类型)...
->+[s]"func_name"([python]#0,+内容)->+[.]"bk1"([python]#0,+模块)...
->[python]#0(Python,+模块)...

->[]{
    []=>然后"顺序"(观察,观察#2)->观察#2=>+[code]([想],收集块)...
        ->[想](结构,观察#2)->o([想],模块#2)...
        ->+顺序(+模块,模块#2)->+的(结构,+顺序)->[投影](,+的)->[投影](,+顺序)...
        ->+[code]([python],P代码2)...
        ->+[.]"bk1"([python],+模块)->+[.]"bk2"([python],模块#2)...
        ->[python](Python,+模块)
}...

->+[code]([想],后处理)->[想](+收集块,+模块)


## end
#4944, 140:
"""
记住"Python"
print(np.max([1,2]))
print(func_name)

"""

state=True
bk1[0]+=bk2[0]
bk1[1]=np.max([bk1[1],bk2[1]])
# bk1[2]=bk1[1]
ans=bk1

## end
#4946, 44:
"""


"""
state=True
bk1[1]+=bk2[1]
ans=bk1

## end
#4948, 322:
"""
保存:...

"""
+收集内容(观察,内容)->.(+收集内容,类型)...

->[]{
    []:->如果(观察,)->[m_text]"if"(,内容)->[m_text]"如果"(,类型),
    ->循环(观察,)->[m_text]"loop"(,内容)->[m_text]"循环"(,类型),
    ->函数(观察,)->."函数"(观察,_模块)->_模块(,name)...
        ->[m_text](name,内容)->[m_name](+函数,内容)->[m_text]"函数"(,类型),
    ->[m_text]"code"(,内容)->[m_text]"运算"(,类型)
}



## end
#4950, 236:
"""
记住"Python"
print(func_type)

"""

state=True

bk1[0]=np.max([len(func_name),bk1[0]])
bk1[2]=np.max([len(func_name),bk1[0]])


if func_type=="如果":
    bk1[1]=bk1[1]+1
elif func_type=="函数":
    bk1[1]=bk1[1]+1
bk1[3]=bk1[1]

ans=bk1


## end
#4952, 188:
"""


"""
+整理结构(_媒介,_凭依)->+[del](,+整理结构)...

->的(_凭依,召唤规则)->+[删除结构](,召唤规则)->+[del](,召唤规则)...
->的(_凭依,降临规则)->+[删除结构](,降临规则)->+[del](,降临规则)...
->+[显示PPT场景]"1"(,_凭依)->+[PPT场景转H代码](_凭依,_凭依)



## end
#4954, 12:

描述模块:...



## end
#4956, 105:
"""
写模块:...

"""
+描述模块(_凭依,_模块)->+[del](,+描述模块)...
->的(描述模块,写模块)...

->+[做](_凭依,_模块)->+[code](+[做],写模块)


## end
#4958, 845:
"""
P代码:...
P代码b:...
P代码2:...
P代码3:...

"""
+写模块(_文本,_模块)->+[del](,+写模块)...
->的(写模块,P代码)...
->的(写模块,P代码2)->的(写模块,P代码3)...

->+[临时文本]#内部->[]{
    []=>内部(_模块,_模块1)->_模块1=>+[做](+[临时文本]#a,_模块1)...
        ->+[code](+[做],写模块)...
        ->+[python](Python,+[临时文本]#内部)->+[code](+[python],P代码2)...
        ->+[s]"text_a"(+[python],+[临时文本]#a)...
        ->+[s]"text_0"(+[python],+[临时文本]#内部)
}...

->_re"函数|内容|条件"(_模块,)->+[标题](_re,)...
->+[python](Python,_文本)->+[code](+[python],P代码)...
    ->+[s]"var_name"(+[python],_re)->+[s]"pt_name"(+[python],+[标题])...
    ->+[s]"text_0"(+[python],+[临时文本]#内部)...

->[]{
    []:->顺序(_模块,_模块1)->_模块1(,)...
        ->+[做](+[临时文本]#a,_模块1)->+[code](+[做],写模块)...
        ->+[python](Python,_文本)->+[code](+[python],P代码3)...
        ->+[s]"text_a"(+[python],+[临时文本]#a)...
        ->+[s]"text_0"(+[python],_文本),

    ->[]
}

## end
#4960, 792:
"""
    text_0=str_a+text_0.replace("\n","\n"+str_a)
print(text_0)
print(text_1)
+[P函数](,P代码)

"""
# print(var_name,pt_name)
if text_0=="":
    ans=var_name
else:
    str_a="├"
    list_line=text_0.split("\n")
    list_line_1=[]
    n_last=0
    for i in range(len(list_line)):
        line=list_line[i]
        if line[0]=="|" or line[0]=="├" or line[0]=="└" or line[0]==" ":
            line="|"+line
        else:
            n_last=i
            line="├"+line
        list_line_1.append(line)
    for i in range(n_last,len(list_line_1)):
        if list_line_1[i][0]=="|":
            list_line_1[i]=' '+list_line_1[i][1:]
        else:
            list_line_1[i]='└'+list_line_1[i][1:]

    text_1="\n".join(list_line_1)
    ans=var_name+"\n"+text_1


"""
print(text_1)
+[P函数](,P代码)

"""
## end
#4962, 915:
"""
记住"Python"
+[P函数](,P代码2)
测试:...

"""
import numpy as np

ans=""
pat_line_0="{s:─<{n}}"
pat_line_1="{s: <{n}}"
if text_0!="":
    list_line_0=text_0.split("\n")
    n_0=np.max([len(line) for line in list_line_0])
    l_0=len(list_line_0)
    list_line_a=text_a.split("\n")
    n_a=np.max([len(line) for line in list_line_a])
    l_a=len(list_line_a)

    for i in range(np.max([l_a,l_0])):
        pat_line=pat_line_1

        if i>=l_a:
            line_a=pat_line.format(s=" ",n=n_a)
        else:
            line_a=pat_line.format(s=list_line_a[i],n=n_a)
        
        if i>=l_0:
            line_0=pat_line.format(s=" ",n=n_0)
        else:
            line_0=pat_line.format(s=list_line_0[i],n=n_0)

        if i==0:
            line_a=line_a.replace(" ","─")
            ans+=line_a+"────"+line_0+"\n"
        else:
            ans+=line_a+"    "+line_0+"\n"

    ans=ans[0:-1]
else:
    ans=text_a




## end
#4964, 34:
"""


"""

ans=text_0+"\n"+text_a

## end
#4965, 17:
"""


"""
+整理文本


## end
#4966, 17:
"""


"""
+整理文本


## end
#4967, 17:
"""


"""
+整理文本


## end
#4968, 17:
"""


"""
+整理文本


## end
#4969, 17:
"""


"""
+整理文本


## end
#4970, 17:
"""


"""
+整理文本


## end
#4971, 17:
"""


"""
+整理文本


## end
#4972, 17:
"""


"""
+整理文本


## end
#4973, 17:
"""


"""
+整理文本


## end
#4974, 17:
"""


"""
+整理文本


## end
#4975, 17:
"""


"""
+整理文本


## end
#4976, 17:
"""


"""
+整理文本


## end
#4977, 17:
"""


"""
+整理文本


## end
#4978, 17:
"""


"""
+整理文本


## end
#4980, 265:
"""
+[P函数](,测试)

"""
text_a="""
aaa
c
v
"""
text_0=text_a

list_line=text_0.split("\n")
list_ns=[len(line) for line in list_line]
print(list_ns)




"""
+[P函数](,测试)
print('{s:X<{n}}'.format(s="11",n=10))
print(f'{"dog": <10}'+'1')
print(f'{"%s":X<10}'%("AAA"))

"""
## end
#4981, 17:
"""


"""
+整理文本


## end
#4982, 17:
"""


"""
+整理文本


## end
#4983, 17:
"""


"""
+整理文本


## end
#4984, 17:
"""


"""
+整理文本


## end
#4985, 17:
"""


"""
+整理文本


## end
#4987, 17:
"""


"""
+整理文本


## end
#4988, 17:
"""


"""
+整理文本


## end
#4989, 17:
"""


"""
+整理文本


## end
#4990, 17:
"""


"""
+整理文本


## end
#4991, 17:
"""


"""
+整理文本


## end
#4992, 17:
"""


"""
+整理文本


## end
#4993, 17:
"""


"""
+整理文本


## end
#4994, 17:
"""


"""
+整理文本


## end
#4995, 17:
"""


"""
+整理文本


## end
#4996, 17:
"""


"""
+整理文本


## end
#4997, 17:
"""


"""
+整理文本


## end
#4998, 17:
"""


"""
+整理文本


## end
#4999, 17:
"""


"""
+整理文本


## end
#5000, 17:
"""


"""
+整理文本


## end
#5001, 17:
"""


"""
+整理文本


## end
#5002, 17:
"""


"""
+整理文本


## end
#5005, 17:
"""


"""
+整理文本


## end
#5006, 17:
"""


"""
+整理文本


## end
#5007, 17:
"""


"""
+整理文本


## end
#5008, 17:
"""


"""
+整理文本


## end
#5009, 17:
"""


"""
+整理文本


## end
#5010, 17:
"""


"""
+整理文本


## end
#5011, 17:
"""


"""
+整理文本


## end
#5012, 17:
"""


"""
+整理文本


## end
#5013, 17:
"""


"""
+整理文本


## end
#5014, 17:
"""


"""
+整理文本


## end
#5015, 17:
"""


"""
+整理文本


## end
#5016, 17:
"""


"""
+整理文本


## end
#5018, 1294:
"""
P代码:...
P代码1:...
P代码2:...
收集内容:...
+[新建阅读窗口](,P代码)

保存:...

"""
+收集块(结构,观察)...

->观察(,_块)->+的(结构,+模块)->+模块"1,1,1"(,_块)...
    ->+的#2(结构,+内容)->+内容(+模块,)...
        ->+[code]([想]#0,收集内容)->[想]#0(观察,+内容)...
    ->[投影](,+的)->[投影](,+模块)->[投影](,+的#2)->[投影](,+内容)...

->[]{
    []:->条件(观察,条件#1)->条件#1(,_cond)->+的(结构,+模块#2)->+模块#2"1,1,1"...
        ->+条件#2(+模块#2,)->+的#2(结构,+条件#2)->[m_text](_cond,+条件#2)...
        ->[投影](,+的)->[投影](,+模块#2)->[投影](,+的#2)->[投影](,+条件#2)...
        ->+内部(+模块#2,+模块)->+的(结构,+内部)->[投影](,+的)->[投影](,+内部)...
    ->+[o](+收集块,+模块#2),

    ->+[o](+收集块,+模块)
}...

->+[code]([python]#0,P代码1)...
    ->+[.]"func_name"([python]#0,+内容)->+[.]"bk1"([python]#0,+模块)...
    ->[python]#0(Python,+模块)...
->[]{
    []=>然后"运算"(观察,观察#2)->观察#2=>+[code]([想],收集块)...
        ->[想](结构,观察#2)->o([想],模块#2)...
        ->+内部(+模块,模块#2)->+的(结构,+内部)->[投影](,+的)->[投影](,+内部)...
        ->+[code]([python],P代码)...
        ->+[.]"bk1"([python],+模块)->+[.]"bk2"([python],模块#2)...
        ->[python](Python,+模块)
}...
->[]{
    []=>然后"顺序"(观察,观察#2)->观察#2=>+[code]([想],收集块)...
        ->[想](结构,观察#2)->o([想],模块#2)...
        ->+顺序(+模块,模块#2)->+的(结构,+顺序)->[投影](,+的)->[投影](,+顺序)...
        ->+[code]([python],P代码2)...
        ->+[.]"bk1"([python],+模块)->+[.]"bk2"([python],模块#2)...
        ->[python](Python,+模块)
}


## end
#5019, 17:
"""


"""
+整理文本


## end
#5020, 17:
"""


"""
+整理文本


## end
#5021, 17:
"""


"""
+整理文本


## end
#5022, 17:
"""


"""
+整理文本


## end
#5023, 17:
"""


"""
+整理文本


## end
#5024, 17:
"""


"""
+整理文本


## end
#5025, 17:
"""


"""
+整理文本


## end
#5026, 17:
"""


"""
+整理文本


## end
#5027, 209:
"""


"""
+整理结构(_媒介,_凭依)->+[del](,+整理结构)...

->的(_凭依,召唤规则)->+[删除结构](,召唤规则)->+[del](,召唤规则)...
->的(_凭依,降临规则)->+[删除结构](,降临规则)->+[del](,降临规则)...

->的(_凭依,文本)->+[结构转文本](文本,_凭依)...
->+[记住](,_凭依)->+[修改内容](_凭依,+[显示])

## end
#5029, 34:
"""


"""

ans=text_0+"\n"+text_a

## end
#5030, 265:
"""
+[P函数](,测试)

"""
text_a="""
aaa
c
v
"""
text_0=text_a

list_line=text_0.split("\n")
list_ns=[len(line) for line in list_line]
print(list_ns)




"""
+[P函数](,测试)
print('{s:X<{n}}'.format(s="11",n=10))
print(f'{"dog": <10}'+'1')
print(f'{"%s":X<10}'%("AAA"))

"""
## end
#5032, 915:
"""
记住"Python"
+[P函数](,P代码2)
测试:...

"""
import numpy as np

ans=""
pat_line_0="{s:─<{n}}"
pat_line_1="{s: <{n}}"
if text_0!="":
    list_line_0=text_0.split("\n")
    n_0=np.max([len(line) for line in list_line_0])
    l_0=len(list_line_0)
    list_line_a=text_a.split("\n")
    n_a=np.max([len(line) for line in list_line_a])
    l_a=len(list_line_a)

    for i in range(np.max([l_a,l_0])):
        pat_line=pat_line_1

        if i>=l_a:
            line_a=pat_line.format(s=" ",n=n_a)
        else:
            line_a=pat_line.format(s=list_line_a[i],n=n_a)
        
        if i>=l_0:
            line_0=pat_line.format(s=" ",n=n_0)
        else:
            line_0=pat_line.format(s=list_line_0[i],n=n_0)

        if i==0:
            line_a=line_a.replace(" ","─")
            ans+=line_a+"────"+line_0+"\n"
        else:
            ans+=line_a+"    "+line_0+"\n"

    ans=ans[0:-1]
else:
    ans=text_a




## end
#5033, 792:
"""
    text_0=str_a+text_0.replace("\n","\n"+str_a)
print(text_0)
print(text_1)
+[P函数](,P代码)

"""
# print(var_name,pt_name)
if text_0=="":
    ans=var_name
else:
    str_a="├"
    list_line=text_0.split("\n")
    list_line_1=[]
    n_last=0
    for i in range(len(list_line)):
        line=list_line[i]
        if line[0]=="|" or line[0]=="├" or line[0]=="└" or line[0]==" ":
            line="|"+line
        else:
            n_last=i
            line="├"+line
        list_line_1.append(line)
    for i in range(n_last,len(list_line_1)):
        if list_line_1[i][0]=="|":
            list_line_1[i]=' '+list_line_1[i][1:]
        else:
            list_line_1[i]='└'+list_line_1[i][1:]

    text_1="\n".join(list_line_1)
    ans=var_name+"\n"+text_1


"""
print(text_1)
+[P函数](,P代码)

"""
## end
#5038, 845:
"""
P代码:...
P代码b:...
P代码2:...
P代码3:...

"""
+写模块(_文本,_模块)->+[del](,+写模块)...
->的(写模块,P代码)...
->的(写模块,P代码2)->的(写模块,P代码3)...

->+[临时文本]#内部->[]{
    []=>内部(_模块,_模块1)->_模块1=>+[做](+[临时文本]#a,_模块1)...
        ->+[code](+[做],写模块)...
        ->+[python](Python,+[临时文本]#内部)->+[code](+[python],P代码2)...
        ->+[s]"text_a"(+[python],+[临时文本]#a)...
        ->+[s]"text_0"(+[python],+[临时文本]#内部)
}...

->_re"函数|内容|条件"(_模块,)->+[标题](_re,)...
->+[python](Python,_文本)->+[code](+[python],P代码)...
    ->+[s]"var_name"(+[python],_re)->+[s]"pt_name"(+[python],+[标题])...
    ->+[s]"text_0"(+[python],+[临时文本]#内部)...

->[]{
    []:->顺序(_模块,_模块1)->_模块1(,)...
        ->+[做](+[临时文本]#a,_模块1)->+[code](+[做],写模块)...
        ->+[python](Python,_文本)->+[code](+[python],P代码3)...
        ->+[s]"text_a"(+[python],+[临时文本]#a)...
        ->+[s]"text_0"(+[python],_文本),

    ->[]
}

## end
#5040, 105:
"""
写模块:...

"""
+描述模块(_凭依,_模块)->+[del](,+描述模块)...
->的(描述模块,写模块)...

->+[做](_凭依,_模块)->+[code](+[做],写模块)


## end
#5042, 98:

描述模块:...

代码模块:...
如果模块:...

for模块:...
函数模块:...
将条目"for模块"复制为条目"函数模块"

一般模块:...
+[新建阅读窗口](,如果模块)

## end
#5043, 985:
"""
P代码:...
P代码1:...
P代码2:...
收集内容:...
+[新建阅读窗口](,P代码)

"""
+收集块(结构,观察)...

->观察(,_块)->+的(结构,+模块)->+模块"1,1,1"(,_块)->+[o](+收集块,+模块)...
    ->+的#2(结构,+内容)->+内容(+模块,)...
        ->+[code]([想]#0,收集内容)->[想]#0(观察,+内容)...
    ->[投影](,+的)->[投影](,+模块)->[投影](,+的#2)->[投影](,+内容)...

->+[code]([python]#0,P代码1)...
    ->+[.]"func_name"([python]#0,+内容)->+[.]"bk1"([python]#0,+模块)...
    ->[python]#0(Python,+模块)...
->[]{
    []=>然后"运算"(观察,观察#2)->观察#2=>+[code]([想],收集块)...
        ->[想](结构,观察#2)->o([想],模块#2)...
        ->+内部(+模块,模块#2)->+的(结构,+内部)->[投影](,+的)->[投影](,+内部)...
        ->+[code]([python],P代码)...
        ->+[.]"bk1"([python],+模块)->+[.]"bk2"([python],模块#2)...
        ->[python](Python,+模块)
}...
->[]{
    []=>然后"顺序"(观察,观察#2)->观察#2=>+[code]([想],收集块)...
        ->[想](结构,观察#2)->o([想],模块#2)...
        ->+顺序(+模块,模块#2)->+的(结构,+顺序)->[投影](,+的)->[投影](,+顺序)...
        ->+[code]([python],P代码2)...
        ->+[.]"bk1"([python],+模块)->+[.]"bk2"([python],模块#2)...
        ->[python](Python,+模块)
}


## end
#5044, 286:
"""
    ->否则(观察,)->[m_text]"else"(,内容),

"""
+收集内容(观察,内容)...

->观察(,_块)->[]{
    []:->如果(观察,)->[m_text]"if"(,内容),
    ->循环(观察,)->_块(,循环#1)->循环#1->[m_text](循环#1,内容),
    ->函数(观察,)->."函数"(观察,_模块)->_模块(,name)...
        ->[m_text](name,内容)->[m_name](+函数,内容),
    ->[m_text]"code"(,内容)
}



## end
#5047, 1110:
"""
收集内容:...
+[新建阅读窗口](,收集内容)

保存:...

"""
+收集块(结构,观察)...

->观察(,_块)->+的(结构,+模块)->+模块"1,1,1"(,_块)...
    ->+的#2(结构,+内容)->+内容(+模块,)...
        ->+[code]([想]#0,收集内容)->[想]#0(观察,+内容)...
    ->[投影](,+的)->[投影](,+模块)->[投影](,+的#2)->[投影](,+内容)...

->[]{
    []:->条件(观察,条件#1)->条件#1(,_cond)->+的(结构,+模块#2)->+模块#2"1,1,1"...
        ->+条件#2(+模块#2,)->+的#2(结构,+条件#2)->[m_text](_cond,+条件#2)...
        ->[投影](,+的)->[投影](,+模块#2)->[投影](,+的#2)->[投影](,+条件#2)...
        ->+内部(+模块#2,+模块)->+的(结构,+内部)->[投影](,+的)->[投影](,+内部)...
    ->+[o](+收集块,+模块#2),

    ->否则(观察,)...
        ->+模块#2"1,1,1"->+的(结构,+模块#2)->[投影](,+的)->[投影](,+模块#2)...
        ->+内容"else"(+模块#2,)->+的(结构,+内容)->[投影](,+的)->[投影](,+内容)...
        ->+内部(+模块#2,+模块)->+的(结构,+内部)->[投影](,+的)->[投影](,+内部)...
    ->+[o](+收集块,+模块#2),

    ->+[o](+收集块,+模块)
}...

->[]{
    []=>然后"运算"(观察,观察#2)->观察#2=>+[code]([想],收集块)...
        ->[想](结构,观察#2)->o([想],模块#2)...
        ->+内部(+模块,模块#2)->+的(结构,+内部)->[投影](,+的)->[投影](,+内部)
}...
->[]{
    []=>然后"顺序"(观察,观察#2)->观察#2=>+[code]([想],收集块)...
        ->[想](结构,观察#2)->o([想],模块#2)...
        ->+顺序(+模块,模块#2)->+的(结构,+顺序)->[投影](,+的)->[投影](,+顺序)
}


## end
#5049, 244:
"""
收集块:...

"""
+描述结构(_媒介,结构)->+操作(+描述结构,)...

->的(_媒介,起点)->起点(,块)->+观察(+代码块,块)->[观察代码结构](_媒介,+观察)...
->+[code]([想],收集块)->+[.]([想],+操作)->[想](结构,+观察)->o([想],模块)...

->+的(结构,+起点)->+起点(模块,)->[投影](,+的)->[投影](,+起点)...
->+的(+操作,+代码模块)->+代码模块(,模块)



## end
#5052, 451:
"""
描述结构:...
库:...
+[新建阅读窗口](,描述结构)

"""

+生成结构(_媒介,_凭依)->+[del](,+生成结构)...
->的(生成结构,描述结构)->的(生成结构,库)...

->[]{
    []:->的(_凭依,结构)->结构->+[删除结构](,结构),  ->+的(_凭依,+结构)
}->的(_凭依,结构)...
->[]{
    []:->的(_凭依,文本)->文本->+[删除结构](,文本),  ->+的(_凭依,+文本)
}->的(_凭依,文本)...

->+[code]([想],描述结构)->[想](_媒介,结构)...
->操作([想],)->[]{
    []=>的(操作,_操作)->_操作(,_模块)->_模块=>[说]"操作: "(,_操作)...
        ->的(库,_条目)->_条目->[eq](_条目,_操作)...
        ->+[做](文本,_模块)->+[code](+[做],_条目)
}



## end
#5055, 21:


生成结构:...
整理结构:...


## end
#5056, 153:
"""

"""

+召唤规则(_题目,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_代码)...

->[==]"代码结构转代码"(,召唤星辰)...

->+整理结构(_题目,_代码)->+的(操作,+整理结构)...
->+生成结构(_题目,_代码)->+的(操作,+生成结构)



## end
#5059, 23:


召唤规则:...
降临规则:...




## end
#5062, 260:
main
├if
|├a==1────a==2──────────────────────else
|└code    if                        code
|         ├b==2────else                 
|         └code    if                   
|                  ├b==2────else        
|                  └code    code        
└code
## end
#5064, 222:
"""

"""

+召唤规则(_题目,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_代码)...

->[==]"代码结构转流程图"(,召唤星辰)...

->+整理结构(_题目,_代码)->+的(操作,+整理结构)...
->+模块连线(_题目,_代码)->+的(操作,+模块连线)...
->+布置位置(_题目,_代码)->+的(操作,+布置位置)...
->+生成结构(_题目,_代码)->+的(操作,+生成结构)



## end
#5066, 21232:
代码结构转流程图#0"

召唤规则:...
降临规则:...



"(,)
的#1""(代码结构转流程图#0,召唤规则#2)
召唤规则#2"\"\"\"

\"\"\"

+召唤规则(_题目,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_代码)...

->[==]\"代码结构转流程图\"(,召唤星辰)...

->+整理结构(_题目,_代码)->+的(操作,+整理结构)...
->+模块连线(_题目,_代码)->+的(操作,+模块连线)...
->+布置位置(_题目,_代码)->+的(操作,+布置位置)...
->+生成结构(_题目,_代码)->+的(操作,+生成结构)


"(,)
的#3""(代码结构转流程图#0,降临规则#4)
降临规则#4"

生成结构:...
布置位置:...
模块连线:...
整理结构:...
+[新建阅读窗口](,生成结构)

"(,)
的#5""(降临规则#4,生成结构#6)
生成结构#6"\"\"\"
描述结构:...
库:...

\"\"\"

+生成结构(_媒介,_凭依)->+[del](,+生成结构)...
->的(生成结构,描述结构)->的(生成结构,库)...

->[]{
    []:->的(_凭依,结构)->结构->+[删除结构](,结构),
    ->+的(_凭依,+结构)
}->的(_凭依,结构)...

->+[code]([想],描述结构)->[想](_媒介,结构)...
->操作([想],)->[]{
    []=>的(操作,_操作)->_操作(,_模块)->_模块=>[说]\"操作: \"(,_操作)...
        ->的(库,_条目)->_条目->[eq](_条目,_操作)...
        ->+[做](_凭依,_模块)->+[code](+[做],_条目)
}


"(,)
的#7""(生成结构#6,描述结构#8)
描述结构#8"\"\"\"
收集块:...

\"\"\"
+描述结构(_媒介,结构)->+操作(+描述结构,)...

->的(_媒介,起点)->起点(,块)->+观察(+代码块,块)->[观察代码结构](_媒介,+观察)...
->+[code]([想],收集块)->[想](结构,+观察)->o([想],模块)...
->+起点(,模块)->+的(结构,+起点)->[投影](,+起点)->[投影](,+的)...

->+描述模块(,模块)->+的(+操作,+描述模块)

"(,)
的#9""(描述结构#8,收集块#10)
收集块#10"\"\"\"
P代码:...
P代码1:...
P代码2:...
+[新建阅读窗口](,P代码)

收集内容:...
后处理:...

保存:...
+[新建阅读窗口](,保存)

\"\"\"
+收集块(结构,观察)...

->观察(,_块)->+的(结构,+模块)->+模块\"0,1,0,1\"(,_块)...
    ->+的#2(结构,+内容)->+内容(+模块,)...
        ->+[code]([想]#0,收集内容)->+[.]([想]#0,+类型)->[想]#0(观察,+内容)...
    ->[投影](,+的)->[投影](,+模块)->[投影](,+的#2)->[投影](,+内容)...

->[]{
    []=>然后\"运算\"(观察,观察#2)->观察#2=>+[code]([想],收集块)...
        ->[想](结构,观察#2)->o([想],模块#2)...
        ->+内部(+模块,模块#2)->+的(结构,+内部)->[投影](,+的)->[投影](,+内部)...
        ->+[code]([python],P代码)...
        ->+[.]\"bk1\"([python],+模块)->+[.]\"bk2\"([python],模块#2)...
        ->[python](Python,+模块)
}...

->+[code]([python]#0,P代码1)->+[s]\"func_type\"([python]#0,+类型)...
->+[s]\"func_name\"([python]#0,+内容)->+[.]\"bk1\"([python]#0,+模块)...
->[python]#0(Python,+模块)...

->[]{
    []=>然后\"顺序\"(观察,观察#2)->观察#2=>+[code]([想],收集块)...
        ->[想](结构,观察#2)->o([想],模块#2)...
        ->+顺序(+模块,模块#2)->+的(结构,+顺序)->[投影](,+的)->[投影](,+顺序)...
        ->+[code]([python],P代码2)...
        ->+[.]\"bk1\"([python],+模块)->+[.]\"bk2\"([python],模块#2)...
        ->[python](Python,+模块)
}...

->+[code]([想],后处理)->[想](+收集块,+模块)

"(,)
的#11""(收集块#10,P代码#12)
P代码#12"\"\"\"
记住\"Python\"
print(np.max([1,2]))
print(func_name)

\"\"\"

state=True
bk1[0]+=bk2[0]
bk1[1]=np.max([bk1[1],bk2[1]])
# bk1[2]=bk1[1]
ans=bk1
"(,)
的#13""(收集块#10,P代码2#14)
P代码2#14"\"\"\"


\"\"\"
state=True
bk1[1]+=bk2[1]
ans=bk1
"(,)
的#15""(收集块#10,收集内容#16)
收集内容#16"\"\"\"
保存:...

\"\"\"
+收集内容(观察,内容)->.(+收集内容,类型)...

->[]{
    []:->如果(观察,)->[m_text]\"if\"(,内容)->[m_text]\"如果\"(,类型),
    ->循环(观察,)->[m_text]\"loop\"(,内容)->[m_text]\"循环\"(,类型),
    ->函数(观察,)->.\"函数\"(观察,_模块)->_模块(,name)...
        ->[m_text](name,内容)->[m_name](+函数,内容)->[m_text]\"函数\"(,类型),
    ->[m_text]\"code\"(,内容)->[m_text]\"运算\"(,类型)
}


"(,)
的#17""(收集内容#16,保存#18)
保存#18"\"\"\"


\"\"\"
+收集内容(观察,内容)->.(+收集内容,类型)...

->[]{
    []:->如果(观察,)->[m_text]\"if\"(,内容),
    ->条件(观察,条件#1)->条件#1(,_cond)...
        ->[m_text](_cond,内容)->[m_name](+条件,内容),
    ->否则(观察,)->[m_text]\"else\"(,内容),
    ->循环(观察,)->[m_text]\"loop\"(,内容),
    ->函数(观察,)->.\"函数\"(观察,_模块)->_模块(,name)...
        ->[m_text](name,内容)->[m_name](+函数,内容),
    ->[m_text]\"code\"(,内容)
}


"(,)
的#19""(收集块#10,P代码1#20)
P代码1#20"\"\"\"
记住\"Python\"
print(func_type)

\"\"\"

state=True

bk1[0]=np.max([len(func_name),bk1[0]])
bk1[2]=np.max([len(func_name),bk1[0]])


if func_type==\"如果\":
    bk1[1]=bk1[1]+1
elif func_type==\"函数\":
    bk1[1]=bk1[1]+1
bk1[3]=bk1[1]

ans=bk1

"(,)
的#21""(收集块#10,保存#22)
保存#22"\"\"\"
P代码:...
P代码1:...
P代码2:...
收集内容:...
+[新建阅读窗口](,P代码)

保存:...

\"\"\"
+收集块(结构,观察)...

->观察(,_块)->+的(结构,+模块)->+模块\"1,1,1\"(,_块)...
    ->+的#2(结构,+内容)->+内容(+模块,)...
        ->+[code]([想]#0,收集内容)->[想]#0(观察,+内容)...
    ->[投影](,+的)->[投影](,+模块)->[投影](,+的#2)->[投影](,+内容)...

->[]{
    []:->条件(观察,条件#1)->条件#1(,_cond)->+的(结构,+模块#2)->+模块#2\"1,1,1\"...
        ->+条件#2(+模块#2,)->+的#2(结构,+条件#2)->[m_text](_cond,+条件#2)...
        ->[投影](,+的)->[投影](,+模块#2)->[投影](,+的#2)->[投影](,+条件#2)...
        ->+内部(+模块#2,+模块)->+的(结构,+内部)->[投影](,+的)->[投影](,+内部)...
    ->+[o](+收集块,+模块#2),

    ->+[o](+收集块,+模块)
}...

->+[code]([python]#0,P代码1)...
    ->+[.]\"func_name\"([python]#0,+内容)->+[.]\"bk1\"([python]#0,+模块)...
    ->[python]#0(Python,+模块)...
->[]{
    []=>然后\"运算\"(观察,观察#2)->观察#2=>+[code]([想],收集块)...
        ->[想](结构,观察#2)->o([想],模块#2)...
        ->+内部(+模块,模块#2)->+的(结构,+内部)->[投影](,+的)->[投影](,+内部)...
        ->+[code]([python],P代码)...
        ->+[.]\"bk1\"([python],+模块)->+[.]\"bk2\"([python],模块#2)...
        ->[python](Python,+模块)
}...
->[]{
    []=>然后\"顺序\"(观察,观察#2)->观察#2=>+[code]([想],收集块)...
        ->[想](结构,观察#2)->o([想],模块#2)...
        ->+顺序(+模块,模块#2)->+的(结构,+顺序)->[投影](,+的)->[投影](,+顺序)...
        ->+[code]([python],P代码2)...
        ->+[.]\"bk1\"([python],+模块)->+[.]\"bk2\"([python],模块#2)...
        ->[python](Python,+模块)
}

"(,)
的#23""(收集块#10,后处理#24)
后处理#24"\"\"\"
P代码:...

\"\"\"

+后处理(收集块,模块)...

->收集块(结构,观察)->结构->观察(,)...
->+[code]([python],P代码)->[python](Python,+模块#2)...
->[]{
    []:->条件(观察,条件#1)->条件#1(,_cond)->+的(结构,+模块#2)...
        ->+条件#2(+模块#2,)->+的#2(结构,+条件#2)->[m_text](_cond,+条件#2)...
        ->[投影](,+的)->[投影](,+模块#2)->[投影](,+的#2)->[投影](,+条件#2)...
        ->+顺序(+模块#2,模块)->+的(结构,+顺序)->[投影](,+的)->[投影](,+顺序)...
    ->+[o](收集块,+模块#2),

    ->否则(观察,)...
        ->+的(结构,+模块#2)->[投影](,+的)->[投影](,+模块#2)...
        ->+内容\"else\"(+模块#2,)->+的(结构,+内容)->[投影](,+的)->[投影](,+内容)...
        ->+顺序(+模块#2,模块)->+的(结构,+顺序)->[投影](,+的)->[投影](,+顺序)...
    ->+[o](收集块,+模块#2),

    ->+[o](收集块,模块)
}



"(,)
的#25""(后处理#24,P代码#26)
P代码#26"\"\"\"


\"\"\"

state=True
ans=bk1
ans[1]+=0.5
ans[3]=0.5

"(,)
的#27""(生成结构#6,库#28)
库#28"
描述模块:...


"(,)
的#29""(库#28,描述模块#30)
描述模块#30"\"\"\"
写模块:...

\"\"\"
+描述模块(_凭依,_模块)->+[del](,+描述模块)...
->的(描述模块,写模块)...

->+[做](_凭依,_模块)->+[code](+[做],写模块)

"(,)
的#31""(描述模块#30,写模块#32)
写模块#32"\"\"\"
P代码:...
P代码b:...
P代码2:...
P代码3:...

\"\"\"
+写模块(_文本,_模块)->+[del](,+写模块)...
->的(写模块,P代码)...
->的(写模块,P代码2)->的(写模块,P代码3)...

->+[临时文本]#内部->[]{
    []=>内部(_模块,_模块1)->_模块1=>+[做](+[临时文本]#a,_模块1)...
        ->+[code](+[做],写模块)...
        ->+[python](Python,+[临时文本]#内部)->+[code](+[python],P代码2)...
        ->+[s]\"text_a\"(+[python],+[临时文本]#a)...
        ->+[s]\"text_0\"(+[python],+[临时文本]#内部)
}...

->_re\"函数|内容|条件\"(_模块,)->+[标题](_re,)...
->+[python](Python,_文本)->+[code](+[python],P代码)...
    ->+[s]\"var_name\"(+[python],_re)->+[s]\"pt_name\"(+[python],+[标题])...
    ->+[s]\"text_0\"(+[python],+[临时文本]#内部)...

->[]{
    []:->顺序(_模块,_模块1)->_模块1(,)...
        ->+[做](+[临时文本]#a,_模块1)->+[code](+[做],写模块)...
        ->+[python](Python,_文本)->+[code](+[python],P代码3)...
        ->+[s]\"text_a\"(+[python],+[临时文本]#a)...
        ->+[s]\"text_0\"(+[python],_文本),

    ->[]
}
"(,)
的#33""(写模块#32,P代码#34)
P代码#34"\"\"\"
    text_0=str_a+text_0.replace(\"\n\",\"\n\"+str_a)
print(text_0)
print(text_1)
+[P函数](,P代码)

\"\"\"
# print(var_name,pt_name)
if text_0==\"\":
    ans=var_name
else:
    str_a=\"├\"
    list_line=text_0.split(\"\n\")
    list_line_1=[]
    n_last=0
    for i in range(len(list_line)):
        line=list_line[i]
        if line[0]==\"|\" or line[0]==\"├\" or line[0]==\"└\" or line[0]==\" \":
            line=\"|\"+line
        else:
            n_last=i
            line=\"├\"+line
        list_line_1.append(line)
    for i in range(n_last,len(list_line_1)):
        if list_line_1[i][0]==\"|\":
            list_line_1[i]=' '+list_line_1[i][1:]
        else:
            list_line_1[i]='└'+list_line_1[i][1:]

    text_1=\"\n\".join(list_line_1)
    ans=var_name+\"\n\"+text_1


\"\"\"
print(text_1)
+[P函数](,P代码)

\"\"\""(,)
的#35""(写模块#32,P代码2#36)
P代码2#36"\"\"\"
记住\"Python\"
+[P函数](,P代码2)
测试:...

\"\"\"
import numpy as np

ans=\"\"
pat_line_0=\"{s:─<{n}}\"
pat_line_1=\"{s: <{n}}\"
if text_0!=\"\":
    list_line_0=text_0.split(\"\n\")
    n_0=np.max([len(line) for line in list_line_0])
    l_0=len(list_line_0)
    list_line_a=text_a.split(\"\n\")
    n_a=np.max([len(line) for line in list_line_a])
    l_a=len(list_line_a)

    for i in range(np.max([l_a,l_0])):
        pat_line=pat_line_1

        if i>=l_a:
            line_a=pat_line.format(s=\" \",n=n_a)
        else:
            line_a=pat_line.format(s=list_line_a[i],n=n_a)
        
        if i>=l_0:
            line_0=pat_line.format(s=\" \",n=n_0)
        else:
            line_0=pat_line.format(s=list_line_0[i],n=n_0)

        if i==0:
            line_a=line_a.replace(\" \",\"─\")
            ans+=line_a+\"────\"+line_0+\"\n\"
        else:
            ans+=line_a+\"    \"+line_0+\"\n\"

    ans=ans[0:-1]
else:
    ans=text_a



"(,)
的#37""(P代码2#36,测试#38)
测试#38"\"\"\"
+[P函数](,测试)

\"\"\"
text_a=\"\"\"
aaa
c
v
\"\"\"
text_0=text_a

list_line=text_0.split(\"\n\")
list_ns=[len(line) for line in list_line]
print(list_ns)




\"\"\"
+[P函数](,测试)
print('{s:X<{n}}'.format(s=\"11\",n=10))
print(f'{\"dog\": <10}'+'1')
print(f'{\"%s\":X<10}'%(\"AAA\"))

\"\"\""(,)
的#39""(写模块#32,P代码3#40)
P代码3#40"\"\"\"


\"\"\"

ans=text_0+\"\n\"+text_a
"(,)
的#41""(写模块#32,P代码b#42)
P代码b#42""(,)
的#43""(降临规则#4,整理结构#44)
整理结构#44"\"\"\"


\"\"\"
+整理结构(_媒介,_凭依)->+[del](,+整理结构)...

->的(_凭依,召唤规则)->+[删除结构](,召唤规则)->+[del](,召唤规则)...
->的(_凭依,降临规则)->+[删除结构](,降临规则)->+[del](,降临规则)...
->+[记住](,_凭依)->+[修改内容](_凭依,+[显示])

"(,)
的#45""(降临规则#4,模块连线#46)
模块连线#46"\"\"\"
描述结构:...
库:...
+[新建阅读窗口](,库)
+[新建阅读窗口](,描述结构)

\"\"\"

+模块连线(_媒介,_凭依)->+[del](,+模块连线)...
->的(模块连线,描述结构)->的(模块连线,库)...

->的(_凭依,结构)...
->+[code]([想],描述结构)->[想](_媒介,结构)...
->操作([想],)->[]{
    []=>的(操作,_操作)->_操作(_模块1,_模块2)->_模块1->_模块2(,)...
        =>[说]\"连线: \"(,_操作)->的(库,_条目)->_条目->[eq](_条目,_操作)...
        ->+[做](_模块1,_模块2)->+[code](+[做],_条目)->+[.](+[做],_凭依)
}


"(,)
的#47""(模块连线#46,描述结构#48)
描述结构#48"\"\"\"
绘制模块:...

\"\"\"
+描述结构(_媒介,结构)->+操作(+描述结构,)...

->的(结构,起点)->起点(,模块)...
->+[code]([想],绘制模块)->+[.]([想],+操作)->[想](结构,模块)


"(,)
的#49""(描述结构#48,绘制模块#50)
绘制模块#50"\"\"\"
连线类型:...

\"\"\"

+绘制模块(结构,模块)->.(+绘制模块,操作)...

->+结构->[]{
    []=>内部(模块,模块#2)->模块#2=>+[code]([想],绘制模块)->+[.]([想],操作)...
        ->[想](结构,模块#2)
}...

->[]{
    []:->顺序(模块,模块#2)->模块#2->+[code]([想],绘制模块)->+[.]([想],操作)...
        ->[想](结构,模块#2),
    ->[]
}...

->+[code]([想]#0,连线类型)->[想]#0(操作,模块)


"(,)
的#51""(绘制模块#50,连线类型#52)
连线类型#52"\"\"\"


\"\"\"
+连线类型(操作,模块)...

->[]{
    []:->顺序(模块,模块#2)->模块#2->+画顺序(模块,模块#2)->+的(操作,+画顺序),
    ->[]
}...
->[]{
    []:->内容\"if\"(模块,)=>内部(模块,模块#2)->模块#2->结尾(模块#2,模块#3)...
        =>+画if开头(模块,模块#2)->+的(操作,+画if开头)...
        ->+画if结尾(模块,模块#3)->+的(操作,+画if结尾),
    ->[]
}


"(,)
的#53""(模块连线#46,库#54)
库#54"+[删除结构](,库)


画顺序:...
画if开头:...
画if结尾:...

"(,)
的#55""(库#54,画顺序#56)
画顺序#56"\"\"\"
M代码:...

\"\"\"
+画顺序(模块#1,模块#2)->+[del](,+画顺序)...
->的(画顺序,M代码)...

->.(+画顺序,_凭依)...
->是(模块#1,_模块1)->在(_模块1,空间点#1)...
->是(模块#2,_模块2)->在(_模块2,空间点#2)...

->+的(_凭依,+连线)...
->+连线(_模块1,_模块2)->+样式\"折线\"(+连线,)->+的(+连线,+样式)...
->+的(+连线,+x)->+的(+连线,+y)...

->+[matlab](Matlab,)->+[code](+[matlab],M代码)...
->+[.]\"pt1\"(+[matlab],空间点#1)->+[.]\"pt2\"(+[matlab],空间点#2)...
->+[.]\"siz1\"(+[matlab],模块#1)->+[.]\"siz2\"(+[matlab],模块#2)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)



"(,)
的#57""(画顺序#56,M代码#58)
M代码#58"%{

%}


L=siz1(4)-0.3;

x=[pt1(1),pt2(1)];
y=[pt1(2)-L,pt2(2)];


"(,)
的#59""(库#54,画if开头#60)
画if开头#60""(,)
的#61""(库#54,画if结尾#62)
画if结尾#62""(,)
的#63""(降临规则#4,布置位置#64)
布置位置#64"\"\"\"
描述结构:...
库:...
+[新建阅读窗口](,库)
+[新建阅读窗口](,描述结构)

\"\"\"

+布置位置(_媒介,_凭依)->+[del](,+布置位置)...
->的(布置位置,描述结构)->的(布置位置,库)...

->的(_凭依,结构)...
->+[code]([想],描述结构)->[想](_媒介,结构)...
->操作([想],)->[]{
    []=>的(操作,_操作)->_操作(,_模块)->_模块=>[说]\"操作: \"(,_操作)...
        ->的(库,_条目)->_条目->[eq](_条目,_操作)...
        ->+[做](_凭依,_模块)->+[code](+[做],_条目)
}


"(,)
的#65""(布置位置#64,库#66)
库#66"
绘制如果:...
绘制条件:...
绘制否则:...
+[新建阅读窗口](,绘制如果)
将条目\"绘制条件\"复制为条目\"绘制否则\"

绘制函数:...
将条目\"绘制运算\"复制为条目\"绘制函数\"

绘制运算:...


"(,)
的#67""(库#66,绘制条件#68)
绘制条件#68"\"\"\"
M代码:...
M代码0:...
M代码2:...
M代码3:...

保存:...

\"\"\"

+绘制条件(_凭依,模块)->+[del](,+绘制条件)...
->的(绘制条件,M代码)->的(绘制条件,M代码2)->的(绘制条件,M代码0)...
->的(绘制条件,M代码3)...

->+的(_凭依,+条件模块)->+在(+条件模块,+空间点)->+是(模块,+条件模块)...
->+的(+条件模块,+在)->+的(+条件模块,+空间点)->+的(模块,+是)...

->条件(模块,)->+[修改内容](条件,+条件模块)...
->+[matlab](Matlab,+空间点)->+[.]\"siz0\"(+[matlab],模块)...
->[]{
    []:->相邻(模块,模块#1)->模块#1->是(模块#1,_模块1)->在(_模块1,空间点#1)...
        ->+[code](+[matlab],M代码)...
        ->+[.]\"siz1\"(+[matlab],模块#1)->+[.]\"pt1\"(+[matlab],空间点#1),

    ->内部(模块#2,模块)->模块#2->是(模块#2,_模块2)->在(_模块2,空间点#2)...
        ->+[code](+[matlab],M代码2)...
        ->+[.]\"siz1\"(+[matlab],模块#2)->+[.]\"pt1\"(+[matlab],空间点#2),

    ->+[code](+[matlab],M代码0)
}


"(,)
的#69""(绘制条件#68,保存#70)
保存#70"\"\"\"
M代码:...
M代码0:...
M代码2:...
M代码3:...

\"\"\"

+绘制条件(_凭依,模块)->+[del](,+绘制条件)...
->的(绘制条件,M代码)->的(绘制条件,M代码2)->的(绘制条件,M代码0)...
->的(绘制条件,M代码3)...

->+的(_凭依,+条件模块)->+在(+条件模块,+空间点)->+是(模块,+条件模块)...
->+的(+条件模块,+在)->+的(+条件模块,+空间点)->+的(模块,+是)...

->+样式\"多边形\"(+条件模块,)->+的(+条件模块,+样式)...
->+的(+条件模块,+宽度)->+的(+条件模块,+长度)...
->+的(+条件模块,+x)->+的(+条件模块,+y)...

->+[matlab](Matlab,)->+[code](+[matlab],M代码3)->+[.]\"siz0\"(+[matlab],模块)...
->+[o]\"W\"(+[matlab],+宽度)->+[o]\"L\"(+[matlab],+长度)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)...

->+[matlab](Matlab,+空间点)...
->[]{
    []:->相邻(模块,模块#1)->模块#1->是(模块#1,_模块1)->在(_模块1,空间点#1)...
        ->+[code](+[matlab],M代码)...
        ->+[.]\"siz1\"(+[matlab],模块#1)->+[.]\"pt1\"(+[matlab],空间点#1),

    ->内部(模块#2,模块)->模块#2->是(模块#2,_模块2)->在(_模块2,空间点#2)...
        ->+[code](+[matlab],M代码2)...
        ->+[.]\"siz1\"(+[matlab],模块#2)->+[.]\"pt1\"(+[matlab],空间点#2),

    ->+[code](+[matlab],M代码0)
}


"(,)
的#71""(绘制条件#68,M代码3#72)
M代码3#72"%{

%}

W=siz0(3);
L=siz0(4);

x=[-1,1,1,-1]*W/2;
y=-[0,0,1,1]*L;

"(,)
的#73""(绘制条件#68,M代码0#74)
M代码0#74"%{

%}

ans=[0,0];


"(,)
的#75""(绘制条件#68,M代码2#76)
M代码2#76"%{
记住\"Matlab\"
siz0
siz1
%}

ans=[siz1(1)/2-siz0(3)/2,-0.7]+pt1;



"(,)
的#77""(绘制条件#68,M代码#78)
M代码#78"%{
-siz0(3)/2
%}

ans=[-siz0(1)/2-siz1(1)/2,0]+pt1;


"(,)
的#79""(库#66,绘制运算#80)
绘制运算#80"\"\"\"
M代码:...
M代码0:...
M代码2:...
M代码3:...

\"\"\"

+绘制运算(_凭依,模块)->+[del](,+绘制运算)...
->的(绘制运算,M代码)->的(绘制运算,M代码2)->的(绘制运算,M代码0)...
->的(绘制运算,M代码3)...

->+的(_凭依,+运算模块)->+在(+运算模块,+空间点)->+是(模块,+运算模块)...
->+的(+运算模块,+在)->+的(+运算模块,+空间点)->+的(模块,+是)...

->+[matlab](Matlab,+空间点)->+[.]\"siz0\"(+[matlab],模块)...
->[]{
    []:->顺序(模块#1,模块)->模块#1->是(模块#1,_模块1)->在(_模块1,空间点#1)...
        ->+[code](+[matlab],M代码)...
        ->+[.]\"siz1\"(+[matlab],模块#1)->+[.]\"pt1\"(+[matlab],空间点#1),

    ->内部(模块#2,模块)->模块#2->是(模块#2,_模块2)->在(_模块2,空间点#2)...
        ->+[code](+[matlab],M代码2)...
        ->+[.]\"siz1\"(+[matlab],模块#2)->+[.]\"pt1\"(+[matlab],空间点#2),

    ->+[code](+[matlab],M代码0)
}...


->+样式\"多边形\"(+运算模块,)->+的(+运算模块,+样式)...
->+的(+运算模块,+宽度)->+的(+运算模块,+长度)...
->+的(+运算模块,+x)->+的(+运算模块,+y)...

->+文字\"code\"->+的(_凭依,+文字)->+的(+运算模块,+文字)...
->+的(+文字,+文字位置)->+文字位置\"居中\"...
->+在(+文字,+空间点#2)->+的(+文字,+在)->+的(+文字,+空间点#2)...

->+[matlab](Matlab,+空间点#2)->+[code](+[matlab],M代码3)...
->+[.]\"pt0\"(+[matlab],+空间点)...
->+[o]\"W\"(+[matlab],+宽度)->+[o]\"L\"(+[matlab],+长度)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)


"(,)
的#81""(绘制运算#80,M代码3#82)
M代码3#82"%{

%}

W=siz0(3)-1;
L=siz0(4)-0.3;

x=[-1,1,1,-1]*W/2;
y=-[0,0,1,1]*L;

ans=pt0+[0,-1/2]*L;"(,)
的#83""(绘制运算#80,M代码0#84)
M代码0#84"%{

%}

ans=[0,0];


"(,)
的#85""(绘制运算#80,M代码2#86)
M代码2#86"%{
记住\"Matlab\"
siz0
siz1
%}

ans=[0,-1]+pt1;



"(,)
的#87""(绘制运算#80,M代码#88)
M代码#88"%{

%}

ans=[0,-siz1(4)]+pt1;


"(,)
的#89""(库#66,绘制函数#90)
绘制函数#90"\"\"\"
M代码:...
M代码0:...
M代码2:...
M代码3:...

\"\"\"

+绘制函数(_凭依,模块)->+[del](,+绘制函数)...
->的(绘制函数,M代码)->的(绘制函数,M代码2)->的(绘制函数,M代码0)...
->的(绘制函数,M代码3)...

->函数(模块,)...
->+的(_凭依,+函数模块)->+在(+函数模块,+空间点)->+是(模块,+函数模块)...
->+的(+函数模块,+在)->+的(+函数模块,+空间点)->+的(模块,+是)...

->+[matlab](Matlab,+空间点)->+[.]\"siz0\"(+[matlab],模块)...
->[]{
    []:->顺序(模块#1,模块)->模块#1->是(模块#1,_模块1)->在(_模块1,空间点#1)...
        ->+[code](+[matlab],M代码)...
        ->+[.]\"siz1\"(+[matlab],模块#1)->+[.]\"pt1\"(+[matlab],空间点#1),

    ->内部(模块#2,模块)->模块#2->是(模块#2,_模块2)->在(_模块2,空间点#2)...
        ->+[code](+[matlab],M代码2)...
        ->+[.]\"siz1\"(+[matlab],模块#2)->+[.]\"pt1\"(+[matlab],空间点#2),

    ->+[code](+[matlab],M代码0)
}...

->+样式\"多边形\"(+函数模块,)->+的(+函数模块,+样式)...
->+的(+函数模块,+宽度)->+的(+函数模块,+长度)...
->+的(+函数模块,+x)->+的(+函数模块,+y)...

->+文字->[m_text](函数,+文字)->+的(_凭依,+文字)->+的(+函数模块,+文字)...
->+的(+文字,+文字位置)->+文字位置\"居中\"...
->+在(+文字,+空间点#2)->+的(+文字,+在)->+的(+文字,+空间点#2)...

->+[matlab](Matlab,+空间点#2)->+[code](+[matlab],M代码3)...
->+[.]\"pt0\"(+[matlab],+空间点)...
->+[o]\"W\"(+[matlab],+宽度)->+[o]\"L\"(+[matlab],+长度)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)

"(,)
的#91""(绘制函数#90,M代码3#92)
M代码3#92"%{

%}

W=siz0(1);
L=siz0(2);

x=[-1,1,1,-1]*W/2;
y=[0,0,-1,-1]*L;

% ans=pt0+[-1,0]*W/2+[1,1];
ans=pt0+[0,-0.5];

"(,)
的#93""(绘制函数#90,M代码#94)
M代码#94"%{

%}

ans=[0,-siz1(4)]+pt1;


"(,)
的#95""(绘制函数#90,M代码2#96)
M代码2#96"%{
记住\"Matlab\"
siz0
siz1
%}

ans=[0,-siz1(2)]+pt1;



"(,)
的#97""(绘制函数#90,M代码0#98)
M代码0#98"%{

%}

ans=[0,0];


"(,)
的#99""(库#66,绘制否则#100)
绘制否则#100"\"\"\"
M代码:...
M代码0:...
M代码2:...
M代码3:...

保存:...

\"\"\"

+绘制否则(_凭依,模块)->+[del](,+绘制否则)...
->的(绘制否则,M代码2)->的(绘制否则,M代码0)...
->的(绘制否则,M代码3)...

->+的(_凭依,+否则模块)->+在(+否则模块,+空间点)->+是(模块,+否则模块)...
->+的(+否则模块,+在)->+的(+否则模块,+空间点)->+的(模块,+是)...

->+[修改内容]\"else\"(,+否则模块)...

->+[matlab](Matlab,+空间点)->+[.]\"siz0\"(+[matlab],模块)...
->[]{
    []:->内部(模块#2,模块)->模块#2->是(模块#2,_模块2)->在(_模块2,空间点#2)...
        ->+[code](+[matlab],M代码2)...
        ->+[.]\"siz1\"(+[matlab],模块#2)->+[.]\"pt1\"(+[matlab],空间点#2),

    ->+[code](+[matlab],M代码0)
}


"(,)
的#101""(绘制否则#100,保存#102)
保存#102"\"\"\"
M代码:...
M代码0:...
M代码2:...
M代码3:...

保存:...

\"\"\"

+绘制否则(_凭依,模块)->+[del](,+绘制否则)...
->的(绘制否则,M代码2)->的(绘制否则,M代码0)...
->的(绘制否则,M代码3)...

->+的(_凭依,+否则模块)->+在(+否则模块,+空间点)->+是(模块,+否则模块)...
->+的(+否则模块,+在)->+的(+否则模块,+空间点)->+的(模块,+是)...

->+样式\"多边形\"(+否则模块,)->+的(+否则模块,+样式)...
->+的(+否则模块,+宽度)->+的(+否则模块,+长度)...
->+的(+否则模块,+x)->+的(+否则模块,+y)...

->+[matlab](Matlab,)->+[code](+[matlab],M代码3)->+[.]\"siz0\"(+[matlab],模块)...
->+[o]\"W\"(+[matlab],+宽度)->+[o]\"L\"(+[matlab],+长度)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)...

->+[matlab](Matlab,+空间点)...
->[]{
    []:->内部(模块#2,模块)->模块#2->是(模块#2,_模块2)->在(_模块2,空间点#2)...
        ->+[code](+[matlab],M代码2)...
        ->+[.]\"siz1\"(+[matlab],模块#2)->+[.]\"pt1\"(+[matlab],空间点#2),

    ->+[code](+[matlab],M代码0)
}


"(,)
的#103""(绘制否则#100,M代码3#104)
M代码3#104"%{

%}

W=siz0(3);
L=siz0(4);

x=[-1,1,1,-1]*W/2;
y=-[0,0,1,1]*L;

"(,)
的#105""(绘制否则#100,M代码#106)
M代码#106"%{

%}

ans=[siz0(1),0]+pt1;


"(,)
的#107""(绘制否则#100,M代码2#108)
M代码2#108"%{
记住\"Matlab\"
siz0
siz1
%}

ans=[siz1(1)/2-siz0(3)/2,-0.7]+pt1;



"(,)
的#109""(绘制否则#100,M代码0#110)
M代码0#110"%{

%}

ans=[0,0];


"(,)
的#111""(库#66,绘制如果#112)
绘制如果#112"\"\"\"
M代码:...
M代码0:...
M代码2:...
M代码3:...

\"\"\"

+绘制如果(_凭依,模块)->+[del](,+绘制如果)...
->的(绘制如果,M代码)->的(绘制如果,M代码2)->的(绘制如果,M代码0)...
->的(绘制如果,M代码3)...

->+的(_凭依,+如果模块)->+在(+如果模块,+空间点)->+是(模块,+如果模块)...
->+的(+如果模块,+在)->+的(+如果模块,+空间点)->+的(模块,+是)...

->+[matlab](Matlab,+空间点)->+[.]\"siz0\"(+[matlab],模块)...
->[]{
    []:->顺序(模块#1,模块)->模块#1->是(模块#1,_模块1)->在(_模块1,空间点#1)...
        ->+[code](+[matlab],M代码)...
        ->+[.]\"siz1\"(+[matlab],模块#1)->+[.]\"pt1\"(+[matlab],空间点#1),

    ->内部(模块#2,模块)->模块#2->是(模块#2,_模块2)->在(_模块2,空间点#2)...
        ->+[code](+[matlab],M代码2)...
        ->+[.]\"siz1\"(+[matlab],模块#2)->+[.]\"pt1\"(+[matlab],空间点#2),

    ->+[code](+[matlab],M代码0)
}...

->+样式\"多边形\"(+如果模块,)->+的(+如果模块,+样式)...
->+的(+如果模块,+宽度)->+的(+如果模块,+长度)...
->+的(+如果模块,+x)->+的(+如果模块,+y)...

->+文字\"if\"->+的(_凭依,+文字)->+的(+如果模块,+文字)...
->+的(+文字,+文字位置)->+文字位置\"居中\"...
->+在(+文字,+空间点#2)->+的(+文字,+在)->+的(+文字,+空间点#2)...

->+[matlab](Matlab,+空间点#2)->+[code](+[matlab],M代码3)...
->+[.]\"pt0\"(+[matlab],+空间点)...
->+[o]\"W\"(+[matlab],+宽度)->+[o]\"L\"(+[matlab],+长度)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)


"(,)
的#113""(绘制如果#112,M代码3#114)
M代码3#114"%{

%}

W=2;
L=1-0.3;

x=[-1,0,1,0]*W/2;
y=-[1/2,0,1/2,1]*L;

ans=pt0+[0,-1/2]*L;
"(,)
的#115""(绘制如果#112,M代码0#116)
M代码0#116"%{

%}

ans=[0,0];


"(,)
的#117""(绘制如果#112,M代码2#118)
M代码2#118"%{
记住\"Matlab\"
siz0
siz1
%}

ans=[0,-1]+pt1;



"(,)
的#119""(绘制如果#112,M代码#120)
M代码#120"%{

%}

ans=[0,-siz1(4)]+pt1;


"(,)
的#121""(布置位置#64,描述结构#122)
描述结构#122"\"\"\"
绘制模块:...

\"\"\"
+描述结构(_媒介,结构)->+操作(+描述结构,)...

->的(结构,起点)->起点(,模块)...
->+[code]([想],绘制模块)->+[.]([想],+操作)->[想](结构,模块)


"(,)
的#123""(描述结构#122,绘制模块#124)
绘制模块#124"\"\"\"
模块类型:...

\"\"\"

+绘制模块(结构,模块)->.(+绘制模块,操作)...

->+结构->[]{
    []=>内部(模块,模块#2)->模块#2=>+[code]([想],绘制模块)->+[.]([想],操作)...
        ->[想](结构,模块#2)->结尾([想],模块#3)...
        ->+结尾(模块#2,模块#3)->+的(结构,+结尾)->[投影](,+的)->[投影](,+结尾):
            ->上一个(+结构,)...
                ->+上一个(+结构,模块#1)->模块#1->+[上一个](+结构,模块#2)...
                ->+相邻(模块#1,模块#2)->+的(结构,+相邻)->[投影](,+的)->[投影](,+相邻),
            ->+[上一个](+结构,模块#2)
}...

->[]{
    []:->顺序(模块,模块#2)->模块#2->+[code]([想],绘制模块)->+[.]([想],操作)...
        ->[想](结构,模块#2)->结尾([想],模块#3)->+结尾(+绘制模块,模块#3),
    ->+结尾(+绘制模块,模块)
}...

->+[code]([想]#0,模块类型)->[想]#0(操作,模块)


"(,)
的#125""(绘制模块#124,模块类型#126)
模块类型#126"\"\"\"
->+绘制运算(,模块)->+的(操作,+绘制运算),
    

\"\"\"

+模块类型(操作,模块)...

->[]{
    []:->内容(模块,)->[]{
        []:->[==]\"if\"(,内容)->+绘制如果(,模块)->+的(操作,+绘制如果),
        ->[==]\"else\"(,内容)->+绘制否则(,模块)->+的(操作,+绘制否则),
        ->[==]\"code\"(,内容)->+绘制运算(,模块)->+的(操作,+绘制运算)
    },
    ->条件(模块,)->+绘制条件(,模块)->+的(操作,+绘制条件),
    ->函数(模块,)->+绘制函数(,模块)->+的(操作,+绘制函数),
    ->+绘制运算(,模块)->+的(操作,+绘制运算)
}


"(,)

## end
#5068, 363:
"""
描述结构:...
库:...
+[新建阅读窗口](,库)
+[新建阅读窗口](,描述结构)

"""

+模块连线(_媒介,_凭依)->+[del](,+模块连线)...
->的(模块连线,描述结构)->的(模块连线,库)...

->的(_凭依,结构)...
->+[code]([想],描述结构)->[想](_媒介,结构)...
->操作([想],)->[]{
    []=>的(操作,_操作)->_操作(_模块1,_模块2)->_模块1->_模块2(,)...
        =>[说]"连线: "(,_操作)->的(库,_条目)->_条目->[eq](_条目,_操作)...
        ->+[做](_模块1,_模块2)->+[code](+[做],_条目)->+[.](+[做],_凭依)
}



## end
#5070, 121:
"""
绘制模块:...

"""
+描述结构(_媒介,结构)->+操作(+描述结构,)...

->的(结构,起点)->起点(,模块)...
->+[code]([想],绘制模块)->+[.]([想],+操作)->[想](结构,模块)



## end
#5072, 67:
+[删除结构](,库)


画顺序:...
画if开头:...
将条目"画if开头"复制为条目"画if结尾"

画if结尾:...


## end
#5074, 297:
"""
连线类型:...

"""

+绘制模块(结构,模块)->.(+绘制模块,操作)...

->+结构->[]{
    []=>内部(模块,模块#2)->模块#2=>+[code]([想],绘制模块)->+[.]([想],操作)...
        ->[想](结构,模块#2)
}...

->[]{
    []:->顺序(模块,模块#2)->模块#2->+[code]([想],绘制模块)->+[.]([想],操作)...
        ->[想](结构,模块#2),
    ->[]
}...

->+[code]([想]#0,连线类型)->[想]#0(操作,模块)



## end
#5078, 359:
"""


"""
+收集内容(观察,内容)->.(+收集内容,类型)...

->[]{
    []:->如果(观察,)->[m_text]"if"(,内容),
    ->条件(观察,条件#1)->条件#1(,_cond)...
        ->[m_text](_cond,内容)->[m_name](+条件,内容),
    ->否则(观察,)->[m_text]"else"(,内容),
    ->循环(观察,)->[m_text]"loop"(,内容),
    ->函数(观察,)->."函数"(观察,_模块)->_模块(,name)...
        ->[m_text](name,内容)->[m_name](+函数,内容),
    ->[m_text]"code"(,内容)
}



## end
#5080, 631:
"""
P代码:...

"""

+后处理(收集块,模块)...

->收集块(结构,观察)->结构->观察(,)...
->+[code]([python],P代码)->[python](Python,+模块#2)...
->[]{
    []:->条件(观察,条件#1)->条件#1(,_cond)->+的(结构,+模块#2)...
        ->+条件#2(+模块#2,)->+的#2(结构,+条件#2)->[m_text](_cond,+条件#2)...
        ->[投影](,+的)->[投影](,+模块#2)->[投影](,+的#2)->[投影](,+条件#2)...
        ->+顺序(+模块#2,模块)->+的(结构,+顺序)->[投影](,+的)->[投影](,+顺序)...
    ->+[o](收集块,+模块#2),

    ->否则(观察,)...
        ->+的(结构,+模块#2)->[投影](,+的)->[投影](,+模块#2)...
        ->+内容"else"(+模块#2,)->+的(结构,+内容)->[投影](,+的)->[投影](,+内容)...
        ->+顺序(+模块#2,模块)->+的(结构,+顺序)->[投影](,+的)->[投影](,+顺序)...
    ->+[o](收集块,+模块#2),

    ->+[o](收集块,模块)
}




## end
#5082, 54:
"""


"""

state=True
ans=bk1
ans[1]+=0.5
ans[3]=0.5


## end
#5086, 4:
a==1
## end
#5087, 5:
1,1,1
## end
#5090, 4:
a==2
## end
#5091, 5:
1,1,1
## end
#5094, 4:
b==2
## end
#5095, 5:
1,1,1
## end
#5098, 4:
else
## end
#5100, 5:
1,1,1
## end
#5102, 4:
else
## end
#5104, 5:
1,1,1
## end
#5105, 903:
"""
M代码:...
M代码0:...
M代码2:...
M代码3:...

"""

+绘制条件(_凭依,模块)->+[del](,+绘制条件)...
->的(绘制条件,M代码)->的(绘制条件,M代码2)->的(绘制条件,M代码0)...
->的(绘制条件,M代码3)...

->+的(_凭依,+条件模块)->+在(+条件模块,+空间点)->+是(模块,+条件模块)...
->+的(+条件模块,+在)->+的(+条件模块,+空间点)->+的(模块,+是)...

->+样式"多边形"(+条件模块,)->+的(+条件模块,+样式)...
->+的(+条件模块,+宽度)->+的(+条件模块,+长度)...
->+的(+条件模块,+x)->+的(+条件模块,+y)...

->+[matlab](Matlab,)->+[code](+[matlab],M代码3)->+[.]"siz0"(+[matlab],模块)...
->+[o]"W"(+[matlab],+宽度)->+[o]"L"(+[matlab],+长度)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)...

->+[matlab](Matlab,+空间点)...
->[]{
    []:->相邻(模块,模块#1)->模块#1->是(模块#1,_模块1)->在(_模块1,空间点#1)...
        ->+[code](+[matlab],M代码)...
        ->+[.]"siz1"(+[matlab],模块#1)->+[.]"pt1"(+[matlab],空间点#1),

    ->内部(模块#2,模块)->模块#2->是(模块#2,_模块2)->在(_模块2,空间点#2)...
        ->+[code](+[matlab],M代码2)...
        ->+[.]"siz1"(+[matlab],模块#2)->+[.]"pt1"(+[matlab],空间点#2),

    ->+[code](+[matlab],M代码0)
}



## end
#5106, 67:
%{

%}

W=siz0(3);
L=siz0(4);

x=[-1,1,1,-1]*W/2;
y=-[0,0,1,1]*L;


## end
#5107, 21:
%{

%}

ans=[0,0];



## end
#5108, 67:
%{
记住"Matlab"
siz0
siz1
%}

ans=[siz1(1)/2-siz0(3)/2,-0.7]+pt1;




## end
#5109, 54:
%{
-siz0(3)/2
%}

ans=[-siz0(1)/2-siz1(1)/2,0]+pt1;



## end
#5115, 693:
"""
M代码:...
M代码0:...
M代码2:...
M代码3:...

保存:...

"""

+绘制条件(_凭依,模块)->+[del](,+绘制条件)...
->的(绘制条件,M代码)->的(绘制条件,M代码2)->的(绘制条件,M代码0)...
->的(绘制条件,M代码3)...

->+的(_凭依,+条件模块)->+在(+条件模块,+空间点)->+是(模块,+条件模块)...
->+的(+条件模块,+在)->+的(+条件模块,+空间点)->+的(模块,+是)...

->条件(模块,)->+[修改内容](条件,+条件模块)...
->+[matlab](Matlab,+空间点)->+[.]"siz0"(+[matlab],模块)...
->[]{
    []:->相邻(模块,模块#1)->模块#1->是(模块#1,_模块1)->在(_模块1,空间点#1)...
        ->+[code](+[matlab],M代码)...
        ->+[.]"siz1"(+[matlab],模块#1)->+[.]"pt1"(+[matlab],空间点#1),

    ->内部(模块#2,模块)->模块#2->是(模块#2,_模块2)->在(_模块2,空间点#2)...
        ->+[code](+[matlab],M代码2)...
        ->+[.]"siz1"(+[matlab],模块#2)->+[.]"pt1"(+[matlab],空间点#2),

    ->+[code](+[matlab],M代码0)
}



## end
#5116, 92:
%{

%}

W=siz0(3)-1;
L=siz0(4)-0.3;

x=[-1,1,1,-1]*W/2;
y=-[0,0,1,1]*L;

ans=pt0+[0,-1/2]*L;
## end
#5117, 21:
%{

%}

ans=[0,0];



## end
#5118, 47:
%{
记住"Matlab"
siz0
siz1
%}

ans=[0,-1]+pt1;




## end
#5119, 32:
%{

%}

ans=[0,-siz1(4)]+pt1;



## end
#5124, 1063:
"""
M代码:...
M代码0:...
M代码2:...
M代码3:...

"""

+绘制运算(_凭依,模块)->+[del](,+绘制运算)...
->的(绘制运算,M代码)->的(绘制运算,M代码2)->的(绘制运算,M代码0)...
->的(绘制运算,M代码3)...

->+的(_凭依,+运算模块)->+在(+运算模块,+空间点)->+是(模块,+运算模块)...
->+的(+运算模块,+在)->+的(+运算模块,+空间点)->+的(模块,+是)...

->+[matlab](Matlab,+空间点)->+[.]"siz0"(+[matlab],模块)...
->[]{
    []:->顺序(模块#1,模块)->模块#1->是(模块#1,_模块1)->在(_模块1,空间点#1)...
        ->+[code](+[matlab],M代码)...
        ->+[.]"siz1"(+[matlab],模块#1)->+[.]"pt1"(+[matlab],空间点#1),

    ->内部(模块#2,模块)->模块#2->是(模块#2,_模块2)->在(_模块2,空间点#2)...
        ->+[code](+[matlab],M代码2)...
        ->+[.]"siz1"(+[matlab],模块#2)->+[.]"pt1"(+[matlab],空间点#2),

    ->+[code](+[matlab],M代码0)
}...


->+样式"多边形"(+运算模块,)->+的(+运算模块,+样式)...
->+的(+运算模块,+宽度)->+的(+运算模块,+长度)...
->+的(+运算模块,+x)->+的(+运算模块,+y)...

->+文字"code"->+的(_凭依,+文字)->+的(+运算模块,+文字)...
->+的(+文字,+文字位置)->+文字位置"居中"...
->+在(+文字,+空间点#2)->+的(+文字,+在)->+的(+文字,+空间点#2)...

->+[matlab](Matlab,+空间点#2)->+[code](+[matlab],M代码3)...
->+[.]"pt0"(+[matlab],+空间点)...
->+[o]"W"(+[matlab],+宽度)->+[o]"L"(+[matlab],+长度)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)



## end
#5125, 115:
%{

%}

W=siz0(1);
L=siz0(2);

x=[-1,1,1,-1]*W/2;
y=[0,0,-1,-1]*L;

% ans=pt0+[-1,0]*W/2+[1,1];
ans=pt0+[0,-0.5];


## end
#5126, 32:
%{

%}

ans=[0,-siz1(4)]+pt1;



## end
#5127, 53:
%{
记住"Matlab"
siz0
siz1
%}

ans=[0,-siz1(2)]+pt1;




## end
#5128, 21:
%{

%}

ans=[0,0];



## end
#5133, 1086:
"""
M代码:...
M代码0:...
M代码2:...
M代码3:...

"""

+绘制函数(_凭依,模块)->+[del](,+绘制函数)...
->的(绘制函数,M代码)->的(绘制函数,M代码2)->的(绘制函数,M代码0)...
->的(绘制函数,M代码3)...

->函数(模块,)...
->+的(_凭依,+函数模块)->+在(+函数模块,+空间点)->+是(模块,+函数模块)...
->+的(+函数模块,+在)->+的(+函数模块,+空间点)->+的(模块,+是)...

->+[matlab](Matlab,+空间点)->+[.]"siz0"(+[matlab],模块)...
->[]{
    []:->顺序(模块#1,模块)->模块#1->是(模块#1,_模块1)->在(_模块1,空间点#1)...
        ->+[code](+[matlab],M代码)...
        ->+[.]"siz1"(+[matlab],模块#1)->+[.]"pt1"(+[matlab],空间点#1),

    ->内部(模块#2,模块)->模块#2->是(模块#2,_模块2)->在(_模块2,空间点#2)...
        ->+[code](+[matlab],M代码2)...
        ->+[.]"siz1"(+[matlab],模块#2)->+[.]"pt1"(+[matlab],空间点#2),

    ->+[code](+[matlab],M代码0)
}...

->+样式"多边形"(+函数模块,)->+的(+函数模块,+样式)...
->+的(+函数模块,+宽度)->+的(+函数模块,+长度)...
->+的(+函数模块,+x)->+的(+函数模块,+y)...

->+文字->[m_text](函数,+文字)->+的(_凭依,+文字)->+的(+函数模块,+文字)...
->+的(+文字,+文字位置)->+文字位置"居中"...
->+在(+文字,+空间点#2)->+的(+文字,+在)->+的(+文字,+空间点#2)...

->+[matlab](Matlab,+空间点#2)->+[code](+[matlab],M代码3)...
->+[.]"pt0"(+[matlab],+空间点)...
->+[o]"W"(+[matlab],+宽度)->+[o]"L"(+[matlab],+长度)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)


## end
#5134, 739:
"""
M代码:...
M代码0:...
M代码2:...
M代码3:...

保存:...

"""

+绘制否则(_凭依,模块)->+[del](,+绘制否则)...
->的(绘制否则,M代码2)->的(绘制否则,M代码0)...
->的(绘制否则,M代码3)...

->+的(_凭依,+否则模块)->+在(+否则模块,+空间点)->+是(模块,+否则模块)...
->+的(+否则模块,+在)->+的(+否则模块,+空间点)->+的(模块,+是)...

->+样式"多边形"(+否则模块,)->+的(+否则模块,+样式)...
->+的(+否则模块,+宽度)->+的(+否则模块,+长度)...
->+的(+否则模块,+x)->+的(+否则模块,+y)...

->+[matlab](Matlab,)->+[code](+[matlab],M代码3)->+[.]"siz0"(+[matlab],模块)...
->+[o]"W"(+[matlab],+宽度)->+[o]"L"(+[matlab],+长度)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)...

->+[matlab](Matlab,+空间点)...
->[]{
    []:->内部(模块#2,模块)->模块#2->是(模块#2,_模块2)->在(_模块2,空间点#2)...
        ->+[code](+[matlab],M代码2)...
        ->+[.]"siz1"(+[matlab],模块#2)->+[.]"pt1"(+[matlab],空间点#2),

    ->+[code](+[matlab],M代码0)
}



## end
#5135, 67:
%{

%}

W=siz0(3);
L=siz0(4);

x=[-1,1,1,-1]*W/2;
y=-[0,0,1,1]*L;


## end
#5136, 31:
%{

%}

ans=[siz0(1),0]+pt1;



## end
#5137, 67:
%{
记住"Matlab"
siz0
siz1
%}

ans=[siz1(1)/2-siz0(3)/2,-0.7]+pt1;




## end
#5138, 21:
%{

%}

ans=[0,0];



## end
#5144, 517:
"""
M代码:...
M代码0:...
M代码2:...
M代码3:...

保存:...

"""

+绘制否则(_凭依,模块)->+[del](,+绘制否则)...
->的(绘制否则,M代码2)->的(绘制否则,M代码0)...
->的(绘制否则,M代码3)...

->+的(_凭依,+否则模块)->+在(+否则模块,+空间点)->+是(模块,+否则模块)...
->+的(+否则模块,+在)->+的(+否则模块,+空间点)->+的(模块,+是)...

->+[修改内容]"else"(,+否则模块)...

->+[matlab](Matlab,+空间点)->+[.]"siz0"(+[matlab],模块)...
->[]{
    []:->内部(模块#2,模块)->模块#2->是(模块#2,_模块2)->在(_模块2,空间点#2)...
        ->+[code](+[matlab],M代码2)...
        ->+[.]"siz1"(+[matlab],模块#2)->+[.]"pt1"(+[matlab],空间点#2),

    ->+[code](+[matlab],M代码0)
}



## end
#5145, 82:
%{

%}

W=2;
L=1-0.3;

x=[-1,0,1,0]*W/2;
y=-[1/2,0,1/2,1]*L;

ans=pt0+[0,-1/2]*L;

## end
#5146, 21:
%{

%}

ans=[0,0];



## end
#5147, 47:
%{
记住"Matlab"
siz0
siz1
%}

ans=[0,-1]+pt1;




## end
#5148, 32:
%{

%}

ans=[0,-siz1(4)]+pt1;



## end
#5153, 1060:
"""
M代码:...
M代码0:...
M代码2:...
M代码3:...

"""

+绘制如果(_凭依,模块)->+[del](,+绘制如果)...
->的(绘制如果,M代码)->的(绘制如果,M代码2)->的(绘制如果,M代码0)...
->的(绘制如果,M代码3)...

->+的(_凭依,+如果模块)->+在(+如果模块,+空间点)->+是(模块,+如果模块)...
->+的(+如果模块,+在)->+的(+如果模块,+空间点)->+的(模块,+是)...

->+[matlab](Matlab,+空间点)->+[.]"siz0"(+[matlab],模块)...
->[]{
    []:->顺序(模块#1,模块)->模块#1->是(模块#1,_模块1)->在(_模块1,空间点#1)...
        ->+[code](+[matlab],M代码)...
        ->+[.]"siz1"(+[matlab],模块#1)->+[.]"pt1"(+[matlab],空间点#1),

    ->内部(模块#2,模块)->模块#2->是(模块#2,_模块2)->在(_模块2,空间点#2)...
        ->+[code](+[matlab],M代码2)...
        ->+[.]"siz1"(+[matlab],模块#2)->+[.]"pt1"(+[matlab],空间点#2),

    ->+[code](+[matlab],M代码0)
}...

->+样式"多边形"(+如果模块,)->+的(+如果模块,+样式)...
->+的(+如果模块,+宽度)->+的(+如果模块,+长度)...
->+的(+如果模块,+x)->+的(+如果模块,+y)...

->+文字"if"->+的(_凭依,+文字)->+的(+如果模块,+文字)...
->+的(+文字,+文字位置)->+文字位置"居中"...
->+在(+文字,+空间点#2)->+的(+文字,+在)->+的(+文字,+空间点#2)...

->+[matlab](Matlab,+空间点#2)->+[code](+[matlab],M代码3)...
->+[.]"pt0"(+[matlab],+空间点)...
->+[o]"W"(+[matlab],+宽度)->+[o]"L"(+[matlab],+长度)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)



## end
#5159, 109:

绘制如果:...
绘制条件:...
绘制否则:...
+[新建阅读窗口](,绘制如果)
将条目"绘制条件"复制为条目"绘制否则"

绘制函数:...
将条目"绘制运算"复制为条目"绘制函数"

绘制运算:...



## end
#5160, 371:
"""
->+绘制运算(,模块)->+的(操作,+绘制运算),
    

"""

+模块类型(操作,模块)...

->[]{
    []:->内容(模块,)->[]{
        []:->[==]"if"(,内容)->+绘制如果(,模块)->+的(操作,+绘制如果),
        ->[==]"else"(,内容)->+绘制否则(,模块)->+的(操作,+绘制否则),
        ->[==]"code"(,内容)->+绘制运算(,模块)->+的(操作,+绘制运算)
    },
    ->条件(模块,)->+绘制条件(,模块)->+的(操作,+绘制条件),
    ->函数(模块,)->+绘制函数(,模块)->+的(操作,+绘制函数),
    ->+绘制运算(,模块)->+的(操作,+绘制运算)
}



## end
#5162, 604:
"""
模块类型:...

"""

+绘制模块(结构,模块)->.(+绘制模块,操作)...

->+结构->[]{
    []=>内部(模块,模块#2)->模块#2=>+[code]([想],绘制模块)->+[.]([想],操作)...
        ->[想](结构,模块#2)->结尾([想],模块#3)...
        ->+结尾(模块#2,模块#3)->+的(结构,+结尾)->[投影](,+的)->[投影](,+结尾):
            ->上一个(+结构,)...
                ->+上一个(+结构,模块#1)->模块#1->+[上一个](+结构,模块#2)...
                ->+相邻(模块#1,模块#2)->+的(结构,+相邻)->[投影](,+的)->[投影](,+相邻),
            ->+[上一个](+结构,模块#2)
}...

->[]{
    []:->顺序(模块,模块#2)->模块#2->+[code]([想],绘制模块)->+[.]([想],操作)...
        ->[想](结构,模块#2)->结尾([想],模块#3)->+结尾(+绘制模块,模块#3),
    ->+结尾(+绘制模块,模块)
}...

->+[code]([想]#0,模块类型)->[想]#0(操作,模块)



## end
#5164, 121:
"""
绘制模块:...

"""
+描述结构(_媒介,结构)->+操作(+描述结构,)...

->的(结构,起点)->起点(,模块)...
->+[code]([想],绘制模块)->+[.]([想],+操作)->[想](结构,模块)



## end
#5167, 330:
"""
描述结构:...
库:...
+[新建阅读窗口](,库)
+[新建阅读窗口](,描述结构)

"""

+布置位置(_媒介,_凭依)->+[del](,+布置位置)...
->的(布置位置,描述结构)->的(布置位置,库)...

->的(_凭依,结构)...
->+[code]([想],描述结构)->[想](_媒介,结构)...
->操作([想],)->[]{
    []=>的(操作,_操作)->_操作(,_模块)->_模块=>[说]"操作: "(,_操作)...
        ->的(库,_条目)->_条目->[eq](_条目,_操作)...
        ->+[做](_凭依,_模块)->+[code](+[做],_条目)
}



## end
#5170, 266:
"""


"""
+连线类型(操作,模块)...

->[]{
    []:->顺序(模块,模块#2)->模块#2->+画顺序(模块,模块#2)->+的(操作,+画顺序),
    ->[]
}...
->[]{
    []:->内容"if"(模块,)=>内部(模块,模块#2)->模块#2->结尾(模块#2,模块#3)...
        =>+画if开头(模块,模块#2)->+的(操作,+画if开头)...
        ->+画if结尾(模块,模块#3)->+的(操作,+画if结尾),
    ->[]
}



## end
#5172, 466:
"""
M代码:...

"""
+画if结尾(模块#1,模块#2)->+[del](,+画if结尾)...
->的(画if结尾,M代码)...

->.(+画if结尾,_凭依)...
->是(模块#1,_模块1)->在(_模块1,空间点#1)...
->是(模块#2,_模块2)->在(_模块2,空间点#2)...

->+的(_凭依,+连线)...
->+连线(_模块1,_模块2)->+样式"曲线"(+连线,)->+的(+连线,+样式)...
->+的(+连线,+x)->+的(+连线,+y)...

->+[matlab](Matlab,)->+[code](+[matlab],M代码)...
->+[.]"pt1"(+[matlab],空间点#1)->+[.]"pt2"(+[matlab],空间点#2)...
->+[.]"siz1"(+[matlab],模块#1)->+[.]"siz2"(+[matlab],模块#2)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)




## end
#5174, 165:
%{
siz2
%}


Dy1=siz1(4)-0.3;
Dy2=siz2(4)-0.3;

x=[pt1(1),pt2(1),pt2(1)];
y=[pt1(2)-Dy1,pt1(2)-Dy1,pt2(2)-Dy2];

% x=[pt1(1),pt2(1)];
% y=[pt1(2)-Dy1,pt2(2)-Dy2];



## end
#5180, 2:
折线
## end
#5187, 2:
折线
## end
#5194, 2:
折线
## end
#5201, 2:
折线
## end
#5208, 2:
折线
## end
#5215, 2:
折线
## end
#5217, 10:
-1.0, -5.0
## end
#5219, 8:
0.0, 0.0
## end
#5222, 2:
折线
## end
#5224, 10:
-1.7, -2.2
## end
#5226, 8:
6.0, 6.0
## end
#5229, 2:
折线
## end
#5231, 10:
-1.7, -2.2
## end
#5233, 8:
0.0, 0.0
## end
#5236, 2:
折线
## end
#5238, 40:
-2.9000000000000004, -3.4000000000000004
## end
#5240, 8:
2.0, 2.0
## end
#5243, 2:
折线
## end
#5245, 40:
-2.9000000000000004, -3.4000000000000004
## end
#5247, 10:
-2.0, -2.0
## end
#5250, 2:
折线
## end
#5252, 10:
-1.7, -2.2
## end
#5254, 10:
-6.0, -6.0
## end
#5257, 2:
折线
## end
#5259, 67:
%{

%}


L=siz1(4)-0.3;

x=[pt1(1),pt2(1)];
y=[pt1(2)-L,pt2(2)];



## end
#5261, 458:
"""
M代码:...

"""
+画顺序(模块#1,模块#2)->+[del](,+画顺序)...
->的(画顺序,M代码)...

->.(+画顺序,_凭依)...
->是(模块#1,_模块1)->在(_模块1,空间点#1)...
->是(模块#2,_模块2)->在(_模块2,空间点#2)...

->+的(_凭依,+连线)...
->+连线(_模块1,_模块2)->+样式"折线"(+连线,)->+的(+连线,+样式)...
->+的(+连线,+x)->+的(+连线,+y)...

->+[matlab](Matlab,)->+[code](+[matlab],M代码)...
->+[.]"pt1"(+[matlab],空间点#1)->+[.]"pt2"(+[matlab],空间点#2)...
->+[.]"siz1"(+[matlab],模块#1)->+[.]"siz2"(+[matlab],模块#2)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)




## end
#5264, 96:
%{

%}


Dy1=1-0.3;
Dy2=0.2;

x=[pt1(1),pt1(1),pt2(1)];
y=[pt1(2)-Dy1,pt2(2)-Dy2,pt2(2)-Dy2];



## end
#5266, 466:
"""
M代码:...

"""
+画if开头(模块#1,模块#2)->+[del](,+画if开头)...
->的(画if开头,M代码)...

->.(+画if开头,_凭依)...
->是(模块#1,_模块1)->在(_模块1,空间点#1)...
->是(模块#2,_模块2)->在(_模块2,空间点#2)...

->+的(_凭依,+连线)...
->+连线(_模块1,_模块2)->+样式"曲线"(+连线,)->+的(+连线,+样式)...
->+的(+连线,+x)->+的(+连线,+y)...

->+[matlab](Matlab,)->+[code](+[matlab],M代码)...
->+[.]"pt1"(+[matlab],空间点#1)->+[.]"pt2"(+[matlab],空间点#2)...
->+[.]"siz1"(+[matlab],模块#1)->+[.]"siz2"(+[matlab],模块#2)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)




## end
#5271, 4:
a==1
## end
#5273, 18:
4.0, 1.5, 4.0, 0.5
## end
#5275, 4:
b==2
## end
#5277, 18:
4.0, 1.5, 4.0, 0.5
## end
#5279, 4:
b==2
## end
#5281, 18:
4.0, 1.5, 4.0, 0.5
## end
#5283, 4:
else
## end
#5285, 18:
4.0, 1.5, 4.0, 0.5
## end
#5287, 4:
else
## end
#5289, 18:
8.0, 3.0, 8.0, 0.5
## end
#5291, 4:
a==2
## end
#5293, 20:
12.0, 4.5, 12.0, 0.5
## end
#5295, 4:
else
## end
#5297, 18:
4.0, 1.5, 4.0, 0.5
## end
#5308, 9:
0.0, -0.5
## end
#5310, 2:
居中
## end
#5314, 4:
main
## end
#5315, 20:
0.0, 0.0, -7.5, -7.5
## end
#5317, 24:
-10.0, 10.0, 10.0, -10.0
## end
#5319, 3:
7.5
## end
#5321, 4:
20.0
## end
#5324, 3:
多边形
## end
#5327, 8:
0.0, 0.0
## end
#5333, 10:
0.0, -1.35
## end
#5335, 2:
居中
## end
#5339, 2:
if
## end
#5340, 24:
-0.35, -0.0, -0.35, -0.7
## end
#5342, 19:
-1.0, 0.0, 1.0, 0.0
## end
#5344, 3:
0.7
## end
#5346, 3:
2.0
## end
#5349, 3:
多边形
## end
#5352, 9:
0.0, -1.0
## end
#5358, 10:
0.0, -6.85
## end
#5360, 2:
居中
## end
#5364, 4:
code
## end
#5365, 22:
-0.0, -0.0, -0.7, -0.7
## end
#5367, 20:
-1.5, 1.5, 1.5, -1.5
## end
#5369, 3:
0.7
## end
#5371, 3:
3.0
## end
#5374, 3:
多边形
## end
#5377, 9:
0.0, -6.5
## end
#5385, 9:
8.0, -1.7
## end
#5387, 4:
else
## end
#5391, 24:
8.0, -2.5500000000000003
## end
#5393, 2:
居中
## end
#5397, 4:
code
## end
#5398, 22:
-0.0, -0.0, -0.7, -0.7
## end
#5400, 20:
-1.5, 1.5, 1.5, -1.5
## end
#5402, 3:
0.7
## end
#5404, 3:
3.0
## end
#5407, 3:
多边形
## end
#5410, 9:
8.0, -2.2
## end
#5418, 9:
0.0, -1.7
## end
#5420, 4:
a==2
## end
#5424, 24:
0.0, -2.5500000000000003
## end
#5426, 2:
居中
## end
#5430, 2:
if
## end
#5431, 24:
-0.35, -0.0, -0.35, -0.7
## end
#5433, 19:
-1.0, 0.0, 1.0, 0.0
## end
#5435, 3:
0.7
## end
#5437, 3:
2.0
## end
#5440, 3:
多边形
## end
#5443, 9:
0.0, -2.2
## end
#5451, 24:
2.0, -2.9000000000000004
## end
#5453, 4:
else
## end
#5457, 24:
2.0, -3.7500000000000004
## end
#5459, 2:
居中
## end
#5463, 2:
if
## end
#5464, 24:
-0.35, -0.0, -0.35, -0.7
## end
#5466, 19:
-1.0, 0.0, 1.0, 0.0
## end
#5468, 3:
0.7
## end
#5470, 3:
2.0
## end
#5473, 3:
多边形
## end
#5476, 24:
2.0, -3.4000000000000004
## end
#5484, 24:
4.0, -4.1000000000000005
## end
#5486, 4:
else
## end
#5490, 10:
4.0, -4.95
## end
#5492, 2:
居中
## end
#5496, 4:
code
## end
#5497, 22:
-0.0, -0.0, -0.7, -0.7
## end
#5499, 20:
-1.5, 1.5, 1.5, -1.5
## end
#5501, 3:
0.7
## end
#5503, 3:
3.0
## end
#5506, 3:
多边形
## end
#5509, 24:
4.0, -4.6000000000000005
## end
#5517, 24:
0.0, -4.1000000000000005
## end
#5519, 4:
b==2
## end
#5523, 10:
0.0, -4.95
## end
#5525, 2:
居中
## end
#5529, 4:
code
## end
#5530, 22:
-0.0, -0.0, -0.7, -0.7
## end
#5532, 20:
-1.5, 1.5, 1.5, -1.5
## end
#5534, 3:
0.7
## end
#5536, 3:
3.0
## end
#5539, 3:
多边形
## end
#5542, 24:
0.0, -4.6000000000000005
## end
#5550, 25:
-4.0, -2.9000000000000004
## end
#5552, 4:
b==2
## end
#5556, 25:
-4.0, -3.7500000000000004
## end
#5558, 2:
居中
## end
#5562, 4:
code
## end
#5563, 22:
-0.0, -0.0, -0.7, -0.7
## end
#5565, 20:
-1.5, 1.5, 1.5, -1.5
## end
#5567, 3:
0.7
## end
#5569, 3:
3.0
## end
#5572, 3:
多边形
## end
#5575, 25:
-4.0, -3.4000000000000004
## end
#5583, 10:
-8.0, -1.7
## end
#5585, 4:
a==1
## end
#5589, 25:
-8.0, -2.5500000000000003
## end
#5591, 2:
居中
## end
#5595, 4:
code
## end
#5596, 22:
-0.0, -0.0, -0.7, -0.7
## end
#5598, 20:
-1.5, 1.5, 1.5, -1.5
## end
#5600, 3:
0.7
## end
#5602, 3:
3.0
## end
#5605, 3:
多边形
## end
#5608, 10:
-8.0, -2.2
## end
#5612, 31:
-6.2, -6.2, -2.9000000000000004
## end
#5614, 13:
0.0, 8.0, 8.0
## end
#5617, 2:
曲线
## end
#5620, 16:
-1.7, -1.9, -1.9
## end
#5622, 13:
0.0, 0.0, 8.0
## end
#5625, 2:
曲线
## end
#5628, 16:
-6.2, -6.2, -5.9
## end
#5630, 13:
0.0, 0.0, 0.0
## end
#5633, 2:
曲线
## end
#5636, 16:
-1.7, -1.9, -1.9
## end
#5638, 13:
0.0, 0.0, 0.0
## end
#5641, 2:
曲线
## end
#5644, 31:
-6.2, -6.2, -2.9000000000000004
## end
#5646, 15:
0.0, -8.0, -8.0
## end
#5649, 2:
曲线
## end
#5652, 16:
-1.7, -1.9, -1.9
## end
#5654, 14:
0.0, 0.0, -8.0
## end
#5657, 2:
曲线
## end
#5660, 10:
-6.2, -6.5
## end
#5662, 8:
0.0, 0.0
## end
#5665, 2:
折线
## end
#5668, 10:
-1.9, -2.2
## end
#5670, 8:
8.0, 8.0
## end
#5673, 2:
折线
## end
#5676, 10:
-1.9, -2.2
## end
#5678, 8:
0.0, 0.0
## end
#5681, 2:
折线
## end
#5684, 31:
-5.9, -5.9, -5.6000000000000005
## end
#5686, 13:
0.0, 2.0, 2.0
## end
#5689, 2:
曲线
## end
#5692, 61:
-2.9000000000000004, -3.1000000000000005, -3.1000000000000005
## end
#5694, 13:
0.0, 0.0, 2.0
## end
#5697, 2:
曲线
## end
#5700, 31:
-5.9, -5.9, -4.1000000000000005
## end
#5702, 15:
0.0, -4.0, -4.0
## end
#5705, 2:
曲线
## end
#5708, 61:
-2.9000000000000004, -3.1000000000000005, -3.1000000000000005
## end
#5710, 14:
0.0, 0.0, -4.0
## end
#5713, 2:
曲线
## end
#5716, 40:
-3.1000000000000005, -3.4000000000000004
## end
#5718, 8:
2.0, 2.0
## end
#5721, 2:
折线
## end
#5724, 60:
-5.6000000000000005, -5.6000000000000005, -5.300000000000001
## end
#5726, 13:
2.0, 4.0, 4.0
## end
#5729, 2:
曲线
## end
#5732, 59:
-4.1000000000000005, -4.300000000000001, -4.300000000000001
## end
#5734, 13:
2.0, 2.0, 4.0
## end
#5737, 2:
曲线
## end
#5740, 60:
-5.6000000000000005, -5.6000000000000005, -5.300000000000001
## end
#5742, 13:
2.0, 0.0, 0.0
## end
#5745, 2:
曲线
## end
#5748, 59:
-4.1000000000000005, -4.300000000000001, -4.300000000000001
## end
#5750, 13:
2.0, 2.0, 0.0
## end
#5753, 2:
曲线
## end
#5756, 39:
-4.300000000000001, -4.6000000000000005
## end
#5758, 8:
4.0, 4.0
## end
#5761, 2:
折线
## end
#5764, 39:
-4.300000000000001, -4.6000000000000005
## end
#5766, 8:
0.0, 0.0
## end
#5769, 2:
折线
## end
#5772, 40:
-3.1000000000000005, -3.4000000000000004
## end
#5774, 10:
-4.0, -4.0
## end
#5777, 2:
折线
## end
#5780, 10:
-1.9, -2.2
## end
#5782, 10:
-8.0, -8.0
## end
#5785, 2:
折线
## end
#5789, 5745:

<svg xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 1000 550.7822580645161" style="overflow: hidden;border: 2px solid #888888;"> 
<polygon points="0,87 1000,87 1000,462 0,462 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="450,155 500,137 550,155 500,172 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="425,412 575,412 575,447 425,447 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="825,197 975,197 975,232 825,232 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="450,215 500,197 550,215 500,232 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="550,275 600,257 650,275 600,292 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="625,317 775,317 775,352 625,352 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="425,317 575,317 575,352 425,352 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="225,257 375,257 375,292 225,292 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="25,197 175,197 175,232 25,232 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polyline points="500,397 900,397 900,232 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="500,172 500,182 900,182 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="500,397 500,397 500,382 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="500,172 500,182 500,182 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="500,397 100,397 100,232 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="500,172 500,182 100,182 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polygon points="500,397 500,412 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="900,182 900,197 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="500,182 500,197 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polyline points="500,382 600,382 600,367 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="500,232 500,242 600,242 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="500,382 300,382 300,292 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="500,232 500,242 300,242 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polygon points="600,242 600,257 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polyline points="600,367 700,367 700,352 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="600,292 600,302 700,302 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="600,367 500,367 500,352 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="600,292 600,302 500,302 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polygon points="700,302 700,317 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="500,302 500,317 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="300,242 300,257 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="100,182 100,197 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<text dominant-baseline="middle" text-anchor="middle" x="100.000000" y="215.391129" font-size="15">code</text>
<text dominant-baseline="middle"  x="100.000000" y="172.891129" font-size="15">a==1</text>
<text dominant-baseline="middle" text-anchor="middle" x="300.000000" y="275.391129" font-size="15">code</text>
<text dominant-baseline="middle"  x="300.000000" y="232.891129" font-size="15">b==2</text>
<text dominant-baseline="middle" text-anchor="middle" x="500.000000" y="335.391129" font-size="15">code</text>
<text dominant-baseline="middle"  x="500.000000" y="292.891129" font-size="15">b==2</text>
<text dominant-baseline="middle" text-anchor="middle" x="700.000000" y="335.391129" font-size="15">code</text>
<text dominant-baseline="middle"  x="700.000000" y="292.891129" font-size="15">else</text>
<text dominant-baseline="middle" text-anchor="middle" x="600.000000" y="275.391129" font-size="15">if</text>
<text dominant-baseline="middle"  x="600.000000" y="232.891129" font-size="15">else</text>
<text dominant-baseline="middle" text-anchor="middle" x="500.000000" y="215.391129" font-size="15">if</text>
<text dominant-baseline="middle"  x="500.000000" y="172.891129" font-size="15">a==2</text>
<text dominant-baseline="middle" text-anchor="middle" x="900.000000" y="215.391129" font-size="15">code</text>
<text dominant-baseline="middle"  x="900.000000" y="172.891129" font-size="15">else</text>
<text dominant-baseline="middle" text-anchor="middle" x="500.000000" y="430.391129" font-size="15">code</text>
<text dominant-baseline="middle" text-anchor="middle" x="500.000000" y="155.391129" font-size="15">if</text>
<text dominant-baseline="middle" text-anchor="middle" x="500.000000" y="112.891129" font-size="15">main</text>

</svg>


## end
#5795, 1056:

def parser_token_cmd(code,i,list_pt=None):
    i0=i
    text=""
    pat=r"[{};]|//|/\*"
    pat1=r"if[\s\(]+|while[\s\(]+|for[\s\(]+|do[\s\{]+"

    b_n=0
    n_quote=0;
    while i<len(code):
        if n_quote>0:
            if code[i]=="\"":
                n_quote=0
            elif code[i]=="\\" and i+1<len(code):
                i+=1
        elif b_n>0:
            if code[i]==")":
                b_n=b_n-1;
            elif code[i]=="(":
                b_n+=1
        elif code[i]=="\"":
            n_quote=1
        elif re.match(pat,code[i:]) or re.match(pat1,code[i:]):
            break
        elif code[i]=="\n":
            result=re.match(r"(\s*)",code[i:])
            i+=len(result.group(1))-1
        elif code[i]=="(":
            b_n+=1
        elif code[i]==")":
            b_n=b_n-1;
        if b_n<0:
            break
        text+=code[i]
        i+=1

    if text=="":
        return [False,i0,None]
    else:
        print("cmd:",text)
        pt0=NetP('cmd',text)
        list_pt.append(pt0)
        return [True,i,pt0]

## end
#5799, 155:
"""

"""

+召唤规则(_题目,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_代码)...

->[==]"代码结构转文本描述"(,召唤星辰)...

->+整理结构(_题目,_代码)->+的(操作,+整理结构)...
->+生成结构(_题目,_代码)->+的(操作,+生成结构)



## end
#5800, 133:
"""
记住"Python"
print(np.max([1,2]))
print(func_name)

"""

state=True
bk1[0]+=1
bk1[1]=np.max([bk1[2],bk2[2]])
bk1[2]=bk1[1]
ans=bk1

## end
#5801, 46:
"""


"""
state=True
bk1[2]+=bk2[2]+1
ans=bk1

## end
#5802, 263:
"""

    ->否则(观察,)->[m_text]"else"(,内容),

"""
+收集内容(观察,内容)...

->[]{
    []:->如果(观察,)->[m_text]"if"(,内容),
    ->循环(观察,)->[m_text]"loop"(,内容),
    ->函数(观察,)->."函数"(观察,_模块)->_模块(,name)...
        ->[m_text](name,内容)->[m_name](+函数,内容),
    ->[m_text]"code"(,内容)
}



## end
#5803, 94:
"""


"""

state=True
# print("!!!!",func_name,len(func_name))
bk1[0]=len(func_name)
ans=bk1


## end
#5804, 985:
"""
P代码:...
P代码1:...
P代码2:...
收集内容:...
+[新建阅读窗口](,P代码)

"""
+收集块(结构,观察)...

->观察(,_块)->+的(结构,+模块)->+模块"1,1,1"(,_块)->+[o](+收集块,+模块)...
    ->+的#2(结构,+内容)->+内容(+模块,)...
        ->+[code]([想]#0,收集内容)->[想]#0(观察,+内容)...
    ->[投影](,+的)->[投影](,+模块)->[投影](,+的#2)->[投影](,+内容)...

->+[code]([python]#0,P代码1)...
    ->+[.]"func_name"([python]#0,+内容)->+[.]"bk1"([python]#0,+模块)...
    ->[python]#0(Python,+模块)...
->[]{
    []=>然后"运算"(观察,观察#2)->观察#2=>+[code]([想],收集块)...
        ->[想](结构,观察#2)->o([想],模块#2)...
        ->+内部(+模块,模块#2)->+的(结构,+内部)->[投影](,+的)->[投影](,+内部)...
        ->+[code]([python],P代码)...
        ->+[.]"bk1"([python],+模块)->+[.]"bk2"([python],模块#2)...
        ->[python](Python,+模块)
}...
->[]{
    []=>然后"顺序"(观察,观察#2)->观察#2=>+[code]([想],收集块)...
        ->[想](结构,观察#2)->o([想],模块#2)...
        ->+顺序(+模块,模块#2)->+的(结构,+顺序)->[投影](,+的)->[投影](,+顺序)...
        ->+[code]([python],P代码2)...
        ->+[.]"bk1"([python],+模块)->+[.]"bk2"([python],模块#2)...
        ->[python](Python,+模块)
}


## end
#5810, 1547:
"""
P代码:...
P代码1:...
P代码2:...
收集内容:...
+[新建阅读窗口](,P代码)
+[新建阅读窗口](,收集内容)

保存:...

"""
+收集块(结构,观察)...

->观察(,_块)->+的(结构,+模块)->+模块"1,1,1"(,_块)...
    ->+的#2(结构,+内容)->+内容(+模块,)...
        ->+[code]([想]#0,收集内容)->[想]#0(观察,+内容)...
    ->[投影](,+的)->[投影](,+模块)->[投影](,+的#2)->[投影](,+内容)...

->[]{
    []:->条件(观察,条件#1)->条件#1(,_cond)->+的(结构,+模块#2)->+模块#2"1,1,1"...
        ->+条件#2(+模块#2,)->+的#2(结构,+条件#2)->[m_text](_cond,+条件#2)...
        ->[投影](,+的)->[投影](,+模块#2)->[投影](,+的#2)->[投影](,+条件#2)...
        ->+内部(+模块#2,+模块)->+的(结构,+内部)->[投影](,+的)->[投影](,+内部)...
    ->+[o](+收集块,+模块#2),

    ->否则(观察,)...
        ->+模块#2"1,1,1"->+的(结构,+模块#2)->[投影](,+的)->[投影](,+模块#2)...
        ->+内容"else"(+模块#2,)->+的(结构,+内容)->[投影](,+的)->[投影](,+内容)...
        ->+内部(+模块#2,+模块)->+的(结构,+内部)->[投影](,+的)->[投影](,+内部)...
    ->+[o](+收集块,+模块#2),

    ->+[o](+收集块,+模块)
}...

->+[code]([python]#0,P代码1)...
    ->+[.]"func_name"([python]#0,+内容)->+[.]"bk1"([python]#0,+模块)...
    ->[python]#0(Python,+模块)...
->[]{
    []=>然后"运算"(观察,观察#2)->观察#2=>+[code]([想],收集块)...
        ->[想](结构,观察#2)->o([想],模块#2)...
        ->+内部(+模块,模块#2)->+的(结构,+内部)->[投影](,+的)->[投影](,+内部)...
        ->+[code]([python],P代码)...
        ->+[.]"bk1"([python],+模块)->+[.]"bk2"([python],模块#2)...
        ->[python](Python,+模块)
}...
->[]{
    []=>然后"顺序"(观察,观察#2)->观察#2=>+[code]([想],收集块)...
        ->[想](结构,观察#2)->o([想],模块#2)...
        ->+顺序(+模块,模块#2)->+的(结构,+顺序)->[投影](,+的)->[投影](,+顺序)...
        ->+[code]([python],P代码2)...
        ->+[.]"bk1"([python],+模块)->+[.]"bk2"([python],模块#2)...
        ->[python](Python,+模块)
}


## end
#5812, 179:
"""
收集块:...

"""
+描述结构(_媒介,结构)->+操作(+描述结构,)...

->的(_媒介,起点)->起点(,块)->+观察(+代码块,块)->[观察代码结构](_媒介,+观察)...
->+[code]([想],收集块)->[想](结构,+观察)->o([想],模块)...

->+描述模块(,模块)->+的(+操作,+描述模块)


## end
#5813, 792:
"""
    text_0=str_a+text_0.replace("\n","\n"+str_a)
print(text_0)
print(text_1)
+[P函数](,P代码)

"""
# print(var_name,pt_name)
if text_0=="":
    ans=var_name
else:
    str_a="├"
    list_line=text_0.split("\n")
    list_line_1=[]
    n_last=0
    for i in range(len(list_line)):
        line=list_line[i]
        if line[0]=="|" or line[0]=="├" or line[0]=="└" or line[0]==" ":
            line="|"+line
        else:
            n_last=i
            line="├"+line
        list_line_1.append(line)
    for i in range(n_last,len(list_line_1)):
        if list_line_1[i][0]=="|":
            list_line_1[i]=' '+list_line_1[i][1:]
        else:
            list_line_1[i]='└'+list_line_1[i][1:]

    text_1="\n".join(list_line_1)
    ans=var_name+"\n"+text_1


"""
print(text_1)
+[P函数](,P代码)

"""
## end
#5814, 265:
"""
+[P函数](,测试)

"""
text_a="""
aaa
c
v
"""
text_0=text_a

list_line=text_0.split("\n")
list_ns=[len(line) for line in list_line]
print(list_ns)




"""
+[P函数](,测试)
print('{s:X<{n}}'.format(s="11",n=10))
print(f'{"dog": <10}'+'1')
print(f'{"%s":X<10}'%("AAA"))

"""
## end
#5816, 915:
"""
记住"Python"
+[P函数](,P代码2)
测试:...

"""
import numpy as np

ans=""
pat_line_0="{s:─<{n}}"
pat_line_1="{s: <{n}}"
if text_0!="":
    list_line_0=text_0.split("\n")
    n_0=np.max([len(line) for line in list_line_0])
    l_0=len(list_line_0)
    list_line_a=text_a.split("\n")
    n_a=np.max([len(line) for line in list_line_a])
    l_a=len(list_line_a)

    for i in range(np.max([l_a,l_0])):
        pat_line=pat_line_1

        if i>=l_a:
            line_a=pat_line.format(s=" ",n=n_a)
        else:
            line_a=pat_line.format(s=list_line_a[i],n=n_a)
        
        if i>=l_0:
            line_0=pat_line.format(s=" ",n=n_0)
        else:
            line_0=pat_line.format(s=list_line_0[i],n=n_0)

        if i==0:
            line_a=line_a.replace(" ","─")
            ans+=line_a+"────"+line_0+"\n"
        else:
            ans+=line_a+"    "+line_0+"\n"

    ans=ans[0:-1]
else:
    ans=text_a




## end
#5817, 34:
"""


"""

ans=text_0+"\n"+text_a

## end
#5823, 845:
"""
P代码:...
P代码b:...
P代码2:...
P代码3:...

"""
+写模块(_文本,_模块)->+[del](,+写模块)...
->的(写模块,P代码)...
->的(写模块,P代码2)->的(写模块,P代码3)...

->+[临时文本]#内部->[]{
    []=>内部(_模块,_模块1)->_模块1=>+[做](+[临时文本]#a,_模块1)...
        ->+[code](+[做],写模块)...
        ->+[python](Python,+[临时文本]#内部)->+[code](+[python],P代码2)...
        ->+[s]"text_a"(+[python],+[临时文本]#a)...
        ->+[s]"text_0"(+[python],+[临时文本]#内部)
}...

->_re"函数|内容|条件"(_模块,)->+[标题](_re,)...
->+[python](Python,_文本)->+[code](+[python],P代码)...
    ->+[s]"var_name"(+[python],_re)->+[s]"pt_name"(+[python],+[标题])...
    ->+[s]"text_0"(+[python],+[临时文本]#内部)...

->[]{
    []:->顺序(_模块,_模块1)->_模块1(,)...
        ->+[做](+[临时文本]#a,_模块1)->+[code](+[做],写模块)...
        ->+[python](Python,_文本)->+[code](+[python],P代码3)...
        ->+[s]"text_a"(+[python],+[临时文本]#a)...
        ->+[s]"text_0"(+[python],_文本),

    ->[]
}

## end
#5825, 105:
"""
写模块:...

"""
+描述模块(_凭依,_模块)->+[del](,+描述模块)...
->的(描述模块,写模块)...

->+[做](_凭依,_模块)->+[code](+[做],写模块)


## end
#5827, 12:

描述模块:...



## end
#5830, 363:
"""
描述结构:...
库:...

"""

+生成结构(_媒介,_凭依)->+[del](,+生成结构)...
->的(生成结构,描述结构)->的(生成结构,库)...

->[]{
    []:->的(_凭依,结构)->结构->+[删除结构](,结构),
    ->+的(_凭依,+结构)
}->的(_凭依,结构)...

->+[code]([想],描述结构)->[想](_媒介,结构)...
->操作([想],)->[]{
    []=>的(操作,_操作)->_操作(,_模块)->_模块=>[说]"操作: "(,_操作)...
        ->的(库,_条目)->_条目->[eq](_条目,_操作)...
        ->+[做](_凭依,_模块)->+[code](+[做],_条目)
}



## end
#5831, 175:
"""


"""
+整理结构(_媒介,_凭依)->+[del](,+整理结构)...

->的(_凭依,召唤规则)->+[删除结构](,召唤规则)->+[del](,召唤规则)...
->的(_凭依,降临规则)->+[删除结构](,降临规则)->+[del](,降临规则)...
->+[记住](,_凭依)->+[修改内容](_凭依,+[显示])

## end
#5834, 21:


生成结构:...
整理结构:...


## end
#5837, 23:


召唤规则:...
降临规则:...




## end
#5840, 166:

代码:...
+[新建阅读窗口](,代码)
结构:...
+[删除结构](,结构)->+[分析程序结构](代码,结构)->+[显示星图](,结构)
+[显示星图](,结构)

输出代码:...
+[删除结构](,输出代码)->+[召唤星辰]"代码结构转代码"(结构,输出代码)
的(输出代码,结构)->+[显示星图](,结构)


## end
#5842, 66:
if (++depth>5) if (erand48(Xi)<p) f=f*(1/p); else return obj.e;



## end
#5844, 299:
cmd#0"++depth>5"(,)
cmd#1"erand48(Xi)<p"(,)
cmd#2"f=f*(1/p)"(,)
块#3""(,cmd#2)
运算#4""(条件#9,块#3)
cmd#5"return obj.e"(,)
块#6""(,cmd#5)
运算#7""(否则#8,块#6)
否则#8"else"(运算#4,)
条件#9""(如果#10,cmd#1)
如果#10"if"(,)
块#11""(,如果#10)
运算#12""(条件#13,块#11)
条件#13""(如果#14,cmd#0)
如果#14"if"(,)
块#15""(,如果#14)
起点#16""(,块#15)

## end
#5846, 93:
if ++depth>5
    if erand48(Xi)<p
        f=f*(1/p)
    else
        return obj.e
    end
end
## end
#5851, 153:
"""

"""

+召唤规则(_题目,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_代码)...

->[==]"代码结构转代码"(,召唤星辰)...

->+整理结构(_题目,_代码)->+的(操作,+整理结构)...
->+生成结构(_题目,_代码)->+的(操作,+生成结构)



## end
#5855, 10237:
代码结构转代码#0"

召唤规则:...
降临规则:...



"(,)
的#1""(代码结构转代码#0,降临规则#2)
降临规则#2"

生成结构:...
整理结构:...

"(,)
的#3""(降临规则#2,整理结构#4)
整理结构#4"\"\"\"


\"\"\"
+整理结构(_媒介,_凭依)->+[del](,+整理结构)...

->的(_凭依,召唤规则)->+[删除结构](,召唤规则)->+[del](,召唤规则)...
->的(_凭依,降临规则)->+[删除结构](,降临规则)->+[del](,降临规则)...

->的(_凭依,文本)->+[结构转文本](文本,_凭依)...
->+[记住](,_凭依)->+[修改内容](_凭依,+[显示])
"(,)
的#5""(降临规则#2,生成结构#6)
生成结构#6"\"\"\"
描述结构:...
库:...
+[新建阅读窗口](,描述结构)

\"\"\"

+生成结构(_媒介,_凭依)->+[del](,+生成结构)...
->的(生成结构,描述结构)->的(生成结构,库)...

->[]{
    []:->的(_凭依,结构)->结构->+[删除结构](,结构),  ->+的(_凭依,+结构)
}->的(_凭依,结构)...
->[]{
    []:->的(_凭依,文本)->文本->+[删除结构](,文本),  ->+的(_凭依,+文本)
}->的(_凭依,文本)...

->+[code]([想],描述结构)->[想](_媒介,结构)...
->操作([想],)->[]{
    []=>的(操作,_操作)->_操作(,_模块)->_模块=>[说]\"操作: \"(,_操作)...
        ->的(库,_条目)->_条目->[eq](_条目,_操作)...
        ->+[做](文本,_模块)->+[code](+[做],_条目)
}


"(,)
的#7""(生成结构#6,库#8)
库#8"
描述模块:...

代码模块:...
如果模块:...

for模块:...
函数模块:...
将条目\"for模块\"复制为条目\"函数模块\"

一般模块:...
+[新建阅读窗口](,如果模块)
"(,)
的#9""(库#8,描述模块#10)
描述模块#10"\"\"\"
写模块:...

\"\"\"
+描述模块(_凭依,_模块)->+[del](,+描述模块)...
->的(描述模块,写模块)...

->+[做](_凭依,_模块)->+[code](+[做],写模块)

"(,)
的#11""(描述模块#10,写模块#12)
写模块#12"\"\"\"
P代码:...
P代码b:...
P代码2:...
P代码3:...

\"\"\"
+写模块(_文本,_模块)->+[del](,+写模块)...
->的(写模块,P代码)...
->的(写模块,P代码2)->的(写模块,P代码3)...

->+[临时文本]#内部->[]{
    []=>内部(_模块,_模块1)->_模块1=>+[做](+[临时文本]#a,_模块1)...
        ->+[code](+[做],写模块)...
        ->+[python](Python,+[临时文本]#内部)->+[code](+[python],P代码2)...
        ->+[s]\"text_a\"(+[python],+[临时文本]#a)...
        ->+[s]\"text_0\"(+[python],+[临时文本]#内部)
}...

->_re\"函数|内容|条件\"(_模块,)->+[标题](_re,)...
->+[python](Python,_文本)->+[code](+[python],P代码)...
    ->+[s]\"var_name\"(+[python],_re)->+[s]\"pt_name\"(+[python],+[标题])...
    ->+[s]\"text_0\"(+[python],+[临时文本]#内部)...

->[]{
    []:->顺序(_模块,_模块1)->_模块1(,)...
        ->+[做](+[临时文本]#a,_模块1)->+[code](+[做],写模块)...
        ->+[python](Python,_文本)->+[code](+[python],P代码3)...
        ->+[s]\"text_a\"(+[python],+[临时文本]#a)...
        ->+[s]\"text_0\"(+[python],_文本),

    ->[]
}
"(,)
的#13""(写模块#12,P代码b#14)
P代码b#14""(,)
的#15""(写模块#12,P代码3#16)
P代码3#16"\"\"\"


\"\"\"

ans=text_0+\"\n\"+text_a
"(,)
的#17""(写模块#12,P代码2#18)
P代码2#18"\"\"\"
记住\"Python\"
+[P函数](,P代码2)
测试:...

\"\"\"
import numpy as np

ans=\"\"
pat_line_0=\"{s:─<{n}}\"
pat_line_1=\"{s: <{n}}\"
if text_0!=\"\":
    list_line_0=text_0.split(\"\n\")
    n_0=np.max([len(line) for line in list_line_0])
    l_0=len(list_line_0)
    list_line_a=text_a.split(\"\n\")
    n_a=np.max([len(line) for line in list_line_a])
    l_a=len(list_line_a)

    for i in range(np.max([l_a,l_0])):
        pat_line=pat_line_1

        if i>=l_a:
            line_a=pat_line.format(s=\" \",n=n_a)
        else:
            line_a=pat_line.format(s=list_line_a[i],n=n_a)
        
        if i>=l_0:
            line_0=pat_line.format(s=\" \",n=n_0)
        else:
            line_0=pat_line.format(s=list_line_0[i],n=n_0)

        if i==0:
            line_a=line_a.replace(\" \",\"─\")
            ans+=line_a+\"────\"+line_0+\"\n\"
        else:
            ans+=line_a+\"    \"+line_0+\"\n\"

    ans=ans[0:-1]
else:
    ans=text_a



"(,)
的#19""(P代码2#18,测试#20)
测试#20"\"\"\"
+[P函数](,测试)

\"\"\"
text_a=\"\"\"
aaa
c
v
\"\"\"
text_0=text_a

list_line=text_0.split(\"\n\")
list_ns=[len(line) for line in list_line]
print(list_ns)




\"\"\"
+[P函数](,测试)
print('{s:X<{n}}'.format(s=\"11\",n=10))
print(f'{\"dog\": <10}'+'1')
print(f'{\"%s\":X<10}'%(\"AAA\"))

\"\"\""(,)
的#21""(写模块#12,P代码#22)
P代码#22"\"\"\"
    text_0=str_a+text_0.replace(\"\n\",\"\n\"+str_a)
print(text_0)
print(text_1)
+[P函数](,P代码)

\"\"\"
# print(var_name,pt_name)
if text_0==\"\":
    ans=var_name
else:
    str_a=\"├\"
    list_line=text_0.split(\"\n\")
    list_line_1=[]
    n_last=0
    for i in range(len(list_line)):
        line=list_line[i]
        if line[0]==\"|\" or line[0]==\"├\" or line[0]==\"└\" or line[0]==\" \":
            line=\"|\"+line
        else:
            n_last=i
            line=\"├\"+line
        list_line_1.append(line)
    for i in range(n_last,len(list_line_1)):
        if list_line_1[i][0]==\"|\":
            list_line_1[i]=' '+list_line_1[i][1:]
        else:
            list_line_1[i]='└'+list_line_1[i][1:]

    text_1=\"\n\".join(list_line_1)
    ans=var_name+\"\n\"+text_1


\"\"\"
print(text_1)
+[P函数](,P代码)

\"\"\""(,)
的#23""(库#8,代码模块#24)
代码模块#24"\"\"\"


\"\"\"
+代码模块(_文本,模块)->+[del](,+代码模块)...
->的(库,代码模块)->库(,)...

->[]{
    []:->函数(模块,)->的(库,函数模块)->函数模块(,)...
        ->+[做](_文本,模块)->+[code](+[做],函数模块),

    ->内容\"if\"(模块,)->的(库,如果模块)->如果模块(,)...
        ->+[做](_文本,模块)->+[code](+[做],如果模块),
    ->内容\"for\"(模块,)->的(库,for模块)->for模块(,)...
        ->+[做](_文本,模块)->+[code](+[做],for模块),

    ->的(库,一般模块)->一般模块(,)...
        ->+[做](_文本,模块)->+[code](+[做],一般模块)
}...

->[]{
    []:->顺序(模块,模块#1)->模块#1->+[做](_文本,模块#1)->+[code](+[做],代码模块),
    ->[]
}

"(,)
的#25""(库#8,函数模块#26)
函数模块#26"\"\"\"
模板:...

\"\"\"
+函数模块(_文本,模块)->+[del](,+函数模块)...
->的(函数模块,模板)->的(库,函数模块)->库->的(库,代码模块)...

->函数(模块,)...
->+[文本结构_插入尾部]\"
\"(_文本,+节点)...
->+[模板文本](模板,+节点)->+[.](+[模板文本],函数)...

->+[文本结构_插入]\"    \"(+节点,+运算)->[]{
    []:->内部(模块,模块#2)->模块#2->+[做](+运算,模块#2)->+[code](+[做],代码模块),
    ->[]
}

"(,)
的#27""(函数模块#26,模板#28)
模板#28"function %函数
%运算
end"(,)
的#29""(库#8,一般模块#30)
一般模块#30"\"\"\"
P代码:...

\"\"\"
+一般模块(_文本,模块)->+[del](,+一般模块)...
->的(一般模块,P代码)->的(库,一般模块)->库->的(库,代码模块)...

->模块(,_块)->_块(,_代码)...
->+[文本结构_插入尾部]\"
\"(_文本,+节点)...
->[]:
    ->_代码->+[python](Python,+节点)...
        ->+[code](+[python],P代码)->+[.]\"text\"(+[python],_代码),
    ->+[修改内容]\"%s;\"(_块,+节点)
"(,)
的#31""(一般模块#30,P代码#32)
P代码#32"\"\"\"
记住\"Python\"
print(re.sub())

\"\"\"

import re
ans=re.sub(r\"\n+$\",\"\",text)

"(,)
的#33""(库#8,如果模块#34)
如果模块#34"\"\"\"
if模板:...
elif模板:...
else模板:...

\"\"\"
+如果模块(_文本,模块)->+[del](,+如果模块)...
->的(如果模块,if模板)->的(如果模块,elif模板)->的(如果模块,else模板)...
->的(库,如果模块)->库->的(库,代码模块)...

->+[文本结构_插入尾部]\"
\"(_文本,+节点)...

->内部(模块,模块#1)->条件(模块#1,)...
->+[模板文本](if模板,+节点)->+[.]\"条件\"(+[模板文本],条件)...

->+[文本结构_插入]\"    \"(+节点,+运算)->[]{
    []:->内部(模块#1,模块#2)->模块#2->+[做](+运算,模块#2)->+[code](+[做],代码模块),
    ->[]
}...

->+[文本结构_插入](+节点,+elif)->[]{
    []=>内部(模块,模块#2)->模块#2{[]=>[is](模块#1,模块#2)}->条件(模块#2,)...
        =>+[文本结构_插入尾部](+elif,+节点#2)...
        ->+[模板文本](elif模板,+节点#2)->+[.]\"条件\"(+[模板文本],条件)...
        ->+[文本结构_插入]\"    \"(+节点#2,+运算#2)->[]:
            ->内部(模块#2,模块#3)->+[做](+运算#2,模块#3)->+[code](+[做],代码模块),
            ->[]
}...

->+[文本结构_插入](+节点,+else)->[]{
    []:->内部(模块,模块#2)->模块#2->内容\"else\"(模块#2,)->内部(模块#2,模块#3)...
        ->+[修改内容](else模板,+else)->+[文本结构_插入]\"    \"(+else,+运算#2)...
        ->+[做](+运算#2,模块#3)->+[code](+[做],代码模块),
    ->[]
}


"(,)
的#35""(如果模块#34,else模板#36)
else模板#36"
else
%运算"(,)
的#37""(如果模块#34,elif模板#38)
elif模板#38"
elseif %条件
%运算"(,)
的#39""(如果模块#34,if模板#40)
if模板#40"if %条件
%运算%elif%else
end"(,)
的#41""(库#8,for模块#42)
for模块#42"\"\"\"
模板:...

\"\"\"
+for模块(_文本,模块)->+[del](,+for模块)...
->的(for模块,模板)->的(库,for模块)->库->的(库,代码模块)...

->模块(,_块)->_块(,_循环)->条件(_循环,初始化)->初始化(,cmd)...
->+[文本结构_插入尾部]\"
\"(_文本,+节点)...
->+[模板文本](模板,+节点)->+[.]\"条件\"(+[模板文本],cmd)...

->+[文本结构_插入]\"    \"(+节点,+运算)->[]{
    []:->内部(模块,模块#2)->模块#2->+[做](+运算,模块#2)->+[code](+[做],代码模块),
    ->[]
}

"(,)
的#43""(for模块#42,模板#44)
模板#44"for %条件
%运算
end"(,)
的#45""(生成结构#6,描述结构#46)
描述结构#46"\"\"\"
收集块:...

\"\"\"
+描述结构(_媒介,结构)->+操作(+描述结构,)...

->的(_媒介,起点)->起点(,块)->+观察(+代码块,块)->[观察代码结构](_媒介,+观察)...
->+[code]([想],收集块)->+[.]([想],+操作)->[想](结构,+观察)->o([想],模块)...

->+的(结构,+起点)->+起点(模块,)->[投影](,+的)->[投影](,+起点)...
->+的(+操作,+代码模块)->+代码模块(,模块)


"(,)
的#47""(描述结构#46,收集块#48)
收集块#48"\"\"\"
收集内容:...
+[新建阅读窗口](,收集内容)

保存:...

\"\"\"
+收集块(结构,观察)...

->观察(,_块)->+的(结构,+模块)->+模块\"1,1,1\"(,_块)...
    ->+的#2(结构,+内容)->+内容(+模块,)...
        ->+[code]([想]#0,收集内容)->[想]#0(观察,+内容)...
    ->[投影](,+的)->[投影](,+模块)->[投影](,+的#2)->[投影](,+内容)...

->[]{
    []:->条件(观察,条件#1)->条件#1(,_cond)->+的(结构,+模块#2)->+模块#2\"1,1,1\"...
        ->+条件#2(+模块#2,)->+的#2(结构,+条件#2)->[m_text](_cond,+条件#2)...
        ->[投影](,+的)->[投影](,+模块#2)->[投影](,+的#2)->[投影](,+条件#2)...
        ->+内部(+模块#2,+模块)->+的(结构,+内部)->[投影](,+的)->[投影](,+内部)...
    ->+[o](+收集块,+模块#2),

    ->否则(观察,)...
        ->+模块#2\"1,1,1\"->+的(结构,+模块#2)->[投影](,+的)->[投影](,+模块#2)...
        ->+内容\"else\"(+模块#2,)->+的(结构,+内容)->[投影](,+的)->[投影](,+内容)...
        ->+内部(+模块#2,+模块)->+的(结构,+内部)->[投影](,+的)->[投影](,+内部)...
    ->+[o](+收集块,+模块#2),

    ->+[o](+收集块,+模块)
}...

->[]{
    []=>然后\"运算\"(观察,观察#2)->观察#2=>+[code]([想],收集块)...
        ->[想](结构,观察#2)->o([想],模块#2)...
        ->+内部(+模块,模块#2)->+的(结构,+内部)->[投影](,+的)->[投影](,+内部)
}...
->[]{
    []=>然后\"顺序\"(观察,观察#2)->观察#2=>+[code]([想],收集块)...
        ->[想](结构,观察#2)->o([想],模块#2)...
        ->+顺序(+模块,模块#2)->+的(结构,+顺序)->[投影](,+的)->[投影](,+顺序)
}

"(,)
的#49""(收集块#48,保存#50)
保存#50"\"\"\"
P代码:...
P代码1:...
P代码2:...
收集内容:...
+[新建阅读窗口](,P代码)

\"\"\"
+收集块(结构,观察)...

->观察(,_块)->+的(结构,+模块)->+模块\"1,1,1\"(,_块)->+[o](+收集块,+模块)...
    ->+的#2(结构,+内容)->+内容(+模块,)...
        ->+[code]([想]#0,收集内容)->[想]#0(观察,+内容)...
    ->[投影](,+的)->[投影](,+模块)->[投影](,+的#2)->[投影](,+内容)...

->+[code]([python]#0,P代码1)...
    ->+[.]\"func_name\"([python]#0,+内容)->+[.]\"bk1\"([python]#0,+模块)...
    ->[python]#0(Python,+模块)...
->[]{
    []=>然后\"运算\"(观察,观察#2)->观察#2=>+[code]([想],收集块)...
        ->[想](结构,观察#2)->o([想],模块#2)...
        ->+内部(+模块,模块#2)->+的(结构,+内部)->[投影](,+的)->[投影](,+内部)...
        ->+[code]([python],P代码)...
        ->+[.]\"bk1\"([python],+模块)->+[.]\"bk2\"([python],模块#2)...
        ->[python](Python,+模块)
}...
->[]{
    []=>然后\"顺序\"(观察,观察#2)->观察#2=>+[code]([想],收集块)...
        ->[想](结构,观察#2)->o([想],模块#2)...
        ->+顺序(+模块,模块#2)->+的(结构,+顺序)->[投影](,+的)->[投影](,+顺序)...
        ->+[code]([python],P代码2)...
        ->+[.]\"bk1\"([python],+模块)->+[.]\"bk2\"([python],模块#2)...
        ->[python](Python,+模块)
}

"(,)
的#51""(收集块#48,收集内容#52)
收集内容#52"\"\"\"
    ->否则(观察,)->[m_text]\"else\"(,内容),

\"\"\"
+收集内容(观察,内容)...

->观察(,_块)->[]{
    []:->如果(观察,)->[m_text]\"if\"(,内容),
    ->循环(观察,)->_块(,循环#1)->循环#1->[m_text](循环#1,内容),
    ->函数(观察,)->.\"函数\"(观察,_模块)->_模块(,name)...
        ->[m_text](name,内容)->[m_name](+函数,内容),
    ->[m_text]\"code\"(,内容)
}


"(,)
的#53""(代码结构转代码#0,召唤规则#54)
召唤规则#54"\"\"\"

\"\"\"

+召唤规则(_题目,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_代码)...

->[==]\"代码结构转代码\"(,召唤星辰)...

->+整理结构(_题目,_代码)->+的(操作,+整理结构)...
->+生成结构(_题目,_代码)->+的(操作,+生成结构)


"(,)

## end
#5866, 490:
"""


"""
+代码模块(_文本,模块)->+[del](,+代码模块)...
->的(库,代码模块)->库(,)...

->[]{
    []:->函数(模块,)->的(库,函数模块)->函数模块(,)...
        ->+[做](_文本,模块)->+[code](+[做],函数模块),

    ->内容"if"(模块,)->的(库,如果模块)->如果模块(,)...
        ->+[做](_文本,模块)->+[code](+[做],如果模块),
    ->内容"for"(模块,)->的(库,for模块)->for模块(,)...
        ->+[做](_文本,模块)->+[code](+[做],for模块),

    ->的(库,一般模块)->一般模块(,)...
        ->+[做](_文本,模块)->+[code](+[做],一般模块)
}...

->[]{
    []:->顺序(模块,模块#1)->模块#1->+[做](_文本,模块#1)->+[code](+[做],代码模块),
    ->[]
}


## end
#5868, 283:
"""
模板:...

"""
+函数模块(_文本,模块)->+[del](,+函数模块)...
->的(函数模块,模板)->的(库,函数模块)->库->的(库,代码模块)...

->函数(模块,)...
->+[文本结构_插入尾部]"
"(_文本,+节点)...
->+[模板文本](模板,+节点)->+[.](+[模板文本],函数)...

->+[文本结构_插入]"    "(+节点,+运算)->[]{
    []:->内部(模块,模块#2)->模块#2->+[做](+运算,模块#2)->+[code](+[做],代码模块),
    ->[]
}


## end
#5870, 276:
"""
P代码:...

"""
+一般模块(_文本,模块)->+[del](,+一般模块)...
->的(一般模块,P代码)->的(库,一般模块)->库->的(库,代码模块)...

->模块(,_块)->_块(,_代码)...
->+[文本结构_插入尾部]"
"(_文本,+节点)...
->[]:
    ->_代码->+[python](Python,+节点)...
        ->+[code](+[python],P代码)->+[.]"text"(+[python],_代码),
    ->+[修改内容]"%s;"(_块,+节点)

## end
#5872, 4:
    
## end
#5874, 4:
    
## end
#5875, 4:
    
## end
#5877, 4:
    
## end
#5878, 4:
    
## end
#5880, 4:
    
## end
#5881, 4:
    
## end
#5882, 4:
    
## end
#5884, 4:
    
## end
#5885, 4:
    
## end
#5886, 4:
    
## end
#5888, 4:
    
## end
#5889, 4:
    
## end
#5890, 4:
    
## end
#5892, 4:
    
## end
#5893, 4:
    
## end
#5894, 4:
    
## end
#5895, 4:
    
## end
#5896, 4:
    
## end
#5898, 4:
    
## end
#5899, 4:
    
## end
#5900, 4:
    
## end
#5901, 4:
    
## end
#5902, 4:
    
## end
#5904, 4:
    
## end
#5905, 4:
    
## end
#5906, 4:
    
## end
#5907, 4:
    
## end
#5908, 4:
    
## end
#5910, 4:
    
## end
#5911, 4:
    
## end
#5912, 4:
    
## end
#5913, 4:
    
## end
#5914, 4:
    
## end
#5916, 76:
"""
记住"Python"
print(re.sub())

"""

import re
ans=re.sub(r"\n+$","",text)


## end
#5918, 4:
    
## end
#5919, 4:
    
## end
#5920, 4:
    
## end
#5921, 4:
    
## end
#5922, 4:
    
## end
#5923, 9:

else
%运算
## end
#5924, 15:

elseif %条件
%运算
## end
#5925, 24:
if %条件
%运算%elif%else
end
## end
#5929, 911:
"""
if模板:...
elif模板:...
else模板:...

"""
+如果模块(_文本,模块)->+[del](,+如果模块)...
->的(如果模块,if模板)->的(如果模块,elif模板)->的(如果模块,else模板)...
->的(库,如果模块)->库->的(库,代码模块)...

->+[文本结构_插入尾部]"
"(_文本,+节点)...

->内部(模块,模块#1)->条件(模块#1,)...
->+[模板文本](if模板,+节点)->+[.]"条件"(+[模板文本],条件)...

->+[文本结构_插入]"    "(+节点,+运算)->[]{
    []:->内部(模块#1,模块#2)->模块#2->+[做](+运算,模块#2)->+[code](+[做],代码模块),
    ->[]
}...

->+[文本结构_插入](+节点,+elif)->[]{
    []=>内部(模块,模块#2)->模块#2{[]=>[is](模块#1,模块#2)}->条件(模块#2,)...
        =>+[文本结构_插入尾部](+elif,+节点#2)...
        ->+[模板文本](elif模板,+节点#2)->+[.]"条件"(+[模板文本],条件)...
        ->+[文本结构_插入]"    "(+节点#2,+运算#2)->[]:
            ->内部(模块#2,模块#3)->+[做](+运算#2,模块#3)->+[code](+[做],代码模块),
            ->[]
}...

->+[文本结构_插入](+节点,+else)->[]{
    []:->内部(模块,模块#2)->模块#2->内容"else"(模块#2,)->内部(模块#2,模块#3)...
        ->+[修改内容](else模板,+else)->+[文本结构_插入]"    "(+else,+运算#2)...
        ->+[做](+运算#2,模块#3)->+[code](+[做],代码模块),
    ->[]
}



## end
#5932, 20:
function %函数
%运算
end
## end
#5939, 4:
    
## end
#5941, 4:
    
## end
#5942, 4:
    
## end
#5943, 4:
    
## end
#5945, 4:
    
## end
#5946, 4:
    
## end
#5947, 4:
    
## end
#5949, 4:
    
## end
#5950, 4:
    
## end
#5951, 4:
    
## end
#5953, 15:
for %条件
%运算
end
## end
#5955, 326:
"""
模板:...

"""
+for模块(_文本,模块)->+[del](,+for模块)...
->的(for模块,模板)->的(库,for模块)->库->的(库,代码模块)...

->模块(,_块)->_块(,_循环)->条件(_循环,初始化)->初始化(,cmd)...
->+[文本结构_插入尾部]"
"(_文本,+节点)...
->+[模板文本](模板,+节点)->+[.]"条件"(+[模板文本],cmd)...

->+[文本结构_插入]"    "(+节点,+运算)->[]{
    []:->内部(模块,模块#2)->模块#2->+[做](+运算,模块#2)->+[code](+[做],代码模块),
    ->[]
}


## end
#5958, 4:
    
## end
#5959, 4:
    
## end
#5960, 4:
    
## end
#5961, 4:
    
## end
#5963, 4:
    
## end
#5973, 9:
++depth>5
## end
#5974, 5:
1,1,1
## end
#5979, 13:
erand48(Xi)<p
## end
#5980, 5:
1,1,1
## end
#5982, 4:
code
## end
#5984, 5:
1,1,1
## end
#5991, 4:
else
## end
#5993, 5:
1,1,1
## end
#5994, 4:
code
## end
#5996, 5:
1,1,1
## end
#6000, 2:
if
## end
#6002, 5:
1,1,1
## end
#6006, 2:
if
## end
#6008, 5:
1,1,1
## end
#6014, 56:
if erand48(Xi)<p
    f=f*(1/p)
else
    return obj.e
end
## end
#6015, 30:
if ++depth>5
%运算%elif%else
end
## end
#6018, 1:


## end
#6019, 4:
    
## end
#6023, 12:
return obj.e
## end
#6024, 22:

else
    return obj.e
## end
#6026, 9:
f=f*(1/p)
## end
#6027, 34:
if erand48(Xi)<p
%运算%elif%else
end
## end
#6030, 1:


## end
#6031, 4:
    
## end
#6035, 9:
f=f*(1/p)
## end
#6038, 1:


## end
#6041, 4:
    
## end
#6045, 12:
return obj.e
## end
#6048, 1:


## end
### 结束