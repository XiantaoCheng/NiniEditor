### 节点
地址, 的, 草稿, 目录, 的, 的, 光路图, 的, 第一幅, 比例, 的, 尺寸, 的, 原点, 的, 坐标系, 是, 是, 是, 是, 是, 是, 是, 是, 是, 是, 是, 是, 的, PPT, 的, 节点数目统计, 20210604, 的, 20210831, 的, 的, iFAST光路, 的, 第一级放大, 的, 的, 的, 泵光2, 泵光1, 种子光, 的, 的, Crystal, M19, 的, 描述, 的, 的, 的, 的, 的, 经过, X6, 经过, S, 经过, 的, 的, 的, 的, 的, 的, 的, 的, 的, 经过, M18, 经过, X5, 经过, M17, 经过, M16, 经过, 的, 的, 从, 分出来, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 经过, Stretcher, 经过, 经过, M15, 经过, 经过, M14, 经过, I2, 经过, X4, 经过, Dazzler, 经过, Faraday, 经过, X3, 经过, M13, 经过, M12, 经过, I1, 经过, 经过, I0, 经过, X2, 经过, X1, 经过, M11, 经过, M10, 经过, 经过, X0, 经过, M9, 经过, M8, 经过, 经过, M7, 经过, M6, 经过, 经过, M5, 经过, M4, 经过, 经过, M3, 经过, M2, 经过, 经过, M1, 经过, M0, 经过, 经过, 2nd, 的, 位置, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 在, 空间点, 的, 在, 空间点, 的, 在, 空间点, 的, 在, 空间点, 的, 在, 空间点, 的, 在, 空间点, 的, 在, 空间点, 的, 在, 空间点, 的, 在, 空间点, 的, 在, 空间点, 的, 在, 空间点, 的, 在, 空间点, 的, 在, 空间点, 的, 在, 空间点, 的, 在, 空间点, 的, 在, 空间点, 的, 在, 空间点, 的, 在, 空间点, 的, 在, 空间点, 的, 在, 空间点, 的, 在, 空间点, 的, 在, 空间点, 的, 在, 空间点, 的, 在, 空间点, 的, 在, 空间点, 的, 在, 空间点, 的, 在, 空间点, 的, 在, 空间点, 的, 在, 空间点, 的, 在, 空间点, 的, 在, 空间点, 的, 在, 空间点, 的, 在, 空间点, 的, 在, 空间点, 的, 在, 空间点, 的, 在, 空间点, 的, 的, 的, 的, 的, 输入, 的, 输出, 的, 的, 的, 的, 的, 的, 的, 的, 的, 空间点, 在, 输入, 的, 输出, 的, 的, 的, 输出, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 反射, 反射, 反射, 反射, 反射, 反射, 反射, 反射, 反射, 反射, 反射, 反射, 反射, 反射, 反射, 反射, 反射, 反射, 反射, 反射, 反射, 的, 的, 反射, 反射, 的, 测试结构, 光线, 光线, 光线, 光线, 光线, 光线, 光线, 光线, 光线, 光线, 光线, 光线, 光线, 光线, 光线, 光线, 光线, 光线, 光线, 光线, 光线, 光线, 光线, 光线, 光线, 是, 终点, 是, 终点, 是, 起点, 是, 终点, 是, 起点, 是, 穿过, 是, 终点, 是, 起点, 是, 起点, 是, 终点, 是, 终点, 是, 起点, 是, 穿过, 是, 起点, 是, 终点, 是, 穿过, 是, 终点, 是, 起点, 是, 终点, 是, 起点, 是, 穿过, 是, 终点, 是, 起点, 是, 终点, 是, 起点, 是, 穿过, 是, 终点, 是, 起点, 是, 终点, 是, 起点, 是, 穿过, 是, 终点, 是, 起点, 是, 终点, 是, 起点, 是, 穿过, 是, 终点, 是, 起点, 是, 终点, 是, 起点, 是, 穿过, 是, 穿过, 是, 终点, 是, 起点, 是, 终点, 是, 起点, 是, 穿过, 是, 穿过, 是, 穿过, 是, 穿过, 是, 穿过, 是, 终点, 是, 起点, 是, 终点, 是, 起点, 是, 穿过, 是, 穿过, 是, 穿过, 是, 穿过, 是, 穿过, 是, 终点, 是, 起点, 是, 终点, 是, 起点, 是, 终点, 是, 起点, 是, 终点, 是, 起点, 是, 起点, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 方向, 朝着, 方向, 朝着, 方向, 朝着, 方向, 朝着, 方向, 朝着, 方向, 朝着, 方向, 朝着, 方向, 朝着, 方向, 朝着, 方向, 朝着, 方向, 朝着, 方向, 朝着, 方向, 朝着, 方向, 朝着, 方向, 朝着, 方向, 朝着, 方向, 朝着, 方向, 朝着, 方向, 朝着, 方向, 朝着, 方向, 朝着, 方向, 朝着, 方向, 朝着, 方向, 朝着, 方向, 朝着, 方向, 朝着, 方向, 朝着, 方向, 朝着, 方向, 朝着, 方向, 朝着, 方向, 朝着, 方向, 朝着, 方向, 朝着, 方向, 朝着, 方向, 朝着, 方向, 朝着, 的, 光线, 的, 光线, 的, 光线, 的, 光线, 的, 光线, 的, 光线, 的, 光线, 的, 光线, 的, 光线, 的, 光线, 的, 光线, 的, 光线, 的, 光线, 的, 光线, 的, 光线, 的, 光线, 的, 光线, 的, 光线, 的, 光线, 种子光, 的, 的, 光线, 的, 光线, 泵光1, 的, 的, 光线, 的, 光线, 的, 光线, 的, 光线, 的, 光线, 泵光2, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 焦点, 直径, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 焦点, 直径, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 焦点, 直径, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 焦点, 直径, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 焦点, 直径, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 焦点, 直径, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 焦点, 直径, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 焦点, 直径, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 焦点, 直径, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 焦点, 直径, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 焦点, 直径, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 焦点, 直径, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 焦点, 直径, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 焦点, 直径, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 焦点, 直径, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 焦点, 直径, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 焦点, 直径, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 焦点, 直径, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 焦点, 直径, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 焦点, 直径, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 焦点, 直径, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 焦点, 直径, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 焦点, 直径, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 焦点, 直径, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 焦点, 直径, 的, 是, 2nd, 的, 是, M0, 的, 是, M1, 的, 是, M2, 的, 是, M3, 的, 是, M4, 的, 是, M5, 的, 是, M6, 的, 是, M7, 的, 是, M8, 的, 是, M9, 的, 是, X0, 的, 是, M10, 的, 是, M11, 的, 是, X1, 的, 是, X2, 的, 是, I0, 的, 是, I1, 的, 是, M12, 的, 是, M13, 的, 是, X3, 的, 是, Faraday, 的, 是, Dazzler, 的, 是, X4, 的, 是, I2, 的, 是, M14, 的, 是, M15, 的, 是, Stretcher, 的, 是, M16, 的, 是, M17, 的, 是, X5, 的, 是, M18, 的, 是, S, 的, 是, X6, 的, 是, M19, 的, 是, Crystal, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 第二幅, 的, 的, 的, 的, 的, 分出来, 散射光, 输入光, 声波, 晶体, 的, 的, 的, 的, 尺寸, 的, 空间点, 在, 的, 的, 的, 尺寸, 的, 在, 的, 流程图, 20220120, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 内容, 的, 样式, 尺寸, 的, 空间点, 在, 矩形8, 内容, 的, 样式, 尺寸, 的, 空间点, 在, 矩形7, 内容, 的, 样式, 尺寸, 的, 空间点, 在, 矩形6, 内容, 的, 样式, 尺寸, 的, 空间点, 在, 矩形5, 内容, 的, 样式, 尺寸, 的, 空间点, 在, 矩形4, 内容, 的, 样式, 尺寸, 的, 空间点, 在, 矩形3, 内容, 的, 样式, 尺寸, 的, 空间点, 在, 矩形2, 内容, 的, 样式, 尺寸, 的, 空间点, 在, 矩形1, 内容, 的, 样式, 尺寸, 的, 空间点, 在, 矩形0, 的, 框架, 的, 窗口, 的, 的, 的, 的, 尺寸, 的, 空间点, 在, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 尺寸, 的, 空间点, 在, 的, 的, 屏幕, 的, 的, 地址, 的, 箭头, 的, 的, 类型, 的, y, 的, x, 的, 的, 的, 方向, 朝向, 的, 的, 长度, 的, 的, 的, 箭头长度, 的, 的, 的, 箭头宽度, 的, 的, 的, 空间点, 在, 的, 的, 箭头2, 类型, 的, x, 的, y, 的, 长度, 的, 箭头长度, 的, 箭头宽度, 的, 复制图形, 的, 的, 的, 空间点, 在, 的, 的, 方向, 朝向, 20220121, 的, 的, 测试, 的, 圆形, 的, 的, 的, 类型, 的, y, 的, x, 的, 的, 晶体, 的, 场景, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 样式, 类型, 的, 方向, 朝向, 空间点, 在, L1, 样式, 类型, 的, 方向, 朝向, 空间点, 在, L0, 的, y, 的, x, 的, 的, y, 的, x, 的, 的, 的, 的, 的, 的, 的, 的, 的, 样式, 类型, 的, 方向, 朝向, 空间点, 在, 圆柱0, 的, 的, 三维场景, 的, 圆柱体, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, Z, 的, Y, 的, X, 的, 样式, 方向, 朝向, 空间点, 在, 的, 圆柱体1, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, Z, 的, Y, 的, X, 的, 样式, 方向, 朝向, 空间点, 在, 的, 的, 形状, 的, 的, 的, 直径, 的, 的, 的, 高, 的, 的, 模拟场景, 手, 模拟空间, 的, 窗口, 的, 电子, 的, 光束, 的, 的, 参考波长, y, 的, x, 的, 空间点, 在, 宽度, 的, 长度, 的, 样式, 类型, 的, y, 的, x, 的, 空间点, 在, 宽度, 的, 长度, 的, 样式, 类型, 的, 启动时间, 的, 数密度, 的, gamma, 的, beta_r, 的, 延时函数, 的, 空间点, 在, 腰宽, 的, 展宽, 的, 焦点位置, 的, a0, 的, 偏振态, 的, 的, A, 空间点, 在, 的, 预览动画, 动画, 画图, 初始化, 序号, 的, 动画, 画图, 初始化, 的, 保存代码, 的, fx, 的, ft, 20221001, 的, 探测场, 的, 探测类型, 的, 时间间隔, 的, 探测间隔, 的, 表达式, 的, 公式, 的, 数据地址, 表达式, 的, 公式, 20221116, 的, 的, 水管图, 手, outer, 的, inner, 的, TSFV, 的, HeatEx, 的, A1, 的, A2, 的, A3, 的, A4, 的, A5, 的, A6, 的, A7, 的, A8, 的, A9, 的, A10, 的, A11, 的, A12, 的, 空间点, 在, 空间点, 在, 空间点, 在, 空间点, 在, 空间点, 在, 空间点, 在, 空间点, 在, 空间点, 在, 空间点, 在, 空间点, 在, 空间点, 在, 空间点, 在, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 样式, y, 的, x, 的, 类型, 的, B1, 的, B2, 的, B3, 的, B4, 的, B5, 的, B6, 的, B7, 的, B8, 的, B9, 的, B10, 的, B11, 的, B12, 的, 空间点, 在, 空间点, 在, 空间点, 在, 空间点, 在, 空间点, 在, 空间点, 在, 空间点, 在, 空间点, 在, 空间点, 在, 空间点, 在, 空间点, 在, 空间点, 在, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 样式, y, 的, x, 的, 类型, 的, 的, 外部水管, 手, 的, 线路1, 的, 线路2, 的, A1, 的, A2, 的, A3, 的, A4, 的, 空间点, 在, 空间点, 在, 空间点, 在, 空间点, 在, 20221130, 的, B1, 的, B2, 的, B3, 的, B4, 的, B5, 的, B6, 的, 空间点, 在, 空间点, 在, 空间点, 在, 空间点, 在, 空间点, 在, 空间点, 在, 线路3, 的, 线路4, 的, C1, 的, C2, 的, C3, 的, C4, 的, C5, 的, C6, 的, D1, 的, D2, 的, D3, 的, D4, 的, D5, 的, D6, 的, 空间点, 在, 空间点, 在, 空间点, 在, 空间点, 在, 空间点, 在, 空间点, 在, 空间点, 在, 空间点, 在, 空间点, 在, 空间点, 在, 空间点, 在, 空间点, 在, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 样式, y, 的, x, 的, 类型, 的, 样式, y, 的, x, 的, 类型, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 样式, y, 的, x, 的, 类型, 的, 样式, y, 的, x, 的, 类型, 的, 的, 线路0, E1, 的, E2, 的, 空间点, 在, 空间点, 在, 经过, 的, 经过, 的, 经过, 的, 经过, 的, 样式, y, 的, x, 的, 类型, 的, PS140, 的, room1, 的, room2, 的, 走廊1, 的, 走廊2, 的, y, 的, x, 的, 空间点, 在, 宽度, 的, 长度, 的, 样式, 类型, 的, y, 的, x, 的, 空间点, 在, 宽度, 的, 长度, 的, 样式, 类型, 的, y, 的, x, 的, 空间点, 在, 宽度, 的, 长度, 的, 样式, 类型, 的, y, 的, x, 的, 空间点, 在, 宽度, 的, 长度, 的, 样式, 类型, 的, y, 的, x, 的, 空间点, 在, 宽度, 的, 长度, 的, 样式, 类型, 的, 
### 关联
#, 2#0, #, #, 3#2, 2#6, #, 2#8, #, #, 15#9, #, 15#11, #, 15#13, 8#, #, #, #, #, #, #, #, #, #, #, #, #, 2#29, #, 3#31, #, #, 31#32, #, 31#34, 2#37, #, 8#39, #, 39#43, 39#44, 39#45, #, #, #, 39#48, 39#49, #, #, 39#51, #, 39#57, 39#58, 39#59, 39#60, 39#61, 44#58, #, 44#60, #, 44#48, 39#71, 39#72, 39#73, 39#74, 39#75, 39#76, 39#77, 39#78, 39#79, 43#72, #, 43#74, #, 43#76, #, 43#78, #, 43#48, 39#82, 39#83, 83#59, 44#43, 39#149, 39#150, 39#151, 39#152, 39#153, 39#154, 39#155, 39#156, 39#157, 39#158, 39#159, 39#160, 39#161, 39#162, 39#163, 39#164, 39#165, 39#166, 39#167, 39#168, 39#169, 39#170, 39#171, 39#172, 39#173, 39#174, 39#175, 39#176, 39#177, 39#178, 39#179, 39#180, 39#181, 39#182, 39#183, 39#184, 39#185, 39#186, 39#187, 39#188, 39#189, 39#190, 39#191, 39#192, 39#193, 39#194, 39#195, 39#196, 39#197, 39#198, 39#199, 39#200, 39#201, 39#202, 39#203, 39#204, 39#205, 39#206, 39#207, 39#208, 39#209, 39#210, 39#211, 39#212, 39#213, 45#150, #, 45#49, 45#153, #, 45#49, 45#156, #, 45#158, #, 45#160, #, 45#162, #, 45#164, #, 45#166, #, 45#168, #, 45#170, #, 45#172, #, 45#48, 45#175, #, 45#177, #, 45#179, #, 45#181, #, 45#183, #, 45#48, 45#186, #, 45#188, #, 45#190, #, 45#48, 45#193, #, 45#195, #, 45#48, 45#198, #, 45#200, #, 45#48, 45#203, #, 45#205, #, 45#48, 45#208, #, 45#210, #, 45#48, 45#213, #, 39#215, #, 39#324, 39#325, 39#326, 39#327, 39#328, 39#329, 39#330, 39#331, 39#332, 39#333, 39#334, 39#335, 39#336, 39#337, 39#338, 39#339, 39#340, 39#341, 39#342, 39#343, 39#344, 39#345, 39#346, 39#347, 39#348, 39#349, 39#350, 39#351, 39#352, 39#353, 39#354, 39#355, 39#356, 39#357, 39#358, 39#359, 39#360, 39#361, 39#362, 39#363, 39#364, 39#365, 39#366, 39#367, 39#368, 39#369, 39#370, 39#371, 39#372, 39#373, 39#374, 39#375, 39#376, 39#377, 39#378, 39#379, 39#380, 39#381, 39#382, 39#383, 39#384, 39#385, 39#386, 39#387, 39#388, 39#389, 39#390, 39#391, 39#392, 39#393, 39#394, 39#395, 39#396, 39#397, 39#398, 39#399, 39#400, 39#401, 39#402, 39#403, 39#404, 39#405, 39#406, 39#407, 39#408, 39#409, 39#410, 39#411, 39#412, 39#413, 39#414, 39#415, 39#416, 39#417, 39#418, 39#419, 39#420, 39#421, 39#422, 39#423, 39#424, 39#425, 39#426, 39#427, 39#428, 39#429, 39#430, 39#431, 48#325, #, 215#325, 49#328, #, 215#328, 58#331, #, 215#331, 60#334, #, 215#334, 72#337, #, 215#337, 74#340, #, 215#340, 76#343, #, 215#343, 78#346, #, 215#346, 150#349, #, 215#349, 153#352, #, 215#352, 156#355, #, 215#355, 158#358, #, 215#358, 160#361, #, 215#361, 162#364, #, 215#364, 164#367, #, 215#367, 166#370, #, 215#370, 168#373, #, 215#373, 170#376, #, 215#376, 172#379, #, 215#379, 175#382, #, 215#382, 177#385, #, 215#385, 179#388, #, 215#388, 181#391, #, 215#391, 183#394, #, 215#394, 186#397, #, 215#397, 188#400, #, 215#400, 190#403, #, 215#403, 193#406, #, 215#406, 195#409, #, 215#409, 198#412, #, 215#412, 200#415, #, 215#415, 203#418, #, 215#418, 205#421, #, 215#421, 208#424, #, 215#424, 210#427, #, 215#427, 213#430, #, 215#430, 39#436, 39#437, 39#438, 39#439, #150, 45#436, #213, 45#438, 39#447, 39#448, 39#449, 39#450, 39#451, 39#452, 39#453, 215#448, #, 450#448, #, 44#450, #48, 44#452, 39#456, 39#457, #48, 43#456, 39#479, 39#480, 39#481, 39#482, 39#483, 39#484, 39#485, 39#486, 39#487, 39#488, 39#489, 39#490, 39#491, 39#492, 39#493, 39#494, 39#495, 39#496, 39#497, 39#498, 39#499, 71#, 75#, 77#, 151#, 152#, 154#, 155#, 167#, 169#, 180#, 182#, 187#, 189#, 192#, 194#, 197#, 199#, 202#, 204#, 207#, 209#, 39#502, 39#503, 59#, 149#, 39#505, #, #, 506#, 507#, 508#, 509#, 510#, 511#, 512#, 513#, 514#, 515#, 516#, 517#, 518#, 519#, 520#, 521#, 522#, 523#, #, 525#, 526#, 527#, 528#, 529#, 532#456, 530#456, 534#77, 529#78, 536#77, 530#78, 538#75, 528#76, 540#75, 529#76, 542#73, 528#74, 544#71, 527#72, 546#71, 528#72, 548#82, 527#60, 550#452, 526#452, 552#59, 525#60, 554#59, 526#60, 556#57, 525#58, 558#450, 525#450, 560#438, 524#438, 562#211, 524#48, 564#209, 523#210, 566#209, 524#210, 568#207, 522#208, 570#207, 523#208, 572#206, 522#48, 574#204, 521#205, 576#204, 522#205, 578#202, 520#203, 580#202, 521#203, 582#201, 520#48, 584#199, 519#200, 586#199, 520#200, 588#197, 518#198, 590#197, 519#198, 592#196, 518#48, 594#194, 517#195, 596#194, 518#195, 598#192, 516#193, 600#192, 517#193, 602#191, 516#48, 604#189, 515#190, 606#189, 516#190, 608#187, 514#188, 610#187, 515#188, 612#185, 514#186, 614#184, 514#48, 616#182, 513#183, 618#182, 514#183, 620#180, 512#181, 622#180, 513#181, 624#178, 512#179, 626#176, 512#177, 628#174, 512#175, 630#173, 512#48, 632#171, 512#172, 634#169, 511#170, 636#169, 512#170, 638#167, 510#168, 640#167, 511#168, 642#165, 510#166, 644#163, 510#164, 646#161, 510#162, 648#159, 510#160, 650#157, 510#158, 652#155, 509#156, 654#155, 510#156, 656#154, 508#49, 658#154, 509#49, 660#152, 507#153, 662#152, 508#153, 664#151, 506#49, 666#151, 507#49, 668#436, 506#436, 505#524, 505#506, 505#507, 505#508, 505#509, 505#510, 505#511, 505#512, 505#513, 505#514, 505#515, 505#516, 505#517, 505#518, 505#519, 505#520, 505#521, 505#522, 505#523, 505#526, 505#525, 505#530, 505#527, 505#528, 505#529, 505#532, 505#531, 505#536, 505#535, 505#534, 505#533, 505#540, 505#539, 505#538, 505#537, 505#542, 505#541, 505#546, 505#545, 505#544, 505#543, 505#548, 505#547, 505#550, 505#549, 505#554, 505#553, 505#552, 505#551, 505#556, 505#555, 505#558, 505#557, 505#560, 505#559, 505#562, 505#561, 505#566, 505#565, 505#564, 505#563, 505#570, 505#569, 505#568, 505#567, 505#572, 505#571, 505#576, 505#575, 505#574, 505#573, 505#580, 505#579, 505#578, 505#577, 505#582, 505#581, 505#586, 505#585, 505#584, 505#583, 505#590, 505#589, 505#588, 505#587, 505#592, 505#591, 505#596, 505#595, 505#594, 505#593, 505#600, 505#599, 505#598, 505#597, 505#602, 505#601, 505#606, 505#605, 505#604, 505#603, 505#610, 505#609, 505#608, 505#607, 505#612, 505#611, 505#614, 505#613, 505#618, 505#617, 505#616, 505#615, 505#622, 505#621, 505#620, 505#619, 505#624, 505#623, 505#626, 505#625, 505#628, 505#627, 505#630, 505#629, 505#632, 505#631, 505#636, 505#635, 505#634, 505#633, 505#640, 505#639, 505#638, 505#637, 505#642, 505#641, 505#644, 505#643, 505#646, 505#645, 505#648, 505#647, 505#650, 505#649, 505#654, 505#653, 505#652, 505#651, 505#658, 505#657, 505#656, 505#655, 505#662, 505#661, 505#660, 505#659, 505#666, 505#665, 505#664, 505#663, 505#668, 505#667, 39#904, 39#905, 39#906, 39#907, 39#908, 39#909, 39#910, 39#911, 39#912, 39#913, 39#914, 39#915, 39#916, 39#917, 39#918, 39#919, 39#920, 39#921, 39#922, 39#923, 39#924, 39#925, 39#926, 39#927, 39#928, 39#929, 39#930, 39#931, 39#932, 39#933, 39#934, 39#935, 39#936, 39#937, 39#938, 39#939, 39#940, 39#941, 39#942, 39#943, 39#944, 39#945, 39#946, 39#947, 39#948, 39#949, 39#950, 39#951, 39#952, 39#953, 39#954, 39#955, 39#956, 39#957, 39#958, 39#959, 39#960, 39#961, 39#962, 39#963, 39#964, 39#965, 39#966, 39#967, 39#968, 39#969, 39#970, 39#971, 39#972, 39#973, 39#974, 39#975, #, 48#904, #, 49#906, #, 58#908, #, 60#910, #, 72#912, #, 74#914, #, 76#916, #, 78#918, #, 150#920, #, 153#922, #, 156#924, #, 158#926, #, 160#928, #, 162#930, #, 164#932, #, 166#934, #, 168#936, #, 170#938, #, 172#940, #, 175#942, #, 177#944, #, 179#946, #, 181#948, #, 183#950, #, 186#952, #, 188#954, #, 190#956, #, 193#958, #, 195#960, #, 198#962, #, 200#964, #, 203#966, #, 205#968, #, 208#970, #, 210#972, #, 213#974, 8#977, #, 8#979, #, 8#981, #, 8#983, #, 8#985, #, 8#987, #, 8#989, #, 8#991, #, 8#993, #, 8#995, #, 8#997, #, 8#999, #, 8#1001, #, 8#1003, #, 8#1005, #, 8#1007, #, 8#1009, #, 8#1011, #, 8#1013, #, #, 8#1014, 8#1017, #, 8#1019, #, #, 8#1020, 8#1023, #, 8#1025, #, 8#1027, #, 8#1029, #, 8#1031, #, #, 8#1032, 1031#1076, 1031#1077, 1031#1045, 1031#1053, 1031#1054, 1031#1078, 1031#1079, 1031#1066, 1031#1080, 1031#1081, 1031#1082, #, 1045#1068, 1045#1050, 1045#1051, 1045#1052, #, #, #, #, #, 1054#1058, 1054#1062, 1054#1063, #, 1058#1076, 1058#1077, 1058#1082, #, #, 1063#1065, #, #, 1066#1068, #, 1068#1076, 1068#1077, 1068#1078, 1068#1080, 1068#1079, 1068#1081, 1068#1082, #, #, #, #, #, #, #, 1032#1031, 1029#1126, 1029#1127, 1029#1095, 1029#1103, 1029#1104, 1029#1128, 1029#1129, 1029#1116, 1029#1130, 1029#1131, 1029#1132, #, 1095#1118, 1095#1100, 1095#1101, 1095#1102, #, #, #, #, #, 1104#1108, 1104#1112, 1104#1113, #, 1108#1126, 1108#1127, 1108#1132, #, #, 1113#1115, #, #, 1116#1118, #, 1118#1126, 1118#1127, 1118#1128, 1118#1130, 1118#1129, 1118#1131, 1118#1132, #, #, #, #, #, #, #, 1032#1029, 1027#1176, 1027#1177, 1027#1145, 1027#1153, 1027#1154, 1027#1178, 1027#1179, 1027#1166, 1027#1180, 1027#1181, 1027#1182, #, 1145#1168, 1145#1150, 1145#1151, 1145#1152, #, #, #, #, #, 1154#1158, 1154#1162, 1154#1163, #, 1158#1176, 1158#1177, 1158#1182, #, #, 1163#1165, #, #, 1166#1168, #, 1168#1176, 1168#1177, 1168#1178, 1168#1180, 1168#1179, 1168#1181, 1168#1182, #, #, #, #, #, #, #, 1032#1027, 1025#1226, 1025#1227, 1025#1195, 1025#1203, 1025#1204, 1025#1228, 1025#1229, 1025#1216, 1025#1230, 1025#1231, 1025#1232, #, 1195#1218, 1195#1200, 1195#1201, 1195#1202, #, #, #, #, #, 1204#1208, 1204#1212, 1204#1213, #, 1208#1226, 1208#1227, 1208#1232, #, #, 1213#1215, #, #, 1216#1218, #, 1218#1226, 1218#1227, 1218#1228, 1218#1230, 1218#1229, 1218#1231, 1218#1232, #, #, #, #, #, #, #, 1032#1025, 1019#1276, 1019#1277, 1019#1245, 1019#1253, 1019#1254, 1019#1278, 1019#1279, 1019#1266, 1019#1280, 1019#1281, 1019#1282, #, 1245#1268, 1245#1250, 1245#1251, 1245#1252, #, #, #, #, #, 1254#1258, 1254#1262, 1254#1263, #, 1258#1276, 1258#1277, 1258#1282, #, #, 1263#1265, #, #, 1266#1268, #, 1268#1276, 1268#1277, 1268#1278, 1268#1280, 1268#1279, 1268#1281, 1268#1282, #, #, #, #, #, #, #, 1020#1019, 1017#1326, 1017#1327, 1017#1295, 1017#1303, 1017#1304, 1017#1328, 1017#1329, 1017#1316, 1017#1330, 1017#1331, 1017#1332, #, 1295#1318, 1295#1300, 1295#1301, 1295#1302, #, #, #, #, #, 1304#1308, 1304#1312, 1304#1313, #, 1308#1326, 1308#1327, 1308#1332, #, #, 1313#1315, #, #, 1316#1318, #, 1318#1326, 1318#1327, 1318#1328, 1318#1330, 1318#1329, 1318#1331, 1318#1332, #, #, #, #, #, #, #, 1020#1017, 1013#1376, 1013#1377, 1013#1345, 1013#1353, 1013#1354, 1013#1378, 1013#1379, 1013#1366, 1013#1380, 1013#1381, 1013#1382, #, 1345#1368, 1345#1350, 1345#1351, 1345#1352, #, #, #, #, #, 1354#1358, 1354#1362, 1354#1363, #, 1358#1376, 1358#1377, 1358#1382, #, #, 1363#1365, #, #, 1366#1368, #, 1368#1376, 1368#1377, 1368#1378, 1368#1380, 1368#1379, 1368#1381, 1368#1382, #, #, #, #, #, #, #, 1014#1013, 1011#1426, 1011#1427, 1011#1395, 1011#1403, 1011#1404, 1011#1428, 1011#1429, 1011#1416, 1011#1430, 1011#1431, 1011#1432, #, 1395#1418, 1395#1400, 1395#1401, 1395#1402, #, #, #, #, #, 1404#1408, 1404#1412, 1404#1413, #, 1408#1426, 1408#1427, 1408#1432, #, #, 1413#1415, #, #, 1416#1418, #, 1418#1426, 1418#1427, 1418#1428, 1418#1430, 1418#1429, 1418#1431, 1418#1432, #, #, #, #, #, #, #, 1014#1011, 1009#1476, 1009#1477, 1009#1445, 1009#1453, 1009#1454, 1009#1478, 1009#1479, 1009#1466, 1009#1480, 1009#1481, 1009#1482, #, 1445#1468, 1445#1450, 1445#1451, 1445#1452, #, #, #, #, #, 1454#1458, 1454#1462, 1454#1463, #, 1458#1476, 1458#1477, 1458#1482, #, #, 1463#1465, #, #, 1466#1468, #, 1468#1476, 1468#1477, 1468#1478, 1468#1480, 1468#1479, 1468#1481, 1468#1482, #, #, #, #, #, #, #, 1014#1009, 1007#1526, 1007#1527, 1007#1495, 1007#1503, 1007#1504, 1007#1528, 1007#1529, 1007#1516, 1007#1530, 1007#1531, 1007#1532, #, 1495#1518, 1495#1500, 1495#1501, 1495#1502, #, #, #, #, #, 1504#1508, 1504#1512, 1504#1513, #, 1508#1526, 1508#1527, 1508#1532, #, #, 1513#1515, #, #, 1516#1518, #, 1518#1526, 1518#1527, 1518#1528, 1518#1530, 1518#1529, 1518#1531, 1518#1532, #, #, #, #, #, #, #, 1014#1007, 1005#1576, 1005#1577, 1005#1545, 1005#1553, 1005#1554, 1005#1578, 1005#1579, 1005#1566, 1005#1580, 1005#1581, 1005#1582, #, 1545#1568, 1545#1550, 1545#1551, 1545#1552, #, #, #, #, #, 1554#1558, 1554#1562, 1554#1563, #, 1558#1576, 1558#1577, 1558#1582, #, #, 1563#1565, #, #, 1566#1568, #, 1568#1576, 1568#1577, 1568#1578, 1568#1580, 1568#1579, 1568#1581, 1568#1582, #, #, #, #, #, #, #, 1014#1005, 1003#1626, 1003#1627, 1003#1595, 1003#1603, 1003#1604, 1003#1628, 1003#1629, 1003#1616, 1003#1630, 1003#1631, 1003#1632, #, 1595#1618, 1595#1600, 1595#1601, 1595#1602, #, #, #, #, #, 1604#1608, 1604#1612, 1604#1613, #, 1608#1626, 1608#1627, 1608#1632, #, #, 1613#1615, #, #, 1616#1618, #, 1618#1626, 1618#1627, 1618#1628, 1618#1630, 1618#1629, 1618#1631, 1618#1632, #, #, #, #, #, #, #, 1014#1003, 1001#1676, 1001#1677, 1001#1645, 1001#1653, 1001#1654, 1001#1678, 1001#1679, 1001#1666, 1001#1680, 1001#1681, 1001#1682, #, 1645#1668, 1645#1650, 1645#1651, 1645#1652, #, #, #, #, #, 1654#1658, 1654#1662, 1654#1663, #, 1658#1676, 1658#1677, 1658#1682, #, #, 1663#1665, #, #, 1666#1668, #, 1668#1676, 1668#1677, 1668#1678, 1668#1680, 1668#1679, 1668#1681, 1668#1682, #, #, #, #, #, #, #, 1014#1001, 999#1726, 999#1727, 999#1695, 999#1703, 999#1704, 999#1728, 999#1729, 999#1716, 999#1730, 999#1731, 999#1732, #, 1695#1718, 1695#1700, 1695#1701, 1695#1702, #, #, #, #, #, 1704#1708, 1704#1712, 1704#1713, #, 1708#1726, 1708#1727, 1708#1732, #, #, 1713#1715, #, #, 1716#1718, #, 1718#1726, 1718#1727, 1718#1728, 1718#1730, 1718#1729, 1718#1731, 1718#1732, #, #, #, #, #, #, #, 1014#999, 997#1776, 997#1777, 997#1745, 997#1753, 997#1754, 997#1778, 997#1779, 997#1766, 997#1780, 997#1781, 997#1782, #, 1745#1768, 1745#1750, 1745#1751, 1745#1752, #, #, #, #, #, 1754#1758, 1754#1762, 1754#1763, #, 1758#1776, 1758#1777, 1758#1782, #, #, 1763#1765, #, #, 1766#1768, #, 1768#1776, 1768#1777, 1768#1778, 1768#1780, 1768#1779, 1768#1781, 1768#1782, #, #, #, #, #, #, #, 1014#997, 995#1826, 995#1827, 995#1795, 995#1803, 995#1804, 995#1828, 995#1829, 995#1816, 995#1830, 995#1831, 995#1832, #, 1795#1818, 1795#1800, 1795#1801, 1795#1802, #, #, #, #, #, 1804#1808, 1804#1812, 1804#1813, #, 1808#1826, 1808#1827, 1808#1832, #, #, 1813#1815, #, #, 1816#1818, #, 1818#1826, 1818#1827, 1818#1828, 1818#1830, 1818#1829, 1818#1831, 1818#1832, #, #, #, #, #, #, #, 1014#995, 993#1876, 993#1877, 993#1845, 993#1853, 993#1854, 993#1878, 993#1879, 993#1866, 993#1880, 993#1881, 993#1882, #, 1845#1868, 1845#1850, 1845#1851, 1845#1852, #, #, #, #, #, 1854#1858, 1854#1862, 1854#1863, #, 1858#1876, 1858#1877, 1858#1882, #, #, 1863#1865, #, #, 1866#1868, #, 1868#1876, 1868#1877, 1868#1878, 1868#1880, 1868#1879, 1868#1881, 1868#1882, #, #, #, #, #, #, #, 1014#993, 991#1926, 991#1927, 991#1895, 991#1903, 991#1904, 991#1928, 991#1929, 991#1916, 991#1930, 991#1931, 991#1932, #, 1895#1918, 1895#1900, 1895#1901, 1895#1902, #, #, #, #, #, 1904#1908, 1904#1912, 1904#1913, #, 1908#1926, 1908#1927, 1908#1932, #, #, 1913#1915, #, #, 1916#1918, #, 1918#1926, 1918#1927, 1918#1928, 1918#1930, 1918#1929, 1918#1931, 1918#1932, #, #, #, #, #, #, #, 1014#991, 989#1976, 989#1977, 989#1945, 989#1953, 989#1954, 989#1978, 989#1979, 989#1966, 989#1980, 989#1981, 989#1982, #, 1945#1968, 1945#1950, 1945#1951, 1945#1952, #, #, #, #, #, 1954#1958, 1954#1962, 1954#1963, #, 1958#1976, 1958#1977, 1958#1982, #, #, 1963#1965, #, #, 1966#1968, #, 1968#1976, 1968#1977, 1968#1978, 1968#1980, 1968#1979, 1968#1981, 1968#1982, #, #, #, #, #, #, #, 1014#989, 987#2026, 987#2027, 987#1995, 987#2003, 987#2004, 987#2028, 987#2029, 987#2016, 987#2030, 987#2031, 987#2032, #, 1995#2018, 1995#2000, 1995#2001, 1995#2002, #, #, #, #, #, 2004#2008, 2004#2012, 2004#2013, #, 2008#2026, 2008#2027, 2008#2032, #, #, 2013#2015, #, #, 2016#2018, #, 2018#2026, 2018#2027, 2018#2028, 2018#2030, 2018#2029, 2018#2031, 2018#2032, #, #, #, #, #, #, #, 1014#987, 985#2076, 985#2077, 985#2045, 985#2053, 985#2054, 985#2078, 985#2079, 985#2066, 985#2080, 985#2081, 985#2082, #, 2045#2068, 2045#2050, 2045#2051, 2045#2052, #, #, #, #, #, 2054#2058, 2054#2062, 2054#2063, #, 2058#2076, 2058#2077, 2058#2082, #, #, 2063#2065, #, #, 2066#2068, #, 2068#2076, 2068#2077, 2068#2078, 2068#2080, 2068#2079, 2068#2081, 2068#2082, #, #, #, #, #, #, #, 1014#985, 983#2126, 983#2127, 983#2095, 983#2103, 983#2104, 983#2128, 983#2129, 983#2116, 983#2130, 983#2131, 983#2132, #, 2095#2118, 2095#2100, 2095#2101, 2095#2102, #, #, #, #, #, 2104#2108, 2104#2112, 2104#2113, #, 2108#2126, 2108#2127, 2108#2132, #, #, 2113#2115, #, #, 2116#2118, #, 2118#2126, 2118#2127, 2118#2128, 2118#2130, 2118#2129, 2118#2131, 2118#2132, #, #, #, #, #, #, #, 1014#983, 981#2176, 981#2177, 981#2145, 981#2153, 981#2154, 981#2178, 981#2179, 981#2166, 981#2180, 981#2181, 981#2182, #, 2145#2168, 2145#2150, 2145#2151, 2145#2152, #, #, #, #, #, 2154#2158, 2154#2162, 2154#2163, #, 2158#2176, 2158#2177, 2158#2182, #, #, 2163#2165, #, #, 2166#2168, #, 2168#2176, 2168#2177, 2168#2178, 2168#2180, 2168#2179, 2168#2181, 2168#2182, #, #, #, #, #, #, #, 1014#981, 979#2226, 979#2227, 979#2195, 979#2203, 979#2204, 979#2228, 979#2229, 979#2216, 979#2230, 979#2231, 979#2232, #, 2195#2218, 2195#2200, 2195#2201, 2195#2202, #, #, #, #, #, 2204#2208, 2204#2212, 2204#2213, #, 2208#2226, 2208#2227, 2208#2232, #, #, 2213#2215, #, #, 2216#2218, #, 2218#2226, 2218#2227, 2218#2228, 2218#2230, 2218#2229, 2218#2231, 2218#2232, #, #, #, #, #, #, #, 1014#979, 977#2276, 977#2277, 977#2245, 977#2253, 977#2254, 977#2278, 977#2279, 977#2266, 977#2280, 977#2281, 977#2282, #, 2245#2268, 2245#2250, 2245#2251, 2245#2252, #, #, #, #, #, 2254#2258, 2254#2262, 2254#2263, #, 2258#2276, 2258#2277, 2258#2282, #, #, 2263#2265, #, #, 2266#2268, #, 2268#2276, 2268#2277, 2268#2278, 2268#2280, 2268#2279, 2268#2281, 2268#2282, #, #, #, #, #, #, #, 1014#977, 213#2285, #, 8#2285, 210#2288, #, 8#2288, 208#2291, #, 8#2291, 205#2294, #, 8#2294, 203#2297, #, 8#2297, 200#2300, #, 8#2300, 198#2303, #, 8#2303, 195#2306, #, 8#2306, 193#2309, #, 8#2309, 190#2312, #, 8#2312, 188#2315, #, 8#2315, 186#2318, #, 8#2318, 183#2321, #, 8#2321, 181#2324, #, 8#2324, 179#2327, #, 8#2327, 177#2330, #, 8#2330, 175#2333, #, 8#2333, 172#2336, #, 8#2336, 170#2339, #, 8#2339, 168#2342, #, 8#2342, 166#2345, #, 8#2345, 164#2348, #, 8#2348, 162#2351, #, 8#2351, 160#2354, #, 8#2354, 158#2357, #, 8#2357, 156#2360, #, 8#2360, 153#2363, #, 8#2363, 150#2366, #, 8#2366, 78#2369, #, 8#2369, 76#2372, #, 8#2372, 74#2375, #, 8#2375, 72#2378, #, 8#2378, 60#2381, #, 8#2381, 58#2384, #, 8#2384, 49#2387, #, 8#2387, 48#2390, #, 8#2390, 2390#2433, 2390#2434, 2390#2435, 2390#2405, 2390#2413, 2390#2436, 2390#2414, 2390#2437, 2390#2438, 2390#2439, 2390#2440, 2390#2441, 2390#2421, #, 2405#2423, 2405#2410, 2405#2411, 2405#2412, #, #, #, #, #, 2414#2417, 2414#2418, #, #, 2418#2434, 2418#2435, #, 2421#2423, #, 2423#2433, 2423#2434, 2423#2435, 2423#2436, 2423#2437, 2423#2438, 2423#2439, 2423#2440, 2423#2441, #, #, #, #, #, #, #, #, #, 2387#2483, 2387#2484, 2387#2485, 2387#2455, 2387#2463, 2387#2486, 2387#2464, 2387#2487, 2387#2488, 2387#2489, 2387#2490, 2387#2491, 2387#2471, #, 2455#2473, 2455#2460, 2455#2461, 2455#2462, #, #, #, #, #, 2464#2467, 2464#2468, #, #, 2468#2484, 2468#2485, #, 2471#2473, #, 2473#2483, 2473#2484, 2473#2485, 2473#2486, 2473#2487, 2473#2488, 2473#2489, 2473#2490, 2473#2491, #, #, #, #, #, #, #, #, #, 2384#2533, 2384#2534, 2384#2535, 2384#2505, 2384#2513, 2384#2536, 2384#2514, 2384#2537, 2384#2538, 2384#2539, 2384#2540, 2384#2541, 2384#2521, #, 2505#2523, 2505#2510, 2505#2511, 2505#2512, #, #, #, #, #, 2514#2517, 2514#2518, #, #, 2518#2534, 2518#2535, #, 2521#2523, #, 2523#2533, 2523#2534, 2523#2535, 2523#2536, 2523#2537, 2523#2538, 2523#2539, 2523#2540, 2523#2541, #, #, #, #, #, #, #, #, #, 2381#2583, 2381#2584, 2381#2585, 2381#2555, 2381#2563, 2381#2586, 2381#2564, 2381#2587, 2381#2588, 2381#2589, 2381#2590, 2381#2591, 2381#2571, #, 2555#2573, 2555#2560, 2555#2561, 2555#2562, #, #, #, #, #, 2564#2567, 2564#2568, #, #, 2568#2584, 2568#2585, #, 2571#2573, #, 2573#2583, 2573#2584, 2573#2585, 2573#2586, 2573#2587, 2573#2588, 2573#2589, 2573#2590, 2573#2591, #, #, #, #, #, #, #, #, #, 2378#2633, 2378#2634, 2378#2635, 2378#2605, 2378#2613, 2378#2636, 2378#2614, 2378#2637, 2378#2638, 2378#2639, 2378#2640, 2378#2641, 2378#2621, #, 2605#2623, 2605#2610, 2605#2611, 2605#2612, #, #, #, #, #, 2614#2617, 2614#2618, #, #, 2618#2634, 2618#2635, #, 2621#2623, #, 2623#2633, 2623#2634, 2623#2635, 2623#2636, 2623#2637, 2623#2638, 2623#2639, 2623#2640, 2623#2641, #, #, #, #, #, #, #, #, #, 2375#2683, 2375#2684, 2375#2685, 2375#2655, 2375#2663, 2375#2686, 2375#2664, 2375#2687, 2375#2688, 2375#2689, 2375#2690, 2375#2691, 2375#2671, #, 2655#2673, 2655#2660, 2655#2661, 2655#2662, #, #, #, #, #, 2664#2667, 2664#2668, #, #, 2668#2684, 2668#2685, #, 2671#2673, #, 2673#2683, 2673#2684, 2673#2685, 2673#2686, 2673#2687, 2673#2688, 2673#2689, 2673#2690, 2673#2691, #, #, #, #, #, #, #, #, #, 2372#2733, 2372#2734, 2372#2735, 2372#2705, 2372#2713, 2372#2736, 2372#2714, 2372#2737, 2372#2738, 2372#2739, 2372#2740, 2372#2741, 2372#2721, #, 2705#2723, 2705#2710, 2705#2711, 2705#2712, #, #, #, #, #, 2714#2717, 2714#2718, #, #, 2718#2734, 2718#2735, #, 2721#2723, #, 2723#2733, 2723#2734, 2723#2735, 2723#2736, 2723#2737, 2723#2738, 2723#2739, 2723#2740, 2723#2741, #, #, #, #, #, #, #, #, #, 2369#2783, 2369#2784, 2369#2785, 2369#2755, 2369#2763, 2369#2786, 2369#2764, 2369#2787, 2369#2788, 2369#2789, 2369#2790, 2369#2791, 2369#2771, #, 2755#2773, 2755#2760, 2755#2761, 2755#2762, #, #, #, #, #, 2764#2767, 2764#2768, #, #, 2768#2784, 2768#2785, #, 2771#2773, #, 2773#2783, 2773#2784, 2773#2785, 2773#2786, 2773#2787, 2773#2788, 2773#2789, 2773#2790, 2773#2791, #, #, #, #, #, #, #, #, #, 2366#2833, 2366#2834, 2366#2835, 2366#2805, 2366#2813, 2366#2836, 2366#2814, 2366#2837, 2366#2838, 2366#2839, 2366#2840, 2366#2841, 2366#2821, #, 2805#2823, 2805#2810, 2805#2811, 2805#2812, #, #, #, #, #, 2814#2817, 2814#2818, #, #, 2818#2834, 2818#2835, #, 2821#2823, #, 2823#2833, 2823#2834, 2823#2835, 2823#2836, 2823#2837, 2823#2838, 2823#2839, 2823#2840, 2823#2841, #, #, #, #, #, #, #, #, #, 2363#2883, 2363#2884, 2363#2885, 2363#2855, 2363#2863, 2363#2886, 2363#2864, 2363#2887, 2363#2888, 2363#2889, 2363#2890, 2363#2891, 2363#2871, #, 2855#2873, 2855#2860, 2855#2861, 2855#2862, #, #, #, #, #, 2864#2867, 2864#2868, #, #, 2868#2884, 2868#2885, #, 2871#2873, #, 2873#2883, 2873#2884, 2873#2885, 2873#2886, 2873#2887, 2873#2888, 2873#2889, 2873#2890, 2873#2891, #, #, #, #, #, #, #, #, #, 2360#2933, 2360#2934, 2360#2935, 2360#2905, 2360#2913, 2360#2936, 2360#2914, 2360#2937, 2360#2938, 2360#2939, 2360#2940, 2360#2941, 2360#2921, #, 2905#2923, 2905#2910, 2905#2911, 2905#2912, #, #, #, #, #, 2914#2917, 2914#2918, #, #, 2918#2934, 2918#2935, #, 2921#2923, #, 2923#2933, 2923#2934, 2923#2935, 2923#2936, 2923#2937, 2923#2938, 2923#2939, 2923#2940, 2923#2941, #, #, #, #, #, #, #, #, #, 2357#2983, 2357#2984, 2357#2985, 2357#2955, 2357#2963, 2357#2986, 2357#2964, 2357#2987, 2357#2988, 2357#2989, 2357#2990, 2357#2991, 2357#2971, #, 2955#2973, 2955#2960, 2955#2961, 2955#2962, #, #, #, #, #, 2964#2967, 2964#2968, #, #, 2968#2984, 2968#2985, #, 2971#2973, #, 2973#2983, 2973#2984, 2973#2985, 2973#2986, 2973#2987, 2973#2988, 2973#2989, 2973#2990, 2973#2991, #, #, #, #, #, #, #, #, #, 2354#3033, 2354#3034, 2354#3035, 2354#3005, 2354#3013, 2354#3036, 2354#3014, 2354#3037, 2354#3038, 2354#3039, 2354#3040, 2354#3041, 2354#3021, #, 3005#3023, 3005#3010, 3005#3011, 3005#3012, #, #, #, #, #, 3014#3017, 3014#3018, #, #, 3018#3034, 3018#3035, #, 3021#3023, #, 3023#3033, 3023#3034, 3023#3035, 3023#3036, 3023#3037, 3023#3038, 3023#3039, 3023#3040, 3023#3041, #, #, #, #, #, #, #, #, #, 2351#3083, 2351#3084, 2351#3085, 2351#3055, 2351#3063, 2351#3086, 2351#3064, 2351#3087, 2351#3088, 2351#3089, 2351#3090, 2351#3091, 2351#3071, #, 3055#3073, 3055#3060, 3055#3061, 3055#3062, #, #, #, #, #, 3064#3067, 3064#3068, #, #, 3068#3084, 3068#3085, #, 3071#3073, #, 3073#3083, 3073#3084, 3073#3085, 3073#3086, 3073#3087, 3073#3088, 3073#3089, 3073#3090, 3073#3091, #, #, #, #, #, #, #, #, #, 2348#3133, 2348#3134, 2348#3135, 2348#3105, 2348#3113, 2348#3136, 2348#3114, 2348#3137, 2348#3138, 2348#3139, 2348#3140, 2348#3141, 2348#3121, #, 3105#3123, 3105#3110, 3105#3111, 3105#3112, #, #, #, #, #, 3114#3117, 3114#3118, #, #, 3118#3134, 3118#3135, #, 3121#3123, #, 3123#3133, 3123#3134, 3123#3135, 3123#3136, 3123#3137, 3123#3138, 3123#3139, 3123#3140, 3123#3141, #, #, #, #, #, #, #, #, #, 2345#3183, 2345#3184, 2345#3185, 2345#3155, 2345#3163, 2345#3186, 2345#3164, 2345#3187, 2345#3188, 2345#3189, 2345#3190, 2345#3191, 2345#3171, #, 3155#3173, 3155#3160, 3155#3161, 3155#3162, #, #, #, #, #, 3164#3167, 3164#3168, #, #, 3168#3184, 3168#3185, #, 3171#3173, #, 3173#3183, 3173#3184, 3173#3185, 3173#3186, 3173#3187, 3173#3188, 3173#3189, 3173#3190, 3173#3191, #, #, #, #, #, #, #, #, #, 2342#3233, 2342#3234, 2342#3235, 2342#3205, 2342#3213, 2342#3236, 2342#3214, 2342#3237, 2342#3238, 2342#3239, 2342#3240, 2342#3241, 2342#3221, #, 3205#3223, 3205#3210, 3205#3211, 3205#3212, #, #, #, #, #, 3214#3217, 3214#3218, #, #, 3218#3234, 3218#3235, #, 3221#3223, #, 3223#3233, 3223#3234, 3223#3235, 3223#3236, 3223#3237, 3223#3238, 3223#3239, 3223#3240, 3223#3241, #, #, #, #, #, #, #, #, #, 2339#3283, 2339#3284, 2339#3285, 2339#3255, 2339#3263, 2339#3286, 2339#3264, 2339#3287, 2339#3288, 2339#3289, 2339#3290, 2339#3291, 2339#3271, #, 3255#3273, 3255#3260, 3255#3261, 3255#3262, #, #, #, #, #, 3264#3267, 3264#3268, #, #, 3268#3284, 3268#3285, #, 3271#3273, #, 3273#3283, 3273#3284, 3273#3285, 3273#3286, 3273#3287, 3273#3288, 3273#3289, 3273#3290, 3273#3291, #, #, #, #, #, #, #, #, #, 2336#3333, 2336#3334, 2336#3335, 2336#3305, 2336#3313, 2336#3336, 2336#3314, 2336#3337, 2336#3338, 2336#3339, 2336#3340, 2336#3341, 2336#3321, #, 3305#3323, 3305#3310, 3305#3311, 3305#3312, #, #, #, #, #, 3314#3317, 3314#3318, #, #, 3318#3334, 3318#3335, #, 3321#3323, #, 3323#3333, 3323#3334, 3323#3335, 3323#3336, 3323#3337, 3323#3338, 3323#3339, 3323#3340, 3323#3341, #, #, #, #, #, #, #, #, #, 2333#3383, 2333#3384, 2333#3385, 2333#3355, 2333#3363, 2333#3386, 2333#3364, 2333#3387, 2333#3388, 2333#3389, 2333#3390, 2333#3391, 2333#3371, #, 3355#3373, 3355#3360, 3355#3361, 3355#3362, #, #, #, #, #, 3364#3367, 3364#3368, #, #, 3368#3384, 3368#3385, #, 3371#3373, #, 3373#3383, 3373#3384, 3373#3385, 3373#3386, 3373#3387, 3373#3388, 3373#3389, 3373#3390, 3373#3391, #, #, #, #, #, #, #, #, #, 2330#3433, 2330#3434, 2330#3435, 2330#3405, 2330#3413, 2330#3436, 2330#3414, 2330#3437, 2330#3438, 2330#3439, 2330#3440, 2330#3441, 2330#3421, #, 3405#3423, 3405#3410, 3405#3411, 3405#3412, #, #, #, #, #, 3414#3417, 3414#3418, #, #, 3418#3434, 3418#3435, #, 3421#3423, #, 3423#3433, 3423#3434, 3423#3435, 3423#3436, 3423#3437, 3423#3438, 3423#3439, 3423#3440, 3423#3441, #, #, #, #, #, #, #, #, #, 2327#3483, 2327#3484, 2327#3485, 2327#3455, 2327#3463, 2327#3486, 2327#3464, 2327#3487, 2327#3488, 2327#3489, 2327#3490, 2327#3491, 2327#3471, #, 3455#3473, 3455#3460, 3455#3461, 3455#3462, #, #, #, #, #, 3464#3467, 3464#3468, #, #, 3468#3484, 3468#3485, #, 3471#3473, #, 3473#3483, 3473#3484, 3473#3485, 3473#3486, 3473#3487, 3473#3488, 3473#3489, 3473#3490, 3473#3491, #, #, #, #, #, #, #, #, #, 2324#3533, 2324#3534, 2324#3535, 2324#3505, 2324#3513, 2324#3536, 2324#3514, 2324#3537, 2324#3538, 2324#3539, 2324#3540, 2324#3541, 2324#3521, #, 3505#3523, 3505#3510, 3505#3511, 3505#3512, #, #, #, #, #, 3514#3517, 3514#3518, #, #, 3518#3534, 3518#3535, #, 3521#3523, #, 3523#3533, 3523#3534, 3523#3535, 3523#3536, 3523#3537, 3523#3538, 3523#3539, 3523#3540, 3523#3541, #, #, #, #, #, #, #, #, #, 2321#3583, 2321#3584, 2321#3585, 2321#3555, 2321#3563, 2321#3586, 2321#3564, 2321#3587, 2321#3588, 2321#3589, 2321#3590, 2321#3591, 2321#3571, #, 3555#3573, 3555#3560, 3555#3561, 3555#3562, #, #, #, #, #, 3564#3567, 3564#3568, #, #, 3568#3584, 3568#3585, #, 3571#3573, #, 3573#3583, 3573#3584, 3573#3585, 3573#3586, 3573#3587, 3573#3588, 3573#3589, 3573#3590, 3573#3591, #, #, #, #, #, #, #, #, #, 2318#3633, 2318#3634, 2318#3635, 2318#3605, 2318#3613, 2318#3636, 2318#3614, 2318#3637, 2318#3638, 2318#3639, 2318#3640, 2318#3641, 2318#3621, #, 3605#3623, 3605#3610, 3605#3611, 3605#3612, #, #, #, #, #, 3614#3617, 3614#3618, #, #, 3618#3634, 3618#3635, #, 3621#3623, #, 3623#3633, 3623#3634, 3623#3635, 3623#3636, 3623#3637, 3623#3638, 3623#3639, 3623#3640, 3623#3641, #, #, #, #, #, #, #, #, #, 2315#3683, 2315#3684, 2315#3685, 2315#3655, 2315#3663, 2315#3686, 2315#3664, 2315#3687, 2315#3688, 2315#3689, 2315#3690, 2315#3691, 2315#3671, #, 3655#3673, 3655#3660, 3655#3661, 3655#3662, #, #, #, #, #, 3664#3667, 3664#3668, #, #, 3668#3684, 3668#3685, #, 3671#3673, #, 3673#3683, 3673#3684, 3673#3685, 3673#3686, 3673#3687, 3673#3688, 3673#3689, 3673#3690, 3673#3691, #, #, #, #, #, #, #, #, #, 2312#3733, 2312#3734, 2312#3735, 2312#3705, 2312#3713, 2312#3736, 2312#3714, 2312#3737, 2312#3738, 2312#3739, 2312#3740, 2312#3741, 2312#3721, #, 3705#3723, 3705#3710, 3705#3711, 3705#3712, #, #, #, #, #, 3714#3717, 3714#3718, #, #, 3718#3734, 3718#3735, #, 3721#3723, #, 3723#3733, 3723#3734, 3723#3735, 3723#3736, 3723#3737, 3723#3738, 3723#3739, 3723#3740, 3723#3741, #, #, #, #, #, #, #, #, #, 2309#3783, 2309#3784, 2309#3785, 2309#3755, 2309#3763, 2309#3786, 2309#3764, 2309#3787, 2309#3788, 2309#3789, 2309#3790, 2309#3791, 2309#3771, #, 3755#3773, 3755#3760, 3755#3761, 3755#3762, #, #, #, #, #, 3764#3767, 3764#3768, #, #, 3768#3784, 3768#3785, #, 3771#3773, #, 3773#3783, 3773#3784, 3773#3785, 3773#3786, 3773#3787, 3773#3788, 3773#3789, 3773#3790, 3773#3791, #, #, #, #, #, #, #, #, #, 2306#3833, 2306#3834, 2306#3835, 2306#3805, 2306#3813, 2306#3836, 2306#3814, 2306#3837, 2306#3838, 2306#3839, 2306#3840, 2306#3841, 2306#3821, #, 3805#3823, 3805#3810, 3805#3811, 3805#3812, #, #, #, #, #, 3814#3817, 3814#3818, #, #, 3818#3834, 3818#3835, #, 3821#3823, #, 3823#3833, 3823#3834, 3823#3835, 3823#3836, 3823#3837, 3823#3838, 3823#3839, 3823#3840, 3823#3841, #, #, #, #, #, #, #, #, #, 2303#3883, 2303#3884, 2303#3885, 2303#3855, 2303#3863, 2303#3886, 2303#3864, 2303#3887, 2303#3888, 2303#3889, 2303#3890, 2303#3891, 2303#3871, #, 3855#3873, 3855#3860, 3855#3861, 3855#3862, #, #, #, #, #, 3864#3867, 3864#3868, #, #, 3868#3884, 3868#3885, #, 3871#3873, #, 3873#3883, 3873#3884, 3873#3885, 3873#3886, 3873#3887, 3873#3888, 3873#3889, 3873#3890, 3873#3891, #, #, #, #, #, #, #, #, #, 2300#3933, 2300#3934, 2300#3935, 2300#3905, 2300#3913, 2300#3936, 2300#3914, 2300#3937, 2300#3938, 2300#3939, 2300#3940, 2300#3941, 2300#3921, #, 3905#3923, 3905#3910, 3905#3911, 3905#3912, #, #, #, #, #, 3914#3917, 3914#3918, #, #, 3918#3934, 3918#3935, #, 3921#3923, #, 3923#3933, 3923#3934, 3923#3935, 3923#3936, 3923#3937, 3923#3938, 3923#3939, 3923#3940, 3923#3941, #, #, #, #, #, #, #, #, #, 2297#3983, 2297#3984, 2297#3985, 2297#3955, 2297#3963, 2297#3986, 2297#3964, 2297#3987, 2297#3988, 2297#3989, 2297#3990, 2297#3991, 2297#3971, #, 3955#3973, 3955#3960, 3955#3961, 3955#3962, #, #, #, #, #, 3964#3967, 3964#3968, #, #, 3968#3984, 3968#3985, #, 3971#3973, #, 3973#3983, 3973#3984, 3973#3985, 3973#3986, 3973#3987, 3973#3988, 3973#3989, 3973#3990, 3973#3991, #, #, #, #, #, #, #, #, #, 2294#4033, 2294#4034, 2294#4035, 2294#4005, 2294#4013, 2294#4036, 2294#4014, 2294#4037, 2294#4038, 2294#4039, 2294#4040, 2294#4041, 2294#4021, #, 4005#4023, 4005#4010, 4005#4011, 4005#4012, #, #, #, #, #, 4014#4017, 4014#4018, #, #, 4018#4034, 4018#4035, #, 4021#4023, #, 4023#4033, 4023#4034, 4023#4035, 4023#4036, 4023#4037, 4023#4038, 4023#4039, 4023#4040, 4023#4041, #, #, #, #, #, #, #, #, #, 2291#4083, 2291#4084, 2291#4085, 2291#4055, 2291#4063, 2291#4086, 2291#4064, 2291#4087, 2291#4088, 2291#4089, 2291#4090, 2291#4091, 2291#4071, #, 4055#4073, 4055#4060, 4055#4061, 4055#4062, #, #, #, #, #, 4064#4067, 4064#4068, #, #, 4068#4084, 4068#4085, #, 4071#4073, #, 4073#4083, 4073#4084, 4073#4085, 4073#4086, 4073#4087, 4073#4088, 4073#4089, 4073#4090, 4073#4091, #, #, #, #, #, #, #, #, #, 2288#4133, 2288#4134, 2288#4135, 2288#4105, 2288#4113, 2288#4136, 2288#4114, 2288#4137, 2288#4138, 2288#4139, 2288#4140, 2288#4141, 2288#4121, #, 4105#4123, 4105#4110, 4105#4111, 4105#4112, #, #, #, #, #, 4114#4117, 4114#4118, #, #, 4118#4134, 4118#4135, #, 4121#4123, #, 4123#4133, 4123#4134, 4123#4135, 4123#4136, 4123#4137, 4123#4138, 4123#4139, 4123#4140, 4123#4141, #, #, #, #, #, #, #, #, #, 2285#4183, 2285#4184, 2285#4185, 2285#4155, 2285#4163, 2285#4186, 2285#4164, 2285#4187, 2285#4188, 2285#4189, 2285#4190, 2285#4191, 2285#4171, #, 4155#4173, 4155#4160, 4155#4161, 4155#4162, #, #, #, #, #, 4164#4167, 4164#4168, #, #, 4168#4184, 4168#4185, #, 4171#4173, #, 4173#4183, 4173#4184, 4173#4185, 4173#4186, 4173#4187, 4173#4188, 4173#4189, 4173#4190, 4173#4191, #, #, #, #, #, #, #, #, #, 2#4193, #, 4193#4199, 4193#4200, 4193#4201, 4193#4202, 4193#4203, 4201#4200, #, #, #, #, 4193#4208, 4193#4209, 4193#4210, 4193#4211, #, 4203#4208, #, 4203#4210, 4193#4215, 4193#4216, 4193#4217, #, 4202#4215, 4202#4210, 2#4219, #, #, 31#4220, 4219#4294, 4219#4295, 4219#4296, 4219#4297, 4219#4298, 4219#4299, 4219#4300, 4219#4301, 4219#4302, 4219#4303, 4219#4304, 4219#4305, 4219#4306, 4219#4307, 4219#4308, 4219#4309, 4219#4310, 4219#4311, 4219#4312, 4219#4313, 4219#4314, 4219#4315, 4219#4316, 4219#4317, 4219#4318, 4219#4319, 4219#4320, 4219#4321, 4219#4322, 4219#4323, 4219#4324, 4219#4325, 4219#4326, 4219#4327, 4219#4328, 4219#4329, 4219#4330, 4219#4331, 4219#4332, 4219#4333, 4219#4334, 4219#4335, 4219#4336, 4219#4337, 4219#4338, 4219#4339, 4219#4340, 4219#4341, 4219#4342, 4219#4343, 4219#4344, 4219#4345, 4219#4346, 4219#4347, 4219#4348, 4219#4349, 4219#4350, 4219#4351, 4219#4352, 4219#4353, 4219#4354, 4219#4355, 4219#4356, 4219#4357, 4219#4358, 4219#4359, 4219#4360, 4219#4361, 4219#4362, 4219#4363, 4219#4364, 4219#4365, #, 4301#4294, 4301#, #, 4301#4297, #, 4301#4299, #, #, 4309#4302, 4309#, #, 4309#4305, #, 4309#4307, #, #, 4317#4310, 4317#, #, 4317#4313, #, 4317#4315, #, #, 4325#4318, 4325#, #, 4325#4321, #, 4325#4323, #, #, 4333#4326, 4333#, #, 4333#4329, #, 4333#4331, #, #, 4341#4334, 4341#, #, 4341#4337, #, 4341#4339, #, #, 4349#4342, 4349#, #, 4349#4345, #, 4349#4347, #, #, 4357#4350, 4357#, #, 4357#4353, #, 4357#4355, #, #, 4365#4358, 4365#, #, 4365#4361, #, 4365#4363, #, 4219#4367, #, 4219#4369, #, 4219#4374, 4219#4375, 4219#4376, 4219#4377, #, 4369#4374, #, 4369#4376, 4367#4357, 4367#4365, 4367#4301, 4367#4341, 4367#4309, 4367#4317, 4367#4325, 4367#4349, 4367#4333, 4219#4391, 4219#4392, 4219#4393, 4219#4394, #, 4369#4391, #, 4369#4393, 4219#4397, 4219#4398, #4369, 4367#4397, 4219#4400, #, 4219#4402, #, 4219#4405, 4219#4406, #, 4402#4405, #, 4402#4407, #, 4402#4409, 4219#4413, 4219#4414, #, 4402#4413, 4219#4417, 4219#4418, #, 4402#4417, 4219#4421, 4219#4422, #, 4402#4421, 4219#4425, 4219#4426, #, 4402#4425, 4219#4429, 4219#4430, #, 4402#4429, 4367#4402, 4219#4433, #, #, 4433#4434, #, 4433#4436, #, 4433#4438, #, 4433#4440, #, 4433#4442, #, 4433#4444, 4402#4433, 4367#4433, 4219#4450, 4219#4451, #, 4433#4450, 4219#4454, 4219#4455, #, 4433#4454, #, 31#4456, 2#4459, #, 4219#4461, #, 4367#4461, 4219#4465, 4219#4466, #, 4461#4465, #, 4461#4467, #, 4461#4469, 2#4472, #, 4472#4474, #, 4472#4491, 4472#4492, 4472#4493, 4472#4494, 4472#4495, 4472#4496, 4472#4497, 4472#4498, 4472#4499, 4472#4500, 4472#4501, 4472#4502, 4472#4503, 4472#4504, 4472#4505, 4472#4506, 4498#, #, 4498#4492, #, 4498#4494, #, 4498#4496, #, 4506#, #, 4506#4500, #, 4506#4502, #, 4506#4504, #, 4474#4506, #, 4506#4508, #, 4506#4510, 4474#4498, #, 4498#4513, #, 4498#4515, 4472#4525, 4472#4526, 4472#4527, 4472#4528, 4472#4529, 4472#4530, 4472#4531, 4472#4532, 4532#, #, 4532#4526, #, 4532#4528, #, 4532#4530, #, 4474#4532, 4472#4535, #, 4472#4537, #, 4535#4537, 4472#4550, 4472#4551, 4472#4552, 4472#4553, 4472#4554, 4472#4555, 4472#4556, 4472#4557, 4472#4558, 4472#4559, 4472#4560, #, 4537#4550, #, 4537#4552, #, 4537#4554, 4537#, #, 4537#4557, #, 4537#4559, 4472#4562, #, 4535#4562, 4472#4575, 4472#4576, 4472#4577, 4472#4578, 4472#4579, 4472#4580, 4472#4581, 4472#4582, 4472#4583, 4472#4584, 4472#4585, #, 4562#4575, #, 4562#4577, #, 4562#4579, 4562#, #, 4562#4582, #, 4562#4584, 4472#4588, 4472#4589, #, 4562#4588, 4472#4592, 4472#4593, #, 4562#4592, 4472#4596, 4472#4597, #, 4562#4596, 2#4599, #, #4599, #, 4599#4601, #, 4599#4603, #, 4599#4605, #, 4599#4607, 4599#4610, #, #, 4601#4611, #, 4601#4613, #, 4601#4615, #, 4601#4617, #, 4601#4619, 4601#, #, 4601#4622, #, 4603#4624, #, 4603#4626, #, 4603#4628, #, 4603#4630, #, 4603#4632, 4603#, #, 4603#4635, #, 4603#4637, #4676, 4605#4639, #, 4605#4641, #, 4605#4643, #4678, 4605#4645, #, 4605#4647, #, 4607#4649, #, 4607#4651, #4660, 4607#4653, #, 4607#4655, #, 4607#4657, 4599#4660, #, #, 4660#4661, 4599#4664, #, #, #, #, #, 4664#4668, #, #, #, 4599#4674, #, 4599#4676, #, 4599#4678, #, #, 31#4679, #, 4599#4681, #, 4681#4683, #, 4681#4685, #, 4681#4687, #, 4676#4689, 4676#, 4599#4693, #, #, 4678#4694, 4678#, #, 31#4697, 2#4700, #, #4700, #, 4700#4702, #, 4700#4704, #, 4700#4706, #, 4700#4708, #, 4700#4710, #, 4700#4712, #, 4700#4714, #, 4700#4716, #, 4700#4718, #, 4700#4720, #, 4700#4722, #, 4700#4724, #, 4700#4726, #, 4700#4728, #, 4700#4730, #, 4700#4732, #, 4710#4734, #, 4712#4736, #, 4714#4738, #, 4716#4740, #, 4718#4742, #, 4720#4744, #, 4722#4746, #, 4724#4748, #, 4726#4750, #, 4728#4752, #, 4730#4754, #, 4732#4756, 4702#4710, 4700#4758, 4702#4712, 4700#4760, 4702#4714, 4700#4762, 4702#4716, 4700#4764, 4702#4718, 4700#4766, 4702#4720, 4700#4768, 4702#4722, 4700#4770, 4702#4724, 4700#4772, 4702#4726, 4700#4774, 4702#4728, 4700#4776, 4702#4730, 4700#4778, 4702#4732, 4700#4780, 4702#, #, 4702#4783, #, 4702#4785, #, 4702#4787, #, 4700#4789, #, 4700#4791, #, 4700#4793, #, 4700#4795, #, 4700#4797, #, 4700#4799, #, 4700#4801, #, 4700#4803, #, 4700#4805, #, 4700#4807, #, 4700#4809, #, 4700#4811, #, 4789#4813, #, 4791#4815, #, 4793#4817, #, 4795#4819, #, 4797#4821, #, 4799#4823, #, 4801#4825, #, 4803#4827, #, 4805#4829, #, 4807#4831, #, 4809#4833, #, 4811#4835, 4704#4789, 4700#4837, 4704#4791, 4700#4839, 4704#4793, 4700#4841, 4704#4795, 4700#4843, 4704#4797, 4700#4845, 4704#4799, 4700#4847, 4704#4801, 4700#4849, 4704#4803, 4700#4851, 4704#4805, 4700#4853, 4704#4807, 4700#4855, 4704#4809, 4700#4857, 4704#4811, 4700#4859, 4704#, #, 4704#4862, #, 4704#4864, #, 4704#4866, 2#4869, #, #4869, del#4870, #, 4869#4872, #, 4869#4874, #, 4869#4876, #, 4869#4878, #, 4869#4880, #, 4869#4882, #, 4876#4884, #, 4878#4886, #, 4880#4888, #, 4882#4890, #, 31#4892, #, 4869#4894, #, 4869#4896, #, 4869#4898, #, 4869#4900, #, 4869#4902, #, 4869#4904, #, 4894#4906, #, 4904#4908, #, 4896#4910, #, 4902#4912, #, 4898#4914, #, 4900#4916, #, 4869#4918, #, 4869#4920, #, 4869#4922, #, 4869#4924, #, 4869#4926, #, 4869#4928, #, 4869#4930, #, 4869#4932, #, 4869#4934, #, 4869#4936, #, 4869#4938, #, 4869#4940, #, 4869#4942, #, 4869#4944, #, 4922#4946, #, 4932#4948, #, 4924#4950, #, 4930#4952, #, 4926#4954, #, 4928#4956, #, 4934#4958, #, 4944#4960, #, 4936#4962, #, 4942#4964, #, 4938#4966, #, 4940#4968, #4876, 4869#4970, #4878, 4869#4972, #4880, 4869#4974, #4882, 4869#4976, #4876, 4869#4978, #4894, 4869#4980, #4896, 4869#4982, #4898, 4869#4984, #4900, 4869#4986, #4902, 4869#4988, #4904, 4869#4990, #4882, 4869#4992, 4872#4876, 4869#4994, 4872#4878, 4869#4996, 4872#4880, 4869#4998, 4872#4882, 4869#5000, 4874#4876, 4869#5002, 4874#4894, 4869#5004, 4874#4896, 4869#5006, 4874#4898, 4869#5008, 4874#4900, 4869#5010, 4874#4902, 4869#5012, 4874#4904, 4869#5014, 4874#4882, 4869#5016, 4872#, #, 4872#5019, #, 4872#5021, #, 4872#5023, 4874#, #, 4874#5026, #, 4874#5028, #, 4874#5030, 4918#4922, 4869#5032, 4918#4924, 4869#5034, 4918#4926, 4869#5036, 4918#4928, 4869#5038, 4918#4930, 4869#5040, 4918#4932, 4869#5042, 4920#4934, 4869#5044, 4920#4936, 4869#5046, 4920#4938, 4869#5048, 4920#4940, 4869#5050, 4920#4942, 4869#5052, 4920#4944, 4869#5054, 4918#, #, 4918#5057, #, 4918#5059, #, 4918#5061, 4920#, #, 4920#5064, #, 4920#5066, #, 4920#5068, 4869#5071, #, #, 4869#5072, #, 4869#5074, #, 5072#5076, #, 5074#5078, 5071#4876, 4869#5080, 5071#5072, 4869#5082, 5071#5074, 4869#5084, 5071#4882, 4869#5086, 5071#, #, 5071#5089, #, 5071#5091, #, 5071#5093, #, 4869#5095, #, 4869#5097, #, 4869#5099, #, 4869#5101, #, 4869#5103, #, 5095#5105, #, 5095#5107, #, 5095#5109, #, 5095#5111, #, 5095#5113, 5095#, #, 5095#5116, #, 5101#5118, #, 5101#5120, #, 5101#5122, #, 5101#5124, #, 5101#5126, 5101#, #, 5101#5129, #, 5103#5131, #, 5103#5133, #, 5103#5135, #, 5103#5137, #, 5103#5139, 5103#, #, 5103#5142, #, 5097#5144, #, 5097#5146, #, 5097#5148, #, 5097#5150, #, 5097#5152, 5097#, #, 5097#5155, #, 5099#5157, #, 5099#5159, #, 5099#5161, #, 5099#5163, #, 5099#5165, 5099#, #, 5099#5168, 
### 内容
#0, 14:
文档\S应用\草稿.ftxt
## end
#2, 388:
+[返回目录](,草稿)
地址::文档\S应用\草稿.ftxt

光路图::文档\S应用\绘制光路图.ftxt
+[打开文件](+新窗口,光路图)
PPT::文档\S应用\PPT.ftxt
+[打开文件](+新窗口,PPT)
iFAST光路::文档\实验室信息\iFAST光路.ftxt
+[打开文件](+新窗口,iFAST光路)
星图::文档\S应用\星图.txt
+[打开文件](+新窗口,星图)

Nini, 导入词典的库. 导入词典
Nini, 导入PPT的库. Nini, 导入三维场景的库
Nini, 导入图形库的库
Nini, 打开三维场景(文件)
Nini, 打开能谱仪论文(文件)


第一幅:...
第二幅:...

流程图:...
测试:...

晶体:...
Nini, 打开相对论双折射(文件)

模拟场景:...
水管图:...
外部水管:...

## end
#3, 46:
草稿:...
创建于 20210520

节点数目统计::
+[设置结构](,节点数目统计)
## end
#6, 17:
文档\S应用\绘制光路图.ftxt
## end
#8, 413:
+[返回目录](,第一幅)
+[画板](+新画板,第一幅)
第一级放大:...
+[逻辑结构转光路](第一级放大,第一幅)

第一级放大的所有元件位置缩小10倍. 
第一幅=>的(第一幅,_元件)->的(_元件,中心)=>+[matlab]"pt=pt/4*3;"(Matlab,)->+[o]"pt"(+[matlab],中心)
第一幅=>的(第一幅,光线)->的(光线,_re)->_re"起点|终点"=>+[matlab]"pt=pt/10*3;"(Matlab,)->+[o]"pt"(+[matlab],_re)

将I1和I2的线颜色改为绿色, 并且加粗
的(I1,线颜色)->的(I1,线粗细)->+[修改内容]"0,200,0"(,线颜色)->+[修改内容]"4"(,线粗细)
的(I2,线颜色)->的(I2,线粗细)->+[修改内容]"0,200,0"(,线颜色)->+[修改内容]"4"(,线粗细)




## end
#9, 18:
1.3236609426061823
## end
#11, 8:
958, 476
## end
#13, 11:
600.0, 50.0
## end
#29, 15:
文档\S应用\PPT.ftxt
## end
#32, 3:
429
## end
#34, 4:
4232
## end
#37, 21:
文档\实验室信息\iFAST光路.ftxt
## end
#39, 4469:
+[返回目录](,场景)
+[显示星图](,场景)
+[删除结构](,场景)

有一束种子光和两束泵光
+种子光->+泵光1->+泵光2

被多次经过的元件有, M1, Crystal
+M1->+Crystal

描述::泵光1经过+X, +S, Crystal
+[经过元件](描述,+[显示])
Crystal->+经过(泵光1,Crystal)->+S->+经过(泵光1,+S)->+X->+经过(泵光1,+X)

描述::在S上, 从泵光1分出来了泵光2, 然后经过+M, +X, +M, +M, Crystal
+[经过元件](描述,+[显示])
Crystal->+经过(泵光2,Crystal)->+M->+经过(泵光2,+M)->+M->+经过(泵光2,+M)->+X->+经过(泵光2,+X)->+M->+经过(泵光2,+M)
经过(泵光1,S)->+分出来(泵光1,泵光2)->+从(+分出来,经过)

描述::种子光经过+Stretcher, M1, +M, M1, +M, +I, +X, +Dazzler, +Faraday, +X, +M, +M, +I, Crystal, +I, +X, +X, +M, +M, Crystal, +X, +M, +M, Crystal, +M, +M, Crystal, +M, +M, Crystal, +M, +M, Crystal, +M, +M, Crystal, +2nd
+[经过元件](描述,+[显示])
+2nd->+经过(种子光,+2nd)->Crystal->+经过(种子光,Crystal)->+M->+经过(种子光,+M)->+M->+经过(种子光,+M)->Crystal->+经过(种子光,Crystal)->+M->+经过(种子光,+M)->+M->+经过(种子光,+M)->Crystal->+经过(种子光,Crystal)->+M->+经过(种子光,+M)->+M->+经过(种子光,+M)->Crystal->+经过(种子光,Crystal)->+M->+经过(种子光,+M)->+M->+经过(种子光,+M)->Crystal->+经过(种子光,Crystal)->+M->+经过(种子光,+M)->+M->+经过(种子光,+M)->+X->+经过(种子光,+X)->Crystal->+经过(种子光,Crystal)->+M->+经过(种子光,+M)->+M->+经过(种子光,+M)->+X->+经过(种子光,+X)->+X->+经过(种子光,+X)->+I->+经过(种子光,+I)->Crystal->+经过(种子光,Crystal)->+I->+经过(种子光,+I)->+M->+经过(种子光,+M)->+M->+经过(种子光,+M)->+X->+经过(种子光,+X)->+Faraday->+经过(种子光,+Faraday)->+Dazzler->+经过(种子光,+Dazzler)->+X->+经过(种子光,+X)->+I->+经过(种子光,+I)->+M->+经过(种子光,+M)->M1->+经过(种子光,M1)->+M->+经过(种子光,+M)->M1->+经过(种子光,M1)->+Stretcher->+经过(种子光,+Stretcher)



所有的镜子M都按顺序命名为Mi. Iris, 透镜, 爬高镜和X都用同样的方法命名. 
+[自动命名]"M"(,第一级放大)
+[自动命名]"I"(,第一级放大)
+[自动命名]"X"(,第一级放大)

+[修改标题]"M19"(,M1)

将所有种子光的经过置顶
种子光=>经过(种子光,)=>+[置顶](种子光,经过)
泵光1=>经过(泵光1,)=>+[置顶](泵光1,经过)
泵光2=>经过(泵光2,)=>+[置顶](泵光2,经过)
依次显示种子光经过的元件. 
种子光=>经过(种子光,_元件)=>+[显示](,_元件)

+位置
位置
所有被光线经过的东西都是元件, 都有空间位置
第一级放大=>的(第一级放大,_元件)->[]{经过(,_元件)}=>+的(位置,+空间点)->+在(_元件,+空间点)

显示所有泵光1经过的元件
泵光1=>经过(泵光1,_元件)=>+[显示](,_元件)
泵光2=>经过(泵光2,_元件)=>+[显示](,_元件)


种子光输出的元件是2nd, 输入元件是Stretcher. 
泵光1有输入, 输出是Crystal
泵光2的输出是Crystal
经过(种子光,2nd)...
->+的(种子光,+输出)->+输出(,2nd)->+的(种子光,+输入)->+输入(,Stretcher)
经过(泵光1,Crystal)...
->+的(泵光1,+输出)->+输出(,Crystal)->+的(泵光1,+输入)->+在(+输入,+空间点)->+的(位置,+空间点)
经过(泵光2,Crystal)...
->+的(泵光2,+输出)->+输出(,Crystal)

泵光1=>的(泵光1,输出)->输出(,_元件)->在(_元件,空间点)=>+[显示](,空间点)




设置泵光1的元件
+[设置位置](,泵光1)
在(X6,空间点)->+[修改内容]"0,0,0"(,空间点)
的(泵光1,输入)->+[相对]"0,10,0"(X6,输入)
+[相对]"0,-5,0"(X6,S)
+[相对]"80,0,0"(S,Crystal)

+[设置位置](,泵光2)
+[相对]"0,-18,0"(S,M18)
+[相对]"80,0,0"(Crystal,M16)
+[相对]"80,0,0"(Crystal,M17)
+[对齐Y](M18,M17)->+[对齐X](M16,M17)
+[相对]"-10,0,0"(M17,X5)

+[matlab]"clf"(Matlab,)...
->+[显示光路](+[matlab],泵光1)->+[显示光路](+[matlab],泵光2)

M13,M12
M9,M8
M5,M4
M1,M0

M11,M10
M7,M6
M3,M2

设置种子光的元件
+[设置位置](,种子光)
在(Stretcher,空间点)->+[修改内容]"60,30,0"(,空间点)
+[相对]"0,-80,0"(Stretcher,M19)
+[相对]"40,0,0"(M19,M15)
+[相对]"0,-10,0"(Stretcher,M14)
+[相对]"-2,0,0"(M14,I2)
+[相对]"-2,0,0"(I2,X4)
+[相对]"-2,0,0"(X4,Dazzler)
+[相对]"-2,0,0"(Dazzler,Faraday)
+[相对]"-2,0,0"(Faraday,X3)


+[相对]"-25,0,0"(M14,M13)
+[相对]"0,-41.05,0"(M13,M12)
+[相对]"50"(Crystal,M11)->+[沿着](+[相对],)->[方向](M12,Crystal)->[m_text]([方向],+[沿着])
+[相对]"0,-30,0"(M11,M10)
+[相对]"55"(Crystal,M9)->+[沿着](+[相对],)->[方向](M10,Crystal)->[m_text]([方向],+[沿着])
+[相对]"0,-25,0"(M9,M8)
+[相对]"58"(Crystal,M7)->+[沿着](+[相对],)->[方向](M8,Crystal)->[m_text]([方向],+[沿着])
+[相对]"0,-20,0"(M7,M6)
+[相对]"62"(Crystal,M5)->+[沿着](+[相对],)->[方向](M6,Crystal)->[m_text]([方向],+[沿着])
+[相对]"0,-15,0"(M5,M4)
+[相对]"64"(Crystal,M3)->+[沿着](+[相对],)->[方向](M4,Crystal)->[m_text]([方向],+[沿着])
+[相对]"0,-10,0"(M3,M2)
+[相对]"65"(Crystal,M1)->+[沿着](+[相对],)->[方向](M2,Crystal)->[m_text]([方向],+[沿着])
+[相对]"0,-5,0"(M1,M0)


+[相对]"3"(M12,I1)->+[沿着](+[相对],)->[方向](M12,Crystal)->[m_text]([方向],+[沿着])
+[相对]"5"(M11,I0)->+[沿着](+[相对],)->[方向](M11,Crystal)->[m_text]([方向],+[沿着])
+[相对]"3"(M11,X2)->+[沿着](+[相对],)->[方向](M11,Crystal)->[m_text]([方向],+[沿着])
+[相对]"2"(M11,X1)->+[沿着](+[相对],)->[方向](M11,Crystal)->[m_text]([方向],+[沿着])
+[相对]"5"(M9,X0)->+[沿着](+[相对],)->[方向](M9,Crystal)->[m_text]([方向],+[沿着])

+[matlab]"clf"(Matlab,)->+[显示光路](+[matlab],种子光)
+[相对]"120,0,0"(Crystal,2nd)

显示所有元件所在的空间点位置. 
位置=>的(位置,空间点)->在(_元件,空间点)...
=>+[标题](_元件,)->+[修改内容](+[标题],+[显示])->+[显示](,空间点)



显示种子光和泵光光路
+[matlab]"clf"(Matlab,)...
->+[显示光路](+[matlab],泵光1)->+[显示光路](+[matlab],泵光2)...
->+[显示光路](+[matlab],种子光)

所有经过了镜子的光线都被那面镜子反射. 
[]=>经过(_光线,_re)->_re"^M"=>+反射(经过,)
[]=>经过(_光线,_re)->_re"^S"=>+反射(经过,)


测试结构::
+[场景结构转路线结构](第一级放大,测试结构)
+[删除结构](,测试结构)
+[设置结构](,测试结构)


位置::
所有被光线经过的东西都是元件, 都朝着某个方向
第一级放大=>的(第一级放大,_元件)->[]{经过(,_元件)}=>+朝着(_元件,+方向)

自动调整所有元件的方向. 
第一级放大=>的(第一级放大,_元件)->[]{经过(,_元件)}=>+[自动调整镜子方向](,_元件)


+[显示光路场景结构](,场景)
+[显示星图](,测试结构)
## end
#51, 20:
泵光1经过+X, +S, Crystal
## end
#325, 15:
80.0, -5.0, 0.0
## end
#328, 16:
60.0, -50.0, 0.0
## end
#331, 5:
0,0,0
## end
#334, 14:
0.0, -5.0, 0.0
## end
#337, 15:
0.0, -23.0, 0.0
## end
#340, 17:
150.0, -23.0, 0.0
## end
#343, 17:
160.0, -23.0, 0.0
## end
#346, 16:
160.0, -5.0, 0.0
## end
#349, 7:
60,30,0
## end
#352, 17:
100.0, -50.0, 0.0
## end
#355, 15:
60.0, 20.0, 0.0
## end
#358, 15:
58.0, 20.0, 0.0
## end
#361, 15:
56.0, 20.0, 0.0
## end
#364, 15:
54.0, 20.0, 0.0
## end
#367, 15:
52.0, 20.0, 0.0
## end
#370, 15:
50.0, 20.0, 0.0
## end
#373, 15:
35.0, 20.0, 0.0
## end
#376, 30:
35.0, -21.049999999999997, 0.0
## end
#379, 43:
37.82565167456592, -20.042184236071485, 0.0
## end
#382, 42:
122.3847751184888, 10.117236458927671, 0.0
## end
#385, 42:
124.26854290153275, 10.78911363488001, 0.0
## end
#388, 43:
125.21042679305472, 11.125052222856182, 0.0
## end
#391, 43:
127.09419457609867, 11.796929398808523, 0.0
## end
#394, 44:
127.09419457609867, -18.203070601191477, 0.0
## end
#397, 42:
31.856233275333445, 8.497322903483086, 0.0
## end
#400, 42:
27.041856602866787, 9.847055193831395, 0.0
## end
#403, 44:
27.041856602866787, -15.152944806168605, 0.0
## end
#406, 41:
136.9626108456817, 5.920666904700717, 0.0
## end
#409, 43:
136.9626108456817, -14.079333095299283, 0.0
## end
#412, 41:
18.772875495902404, 4.75905861032361, 0.0
## end
#415, 43:
18.772875495902404, -10.24094138967639, 0.0
## end
#418, 44:
143.76681411841798, 0.45833465327367406, 0.0
## end
#421, 43:
143.76681411841798, -9.541665346726326, 0.0
## end
#424, 44:
15.164238783895684, -0.3822010082395959, 0.0
## end
#427, 43:
15.164238783895684, -5.382201008239596, 0.0
## end
#430, 16:
200.0, -5.0, 0.0
## end
#448, 14:
0.0, 10.0, 0.0
## end
#904, 28:
90.11847530663427, 90.0, 0.0
## end
#906, 16:
135.0, 90.0, 0.0
## end
#908, 14:
0.0, 90.0, 0.0
## end
#910, 29:
-45.00000000000001, 90.0, 0.0
## end
#912, 16:
135.0, 90.0, 0.0
## end
#914, 15:
90.0, 90.0, 0.0
## end
#916, 17:
-135.0, 90.0, 0.0
## end
#918, 29:
-45.00000000000001, 90.0, 0.0
## end
#922, 16:
-90.0, 90.0, 0.0
## end
#924, 29:
-45.00000000000001, 90.0, 0.0
## end
#926, 16:
-90.0, 90.0, 0.0
## end
#928, 16:
-90.0, 90.0, 0.0
## end
#930, 16:
-90.0, 90.0, 0.0
## end
#932, 16:
-90.0, 90.0, 0.0
## end
#934, 16:
-90.0, 90.0, 0.0
## end
#936, 28:
45.00000000000001, 90.0, 0.0
## end
#938, 29:
144.81481154832852, 90.0, 0.0
## end
#940, 29:
109.62962309665703, 90.0, 0.0
## end
#942, 29:
109.62962309665703, 90.0, 0.0
## end
#944, 29:
109.62962309665703, 90.0, 0.0
## end
#946, 29:
109.62962309665703, 90.0, 0.0
## end
#948, 30:
-35.185188451671486, 90.0, 0.0
## end
#950, 29:
-142.8305404102467, 90.0, 0.0
## end
#952, 30:
-105.66108082049337, 90.0, 0.0
## end
#954, 28:
37.16945958975333, 90.0, 0.0
## end
#956, 28:
140.4264266781094, 90.0, 0.0
## end
#958, 30:
-39.573573321890606, 90.0, 0.0
## end
#960, 29:
-139.5281285065799, 90.0, 0.0
## end
#962, 28:
40.47187149342011, 90.0, 0.0
## end
#964, 29:
137.44624936300656, 90.0, 0.0
## end
#966, 29:
-42.55375063699344, 90.0, 0.0
## end
#968, 29:
-137.0369497017003, 90.0, 0.0
## end
#970, 28:
42.96305029829969, 90.0, 0.0
## end
#972, 29:
135.05923765331713, 90.0, 0.0
## end
#977, 163:
+[返回目录](,光线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

焦点::0.7
直径::70

画图:...
选中区域:...
HTML:...
+[创建输入](直径,选中区域)
的(画图,输入)->+[有](HTML,输入)

## end
#979, 163:
+[返回目录](,光线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

焦点::0.7
直径::70

画图:...
选中区域:...
HTML:...
+[创建输入](直径,选中区域)
的(画图,输入)->+[有](HTML,输入)

## end
#981, 163:
+[返回目录](,光线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

焦点::0.7
直径::70

画图:...
选中区域:...
HTML:...
+[创建输入](直径,选中区域)
的(画图,输入)->+[有](HTML,输入)

## end
#983, 163:
+[返回目录](,光线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

焦点::0.7
直径::70

画图:...
选中区域:...
HTML:...
+[创建输入](直径,选中区域)
的(画图,输入)->+[有](HTML,输入)

## end
#985, 163:
+[返回目录](,光线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

焦点::0.7
直径::70

画图:...
选中区域:...
HTML:...
+[创建输入](直径,选中区域)
的(画图,输入)->+[有](HTML,输入)

## end
#987, 163:
+[返回目录](,光线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

焦点::0.7
直径::70

画图:...
选中区域:...
HTML:...
+[创建输入](直径,选中区域)
的(画图,输入)->+[有](HTML,输入)

## end
#989, 163:
+[返回目录](,光线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

焦点::0.7
直径::70

画图:...
选中区域:...
HTML:...
+[创建输入](直径,选中区域)
的(画图,输入)->+[有](HTML,输入)

## end
#991, 163:
+[返回目录](,光线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

焦点::0.7
直径::70

画图:...
选中区域:...
HTML:...
+[创建输入](直径,选中区域)
的(画图,输入)->+[有](HTML,输入)

## end
#993, 163:
+[返回目录](,光线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

焦点::0.7
直径::70

画图:...
选中区域:...
HTML:...
+[创建输入](直径,选中区域)
的(画图,输入)->+[有](HTML,输入)

## end
#995, 163:
+[返回目录](,光线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

焦点::0.7
直径::70

画图:...
选中区域:...
HTML:...
+[创建输入](直径,选中区域)
的(画图,输入)->+[有](HTML,输入)

## end
#997, 163:
+[返回目录](,光线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

焦点::0.7
直径::70

画图:...
选中区域:...
HTML:...
+[创建输入](直径,选中区域)
的(画图,输入)->+[有](HTML,输入)

## end
#999, 163:
+[返回目录](,光线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

焦点::0.7
直径::70

画图:...
选中区域:...
HTML:...
+[创建输入](直径,选中区域)
的(画图,输入)->+[有](HTML,输入)

## end
#1001, 163:
+[返回目录](,光线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

焦点::0.7
直径::70

画图:...
选中区域:...
HTML:...
+[创建输入](直径,选中区域)
的(画图,输入)->+[有](HTML,输入)

## end
#1003, 163:
+[返回目录](,光线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

焦点::0.7
直径::70

画图:...
选中区域:...
HTML:...
+[创建输入](直径,选中区域)
的(画图,输入)->+[有](HTML,输入)

## end
#1005, 163:
+[返回目录](,光线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

焦点::0.7
直径::70

画图:...
选中区域:...
HTML:...
+[创建输入](直径,选中区域)
的(画图,输入)->+[有](HTML,输入)

## end
#1007, 163:
+[返回目录](,光线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

焦点::0.7
直径::70

画图:...
选中区域:...
HTML:...
+[创建输入](直径,选中区域)
的(画图,输入)->+[有](HTML,输入)

## end
#1009, 163:
+[返回目录](,光线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

焦点::0.7
直径::70

画图:...
选中区域:...
HTML:...
+[创建输入](直径,选中区域)
的(画图,输入)->+[有](HTML,输入)

## end
#1011, 163:
+[返回目录](,光线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

焦点::0.7
直径::70

画图:...
选中区域:...
HTML:...
+[创建输入](直径,选中区域)
的(画图,输入)->+[有](HTML,输入)

## end
#1013, 163:
+[返回目录](,光线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

焦点::0.7
直径::70

画图:...
选中区域:...
HTML:...
+[创建输入](直径,选中区域)
的(画图,输入)->+[有](HTML,输入)

## end
#1017, 163:
+[返回目录](,光线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

焦点::0.7
直径::70

画图:...
选中区域:...
HTML:...
+[创建输入](直径,选中区域)
的(画图,输入)->+[有](HTML,输入)

## end
#1019, 163:
+[返回目录](,光线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

焦点::0.7
直径::70

画图:...
选中区域:...
HTML:...
+[创建输入](直径,选中区域)
的(画图,输入)->+[有](HTML,输入)

## end
#1025, 163:
+[返回目录](,光线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

焦点::0.7
直径::70

画图:...
选中区域:...
HTML:...
+[创建输入](直径,选中区域)
的(画图,输入)->+[有](HTML,输入)

## end
#1027, 163:
+[返回目录](,光线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

焦点::0.7
直径::70

画图:...
选中区域:...
HTML:...
+[创建输入](直径,选中区域)
的(画图,输入)->+[有](HTML,输入)

## end
#1029, 163:
+[返回目录](,光线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

焦点::0.7
直径::70

画图:...
选中区域:...
HTML:...
+[创建输入](直径,选中区域)
的(画图,输入)->+[有](HTML,输入)

## end
#1031, 163:
+[返回目录](,光线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

焦点::0.7
直径::70

画图:...
选中区域:...
HTML:...
+[创建输入](直径,选中区域)
的(画图,输入)->+[有](HTML,输入)

## end
#1045, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1051, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1052, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1053, 2:
直线
## end
#1054, 362:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and (d<直径[0]/4 or d<5):
    state=True
else:
    state=False

## end
#1058, 49:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0
直径::70

## end
#1062, 14:
+[返回目录]
+[内容]

## end
#1063, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1065, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1066, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1068, 46:
线颜色::0,0,0
线型::DashLine
线粗细::2
焦点::0.7
直径::70

## end
#1076, 11:
960.0, 30.0
## end
#1077, 11:
480.0, 30.0
## end
#1078, 7:
255,0,0
## end
#1079, 1:
1
## end
#1080, 9:
SolidLine
## end
#1081, 3:
100
## end
#1082, 1:
5
## end
#1095, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1101, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1102, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1103, 2:
直线
## end
#1104, 362:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and (d<直径[0]/4 or d<5):
    state=True
else:
    state=False

## end
#1108, 49:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0
直径::70

## end
#1112, 14:
+[返回目录]
+[内容]

## end
#1113, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1115, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1116, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1118, 46:
线颜色::0,0,0
线型::DashLine
线粗细::2
焦点::0.7
直径::70

## end
#1126, 12:
960.0, 138.0
## end
#1127, 11:
960.0, 30.0
## end
#1128, 7:
255,0,0
## end
#1129, 1:
1
## end
#1130, 9:
SolidLine
## end
#1131, 3:
100
## end
#1132, 1:
5
## end
#1145, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1151, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1152, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1153, 2:
直线
## end
#1154, 362:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and (d<直径[0]/4 or d<5):
    state=True
else:
    state=False

## end
#1158, 49:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0
直径::70

## end
#1162, 14:
+[返回目录]
+[内容]

## end
#1163, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1165, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1166, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1168, 46:
线颜色::0,0,0
线型::DashLine
线粗细::2
焦点::0.7
直径::70

## end
#1176, 10:
0.0, 138.0
## end
#1177, 12:
960.0, 138.0
## end
#1178, 7:
255,0,0
## end
#1179, 1:
1
## end
#1180, 9:
SolidLine
## end
#1181, 3:
100
## end
#1182, 1:
5
## end
#1195, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1201, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1202, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1203, 2:
直线
## end
#1204, 362:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and (d<直径[0]/4 or d<5):
    state=True
else:
    state=False

## end
#1208, 49:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0
直径::70

## end
#1212, 14:
+[返回目录]
+[内容]

## end
#1213, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1215, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1216, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1218, 46:
线颜色::0,0,0
线型::DashLine
线粗细::2
焦点::0.7
直径::70

## end
#1226, 9:
0.0, 30.0
## end
#1227, 10:
0.0, 138.0
## end
#1228, 7:
255,0,0
## end
#1229, 1:
1
## end
#1230, 9:
SolidLine
## end
#1231, 3:
100
## end
#1232, 1:
5
## end
#1245, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1251, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1252, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1253, 2:
直线
## end
#1254, 362:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and (d<直径[0]/4 or d<5):
    state=True
else:
    state=False

## end
#1258, 49:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0
直径::70

## end
#1262, 14:
+[返回目录]
+[内容]

## end
#1263, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1265, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1266, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1268, 46:
线颜色::0,0,0
线型::DashLine
线粗细::2
焦点::0.7
直径::70

## end
#1276, 9:
0.0, 30.0
## end
#1277, 11:
480.0, 30.0
## end
#1278, 7:
255,0,0
## end
#1279, 1:
1
## end
#1280, 9:
SolidLine
## end
#1281, 3:
100
## end
#1282, 1:
5
## end
#1295, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1301, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1302, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1303, 2:
直线
## end
#1304, 362:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and (d<直径[0]/4 or d<5):
    state=True
else:
    state=False

## end
#1308, 49:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0
直径::70

## end
#1312, 14:
+[返回目录]
+[内容]

## end
#1313, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1315, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1316, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1318, 46:
线颜色::0,0,0
线型::DashLine
线粗细::2
焦点::0.7
直径::70

## end
#1326, 10:
0.0, -60.0
## end
#1327, 9:
0.0, 30.0
## end
#1328, 7:
255,0,0
## end
#1329, 1:
1
## end
#1330, 9:
SolidLine
## end
#1331, 3:
100
## end
#1332, 1:
5
## end
#1345, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1351, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1352, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1353, 2:
直线
## end
#1354, 362:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and (d<直径[0]/4 or d<5):
    state=True
else:
    state=False

## end
#1358, 49:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0
直径::70

## end
#1362, 14:
+[返回目录]
+[内容]

## end
#1363, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1365, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1366, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1368, 46:
线颜色::0,0,0
线型::DashLine
线粗细::2
焦点::0.7
直径::70

## end
#1376, 35:
90.9854327033741, 32.29320604943757
## end
#1377, 12:
1200.0, 30.0
## end
#1378, 7:
255,0,0
## end
#1379, 1:
1
## end
#1380, 9:
SolidLine
## end
#1381, 3:
100
## end
#1382, 1:
5
## end
#1395, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1401, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1402, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1403, 2:
直线
## end
#1404, 362:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and (d<直径[0]/4 or d<5):
    state=True
else:
    state=False

## end
#1408, 49:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0
直径::70

## end
#1412, 14:
+[返回目录]
+[内容]

## end
#1413, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1415, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1416, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1418, 46:
线颜色::0,0,0
线型::DashLine
线粗细::2
焦点::0.7
直径::70

## end
#1426, 36:
90.9854327033741, 2.2932060494375754
## end
#1427, 35:
90.9854327033741, 32.29320604943757
## end
#1428, 7:
255,0,0
## end
#1429, 1:
1
## end
#1430, 9:
SolidLine
## end
#1431, 3:
100
## end
#1432, 1:
5
## end
#1445, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1451, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1452, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1453, 2:
直线
## end
#1454, 362:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and (d<直径[0]/4 or d<5):
    state=True
else:
    state=False

## end
#1458, 49:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0
直径::70

## end
#1462, 14:
+[返回目录]
+[内容]

## end
#1463, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1465, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1466, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1468, 46:
线颜色::0,0,0
线型::DashLine
线粗细::2
焦点::0.7
直径::70

## end
#1476, 37:
862.6008847105079, 57.249992080357956
## end
#1477, 36:
90.9854327033741, 2.2932060494375754
## end
#1478, 7:
255,0,0
## end
#1479, 1:
1
## end
#1480, 9:
SolidLine
## end
#1481, 3:
100
## end
#1482, 1:
5
## end
#1495, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1501, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1502, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1503, 2:
直线
## end
#1504, 362:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and (d<直径[0]/4 or d<5):
    state=True
else:
    state=False

## end
#1508, 49:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0
直径::70

## end
#1512, 14:
+[返回目录]
+[内容]

## end
#1513, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1515, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1516, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1518, 46:
线颜色::0,0,0
线型::DashLine
线粗细::2
焦点::0.7
直径::70

## end
#1526, 38:
862.6008847105079, -2.7500079196420444
## end
#1527, 37:
862.6008847105079, 57.249992080357956
## end
#1528, 7:
255,0,0
## end
#1529, 1:
1
## end
#1530, 9:
SolidLine
## end
#1531, 3:
100
## end
#1532, 1:
5
## end
#1545, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1551, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1552, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1553, 2:
直线
## end
#1554, 362:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and (d<直径[0]/4 or d<5):
    state=True
else:
    state=False

## end
#1558, 49:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0
直径::70

## end
#1562, 14:
+[返回目录]
+[内容]

## end
#1563, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1565, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1566, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1568, 46:
线颜色::0,0,0
线型::DashLine
线粗细::2
焦点::0.7
直径::70

## end
#1576, 37:
112.63725297541443, 61.44564833805834
## end
#1577, 38:
862.6008847105079, -2.7500079196420444
## end
#1578, 7:
255,0,0
## end
#1579, 1:
1
## end
#1580, 9:
SolidLine
## end
#1581, 3:
100
## end
#1582, 1:
5
## end
#1595, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1601, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1602, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1603, 2:
直线
## end
#1604, 362:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and (d<直径[0]/4 or d<5):
    state=True
else:
    state=False

## end
#1608, 49:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0
直径::70

## end
#1612, 14:
+[返回目录]
+[内容]

## end
#1613, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1615, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1616, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1618, 46:
线颜色::0,0,0
线型::DashLine
线粗细::2
焦点::0.7
直径::70

## end
#1626, 38:
112.63725297541443, -28.55435166194166
## end
#1627, 37:
112.63725297541443, 61.44564833805834
## end
#1628, 7:
255,0,0
## end
#1629, 1:
1
## end
#1630, 9:
SolidLine
## end
#1631, 3:
100
## end
#1632, 1:
5
## end
#1645, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1651, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1652, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1653, 2:
直线
## end
#1654, 362:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and (d<直径[0]/4 or d<5):
    state=True
else:
    state=False

## end
#1658, 49:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0
直径::70

## end
#1662, 14:
+[返回目录]
+[内容]

## end
#1663, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1665, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1666, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1668, 46:
线颜色::0,0,0
线型::DashLine
线粗细::2
焦点::0.7
直径::70

## end
#1676, 36:
821.7756650740902, 84.47599857179571
## end
#1677, 38:
112.63725297541443, -28.55435166194166
## end
#1678, 7:
255,0,0
## end
#1679, 1:
1
## end
#1680, 9:
SolidLine
## end
#1681, 3:
100
## end
#1682, 1:
5
## end
#1695, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1701, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1702, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1703, 2:
直线
## end
#1704, 362:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and (d<直径[0]/4 or d<5):
    state=True
else:
    state=False

## end
#1708, 49:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0
直径::70

## end
#1712, 14:
+[返回目录]
+[内容]

## end
#1713, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1715, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1716, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1718, 46:
线颜色::0,0,0
线型::DashLine
线粗细::2
焦点::0.7
直径::70

## end
#1726, 36:
821.7756650740902, -35.5240014282043
## end
#1727, 36:
821.7756650740902, 84.47599857179571
## end
#1728, 7:
255,0,0
## end
#1729, 1:
1
## end
#1730, 9:
SolidLine
## end
#1731, 3:
100
## end
#1732, 1:
5
## end
#1745, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1751, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1752, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1753, 2:
直线
## end
#1754, 362:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and (d<直径[0]/4 or d<5):
    state=True
else:
    state=False

## end
#1758, 49:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0
直径::70

## end
#1762, 14:
+[返回目录]
+[内容]

## end
#1763, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1765, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1766, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1768, 46:
线颜色::0,0,0
线型::DashLine
线粗细::2
焦点::0.7
直径::70

## end
#1776, 37:
162.25113961720075, 90.91766883701163
## end
#1777, 36:
821.7756650740902, -35.5240014282043
## end
#1778, 7:
255,0,0
## end
#1779, 1:
1
## end
#1780, 9:
SolidLine
## end
#1781, 3:
100
## end
#1782, 1:
5
## end
#1795, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1801, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1802, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1803, 2:
直线
## end
#1804, 362:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and (d<直径[0]/4 or d<5):
    state=True
else:
    state=False

## end
#1808, 49:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0
直径::70

## end
#1812, 14:
+[返回目录]
+[内容]

## end
#1813, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1815, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1816, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1818, 46:
线颜色::0,0,0
线型::DashLine
线粗细::2
焦点::0.7
直径::70

## end
#1826, 38:
162.25113961720075, -59.08233116298837
## end
#1827, 37:
162.25113961720075, 90.91766883701163
## end
#1828, 7:
255,0,0
## end
#1829, 1:
1
## end
#1830, 9:
SolidLine
## end
#1831, 3:
100
## end
#1832, 1:
5
## end
#1845, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1851, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1852, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1853, 2:
直线
## end
#1854, 362:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and (d<直径[0]/4 or d<5):
    state=True
else:
    state=False

## end
#1858, 49:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0
直径::70

## end
#1862, 14:
+[返回目录]
+[内容]

## end
#1863, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1865, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1866, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1868, 46:
线颜色::0,0,0
线型::DashLine
线粗细::2
焦点::0.7
直径::70

## end
#1876, 36:
762.565167456592, 109.21842360714886
## end
#1877, 38:
162.25113961720075, -59.08233116298837
## end
#1878, 7:
255,0,0
## end
#1879, 1:
1
## end
#1880, 9:
SolidLine
## end
#1881, 3:
100
## end
#1882, 1:
5
## end
#1895, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1901, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1902, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1903, 2:
直线
## end
#1904, 362:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and (d<直径[0]/4 or d<5):
    state=True
else:
    state=False

## end
#1908, 49:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0
直径::70

## end
#1912, 14:
+[返回目录]
+[内容]

## end
#1913, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1915, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1916, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1918, 46:
线颜色::0,0,0
线型::DashLine
线粗细::2
焦点::0.7
直径::70

## end
#1926, 36:
762.565167456592, -70.78157639285114
## end
#1927, 36:
762.565167456592, 109.21842360714886
## end
#1928, 7:
255,0,0
## end
#1929, 1:
1
## end
#1930, 9:
SolidLine
## end
#1931, 3:
100
## end
#1932, 1:
5
## end
#1945, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1951, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1952, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1953, 2:
直线
## end
#1954, 362:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and (d<直径[0]/4 or d<5):
    state=True
else:
    state=False

## end
#1958, 49:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0
直径::70

## end
#1962, 14:
+[返回目录]
+[内容]

## end
#1963, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1965, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1966, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1968, 46:
线颜色::0,0,0
线型::DashLine
线粗细::2
焦点::0.7
直径::70

## end
#1976, 25:
210.0, 126.29999999999998
## end
#1977, 36:
762.565167456592, -70.78157639285114
## end
#1978, 7:
255,0,0
## end
#1979, 1:
1
## end
#1980, 9:
SolidLine
## end
#1981, 3:
100
## end
#1982, 1:
5
## end
#1995, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#2001, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#2002, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#2003, 2:
直线
## end
#2004, 362:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and (d<直径[0]/4 or d<5):
    state=True
else:
    state=False

## end
#2008, 49:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0
直径::70

## end
#2012, 14:
+[返回目录]
+[内容]

## end
#2013, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#2015, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#2016, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#2018, 46:
线颜色::0,0,0
线型::DashLine
线粗细::2
焦点::0.7
直径::70

## end
#2026, 13:
210.0, -120.0
## end
#2027, 25:
210.0, 126.29999999999998
## end
#2028, 7:
255,0,0
## end
#2029, 1:
1
## end
#2030, 9:
SolidLine
## end
#2031, 3:
100
## end
#2032, 1:
5
## end
#2045, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#2051, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#2052, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#2053, 2:
直线
## end
#2054, 362:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and (d<直径[0]/4 or d<5):
    state=True
else:
    state=False

## end
#2058, 49:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0
直径::70

## end
#2062, 14:
+[返回目录]
+[内容]

## end
#2063, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#2065, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#2066, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#2068, 46:
线颜色::0,0,0
线型::DashLine
线粗细::2
焦点::0.7
直径::70

## end
#2076, 13:
360.0, -120.0
## end
#2077, 13:
210.0, -120.0
## end
#2078, 7:
255,0,0
## end
#2079, 1:
1
## end
#2080, 9:
SolidLine
## end
#2081, 3:
100
## end
#2082, 1:
5
## end
#2095, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#2101, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#2102, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#2103, 2:
直线
## end
#2104, 362:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and (d<直径[0]/4 or d<5):
    state=True
else:
    state=False

## end
#2108, 49:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0
直径::70

## end
#2112, 14:
+[返回目录]
+[内容]

## end
#2113, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#2115, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#2116, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#2118, 46:
线颜色::0,0,0
线型::DashLine
线粗细::2
焦点::0.7
直径::70

## end
#2126, 12:
360.0, 300.0
## end
#2127, 13:
360.0, -120.0
## end
#2128, 7:
255,0,0
## end
#2129, 1:
1
## end
#2130, 9:
SolidLine
## end
#2131, 3:
100
## end
#2132, 1:
5
## end
#2145, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#2151, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#2152, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#2153, 2:
直线
## end
#2154, 362:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and (d<直径[0]/4 or d<5):
    state=True
else:
    state=False

## end
#2158, 49:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0
直径::70

## end
#2162, 14:
+[返回目录]
+[内容]

## end
#2163, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#2165, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#2166, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#2168, 46:
线颜色::0,0,0
线型::DashLine
线粗细::2
焦点::0.7
直径::70

## end
#2176, 12:
600.0, 300.0
## end
#2177, 12:
360.0, 300.0
## end
#2178, 7:
255,0,0
## end
#2179, 1:
1
## end
#2180, 9:
SolidLine
## end
#2181, 3:
100
## end
#2182, 1:
5
## end
#2195, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#2201, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#2202, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#2203, 2:
直线
## end
#2204, 362:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and (d<直径[0]/4 or d<5):
    state=True
else:
    state=False

## end
#2208, 49:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0
直径::70

## end
#2212, 14:
+[返回目录]
+[内容]

## end
#2213, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#2215, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#2216, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#2218, 46:
线颜色::0,0,0
线型::DashLine
线粗细::2
焦点::0.7
直径::70

## end
#2226, 12:
360.0, 300.0
## end
#2227, 12:
600.0, 300.0
## end
#2228, 7:
255,0,0
## end
#2229, 1:
1
## end
#2230, 9:
SolidLine
## end
#2231, 3:
100
## end
#2232, 1:
5
## end
#2245, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#2251, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#2252, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#2253, 2:
直线
## end
#2254, 362:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and (d<直径[0]/4 or d<5):
    state=True
else:
    state=False

## end
#2258, 49:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0
直径::70

## end
#2262, 14:
+[返回目录]
+[内容]

## end
#2263, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#2265, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#2266, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#2268, 46:
线颜色::0,0,0
线型::DashLine
线粗细::2
焦点::0.7
直径::70

## end
#2276, 13:
360.0, -180.0
## end
#2277, 12:
360.0, 300.0
## end
#2278, 7:
255,0,0
## end
#2279, 1:
1
## end
#2280, 9:
SolidLine
## end
#2281, 3:
100
## end
#2282, 1:
5
## end
#2285, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#2288, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#2291, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#2294, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#2297, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#2300, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#2303, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#2306, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#2309, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#2312, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#2315, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#2318, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#2321, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#2324, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#2327, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#2330, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#2333, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#2336, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#2339, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#2342, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#2345, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#2348, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#2351, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#2354, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#2357, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#2360, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#2363, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#2366, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#2369, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#2372, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#2375, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#2378, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#2381, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#2384, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#2387, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#2390, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#2405, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#2411, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#2412, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#2413, 2:
圆形
## end
#2414, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#2417, 14:
+[返回目录]
+[内容]

## end
#2418, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#2421, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#2423, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#2433, 1:
4
## end
#2434, 11:
480.0, 30.0
## end
#2435, 2:
10
## end
#2436, 19:
0.11847530663426653
## end
#2437, 11:
255,255,255
## end
#2438, 5:
0,0,0
## end
#2439, 8:
DashLine
## end
#2440, 1:
2
## end
#2441, 7:
Crystal
## end
#2455, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#2461, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#2462, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#2463, 2:
圆形
## end
#2464, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#2467, 14:
+[返回目录]
+[内容]

## end
#2468, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#2471, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#2473, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#2483, 1:
4
## end
#2484, 12:
360.0, 300.0
## end
#2485, 2:
10
## end
#2486, 4:
45.0
## end
#2487, 11:
255,255,255
## end
#2488, 5:
0,0,0
## end
#2489, 8:
DashLine
## end
#2490, 1:
2
## end
#2491, 3:
M19
## end
#2505, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#2511, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#2512, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#2513, 2:
圆形
## end
#2514, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#2517, 14:
+[返回目录]
+[内容]

## end
#2518, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#2521, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#2523, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#2533, 1:
4
## end
#2534, 9:
0.0, -0.0
## end
#2535, 2:
10
## end
#2536, 5:
-90.0
## end
#2537, 11:
255,255,255
## end
#2538, 5:
0,0,0
## end
#2539, 8:
DashLine
## end
#2540, 1:
2
## end
#2541, 2:
X6
## end
#2555, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#2561, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#2562, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#2563, 2:
圆形
## end
#2564, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#2567, 14:
+[返回目录]
+[内容]

## end
#2568, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#2571, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#2573, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#2583, 1:
4
## end
#2584, 9:
0.0, 30.0
## end
#2585, 2:
10
## end
#2586, 6:
-135.0
## end
#2587, 11:
255,255,255
## end
#2588, 5:
0,0,0
## end
#2589, 8:
DashLine
## end
#2590, 1:
2
## end
#2591, 1:
S
## end
#2605, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#2611, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#2612, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#2613, 2:
圆形
## end
#2614, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#2617, 14:
+[返回目录]
+[内容]

## end
#2618, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#2621, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#2623, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#2633, 1:
4
## end
#2634, 10:
0.0, 138.0
## end
#2635, 2:
10
## end
#2636, 4:
45.0
## end
#2637, 11:
255,255,255
## end
#2638, 5:
0,0,0
## end
#2639, 8:
DashLine
## end
#2640, 1:
2
## end
#2641, 3:
M18
## end
#2655, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#2661, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#2662, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#2663, 2:
圆形
## end
#2664, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#2667, 14:
+[返回目录]
+[内容]

## end
#2668, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#2671, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#2673, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#2683, 1:
4
## end
#2684, 12:
900.0, 138.0
## end
#2685, 2:
10
## end
#2686, 3:
0.0
## end
#2687, 11:
255,255,255
## end
#2688, 5:
0,0,0
## end
#2689, 8:
DashLine
## end
#2690, 1:
2
## end
#2691, 2:
X5
## end
#2705, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#2711, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#2712, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#2713, 2:
圆形
## end
#2714, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#2717, 14:
+[返回目录]
+[内容]

## end
#2718, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#2721, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#2723, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#2733, 1:
4
## end
#2734, 12:
960.0, 138.0
## end
#2735, 2:
10
## end
#2736, 6:
-225.0
## end
#2737, 11:
255,255,255
## end
#2738, 5:
0,0,0
## end
#2739, 8:
DashLine
## end
#2740, 1:
2
## end
#2741, 3:
M17
## end
#2755, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#2761, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#2762, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#2763, 2:
圆形
## end
#2764, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#2767, 14:
+[返回目录]
+[内容]

## end
#2768, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#2771, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#2773, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#2783, 1:
4
## end
#2784, 11:
960.0, 30.0
## end
#2785, 2:
10
## end
#2786, 6:
-135.0
## end
#2787, 11:
255,255,255
## end
#2788, 5:
0,0,0
## end
#2789, 8:
DashLine
## end
#2790, 1:
2
## end
#2791, 3:
M16
## end
#2805, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#2811, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#2812, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#2813, 2:
圆形
## end
#2814, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#2817, 14:
+[返回目录]
+[内容]

## end
#2818, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#2821, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#2823, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#2833, 1:
4
## end
#2834, 13:
360.0, -180.0
## end
#2835, 2:
10
## end
#2836, 14:
1200.0, -600.0
## end
#2837, 11:
255,255,255
## end
#2838, 5:
0,0,0
## end
#2839, 8:
DashLine
## end
#2840, 1:
2
## end
#2841, 9:
Stretcher
## end
#2855, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#2861, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#2862, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#2863, 2:
圆形
## end
#2864, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#2867, 14:
+[返回目录]
+[内容]

## end
#2868, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#2871, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#2873, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#2883, 1:
4
## end
#2884, 12:
600.0, 300.0
## end
#2885, 2:
10
## end
#2886, 6:
-180.0
## end
#2887, 11:
255,255,255
## end
#2888, 5:
0,0,0
## end
#2889, 8:
DashLine
## end
#2890, 1:
2
## end
#2891, 3:
M15
## end
#2905, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#2911, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#2912, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#2913, 2:
圆形
## end
#2914, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#2917, 14:
+[返回目录]
+[内容]

## end
#2918, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#2921, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#2923, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#2933, 1:
4
## end
#2934, 13:
360.0, -120.0
## end
#2935, 2:
10
## end
#2936, 6:
-135.0
## end
#2937, 11:
255,255,255
## end
#2938, 5:
0,0,0
## end
#2939, 8:
DashLine
## end
#2940, 1:
2
## end
#2941, 3:
M14
## end
#2955, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#2961, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#2962, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#2963, 2:
圆形
## end
#2964, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#2967, 14:
+[返回目录]
+[内容]

## end
#2968, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#2971, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#2973, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#2983, 1:
4
## end
#2984, 13:
348.0, -120.0
## end
#2985, 2:
10
## end
#2986, 6:
-180.0
## end
#2987, 11:
255,255,255
## end
#2988, 7:
0,200,0
## end
#2989, 8:
DashLine
## end
#2990, 1:
4
## end
#2991, 2:
I2
## end
#3005, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#3011, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#3012, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#3013, 2:
圆形
## end
#3014, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#3017, 14:
+[返回目录]
+[内容]

## end
#3018, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#3021, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#3023, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#3033, 1:
4
## end
#3034, 13:
336.0, -120.0
## end
#3035, 2:
10
## end
#3036, 6:
-180.0
## end
#3037, 11:
255,255,255
## end
#3038, 5:
0,0,0
## end
#3039, 8:
DashLine
## end
#3040, 1:
2
## end
#3041, 2:
X4
## end
#3055, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#3061, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#3062, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#3063, 2:
圆形
## end
#3064, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#3067, 14:
+[返回目录]
+[内容]

## end
#3068, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#3071, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#3073, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#3083, 1:
4
## end
#3084, 13:
324.0, -120.0
## end
#3085, 2:
10
## end
#3086, 6:
-180.0
## end
#3087, 11:
255,255,255
## end
#3088, 5:
0,0,0
## end
#3089, 8:
DashLine
## end
#3090, 1:
2
## end
#3091, 7:
Dazzler
## end
#3105, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#3111, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#3112, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#3113, 2:
圆形
## end
#3114, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#3117, 14:
+[返回目录]
+[内容]

## end
#3118, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#3121, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#3123, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#3133, 1:
4
## end
#3134, 13:
312.0, -120.0
## end
#3135, 2:
10
## end
#3136, 6:
-180.0
## end
#3137, 11:
255,255,255
## end
#3138, 5:
0,0,0
## end
#3139, 8:
DashLine
## end
#3140, 1:
2
## end
#3141, 7:
Faraday
## end
#3155, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#3161, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#3162, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#3163, 2:
圆形
## end
#3164, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#3167, 14:
+[返回目录]
+[内容]

## end
#3168, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#3171, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#3173, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#3183, 1:
4
## end
#3184, 13:
300.0, -120.0
## end
#3185, 2:
10
## end
#3186, 6:
-180.0
## end
#3187, 11:
255,255,255
## end
#3188, 5:
0,0,0
## end
#3189, 8:
DashLine
## end
#3190, 1:
2
## end
#3191, 2:
X3
## end
#3205, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#3211, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#3212, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#3213, 2:
圆形
## end
#3214, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#3217, 14:
+[返回目录]
+[内容]

## end
#3218, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#3221, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#3223, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#3233, 1:
4
## end
#3234, 13:
210.0, -120.0
## end
#3235, 2:
10
## end
#3236, 18:
-44.99999999999999
## end
#3237, 11:
255,255,255
## end
#3238, 5:
0,0,0
## end
#3239, 8:
DashLine
## end
#3240, 1:
2
## end
#3241, 3:
M13
## end
#3255, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#3261, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#3262, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#3263, 2:
圆形
## end
#3264, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#3267, 14:
+[返回目录]
+[内容]

## end
#3268, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#3271, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#3273, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#3283, 1:
4
## end
#3284, 25:
210.0, 126.29999999999998
## end
#3285, 2:
10
## end
#3286, 17:
54.81481154832852
## end
#3287, 11:
255,255,255
## end
#3288, 5:
0,0,0
## end
#3289, 8:
DashLine
## end
#3290, 1:
2
## end
#3291, 3:
M12
## end
#3305, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#3311, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#3312, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#3313, 2:
圆形
## end
#3314, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#3317, 14:
+[返回目录]
+[内容]

## end
#3318, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#3321, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#3323, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#3333, 1:
4
## end
#3334, 37:
226.9539100473955, 120.25310541642891
## end
#3335, 2:
10
## end
#3336, 18:
19.629623096657028
## end
#3337, 11:
255,255,255
## end
#3338, 7:
0,200,0
## end
#3339, 8:
DashLine
## end
#3340, 1:
4
## end
#3341, 2:
I1
## end
#3355, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#3361, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#3362, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#3363, 2:
圆形
## end
#3364, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#3367, 14:
+[返回目录]
+[内容]

## end
#3368, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#3371, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#3373, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#3383, 1:
4
## end
#3384, 37:
734.3086507109329, -60.70341875356603
## end
#3385, 2:
10
## end
#3386, 18:
19.629623096657028
## end
#3387, 11:
255,255,255
## end
#3388, 5:
0,0,0
## end
#3389, 8:
DashLine
## end
#3390, 1:
2
## end
#3391, 2:
I0
## end
#3405, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#3411, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#3412, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#3413, 2:
圆形
## end
#3414, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#3417, 14:
+[返回目录]
+[内容]

## end
#3418, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#3421, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#3423, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#3433, 1:
4
## end
#3434, 37:
745.6112574091965, -64.73468180928006
## end
#3435, 2:
10
## end
#3436, 18:
19.629623096657028
## end
#3437, 11:
255,255,255
## end
#3438, 5:
0,0,0
## end
#3439, 8:
DashLine
## end
#3440, 1:
2
## end
#3441, 2:
X2
## end
#3455, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#3461, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#3462, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#3463, 2:
圆形
## end
#3464, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#3467, 14:
+[返回目录]
+[内容]

## end
#3468, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#3471, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#3473, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#3483, 1:
4
## end
#3484, 37:
751.2625607583284, -66.75031333713709
## end
#3485, 2:
10
## end
#3486, 18:
19.629623096657028
## end
#3487, 11:
255,255,255
## end
#3488, 5:
0,0,0
## end
#3489, 8:
DashLine
## end
#3490, 1:
2
## end
#3491, 2:
X1
## end
#3505, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#3511, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#3512, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#3513, 2:
圆形
## end
#3514, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#3517, 14:
+[返回目录]
+[内容]

## end
#3518, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#3521, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#3523, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#3533, 1:
4
## end
#3534, 36:
762.565167456592, -70.78157639285114
## end
#3535, 2:
10
## end
#3536, 19:
-125.18518845167148
## end
#3537, 11:
255,255,255
## end
#3538, 5:
0,0,0
## end
#3539, 8:
DashLine
## end
#3540, 1:
2
## end
#3541, 3:
M11
## end
#3555, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#3561, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#3562, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#3563, 2:
圆形
## end
#3564, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#3567, 14:
+[返回目录]
+[内容]

## end
#3568, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#3571, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#3573, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#3583, 1:
4
## end
#3584, 36:
762.565167456592, 109.21842360714886
## end
#3585, 2:
10
## end
#3586, 18:
-232.8305404102467
## end
#3587, 11:
255,255,255
## end
#3588, 5:
0,0,0
## end
#3589, 8:
DashLine
## end
#3590, 1:
2
## end
#3591, 3:
M10
## end
#3605, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#3611, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#3612, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#3613, 2:
圆形
## end
#3614, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#3617, 14:
+[返回目录]
+[内容]

## end
#3618, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#3621, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#3623, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#3633, 1:
4
## end
#3634, 38:
191.13739965200068, -50.98393742089851
## end
#3635, 2:
10
## end
#3636, 19:
-195.66108082049337
## end
#3637, 11:
255,255,255
## end
#3638, 5:
0,0,0
## end
#3639, 8:
DashLine
## end
#3640, 1:
2
## end
#3641, 2:
X0
## end
#3655, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#3661, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#3662, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#3663, 2:
圆形
## end
#3664, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#3667, 14:
+[返回目录]
+[内容]

## end
#3668, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#3671, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#3673, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#3683, 1:
4
## end
#3684, 38:
162.25113961720075, -59.08233116298837
## end
#3685, 2:
10
## end
#3686, 18:
-52.83054041024667
## end
#3687, 11:
255,255,255
## end
#3688, 5:
0,0,0
## end
#3689, 8:
DashLine
## end
#3690, 1:
2
## end
#3691, 2:
M9
## end
#3705, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#3711, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#3712, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#3713, 2:
圆形
## end
#3714, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#3717, 14:
+[返回目录]
+[内容]

## end
#3718, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#3721, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#3723, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#3733, 1:
4
## end
#3734, 37:
162.25113961720075, 90.91766883701163
## end
#3735, 2:
10
## end
#3736, 17:
50.42642667810941
## end
#3737, 11:
255,255,255
## end
#3738, 5:
0,0,0
## end
#3739, 8:
DashLine
## end
#3740, 1:
2
## end
#3741, 2:
M8
## end
#3755, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#3761, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#3762, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#3763, 2:
圆形
## end
#3764, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#3767, 14:
+[返回目录]
+[内容]

## end
#3768, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#3771, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#3773, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#3783, 1:
4
## end
#3784, 36:
821.7756650740902, -35.5240014282043
## end
#3785, 2:
10
## end
#3786, 18:
-129.5735733218906
## end
#3787, 11:
255,255,255
## end
#3788, 5:
0,0,0
## end
#3789, 8:
DashLine
## end
#3790, 1:
2
## end
#3791, 2:
M7
## end
#3805, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#3811, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#3812, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#3813, 2:
圆形
## end
#3814, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#3817, 14:
+[返回目录]
+[内容]

## end
#3818, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#3821, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#3823, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#3833, 1:
4
## end
#3834, 36:
821.7756650740902, 84.47599857179571
## end
#3835, 2:
10
## end
#3836, 18:
-229.5281285065799
## end
#3837, 11:
255,255,255
## end
#3838, 5:
0,0,0
## end
#3839, 8:
DashLine
## end
#3840, 1:
2
## end
#3841, 2:
M6
## end
#3855, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#3861, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#3862, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#3863, 2:
圆形
## end
#3864, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#3867, 14:
+[返回目录]
+[内容]

## end
#3868, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#3871, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#3873, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#3883, 1:
4
## end
#3884, 38:
112.63725297541443, -28.55435166194166
## end
#3885, 2:
10
## end
#3886, 18:
-49.52812850657989
## end
#3887, 11:
255,255,255
## end
#3888, 5:
0,0,0
## end
#3889, 8:
DashLine
## end
#3890, 1:
2
## end
#3891, 2:
M5
## end
#3905, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#3911, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#3912, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#3913, 2:
圆形
## end
#3914, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#3917, 14:
+[返回目录]
+[内容]

## end
#3918, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#3921, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#3923, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#3933, 1:
4
## end
#3934, 37:
112.63725297541443, 61.44564833805834
## end
#3935, 2:
10
## end
#3936, 17:
47.44624936300656
## end
#3937, 11:
255,255,255
## end
#3938, 5:
0,0,0
## end
#3939, 8:
DashLine
## end
#3940, 1:
2
## end
#3941, 2:
M4
## end
#3955, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#3961, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#3962, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#3963, 2:
圆形
## end
#3964, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#3967, 14:
+[返回目录]
+[内容]

## end
#3968, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#3971, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#3973, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#3983, 1:
4
## end
#3984, 38:
862.6008847105079, -2.7500079196420444
## end
#3985, 2:
10
## end
#3986, 19:
-132.55375063699344
## end
#3987, 11:
255,255,255
## end
#3988, 5:
0,0,0
## end
#3989, 8:
DashLine
## end
#3990, 1:
2
## end
#3991, 2:
M3
## end
#4005, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#4011, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#4012, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#4013, 2:
圆形
## end
#4014, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#4017, 14:
+[返回目录]
+[内容]

## end
#4018, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#4021, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#4023, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#4033, 1:
4
## end
#4034, 37:
862.6008847105079, 57.249992080357956
## end
#4035, 2:
10
## end
#4036, 18:
-227.0369497017003
## end
#4037, 11:
255,255,255
## end
#4038, 5:
0,0,0
## end
#4039, 8:
DashLine
## end
#4040, 1:
2
## end
#4041, 2:
M2
## end
#4055, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#4061, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#4062, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#4063, 2:
圆形
## end
#4064, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#4067, 14:
+[返回目录]
+[内容]

## end
#4068, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#4071, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#4073, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#4083, 1:
4
## end
#4084, 36:
90.9854327033741, 2.2932060494375754
## end
#4085, 2:
10
## end
#4086, 18:
-47.03694970170031
## end
#4087, 11:
255,255,255
## end
#4088, 5:
0,0,0
## end
#4089, 8:
DashLine
## end
#4090, 1:
2
## end
#4091, 2:
M1
## end
#4105, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#4111, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#4112, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#4113, 2:
圆形
## end
#4114, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#4117, 14:
+[返回目录]
+[内容]

## end
#4118, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#4121, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#4123, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#4133, 1:
4
## end
#4134, 35:
90.9854327033741, 32.29320604943757
## end
#4135, 2:
10
## end
#4136, 18:
45.059237653317126
## end
#4137, 11:
255,255,255
## end
#4138, 5:
0,0,0
## end
#4139, 8:
DashLine
## end
#4140, 1:
2
## end
#4141, 2:
M0
## end
#4155, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#4161, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#4162, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#4163, 2:
圆形
## end
#4164, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#4167, 14:
+[返回目录]
+[内容]

## end
#4168, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#4171, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#4173, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#4183, 1:
4
## end
#4184, 12:
1200.0, 30.0
## end
#4185, 2:
10
## end
#4186, 13:
4000.0, 100.0
## end
#4187, 11:
255,255,255
## end
#4188, 5:
0,0,0
## end
#4189, 8:
DashLine
## end
#4190, 1:
2
## end
#4191, 3:
2nd
## end
#4193, 295:
+[返回目录](,第二幅)
+[显示星图](,第二幅)
+[删除结构](,第二幅)

有一个晶体, 中间垂直穿过一段声波, 水平偏振的输入光输入之后, 分出一段竖直偏振的散射光. 
+晶体->+声波->+输入光->+散射光(,)...
->+分出来(+输入光,+散射光)

晶体和声波在同一个空间点上, 都有尺寸
+在(晶体,+空间点)->+的(晶体,+尺寸)
+在(声波,空间点)->+的(声波,+尺寸)

入射光起点在晶体中心左边一段距离的位置, 终点在晶体中心右边一段距离的位置. 
散射光起点和晶体边界的x对齐, 高出入射光的某个位置, 终点和入射光终点的x坐标相同. 






## end
#4219, 1031:
+[显示星图](,流程图)
+[删除结构](,流程图)

Nini, 导入PPT的库
Nini, 导入平面测绘的库

流程图中新增9个矩形(矩形)

矩形1距离矩形0为(2,0). 矩形2距离矩形1为(2,0). 矩形3距离矩形2为(2,0)
矩形4距离矩形0为(0,-4)
矩形5距离矩形4为(2,0). 矩形8距离矩形5为(2,0)
矩形6距离矩形5为(0,2). 矩形7距离矩形5为(0,-2)

Nini, 打开动词(库)
矩形1的尺寸是"1.2,0.8"
矩形1的内容是什么

矩形0的内容是"1". 矩形1的内容是"Engineer visiting lab". 矩形2的内容是"New quote". 矩形3的内容"Send QR to factory"

矩形4的内容是"2". 矩形5的内容是"Polish old rods". 矩形6的内容是"Order new rods". 矩形7的内容是"Get rods from QR A/B". 矩形8的内容是"Installation & alignment"

框架::
窗口::
窗口都是矩形. 窗口的尺寸是"12,8"
窗口在(-0.25,-6.25)
框架=>_re"矩形"=>+[有](框架,_re)
在框架中, 全部物体的尺寸都是"1.2,0.8"
框架的屏幕是窗口

地址::output\20220120\流程图.pptx
+[PPT场景输出](框架,地址)->+[打开](,地址)

好, 这张图用PPT画需要7分钟. 

窗口的尺寸是"12,8"
窗口的尺寸是什么
Nini, 打开PPT(文件)
Nini, 导入图形库的库

框架有箭头
箭头::
箭头的类型是"箭头". 箭头的长度是"8". 箭头的箭头长度是"1". 更新箭头(图形)
箭头的箭头宽度是"0.5". 更新箭头(图形)
箭头距离矩形0(1.2,0.4). 箭头朝向-90的角度. 箭头的长度是"4.8"
箭头的箭头长度是"0.3". 箭头的箭头宽度是"0.3"
更新箭头(图形)

箭头2::
框架有箭头2. 将箭头复制到箭头2
箭头2距离矩形4(1.2,0.4). 箭头2朝向-90的角度. 
箭头2的长度是"2.8"
更新箭头2(图形)
+[设置结构](,箭头2)

圆形::
框架有圆形. 圆形的类型是"圆形". 更新圆形(图形)



+[显示PPT场景](,框架)
+[显示PPT图形](,箭头2)
## end
#4220, 4:
4406
## end
#4294, 24:
Installation & alignment
## end
#4296, 2:
矩形
## end
#4297, 7:
1.2,0.8
## end
#4299, 9:
4.0, -4.0
## end
#4302, 20:
Get rods from QR A/B
## end
#4304, 2:
矩形
## end
#4305, 7:
1.2,0.8
## end
#4307, 9:
2.0, -6.0
## end
#4310, 14:
Order new rods
## end
#4312, 2:
矩形
## end
#4313, 7:
1.2,0.8
## end
#4315, 9:
2.0, -2.0
## end
#4318, 15:
Polish old rods
## end
#4320, 2:
矩形
## end
#4321, 7:
1.2,0.8
## end
#4323, 9:
2.0, -4.0
## end
#4326, 1:
2
## end
#4328, 2:
矩形
## end
#4329, 7:
1.2,0.8
## end
#4331, 9:
0.0, -4.0
## end
#4334, 9:
New quote
## end
#4336, 2:
矩形
## end
#4337, 7:
1.2,0.8
## end
#4339, 8:
6.0, 0.0
## end
#4342, 9:
New quote
## end
#4344, 2:
矩形
## end
#4345, 7:
1.2,0.8
## end
#4347, 8:
4.0, 0.0
## end
#4350, 21:
Engineer visiting lab
## end
#4352, 2:
矩形
## end
#4353, 7:
1.2,0.8
## end
#4355, 8:
2.0, 0.0
## end
#4358, 1:
1
## end
#4360, 2:
矩形
## end
#4361, 7:
1.2,0.8
## end
#4363, 3:
0,0
## end
#4374, 4:
12,8
## end
#4376, 11:
-0.25,-6.25
## end
#4391, 3:
1,1
## end
#4393, 3:
0,0
## end
#4400, 24:
output\20220120\流程图.pptx
## end
#4405, 2:
箭头
## end
#4407, 38:
0.0, 4.5, 4.5, 4.8, 4.5, 4.5, 0.0, 0.0
## end
#4409, 48:
0.05, 0.05, 0.15, 0.0, -0.15, -0.05, -0.05, 0.05
## end
#4413, 3:
-90
## end
#4417, 3:
4.8
## end
#4421, 3:
0.3
## end
#4425, 3:
0.3
## end
#4429, 8:
1.2, 0.4
## end
#4434, 2:
箭头
## end
#4436, 48:
0.05, 0.05, 0.15, 0.0, -0.15, -0.05, -0.05, 0.05
## end
#4438, 38:
0.0, 2.5, 2.5, 2.8, 2.5, 2.5, 0.0, 0.0
## end
#4440, 3:
2.8
## end
#4442, 3:
0.3
## end
#4444, 3:
0.3
## end
#4450, 9:
1.2, -3.6
## end
#4454, 3:
-90
## end
#4456, 4:
4471
## end
#4465, 2:
圆形
## end
#4467, 2018:
0.0, 0.0634239196565645, 0.12659245357374926, 0.1892512443604102, 0.2511479871810792, 0.3120334456984872, 0.3716624556603275, 0.4297949120891716, 0.4861967361004687, 0.5406408174555976, 0.5929079290546405, 0.6427876096865393, 0.6900790114821119, 0.7345917086575333, 0.7761464642917568, 0.8145759520503357, 0.8497254299495144, 0.8814533634475821, 0.9096319953545183, 0.9341478602651068, 0.9549022414440739, 0.9718115683235417, 0.984807753012208, 0.9938384644612541, 0.998867339183008, 0.9998741276738751, 0.9968547759519424, 0.9898214418809327, 0.9788024462147787, 0.963842158559942, 0.9450008187146685, 0.9223542941045814, 0.8959937742913359, 0.8660254037844386, 0.8325698546347713, 0.7957618405308322, 0.7557495743542584, 0.712694171378863, 0.6667690005162915, 0.6181589862206053, 0.5670598638627705, 0.5136773915734063, 0.4582265217274105, 0.4009305354066135, 0.3420201433256687, 0.28173255684142984, 0.2203105327865405, 0.15800139597334995, 0.0950560433041829, 0.031727933498067566, -0.031727933498067566, -0.0950560433041829, -0.15800139597334995, -0.2203105327865405, -0.28173255684142984, -0.3420201433256687, -0.4009305354066135, -0.4582265217274105, -0.5136773915734063, -0.5670598638627705, -0.6181589862206053, -0.6667690005162915, -0.712694171378863, -0.7557495743542584, -0.795761840530832, -0.8325698546347715, -0.8660254037844386, -0.8959937742913358, -0.9223542941045815, -0.9450008187146685, -0.963842158559942, -0.9788024462147787, -0.9898214418809327, -0.9968547759519423, -0.9998741276738751, -0.998867339183008, -0.9938384644612541, -0.984807753012208, -0.9718115683235418, -0.954902241444074, -0.9341478602651065, -0.9096319953545182, -0.881453363447582, -0.8497254299495144, -0.8145759520503358, -0.776146464291757, -0.734591708657533, -0.6900790114821119, -0.6427876096865393, -0.5929079290546406, -0.5406408174555979, -0.4861967361004683, -0.42979491208917137, -0.37166245566032746, -0.3120334456984872, -0.25114798718107945, -0.18925124436041066, -0.1265924535737489, -0.06342391965656433, 0.0
## end
#4469, 2004:
1.0, 0.9979866764718844, 0.9919548128307953, 0.9819286972627067, 0.9679487013963562, 0.9500711177409453, 0.9283679330160726, 0.9029265382866213, 0.8738493770697849, 0.8412535328311812, 0.8052702575310585, 0.766044443118978, 0.7237340381050702, 0.6785094115571322, 0.6305526670845225, 0.5800569095711982, 0.5272254676105025, 0.47227107477268265, 0.41541501300188644, 0.3568862215918718, 0.29692037532827475, 0.23575893550942728, 0.17364817766693033, 0.11083819990101094, 0.04758191582374241, -0.015865963834807883, -0.07924995685678848, -0.14231483827328523, -0.2048066680651906, -0.266473813690035, -0.32706796331742166, -0.38634512569312873, -0.44406661260577407, -0.5, -0.5539200638661103, -0.6056096871376666, -0.654860733945285, -0.7014748877063212, -0.7452644496757548, -0.7860530947427874, -0.8236765814298329, -0.8579834132349771, -0.8888354486549234, -0.9161084574320697, -0.9396926207859084, -0.9594929736144974, -0.975429786885407, -0.9874388886763943, -0.9954719225730846, -0.9994965423831851, -0.9994965423831851, -0.9954719225730846, -0.9874388886763943, -0.975429786885407, -0.9594929736144974, -0.9396926207859084, -0.9161084574320697, -0.8888354486549234, -0.8579834132349771, -0.8236765814298329, -0.7860530947427874, -0.7452644496757548, -0.7014748877063212, -0.654860733945285, -0.6056096871376668, -0.5539200638661101, -0.5, -0.4440666126057743, -0.3863451256931285, -0.32706796331742166, -0.2664738136900352, -0.2048066680651906, -0.14231483827328523, -0.07924995685678873, -0.01586596383480838, 0.04758191582374265, 0.1108381999010112, 0.17364817766693033, 0.23575893550942706, 0.29692037532827453, 0.3568862215918722, 0.41541501300188666, 0.47227107477268276, 0.5272254676105024, 0.5800569095711979, 0.6305526670845222, 0.6785094115571324, 0.7237340381050703, 0.766044443118978, 0.8052702575310585, 0.841253532831181, 0.8738493770697852, 0.9029265382866213, 0.9283679330160727, 0.9500711177409453, 0.9679487013963562, 0.9819286972627066, 0.9919548128307953, 0.9979866764718844, 1.0
## end
#4472, 236:
+[显示PPT场景](,场景)
场景::
场景中新增2个L(箭头). 场景中新增1个圆柱(长方体)

三维场景::
三维场景有+圆柱体1
圆柱体1都是网格. 
圆柱体1是(1,1)的圆柱体
+[更新网格]"1,1"(+圆柱体,圆柱体1)->+[del](,+圆柱体)

圆柱体1的形状是"圆柱体". 圆柱体1的直径是"2.54". 圆柱体1的高是"12.7"
+[更新GEANT物体](,圆柱体1)
圆柱体1朝向(0,90,0)的方向


+[显示三维场景](,三维场景)
## end
#4491, 3:
多边形
## end
#4492, 2:
箭头
## end
#4494, 1:
0
## end
#4496, 3:
0,0
## end
#4499, 3:
多边形
## end
#4500, 2:
箭头
## end
#4502, 1:
0
## end
#4504, 3:
0,0
## end
#4508, 38:
0.0, 1.8, 1.8, 2.0, 1.8, 1.8, 0.0, 0.0
## end
#4510, 46:
0.05, 0.05, 0.1, 0.0, -0.1, -0.05, -0.05, 0.05
## end
#4513, 38:
0.0, 1.8, 1.8, 2.0, 1.8, 1.8, 0.0, 0.0
## end
#4515, 46:
0.05, 0.05, 0.1, 0.0, -0.1, -0.05, -0.05, 0.05
## end
#4525, 3:
多边形
## end
#4526, 3:
长方体
## end
#4528, 1:
0
## end
#4530, 3:
0,0
## end
#4556, 2:
网格
## end
#4557, 5:
0,0,0
## end
#4559, 5:
0,0,0
## end
#4575, 2598:
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
-6.35, -6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35;
6.35, 6.35
## end
#4577, 5142:
0.0, 0.0;
0.08054837796383692, 0.0;
0.16077241603866158, 0.0;
0.24034908033772093, 0.0;
0.3189579437199706, 0.0;
0.3962824760370787, 0.0;
0.47201131868861596, 0.0;
0.5458395383532479, 0.0;
0.6174698548475953, 0.0;
0.6866138381686089, 0.0;
0.7529930698993935, 0.0;
0.8163402643019049, 0.0;
0.8764003445822821, 0.0;
0.9329314699950674, 0.0;
0.9857060096505311, 0.0;
1.0345114591039264, 0.0;
1.0791512960358833, 0.0;
1.1194457715784292, 0.0;
1.1552326341002384, 0.0;
1.1863677825366856, 0.0;
1.2127258466339739, 0.0;
1.2342006917708979, 0.0;
1.2507058463255043, 0.0;
1.2621748498657928, 0.0;
1.2685615207624201, 0.0;
1.2698401421458214, 0.0;
1.2660055654589668, 0.0;
1.2570732311887844, 0.0;
1.243079106692769, 0.0;
1.2240795413711265, 0.0;
1.200151039767629, 0.0;
1.1713899535128183, 0.0;
1.1379120933499967, 0.0;
1.099852262806237, 0.0;
1.0573637153861595, 0.0;
1.0106175374741568, 0.0;
0.9598019594299082, 0.0;
0.9051215976511561, 0.0;
0.8467966306556902, 0.0;
0.7850619125001688, 0.0;
0.7201660271057185, 0.0;
0.652370287298226, 0.0;
0.5819476825938114, 0.0;
0.5091817799663991, 0.0;
0.43436558202359926, 0.0;
0.3578003471886159, 0.0;
0.27979437663890644, 0.0;
0.20066177288615444, 0.0;
0.12072117499631228, 0.0;
0.04029447554254581, 0.0;
-0.04029447554254581, -0.0;
-0.12072117499631228, -0.0;
-0.20066177288615444, -0.0;
-0.27979437663890644, -0.0;
-0.3578003471886159, -0.0;
-0.43436558202359926, -0.0;
-0.5091817799663991, -0.0;
-0.5819476825938114, -0.0;
-0.652370287298226, -0.0;
-0.7201660271057185, -0.0;
-0.7850619125001688, -0.0;
-0.8467966306556902, -0.0;
-0.9051215976511561, -0.0;
-0.9598019594299082, -0.0;
-1.0106175374741566, -0.0;
-1.05736371538616, -0.0;
-1.099852262806237, -0.0;
-1.1379120933499964, -0.0;
-1.1713899535128185, -0.0;
-1.200151039767629, -0.0;
-1.2240795413711265, -0.0;
-1.243079106692769, -0.0;
-1.2570732311887844, -0.0;
-1.2660055654589668, -0.0;
-1.2698401421458214, -0.0;
-1.2685615207624201, -0.0;
-1.2621748498657928, -0.0;
-1.2507058463255043, -0.0;
-1.234200691770898, -0.0;
-1.2127258466339739, -0.0;
-1.1863677825366854, -0.0;
-1.1552326341002381, -0.0;
-1.1194457715784292, -0.0;
-1.0791512960358833, -0.0;
-1.0345114591039266, -0.0;
-0.9857060096505315, -0.0;
-0.9329314699950669, -0.0;
-0.8764003445822821, -0.0;
-0.8163402643019049, -0.0;
-0.7529930698993936, -0.0;
-0.6866138381686093, -0.0;
-0.6174698548475948, -0.0;
-0.5458395383532476, -0.0;
-0.4720113186886159, -0.0;
-0.3962824760370787, -0.0;
-0.3189579437199709, -0.0;
-0.24034908033772154, -0.0;
-0.1607724160386611, -0.0;
-0.0805483779638367, -0.0;
0.0, 0.0;
0.0, 0.0;
0.08054837796383692, 0.0;
0.16077241603866158, 0.0;
0.24034908033772093, 0.0;
0.3189579437199706, 0.0;
0.3962824760370787, 0.0;
0.47201131868861596, 0.0;
0.5458395383532479, 0.0;
0.6174698548475953, 0.0;
0.6866138381686089, 0.0;
0.7529930698993935, 0.0;
0.8163402643019049, 0.0;
0.8764003445822821, 0.0;
0.9329314699950674, 0.0;
0.9857060096505311, 0.0;
1.0345114591039264, 0.0;
1.0791512960358833, 0.0;
1.1194457715784292, 0.0;
1.1552326341002384, 0.0;
1.1863677825366856, 0.0;
1.2127258466339739, 0.0;
1.2342006917708979, 0.0;
1.2507058463255043, 0.0;
1.2621748498657928, 0.0;
1.2685615207624201, 0.0;
1.2698401421458214, 0.0;
1.2660055654589668, 0.0;
1.2570732311887844, 0.0;
1.243079106692769, 0.0;
1.2240795413711265, 0.0;
1.200151039767629, 0.0;
1.1713899535128183, 0.0;
1.1379120933499967, 0.0;
1.099852262806237, 0.0;
1.0573637153861595, 0.0;
1.0106175374741568, 0.0;
0.9598019594299082, 0.0;
0.9051215976511561, 0.0;
0.8467966306556902, 0.0;
0.7850619125001688, 0.0;
0.7201660271057185, 0.0;
0.652370287298226, 0.0;
0.5819476825938114, 0.0;
0.5091817799663991, 0.0;
0.43436558202359926, 0.0;
0.3578003471886159, 0.0;
0.27979437663890644, 0.0;
0.20066177288615444, 0.0;
0.12072117499631228, 0.0;
0.04029447554254581, 0.0;
-0.04029447554254581, -0.0;
-0.12072117499631228, -0.0;
-0.20066177288615444, -0.0;
-0.27979437663890644, -0.0;
-0.3578003471886159, -0.0;
-0.43436558202359926, -0.0;
-0.5091817799663991, -0.0;
-0.5819476825938114, -0.0;
-0.652370287298226, -0.0;
-0.7201660271057185, -0.0;
-0.7850619125001688, -0.0;
-0.8467966306556902, -0.0;
-0.9051215976511561, -0.0;
-0.9598019594299082, -0.0;
-1.0106175374741566, -0.0;
-1.05736371538616, -0.0;
-1.099852262806237, -0.0;
-1.1379120933499964, -0.0;
-1.1713899535128185, -0.0;
-1.200151039767629, -0.0;
-1.2240795413711265, -0.0;
-1.243079106692769, -0.0;
-1.2570732311887844, -0.0;
-1.2660055654589668, -0.0;
-1.2698401421458214, -0.0;
-1.2685615207624201, -0.0;
-1.2621748498657928, -0.0;
-1.2507058463255043, -0.0;
-1.234200691770898, -0.0;
-1.2127258466339739, -0.0;
-1.1863677825366854, -0.0;
-1.1552326341002381, -0.0;
-1.1194457715784292, -0.0;
-1.0791512960358833, -0.0;
-1.0345114591039266, -0.0;
-0.9857060096505315, -0.0;
-0.9329314699950669, -0.0;
-0.8764003445822821, -0.0;
-0.8163402643019049, -0.0;
-0.7529930698993936, -0.0;
-0.6866138381686093, -0.0;
-0.6174698548475948, -0.0;
-0.5458395383532476, -0.0;
-0.4720113186886159, -0.0;
-0.3962824760370787, -0.0;
-0.3189579437199709, -0.0;
-0.24034908033772154, -0.0;
-0.1607724160386611, -0.0;
-0.0805483779638367, -0.0;
0.0, 0.0
## end
#4579, 5110:
1.27, 0.0;
1.2674430791192932, 0.0;
1.2597826122951101, 0.0;
1.2470494455236376, 0.0;
1.2292948507733725, 0.0;
1.2065903195310006, 0.0;
1.1790272749304123, 0.0;
1.1467167036240091, 0.0;
1.109788708878627, 0.0;
1.0683919866956002, 0.0;
1.0226932270644444, 0.0;
0.9728764427611021, 0.0;
0.9191422283934392, 0.0;
0.8617069526775579, 0.0;
0.8008018871973436, 0.0;
0.7366722751554217, 0.0;
0.6695763438653382, 0.0;
0.599784264961307, 0.0;
0.5275770665123958, 0.0;
0.4532455014216772, 0.0;
0.37708887666690893, 0.0;
0.29941384809697263, 0.0;
0.22053318563700153, 0.0;
0.1407645138742839, 0.0;
0.060429033096152864, 0.0;
-0.02014977407020601, -0.0;
-0.10064744520812137, -0.0;
-0.18073984460707224, -0.0;
-0.26010446844279206, -0.0;
-0.33842174338634445, -0.0;
-0.41537631341312553, -0.0;
-0.4906583096302735, -0.0;
-0.5639645980093331, -0.0;
-0.635, -0.0;
-0.70347848110996, -0.0;
-0.7691243026648366, -0.0;
-0.831673132110512, -0.0;
-0.8908731073870279, -0.0;
-0.9464858510882086, -0.0;
-0.99828743032334, -0.0;
-1.0460692584158877, -0.0;
-1.0896389348084208, -0.0;
-1.1288210197917528, -0.0;
-1.1634577409387286, -0.0;
-1.1934096283981037, -0.0;
-1.2185560764904118, -0.0;
-1.238795829344467, -0.0;
-1.2540473886190207, -0.0;
-1.2642493416678175, -0.0;
-1.2693606088266451, -0.0;
-1.2693606088266451, -0.0;
-1.2642493416678175, -0.0;
-1.2540473886190207, -0.0;
-1.238795829344467, -0.0;
-1.2185560764904118, -0.0;
-1.1934096283981037, -0.0;
-1.1634577409387286, -0.0;
-1.1288210197917528, -0.0;
-1.0896389348084208, -0.0;
-1.0460692584158877, -0.0;
-0.99828743032334, -0.0;
-0.9464858510882086, -0.0;
-0.8908731073870279, -0.0;
-0.831673132110512, -0.0;
-0.7691243026648369, -0.0;
-0.7034784811099599, -0.0;
-0.635, -0.0;
-0.5639645980093334, -0.0;
-0.49065830963027324, -0.0;
-0.41537631341312553, -0.0;
-0.33842174338634473, -0.0;
-0.26010446844279206, -0.0;
-0.18073984460707224, -0.0;
-0.10064744520812169, -0.0;
-0.02014977407020664, -0.0;
0.06042903309615317, 0.0;
0.1407645138742842, 0.0;
0.22053318563700153, 0.0;
0.29941384809697236, 0.0;
0.37708887666690866, 0.0;
0.45324550142167774, 0.0;
0.5275770665123961, 0.0;
0.5997842649613071, 0.0;
0.669576343865338, 0.0;
0.7366722751554213, 0.0;
0.8008018871973431, 0.0;
0.8617069526775581, 0.0;
0.9191422283934393, 0.0;
0.9728764427611021, 0.0;
1.0226932270644444, 0.0;
1.0683919866955998, 0.0;
1.1097887088786271, 0.0;
1.1467167036240091, 0.0;
1.1790272749304123, 0.0;
1.2065903195310006, 0.0;
1.2292948507733725, 0.0;
1.2470494455236374, 0.0;
1.2597826122951101, 0.0;
1.2674430791192932, 0.0;
1.27, 0.0;
1.27, 0.0;
1.2674430791192932, 0.0;
1.2597826122951101, 0.0;
1.2470494455236376, 0.0;
1.2292948507733725, 0.0;
1.2065903195310006, 0.0;
1.1790272749304123, 0.0;
1.1467167036240091, 0.0;
1.109788708878627, 0.0;
1.0683919866956002, 0.0;
1.0226932270644444, 0.0;
0.9728764427611021, 0.0;
0.9191422283934392, 0.0;
0.8617069526775579, 0.0;
0.8008018871973436, 0.0;
0.7366722751554217, 0.0;
0.6695763438653382, 0.0;
0.599784264961307, 0.0;
0.5275770665123958, 0.0;
0.4532455014216772, 0.0;
0.37708887666690893, 0.0;
0.29941384809697263, 0.0;
0.22053318563700153, 0.0;
0.1407645138742839, 0.0;
0.060429033096152864, 0.0;
-0.02014977407020601, -0.0;
-0.10064744520812137, -0.0;
-0.18073984460707224, -0.0;
-0.26010446844279206, -0.0;
-0.33842174338634445, -0.0;
-0.41537631341312553, -0.0;
-0.4906583096302735, -0.0;
-0.5639645980093331, -0.0;
-0.635, -0.0;
-0.70347848110996, -0.0;
-0.7691243026648366, -0.0;
-0.831673132110512, -0.0;
-0.8908731073870279, -0.0;
-0.9464858510882086, -0.0;
-0.99828743032334, -0.0;
-1.0460692584158877, -0.0;
-1.0896389348084208, -0.0;
-1.1288210197917528, -0.0;
-1.1634577409387286, -0.0;
-1.1934096283981037, -0.0;
-1.2185560764904118, -0.0;
-1.238795829344467, -0.0;
-1.2540473886190207, -0.0;
-1.2642493416678175, -0.0;
-1.2693606088266451, -0.0;
-1.2693606088266451, -0.0;
-1.2642493416678175, -0.0;
-1.2540473886190207, -0.0;
-1.238795829344467, -0.0;
-1.2185560764904118, -0.0;
-1.1934096283981037, -0.0;
-1.1634577409387286, -0.0;
-1.1288210197917528, -0.0;
-1.0896389348084208, -0.0;
-1.0460692584158877, -0.0;
-0.99828743032334, -0.0;
-0.9464858510882086, -0.0;
-0.8908731073870279, -0.0;
-0.831673132110512, -0.0;
-0.7691243026648369, -0.0;
-0.7034784811099599, -0.0;
-0.635, -0.0;
-0.5639645980093334, -0.0;
-0.49065830963027324, -0.0;
-0.41537631341312553, -0.0;
-0.33842174338634473, -0.0;
-0.26010446844279206, -0.0;
-0.18073984460707224, -0.0;
-0.10064744520812169, -0.0;
-0.02014977407020664, -0.0;
0.06042903309615317, 0.0;
0.1407645138742842, 0.0;
0.22053318563700153, 0.0;
0.29941384809697236, 0.0;
0.37708887666690866, 0.0;
0.45324550142167774, 0.0;
0.5275770665123961, 0.0;
0.5997842649613071, 0.0;
0.669576343865338, 0.0;
0.7366722751554213, 0.0;
0.8008018871973431, 0.0;
0.8617069526775581, 0.0;
0.9191422283934393, 0.0;
0.9728764427611021, 0.0;
1.0226932270644444, 0.0;
1.0683919866955998, 0.0;
1.1097887088786271, 0.0;
1.1467167036240091, 0.0;
1.1790272749304123, 0.0;
1.2065903195310006, 0.0;
1.2292948507733725, 0.0;
1.2470494455236374, 0.0;
1.2597826122951101, 0.0;
1.2674430791192932, 0.0;
1.27, 0.0
## end
#4581, 2:
网格
## end
#4582, 6:
0,90,0
## end
#4584, 5:
0,0,0
## end
#4588, 3:
圆柱体
## end
#4592, 4:
2.54
## end
#4596, 4:
12.7
## end
#4599, 797:
地址::文档\模拟\Smilei\code\run.py
数据地址::文档\\模拟\\Smilei\\code
+[提取Smilei数据]"Rho"(数据地址,)
+[提取Smilei数据]"Jy"(数据地址,)
+[提取Smilei数据]"Ey"(数据地址,)
+[打开](,数据地址)

+[生成Smilei代码_结构](模拟场景,)
保存代码:...

参考波长::800e-9
有模拟空间, 窗口, 电子和光束
有探测场
探测场有探测类型和探测间隔
探测场的探测类型是"'Rho','Jy','Ey'"
探测场的探测间隔是"100"

模拟空间和窗口都是长方形(80e-6,80e-6)

窗口有启动时间
窗口的启动时间是"250e-15"

电子有数密度, gamma, beta_r和延时函数
电子在(40e-6,-50e-6)
电子的gamma是"2.5"
电子的beta_r是(0,1,0)
电子的数密度是"1e24"

光束有腰宽, 展宽, 焦点位置, a0和偏振态
光束的展宽是"100e-15"
光束的腰宽是"30e-6"
光束的a0是"0.01"
光束的偏振态是(1,1i)
光束的焦点位置是A

A::
A在(40e-6,0)

电子的数密度是fx
电子的延时函数是ft
fx:...
ft:...
将"\eqs{\Delta x=2*10^{-6};
n_0=10^{22};
n=n_0*exp(-x^2/\Delta x^2)}"记作为fx
将"\eqs{\Delta t=50*10^{-15};
f=exp(-t^2/\Delta t^2)}"记作为ft
显示ft


预览动画:...
+[删除结构](,预览动画)->+[召唤星辰](模拟场景,预览动画)
的(预览动画,输出代码)->+[M函数](,输出代码)


+[显示PPT场景]"1"(,模拟场景)
## end
#4610, 6:
800e-9
## end
#4611, 28:
-4e-05, 4e-05, 4e-05, -4e-05
## end
#4613, 22:
0.0, 0.0, 8e-05, 8e-05
## end
#4615, 8:
0.0, 0.0
## end
#4617, 5:
8e-05
## end
#4619, 5:
8e-05
## end
#4621, 3:
多边形
## end
#4622, 3:
长方形
## end
#4624, 28:
-4e-05, 4e-05, 4e-05, -4e-05
## end
#4626, 22:
0.0, 0.0, 8e-05, 8e-05
## end
#4628, 8:
0.0, 0.0
## end
#4630, 5:
8e-05
## end
#4632, 5:
8e-05
## end
#4634, 3:
多边形
## end
#4635, 3:
长方形
## end
#4637, 7:
250e-15
## end
#4639, 4:
1e24
## end
#4641, 3:
2.5
## end
#4643, 5:
0,1,0
## end
#4647, 12:
40e-6,-50e-6
## end
#4649, 5:
30e-6
## end
#4651, 7:
100e-15
## end
#4655, 4:
0.01
## end
#4657, 4:
1,1i
## end
#4661, 7:
40e-6,0
## end
#4664, 71:
+[设置结构](,预览动画)
召唤规则:...
降临规则:...
+[新建阅读窗口](,降临规则)


代码结构:...
输出代码:...


## end
#4665, 154:
w_z2=w_02.*sqrt(1+((c*t(i)+pt1(1)-focus2(1))./(z_R2)).^(2));

h2.Position(1)=c*t(i)+pt1(1)-c*tau2;
h2.Position(2)=focus2(2)-w_z2/2;
h2.Position(4)=w_z2;


## end
#4666, 191:
patch([z,fliplr(z)],focus2(2)+[w2/2,-fliplr(w2)/2],[1,0,0],'FaceAlpha',0.2)
h2=rectangle('Position',[pt1(1)-c*tau2,pt1(2)-w2(1)/2,c*tau2,w2(1)],'Curvature',[1,1],'FaceColor',[1,0.5,0,0.8]);


## end
#4667, 166:
tau2=100e-15*2.5;
focus2=[40e-6,0];
w_02=2e-6;
% Gaussian beam
z_R2=w_02^2*pi/lm_0;
z=linspace(pt0(1),pt0(1)+W0,100);
w2=w_02.*sqrt(1+((z-focus2(1))./(z_R2)).^(2));


## end
#4668, 1:
3
## end
#4670, 120:
x3=pt_e3(1)+v3(1)*t(i);
y3=pt_e3(2)+v3(2)*t(i);
h_p3.XData=x3;
h_p3.YData=y3;
h_t3.Position(1)=x3;
h_t3.Position(2)=y3;

## end
#4671, 156:
h_p3=plot(pt_e3(1),pt_e3(2),'r*');
h_t3=text(pt_e3(1),pt_e3(2),'electron3');
plot([pt_e3(1),pt_e3(1)+v3(1)*t(end)],[pt_e3(2),pt_e3(2)+v3(2)*t(end)],'k--');

## end
#4672, 76:
v3=[0.0, 0.916515138991168, 0.0]*c;
v_n3=v3/norm(v3);
pt_e3=[40e-6,-50e-6];

## end
#4674, 2426:
"""
保存:...
list_field::https://smileipic.github.io/Smilei/namelist.html#fields-diagnostics
+[打开网页](,list_field)

"""
import numpy as np

dt = 0.12375
nx = 4992.0
Lx = 624.0
Ly = 628.3185307179587
npatch_x = 128.0

Main(
    geometry = "2Dcartesian",
    
    interpolation_order = 2,

    timestep = dt,
    simulation_time = int(4756.695877042559)*dt,

    cell_length  = [0.125, 15.707963267948966],
    grid_length = [Lx, Ly],

    number_of_patches = [npatch_x, 1],

    cluster_width = nx/npatch_x,
    
    EM_boundary_conditions = [
        ["silver-muller","silver-muller"],
        ["silver-muller","silver-muller"],
#        ["periodic", "periodic"],
    ],
    
    solve_poisson = False,
    print_every = 200,

    random_seed = smilei_mpi_rank
)

LoadBalancing(
    initial_balance = False,
    every = 150,
    cell_load = 1.,
    frozen_particle_load = 0.1
)

def n1_profile(x,y):
    x=x*1.2732395447351627e-07+(0.0)-(4e-05)
    y=(y-Ly/2)*1.2732395447351627e-07+(0.0)-(-5e-05)
    n=0.
    Delta_x=2*10**(-6)
    n_0=10**(22)
    n=n_0*np.exp(-x**(2)/Delta_x**(2))
    
    
    n=n/1.741446424138715e+27
    return n

def ft1_profile(t):
    t=t*4.247069967100916e-16-(3.639482655630923e-14)
    f=1
    Delta_t=50*10**(-15)
    f=np.exp(-t**(2)/Delta_t**(2))
    
    
    return f

Species(
    name = "electron1",
    position_initialization = "random",
    momentum_initialization = "cold",
    particles_per_cell = 1,
    c_part_max = 1.0,
    mass = 1.0,
    charge = -1.0,
    number_density = 0., 

    mean_velocity = [0.0, 0.916515138991168, 0.0],
    temperature = [0.0],
    pusher = "boris",
    time_frozen = 0.0,
    boundary_conditions = [
        ["remove", "remove"],
        ["remove", "remove"],
    ],
)

ParticleInjector(
    species   = "electron1",
    box_side  = "ymin",
    time_envelope = ft1_profile,
    number_density = n1_profile, 
)



LaserGaussian2D(
    box_side         = "xmin",
    a0               = 1.0,
    omega            = 1.0,
    focus            = [314.1592653589793, 314.1592653589793],
    waist            = 235.61944901923448,
    polarization_phi = 0.7853981633974484,
    ellipticity      = -1.0,
    time_envelope    = tgaussian(start=0.0, duration=235.45644591360667*4., fwhm=235.45644591360667, center=235.45644591360667*2., order=2.0, )
)





DiagFields(
    fields = ['Rho','Jy','Ey'],
    every = 100,
)




DiagPerformances(
    every = 50,
)



## end
#4676, 68:
Delta_x=2*10**(-6)
n_0=10**(22)
n=n_0*np.exp(-x**(2)/Delta_x**(2))


## end
#4678, 53:
Delta_t=50*10**(-15)
f=np.exp(-t**(2)/Delta_t**(2))


## end
#4679, 4:
4712
## end
#4683, 15:
'Rho','Jy','Ey'
## end
#4685, 3:
100
## end
#4687, 3:
100
## end
#4689, 65:
\eqs{\Delta x=2*10^{-6};
n_0=10^{22};
n=n_0*exp(-x^2/\Delta x^2)}
## end
#4693, 20:
文档\\模拟\\Smilei\\code
## end
#4694, 50:
\eqs{\Delta t=50*10^{-15};
f=exp(-t^2/\Delta t^2)}
## end
#4697, 4:
4761
## end
#4700, 793:
+[显示PPT场景](,水管图)

有outer, inner, TSFV和HeatEx

在屏幕, 添加标记点
有A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11和A12

A1在(0.5,1)
A2距离A1为(0,0.5)
A3距离A2为(0.8,0)
A4距离A3为(0,-0.3)
A5距离A4为(0.3,0)
A6距离A5为(0,-0.1)
A7距离A6为(-0.6,0)
A8距离A7为(0,-0.2)
A9距离A8为(0.3,0)
A10距离A9为(0,-0.5)
A11距离A10为(-0.8,0)
A12距离A11为(0,0.3)

outer经过A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11和A12
outer是折线

有B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11和B12

B1在(2.5,1)
B2距离B1为(0,0.5)
B3距离A3为(0.1,0)
B4距离A4为(0.1,0.05)
B5距离A5为(0.05,0.05)
B6距离A6为(0.05,-0.05)
B7距离A7为(0.05,-0.05)
B8距离A8为(0.05,0.05)
B9距离A9为(0.1,0.05)
B10距离A10为(0.1,0)
B12距离B1为(0,-0.3)
B11距离B12为(0,-0.3)

inner经过B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11和B12
inner是折线

A10, A11, A12, A1, A2和A3都平移(0,0.3)
B10, B11, B12, B1, B2和B3都平移(0,0.3)

axis([0,2,0,2])
+[显示PPT场景]"1"(,水管图)
## end
#4734, 5:
0.5,1
## end
#4736, 8:
0.5, 1.5
## end
#4738, 8:
1.3, 1.5
## end
#4740, 8:
1.3, 1.2
## end
#4742, 8:
1.6, 1.2
## end
#4744, 23:
1.6, 1.0999999999999999
## end
#4746, 23:
1.0, 1.0999999999999999
## end
#4748, 23:
1.0, 0.8999999999999999
## end
#4750, 23:
1.3, 0.8999999999999999
## end
#4752, 23:
1.3, 0.3999999999999999
## end
#4754, 23:
0.5, 0.3999999999999999
## end
#4756, 8:
0.5, 0.7
## end
#4782, 2:
曲线
## end
#4783, 148:
0.7, 0.3999999999999999, 0.3999999999999999, 0.8999999999999999, 0.8999999999999999, 1.0999999999999999, 1.0999999999999999, 1.2, 1.2, 1.5, 1.5, 1.0
## end
#4785, 58:
0.5, 0.5, 1.3, 1.3, 1.0, 1.0, 1.6, 1.6, 1.3, 1.3, 0.5, 0.5
## end
#4787, 2:
折线
## end
#4813, 5:
2.5,1
## end
#4815, 8:
2.5, 1.5
## end
#4817, 23:
1.4000000000000001, 1.5
## end
#4819, 24:
1.4000000000000001, 1.25
## end
#4821, 24:
1.6500000000000001, 1.25
## end
#4823, 38:
1.6500000000000001, 1.0499999999999998
## end
#4825, 24:
1.05, 1.0499999999999998
## end
#4827, 10:
1.05, 0.95
## end
#4829, 24:
1.4000000000000001, 0.95
## end
#4831, 38:
1.4000000000000001, 0.3999999999999999
## end
#4833, 24:
2.5, 0.39999999999999997
## end
#4835, 8:
2.5, 0.7
## end
#4861, 2:
曲线
## end
#4862, 123:
0.7, 0.39999999999999997, 0.3999999999999999, 0.95, 0.95, 1.0499999999999998, 1.0499999999999998, 1.25, 1.25, 1.5, 1.5, 1.0
## end
#4864, 150:
2.5, 2.5, 1.4000000000000001, 1.4000000000000001, 1.05, 1.05, 1.6500000000000001, 1.6500000000000001, 1.4000000000000001, 1.4000000000000001, 2.5, 2.5
## end
#4866, 2:
折线
## end
#4869, 1421:
+[显示PPT场景](,外部水管)
有线路1和线路2

axis([0,20,0,10])
在屏幕"1", 添加标记点

有A1, A2, A3和A4
A1在(6,8)
A2距离A1为(14,0)
A3距离A2为(0,-1)
A4距离A3为(-15,0)


有B1, B2, B3, B4, B5和B6
B1在(2,8)
B6距离B1为(1,-1)
B2距离B1为(0,-8)
B5距离B2为(1,1)
B3距离B2为(18,0)
B4距离B3为(0,1)

线路1经过A1, A2, A3和A4
线路2经过A1, B1, B2, B3, B4, B5, B6和A4
线路1和线路2都是折线



有线路3和线路4
有C1, C2, C3, C4, C5和C6
C1距离B5为(5,0)
C6距离C1为(0.4,-1)
C2距离C1为(0,0.4)
C5距离C2为(0.4,0.2)
C3距离C2为(-2,0)
C4距离C3为(0,0.2)

有D1, D2, D3, D4, D5和D6
D1距离B5为(15,0)
D6距离D1为(0.4,-1)
D2距离D1为(0,0.4)
D2距离D1为(0,2)
D5距离D2为(0.4,0.2)
D3距离D2为(-2,0)
D4距离D3为(0,0.2)

线路3经过C1, C2, C3, C4, C5和C6
线路4经过D1, D2, D3, D4, D5和D6
线路3和线路4都是折线
线路4是折线

线路0::
有E1和E2
E1距离A1为(0,0.5)
E2距离E1为(-1,0)
线路0经过A1, E1, E2和A4
线路0是折线

+[PPT场景输出]"文档\S应用\草稿\output.pptx"(外部水管,)
+[打开]"文档\S应用\草稿\output.pptx"

有PS140, room1, room2, 走廊1和走廊2
PS140是长方形(20,8)
PS140在(0,2.5)


B2距离B1为(0,-11)
B5距离B2为(1,1)
B3距离B2为(18,0)
B4距离B3为(0,1)
线路2是折线

线路1经过A1, A2, A3和A4
线路2经过A1, B1, B2, B3, B4, B5, B6和A4
线路1和线路2都是折线

走廊1和走廊2都是长方形(25,3)
走廊1距离PS140为(-2.5,-5.5)
走廊2距离PS140为(-2.5,5.5)

C1距离B5为(5,0)
C6距离C1为(0.4,-1)
C2距离C1为(0,1.4)
C5距离C2为(0.4,0.2)
C3距离C2为(-2,0)
C4距离C3为(0,0.2)
线路3是折线

D1距离B5为(15,0)
D6距离D1为(0.4,-1)
D2距离D1为(0,1.4)
D5距离D2为(0.4,0.2)
D3距离D2为(-2,0)
D4距离D3为(0,0.2)
线路4是折线

room1和room2都是长方形(3.5,1.2)
room1距离C3为(-0.5,-0.1)
room2距离D3为(-0.5,-0.1)


axis([-5,30,-5,15])
Nini, 打开PPT(文件)



+[PPT场景输出]"文档\S应用\草稿\output.pptx"(外部水管,)
+[打开]"文档\S应用\草稿\output.pptx"

+[显示PPT场景]"1"(,外部水管)
## end
#4884, 3:
6,8
## end
#4886, 9:
20.0, 8.0
## end
#4888, 9:
20.0, 7.0
## end
#4890, 8:
5.0, 7.0
## end
#4892, 4:
5095
## end
#4906, 3:
2,8
## end
#4908, 8:
3.0, 7.0
## end
#4910, 9:
2.0, -3.0
## end
#4912, 9:
3.0, -2.0
## end
#4914, 10:
20.0, -3.0
## end
#4916, 10:
20.0, -2.0
## end
#4946, 9:
8.0, -2.0
## end
#4948, 9:
8.4, -3.0
## end
#4950, 24:
8.0, -0.6000000000000001
## end
#4952, 24:
8.4, -0.4000000000000001
## end
#4954, 24:
6.0, -0.6000000000000001
## end
#4956, 24:
6.0, -0.4000000000000001
## end
#4958, 10:
18.0, -2.0
## end
#4960, 10:
18.4, -3.0
## end
#4962, 25:
18.0, -0.6000000000000001
## end
#4964, 25:
18.4, -0.4000000000000001
## end
#4966, 25:
16.0, -0.6000000000000001
## end
#4968, 25:
16.0, -0.4000000000000001
## end
#5018, 2:
曲线
## end
#5019, 18:
7.0, 7.0, 8.0, 8.0
## end
#5021, 20:
5.0, 20.0, 20.0, 6.0
## end
#5023, 2:
折线
## end
#5025, 2:
曲线
## end
#5026, 42:
7.0, 7.0, -2.0, -2.0, -3.0, -3.0, 8.0, 8.0
## end
#5028, 40:
5.0, 3.0, 3.0, 20.0, 20.0, 2.0, 2.0, 6.0
## end
#5030, 2:
折线
## end
#5056, 2:
曲线
## end
#5057, 94:
-3.0, -0.4000000000000001, -0.4000000000000001, -0.6000000000000001, -0.6000000000000001, -2.0
## end
#5059, 28:
8.4, 8.4, 6.0, 6.0, 8.0, 8.0
## end
#5061, 2:
折线
## end
#5063, 2:
曲线
## end
#5064, 94:
-3.0, -0.4000000000000001, -0.4000000000000001, -0.6000000000000001, -0.6000000000000001, -2.0
## end
#5066, 34:
18.4, 18.4, 16.0, 16.0, 18.0, 18.0
## end
#5068, 2:
折线
## end
#5076, 8:
6.0, 8.5
## end
#5078, 8:
5.0, 8.5
## end
#5088, 2:
曲线
## end
#5089, 18:
7.0, 8.5, 8.5, 8.0
## end
#5091, 18:
5.0, 5.0, 6.0, 6.0
## end
#5093, 2:
折线
## end
#5097, 3:
多边形
## end
#5099, 3:
多边形
## end
#5105, 20:
-4.0, 4.0, 4.0, -4.0
## end
#5107, 20:
0.0, 0.0, 20.0, 20.0
## end
#5109, 5:
0,2.5
## end
#5111, 4:
20.0
## end
#5113, 3:
8.0
## end
#5115, 3:
多边形
## end
#5116, 3:
长方形
## end
#5118, 20:
-1.5, 1.5, 1.5, -1.5
## end
#5120, 20:
0.0, 0.0, 25.0, 25.0
## end
#5122, 10:
-2.5, -3.0
## end
#5124, 4:
25.0
## end
#5126, 3:
3.0
## end
#5128, 3:
多边形
## end
#5129, 3:
长方形
## end
#5131, 20:
-1.5, 1.5, 1.5, -1.5
## end
#5133, 20:
0.0, 0.0, 25.0, 25.0
## end
#5135, 9:
-2.5, 8.0
## end
#5137, 4:
25.0
## end
#5139, 3:
3.0
## end
#5141, 3:
多边形
## end
#5142, 3:
长方形
## end
#5144, 20:
-0.6, 0.6, 0.6, -0.6
## end
#5146, 18:
0.0, 0.0, 3.5, 3.5
## end
#5148, 24:
5.5, -0.7000000000000001
## end
#5150, 3:
3.5
## end
#5152, 3:
1.2
## end
#5154, 3:
多边形
## end
#5155, 3:
长方形
## end
#5157, 20:
-0.6, 0.6, 0.6, -0.6
## end
#5159, 18:
0.0, 0.0, 3.5, 3.5
## end
#5161, 25:
15.5, -0.7000000000000001
## end
#5163, 3:
3.5
## end
#5165, 3:
1.2
## end
#5167, 3:
多边形
## end
#5168, 3:
长方形
## end
### 结束