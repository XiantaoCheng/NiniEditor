### 节点
地址, 的, 透镜焦距, 目录, 的, 的, 网页画板, 的, 形状与焦距, html, 的, 透镜原理图, 的, 节点数目统计, 20210705, 的, 的, 几何画板, 20210706, 的, 的, 星图, 的, 的, 的, 的, 的, 的, 的, 经过, 经过, 参考线, 焦点, 中心, 圆心, 圆弧, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 于, 相交, 光线, 出, 的, 反射点, 于, 反射, 水平, 光线, 上面, 的, 的, 的, 的, 的, 的, 的, 的, 的, 于, 相交, 出, 的, 反射点, 于, 反射, 水平, 下面, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, HTML, 的, 选中区域, 的, 的, 输入, 的, 的, 输出, 类型, 画图, 的, 的, 的, 的, 图形, 选中框, 输出, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 线粗细, 线型, 线颜色, 面颜色, 角度, 半径, 中心, 起始角度, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 比例, 的, 尺寸, 的, 原点, 的, 坐标系, 20210707, 的, 的, 动词, 的, 经过, 的, 名词, 的, 点, 的, 计算圆弧中心, M函数, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 矩形, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, HTML, 的, 的, 输出, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 面颜色, 线颜色, 线型, 线粗细, 文字, 字体, 起点, 尺寸, 尺寸, 起点, 字体, 文字, 线粗细, 线型, 线颜色, 面颜色, 的, 的, 的, 的, 的, 的, 的, 的, 输入, 输出, 的, 的, HTML, 输出, 的, 的, 选中区域, 类型, 图形, 选中框, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 矩形, 的, 面颜色, 线颜色, 线型, 线粗细, 文字, 字体, 尺寸, 起点, 的, 的, 的, 的, 的, 的, 的, 的, 输入, 输出, 选中框, 图形, 的, 的, 的, 的, 画图, 类型, 输出, 的, 的, 选中区域, 输出, 的, 的, HTML, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 矩形, 的, 直线, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 面颜色, 线颜色, 线型, 线粗细, 文字, 字体, 尺寸, 起点, 的, 的, 的, 的, 的, 的, 的, 的, 输入, 输出, 选中框, 图形, 的, 的, 的, 的, 画图, 类型, 输出, 的, 的, 选中区域, 输出, 的, 的, HTML, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 矩形, 的, 尺寸, 起点, 字体, 文字, 线粗细, 线型, 线颜色, 面颜色, 的, 的, 的, 的, 的, 的, 的, 的, 输入, 输出, 的, 的, HTML, 输出, 的, 的, 选中区域, 类型, 图形, 选中框, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 矩形, 的, 直线, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 的, 抛物线, 起始角度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 的, 的, 的, 的, 的, 的, 的, 的, 输入, 输出, 选中框, 图形, 的, 的, 的, 的, 画图, 类型, 输出, 的, 的, 输入, 的, 的, 选中区域, 的, HTML, 反射点, 反射点, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 圆心, 中心, 焦点, 圆弧, 的, 线型, 线粗细, 线颜色, 终点, 起点, 的, 的, 的, 的, 的, 输入, 的, HTML, LaTeX数学记号, 的, 点线公式, 输出, 的, 的, 输入, 的, 的, 的, 选中区域, 类型, 选中框, 图形, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 参考线, 的, 线型, 线粗细, 线颜色, 终点, 起点, 的, 的, 的, 的, 的, 输入, 的, HTML, LaTeX数学记号, 的, 点线公式, 输出, 的, 的, 输入, 的, 的, 的, 选中区域, 类型, 选中框, 图形, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 直线, 的, 线型, 线粗细, 线颜色, 终点, 起点, 的, 的, 的, 的, 的, 输入, 的, HTML, LaTeX数学记号, 的, 点线公式, 输出, 的, 的, 输入, 的, 的, 的, 选中区域, 类型, 选中框, 图形, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 水平, 光线, 的, 线型, 线粗细, 线颜色, 终点, 起点, 的, 的, 的, 的, 的, 输入, 的, HTML, LaTeX数学记号, 的, 点线公式, 输出, 的, 的, 输入, 的, 的, 的, 选中区域, 类型, 选中框, 图形, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 光线, 的, 面颜色, 线颜色, 线型, 线粗细, 文字, 字体, 尺寸, 起点, 的, 的, 的, 的, 的, 的, 的, 的, 输入, 输出, 选中框, 图形, 的, 的, 的, 的, 画图, 类型, 输出, 的, 的, 选中区域, 输出, 的, 的, HTML, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 矩形, 的, 尺寸, 起点, 字体, 文字, 线粗细, 线型, 线颜色, 面颜色, 的, 的, 的, 的, 的, 的, 的, 的, 输入, 输出, 的, 的, HTML, 输出, 的, 的, 选中区域, 类型, 图形, 选中框, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 矩形, 的, 尺寸, 起点, 字体, 文字, 线粗细, 线型, 线颜色, 面颜色, 的, 的, 的, 的, 的, 的, 的, 的, 输入, 输出, 的, 的, HTML, 输出, 的, 的, 选中区域, 类型, 图形, 选中框, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 矩形, 的, 尺寸, 起点, 字体, 文字, 线粗细, 线型, 线颜色, 面颜色, 的, 的, 的, 的, 的, 的, 的, 的, 输入, 输出, 的, 的, HTML, 输出, 的, 的, 选中区域, 类型, 图形, 选中框, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 矩形, 的, 线型, 线粗细, 线颜色, 终点, 起点, 的, 的, 的, 的, 的, 输入, 的, HTML, LaTeX数学记号, 的, 点线公式, 输出, 的, 的, 输入, 的, 的, 的, 选中区域, 类型, 选中框, 图形, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 直线, 的, 面颜色, 线颜色, 线型, 线粗细, 文字, 字体, 尺寸, 起点, 的, 的, 的, 的, 的, 的, 的, 的, 输入, 输出, 选中框, 图形, 的, 的, 的, 的, 画图, 类型, 输出, 的, 的, 选中区域, 输出, 的, 的, HTML, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 矩形, 的, 尺寸, 起点, 字体, 文字, 线粗细, 线型, 线颜色, 面颜色, 的, 的, 的, 的, 的, 的, 的, 的, 输入, 输出, 的, 的, HTML, 输出, 的, 的, 选中区域, 类型, 图形, 选中框, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 矩形, 起点, 终点, 线颜色, 线型, 线粗细, 的, 的, 的, 的, 的, 输入, 输出, 图形, 选中框, 的, 的, 的, 的, 画图, 类型, 的, 的, 输入, 输出, LaTeX数学记号, 的, 点线公式, 的, 的, 的, 选中区域, 的, HTML, 的, 的, 的, 的, 的, 的, 的, 的, 的, 直线, 面颜色, 线颜色, 线型, 线粗细, 文字, 字体, 尺寸, 起点, 的, 的, 的, 的, 的, 的, 的, 的, 输入, 输出, 选中框, 图形, 的, 的, 的, 的, 画图, 类型, 输出, 的, 的, 选中区域, 输出, 的, 的, HTML, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 矩形, 面颜色, 线颜色, 线型, 线粗细, 文字, 字体, 尺寸, 起点, 的, 的, 的, 的, 的, 的, 的, 的, 输入, 输出, 选中框, 图形, 的, 的, 的, 的, 画图, 类型, 输出, 的, 的, 选中区域, 输出, 的, 的, HTML, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 矩形, 面颜色, 线颜色, 线型, 线粗细, 文字, 字体, 尺寸, 起点, 的, 的, 的, 的, 的, 的, 的, 的, 输入, 输出, 选中框, 图形, 的, 的, 的, 的, 画图, 类型, 输出, 的, 的, 选中区域, 输出, 的, 的, HTML, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 矩形, 尺寸, 起点, 字体, 文字, 线粗细, 线型, 线颜色, 面颜色, 的, 的, 的, 的, 的, 的, 的, 的, 输入, 输出, 的, 的, HTML, 输出, 的, 的, 选中区域, 类型, 图形, 选中框, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 矩形, 线型, 线粗细, 线颜色, 终点, 起点, 的, 的, 的, 的, 的, 输入, 的, HTML, LaTeX数学记号, 的, 点线公式, 输出, 的, 的, 输入, 的, 的, 的, 选中区域, 类型, 选中框, 图形, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 光线, 起点, 终点, 线颜色, 线型, 线粗细, 的, 的, 的, 的, 的, 输入, 输出, 图形, 选中框, 的, 的, 的, 的, 画图, 类型, 的, 的, 输入, 输出, LaTeX数学记号, 的, 点线公式, 的, 的, 的, 选中区域, 的, HTML, 的, 的, 的, 的, 的, 的, 的, 的, 的, 光线, 起点, 终点, 线颜色, 线型, 线粗细, 的, 的, 的, 的, 的, 输入, 输出, 图形, 选中框, 的, 的, 的, 的, 画图, 类型, 的, 的, 输入, 输出, LaTeX数学记号, 的, 点线公式, 的, 的, 的, 选中区域, 的, HTML, 水平, 的, 的, 的, 的, 的, 的, 的, 的, 的, 光线, 起点, 终点, 线颜色, 线型, 线粗细, 的, 的, 的, 的, 的, 输入, 输出, 图形, 选中框, 的, 的, 的, 的, 画图, 类型, 的, 的, 输入, 输出, LaTeX数学记号, 的, 点线公式, 的, 的, 的, 选中区域, 的, HTML, 的, 的, 的, 的, 的, 的, 的, 的, 的, 直线, 起点, 终点, 线颜色, 线型, 线粗细, 的, 的, 的, 的, 的, 输入, 输出, 图形, 选中框, 的, 的, 的, 的, 画图, 类型, 的, 的, 输入, 输出, LaTeX数学记号, 的, 点线公式, 的, 的, 的, 选中区域, 的, HTML, 的, 的, 的, 的, 的, 的, 的, 的, 的, 参考线, 反射点, 反射点, 线粗细, 线型, 线颜色, 面颜色, 角度, 半径, 中心, 起始角度, 的, 的, 的, 的, 的, 的, 的, 的, 输入, 的, HTML, 的, 的, 输入, 输出, 的, 的, 选中区域, 类型, 图形, 选中框, 输出, 的, 的, 的, 的, 画图, 焦点, 中心, 圆心, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 圆弧, 线型, 线粗细, 线颜色, 终点, 起点, 的, 的, 的, 的, 的, 输入, 的, HTML, LaTeX数学记号, 的, 点线公式, 输出, 的, 的, 输入, 的, 的, 的, 选中区域, 类型, 选中框, 图形, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 直线, 面颜色, 线颜色, 线型, 线粗细, 文字, 字体, 尺寸, 起点, 的, 的, 的, 的, 的, 的, 的, 的, 输入, 输出, 选中框, 图形, 的, 的, 的, 的, 画图, 类型, 输出, 的, 的, 选中区域, 输出, 的, 的, HTML, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 矩形, 尺寸, 起点, 字体, 文字, 线粗细, 线型, 线颜色, 面颜色, 的, 的, 的, 的, 的, 的, 的, 的, 输入, 输出, 的, 的, HTML, 输出, 的, 的, 选中区域, 类型, 图形, 选中框, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 矩形, 线型, 线粗细, 线颜色, 终点, 起点, 的, 的, 的, 的, 的, 输入, 的, HTML, LaTeX数学记号, 的, 点线公式, 输出, 的, 的, 输入, 的, 的, 的, 选中区域, 类型, 选中框, 图形, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 直线, 尺寸, 起点, 字体, 文字, 线粗细, 线型, 线颜色, 面颜色, 的, 的, 的, 的, 的, 的, 的, 的, 输入, 输出, 的, 的, HTML, 输出, 的, 的, 选中区域, 类型, 图形, 选中框, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 矩形, 面颜色, 线颜色, 线型, 线粗细, 文字, 字体, 尺寸, 起点, 的, 的, 的, 的, 的, 的, 的, 的, 输入, 输出, 选中框, 图形, 的, 的, 的, 的, 画图, 类型, 输出, 的, 的, 选中区域, 输出, 的, 的, HTML, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 矩形, 尺寸, 起点, 字体, 文字, 线粗细, 线型, 线颜色, 面颜色, 的, 的, 的, 的, 的, 的, 的, 的, 输入, 输出, 的, 的, HTML, 输出, 的, 的, 选中区域, 类型, 图形, 选中框, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 矩形, 下面, 线型, 线粗细, 线颜色, 终点, 起点, 的, 的, 的, 的, 的, 输入, 的, HTML, LaTeX数学记号, 的, 点线公式, 输出, 的, 的, 输入, 的, 的, 的, 选中区域, 类型, 选中框, 图形, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 水平, 光线, 于, 出, 反射, 反射点, 的, 线型, 线粗细, 线颜色, 终点, 起点, 的, 的, 的, 的, 的, 输入, 的, HTML, LaTeX数学记号, 的, 点线公式, 输出, 的, 的, 输入, 的, 的, 的, 选中区域, 类型, 选中框, 图形, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 相交, 光线, 于, 上面, 线型, 线粗细, 线颜色, 终点, 起点, 的, 的, 的, 的, 的, 输入, 的, HTML, LaTeX数学记号, 的, 点线公式, 输出, 的, 的, 输入, 的, 的, 的, 选中区域, 类型, 选中框, 图形, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 水平, 光线, 于, 出, 反射, 反射点, 的, 线型, 线粗细, 线颜色, 终点, 起点, 的, 的, 的, 的, 的, 输入, 的, HTML, LaTeX数学记号, 的, 点线公式, 输出, 的, 的, 输入, 的, 的, 的, 选中区域, 类型, 选中框, 图形, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 相交, 光线, 于, 起始角度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 的, 的, 的, 的, 的, 的, 的, 的, 输入, 输出, 选中框, 图形, 的, 的, 的, 的, 画图, 类型, 输出, 的, 的, 输入, 的, 的, 选中区域, 的, HTML, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 圆心, 中心, 焦点, 圆弧, 线型, 线粗细, 线颜色, 终点, 起点, 的, 的, 的, 的, 的, 输入, 的, HTML, LaTeX数学记号, 的, 点线公式, 输出, 的, 的, 输入, 的, 的, 的, 选中区域, 类型, 选中框, 图形, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 经过, 经过, 参考线, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 坐标系, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 凹透镜原理图, 的, 线型, 线粗细, 线颜色, 终点, 起点, 的, 的, 的, 的, 的, 输入, 的, HTML, LaTeX数学记号, 的, 点线公式, 输出, 的, 的, 输入, 的, 的, 的, 选中区域, 类型, 选中框, 图形, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 光线, 的, 面颜色, 线颜色, 线型, 线粗细, 文字, 字体, 尺寸, 起点, 的, 的, 的, 的, 的, 的, 的, 的, 输入, 输出, 选中框, 图形, 的, 的, 的, 的, 画图, 类型, 输出, 的, 的, 选中区域, 输出, 的, 的, HTML, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 矩形, 的, 尺寸, 起点, 字体, 文字, 线粗细, 线型, 线颜色, 面颜色, 的, 的, 的, 的, 的, 的, 的, 的, 输入, 输出, 的, 的, HTML, 输出, 的, 的, 选中区域, 类型, 图形, 选中框, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 矩形, 的, 面颜色, 线颜色, 线型, 线粗细, 文字, 字体, 尺寸, 起点, 的, 的, 的, 的, 的, 的, 的, 的, 输入, 输出, 选中框, 图形, 的, 的, 的, 的, 画图, 类型, 输出, 的, 的, 选中区域, 输出, 的, 的, HTML, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 矩形, 的, 的, 传输矩阵, html, 20210708, 的, 的, 测试传输矩阵, M函数, 20211008, 的, 
### 关联
#, 2#0, #, #, 3#2, 2#6, #, 2#8, #, 8#, 8#11, #, 3#13, #, #, 13#14, 2#17, #, #, 13#18, 2#21, #, 11#29, 11#30, 11#31, 11#32, 11#33, 11#34, 11#35, 31#33, 31#34, #, 35#, 35#, 35#, #, 11#47, 11#48, 11#49, 11#50, 11#51, 11#52, 11#53, 11#54, 11#55, 11#56, 11#57, 48#32, 49#31, #, 54#49, 35#52, #, 54#52, 35#56, 56#, #, 31#56, 11#67, 11#68, 11#69, 11#70, 11#71, 11#72, 11#73, 11#74, 11#75, 68#32, #31, 73#, 35#71, #, 73#71, 35#, #, 31#, 35#88, 35#115, 35#116, 35#117, 35#118, 35#90, 35#119, 35#97, 35#98, 35#120, 35#121, 35#122, #, 88#106, #, 90#93, 90#96, #, 93#120, 93#121, #, #, #, 98#103, 98#104, 98#105, 98#106, #, #, #, #, 106#115, 106#116, 106#117, 106#118, 106#119, 106#120, 106#121, 106#122, #, #, #, #, #, #, #, #, 31#160, 31#161, 31#132, 31#140, 31#141, 31#162, 31#163, 31#152, 31#164, #, 132#154, 132#137, 132#138, 132#139, #, #, #, #, #, 141#145, 141#148, 141#149, #, 145#160, 145#161, #, #, 149#151, #, #, 152#154, #, 154#160, 154#161, 154#162, 154#164, 154#163, #, #, #, #, #, 56#202, 56#203, 56#174, 56#182, 56#183, 56#204, 56#205, 56#194, 56#206, #, 174#196, 174#179, 174#180, 174#181, #, #, #, #, #, 183#187, 183#190, 183#191, #, 187#202, 187#203, #, #, 191#193, #, #, 194#196, #, 196#202, 196#203, 196#204, 196#206, 196#205, #, #, #, #, #, #, 213#207, #, 213#209, #, 213#211, 11#, #, 13#214, 2#217, #, 217#219, #, 2#221, #, 221#223, #, 223#225, #, 225#, 49#264, 49#265, 49#236, 49#244, 49#245, 49#266, 49#267, 49#256, 49#268, #, 236#258, 236#241, 236#242, 236#243, #, #, #, #, #, 245#249, 245#252, 245#253, #, 249#264, 249#265, #, #, 253#255, #, #, 256#258, #, 258#264, 258#265, 258#266, 258#268, 258#267, #, #, #, #, #, #, 11#269, 269#283, 269#291, 269#313, 269#292, 269#309, 269#310, 269#311, 269#312, 269#314, 269#296, 269#315, 269#316, #, 283#300, 283#288, 283#289, 283#290, #, #, #, #, #, 292#295, 292#300, #, #, 296#299, 296#300, #, #, 300#309, 300#310, 300#311, 300#312, 300#313, 300#314, 300#316, 300#315, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, 333#318, 333#317, 333#319, 333#320, 333#321, 333#322, 333#323, 333#324, #, #, 337#333, 337#334, #, #, 341#333, 341#338, #, #, #, #, #, 350#343, 350#344, 350#345, 350#333, #, 363#317, 363#318, 363#337, 363#319, 363#321, 363#322, 363#323, 363#324, 363#341, 363#320, 363#342, 363#350, #, 11#363, #, #, #, #, #, #, #, #, 381#365, 381#366, 381#367, 381#368, 381#369, 381#370, 381#371, 381#372, #, #, #, #, 389#381, 389#382, 389#383, 389#384, #, #, #, 394#391, 394#381, #, #, 398#395, 398#381, #, 411#389, 411#390, 411#369, 411#394, 411#365, 411#366, 411#367, 411#368, 411#370, 411#398, 411#372, 411#371, #, 11#411, #, 11#413, 413#452, 413#453, 413#424, 413#432, 413#433, 413#454, 413#455, 413#444, 413#456, #, 424#446, 424#429, 424#430, 424#431, #, #, #, #, #, 433#437, 433#440, 433#441, #, 437#452, 437#453, #, #, 441#443, #, #, 444#446, #, 446#452, 446#453, 446#454, 446#456, 446#455, #, #, #, #, #, #, #, #, #, #, #, #, #, 473#457, 473#458, 473#459, 473#460, 473#461, 473#462, 473#463, 473#464, #, #, #, #, 481#473, 481#474, 481#475, 481#476, #, #, #, 486#483, 486#473, #, #, 490#487, 490#473, #, 503#481, 503#482, 503#461, 503#486, 503#457, 503#458, 503#459, 503#460, 503#462, 503#490, 503#464, 503#463, #, 11#503, #, #, #, #, #, #, #, #, 521#506, 521#505, 521#507, 521#508, 521#509, 521#510, 521#511, 521#512, #, #, 525#521, 525#522, #, #, 529#521, 529#526, #, #, #, #, #, 538#531, 538#532, 538#533, 538#521, #, 551#505, 551#506, 551#525, 551#507, 551#509, 551#510, 551#511, 551#512, 551#529, 551#508, 551#530, 551#538, #, 11#551, #, 11#553, 553#592, 553#593, 553#564, 553#572, 553#573, 553#594, 553#595, 553#584, 553#596, #, 564#586, 564#569, 564#570, 564#571, #, #, #, #, #, 573#577, 573#580, 573#581, #, 577#592, 577#593, #, #, 581#583, #, #, 584#586, #, 586#592, 586#593, 586#594, 586#596, 586#595, #, #, #, #, #, 8#598, #, #, #, #, #, #, #, #, #, 615#599, 615#600, 615#601, 615#602, 615#603, 615#604, 615#605, 615#606, #, #, #, #, 623#615, 623#616, 623#617, 623#618, #, #, #, 628#600, 628#601, #, 631#625, 631#628, #, 633#615, #, #, #, 653#599, 653#600, 653#601, 653#623, 653#624, 653#602, 653#631, 653#603, 653#604, 653#605, 653#606, 653#633, 653#634, 653#635, 653#, 653#, 653#, #, 11#653, #, #, #, #, #, 665#656, 665#655, 665#657, 665#658, 665#659, #, 667#665, #, #, 670#668, #, #, 674#658, 674#659, #, 678#670, 678#671, 678#674, #, #, #, #, #, 687#680, 687#681, 687#682, 687#665, #, 697#655, 697#667, 697#656, 697#657, 697#678, 697#679, 697#687, 697#658, 697#659, #, 11#697, #, #, #, #, #, 709#700, 709#699, 709#701, 709#702, 709#703, #, 711#709, #, #, 714#712, #, #, 718#702, 718#703, #, 722#714, 722#715, 722#718, #, #, #, #, #, 731#724, 731#725, 731#726, 731#709, #, 741#699, 741#711, 741#700, 741#701, 741#722, 741#723, 741#731, 741#702, 741#703, #, 11#741, #, #, #, #, #, 753#744, 753#743, 753#745, 753#746, 753#747, #, 755#753, #, #, 758#756, #, #, 762#746, 762#747, #, 766#758, 766#759, 766#762, #, #, #, #, #, 775#768, 775#769, 775#770, 775#753, #, 786#743, 786#755, 786#744, 786#745, 786#766, 786#767, 786#775, 786#746, 786#747, 786#, #, 11#786, #, #, #, #, #, 798#789, 798#788, 798#790, 798#791, 798#792, #, 800#798, #, #, 803#801, #, #, 807#791, 807#792, #, 811#803, 811#804, 811#807, #, #, #, #, #, 820#813, 820#814, 820#815, 820#798, #, 830#788, 830#800, 830#789, 830#790, 830#811, 830#812, 830#820, 830#791, 830#792, #, 11#830, #, #, #, #, #, #, #, #, 848#832, 848#833, 848#834, 848#835, 848#836, 848#837, 848#838, 848#839, #, #, #, #, 856#848, 856#849, 856#850, 856#851, #, #, #, 861#858, 861#848, #, #, 865#862, 865#848, #, 878#856, 878#857, 878#836, 878#861, 878#832, 878#833, 878#834, 878#835, 878#837, 878#865, 878#839, 878#838, #, 11#878, #, #, #, #, #, #, #, #, 896#881, 896#880, 896#882, 896#883, 896#884, 896#885, 896#886, 896#887, #, #, 900#896, 900#897, #, #, 904#896, 904#901, #, #, #, #, #, 913#906, 913#907, 913#908, 913#896, #, 926#880, 926#881, 926#900, 926#882, 926#884, 926#885, 926#886, 926#887, 926#904, 926#883, 926#905, 926#913, #, 11#926, #, #, #, #, #, #, #, #, 944#929, 944#928, 944#930, 944#931, 944#932, 944#933, 944#934, 944#935, #, #, 948#944, 948#945, #, #, 952#944, 952#949, #, #, #, #, #, 961#954, 961#955, 961#956, 961#944, #, 974#928, 974#929, 974#948, 974#930, 974#932, 974#933, 974#934, 974#935, 974#952, 974#931, 974#953, 974#961, #, 11#974, #, #, #, #, #, #, #, #, 992#977, 992#976, 992#978, 992#979, 992#980, 992#981, 992#982, 992#983, #, #, 996#992, 996#993, #, #, 1000#992, 1000#997, #, #, #, #, #, 1009#1002, 1009#1003, 1009#1004, 1009#992, #, 1022#976, 1022#977, 1022#996, 1022#978, 1022#980, 1022#981, 1022#982, 1022#983, 1022#1000, 1022#979, 1022#1001, 1022#1009, #, 11#1022, #, #, #, #, #, 1034#1025, 1034#1024, 1034#1026, 1034#1027, 1034#1028, #, 1036#1034, #, #, 1039#1037, #, #, 1043#1027, 1043#1028, #, 1047#1039, 1047#1040, 1047#1043, #, #, #, #, #, 1056#1049, 1056#1050, 1056#1051, 1056#1034, #, 1066#1024, 1066#1036, 1066#1025, 1066#1026, 1066#1047, 1066#1048, 1066#1056, 1066#1027, 1066#1028, #, 11#1066, #, #, #, #, #, #, #, #, 1084#1068, 1084#1069, 1084#1070, 1084#1071, 1084#1072, 1084#1073, 1084#1074, 1084#1075, #, #, #, #, 1092#1084, 1092#1085, 1092#1086, 1092#1087, #, #, #, 1097#1094, 1097#1084, #, #, 1101#1098, 1101#1084, #, 1114#1092, 1114#1093, 1114#1072, 1114#1097, 1114#1068, 1114#1069, 1114#1070, 1114#1071, 1114#1073, 1114#1101, 1114#1075, 1114#1074, #, 11#1114, #, #, #, #, #, #, #, #, 1132#1117, 1132#1116, 1132#1118, 1132#1119, 1132#1120, 1132#1121, 1132#1122, 1132#1123, #, #, 1136#1132, 1136#1133, #, #, 1140#1132, 1140#1137, #, #, #, #, #, 1149#1142, 1149#1143, 1149#1144, 1149#1132, #, 1162#1116, 1162#1117, 1162#1136, 1162#1118, 1162#1120, 1162#1121, 1162#1122, 1162#1123, 1162#1140, 1162#1119, 1162#1141, 1162#1149, #, #, #, #, #, #, 1173#1163, 1173#1164, 1173#1165, 1173#1166, 1173#1167, #, #, #, #, 1181#1173, 1181#1174, 1181#1175, 1181#1176, #, #, 1185#1163, 1185#1164, #, #, #, 1189#1187, #, 1193#1185, 1193#1186, 1193#1189, #, 1195#1173, #, 1205#1163, 1205#1164, 1205#1181, 1205#1182, 1205#1193, 1205#1165, 1205#1167, 1205#1195, 1205#1166, #, #, #, #, #, #, #, #, #, 1222#1206, 1222#1207, 1222#1208, 1222#1209, 1222#1210, 1222#1211, 1222#1212, 1222#1213, #, #, #, #, 1230#1222, 1230#1223, 1230#1224, 1230#1225, #, #, #, 1235#1232, 1235#1222, #, #, 1239#1236, 1239#1222, #, 1252#1230, 1252#1231, 1252#1210, 1252#1235, 1252#1206, 1252#1207, 1252#1208, 1252#1209, 1252#1211, 1252#1239, 1252#1213, 1252#1212, #, #, #, #, #, #, #, #, #, 1269#1253, 1269#1254, 1269#1255, 1269#1256, 1269#1257, 1269#1258, 1269#1259, 1269#1260, #, #, #, #, 1277#1269, 1277#1270, 1277#1271, 1277#1272, #, #, #, 1282#1279, 1282#1269, #, #, 1286#1283, 1286#1269, #, 1299#1277, 1299#1278, 1299#1257, 1299#1282, 1299#1253, 1299#1254, 1299#1255, 1299#1256, 1299#1258, 1299#1286, 1299#1260, 1299#1259, #, #, #, #, #, #, #, #, #, 1316#1300, 1316#1301, 1316#1302, 1316#1303, 1316#1304, 1316#1305, 1316#1306, 1316#1307, #, #, #, #, 1324#1316, 1324#1317, 1324#1318, 1324#1319, #, #, #, 1329#1326, 1329#1316, #, #, 1333#1330, 1333#1316, #, 1346#1324, 1346#1325, 1346#1304, 1346#1329, 1346#1300, 1346#1301, 1346#1302, 1346#1303, 1346#1305, 1346#1333, 1346#1307, 1346#1306, #, #, #, #, #, #, #, #, #, 1363#1348, 1363#1347, 1363#1349, 1363#1350, 1363#1351, 1363#1352, 1363#1353, 1363#1354, #, #, 1367#1363, 1367#1364, #, #, 1371#1363, 1371#1368, #, #, #, #, #, 1380#1373, 1380#1374, 1380#1375, 1380#1363, #, 1393#1347, 1393#1348, 1393#1367, 1393#1349, 1393#1351, 1393#1352, 1393#1353, 1393#1354, 1393#1371, 1393#1350, 1393#1372, 1393#1380, #, #, #, #, #, #, 1404#1395, 1404#1394, 1404#1396, 1404#1397, 1404#1398, #, 1406#1404, #, #, 1409#1407, #, #, 1413#1397, 1413#1398, #, 1417#1409, 1417#1410, 1417#1413, #, #, #, #, #, 1426#1419, 1426#1420, 1426#1421, 1426#1404, #, 1436#1394, 1436#1406, 1436#1395, 1436#1396, 1436#1417, 1436#1418, 1436#1426, 1436#1397, 1436#1398, #, #, #, #, #, #, 1447#1437, 1447#1438, 1447#1439, 1447#1440, 1447#1441, #, #, #, #, 1455#1447, 1455#1448, 1455#1449, 1455#1450, #, #, 1459#1437, 1459#1438, #, #, #, 1463#1461, #, 1467#1459, 1467#1460, 1467#1463, #, 1469#1447, #, 1479#1437, 1479#1438, 1479#1455, 1479#1456, 1479#1467, 1479#1439, 1479#1441, 1479#1469, 1479#1440, #, #, #, #, #, #, 1490#1480, 1490#1481, 1490#1482, 1490#1483, 1490#1484, #, #, #, #, 1498#1490, 1498#1491, 1498#1492, 1498#1493, #, #, 1502#1480, 1502#1481, #, #, #, 1506#1504, #, 1510#1502, 1510#1503, 1510#1506, #, 1512#1490, #, 1523#, 1523#1480, 1523#1481, 1523#1498, 1523#1499, 1523#1510, 1523#1482, 1523#1484, 1523#1512, 1523#1483, #, #, #, #, #, #, 1534#1524, 1534#1525, 1534#1526, 1534#1527, 1534#1528, #, #, #, #, 1542#1534, 1542#1535, 1542#1536, 1542#1537, #, #, 1546#1524, 1546#1525, #, #, #, 1550#1548, #, 1554#1546, 1554#1547, 1554#1550, #, 1556#1534, #, 1566#1524, 1566#1525, 1566#1542, 1566#1543, 1566#1554, 1566#1526, 1566#1528, 1566#1556, 1566#1527, #, #, #, #, #, #, 1577#1567, 1577#1568, 1577#1569, 1577#1570, 1577#1571, #, #, #, #, 1585#1577, 1585#1578, 1585#1579, 1585#1580, #, #, 1589#1567, 1589#1568, #, #, #, 1593#1591, #, 1597#1589, 1597#1590, 1597#1593, #, 1599#1577, #, 1609#1567, 1609#1568, 1609#1585, 1609#1586, 1609#1597, 1609#1569, 1609#1571, 1609#1599, 1609#1570, #, #, #, #, #, #, #, #, #, #, #, 1628#1612, 1628#1613, 1628#1614, 1628#1615, 1628#1616, 1628#1617, 1628#1618, 1628#1619, #, 1630#1628, #, 1633#1617, 1633#1618, #, #, 1637#1633, 1637#1634, #, #, #, #, #, 1646#1639, 1646#1640, 1646#1641, 1646#1628, #, 1664#, 1664#, 1664#, 1664#1610, 1664#1611, 1664#1630, 1664#1612, 1664#1613, 1664#1614, 1664#1615, 1664#1637, 1664#1616, 1664#1638, 1664#1646, 1664#1617, 1664#1618, 1664#1619, #, #, #, #, #, #, 1675#1666, 1675#1665, 1675#1667, 1675#1668, 1675#1669, #, 1677#1675, #, #, 1680#1678, #, #, 1684#1668, 1684#1669, #, 1688#1680, 1688#1681, 1688#1684, #, #, #, #, #, 1697#1690, 1697#1691, 1697#1692, 1697#1675, #, 1707#1665, 1707#1677, 1707#1666, 1707#1667, 1707#1688, 1707#1689, 1707#1697, 1707#1668, 1707#1669, #, #, #, #, #, #, #, #, #, 1724#1708, 1724#1709, 1724#1710, 1724#1711, 1724#1712, 1724#1713, 1724#1714, 1724#1715, #, #, #, #, 1732#1724, 1732#1725, 1732#1726, 1732#1727, #, #, #, 1737#1734, 1737#1724, #, #, 1741#1738, 1741#1724, #, 1754#1732, 1754#1733, 1754#1712, 1754#1737, 1754#1708, 1754#1709, 1754#1710, 1754#1711, 1754#1713, 1754#1741, 1754#1715, 1754#1714, #, #, #, #, #, #, #, #, #, 1771#1756, 1771#1755, 1771#1757, 1771#1758, 1771#1759, 1771#1760, 1771#1761, 1771#1762, #, #, 1775#1771, 1775#1772, #, #, 1779#1771, 1779#1776, #, #, #, #, #, 1788#1781, 1788#1782, 1788#1783, 1788#1771, #, 1801#1755, 1801#1756, 1801#1775, 1801#1757, 1801#1759, 1801#1760, 1801#1761, 1801#1762, 1801#1779, 1801#1758, 1801#1780, 1801#1788, #, #, #, #, #, #, 1812#1803, 1812#1802, 1812#1804, 1812#1805, 1812#1806, #, 1814#1812, #, #, 1817#1815, #, #, 1821#1805, 1821#1806, #, 1825#1817, 1825#1818, 1825#1821, #, #, #, #, #, 1834#1827, 1834#1828, 1834#1829, 1834#1812, #, 1844#1802, 1844#1814, 1844#1803, 1844#1804, 1844#1825, 1844#1826, 1844#1834, 1844#1805, 1844#1806, #, #, #, #, #, #, #, #, #, 1861#1846, 1861#1845, 1861#1847, 1861#1848, 1861#1849, 1861#1850, 1861#1851, 1861#1852, #, #, 1865#1861, 1865#1862, #, #, 1869#1861, 1869#1866, #, #, #, #, #, 1878#1871, 1878#1872, 1878#1873, 1878#1861, #, 1891#1845, 1891#1846, 1891#1865, 1891#1847, 1891#1849, 1891#1850, 1891#1851, 1891#1852, 1891#1869, 1891#1848, 1891#1870, 1891#1878, #, #, #, #, #, #, #, #, #, 1908#1892, 1908#1893, 1908#1894, 1908#1895, 1908#1896, 1908#1897, 1908#1898, 1908#1899, #, #, #, #, 1916#1908, 1916#1909, 1916#1910, 1916#1911, #, #, #, 1921#1918, 1921#1908, #, #, 1925#1922, 1925#1908, #, 1938#1916, 1938#1917, 1938#1896, 1938#1921, 1938#1892, 1938#1893, 1938#1894, 1938#1895, 1938#1897, 1938#1925, 1938#1899, 1938#1898, #, #, #, #, #, #, #, #, #, 1955#1940, 1955#1939, 1955#1941, 1955#1942, 1955#1943, 1955#1944, 1955#1945, 1955#1946, #, #, 1959#1955, 1959#1956, #, #, 1963#1955, 1963#1960, #, #, #, #, #, 1972#1965, 1972#1966, 1972#1967, 1972#1955, #, 1985#1939, 1985#1940, 1985#1959, 1985#1941, 1985#1943, 1985#1944, 1985#1945, 1985#1946, 1985#1963, 1985#1942, 1985#1964, 1985#1972, #, 2271#2030, #, #, #, #, #, 1997#1988, 1997#1987, 1997#1989, 1997#1990, 1997#1991, #, 1999#1997, #, #, 2002#2000, #, #, 2006#1990, 2006#1991, #, 2010#2002, 2010#2003, 2010#2006, #, #, #, #, #, 2019#2012, 2019#2013, 2019#2014, 2019#1997, #, 2030#1987, 2030#1999, 2030#1988, 2030#1989, 2030#2010, 2030#2011, 2030#2019, 2030#1990, 2030#1991, 2030#, #, 2033#2034, 2033#2079, 2226#2030, #, 2226#2034, #, #, #, #, #, 2046#2037, 2046#2036, 2046#2038, 2046#2039, 2046#2040, #, 2048#2046, #, #, 2051#2049, #, #, 2055#2039, 2055#2040, #, 2059#2051, 2059#2052, 2059#2055, #, #, #, #, #, 2068#2061, 2068#2062, 2068#2063, 2068#2046, #, 2079#2036, 2079#2048, 2079#2037, 2079#2038, 2079#2059, 2079#2060, 2079#2068, 2079#2039, 2079#2040, 2079#2271, #, 2078#2225, 2271#2125, #, #, #, #, #, 2092#2083, 2092#2082, 2092#2084, 2092#2085, 2092#2086, #, 2094#2092, #, #, 2097#2095, #, #, 2101#2085, 2101#2086, #, 2105#2097, 2105#2098, 2105#2101, #, #, #, #, #, 2114#2107, 2114#2108, 2114#2109, 2114#2092, #, 2125#2082, 2125#2094, 2125#2083, 2125#2084, 2125#2105, 2125#2106, 2125#2114, 2125#2085, 2125#2086, 2125#, #, 2128#2129, 2128#2174, 2226#2125, #, 2226#2129, #, #, #, #, #, 2141#2132, 2141#2131, 2141#2133, 2141#2134, 2141#2135, #, 2143#2141, #, #, 2146#2144, #, #, 2150#2134, 2150#2135, #, 2154#2146, 2154#2147, 2154#2150, #, #, #, #, #, 2163#2156, 2163#2157, 2163#2158, 2163#2141, #, 2174#2131, 2174#2143, 2174#2132, 2174#2133, 2174#2154, 2174#2155, 2174#2163, 2174#2134, 2174#2135, 2174#2271, #, 2173#2225, #, #, #, #, #, #, #, #, 2192#2176, 2192#2177, 2192#2178, 2192#2179, 2192#2180, 2192#2181, 2192#2182, 2192#2183, #, #, #, #, 2200#2192, 2200#2193, 2200#2194, 2200#2195, #, #, #, 2205#2177, 2205#2178, #, 2208#2202, 2208#2205, #, 2210#2192, #, 2226#2176, 2226#2177, 2226#2178, 2226#2200, 2226#2201, 2226#2179, 2226#2208, 2226#2180, 2226#2181, 2226#2182, 2226#2183, 2226#2210, 2226#, 2226#, 2226#, #, #, #, #, #, #, 2237#2228, 2237#2227, 2237#2229, 2237#2230, 2237#2231, #, 2239#2237, #, #, 2242#2240, #, #, 2246#2230, 2246#2231, #, 2250#2242, 2250#2243, 2250#2246, #, #, #, #, #, 2259#2252, 2259#2253, 2259#2254, 2259#2237, #, 2271#2227, 2271#2239, 2271#2228, 2271#2229, 2271#2250, 2271#2251, 2271#2259, 2271#2230, 2271#2231, 2271#2223, 2271#2224, #, 2321#1162, 2321#1205, 2321#1252, 2321#1299, 2321#1346, 2321#1393, 2321#1436, 2321#1479, 2321#1523, 2321#1566, 2321#1609, 2321#1664, 2321#1707, 2321#1754, 2321#1801, 2321#1844, 2321#1891, 2321#1938, 2321#1985, 2321#, 2321#1986, 2321#2030, 2321#2029, 2321#2033, 2321#2031, 2321#2034, 2321#2035, 2321#2032, 2321#2079, 2321#2078, 2321#2080, 2321#2081, 2321#2125, 2321#2124, 2321#2128, 2321#2126, 2321#2129, 2321#2130, 2321#2127, 2321#2174, 2321#2173, 2321#2175, 2321#2226, 2321#2223, 2321#2224, 2321#2225, 2321#2271, 2321#2269, 2321#2270, #, 8#2321, #, #, #, #, #, 2333#2324, 2333#2323, 2333#2325, 2333#2326, 2333#2327, #, 2335#2333, #, #, 2338#2336, #, #, 2342#2326, 2342#2327, #, 2346#2338, 2346#2339, 2346#2342, #, #, #, #, #, 2355#2348, 2355#2349, 2355#2350, 2355#2333, #, 2365#2323, 2365#2335, 2365#2324, 2365#2325, 2365#2346, 2365#2347, 2365#2355, 2365#2326, 2365#2327, #, 11#2365, #, #, #, #, #, #, #, #, 2383#2367, 2383#2368, 2383#2369, 2383#2370, 2383#2371, 2383#2372, 2383#2373, 2383#2374, #, #, #, #, 2391#2383, 2391#2384, 2391#2385, 2391#2386, #, #, #, 2396#2393, 2396#2383, #, #, 2400#2397, 2400#2383, #, 2413#2391, 2413#2392, 2413#2371, 2413#2396, 2413#2367, 2413#2368, 2413#2369, 2413#2370, 2413#2372, 2413#2400, 2413#2374, 2413#2373, #, 11#2413, #, #, #, #, #, #, #, #, 2431#2416, 2431#2415, 2431#2417, 2431#2418, 2431#2419, 2431#2420, 2431#2421, 2431#2422, #, #, 2435#2431, 2435#2432, #, #, 2439#2431, 2439#2436, #, #, #, #, #, 2448#2441, 2448#2442, 2448#2443, 2448#2431, #, 2461#2415, 2461#2416, 2461#2435, 2461#2417, 2461#2419, 2461#2420, 2461#2421, 2461#2422, 2461#2439, 2461#2418, 2461#2440, 2461#2448, #, 11#2461, #, #, #, #, #, #, #, #, 2479#2463, 2479#2464, 2479#2465, 2479#2466, 2479#2467, 2479#2468, 2479#2469, 2479#2470, #, #, #, #, 2487#2479, 2487#2480, 2487#2481, 2487#2482, #, #, #, 2492#2489, 2492#2479, #, #, 2496#2493, 2496#2479, #, 2509#2487, 2509#2488, 2509#2467, 2509#2492, 2509#2463, 2509#2464, 2509#2465, 2509#2466, 2509#2468, 2509#2496, 2509#2470, 2509#2469, #, 11#2509, 2#2512, #, 2512#, #, 13#2514, 2512#2517, #, 2517#, #, 13#2519, 
### 内容
#0, 17:
文档\物理问题\透镜焦距.ftxt
## end
#2, 234:
+[返回目录](,透镜焦距)
地址::文档\物理问题\透镜焦距.ftxt

动词:...
+[设置动词](,动词)
名词:...
+[设置名词](,名词)

网页画板::文档\S应用\网页画板.ftxt
+[打开文件](+新窗口,网页画板)
几何画板::文档\S应用\几何样本库.ftxt
+[打开文件](+新窗口,几何画板)
星图::文档\S应用\星图.txt
+[打开文件](+新窗口,星图)


形状与焦距(html):...
传输矩阵(html):...



## end
#3, 48:
透镜焦距:...
创建于 20210705

节点数目统计::
+[设置结构](,节点数目统计)
## end
#6, 16:
文档\S应用\网页画板.ftxt
## end
#8, 1958:
<!--
+[H函数](,形状与焦距)
凹透镜原理图(画图):...
+[画板](+新画板,凹透镜原理图)
凹透镜原理图->画图(凹透镜原理图,)->+[del](,画图)

透镜原理图(画图):...
+[画板](+新画板,透镜原理图)
+[粘贴](,面镜焦距)->+[修改标题]"透镜原理图"(,凹透镜原理图)
-->
I want to discuss the relation of the spherical mirror's shape and the foucs length. <br>
The reflection point on the mirror is A. The focus point is B. And O is the center of the spherical mirror.<br>
<br>
<b><u>Positive mirror</u></b><br>
For positive mirror, let's assume the radiu is R, and the distance from A to OB is d. Then we have, 
$$
\angle CAO = \angle AOB =arcsin(d/R)
\equiv \theta
$$$$
\angle CAB=2\theta
$$$$
\|BD\|=\frac{d}{tan(2\theta)}
=d \frac{1-tan(\theta)^2}{2 tan(\theta)}
$$
For \(\theta \ll 1\), we have, 
$$
\|BD\|\approx \frac{R}{2} = f
$$
Then for parabola, we have, 
$$
y=-\sqrt{R^2-x^2}=-R\sqrt{1-(x/R)^2}
\approx
-R (1-\frac{1}{2}(x/R)^2)
\\
=\frac{1}{2R}x^2-R
=\frac{1}{4f}x^2-R
$$
<br>




<b><u>Negative mirror</u></b><br>
The negative mirror is exavtly same as the positive mirror, 
$$
f=-\frac{R}{2}
$$$$
y=a x^2,\ a=\frac{1}{4 f}
$$
<br>






<b><u>Lens</u></b><br>
Assume the refractive index of the left side is \(n_1\), and the right side is \(n_2\). Then we have, 
$$
\angle CAE = arcsin(d/R)
\equiv \theta
,\ 
\angle OAB\equiv \alpha
$$$$
n_1 sin(\theta)=n_2 sin(\alpha)
$$
And, 
$$
\angle ABO=\angle AOD-\angle OAB
=\theta-\alpha
$$

For small angle assumption, which means \(\theta \ll 1, \alpha \ll 1\), 
$$
\angle ABO=\theta - \alpha 
\approx
\theta - \frac{n_1}{n_2} \theta
=
\frac{n_1-n_2}{n_2} \theta
$$
And, 
$$
\theta \approx \frac{d}{R}
,\ 
\angle ABO \approx
\frac{d}{f}
$$$$
\Rightarrow
\frac{n_1-n_2}{n_2} \frac{d}{R}
= \frac{d}{f}
$$$$
\Rightarrow
f=\frac{n_2 R}{n_1-n_2}
$$

Both positive lens and negative lens follow the same derivation. 


<!--
抛物线::https://courses.lumenlearning.com/suny-osalgebratrig/chapter/the-parabola/#:~:text=Start%20by%20writing%20the%20equation,parallel%20to%20the%20y%2Daxis.
+[打开网页](,抛物线)
+[H函数](,形状与焦距)
-->
## end
#11, 907:
+[返回目录](,凹透镜原理图)
+[显示星图](,凹透镜原理图)
+[删除结构](,凹透镜原理图)
+[新建阅读窗口](,凹透镜原理图)

+[画板](+新画板,凹透镜原理图)

的(圆弧,半径)->半径"-75"->+[修改内容]"75"(,半径)

有一个圆弧(-45,45), 过圆弧圆心和弧线中心有一条水平参考线. 
参考线上下分别有一道水平光线打到圆弧上, 反射光线相交于参考线上某一点. 
那个点是焦点, 标记焦点到圆弧中心的距离. 

中心(圆弧,)->[点](中心,)
[点](中心,)->[m_text]([点],+[显示])

+圆弧->+圆心(+圆弧,)->+中心(+圆弧,)->+焦点(+圆弧,)...
->+参考线->+经过(+参考线,+圆心)->+经过(+参考线,+中心)

+上面(参考线,+光线)->+水平(+光线,)->+反射(圆弧,+光线)...
->+于(+反射,+反射点)->+的(圆弧,+反射点)->+出(+反射,+光线#2)...
->+相交(+光线#2,参考线)->+于(+相交,焦点)

+下面(参考线,+光线)->+水平(+光线,)->+反射(圆弧,+光线)...
->+于(+反射,+反射点)->+的(圆弧,+反射点)->+出(+反射,+光线#2)...
->+相交(+光线#2,参考线)->+于(+相交,焦点)

+[创建圆弧](,圆弧)
上面(参考线,光线)->下面(参考线,光线#2)...
->+[创建直线](,参考线)->+[创建直线](,光线)->+[创建直线](,光线#2)

的(参考线,线型)->+[修改内容]"DashLine"(,线型)
上面的光线是红色的
上面(参考线,光线)->的(光线,线颜色)->+[修改内容]"255,0,0"(,线颜色)

上面光线反射出的光线是直线, 颜色是红色的
上面(,光线)->反射(,光线)->出(反射,光线#2)->+[创建直线](,光线#2)->+[设置结构](,光线#2)
上面光线反射出的光线是直线
下面(,光线)->反射(,光线)->出(反射,光线#2)->+[创建直线](,光线#2)


## end
#14, 2:
20
## end
#17, 17:
文档\S应用\几何样本库.ftxt
## end
#18, 3:
273
## end
#21, 13:
文档\S应用\星图.txt
## end
#31, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#35, 171:
+[返回目录](,圆形)

中心::200,100
半径::100
类型::圆形
角度::0
起始角度::30


面颜色::255,255,0
线颜色::None
线型::SolidLine
线粗细::2

画图:...
选中区域:...
HTML:...
+[创建输入](起始角度,画图)
的(画图,输入)->+[有](HTML,输入)

## end
#49, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#56, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#88, 519:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.beginPath();
ctx.arc(%中心,%半径,0,2*Math.PI)

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fill();
}

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(0,0,0)';
} else {
        ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        if('%线型'==='DashLine') {
            ctx.setLineDash([5,5])
        }
        ctx.stroke();
}

ctx.setLineDash([])

//ctx.stroke()

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#90, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#93, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#96, 14:
+[返回目录]
+[内容]

## end
#97, 2:
圆形
## end
#98, 760:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
angle_0=起始角度[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型


if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


an=np.linspace(angle_0,angle,20)
t=np.deg2rad(an)
x=pt[0]+r*np.cos(t)
y=pt[1]-r*np.sin(t)


path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())





## end
#103, 760:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
angle_0=起始角度[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型


if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


an=np.linspace(angle_0,angle,20)
t=np.deg2rad(an)
x=pt[0]+r*np.cos(t)
y=pt[1]-r*np.sin(t)


path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())





## end
#104, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#106, 75:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
起始角度::30

## end
#115, 1:
2
## end
#116, 9:
SolidLine
## end
#117, 5:
0,0,0
## end
#118, 4:
None
## end
#119, 2:
45
## end
#120, 2:
75
## end
#121, 37:
137.62540000000007, 48.97709999999995
## end
#122, 3:
-45
## end
#132, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#138, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#139, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#140, 2:
直线
## end
#141, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#145, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#148, 14:
+[返回目录]
+[内容]

## end
#149, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#151, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#152, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#154, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#160, 12:
340.5, 52.25
## end
#161, 13:
-142.5, 51.75
## end
#162, 5:
0,0,0
## end
#163, 1:
1
## end
#164, 8:
DashLine
## end
#174, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#180, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#181, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#182, 2:
直线
## end
#183, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#187, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#190, 14:
+[返回目录]
+[内容]

## end
#191, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#193, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#194, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#196, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#202, 11:
206.0, 16.0
## end
#203, 11:
-79.0, 17.0
## end
#204, 7:
255,0,0
## end
#205, 1:
1
## end
#206, 9:
SolidLine
## end
#207, 1:
1
## end
#209, 8:
958, 476
## end
#211, 11:
50.0, 150.0
## end
#214, 4:
1248
## end
#217, 26:
+[返回目录](,动词)

经过:...






## end
#219, 62:
"""
+[返回目录](,经过)

"""

+经过(_直线,和)->+[del](,经过)...
->和(_点,_点)


## end
#221, 22:
+[返回目录](,名词)

点:...



## end
#223, 335:
"""
+[返回目录](,点)

计算圆弧中心(P函数):...

"""

+点(圆心,)->圆心(_圆,)->的(_圆,中心)->[m_text](中心,+点);

+点(中心,)->中心(_圆弧,)...
->的(点,计算圆弧中心)...
->的(_圆弧,中心#2)->的(_圆弧,角度)->的(_圆弧,起始角度)->的(_圆弧,半径)...
->+[code]([python],计算圆弧中心)...
->+[.]"an1"([python],起始角度)->+[.]"an2"([python],角度)...
->+[.]"pt"([python],中心#2)->+[.]"r"([python],半径)...
->[python](Python,+点)




## end
#225, 115:
"""
+[P函数](,计算圆弧中心)

"""

t=np.deg2rad((an1[0]+an2[0])/2)
x=pt[0]+r[0]*np.cos(t)
y=pt[1]-r[0]*np.cos(t)

ans=[x,y]

## end
#236, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#242, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#243, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#244, 2:
直线
## end
#245, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#249, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#252, 14:
+[返回目录]
+[内容]

## end
#253, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#255, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#256, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#258, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#264, 11:
206.5, 17.5
## end
#265, 12:
306.0, -15.0
## end
#266, 7:
255,0,0
## end
#267, 1:
1
## end
#268, 9:
SolidLine
## end
#269, 149:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10

面颜色::255,255,255
线颜色::0,0,0
线型::SolidLine
线粗细::2

画图:...
选中区域:...
HTML:...



## end
#283, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#289, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#290, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#291, 2:
矩形
## end
#292, 231:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


## end
#295, 14:
+[返回目录]
+[内容]

## end
#296, 754:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细
        if('%线型'==='DashLine') {
            ctx.setLineDash([5,5])
        };
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

ctx.setLineDash([])

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#299, 14:
+[返回目录]
+[内容]

## end
#300, 101:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100

## end
#309, 4:
None
## end
#310, 4:
None
## end
#311, 9:
SolidLine
## end
#312, 1:
2
## end
#313, 1:
O
## end
#314, 2:
10
## end
#315, 12:
126.0, 39.75
## end
#316, 10:
36.0, 40.5
## end
#317, 10:
36.0, 40.5
## end
#318, 11:
201.0, 1.75
## end
#319, 2:
10
## end
#320, 1:
A
## end
#321, 1:
2
## end
#322, 9:
SolidLine
## end
#323, 4:
None
## end
#324, 4:
None
## end
#333, 101:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100

## end
#334, 14:
+[返回目录]
+[内容]

## end
#337, 754:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细
        if('%线型'==='DashLine') {
            ctx.setLineDash([5,5])
        };
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

ctx.setLineDash([])

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#338, 14:
+[返回目录]
+[内容]

## end
#341, 231:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


## end
#342, 2:
矩形
## end
#343, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#344, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#350, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#363, 149:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10

面颜色::255,255,255
线颜色::0,0,0
线型::SolidLine
线粗细::2

画图:...
选中区域:...
HTML:...



## end
#365, 4:
None
## end
#366, 4:
None
## end
#367, 9:
SolidLine
## end
#368, 1:
2
## end
#369, 1:
B
## end
#370, 2:
10
## end
#371, 10:
36.0, 40.5
## end
#372, 11:
81.0, 21.75
## end
#381, 101:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100

## end
#383, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#384, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#389, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#390, 2:
矩形
## end
#391, 14:
+[返回目录]
+[内容]

## end
#394, 231:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


## end
#395, 14:
+[返回目录]
+[内容]

## end
#398, 754:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细
        if('%线型'==='DashLine') {
            ctx.setLineDash([5,5])
        };
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

ctx.setLineDash([])

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#411, 149:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10

面颜色::255,255,255
线颜色::0,0,0
线型::SolidLine
线粗细::2

画图:...
选中区域:...
HTML:...



## end
#413, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#424, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#430, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#431, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#432, 2:
直线
## end
#433, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#437, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#440, 14:
+[返回目录]
+[内容]

## end
#441, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#443, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#444, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#446, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#452, 12:
277.0, -22.0
## end
#453, 11:
151.0, 47.0
## end
#454, 5:
0,0,0
## end
#455, 1:
1
## end
#456, 8:
DashLine
## end
#457, 4:
None
## end
#458, 4:
None
## end
#459, 9:
SolidLine
## end
#460, 1:
2
## end
#461, 1:
C
## end
#462, 2:
10
## end
#463, 10:
36.0, 40.5
## end
#464, 12:
-81.0, -8.25
## end
#473, 101:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100

## end
#475, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#476, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#481, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#482, 2:
矩形
## end
#483, 14:
+[返回目录]
+[内容]

## end
#486, 231:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


## end
#487, 14:
+[返回目录]
+[内容]

## end
#490, 754:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细
        if('%线型'==='DashLine') {
            ctx.setLineDash([5,5])
        };
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

ctx.setLineDash([])

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#503, 149:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10

面颜色::255,255,255
线颜色::0,0,0
线型::SolidLine
线粗细::2

画图:...
选中区域:...
HTML:...



## end
#505, 10:
36.0, 40.5
## end
#506, 12:
177.0, 21.75
## end
#507, 2:
10
## end
#508, 1:
D
## end
#509, 1:
2
## end
#510, 9:
SolidLine
## end
#511, 4:
None
## end
#512, 4:
None
## end
#521, 101:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100

## end
#522, 14:
+[返回目录]
+[内容]

## end
#525, 754:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细
        if('%线型'==='DashLine') {
            ctx.setLineDash([5,5])
        };
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

ctx.setLineDash([])

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#526, 14:
+[返回目录]
+[内容]

## end
#529, 231:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


## end
#530, 2:
矩形
## end
#531, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#532, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#538, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#551, 149:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10

面颜色::255,255,255
线颜色::0,0,0
线型::SolidLine
线粗细::2

画图:...
选中区域:...
HTML:...



## end
#553, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#564, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#570, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#571, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#572, 2:
直线
## end
#573, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#577, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#580, 14:
+[返回目录]
+[内容]

## end
#581, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#583, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#584, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#586, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#592, 11:
207.0, 49.0
## end
#593, 11:
207.0, 17.0
## end
#594, 5:
0,0,0
## end
#595, 1:
1
## end
#596, 8:
DashLine
## end
#598, 152:
https://courses.lumenlearning.com/suny-osalgebratrig/chapter/the-parabola/#:~:text=Start%20by%20writing%20the%20equation,parallel%20to%20the%20y%2Daxis.
## end
#599, 3:
135
## end
#600, 12:
221.0, 219.0
## end
#601, 2:
75
## end
#602, 3:
225
## end
#603, 4:
None
## end
#604, 5:
0,0,0
## end
#605, 9:
SolidLine
## end
#606, 1:
2
## end
#615, 75:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
起始角度::30

## end
#617, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#618, 760:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
angle_0=起始角度[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型


if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


an=np.linspace(angle_0,angle,20)
t=np.deg2rad(an)
x=pt[0]+r*np.cos(t)
y=pt[1]-r*np.sin(t)


path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())





## end
#623, 760:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
angle_0=起始角度[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型


if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


an=np.linspace(angle_0,angle,20)
t=np.deg2rad(an)
x=pt[0]+r*np.cos(t)
y=pt[1]-r*np.sin(t)


path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())





## end
#624, 2:
圆形
## end
#625, 14:
+[返回目录]
+[内容]

## end
#628, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#631, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#633, 519:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.beginPath();
ctx.arc(%中心,%半径,0,2*Math.PI)

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fill();
}

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(0,0,0)';
} else {
        ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        if('%线型'==='DashLine') {
            ctx.setLineDash([5,5])
        }
        ctx.stroke();
}

ctx.setLineDash([])

//ctx.stroke()

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#653, 171:
+[返回目录](,圆形)

中心::200,100
半径::100
类型::圆形
角度::0
起始角度::30


面颜色::255,255,0
线颜色::None
线型::SolidLine
线粗细::2

画图:...
选中区域:...
HTML:...
+[创建输入](起始角度,画图)
的(画图,输入)->+[有](HTML,输入)

## end
#655, 8:
DashLine
## end
#656, 1:
1
## end
#657, 5:
0,0,0
## end
#658, 13:
-159.0, 216.5
## end
#659, 12:
363.0, 219.0
## end
#665, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#667, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#668, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#670, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#671, 14:
+[返回目录]
+[内容]

## end
#674, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#678, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#679, 2:
直线
## end
#680, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#681, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#687, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#697, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#699, 8:
DashLine
## end
#700, 1:
1
## end
#701, 5:
0,0,0
## end
#702, 11:
92.0, 166.0
## end
#703, 12:
220.0, 215.0
## end
#709, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#711, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#712, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#714, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#715, 14:
+[返回目录]
+[内容]

## end
#718, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#722, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#723, 2:
直线
## end
#724, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#725, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#731, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#741, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#743, 9:
SolidLine
## end
#744, 1:
1
## end
#745, 7:
255,0,0
## end
#746, 13:
-130.5, 189.5
## end
#747, 12:
154.5, 188.5
## end
#753, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#755, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#756, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#758, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#759, 14:
+[返回目录]
+[内容]

## end
#762, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#766, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#767, 2:
直线
## end
#768, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#769, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#775, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#786, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#788, 9:
SolidLine
## end
#789, 1:
1
## end
#790, 7:
255,0,0
## end
#791, 12:
155.0, 189.5
## end
#792, 12:
300.0, 219.0
## end
#798, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#800, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#801, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#803, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#804, 14:
+[返回目录]
+[内容]

## end
#807, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#811, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#812, 2:
直线
## end
#813, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#814, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#820, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#830, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#832, 4:
None
## end
#833, 4:
None
## end
#834, 9:
SolidLine
## end
#835, 1:
2
## end
#836, 1:
A
## end
#837, 2:
10
## end
#838, 10:
36.0, 40.5
## end
#839, 13:
131.0, 148.75
## end
#848, 101:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100

## end
#850, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#851, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#856, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#857, 2:
矩形
## end
#858, 14:
+[返回目录]
+[内容]

## end
#861, 231:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


## end
#862, 14:
+[返回目录]
+[内容]

## end
#865, 754:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细
        if('%线型'==='DashLine') {
            ctx.setLineDash([5,5])
        };
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

ctx.setLineDash([])

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#878, 149:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10

面颜色::255,255,255
线颜色::0,0,0
线型::SolidLine
线粗细::2

画图:...
选中区域:...
HTML:...



## end
#880, 10:
36.0, 40.5
## end
#881, 13:
205.0, 209.75
## end
#882, 2:
10
## end
#883, 1:
O
## end
#884, 1:
2
## end
#885, 9:
SolidLine
## end
#886, 4:
None
## end
#887, 4:
None
## end
#896, 101:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100

## end
#897, 14:
+[返回目录]
+[内容]

## end
#900, 754:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细
        if('%线型'==='DashLine') {
            ctx.setLineDash([5,5])
        };
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

ctx.setLineDash([])

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#901, 14:
+[返回目录]
+[内容]

## end
#904, 231:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


## end
#905, 2:
矩形
## end
#906, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#907, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#913, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#926, 149:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10

面颜色::255,255,255
线颜色::0,0,0
线型::SolidLine
线粗细::2

画图:...
选中区域:...
HTML:...



## end
#928, 10:
36.0, 40.5
## end
#929, 13:
289.0, 177.75
## end
#930, 2:
10
## end
#931, 1:
B
## end
#932, 1:
2
## end
#933, 9:
SolidLine
## end
#934, 4:
None
## end
#935, 4:
None
## end
#944, 101:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100

## end
#945, 14:
+[返回目录]
+[内容]

## end
#948, 754:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细
        if('%线型'==='DashLine') {
            ctx.setLineDash([5,5])
        };
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

ctx.setLineDash([])

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#949, 14:
+[返回目录]
+[内容]

## end
#952, 231:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


## end
#953, 2:
矩形
## end
#954, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#955, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#961, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#974, 149:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10

面颜色::255,255,255
线颜色::0,0,0
线型::SolidLine
线粗细::2

画图:...
选中区域:...
HTML:...



## end
#976, 10:
36.0, 40.5
## end
#977, 14:
-134.0, 153.75
## end
#978, 2:
10
## end
#979, 1:
C
## end
#980, 1:
2
## end
#981, 9:
SolidLine
## end
#982, 4:
None
## end
#983, 4:
None
## end
#992, 101:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100

## end
#993, 14:
+[返回目录]
+[内容]

## end
#996, 754:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细
        if('%线型'==='DashLine') {
            ctx.setLineDash([5,5])
        };
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

ctx.setLineDash([])

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#997, 14:
+[返回目录]
+[内容]

## end
#1000, 231:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


## end
#1001, 2:
矩形
## end
#1002, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#1003, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#1009, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#1022, 149:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10

面颜色::255,255,255
线颜色::0,0,0
线型::SolidLine
线粗细::2

画图:...
选中区域:...
HTML:...



## end
#1024, 8:
DashLine
## end
#1025, 1:
1
## end
#1026, 5:
0,0,0
## end
#1027, 12:
154.0, 188.0
## end
#1028, 12:
154.0, 220.0
## end
#1034, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#1036, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1037, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1039, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1040, 14:
+[返回目录]
+[内容]

## end
#1043, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#1047, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#1048, 2:
直线
## end
#1049, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1050, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1056, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1066, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#1068, 4:
None
## end
#1069, 4:
None
## end
#1070, 9:
SolidLine
## end
#1071, 1:
2
## end
#1072, 1:
D
## end
#1073, 2:
10
## end
#1074, 10:
36.0, 40.5
## end
#1075, 13:
144.0, 212.75
## end
#1084, 101:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100

## end
#1086, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#1087, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#1092, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#1093, 2:
矩形
## end
#1094, 14:
+[返回目录]
+[内容]

## end
#1097, 231:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


## end
#1098, 14:
+[返回目录]
+[内容]

## end
#1101, 754:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细
        if('%线型'==='DashLine') {
            ctx.setLineDash([5,5])
        };
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

ctx.setLineDash([])

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1114, 149:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10

面颜色::255,255,255
线颜色::0,0,0
线型::SolidLine
线粗细::2

画图:...
选中区域:...
HTML:...



## end
#1116, 10:
36.0, 40.5
## end
#1117, 13:
144.0, 212.75
## end
#1118, 2:
10
## end
#1119, 1:
D
## end
#1120, 1:
2
## end
#1121, 9:
SolidLine
## end
#1122, 4:
None
## end
#1123, 4:
None
## end
#1132, 101:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100

## end
#1133, 14:
+[返回目录]
+[内容]

## end
#1136, 754:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细
        if('%线型'==='DashLine') {
            ctx.setLineDash([5,5])
        };
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

ctx.setLineDash([])

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1137, 14:
+[返回目录]
+[内容]

## end
#1140, 231:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


## end
#1141, 2:
矩形
## end
#1142, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#1143, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#1149, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#1162, 149:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10

面颜色::255,255,255
线颜色::0,0,0
线型::SolidLine
线粗细::2

画图:...
选中区域:...
HTML:...



## end
#1163, 12:
154.0, 220.0
## end
#1164, 12:
154.0, 188.0
## end
#1165, 5:
0,0,0
## end
#1166, 8:
DashLine
## end
#1167, 1:
1
## end
#1173, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#1175, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1176, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1181, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1182, 2:
直线
## end
#1185, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#1186, 14:
+[返回目录]
+[内容]

## end
#1187, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1189, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1193, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#1195, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1205, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#1206, 4:
None
## end
#1207, 4:
None
## end
#1208, 9:
SolidLine
## end
#1209, 1:
2
## end
#1210, 1:
C
## end
#1211, 2:
10
## end
#1212, 10:
36.0, 40.5
## end
#1213, 14:
-134.0, 153.75
## end
#1222, 101:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100

## end
#1224, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#1225, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#1230, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#1231, 2:
矩形
## end
#1232, 14:
+[返回目录]
+[内容]

## end
#1235, 231:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


## end
#1236, 14:
+[返回目录]
+[内容]

## end
#1239, 754:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细
        if('%线型'==='DashLine') {
            ctx.setLineDash([5,5])
        };
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

ctx.setLineDash([])

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1252, 149:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10

面颜色::255,255,255
线颜色::0,0,0
线型::SolidLine
线粗细::2

画图:...
选中区域:...
HTML:...



## end
#1253, 4:
None
## end
#1254, 4:
None
## end
#1255, 9:
SolidLine
## end
#1256, 1:
2
## end
#1257, 1:
B
## end
#1258, 2:
10
## end
#1259, 10:
36.0, 40.5
## end
#1260, 13:
171.0, 208.75
## end
#1269, 101:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100

## end
#1271, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#1272, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#1277, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#1278, 2:
矩形
## end
#1279, 14:
+[返回目录]
+[内容]

## end
#1282, 231:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


## end
#1283, 14:
+[返回目录]
+[内容]

## end
#1286, 754:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细
        if('%线型'==='DashLine') {
            ctx.setLineDash([5,5])
        };
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

ctx.setLineDash([])

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1299, 149:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10

面颜色::255,255,255
线颜色::0,0,0
线型::SolidLine
线粗细::2

画图:...
选中区域:...
HTML:...



## end
#1300, 4:
None
## end
#1301, 4:
None
## end
#1302, 9:
SolidLine
## end
#1303, 1:
2
## end
#1304, 1:
O
## end
#1305, 2:
10
## end
#1306, 10:
36.0, 40.5
## end
#1307, 13:
221.0, 197.75
## end
#1316, 101:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100

## end
#1318, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#1319, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#1324, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#1325, 2:
矩形
## end
#1326, 14:
+[返回目录]
+[内容]

## end
#1329, 231:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


## end
#1330, 14:
+[返回目录]
+[内容]

## end
#1333, 754:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细
        if('%线型'==='DashLine') {
            ctx.setLineDash([5,5])
        };
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

ctx.setLineDash([])

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1346, 149:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10

面颜色::255,255,255
线颜色::0,0,0
线型::SolidLine
线粗细::2

画图:...
选中区域:...
HTML:...



## end
#1347, 10:
36.0, 40.5
## end
#1348, 13:
134.0, 145.75
## end
#1349, 2:
10
## end
#1350, 1:
A
## end
#1351, 1:
2
## end
#1352, 9:
SolidLine
## end
#1353, 4:
None
## end
#1354, 4:
None
## end
#1363, 101:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100

## end
#1364, 14:
+[返回目录]
+[内容]

## end
#1367, 754:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细
        if('%线型'==='DashLine') {
            ctx.setLineDash([5,5])
        };
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

ctx.setLineDash([])

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1368, 14:
+[返回目录]
+[内容]

## end
#1371, 231:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


## end
#1372, 2:
矩形
## end
#1373, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#1374, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#1380, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#1393, 149:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10

面颜色::255,255,255
线颜色::0,0,0
线型::SolidLine
线粗细::2

画图:...
选中区域:...
HTML:...



## end
#1394, 8:
DashLine
## end
#1395, 1:
1
## end
#1396, 7:
255,0,0
## end
#1397, 12:
187.0, 220.0
## end
#1398, 12:
153.0, 189.0
## end
#1404, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#1406, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1407, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1409, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1410, 14:
+[返回目录]
+[内容]

## end
#1413, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#1417, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#1418, 2:
直线
## end
#1419, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1420, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1426, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1436, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#1437, 12:
110.0, 146.0
## end
#1438, 12:
155.0, 189.5
## end
#1439, 7:
255,0,0
## end
#1440, 9:
SolidLine
## end
#1441, 1:
1
## end
#1447, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#1449, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1450, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1455, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1456, 2:
直线
## end
#1459, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#1460, 14:
+[返回目录]
+[内容]

## end
#1461, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1463, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1467, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#1469, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1479, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#1480, 12:
154.5, 188.5
## end
#1481, 13:
-130.5, 189.5
## end
#1482, 7:
255,0,0
## end
#1483, 9:
SolidLine
## end
#1484, 1:
1
## end
#1490, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#1492, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1493, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1498, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1499, 2:
直线
## end
#1502, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#1503, 14:
+[返回目录]
+[内容]

## end
#1504, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1506, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1510, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#1512, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1523, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#1524, 12:
220.0, 215.0
## end
#1525, 12:
155.0, 186.0
## end
#1526, 5:
0,0,0
## end
#1527, 8:
DashLine
## end
#1528, 1:
1
## end
#1534, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#1536, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1537, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1542, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1543, 2:
直线
## end
#1546, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#1547, 14:
+[返回目录]
+[内容]

## end
#1548, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1550, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1554, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#1556, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1566, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#1567, 12:
223.0, 219.5
## end
#1568, 13:
-159.0, 216.5
## end
#1569, 5:
0,0,0
## end
#1570, 8:
DashLine
## end
#1571, 1:
1
## end
#1577, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#1579, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1580, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1585, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1586, 2:
直线
## end
#1589, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#1590, 14:
+[返回目录]
+[内容]

## end
#1591, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1593, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1597, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#1599, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1609, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#1612, 1:
2
## end
#1613, 9:
SolidLine
## end
#1614, 5:
0,0,0
## end
#1615, 4:
None
## end
#1616, 3:
225
## end
#1617, 2:
75
## end
#1618, 12:
221.0, 219.0
## end
#1619, 3:
135
## end
#1628, 75:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
起始角度::30

## end
#1630, 519:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.beginPath();
ctx.arc(%中心,%半径,0,2*Math.PI)

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fill();
}

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(0,0,0)';
} else {
        ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        if('%线型'==='DashLine') {
            ctx.setLineDash([5,5])
        }
        ctx.stroke();
}

ctx.setLineDash([])

//ctx.stroke()

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1633, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#1634, 14:
+[返回目录]
+[内容]

## end
#1637, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#1638, 2:
圆形
## end
#1639, 760:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
angle_0=起始角度[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型


if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


an=np.linspace(angle_0,angle,20)
t=np.deg2rad(an)
x=pt[0]+r*np.cos(t)
y=pt[1]-r*np.sin(t)


path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())





## end
#1640, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#1646, 760:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
angle_0=起始角度[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型


if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


an=np.linspace(angle_0,angle,20)
t=np.deg2rad(an)
x=pt[0]+r*np.cos(t)
y=pt[1]-r*np.sin(t)


path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())





## end
#1664, 171:
+[返回目录](,圆形)

中心::200,100
半径::100
类型::圆形
角度::0
起始角度::30


面颜色::255,255,0
线颜色::None
线型::SolidLine
线粗细::2

画图:...
选中区域:...
HTML:...
+[创建输入](起始角度,画图)
的(画图,输入)->+[有](HTML,输入)

## end
#1665, 8:
DashLine
## end
#1666, 1:
1
## end
#1667, 5:
0,0,0
## end
#1668, 11:
207.0, 17.0
## end
#1669, 11:
207.0, 49.0
## end
#1675, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#1677, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1678, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1680, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1681, 14:
+[返回目录]
+[内容]

## end
#1684, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#1688, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#1689, 2:
直线
## end
#1690, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1691, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1697, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1707, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#1708, 4:
None
## end
#1709, 4:
None
## end
#1710, 9:
SolidLine
## end
#1711, 1:
2
## end
#1712, 1:
D
## end
#1713, 2:
10
## end
#1714, 10:
36.0, 40.5
## end
#1715, 12:
186.0, 39.75
## end
#1724, 101:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100

## end
#1726, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#1727, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#1732, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#1733, 2:
矩形
## end
#1734, 14:
+[返回目录]
+[内容]

## end
#1737, 231:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


## end
#1738, 14:
+[返回目录]
+[内容]

## end
#1741, 754:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细
        if('%线型'==='DashLine') {
            ctx.setLineDash([5,5])
        };
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

ctx.setLineDash([])

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1754, 149:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10

面颜色::255,255,255
线颜色::0,0,0
线型::SolidLine
线粗细::2

画图:...
选中区域:...
HTML:...



## end
#1755, 10:
36.0, 40.5
## end
#1756, 12:
-81.0, -8.25
## end
#1757, 2:
10
## end
#1758, 1:
C
## end
#1759, 1:
2
## end
#1760, 9:
SolidLine
## end
#1761, 4:
None
## end
#1762, 4:
None
## end
#1771, 101:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100

## end
#1772, 14:
+[返回目录]
+[内容]

## end
#1775, 754:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细
        if('%线型'==='DashLine') {
            ctx.setLineDash([5,5])
        };
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

ctx.setLineDash([])

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1776, 14:
+[返回目录]
+[内容]

## end
#1779, 231:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


## end
#1780, 2:
矩形
## end
#1781, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#1782, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#1788, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#1801, 149:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10

面颜色::255,255,255
线颜色::0,0,0
线型::SolidLine
线粗细::2

画图:...
选中区域:...
HTML:...



## end
#1802, 8:
DashLine
## end
#1803, 1:
1
## end
#1804, 5:
0,0,0
## end
#1805, 11:
151.0, 47.0
## end
#1806, 11:
207.0, 17.0
## end
#1812, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#1814, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1815, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1817, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1818, 14:
+[返回目录]
+[内容]

## end
#1821, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#1825, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#1826, 2:
直线
## end
#1827, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1828, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1834, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#1844, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#1845, 10:
36.0, 40.5
## end
#1846, 12:
159.0, 38.75
## end
#1847, 2:
10
## end
#1848, 1:
B
## end
#1849, 1:
2
## end
#1850, 9:
SolidLine
## end
#1851, 4:
None
## end
#1852, 4:
None
## end
#1861, 101:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100

## end
#1862, 14:
+[返回目录]
+[内容]

## end
#1865, 754:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细
        if('%线型'==='DashLine') {
            ctx.setLineDash([5,5])
        };
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

ctx.setLineDash([])

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1866, 14:
+[返回目录]
+[内容]

## end
#1869, 231:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


## end
#1870, 2:
矩形
## end
#1871, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#1872, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#1878, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#1891, 149:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10

面颜色::255,255,255
线颜色::0,0,0
线型::SolidLine
线粗细::2

画图:...
选中区域:...
HTML:...



## end
#1892, 4:
None
## end
#1893, 4:
None
## end
#1894, 9:
SolidLine
## end
#1895, 1:
2
## end
#1896, 1:
A
## end
#1897, 2:
10
## end
#1898, 10:
36.0, 40.5
## end
#1899, 13:
199.0, -10.25
## end
#1908, 101:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100

## end
#1910, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#1911, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#1916, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#1917, 2:
矩形
## end
#1918, 14:
+[返回目录]
+[内容]

## end
#1921, 231:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


## end
#1922, 14:
+[返回目录]
+[内容]

## end
#1925, 754:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细
        if('%线型'==='DashLine') {
            ctx.setLineDash([5,5])
        };
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

ctx.setLineDash([])

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1938, 149:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10

面颜色::255,255,255
线颜色::0,0,0
线型::SolidLine
线粗细::2

画图:...
选中区域:...
HTML:...



## end
#1939, 10:
36.0, 40.5
## end
#1940, 12:
127.0, 23.75
## end
#1941, 2:
10
## end
#1942, 1:
O
## end
#1943, 1:
2
## end
#1944, 9:
SolidLine
## end
#1945, 4:
None
## end
#1946, 4:
None
## end
#1955, 101:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100

## end
#1956, 14:
+[返回目录]
+[内容]

## end
#1959, 754:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细
        if('%线型'==='DashLine') {
            ctx.setLineDash([5,5])
        };
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

ctx.setLineDash([])

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1960, 14:
+[返回目录]
+[内容]

## end
#1963, 231:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


## end
#1964, 2:
矩形
## end
#1965, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#1966, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#1972, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#1985, 149:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10

面颜色::255,255,255
线颜色::0,0,0
线型::SolidLine
线粗细::2

画图:...
选中区域:...
HTML:...



## end
#1987, 9:
SolidLine
## end
#1988, 1:
1
## end
#1989, 5:
0,0,0
## end
#1990, 11:
-81.0, 81.0
## end
#1991, 11:
205.0, 81.0
## end
#1997, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#1999, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#2000, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#2002, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#2003, 14:
+[返回目录]
+[内容]

## end
#2006, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#2010, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#2011, 2:
直线
## end
#2012, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#2013, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#2019, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#2030, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#2036, 9:
SolidLine
## end
#2037, 1:
1
## end
#2038, 5:
0,0,0
## end
#2039, 11:
179.0, 50.0
## end
#2040, 11:
207.0, 81.0
## end
#2046, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#2048, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#2049, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#2051, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#2052, 14:
+[返回目录]
+[内容]

## end
#2055, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#2059, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#2060, 2:
直线
## end
#2061, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#2062, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#2068, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#2079, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#2082, 9:
SolidLine
## end
#2083, 1:
1
## end
#2084, 7:
255,0,0
## end
#2085, 11:
-79.0, 17.0
## end
#2086, 11:
206.0, 16.0
## end
#2092, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#2094, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#2095, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#2097, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#2098, 14:
+[返回目录]
+[内容]

## end
#2101, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#2105, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#2106, 2:
直线
## end
#2107, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#2108, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#2114, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#2125, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#2131, 9:
SolidLine
## end
#2132, 1:
1
## end
#2133, 7:
255,0,0
## end
#2134, 11:
177.5, 48.5
## end
#2135, 11:
206.5, 17.5
## end
#2141, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#2143, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#2144, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#2146, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#2147, 14:
+[返回目录]
+[内容]

## end
#2150, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#2154, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#2155, 2:
直线
## end
#2156, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#2157, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#2163, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#2174, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#2176, 3:
-45
## end
#2177, 37:
137.62540000000007, 48.97709999999995
## end
#2178, 2:
75
## end
#2179, 2:
45
## end
#2180, 4:
None
## end
#2181, 5:
0,0,0
## end
#2182, 9:
SolidLine
## end
#2183, 1:
2
## end
#2192, 75:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
起始角度::30

## end
#2194, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#2195, 760:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
angle_0=起始角度[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型


if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


an=np.linspace(angle_0,angle,20)
t=np.deg2rad(an)
x=pt[0]+r*np.cos(t)
y=pt[1]-r*np.sin(t)


path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())





## end
#2200, 760:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
angle_0=起始角度[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型


if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


an=np.linspace(angle_0,angle,20)
t=np.deg2rad(an)
x=pt[0]+r*np.cos(t)
y=pt[1]-r*np.sin(t)


path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())





## end
#2201, 2:
圆形
## end
#2202, 14:
+[返回目录]
+[内容]

## end
#2205, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#2208, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#2210, 519:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.beginPath();
ctx.arc(%中心,%半径,0,2*Math.PI)

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fill();
}

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(0,0,0)';
} else {
        ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        if('%线型'==='DashLine') {
            ctx.setLineDash([5,5])
        }
        ctx.stroke();
}

ctx.setLineDash([])

//ctx.stroke()

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#2226, 171:
+[返回目录](,圆形)

中心::200,100
半径::100
类型::圆形
角度::0
起始角度::30


面颜色::255,255,0
线颜色::None
线型::SolidLine
线粗细::2

画图:...
选中区域:...
HTML:...
+[创建输入](起始角度,画图)
的(画图,输入)->+[有](HTML,输入)

## end
#2227, 8:
DashLine
## end
#2228, 1:
1
## end
#2229, 5:
0,0,0
## end
#2230, 12:
-168.0, 46.5
## end
#2231, 11:
214.0, 49.5
## end
#2237, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#2239, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#2240, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#2242, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#2243, 14:
+[返回目录]
+[内容]

## end
#2246, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#2250, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#2251, 2:
直线
## end
#2252, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#2253, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#2259, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#2271, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#2321, 907:
+[返回目录](,凹透镜原理图)
+[显示星图](,凹透镜原理图)
+[删除结构](,凹透镜原理图)
+[新建阅读窗口](,凹透镜原理图)

+[画板](+新画板,凹透镜原理图)

的(圆弧,半径)->半径"-75"->+[修改内容]"75"(,半径)

有一个圆弧(-45,45), 过圆弧圆心和弧线中心有一条水平参考线. 
参考线上下分别有一道水平光线打到圆弧上, 反射光线相交于参考线上某一点. 
那个点是焦点, 标记焦点到圆弧中心的距离. 

中心(圆弧,)->[点](中心,)
[点](中心,)->[m_text]([点],+[显示])

+圆弧->+圆心(+圆弧,)->+中心(+圆弧,)->+焦点(+圆弧,)...
->+参考线->+经过(+参考线,+圆心)->+经过(+参考线,+中心)

+上面(参考线,+光线)->+水平(+光线,)->+反射(圆弧,+光线)...
->+于(+反射,+反射点)->+的(圆弧,+反射点)->+出(+反射,+光线#2)...
->+相交(+光线#2,参考线)->+于(+相交,焦点)

+下面(参考线,+光线)->+水平(+光线,)->+反射(圆弧,+光线)...
->+于(+反射,+反射点)->+的(圆弧,+反射点)->+出(+反射,+光线#2)...
->+相交(+光线#2,参考线)->+于(+相交,焦点)

+[创建圆弧](,圆弧)
上面(参考线,光线)->下面(参考线,光线#2)...
->+[创建直线](,参考线)->+[创建直线](,光线)->+[创建直线](,光线#2)

的(参考线,线型)->+[修改内容]"DashLine"(,线型)
上面的光线是红色的
上面(参考线,光线)->的(光线,线颜色)->+[修改内容]"255,0,0"(,线颜色)

上面光线反射出的光线是直线, 颜色是红色的
上面(,光线)->反射(,光线)->出(反射,光线#2)->+[创建直线](,光线#2)->+[设置结构](,光线#2)
上面光线反射出的光线是直线
下面(,光线)->反射(,光线)->出(反射,光线#2)->+[创建直线](,光线#2)


## end
#2323, 8:
DashLine
## end
#2324, 1:
1
## end
#2325, 7:
255,0,0
## end
#2326, 13:
206.75, 18.75
## end
#2327, 13:
107.25, 51.25
## end
#2333, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#2335, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#2336, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#2338, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#2339, 14:
+[返回目录]
+[内容]

## end
#2342, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#2346, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#2347, 2:
直线
## end
#2348, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#2349, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#2355, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#2365, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#2367, 4:
None
## end
#2368, 4:
None
## end
#2369, 9:
SolidLine
## end
#2370, 1:
2
## end
#2371, 3:
n_1
## end
#2372, 2:
10
## end
#2373, 10:
36.0, 40.5
## end
#2374, 12:
53.0, 112.75
## end
#2383, 101:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100

## end
#2385, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#2386, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#2391, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#2392, 2:
矩形
## end
#2393, 14:
+[返回目录]
+[内容]

## end
#2396, 231:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


## end
#2397, 14:
+[返回目录]
+[内容]

## end
#2400, 754:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细
        if('%线型'==='DashLine') {
            ctx.setLineDash([5,5])
        };
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

ctx.setLineDash([])

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#2413, 149:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10

面颜色::255,255,255
线颜色::0,0,0
线型::SolidLine
线粗细::2

画图:...
选中区域:...
HTML:...



## end
#2415, 10:
36.0, 40.5
## end
#2416, 13:
239.0, 113.75
## end
#2417, 2:
10
## end
#2418, 3:
n_2
## end
#2419, 1:
2
## end
#2420, 9:
SolidLine
## end
#2421, 4:
None
## end
#2422, 4:
None
## end
#2431, 101:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100

## end
#2432, 14:
+[返回目录]
+[内容]

## end
#2435, 754:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细
        if('%线型'==='DashLine') {
            ctx.setLineDash([5,5])
        };
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

ctx.setLineDash([])

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#2436, 14:
+[返回目录]
+[内容]

## end
#2439, 231:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


## end
#2440, 2:
矩形
## end
#2441, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#2442, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#2448, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#2461, 149:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10

面颜色::255,255,255
线颜色::0,0,0
线型::SolidLine
线粗细::2

画图:...
选中区域:...
HTML:...



## end
#2463, 4:
None
## end
#2464, 4:
None
## end
#2465, 9:
SolidLine
## end
#2466, 1:
2
## end
#2467, 1:
E
## end
#2468, 2:
10
## end
#2469, 10:
36.0, 40.5
## end
#2470, 12:
61.0, 139.75
## end
#2479, 101:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100

## end
#2481, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#2482, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#2487, 1007:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#2488, 2:
矩形
## end
#2489, 14:
+[返回目录]
+[内容]

## end
#2492, 231:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


## end
#2493, 14:
+[返回目录]
+[内容]

## end
#2496, 754:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细
        if('%线型'==='DashLine') {
            ctx.setLineDash([5,5])
        };
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

ctx.setLineDash([])

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#2509, 149:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10

面颜色::255,255,255
线颜色::0,0,0
线型::SolidLine
线粗细::2

画图:...
选中区域:...
HTML:...



## end
#2512, 988:
<!--
+[H函数](,传输矩阵)
-->
Here I want to discuss about the way to describe the propagation of the laser through a perfect lens. <br>
<br>
<b><u>Positive lens</u></b><br>
Assume now that the focus length of the positive lens is \(f\), the input point on the lens is \((x,y,z)\), and the input direction of the laser is \((k_x,k_y,k_z)\). Also the center of the lens is located at \((0,0,0)\). <br>
The focus point \(\vec{r}_f\) and the output directions \(\vec{k}_o\) are, 
$$
\vec{r}_f=(\frac{k_x}{k_z},\frac{k_y}{k_z},1)\cdot f
$$$$
\Delta x =\frac{k_x}{k_z}f-x
,\ 
\frac{\Delta x}{f}
=\frac{k_x}{k_z}-\frac{x}{f}
$$$$
\frac{\Delta y}{f}
=\frac{k_y}{k_z}-\frac{y}{f}
$$
If we set the \(k_z=1\), then, 
$$
\begin{cases}
k_{ox}=k_x-\frac{x}{f}
\\
k_{oy}=k_y-\frac{y}{f}
\\
k_{oz}=1
\end{cases}
$$
OK, we have the matrix now, which is, 
$$
T=
\left[
\begin{matrix}
1&0&-\frac{1}{f}&0
\\
0&1&0&-\frac{1}{f}
\\
0&0&1&0
\\
0&0&0&1
\end{matrix}
\right]
$$



<!--
测试传输矩阵(M函数):...
+[H函数](,传输矩阵)
-->
## end
#2514, 4:
2528
## end
#2517, 408:
%{
+[M函数](,测试传输矩阵)
%}

f=1;
t=linspace(0,360,10);
kx=1*ones(size(t));
ky=0*ones(size(t));
x=cosd(t);
y=sind(t);

Dz1=abs(f);
Dz2=3*abs(f);

input=[kx;ky;x;y];

T=[
1,0,-1/f,0;
0,1,0,-1/f;
0,0,1,0;
0,0,0,1;
]

output=T*input;
kox=output(1,:);
koy=output(2,:);
xo=output(3,:);
yo=output(4,:);

plot3([-Dz1;0;Dz2],[x-kx*Dz1;x;x+kox*Dz2],[y-ky*Dz1;y;y+koy*Dz2],'b')
axis equal
view([0,90])

%{
+[M函数](,测试传输矩阵)
%}
## end
#2519, 4:
2521
## end
### 结束