### 节点
地址, 的, 计算波前, 目录, 的, 的, 例1, 的, 例2, 的, 光场积分_初步, 的, 几何画板, 的, 抛物镜反射公式, html, 的, 抛物镜反射, 的, 的, 的, 的, 的, 的, 的, 的, C点, B点, A点, L3, L2, L1, 抛物线, 坐标系, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 选中区域, 的, 的, 输出, HTML, 的, 的, 输出, 输入, 的, 的, 的, 的, 的, 的, 起点, 尺寸, 类型, 原点, x坐标, y坐标, 可选, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 选中区域, 的, 的, 输出, HTML, 的, 的, 输出, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 起点, 尺寸, 类型, 线型, 线粗细, 面颜色, 线颜色, 中心位置, 分辨率, 函数, 可选, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, HTML, 的, 选中区域, 的, 的, 输入, 的, 的, 输出, 类型, 画图, 的, 的, 的, 的, 图形, 选中框, 输出, 输入, 的, 的, 的, 的, 的, 的, 的, 线粗细, 线型, 线颜色, 面颜色, 角度, 半径, 中心, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, HTML, 的, 选中区域, 的, 的, 输入, 的, 的, 输出, 类型, 画图, 的, 的, 的, 的, 图形, 选中框, 输出, 输入, 的, 的, 的, 的, 的, 的, 的, 线粗细, 线型, 线颜色, 面颜色, 角度, 半径, 中心, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, HTML, 的, 选中区域, 的, 的, 输入, 的, 的, 输出, 类型, 画图, 的, 的, 的, 的, 图形, 选中框, 输出, 输入, 的, 的, 的, 的, 的, 的, 的, 线粗细, 线型, 线颜色, 面颜色, 角度, 半径, 中心, 比例, 的, 尺寸, 的, 原点, 的, 坐标系, 比例, 的, 尺寸, 的, 原点, 的, 坐标系, 的, 的, 的, 的, 的, 的, 的, 的, 是, 是, 是, 是, 到达, 引出, 到达, 引出, 的, 的, 的, 于, 相切, 上面, 的, 的, 的, 相同, 夹角, 夹角, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 起始角度, 半径, 中心, 数值, 标记, 的, 的, 的, 的, 的, 输入, 的, HTML, 的, 画图, 等于, pt11, 等于, pt12, 等于, pt21, 等于, pt22, 等于, angle, 的, 的, 的, 的, 的, 的, 的, 输出, 的, 的, 的, 的, 的, 的, 的, 输入, 的, 的, P代码, 类型, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 起始角度, 半径, 中心, 数值, 标记, 的, 的, 的, 的, 的, 输入, 的, HTML, 的, 画图, 等于, pt11, 等于, pt12, 等于, pt21, 等于, pt22, 等于, angle, 的, 的, 的, 的, 的, 的, 的, 输出, 的, 的, 的, 的, 的, 的, 的, 输入, 的, 的, P代码, 类型, 的, 节点数目统计, 20210528, 的, 数值, 类型, 起始角度, 中心, 等于, angle, 等于, pt22, 等于, pt21, 等于, pt12, 等于, pt11, 的, 的, 的, 的, 的, 的, 的, 输出, 的, 的, 的, 的, 的, 的, 的, 输入, 的, 的, P代码, 半径, 标记, 的, 的, 的, 的, 的, 输入, 的, 画图, 的, HTML, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 相同, 夹角, 数值, 类型, 起始角度, 中心, 等于, angle, 等于, pt22, 等于, pt21, 等于, pt12, 等于, pt11, 的, 的, 的, 的, 的, 的, 的, 输出, 的, 的, 的, 的, 的, 的, 的, 输入, 的, 的, P代码, 半径, 标记, 的, 的, 的, 的, 的, 输入, 的, 画图, 的, HTML, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 夹角, 上面, 于, 相切, 引出, 到达, 引出, 到达, 是, 是, 是, 是, m_select, m_drawing, m_t, m_dt, m_pos, m_size, m_unit, m_origin, m_mouse, m_scene, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 新窗口, m_select, m_drawing, m_t, m_dt, m_pos, m_size, m_unit, m_origin, m_mouse, m_scene, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 新窗口, 可选, y坐标, x坐标, 原点, 类型, 尺寸, 起点, 的, 的, 的, 的, 的, 的, 输入, 输出, 的, 的, HTML, 输出, 的, 的, 选中区域, 图形, 选中框, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 坐标系, 可选, 函数, 分辨率, 中心位置, 线颜色, 面颜色, 线粗细, 线型, 类型, 尺寸, 起点, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 输入, 输出, 的, 的, HTML, 输出, 的, 的, 选中区域, 图形, 选中框, 输出, 的, 的, 的, 的, 画图, 的, 的, 坐标系, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 圆弧, 线型, 线粗细, 线颜色, 终点, 起点, 的, 的, 的, 的, 的, 输入, 的, HTML, LaTeX数学记号, 的, 点线公式, 输出, 的, 的, 输入, 的, 的, 的, 选中区域, 类型, 选中框, 图形, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, L1, 线型, 线粗细, 线颜色, 终点, 起点, 的, 的, 的, 的, 的, 输入, 的, HTML, LaTeX数学记号, 的, 点线公式, 输出, 的, 的, 输入, 的, 的, 的, 选中区域, 类型, 选中框, 图形, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, L2, 线型, 线粗细, 线颜色, 终点, 起点, 的, 的, 的, 的, 的, 输入, 的, HTML, LaTeX数学记号, 的, 点线公式, 输出, 的, 的, 输入, 的, 的, 的, 选中区域, 类型, 选中框, 图形, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, L3, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 的, 的, 的, 的, 的, 的, 的, 输入, 输出, 选中框, 图形, 的, 的, 的, 的, 画图, 类型, 输出, 的, 的, 输入, 的, 的, 选中区域, 的, HTML, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, A点, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 的, 的, 的, 的, 的, 的, 的, 输入, 输出, 选中框, 图形, 的, 的, 的, 的, 画图, 类型, 输出, 的, 的, 输入, 的, 的, 选中区域, 的, HTML, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, B点, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 的, 的, 的, 的, 的, 的, 的, 输入, 输出, 选中框, 图形, 的, 的, 的, 的, 画图, 类型, 输出, 的, 的, 输入, 的, 的, 选中区域, 的, HTML, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, C点, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 坐标系, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 球面镜反射, 的, 的, 抛物镜反射, 画板, 比例, 的, 尺寸, 的, 原点, 的, 坐标系, 20210529, 的, 的, 验证算法, M函数, 20210530, 的, 的, Reflect_parabola, M函数, 的, 地址, 的, 抛物型柱面镜反射, M函数, 的, 三维场景, 的, Reflection_parabola_3D, M函数, 的, 地址, 的, 备份, 20210531, 的, 20210601, 的, 20210603, 的, 的, 平面镜反射公式, html, 的, Reflection_plane_3D, M函数, 的, 地址, 的, 测试, M函数, 的, 网页画板, 20210710, 的, 的, 场景测试, 的, 参考, 的, 场景, 的, 光路, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 经过, 经过, 经过, 经过, 经过, G2, CM2, BBO, CM1, G1, 的, 星图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 空间点, 在, 空间点, 在, 空间点, 在, 空间点, 在, 空间点, 在, 的, 的, 反射, 反射, 的, 场景画板, 是, 是, 是, 是, 是, 新, 是, 是, 是, 是, 是, 新, 是, 是, 是, 是, 是, 新, 比例, 的, 尺寸, 的, 原点, 的, 坐标系, 的, 的, 的, 的, 的, 的, 的, 的, 是, 高, 的, 厚度, 的, 宽, 晶体, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 是, 是, 高, 的, 厚度, 的, 宽, 光栅, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 是, 是, 焦距, 的, 高, 的, 厚度, 的, 宽, 柱面镜, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 方向, 朝着, 方向, 朝着, 方向, 朝着, 方向, 朝着, 方向, 朝着, 的, 三维场景, 的, 的, 反射, 反射, 是, 是, 是, 是, 是, 新, 是, 是, 是, 是, 是, 新, 是, 是, 是, 是, 是, 新, 是, G1, 的, 是, CM1, 的, 是, BBO, 的, 是, CM2, 的, 是, G2, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 选中框, 图形, 类型, 选中区域, 的, 的, 输出, 输入, 的, 的, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 光线, 的, 光线, 的, 光线, 的, 光线, 的, 光线, 光路, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 焦点, 直径, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 焦点, 直径, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 焦点, 直径, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 焦点, 直径, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 图形, 选中框, 类型, 选中区域, 的, 的, 的, 输入, 的, 的, 的, 输出, 点线公式, 的, LaTeX数学记号, HTML, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线粗细, 线型, 焦点, 直径, 的, 新, 的, 绘制光路图, 20210712, 的, 的, 的, 的, 的, 的, 的, 的, 的, 空间点, 在, 输出, 的, 空间点, 在, 输入, 的, 元件, 光线光路, 的, 的, 的, 的, 的, 的, 元件, 光线光路, 的, 的, 的, 的, 的, 的, 输入, 输入, 输入, 输入, 输入, 20210713, 的, 的, 光路场景, 20210714, 的, 的, 对比高斯光束, 的, 高斯光束, 的, 高斯光束解析解, html, 的, 光场分布函数, M函数, 的, 高斯光束光场分布, M函数, 的, GaussianBeam, M函数, 的, 地址, 的, 存档, M函数, 的, 参考, 的, 超链接, 20210715, 的, 的, 菲涅尔积分, html, 的, 超链接, 的, 参考, 的, 参考2, 的, 正向积分, M函数, 20210716, 的, 的, Jackson, 20210717, 的, 的, 备份, 的, 蒙卡模拟, 的, 测试发射轨迹, M函数, 的, 例子_高斯光束, M函数, 20210719, 的, 的, 柱面镜模拟, M函数, 的, 显示场景, M函数, 的, 的, 20210720Debug, M函数, 20210720, 的, 的, 测试, M函数, 20210721, 的, 的, 直接模拟, M函数, 的, 平面镜对比_r, M函数, 的, 平面镜扰动, M函数, 20210722, 的, 的, 动词, 蒙卡元件模板, 蒙卡整体模板, 透射步骤, 反射步骤, 分光步骤, 入射步骤, 这些事情, 的, 的, 的, 的, 的, 的, 的, S代码, 操作序列, 的, 逻辑结构转波前模拟, 的, 的, 蒙卡元件代码, 的, M代码, 的, 元件场景, 的, Blender输出, 的, 地址, 的, 20210729, 的, 20210730, 的, 20210731, 的, 20210921, 的, 20211031, 的, 20211106, 的, 的, WavefrontPropagation, M函数, 的, 地址, 的, 透镜组场景, M函数, 的, 直线交点, 20220125, 的, 的, 记忆, 的, 的, 当前问题, 的, 20220222, 的, 菲涅尔积分, 的, 20220223, 的, WavefrontPropagation, 的, 答案, 回答, 20220317, 的, 20220803, 的, WavefrontPropagation, 20220804, 的, 的, 的, WavefrontPropagation, 中, 
### 关联
#, 2#0, #, #, 3#2, 2#6, #, 2#8, #, 2#10, #, 2#12, #, 2#14, #, 14#, 14#17, #, 17#26, 17#27, 17#28, 17#29, 17#30, 17#31, 17#32, 17#33, #, #, #, #, #, #, #, #, 33#44, 33#52, 33#56, 33#67, 33#68, 33#69, 33#70, 33#71, 33#72, 33#73, #, 44#60, 44#49, 44#50, 44#51, #, #, #, #, 52#55, 52#60, #, #, 56#59, 56#60, #, #, 60#68, 60#67, 60#70, 60#71, 60#72, 60#73, #, #, #, #, #, #, #, 32#88, 32#96, 32#100, 32#115, 32#116, 32#117, 32#118, 32#119, 32#120, 32#121, 32#122, 32#123, 32#124, 32#125, #, 88#104, 88#93, 88#94, 88#95, #, #, #, #, 96#99, 96#104, #, #, 100#103, 100#104, #, #, 104#120, 104#121, 104#118, 104#119, 104#116, 104#115, 104#122, 104#123, 104#124, 104#125, #, #, #, #, #, #, #, #, #, #, #, 31#163, 31#164, 31#135, 31#143, 31#144, 31#165, 31#166, 31#155, 31#167, #, 135#157, 135#140, 135#141, 135#142, #, #, #, #, #, 144#148, 144#151, 144#152, #, 148#163, 148#164, #, #, 152#154, #, #, 155#157, #, 157#163, 157#164, 157#165, 157#167, 157#166, #, #, #, #, #, 30#205, 30#206, 30#177, 30#185, 30#186, 30#207, 30#208, 30#197, 30#209, #, 177#199, 177#182, 177#183, 177#184, #, #, #, #, #, 186#190, 186#193, 186#194, #, 190#205, 190#206, #, #, 194#196, #, #, 197#199, #, 199#205, 199#206, 199#207, 199#209, 199#208, #, #, #, #, #, 29#247, 29#248, 29#219, 29#227, 29#228, 29#249, 29#250, 29#239, 29#251, #, 219#241, 219#224, 219#225, 219#226, #, #, #, #, #, 228#232, 228#235, 228#236, #, 232#247, 232#248, #, #, 236#238, #, #, 239#241, #, 241#247, 241#248, 241#249, 241#251, 241#250, #, #, #, #, #, 28#263, 28#289, 28#290, 28#291, 28#292, 28#265, 28#293, 28#272, 28#273, 28#294, 28#295, #, 263#281, #, 265#268, 265#271, #, 268#294, 268#295, #, #, #, 273#278, 273#279, 273#280, 273#281, #, #, #, #, 281#289, 281#290, 281#291, 281#292, 281#293, 281#294, 281#295, #, #, #, #, #, #, #, 27#307, 27#333, 27#334, 27#335, 27#336, 27#309, 27#337, 27#316, 27#317, 27#338, 27#339, #, 307#325, #, 309#312, 309#315, #, 312#338, 312#339, #, #, #, 317#322, 317#323, 317#324, 317#325, #, #, #, #, 325#333, 325#334, 325#335, 325#336, 325#337, 325#338, 325#339, #, #, #, #, #, #, #, 26#351, 26#377, 26#378, 26#379, 26#380, 26#353, 26#381, 26#360, 26#361, 26#382, 26#383, #, 351#369, #, 353#356, 353#359, #, 356#382, 356#383, #, #, #, 361#366, 361#367, 361#368, 361#369, #, #, #, #, 369#377, 369#378, 369#379, 369#380, 369#381, 369#382, 369#383, #, #, #, #, #, #, #, #, 390#384, #, 390#386, #, 390#388, 32#, #, 397#391, #, 397#393, #, 397#395, 17#, 17#406, 17#407, 17#408, 17#409, 17#410, 17#411, 17#412, 17#413, 383#248, 339#247, 339#164, 295#163, 29#26, 27#29, 31#27, 28#31, 17#417, 17#418, 17#419, 418#27, 30#32, 27#32, 17#423, 17#424, 17#425, 425#424, 30#29, 30#31, 425#448, 425#489, 425#488, 425#469, 425#468, 425#467, 425#466, 425#465, 425#464, 425#463, 425#462, 425#461, 425#460, 425#459, 425#449, 425#457, 425#447, 425#446, 425#445, #, #, #, #, #, 455#448, 455#445, 455#446, 455#447, 455#449, #, 457#455, #, 459#455, #, 461#205, #, 463#206, #, 465#163, #, 467#164, #, 469#448, #, 477#445, 477#447, 477#469, 477#467, 477#465, 477#463, 477#461, #, 485#461, 485#463, 485#465, 485#467, 485#469, 485#447, 485#445, #, 488#477, 488#485, #, #, 424#512, 424#553, 424#552, 424#533, 424#532, 424#531, 424#530, 424#529, 424#528, 424#527, 424#526, 424#525, 424#524, 424#523, 424#513, 424#521, 424#511, 424#510, 424#509, #, #, #, #, #, 519#512, 519#509, 519#510, 519#511, 519#513, #, 521#519, #, 523#519, #, 525#205, #, 527#206, #, 529#247, #, 531#248, #, 533#512, #, 541#509, 541#511, 541#533, 541#531, 541#529, 541#527, 541#525, #, 549#525, 549#527, 549#529, 549#531, 549#533, 549#511, 549#509, #, 552#541, 552#549, #, #, 3#555, #, #, 555#556, #, #, #, #, 563#558, #, 565#840, #, 567#841, #, 569#883, #, 571#884, #, 579#560, 579#561, 579#563, 579#565, 579#567, 579#569, 579#571, #, 587#571, 587#569, 587#567, 587#565, 587#563, 587#561, 587#560, #, 590#579, 590#587, #, #, #, 598#558, 598#560, 598#591, 598#561, 598#592, #, 600#598, #, 602#598, #, 623#558, 623#559, 623#590, 623#563, 623#562, 623#565, 623#564, 623#567, 623#566, 623#569, 623#568, 623#571, 623#570, 623#600, 623#592, 623#602, 623#561, 623#591, 623#560, 623#688, 922#879, #, #, #, #, 629#624, #, 631#926, #, 633#927, #, 635#883, #, 637#884, #, 645#626, 645#627, 645#629, 645#631, 645#633, 645#635, 645#637, #, 653#637, 653#635, 653#633, 653#631, 653#629, 653#627, 653#626, #, 656#645, 656#653, #, #, #, 664#624, 664#626, 664#657, 664#627, 664#658, #, 666#664, #, 668#664, #, 688#624, 688#625, 688#656, 688#629, 688#628, 688#631, 688#630, 688#633, 688#632, 688#635, 688#634, 688#637, 688#636, 688#666, 688#658, 688#668, 688#627, 688#657, 688#626, 922#965, 1055#836, 691#1055, 922#836, 1010#879, 879#1055, 1055#965, 965#1100, 966#841, 1011#840, 1011#927, 1056#926, #, #, #, #, #, #, #, #, #, #1126, 720#700, 720#701, 720#702, 720#703, 720#704, 720#705, 720#706, 720#707, 720#708, 720#709, #, #, #, #, #, #, #, #, #, #, #836, 741#721, 741#722, 741#723, 741#724, 741#725, 741#726, 741#727, 741#728, 741#729, 741#730, #, #, #, #, #, #, #, #, 755#742, 755#743, 755#744, 755#745, 755#748, 755#747, #, #, 759#755, 759#756, #, #, 763#755, 763#760, #, #, #, #, 771#764, 771#765, 771#766, 771#755, #, 782#742, 782#743, 782#744, 782#745, 782#746, 782#747, 782#748, 782#759, 782#763, 782#771, #, #, #, #, #, #, #, #, #, #, #, #, 804#783, 804#784, 804#785, 804#786, 804#793, 804#792, 804#789, 804#790, 804#787, 804#788, #, #, 808#804, 808#805, #, #, 812#804, 812#809, #, #, #, #, 820#813, 820#814, 820#815, 820#804, #, 836#783, 836#784, 836#, 836#785, 836#786, 836#787, 836#788, 836#789, 836#790, 836#791, 836#792, 836#793, 836#808, 836#812, 836#820, #, #, #, #, #, #, 847#838, 847#837, 847#839, 847#840, 847#841, #, 849#847, #, #, 852#850, #, #, 856#840, 856#841, #, 860#852, 860#853, 860#856, #, #, #, #, #, 869#862, 869#863, 869#864, 869#847, #, 879#837, 879#849, 879#838, 879#839, 879#860, 879#861, 879#869, 879#840, 879#841, #, #, #, #, #, #, 890#881, 890#880, 890#882, 890#883, 890#884, #, 892#890, #, #, 895#893, #, #, 899#883, 899#884, #, 903#895, 903#896, 903#899, #, #, #, #, #, 912#905, 912#906, 912#907, 912#890, #, 922#880, 922#892, 922#881, 922#882, 922#903, 922#904, 922#912, 922#883, 922#884, #, #, #, #, #, #, 933#924, 933#923, 933#925, 933#926, 933#927, #, 935#933, #, #, 938#936, #, #, 942#926, 942#927, #, 946#938, 946#939, 946#942, #, #, #, #, #, 955#948, 955#949, 955#950, 955#933, #, 965#923, 965#935, 965#924, 965#925, 965#946, 965#947, 965#955, 965#926, 965#927, #, #, #, #, #, #, #, #, 980#966, 980#967, 980#968, 980#969, 980#970, 980#971, 980#972, #, #, #, #, 988#980, 988#981, 988#982, 988#983, #, #, #, 993#966, 993#967, #, 996#990, 996#993, #, 998#980, #, 1010#966, 1010#967, 1010#988, 1010#989, 1010#968, 1010#996, 1010#969, 1010#970, 1010#971, 1010#972, 1010#998, #, #, #, #, #, #, #, #, 1025#1011, 1025#1012, 1025#1013, 1025#1014, 1025#1015, 1025#1016, 1025#1017, #, #, #, #, 1033#1025, 1033#1026, 1033#1027, 1033#1028, #, #, #, 1038#1011, 1038#1012, #, 1041#1035, 1041#1038, #, 1043#1025, #, 1055#1011, 1055#1012, 1055#1033, 1055#1034, 1055#1013, 1055#1041, 1055#1014, 1055#1015, 1055#1016, 1055#1017, 1055#1043, #, #, #, #, #, #, #, #, 1070#1056, 1070#1057, 1070#1058, 1070#1059, 1070#1060, 1070#1061, 1070#1062, #, #, #, #, 1078#1070, 1078#1071, 1078#1072, 1078#1073, #, #, #, 1083#1056, 1083#1057, #, 1086#1080, 1086#1083, #, 1088#1070, #, 1100#1056, 1100#1057, 1100#1078, 1100#1079, 1100#1058, 1100#1086, 1100#1059, 1100#1060, 1100#1061, 1100#1062, 1100#1088, #, 1126#623, 1126#688, 1126#622, 1126#689, 1126#691, 1126#690, 1126#692, 1126#693, 1126#694, 1126#695, 1126#696, 1126#697, 1126#698, 1126#699, 1126#, 1126#720, 1126#741, 1126#782, 1126#836, 1126#879, 1126#922, 1126#965, 1126#1010, 1126#1055, 1126#1100, #, 14#1126, 14#1129, #, 1129#, #, 1137#1131, #, 1137#1133, #, 1137#1135, 1126#, #, 555#1138, 14#1141, #, 1141#, #, 555#1143, 1141#1146, #, 1146#, 1146#1149, #, 14#1151, #, 1151#, 14#1154, #, 1151#1156, #, 1156#, 1156#1159, #, 1151#1161, #, #, 555#1162, #, 555#1164, #, 555#1166, 2#1169, #, 1169#, 1169#1172, #, 1172#, 1172#1175, #, 1172#1177, #, 1177#, 2#1180, #, #, 555#1181, 2#1184, #, 1184#1186, #, 1184#1188, #, 1188#1190, #, 1188#1201, 1188#1202, 1188#1203, 1188#1204, 1188#1205, 1188#1206, 1188#1207, 1188#1208, 1188#1209, 1188#1210, 1190#1206, 1190#1207, 1190#1208, 1190#1209, 1190#1210, #, #, #, #, #, 2#1212, #, 1188#1223, 1188#1224, 1188#1225, 1188#1226, 1188#1227, 1188#1228, 1188#1229, 1188#1230, 1188#1231, 1188#1232, #, 1206#1223, #, 1207#1225, #, 1208#1227, #, 1209#1229, #, 1210#1231, 1188#1235, 1188#1236, 1207#1190, 1209#1190, 1184#1238, #, 1210#, 1209#, 1208#, 1207#, 1206#, #, 1210#, 1209#, 1208#, 1207#, 1206#, #, 1210#, 1209#, 1208#, 1207#, 1206#, #, #, 1263#1257, #, 1263#1259, #, 1263#1261, 1238#, 1188#1272, 1188#1273, 1188#1274, 1188#1275, 1188#1276, 1188#1277, 1188#1278, 1188#1279, 1208#1278, #, 1278#1273, #, 1278#1275, #, #, 1278#1277, 1188#1289, 1188#1290, 1188#1291, 1188#1292, 1188#1293, 1188#1294, 1188#1295, 1188#1296, 1188#1297, 1206#1296, 1210#1296, #, 1296#1291, #, 1296#1293, #, #, 1296#1295, 1188#1309, 1188#1310, 1188#1311, 1188#1312, 1188#1313, 1188#1314, 1188#1315, 1188#1316, 1188#1317, 1188#1318, 1188#1319, 1207#1318, 1209#1318, #, 1318#1311, #, 1318#1313, #, 1318#1315, #, #, 1318#1317, 1188#1330, 1188#1331, 1188#1332, 1188#1333, 1188#1334, 1188#1335, 1188#1336, 1188#1337, 1188#1338, 1188#1339, #, 1207#1330, #, 1209#1332, #, 1206#1334, #, 1210#1336, #, 1208#1338, 2#1341, #, 1188#1344, 1188#1345, 1206#1190, 1210#1190, 1210#, 1209#, 1208#, 1207#, 1206#, #, 1210#, 1209#, 1208#, 1207#, 1206#, #, 1210#, 1209#, 1208#, 1207#, 1206#, #, 1210#1365, #, 1238#1365, 1209#1368, #, 1238#1368, 1208#1371, #, 1238#1371, 1207#1374, #, 1238#1374, 1206#1377, #, 1238#1377, 1377#1420, 1377#1421, 1377#1422, 1377#1392, 1377#1400, 1377#1423, 1377#1401, 1377#1424, 1377#1425, 1377#1426, 1377#1427, 1377#1428, 1377#1408, #, 1392#1410, 1392#1397, 1392#1398, 1392#1399, #, #, #, #, #, 1401#1404, 1401#1405, #, #, 1405#1421, 1405#1422, #, 1408#1410, #, 1410#1420, 1410#1421, 1410#1422, 1410#1423, 1410#1424, 1410#1425, 1410#1426, 1410#1427, 1410#1428, #, #, #, #, #, #, #, #, #, 1374#1470, 1374#1471, 1374#1472, 1374#1442, 1374#1450, 1374#1473, 1374#1451, 1374#1474, 1374#1475, 1374#1476, 1374#1477, 1374#1478, 1374#1458, #, 1442#1460, 1442#1447, 1442#1448, 1442#1449, #, #, #, #, #, 1451#1454, 1451#1455, #, #, 1455#1471, 1455#1472, #, 1458#1460, #, 1460#1470, 1460#1471, 1460#1472, 1460#1473, 1460#1474, 1460#1475, 1460#1476, 1460#1477, 1460#1478, #, #, #, #, #, #, #, #, #, 1371#1520, 1371#1521, 1371#1522, 1371#1492, 1371#1500, 1371#1523, 1371#1501, 1371#1524, 1371#1525, 1371#1526, 1371#1527, 1371#1528, 1371#1508, #, 1492#1510, 1492#1497, 1492#1498, 1492#1499, #, #, #, #, #, 1501#1504, 1501#1505, #, #, 1505#1521, 1505#1522, #, 1508#1510, #, 1510#1520, 1510#1521, 1510#1522, 1510#1523, 1510#1524, 1510#1525, 1510#1526, 1510#1527, 1510#1528, #, #, #, #, #, #, #, #, #, 1368#1570, 1368#1571, 1368#1572, 1368#1542, 1368#1550, 1368#1573, 1368#1551, 1368#1574, 1368#1575, 1368#1576, 1368#1577, 1368#1578, 1368#1558, #, 1542#1560, 1542#1547, 1542#1548, 1542#1549, #, #, #, #, #, 1551#1554, 1551#1555, #, #, 1555#1571, 1555#1572, #, 1558#1560, #, 1560#1570, 1560#1571, 1560#1572, 1560#1573, 1560#1574, 1560#1575, 1560#1576, 1560#1577, 1560#1578, #, #, #, #, #, #, #, #, #, 1365#1620, 1365#1621, 1365#1622, 1365#1592, 1365#1600, 1365#1623, 1365#1601, 1365#1624, 1365#1625, 1365#1626, 1365#1627, 1365#1628, 1365#1608, #, 1592#1610, 1592#1597, 1592#1598, 1592#1599, #, #, #, #, #, 1601#1604, 1601#1605, #, #, 1605#1621, 1605#1622, #, 1608#1610, #, 1610#1620, 1610#1621, 1610#1622, 1610#1623, 1610#1624, 1610#1625, 1610#1626, 1610#1627, 1610#1628, #, #, #, #, #, #, #, #, #, 1238#1630, #, 1238#1632, #, 1238#1634, #, 1238#1636, #, 1238#1638, #, #, 1238#1639, 1638#1683, 1638#1684, 1638#1652, 1638#1660, 1638#1661, 1638#1685, 1638#1686, 1638#1673, 1638#1687, 1638#1688, 1638#1689, #, 1652#1675, 1652#1657, 1652#1658, 1652#1659, #, #, #, #, #, 1661#1665, 1661#1669, 1661#1670, #, 1665#1683, 1665#1684, 1665#1689, #, #, 1670#1672, #, #, 1673#1675, #, 1675#1683, 1675#1684, 1675#1685, 1675#1687, 1675#1686, 1675#1688, 1675#1689, #, #, #, #, #, #, #, 1639#1638, 1636#1733, 1636#1734, 1636#1702, 1636#1710, 1636#1711, 1636#1735, 1636#1736, 1636#1723, 1636#1737, 1636#1738, 1636#1739, #, 1702#1725, 1702#1707, 1702#1708, 1702#1709, #, #, #, #, #, 1711#1715, 1711#1719, 1711#1720, #, 1715#1733, 1715#1734, 1715#1739, #, #, 1720#1722, #, #, 1723#1725, #, 1725#1733, 1725#1734, 1725#1735, 1725#1737, 1725#1736, 1725#1738, 1725#1739, #, #, #, #, #, #, #, 1639#1636, 1634#1783, 1634#1784, 1634#1752, 1634#1760, 1634#1761, 1634#1785, 1634#1786, 1634#1773, 1634#1787, 1634#1788, 1634#1789, #, 1752#1775, 1752#1757, 1752#1758, 1752#1759, #, #, #, #, #, 1761#1765, 1761#1769, 1761#1770, #, 1765#1783, 1765#1784, 1765#1789, #, #, 1770#1772, #, #, 1773#1775, #, 1775#1783, 1775#1784, 1775#1785, 1775#1787, 1775#1786, 1775#1788, 1775#1789, #, #, #, #, #, #, #, 1639#1634, 1632#1833, 1632#1834, 1632#1802, 1632#1810, 1632#1811, 1632#1835, 1632#1836, 1632#1823, 1632#1837, 1632#1838, 1632#1839, #, 1802#1825, 1802#1807, 1802#1808, 1802#1809, #, #, #, #, #, 1811#1815, 1811#1819, 1811#1820, #, 1815#1833, 1815#1834, 1815#1839, #, #, 1820#1822, #, #, 1823#1825, #, 1825#1833, 1825#1834, 1825#1835, 1825#1837, 1825#1836, 1825#1838, 1825#1839, #, #, #, #, #, #, #, 1639#1632, 1630#1883, 1630#1884, 1630#1852, 1630#1860, 1630#1861, 1630#1885, 1630#1886, 1630#1873, 1630#1887, 1630#1888, 1630#1889, #, 1852#1875, 1852#1857, 1852#1858, 1852#1859, #, #, #, #, #, 1861#1865, 1861#1869, 1861#1870, #, 1865#1883, 1865#1884, 1865#1889, #, #, 1870#1872, #, #, 1873#1875, #, 1875#1883, 1875#1884, 1875#1885, 1875#1887, 1875#1886, 1875#1888, 1875#1889, #, #, #, #, #, #, #, 1639#1630, 1639#1630, 2#1893, #, #, 555#1894, 1188#1904, 1188#1905, 1188#1906, 1188#1907, 1188#1908, 1188#1909, 1188#1910, 1188#1911, #, 1906#1904, #, 1190#1906, #, 1910#1908, #, 1190#1910, #, #, 1912#1210, 1912#1209, 1912#1208, 1912#1207, 1912#1206, 1913#1190, #, #, 1920#1210, 1920#1209, 1920#1208, 1920#1207, 1920#1206, 1921#1190, #, #, #, #, #, #, 555#1933, 2#1936, #, #, 555#1937, 2#1940, #, 1940#1942, #, 1940#1944, #, 1944#, 1944#1947, #, 1947#, 1947#1950, #, 1950#, 1947#1953, #, 1953#, 1953#1956, #, 1947#1958, #, 1958#, 1944#1961, #, 1944#1963, 1961#, #, 555#1964, 1940#1967, #, 1967#, 1944#1970, 1961#, 1967#1972, #, 1967#1974, #, 1967#1976, #, 1976#, #, 555#1978, 1967#1981, #, #, 555#1982, 1976#1985, #, 1940#1987, #, 1987#1989, #, 1989#, 1987#1992, #, 1992#, #, 555#1994, 1987#1997, #, 1997#, 1997#2000, #, 2000#, 1987#14, 1151#2004, #, 2004#, #, 555#2006, 1156#2009, #, 2009#, #, 555#2011, 1997#2014, #, 2014#, 1997#2017, #, 2017#, 1997#2020, #, 2020#, #, 555#2022, 2#2025, #, #, #, #, #, #, #, #, 2041#2026, 2041#2027, 2041#2028, 2041#2029, 2041#2030, 2041#2031, 2041#2032, 2041#, #, 2043#2041, #, 2025#2043, 2025#2046, #, 2046#2048, #, 2041#2050, #, 1184#2052, #, 1184#2054, #, 2052#2054, #, 555#2056, #, 555#2058, #, 555#2060, #, 555#2062, #, 555#2064, #, 555#2066, 1976#2069, #, 2069#, 2069#2072, #, 1976#2074, #, 2074#, 1169#2077, #, #, 555#2078, 2074#2081, 3#, 2074#2084, 2074#2085, #2074, 2081#2084, #, 555#2086, #1967, 2081#2088, #, 555#2090, #2069, 2081#2092, #, 2#, #, 555#2096, #, 555#2098, #, #, 555#2101, del#2106, del#2105, #, del#2105, 
### 内容
#0, 17:
文档\物理问题\计算波前.ftxt
## end
#2, 694:
+[返回目录](,计算波前)
地址::文档\物理问题\计算波前.ftxt

绘制光路图::文档\S应用\绘制光路图.ftxt
+[打开文件](+新窗口,绘制光路图)
网页画板::文档\S应用\网页画板.ftxt
+[打开文件](+新窗口,网页画板)
几何画板::文档\S应用\几何样本库.ftxt
+[打开文件](+新窗口,几何画板)
星图::文档\S应用\星图.txt
+[打开文件](+新窗口,星图)
三维场景::文档\S应用\三维建模.ftxt
+[打开文件](+新窗口,三维场景)
光路场景::文档\S应用\光路场景.ftxt
+[打开文件](+新窗口,光路场景)
Nini, 打开透镜波前(文件)


动词:...
+[设置动词](,动词)



例1::https://www.ucl.ac.uk/~ucapikr/projects/Dominic_report.pdf
例2::https://ischebeck.net/presentations/Zemax.pdf#page=17
+[打开网页](,例2)

用菲涅尔公式计算波前. 
有三点比较关键: 
1.计算菲涅尔积分的程序(就是个格林函数求和); 
2.计算两点间的路程长度; 
3.将场景描述转换为三维图形的工具(用matlab画曲面). 


光场积分_初步(M函数):...
+[新建阅读窗口](,光场积分_初步)
抛物镜反射公式(html):...
平面镜反射公式(html):...
场景测试:...

对比高斯光束:...

的(对比高斯光束,蒙卡模拟)->+[有](蒙卡模拟,抛物镜反射公式)



## end
#3, 48:
计算波前:...
创建于 20210525

节点数目统计::
+[设置结构](,节点数目统计)
## end
#6, 58:
https://www.ucl.ac.uk/~ucapikr/projects/Dominic_report.pdf
## end
#8, 53:
https://ischebeck.net/presentations/Zemax.pdf#page=17
## end
#10, 724:
%{
+[返回目录](,光场积分_初步)
+[M函数](,光场积分_初步)
%}
clf

physics_constant;
lm=300e-5;
k=2*pi/lm;

D=0.1;
x0=linspace(-D/2,D/2,10);
y0=linspace(-D/2,D/2,10);
z0=0;

[Y0,X0]=meshgrid(y0,x0);
Z0=z0*ones(size(X0));
E0=ones(size(X0));


x=linspace(-1,1,100);
y=linspace(-1,1,100);
z=10;

[Y,X]=meshgrid(y,x);
Z=z*ones(size(X));

E=zeros(size(X));
for i=1:size(X0,1)
    for j=1:size(X0,2)
        L=sqrt((X-X0(i,j)).^2+(Y-Y0(i,j)).^2+(Z-Z0(i,j)).^2);
        dE=E0(i,j)*exp(1i*k*L)/lm./L;
        E=E+dE;
    end
end

subplot(1,2,1)
plot3(X0,Y0,Z0,'b+',X,Y,Z,'r.')
axis equal

subplot(1,2,2)
%surf(X,Y,real(E0.*exp(1i*k*L)/lm./L))
%surf(X,Y,abs(L))
surf(X,Y,abs(E)/max(max(abs(E))))
view(0,90)
axis equal
shading interp

%{
+[M函数](,光场积分)
%}
## end
#12, 17:
文档\S应用\几何样本库.ftxt
## end
#14, 3720:
<!--
+[返回目录](,抛物镜反射公式)
+[H函数](,抛物镜反射公式)
+[新建阅读窗口](,抛物镜反射公式)
抛物镜反射(画板):...
球面镜反射(画板):...

-->

<b><u>Parabola reflection</u></b><br>
The parabola function is,
$$
y=a x^2+b x +c
$$
The function of a line from a given point \((x_0,y_0)\) is, 
$$
\begin{cases}
x=v_1 t +x_0
\\
y=u_1 t+y_0
\end{cases}
$$

The intersection \((x_B,y_B)\) of the parabola and the line L1 is, 
$$
y_B=a x_B^2+b x_B +c
\\\Rightarrow
u_1 t+y_A=a (v_1 t +x_A)^2+b (v_1 t +x_A) +c
\\\Rightarrow
a (v_1 t +x_A)^2+b (v_1 t +x_A) - u_1 t- y_A +c =0
\\\Rightarrow
a (v_1^2 t^2 +2v_1 x_A t + x_A^2)+b (v_1 t +x_A) - u_1 t- y_A +c =0
\\\Rightarrow
a v_1^2 t^2
 + (2a v_1 x_A + b v_1 - u_1) t
 + (a x_A^2+b x_A- y_A +c) =0
$$
So,
$$
t_B=\frac
{-(2a v_1 x_A + b v_1 - u_1) 
+ \sqrt{(2a v_1 x_A + b v_1 - u_1)^2-4 a v_1^2 (a x_A^2+b x_A- y_A +c)}}
{2 a v_1^2}
$$
The tangent \(L_2\) of the parabola at the point \(B\) is, 
$$
\frac{dy}{dx}=2 a x_B+b=tan(\theta_2)
$$
Since the include angle of \(L_2\) and \(L_1\) is same with the angle of \(L_2\) and \(L_3\), we have, 
$$
\theta_2-\theta_3=\theta_1-\theta_2
\\
\theta_3=2\theta_2-\theta_1

$$
Then,
$$
tan(\theta_3) =tan (2\theta_2-\theta_1)
=
\frac{tan (2\theta_2)-tan(\theta_1)}{1+tan (2\theta_2) tan(\theta_1)}
\\
=
(\frac{2tan (\theta_2)}{1-tan (\theta_2)^2}-tan(\theta_1))/(1+\frac{2tan (\theta_2)}{1-tan (\theta_2)^2} tan(\theta_1))
\\
=
\frac
{2tan (\theta_2)-tan(\theta_1)+tan (\theta_2)^2tan(\theta_1)}
{1-tan (\theta_2)^2 + 2tan (\theta_2) tan(\theta_1)}
$$
OK, to summarize, the calculation process is, 
$$
x_B=v_1 t + x_A
\\
=\frac
{-(b v_1 - u_1) 
+ \sqrt{(2a v_1 x_A + b v_1 - u_1)^2-4 a v_1^2 (a x_A^2+b x_A- y_A +c)}}
{2 a v_1}
$$
$$
tan(\theta_2)
=2 a x_B+b
\\
=\frac
{u_1 
+ \sqrt{(2a v_1 x_A + b v_1 - u_1)^2-4 a v_1^2 (a x_A^2+b x_A- y_A +c)}}
{v_1}
$$$$
tan(\theta_3)
=
\frac
{2tan (\theta_2)-tan(\theta_1)+tan (\theta_2)^2tan(\theta_1)}
{1-tan (\theta_2)^2 + 2tan (\theta_2) tan(\theta_1)}
,\ 
tan(\theta_1)=\frac{u_1}{v_1}
$$
If \(\theta_1=90\), then,
$$
x_B=x_A
$$
<br>


<b><u>3D reflection</u></b><br>
For a cylindrical mirror, the mirror is flat along the symmetry direction. If the \(y\) direction is symmetrical, the function of the surface is, 
$$
z=a x^2
$$
Let us assume the start point and light direction are, 
$$
\vec{r}_A=(x_A,y_A,z_A)
,\ 
\vec{v}_1=(v_{1x},v_{1y},v_{1z})
$$
Then, 
$$
t_1=\frac
{-(2a v_{x1} x_A - v_{z1}) 
+ \sqrt{(2a v_{x1} x_A - v_{z1})^2-4 a v_{x1}^2 (a x_A^2- z_A )}}
{2 a v_{x1}^2}
$$
$$
\vec{r}_B=\vec{v}_1 t_1 +\vec{r}_A
$$
For the reflection direction, \(x\) and \(z\) directions are same as the above calculation. The \(y\) direction doesn't change at all. 
<br><br>



<b><u>Debug: 20210720</u></b><br>
For those cases, when \(v_{x1}\ll 1\), we should use the Taylor expansion formula,
$$
t_1=\frac
{-(2a v_{x1} x_A - v_{z1}) 
+ \sqrt{(2a v_{x1} x_A - v_{z1})^2-4 a v_{x1}^2 (a x_A^2- z_A )}}
{2 a v_{x1}^2}
$$$$
t_1=\frac
{-(2a v_{x1} x_A - v_{z1}) 
+(2a v_{x1} x_A - v_{z1})
 \sqrt{1-
\frac{4 a v_{x1}^2 (a x_A^2- z_A )}
{(2a v_{x1} x_A - v_{z1})^2}

}}
{2 a v_{x1}^2}
$$
As a result, for the situation when, 
$$
\frac{4 a v_{x1}^2 (a x_A^2- z_A )}
{(2a v_{x1} x_A - v_{z1})^2}
\ll 1
$$$$
4 a v_{x1}^2 (a x_A^2- z_A )
\ll (2a v_{x1} x_A - v_{z1})^2
$$$$
- 4 a v_{x1}^2 z_A 
\ll 4 a v_{x1} v_{z1} x_A - v_{z1}^2
$$

Let's use \(4 a v_{x1}^2 (a x_A^2- z_A )
\ll (2a v_{x1} x_A - v_{z1})^2\) to judge whether the \(v_{x1}\) is too small. When it is the case, we have,
$$
t_1=\frac
{
-
\frac{2 a v_{x1}^2 (a x_A^2- z_A )}
{(2a v_{x1} x_A - v_{z1})}
}
{2 a v_{x1}^2}

=-
\frac{(a x_A^2- z_A )}
{(2a v_{x1} x_A - v_{z1})}
$$






<!--
+[H函数](,抛物镜反射公式)

验证算法(M函数):...
抛物型柱面镜反射(M函数):...
+[M函数](,验证算法)

三维场景::文档\S应用\三维建模.ftxt
+[打开文件](+新窗口,三维场景)
-->
## end
#17, 979:
+[返回目录](,抛物镜镜反射)
+[画板](+新窗口,球面镜反射)

+[修改标题]"抛物线"(,圆弧)

抛物线:...

有坐标系. 
有抛物线. 抛物线上面有一点A, A点引出一条线L1交抛物线于B点. 
过B点引一条线L2, 和抛物线相切. 
然后, 从B点引出一条直线L3, 最终到达C点. 
L1和L2的夹角, 以及L3和L2的夹角相同. 

+坐标系->+抛物线->+L1->+L2->+L3->+A点->+B点->+C点(,)...
->+[创建坐标系](,+坐标系)->+[创建函数曲线](,+抛物线)...
->+[创建直线](,+L1)->+[创建直线](,+L2)->+[创建直线](,+L3)...
->+[创建圆形](,+A点)->+[创建圆形](,+B点)->+[创建圆形](,+C点)

A点的中心是L1的起点, B点的中心是L1的终点, 也是L3的起点. C点的中心是L3的终点. 
+引出(A点,L1)->+到达(L1,B点)->+引出(B点,L3)->+到达(L3,C点)...
->的(A点,中心#A)->的(B点,中心#B)->的(C点,中心#C)...
->的(L1,起点#1)->的(L1,终点#1)->的(L3,起点#3)->的(L3,终点#3)...
->+是(中心#A,起点#1)->+是(中心#B,终点#1)->+是(中心#B,起点#3)->+是(中心#C,终点#3)

B点在抛物线上. L2和抛物线相切于B点. 
+上面(B点,抛物线)->+相切(L2,抛物线)->+于(+相切,B点)

B点白色, A点红色, C点绿色
的(B点,面颜色#1)->+[修改内容]"255,255,255"(,面颜色#1)...
->的(A点,面颜色#2)->+[修改内容]"255,0,0"(,面颜色#2)...
->的(C点,面颜色#3)->+[修改内容]"0,255,0"(,面颜色#3)

所有的点, 半径为5
[]=>_re"点"=>的(_re,半径)->+[修改内容]"5"(,半径)

L2和L1的夹角与L2和L3的夹角相同. 
+夹角#1(L2,L1)->+夹角#2(L2,L3)->+相同(+夹角#1,+夹角#2)...
->+[创建角度](,+夹角#1)->+[创建角度](,+夹角#2)



## end
#26, 145:
+[返回目录](,圆形)

中心::200,100
半径::100
类型::圆形
角度::0


面颜色::255,255,0
线颜色::None
线型::SolidLine
线粗细::2

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#27, 145:
+[返回目录](,圆形)

中心::200,100
半径::100
类型::圆形
角度::0


面颜色::255,255,0
线颜色::None
线型::SolidLine
线粗细::2

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#28, 145:
+[返回目录](,圆形)

中心::200,100
半径::100
类型::圆形
角度::0


面颜色::255,255,0
线颜色::None
线型::SolidLine
线粗细::2

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#29, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#30, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#31, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#32, 191:
+[返回目录](,抛物线)
+[设置结构](,抛物线)

起点::-200,100
尺寸::100,100
类型::矩形

中心位置::0,100
分辨率::0.1
函数::y=x**2/10
可选::YES

面颜色::None
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

+[创建输入](可选,画图)



## end
#33, 141:
+[返回目录](,坐标系)
+[设置结构](,坐标系)

起点::-200,100
尺寸::100,100
类型::矩形

原点::0.1,0.1
x坐标::x
y坐标::y

可选::YES

画图:...
选中区域:...
HTML:...

+[创建输入](可选,画图)



## end
#44, 1487:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


def drawArrow(qp,pt1,pt2):
    angle=30
    l=30
    D=0
    d=10
    
    lineWidth=2
    
    edgeColor=[0,0,0]
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush())
    
    r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
    if r!=0:
        theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
    dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
    dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]
    
    pt10=[0,0]
    pt20=[0,0]
    pt10[0]=pt1[0]
    pt10[1]=pt1[1]
    pt20[0]=pt2[0]
    pt20[1]=pt2[1]
    
    
    path2=QPainterPath()
    path2.moveTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
    path2.lineTo(pt20[0],pt20[1])
    path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])
    
    qp.drawPath(path2)
    
    
    qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])
    
    qp.setBrush(QBrush())
    qp.setPen(QPen())


pt=起点
size=尺寸
orig=[pt[0]+size[0]*原点[0],pt[1]+size[1]*原点[1]]

qp.setFont(QFont("Decorative",15))

pt1=[pt[0],orig[1]]
pt2=[pt[0]+size[0],orig[1]]
qp.drawText(pt2[0],pt2[1],100,30,Qt.AlignLeft|Qt.AlignVCenter,x坐标)
drawArrow(qp,pt1,pt2)

pt1=[orig[0],pt[1]]
pt2=[orig[0],pt[1]+size[1]]
qp.drawText(pt2[0],pt2[1]-30,100,30,Qt.AlignLeft|Qt.AlignVCenter,y坐标)
drawArrow(qp,pt1,pt2)


qp.drawText(orig[0],orig[1],30,30,Qt.AlignHCenter|Qt.AlignVCenter,'O')
qp.setFont(QFont())


## end
#50, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#51, 1487:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


def drawArrow(qp,pt1,pt2):
    angle=30
    l=30
    D=0
    d=10
    
    lineWidth=2
    
    edgeColor=[0,0,0]
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush())
    
    r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
    if r!=0:
        theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
    dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
    dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]
    
    pt10=[0,0]
    pt20=[0,0]
    pt10[0]=pt1[0]
    pt10[1]=pt1[1]
    pt20[0]=pt2[0]
    pt20[1]=pt2[1]
    
    
    path2=QPainterPath()
    path2.moveTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
    path2.lineTo(pt20[0],pt20[1])
    path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])
    
    qp.drawPath(path2)
    
    
    qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])
    
    qp.setBrush(QBrush())
    qp.setPen(QPen())


pt=起点
size=尺寸
orig=[pt[0]+size[0]*原点[0],pt[1]+size[1]*原点[1]]

qp.setFont(QFont("Decorative",15))

pt1=[pt[0],orig[1]]
pt2=[pt[0]+size[0],orig[1]]
qp.drawText(pt2[0],pt2[1],100,30,Qt.AlignLeft|Qt.AlignVCenter,x坐标)
drawArrow(qp,pt1,pt2)

pt1=[orig[0],pt[1]]
pt2=[orig[0],pt[1]+size[1]]
qp.drawText(pt2[0],pt2[1]-30,100,30,Qt.AlignLeft|Qt.AlignVCenter,y坐标)
drawArrow(qp,pt1,pt2)


qp.drawText(orig[0],orig[1],30,30,Qt.AlignHCenter|Qt.AlignVCenter,'O')
qp.setFont(QFont())


## end
#52, 263:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


if 可选=='NO':
    state=False



## end
#55, 14:
+[返回目录]
+[内容]

## end
#56, 1637:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


function drawArrow(pt1,pt2,ctx) {
    //arrows
    var angle=30/180*Math.PI;
    var l=20;
    var d=10;
    
    r=Math.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2);
    if (r!=0) {
        theta=Math.sign(pt1[1]-pt2[1])*Math.acos((pt2[0]-pt1[0])/r);
    }
    
    dp21=[l*Math.cos(theta-angle/2),-l*Math.sin(theta-angle/2)];
    dp22=[l*Math.cos(theta+angle/2),-l*Math.sin(theta+angle/2)];
    
    pt10=[0,0];
    pt20=[0,0];
    pt10[0]=pt1[0];
    pt10[1]=pt1[1];
    pt20[0]=pt2[0];
    pt20[1]=pt2[1];
    
    
    ctx.strokeStyle='rgb(0,0,0)';
    ctx.lineWidth=2;
    ctx.fillStyle='rgb(0,0,0,0)';
    
    
    ctx.beginPath();
    
    
    //ctx.moveTo(pt10[0]+dp21[0],pt10[1]+dp21[1]);
    //ctx.lineTo(pt10[0],pt10[1]);
    //ctx.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1]);
    
    ctx.moveTo(pt20[0]-dp21[0],pt20[1]-dp21[1]);
    ctx.lineTo(pt20[0],pt20[1]);
    ctx.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1]);
    
    
    ctx.moveTo(pt10[0],pt10[1]);
    ctx.lineTo(pt20[0],pt20[1]);
    
    ctx.stroke()
    ctx.fill()
}


var pt=[%起点]
var size=[%尺寸]
var ratio=[%原点]
var orig=[pt[0]+size[0]*ratio[0],pt[1]+size[1]*ratio[1]]

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='left'
ctx.textBaseline='top'
ctx.font=30+'px serif'

pt1=[pt[0],orig[1]]
pt2=[pt[0]+size[0],orig[1]]
drawArrow(pt1,pt2,ctx)
ctx.fillStyle='rgba(0,0,0,1)';
ctx.fillText('%x坐标',pt2[0],pt2[1])

pt1=[orig[0],pt[1]]
pt2=[orig[0],pt[1]+size[1]]
drawArrow(pt1,pt2,ctx)
ctx.fillStyle='rgba(0,0,0,1)';
ctx.fillText('%y坐标',pt2[0],pt2[1])

ctx.fillText('O',orig[0],orig[1])


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#59, 14:
+[返回目录]
+[内容]

## end
#60, 137:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100
坐标范围::-1,1-1,1
x坐标::x
y坐标::y
可选::NO

## end
#67, 22:
-751.0625, 174.8203125
## end
#68, 20:
534.125, -311.640625
## end
#69, 2:
矩形
## end
#70, 7:
0.1,0.1
## end
#71, 1:
x
## end
#72, 1:
y
## end
#73, 2:
NO
## end
#88, 921:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸

lineWidth=线粗细[0]
lineType=线型

dx=分辨率[0]
orig=中心位置

Nx=np.abs(size[0])
x=np.linspace(-Nx*dx/2,Nx*dx/2,Nx)+orig[0]
y=0*x
exec(函数)

x_p=x/dx+pt[0]+size[0]/2
y_p=-y/dx+pt[1]+size[1]/2+orig[1]


path=QPainterPath()
move=True
for i in range(len(x_p)):
    if (y_p[i]-pt[1])*(y_p[i]-pt[1]-size[1])>0:
        if 面颜色=='None':
            move=True
        continue
    if move:
        path.moveTo(x_p[i],y_p[i])
        move=False
    else:
        path.lineTo(x_p[i],y_p[i])

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawPath(path)

qp.setBrush(QBrush())
qp.setPen(QPen())







## end
#94, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#95, 921:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸

lineWidth=线粗细[0]
lineType=线型

dx=分辨率[0]
orig=中心位置

Nx=np.abs(size[0])
x=np.linspace(-Nx*dx/2,Nx*dx/2,Nx)+orig[0]
y=0*x
exec(函数)

x_p=x/dx+pt[0]+size[0]/2
y_p=-y/dx+pt[1]+size[1]/2+orig[1]


path=QPainterPath()
move=True
for i in range(len(x_p)):
    if (y_p[i]-pt[1])*(y_p[i]-pt[1]-size[1])>0:
        if 面颜色=='None':
            move=True
        continue
    if move:
        path.moveTo(x_p[i],y_p[i])
        move=False
    else:
        path.lineTo(x_p[i],y_p[i])

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawPath(path)

qp.setBrush(QBrush())
qp.setPen(QPen())







## end
#96, 261:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False

if 可选=='NO':
    state=False


## end
#99, 14:
+[返回目录]
+[内容]

## end
#100, 655:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#103, 14:
+[返回目录]
+[内容]

## end
#104, 143:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100
中心位置::0,-10
分辨率::0.1
函数::y=x**2/10
可选::NO

## end
#115, 39:
-303.79355161929175, -123.1272073082769
## end
#116, 37:
-387.2225638671876, 291.8855078125002
## end
#117, 2:
矩形
## end
#118, 8:
DashLine
## end
#119, 1:
2
## end
#120, 4:
None
## end
#121, 5:
0,0,0
## end
#122, 5:
0,100
## end
#123, 3:
0.1
## end
#124, 9:
y=x**2/10
## end
#125, 4:
YES

## end
#135, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#141, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#142, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#143, 2:
直线
## end
#144, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#148, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#151, 14:
+[返回目录]
+[内容]

## end
#152, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#154, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#155, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#157, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#163, 33:
-427.2950034, -122.25767400000005
## end
#164, 12:
-432.0, 77.0
## end
#165, 5:
0,0,0
## end
#166, 1:
1
## end
#167, 9:
SolidLine
## end
#177, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#183, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#184, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#185, 2:
直线
## end
#186, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#190, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#193, 14:
+[返回目录]
+[内容]

## end
#194, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#196, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#197, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#199, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#205, 37:
-524.6167579250259, 199.4023497549124
## end
#206, 38:
-331.5071909250256, -50.22377584508767
## end
#207, 5:
0,0,0
## end
#208, 1:
1
## end
#209, 9:
SolidLine
## end
#219, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#225, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#226, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#227, 2:
直线
## end
#228, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#232, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#235, 14:
+[返回目录]
+[内容]

## end
#236, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#238, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#239, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#241, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#247, 12:
-432.0, 77.0
## end
#248, 32:
-494.5367241, 108.28536840000004
## end
#249, 5:
0,0,0
## end
#250, 1:
1
## end
#251, 9:
SolidLine
## end
#263, 519:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.beginPath();
ctx.arc(%中心,%半径,0,2*Math.PI)

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fill();
}

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(0,0,0)';
} else {
        ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        if('%线型'==='DashLine') {
            ctx.setLineDash([5,5])
        }
        ctx.stroke();
}

ctx.setLineDash([])

//ctx.stroke()

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#265, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#268, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#271, 14:
+[返回目录]
+[内容]

## end
#272, 2:
圆形
## end
#273, 692:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)
qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#278, 692:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)
qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#279, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#281, 66:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#289, 1:
2
## end
#290, 9:
SolidLine
## end
#291, 5:
0,0,0
## end
#292, 7:
255,0,0
## end
#293, 17:
-93.3664606634298
## end
#294, 1:
5
## end
#295, 33:
-427.2950034, -122.25767400000005
## end
#307, 519:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.beginPath();
ctx.arc(%中心,%半径,0,2*Math.PI)

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fill();
}

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(0,0,0)';
} else {
        ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        if('%线型'==='DashLine') {
            ctx.setLineDash([5,5])
        }
        ctx.stroke();
}

ctx.setLineDash([])

//ctx.stroke()

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#309, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#312, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#315, 14:
+[返回目录]
+[内容]

## end
#316, 2:
圆形
## end
#317, 692:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)
qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#322, 692:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)
qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#323, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#325, 66:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#333, 1:
2
## end
#334, 9:
SolidLine
## end
#335, 5:
0,0,0
## end
#336, 11:
255,255,255
## end
#337, 17:
-93.3664606634298
## end
#338, 1:
5
## end
#339, 12:
-432.0, 77.0
## end
#351, 519:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.beginPath();
ctx.arc(%中心,%半径,0,2*Math.PI)

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fill();
}

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(0,0,0)';
} else {
        ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        if('%线型'==='DashLine') {
            ctx.setLineDash([5,5])
        }
        ctx.stroke();
}

ctx.setLineDash([])

//ctx.stroke()

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#353, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#356, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#359, 14:
+[返回目录]
+[内容]

## end
#360, 2:
圆形
## end
#361, 692:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)
qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#366, 692:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)
qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#367, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#369, 66:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#377, 1:
2
## end
#378, 9:
SolidLine
## end
#379, 5:
0,0,0
## end
#380, 7:
0,255,0
## end
#381, 19:
-112.99740361652559
## end
#382, 1:
5
## end
#383, 32:
-494.5367241, 108.28536840000004
## end
#384, 1:
1
## end
#386, 10:
1920, 1001
## end
#388, 14:
-150.0, -200.0
## end
#391, 17:
0.877521022998969
## end
#393, 8:
958, 476
## end
#395, 11:
-400.0, 0.0
## end
#424, 111:
+[返回目录](,角度)

数值::
中心::
半径::20
起始角度::
类型::角度

标记::%数值

画图:...
HTML:...
P代码:...
+[P函数](,P代码)



+[创建输入](标记,画图)


## end
#425, 111:
+[返回目录](,角度)

数值::
中心::
半径::20
起始角度::
类型::角度

标记::%数值

画图:...
HTML:...
P代码:...
+[P函数](,P代码)



+[创建输入](标记,画图)


## end
#445, 18:
-52.27463675779402
## end
#446, 6:
[20.0]
## end
#447, 37:
-432.0731276316314, 80.09697179887604
## end
#448, 18:
-36.37271088095812
## end
#449, 3:
%数值
## end
#455, 121:
+[返回目录]
+[内容]
标记::%数值
中心::-338.8789230341691, -3.8202594274802757
半径::10
起始角度::136.10929165904932
数值::62.220685781962224

## end
#457, 775:
/*
+[返回目录](,HTML)

+[新建阅读窗口](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var pt0=[%中心];
var r=%半径;
var Dangle=%数值;
var angle0=%起始角度;
var text="%标记";

dx=1.5*r*Math.cos((angle0+Dangle)/180*Math.PI/2);
dy=1.5*r*Math.sin((angle0+Dangle)/180*Math.PI/2);


ctx.beginPath();
if(Dangle>0) {
    ctx.arc(pt0[0],pt0[1],r,angle0/180*Math.PI,(angle0+Dangle)/180*Math.PI);
} else {
    ctx.arc(pt0[0],pt0[1],r,(angle0+Dangle)/180*Math.PI,angle0/180*Math.PI);
}

ctx.strokeStyle='rgba(0,0,0)';
ctx.stroke();

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center';
ctx.textBaseline='middle';
ctx.font=8*2+'px serif';

if (text[0]==='%') {
    ctx.fillText(`${-Dangle.toFixed(2)}`,pt0[0]+dx,pt0[1]+dy);
} else {
    ctx.fillText(text,pt0[0]+dx,pt0[1]+dy);
}


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/

## end
#459, 562:
"""
+[返回目录](,画图)

输入:...
+[设置结构](,输入)

"""

pt0=中心
r=半径[0]
angle0=-起始角度[0]
Dangle=-数值[0]

dx=r*np.cos(np.deg2rad(angle0+Dangle)/2)
dy=r*np.sin(np.deg2rad(angle0+Dangle)/2)


qp.setPen(QPen(QColor(0,0,0)))
qp.setBrush(QBrush(QColor(255,255,255)))

qp.drawArc(pt0[0]-r,pt0[1]-r,2*r,2*r,angle0*16,Dangle*16)

qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",10))


if 标记=='%数值':
    qp.drawText(pt0[0]+dx,pt0[1]+dy,"%.2f"%(Dangle))
else:
    qp.drawText(pt0[0]+dx,pt0[1]+dy,str(标记))

qp.drawPoint(pt0[0]+dx,pt0[1]+dy)

qp.setFont(QFont())




## end
#461, 38:
-511.12883700000003, 182.2895806000001
## end
#463, 38:
-318.0192699999999, -67.33654499999997
## end
#465, 33:
-427.2950034, -122.25767400000005
## end
#467, 12:
-432.0, 77.0
## end
#469, 18:
-36.37271088095812
## end
#477, 62:
+[返回目录]
+[内容]
pt11::
pt12::
pt21::
pt22::
angle::
中心::
起始角度::

## end
#485, 14:
+[返回目录]
+[内容]

## end
#488, 940:
"""
+[返回目录](,P代码)

+[P函数](,P代码)

输出:...
+[设置结构](,输出)

"""

Dx1=pt11[0]-pt12[0]
Dy1=pt11[1]-pt12[1]

Dx2=pt21[0]-pt22[0]
Dy2=pt21[1]-pt22[1]

D1=pt11[0]*Dy1-pt11[1]*Dx1
D2=pt21[0]*Dy2-pt21[1]*Dx2

L=Dy1*Dx2-Dy2*Dx1
if L==0:
    pt0="None"
else:
    pt0=[(D1*Dx2-D2*Dx1)/L, (D1*Dy2-D2*Dy1)/L]
    if np.sqrt((pt0[0]-pt11[0])**2+(pt0[1]-pt11[1])**2) < np.sqrt((pt0[0]-pt12[0])**2+(pt0[1]-pt12[1])**2):
        Dx1=-Dx1
        Dy1=-Dy1
    
    if np.sqrt((pt0[0]-pt21[0])**2+(pt0[1]-pt21[1])**2) < np.sqrt((pt0[0]-pt22[0])**2+(pt0[1]-pt22[1])**2):
        Dx2=-Dx2
        Dy2=-Dy2

    sign=np.sign(Dx1*Dy2-Dx2*Dy1)
    Dtheta=np.arccos((Dx1*Dx2+Dy1*Dy2)/np.sqrt((Dx1**2+Dy1**2)*(Dx2**2+Dy2**2)))
    angle=np.rad2deg(Dtheta)*sign

    theta0=np.arccos(Dx1/np.sqrt(Dx1**2+Dy1**2))
    angle0=np.rad2deg(theta0)*np.sign(Dy1)

    print(Dy1/np.sqrt(Dx1**2+Dy1**2),theta0,angle0)

    中心=pt0
    起始角度=angle0


"""
+[P函数](,P代码)
+[设置结构](,输出)

"""
## end
#489, 2:
角度
## end
#509, 18:
-52.27463675779402
## end
#510, 6:
[20.0]
## end
#511, 38:
-428.21092172071167, 75.10443045154693
## end
#512, 19:
-154.30287795777502
## end
#513, 3:
%数值
## end
#519, 121:
+[返回目录]
+[内容]
标记::%数值
中心::-338.8789230341691, -3.8202594274802757
半径::10
起始角度::136.10929165904932
数值::62.220685781962224

## end
#521, 775:
/*
+[返回目录](,HTML)

+[新建阅读窗口](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var pt0=[%中心];
var r=%半径;
var Dangle=%数值;
var angle0=%起始角度;
var text="%标记";

dx=1.5*r*Math.cos((angle0+Dangle)/180*Math.PI/2);
dy=1.5*r*Math.sin((angle0+Dangle)/180*Math.PI/2);


ctx.beginPath();
if(Dangle>0) {
    ctx.arc(pt0[0],pt0[1],r,angle0/180*Math.PI,(angle0+Dangle)/180*Math.PI);
} else {
    ctx.arc(pt0[0],pt0[1],r,(angle0+Dangle)/180*Math.PI,angle0/180*Math.PI);
}

ctx.strokeStyle='rgba(0,0,0)';
ctx.stroke();

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center';
ctx.textBaseline='middle';
ctx.font=8*2+'px serif';

if (text[0]==='%') {
    ctx.fillText(`${-Dangle.toFixed(2)}`,pt0[0]+dx,pt0[1]+dy);
} else {
    ctx.fillText(text,pt0[0]+dx,pt0[1]+dy);
}


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/

## end
#523, 562:
"""
+[返回目录](,画图)

输入:...
+[设置结构](,输入)

"""

pt0=中心
r=半径[0]
angle0=-起始角度[0]
Dangle=-数值[0]

dx=r*np.cos(np.deg2rad(angle0+Dangle)/2)
dy=r*np.sin(np.deg2rad(angle0+Dangle)/2)


qp.setPen(QPen(QColor(0,0,0)))
qp.setBrush(QBrush(QColor(255,255,255)))

qp.drawArc(pt0[0]-r,pt0[1]-r,2*r,2*r,angle0*16,Dangle*16)

qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",10))


if 标记=='%数值':
    qp.drawText(pt0[0]+dx,pt0[1]+dy,"%.2f"%(Dangle))
else:
    qp.drawText(pt0[0]+dx,pt0[1]+dy,str(标记))

qp.drawPoint(pt0[0]+dx,pt0[1]+dy)

qp.setFont(QFont())




## end
#525, 38:
-511.12883700000003, 182.2895806000001
## end
#527, 38:
-318.0192699999999, -67.33654499999997
## end
#529, 12:
-432.0, 77.0
## end
#531, 32:
-494.5367241, 108.28536840000004
## end
#533, 19:
-154.30287795777502
## end
#541, 62:
+[返回目录]
+[内容]
pt11::
pt12::
pt21::
pt22::
angle::
中心::
起始角度::

## end
#549, 14:
+[返回目录]
+[内容]

## end
#552, 940:
"""
+[返回目录](,P代码)

+[P函数](,P代码)

输出:...
+[设置结构](,输出)

"""

Dx1=pt11[0]-pt12[0]
Dy1=pt11[1]-pt12[1]

Dx2=pt21[0]-pt22[0]
Dy2=pt21[1]-pt22[1]

D1=pt11[0]*Dy1-pt11[1]*Dx1
D2=pt21[0]*Dy2-pt21[1]*Dx2

L=Dy1*Dx2-Dy2*Dx1
if L==0:
    pt0="None"
else:
    pt0=[(D1*Dx2-D2*Dx1)/L, (D1*Dy2-D2*Dy1)/L]
    if np.sqrt((pt0[0]-pt11[0])**2+(pt0[1]-pt11[1])**2) < np.sqrt((pt0[0]-pt12[0])**2+(pt0[1]-pt12[1])**2):
        Dx1=-Dx1
        Dy1=-Dy1
    
    if np.sqrt((pt0[0]-pt21[0])**2+(pt0[1]-pt21[1])**2) < np.sqrt((pt0[0]-pt22[0])**2+(pt0[1]-pt22[1])**2):
        Dx2=-Dx2
        Dy2=-Dy2

    sign=np.sign(Dx1*Dy2-Dx2*Dy1)
    Dtheta=np.arccos((Dx1*Dx2+Dy1*Dy2)/np.sqrt((Dx1**2+Dy1**2)*(Dx2**2+Dy2**2)))
    angle=np.rad2deg(Dtheta)*sign

    theta0=np.arccos(Dx1/np.sqrt(Dx1**2+Dy1**2))
    angle0=np.rad2deg(theta0)*np.sign(Dy1)

    print(Dy1/np.sqrt(Dx1**2+Dy1**2),theta0,angle0)

    中心=pt0
    起始角度=angle0


"""
+[P函数](,P代码)
+[设置结构](,输出)

"""
## end
#553, 2:
角度
## end
#556, 4:
1158
## end
#558, 18:
-36.37271088095812
## end
#559, 2:
角度
## end
#560, 18:
-52.27463675779402
## end
#561, 37:
-432.0731276316314, 80.09697179887604
## end
#563, 18:
-36.37271088095812
## end
#565, 12:
-432.0, 77.0
## end
#567, 33:
-427.2950034, -122.25767400000005
## end
#569, 38:
-318.0192699999999, -67.33654499999997
## end
#571, 38:
-511.12883700000003, 182.2895806000001
## end
#579, 62:
+[返回目录]
+[内容]
pt11::
pt12::
pt21::
pt22::
angle::
中心::
起始角度::

## end
#587, 14:
+[返回目录]
+[内容]

## end
#590, 940:
"""
+[返回目录](,P代码)

+[P函数](,P代码)

输出:...
+[设置结构](,输出)

"""

Dx1=pt11[0]-pt12[0]
Dy1=pt11[1]-pt12[1]

Dx2=pt21[0]-pt22[0]
Dy2=pt21[1]-pt22[1]

D1=pt11[0]*Dy1-pt11[1]*Dx1
D2=pt21[0]*Dy2-pt21[1]*Dx2

L=Dy1*Dx2-Dy2*Dx1
if L==0:
    pt0="None"
else:
    pt0=[(D1*Dx2-D2*Dx1)/L, (D1*Dy2-D2*Dy1)/L]
    if np.sqrt((pt0[0]-pt11[0])**2+(pt0[1]-pt11[1])**2) < np.sqrt((pt0[0]-pt12[0])**2+(pt0[1]-pt12[1])**2):
        Dx1=-Dx1
        Dy1=-Dy1
    
    if np.sqrt((pt0[0]-pt21[0])**2+(pt0[1]-pt21[1])**2) < np.sqrt((pt0[0]-pt22[0])**2+(pt0[1]-pt22[1])**2):
        Dx2=-Dx2
        Dy2=-Dy2

    sign=np.sign(Dx1*Dy2-Dx2*Dy1)
    Dtheta=np.arccos((Dx1*Dx2+Dy1*Dy2)/np.sqrt((Dx1**2+Dy1**2)*(Dx2**2+Dy2**2)))
    angle=np.rad2deg(Dtheta)*sign

    theta0=np.arccos(Dx1/np.sqrt(Dx1**2+Dy1**2))
    angle0=np.rad2deg(theta0)*np.sign(Dy1)

    print(Dy1/np.sqrt(Dx1**2+Dy1**2),theta0,angle0)

    中心=pt0
    起始角度=angle0


"""
+[P函数](,P代码)
+[设置结构](,输出)

"""
## end
#591, 6:
[20.0]
## end
#592, 3:
%数值
## end
#598, 121:
+[返回目录]
+[内容]
标记::%数值
中心::-338.8789230341691, -3.8202594274802757
半径::10
起始角度::136.10929165904932
数值::62.220685781962224

## end
#600, 562:
"""
+[返回目录](,画图)

输入:...
+[设置结构](,输入)

"""

pt0=中心
r=半径[0]
angle0=-起始角度[0]
Dangle=-数值[0]

dx=r*np.cos(np.deg2rad(angle0+Dangle)/2)
dy=r*np.sin(np.deg2rad(angle0+Dangle)/2)


qp.setPen(QPen(QColor(0,0,0)))
qp.setBrush(QBrush(QColor(255,255,255)))

qp.drawArc(pt0[0]-r,pt0[1]-r,2*r,2*r,angle0*16,Dangle*16)

qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",10))


if 标记=='%数值':
    qp.drawText(pt0[0]+dx,pt0[1]+dy,"%.2f"%(Dangle))
else:
    qp.drawText(pt0[0]+dx,pt0[1]+dy,str(标记))

qp.drawPoint(pt0[0]+dx,pt0[1]+dy)

qp.setFont(QFont())




## end
#602, 775:
/*
+[返回目录](,HTML)

+[新建阅读窗口](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var pt0=[%中心];
var r=%半径;
var Dangle=%数值;
var angle0=%起始角度;
var text="%标记";

dx=1.5*r*Math.cos((angle0+Dangle)/180*Math.PI/2);
dy=1.5*r*Math.sin((angle0+Dangle)/180*Math.PI/2);


ctx.beginPath();
if(Dangle>0) {
    ctx.arc(pt0[0],pt0[1],r,angle0/180*Math.PI,(angle0+Dangle)/180*Math.PI);
} else {
    ctx.arc(pt0[0],pt0[1],r,(angle0+Dangle)/180*Math.PI,angle0/180*Math.PI);
}

ctx.strokeStyle='rgba(0,0,0)';
ctx.stroke();

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center';
ctx.textBaseline='middle';
ctx.font=8*2+'px serif';

if (text[0]==='%') {
    ctx.fillText(`${-Dangle.toFixed(2)}`,pt0[0]+dx,pt0[1]+dy);
} else {
    ctx.fillText(text,pt0[0]+dx,pt0[1]+dy);
}


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/

## end
#623, 111:
+[返回目录](,角度)

数值::
中心::
半径::20
起始角度::
类型::角度

标记::%数值

画图:...
HTML:...
P代码:...
+[P函数](,P代码)



+[创建输入](标记,画图)


## end
#624, 19:
-154.30287795777502
## end
#625, 2:
角度
## end
#626, 18:
-52.27463675779402
## end
#627, 38:
-428.21092172071167, 75.10443045154693
## end
#629, 19:
-154.30287795777502
## end
#631, 32:
-494.5367241, 108.28536840000004
## end
#633, 12:
-432.0, 77.0
## end
#635, 38:
-318.0192699999999, -67.33654499999997
## end
#637, 38:
-511.12883700000003, 182.2895806000001
## end
#645, 62:
+[返回目录]
+[内容]
pt11::
pt12::
pt21::
pt22::
angle::
中心::
起始角度::

## end
#653, 14:
+[返回目录]
+[内容]

## end
#656, 940:
"""
+[返回目录](,P代码)

+[P函数](,P代码)

输出:...
+[设置结构](,输出)

"""

Dx1=pt11[0]-pt12[0]
Dy1=pt11[1]-pt12[1]

Dx2=pt21[0]-pt22[0]
Dy2=pt21[1]-pt22[1]

D1=pt11[0]*Dy1-pt11[1]*Dx1
D2=pt21[0]*Dy2-pt21[1]*Dx2

L=Dy1*Dx2-Dy2*Dx1
if L==0:
    pt0="None"
else:
    pt0=[(D1*Dx2-D2*Dx1)/L, (D1*Dy2-D2*Dy1)/L]
    if np.sqrt((pt0[0]-pt11[0])**2+(pt0[1]-pt11[1])**2) < np.sqrt((pt0[0]-pt12[0])**2+(pt0[1]-pt12[1])**2):
        Dx1=-Dx1
        Dy1=-Dy1
    
    if np.sqrt((pt0[0]-pt21[0])**2+(pt0[1]-pt21[1])**2) < np.sqrt((pt0[0]-pt22[0])**2+(pt0[1]-pt22[1])**2):
        Dx2=-Dx2
        Dy2=-Dy2

    sign=np.sign(Dx1*Dy2-Dx2*Dy1)
    Dtheta=np.arccos((Dx1*Dx2+Dy1*Dy2)/np.sqrt((Dx1**2+Dy1**2)*(Dx2**2+Dy2**2)))
    angle=np.rad2deg(Dtheta)*sign

    theta0=np.arccos(Dx1/np.sqrt(Dx1**2+Dy1**2))
    angle0=np.rad2deg(theta0)*np.sign(Dy1)

    print(Dy1/np.sqrt(Dx1**2+Dy1**2),theta0,angle0)

    中心=pt0
    起始角度=angle0


"""
+[P函数](,P代码)
+[设置结构](,输出)

"""
## end
#657, 6:
[20.0]
## end
#658, 3:
%数值
## end
#664, 121:
+[返回目录]
+[内容]
标记::%数值
中心::-338.8789230341691, -3.8202594274802757
半径::10
起始角度::136.10929165904932
数值::62.220685781962224

## end
#666, 562:
"""
+[返回目录](,画图)

输入:...
+[设置结构](,输入)

"""

pt0=中心
r=半径[0]
angle0=-起始角度[0]
Dangle=-数值[0]

dx=r*np.cos(np.deg2rad(angle0+Dangle)/2)
dy=r*np.sin(np.deg2rad(angle0+Dangle)/2)


qp.setPen(QPen(QColor(0,0,0)))
qp.setBrush(QBrush(QColor(255,255,255)))

qp.drawArc(pt0[0]-r,pt0[1]-r,2*r,2*r,angle0*16,Dangle*16)

qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",10))


if 标记=='%数值':
    qp.drawText(pt0[0]+dx,pt0[1]+dy,"%.2f"%(Dangle))
else:
    qp.drawText(pt0[0]+dx,pt0[1]+dy,str(标记))

qp.drawPoint(pt0[0]+dx,pt0[1]+dy)

qp.setFont(QFont())




## end
#668, 775:
/*
+[返回目录](,HTML)

+[新建阅读窗口](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var pt0=[%中心];
var r=%半径;
var Dangle=%数值;
var angle0=%起始角度;
var text="%标记";

dx=1.5*r*Math.cos((angle0+Dangle)/180*Math.PI/2);
dy=1.5*r*Math.sin((angle0+Dangle)/180*Math.PI/2);


ctx.beginPath();
if(Dangle>0) {
    ctx.arc(pt0[0],pt0[1],r,angle0/180*Math.PI,(angle0+Dangle)/180*Math.PI);
} else {
    ctx.arc(pt0[0],pt0[1],r,(angle0+Dangle)/180*Math.PI,angle0/180*Math.PI);
}

ctx.strokeStyle='rgba(0,0,0)';
ctx.stroke();

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center';
ctx.textBaseline='middle';
ctx.font=8*2+'px serif';

if (text[0]==='%') {
    ctx.fillText(`${-Dangle.toFixed(2)}`,pt0[0]+dx,pt0[1]+dy);
} else {
    ctx.fillText(text,pt0[0]+dx,pt0[1]+dy);
}


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/

## end
#688, 111:
+[返回目录](,角度)

数值::
中心::
半径::20
起始角度::
类型::角度

标记::%数值

画图:...
HTML:...
P代码:...
+[P函数](,P代码)



+[创建输入](标记,画图)


## end
#704, 7:
-300, 3
## end
#705, 8:
958, 476
## end
#706, 17:
0.877521022998969
## end
#707, 11:
-400.0, 0.0
## end
#708, 38:
-218.35314823921343, 15.79537841398144
## end
#725, 7:
-300, 8
## end
#726, 8:
958, 476
## end
#727, 1:
1
## end
#728, 14:
-150.0, -200.0
## end
#742, 2:
NO
## end
#743, 1:
y
## end
#744, 1:
x
## end
#745, 7:
0.1,0.1
## end
#746, 2:
矩形
## end
#747, 20:
534.125, -311.640625
## end
#748, 22:
-751.0625, 174.8203125
## end
#755, 137:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100
坐标范围::-1,1-1,1
x坐标::x
y坐标::y
可选::NO

## end
#756, 14:
+[返回目录]
+[内容]

## end
#759, 1637:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


function drawArrow(pt1,pt2,ctx) {
    //arrows
    var angle=30/180*Math.PI;
    var l=20;
    var d=10;
    
    r=Math.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2);
    if (r!=0) {
        theta=Math.sign(pt1[1]-pt2[1])*Math.acos((pt2[0]-pt1[0])/r);
    }
    
    dp21=[l*Math.cos(theta-angle/2),-l*Math.sin(theta-angle/2)];
    dp22=[l*Math.cos(theta+angle/2),-l*Math.sin(theta+angle/2)];
    
    pt10=[0,0];
    pt20=[0,0];
    pt10[0]=pt1[0];
    pt10[1]=pt1[1];
    pt20[0]=pt2[0];
    pt20[1]=pt2[1];
    
    
    ctx.strokeStyle='rgb(0,0,0)';
    ctx.lineWidth=2;
    ctx.fillStyle='rgb(0,0,0,0)';
    
    
    ctx.beginPath();
    
    
    //ctx.moveTo(pt10[0]+dp21[0],pt10[1]+dp21[1]);
    //ctx.lineTo(pt10[0],pt10[1]);
    //ctx.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1]);
    
    ctx.moveTo(pt20[0]-dp21[0],pt20[1]-dp21[1]);
    ctx.lineTo(pt20[0],pt20[1]);
    ctx.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1]);
    
    
    ctx.moveTo(pt10[0],pt10[1]);
    ctx.lineTo(pt20[0],pt20[1]);
    
    ctx.stroke()
    ctx.fill()
}


var pt=[%起点]
var size=[%尺寸]
var ratio=[%原点]
var orig=[pt[0]+size[0]*ratio[0],pt[1]+size[1]*ratio[1]]

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='left'
ctx.textBaseline='top'
ctx.font=30+'px serif'

pt1=[pt[0],orig[1]]
pt2=[pt[0]+size[0],orig[1]]
drawArrow(pt1,pt2,ctx)
ctx.fillStyle='rgba(0,0,0,1)';
ctx.fillText('%x坐标',pt2[0],pt2[1])

pt1=[orig[0],pt[1]]
pt2=[orig[0],pt[1]+size[1]]
drawArrow(pt1,pt2,ctx)
ctx.fillStyle='rgba(0,0,0,1)';
ctx.fillText('%y坐标',pt2[0],pt2[1])

ctx.fillText('O',orig[0],orig[1])


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#760, 14:
+[返回目录]
+[内容]

## end
#763, 263:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


if 可选=='NO':
    state=False



## end
#764, 1487:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


def drawArrow(qp,pt1,pt2):
    angle=30
    l=30
    D=0
    d=10
    
    lineWidth=2
    
    edgeColor=[0,0,0]
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush())
    
    r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
    if r!=0:
        theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
    dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
    dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]
    
    pt10=[0,0]
    pt20=[0,0]
    pt10[0]=pt1[0]
    pt10[1]=pt1[1]
    pt20[0]=pt2[0]
    pt20[1]=pt2[1]
    
    
    path2=QPainterPath()
    path2.moveTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
    path2.lineTo(pt20[0],pt20[1])
    path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])
    
    qp.drawPath(path2)
    
    
    qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])
    
    qp.setBrush(QBrush())
    qp.setPen(QPen())


pt=起点
size=尺寸
orig=[pt[0]+size[0]*原点[0],pt[1]+size[1]*原点[1]]

qp.setFont(QFont("Decorative",15))

pt1=[pt[0],orig[1]]
pt2=[pt[0]+size[0],orig[1]]
qp.drawText(pt2[0],pt2[1],100,30,Qt.AlignLeft|Qt.AlignVCenter,x坐标)
drawArrow(qp,pt1,pt2)

pt1=[orig[0],pt[1]]
pt2=[orig[0],pt[1]+size[1]]
qp.drawText(pt2[0],pt2[1]-30,100,30,Qt.AlignLeft|Qt.AlignVCenter,y坐标)
drawArrow(qp,pt1,pt2)


qp.drawText(orig[0],orig[1],30,30,Qt.AlignHCenter|Qt.AlignVCenter,'O')
qp.setFont(QFont())


## end
#765, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#771, 1487:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


def drawArrow(qp,pt1,pt2):
    angle=30
    l=30
    D=0
    d=10
    
    lineWidth=2
    
    edgeColor=[0,0,0]
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush())
    
    r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
    if r!=0:
        theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
    dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
    dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]
    
    pt10=[0,0]
    pt20=[0,0]
    pt10[0]=pt1[0]
    pt10[1]=pt1[1]
    pt20[0]=pt2[0]
    pt20[1]=pt2[1]
    
    
    path2=QPainterPath()
    path2.moveTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
    path2.lineTo(pt20[0],pt20[1])
    path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])
    
    qp.drawPath(path2)
    
    
    qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])
    
    qp.setBrush(QBrush())
    qp.setPen(QPen())


pt=起点
size=尺寸
orig=[pt[0]+size[0]*原点[0],pt[1]+size[1]*原点[1]]

qp.setFont(QFont("Decorative",15))

pt1=[pt[0],orig[1]]
pt2=[pt[0]+size[0],orig[1]]
qp.drawText(pt2[0],pt2[1],100,30,Qt.AlignLeft|Qt.AlignVCenter,x坐标)
drawArrow(qp,pt1,pt2)

pt1=[orig[0],pt[1]]
pt2=[orig[0],pt[1]+size[1]]
qp.drawText(pt2[0],pt2[1]-30,100,30,Qt.AlignLeft|Qt.AlignVCenter,y坐标)
drawArrow(qp,pt1,pt2)


qp.drawText(orig[0],orig[1],30,30,Qt.AlignHCenter|Qt.AlignVCenter,'O')
qp.setFont(QFont())


## end
#782, 141:
+[返回目录](,坐标系)
+[设置结构](,坐标系)

起点::-200,100
尺寸::100,100
类型::矩形

原点::0.1,0.1
x坐标::x
y坐标::y

可选::YES

画图:...
选中区域:...
HTML:...

+[创建输入](可选,画图)



## end
#783, 4:
YES

## end
#784, 22:
y=20-np.sqrt(400-x**2)
## end
#785, 3:
0.1
## end
#786, 5:
0,100
## end
#787, 5:
0,0,0
## end
#788, 4:
None
## end
#789, 1:
2
## end
#790, 8:
DashLine
## end
#791, 2:
矩形
## end
#792, 37:
-387.2225638671876, 291.8855078125002
## end
#793, 38:
-393.3006959651866, -94.16901354931093
## end
#804, 143:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100
中心位置::0,-10
分辨率::0.1
函数::y=x**2/10
可选::NO

## end
#805, 14:
+[返回目录]
+[内容]

## end
#808, 655:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#809, 14:
+[返回目录]
+[内容]

## end
#812, 261:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False

if 可选=='NO':
    state=False


## end
#813, 921:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸

lineWidth=线粗细[0]
lineType=线型

dx=分辨率[0]
orig=中心位置

Nx=np.abs(size[0])
x=np.linspace(-Nx*dx/2,Nx*dx/2,Nx)+orig[0]
y=0*x
exec(函数)

x_p=x/dx+pt[0]+size[0]/2
y_p=-y/dx+pt[1]+size[1]/2+orig[1]


path=QPainterPath()
move=True
for i in range(len(x_p)):
    if (y_p[i]-pt[1])*(y_p[i]-pt[1]-size[1])>0:
        if 面颜色=='None':
            move=True
        continue
    if move:
        path.moveTo(x_p[i],y_p[i])
        move=False
    else:
        path.lineTo(x_p[i],y_p[i])

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawPath(path)

qp.setBrush(QBrush())
qp.setPen(QPen())







## end
#814, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#820, 921:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸

lineWidth=线粗细[0]
lineType=线型

dx=分辨率[0]
orig=中心位置

Nx=np.abs(size[0])
x=np.linspace(-Nx*dx/2,Nx*dx/2,Nx)+orig[0]
y=0*x
exec(函数)

x_p=x/dx+pt[0]+size[0]/2
y_p=-y/dx+pt[1]+size[1]/2+orig[1]


path=QPainterPath()
move=True
for i in range(len(x_p)):
    if (y_p[i]-pt[1])*(y_p[i]-pt[1]-size[1])>0:
        if 面颜色=='None':
            move=True
        continue
    if move:
        path.moveTo(x_p[i],y_p[i])
        move=False
    else:
        path.lineTo(x_p[i],y_p[i])

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawPath(path)

qp.setBrush(QBrush())
qp.setPen(QPen())







## end
#836, 202:
+[返回目录](,圆弧)
+[设置结构](,圆弧)

起点::-200,100
尺寸::100,100
类型::矩形

中心位置::0,100
分辨率::0.1
函数::y=20-np.sqrt(400-x**2)
可选::YES

面颜色::None
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

+[创建输入](可选,画图)



## end
#837, 9:
SolidLine
## end
#838, 1:
1
## end
#839, 5:
0,0,0
## end
#840, 12:
-432.0, 77.0
## end
#841, 33:
-427.2950034, -122.25767400000005
## end
#847, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#849, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#850, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#852, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#853, 14:
+[返回目录]
+[内容]

## end
#856, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#860, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#861, 2:
直线
## end
#862, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#863, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#869, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#879, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#880, 9:
SolidLine
## end
#881, 1:
1
## end
#882, 5:
0,0,0
## end
#883, 38:
-331.5071909250256, -50.22377584508767
## end
#884, 37:
-524.6167579250259, 199.4023497549124
## end
#890, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#892, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#893, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#895, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#896, 14:
+[返回目录]
+[内容]

## end
#899, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#903, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#904, 2:
直线
## end
#905, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#906, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#912, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#922, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#923, 9:
SolidLine
## end
#924, 1:
1
## end
#925, 5:
0,0,0
## end
#926, 32:
-494.5367241, 108.28536840000004
## end
#927, 12:
-432.0, 77.0
## end
#933, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#935, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#936, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#938, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#939, 14:
+[返回目录]
+[内容]

## end
#942, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#946, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#947, 2:
直线
## end
#948, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#949, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#955, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#965, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#966, 33:
-427.2950034, -122.25767400000005
## end
#967, 1:
5
## end
#968, 17:
-93.3664606634298
## end
#969, 7:
255,0,0
## end
#970, 5:
0,0,0
## end
#971, 9:
SolidLine
## end
#972, 1:
2
## end
#980, 66:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#982, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#983, 692:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)
qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#988, 692:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)
qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#989, 2:
圆形
## end
#990, 14:
+[返回目录]
+[内容]

## end
#993, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#996, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#998, 519:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.beginPath();
ctx.arc(%中心,%半径,0,2*Math.PI)

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fill();
}

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(0,0,0)';
} else {
        ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        if('%线型'==='DashLine') {
            ctx.setLineDash([5,5])
        }
        ctx.stroke();
}

ctx.setLineDash([])

//ctx.stroke()

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1010, 145:
+[返回目录](,圆形)

中心::200,100
半径::100
类型::圆形
角度::0


面颜色::255,255,0
线颜色::None
线型::SolidLine
线粗细::2

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#1011, 12:
-432.0, 77.0
## end
#1012, 1:
5
## end
#1013, 17:
-93.3664606634298
## end
#1014, 11:
255,255,255
## end
#1015, 5:
0,0,0
## end
#1016, 9:
SolidLine
## end
#1017, 1:
2
## end
#1025, 66:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#1027, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#1028, 692:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)
qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#1033, 692:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)
qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#1034, 2:
圆形
## end
#1035, 14:
+[返回目录]
+[内容]

## end
#1038, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#1041, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#1043, 519:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.beginPath();
ctx.arc(%中心,%半径,0,2*Math.PI)

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fill();
}

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(0,0,0)';
} else {
        ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        if('%线型'==='DashLine') {
            ctx.setLineDash([5,5])
        }
        ctx.stroke();
}

ctx.setLineDash([])

//ctx.stroke()

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1055, 145:
+[返回目录](,圆形)

中心::200,100
半径::100
类型::圆形
角度::0


面颜色::255,255,0
线颜色::None
线型::SolidLine
线粗细::2

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#1056, 32:
-494.5367241, 108.28536840000004
## end
#1057, 1:
5
## end
#1058, 19:
-112.99740361652559
## end
#1059, 7:
0,255,0
## end
#1060, 5:
0,0,0
## end
#1061, 9:
SolidLine
## end
#1062, 1:
2
## end
#1070, 66:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#1072, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#1073, 692:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)
qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#1078, 692:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
angle=角度[0]
theta=np.deg2rad(angle)

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen(QColor(0,0,0,0)))
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)
qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#1079, 2:
圆形
## end
#1080, 14:
+[返回目录]
+[内容]

## end
#1083, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#1086, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#1088, 519:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.beginPath();
ctx.arc(%中心,%半径,0,2*Math.PI)

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fill();
}

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(0,0,0)';
} else {
        ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        if('%线型'==='DashLine') {
            ctx.setLineDash([5,5])
        }
        ctx.stroke();
}

ctx.setLineDash([])

//ctx.stroke()

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1100, 145:
+[返回目录](,圆形)

中心::200,100
半径::100
类型::圆形
角度::0


面颜色::255,255,0
线颜色::None
线型::SolidLine
线粗细::2

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#1126, 977:
+[返回目录](,球面镜反射)
+[画板](+新窗口,球面镜反射)

+[修改标题]"圆弧"(,抛物线)

圆弧:...

有坐标系. 
有抛物线. 抛物线上面有一点A, A点引出一条线L1交抛物线于B点. 
过B点引一条线L2, 和抛物线相切. 
然后, 从B点引出一条直线L3, 最终到达C点. 
L1和L2的夹角, 以及L3和L2的夹角相同. 

+坐标系->+抛物线->+L1->+L2->+L3->+A点->+B点->+C点(,)...
->+[创建坐标系](,+坐标系)->+[创建函数曲线](,+抛物线)...
->+[创建直线](,+L1)->+[创建直线](,+L2)->+[创建直线](,+L3)...
->+[创建圆形](,+A点)->+[创建圆形](,+B点)->+[创建圆形](,+C点)

A点的中心是L1的起点, B点的中心是L1的终点, 也是L3的起点. C点的中心是L3的终点. 
+引出(A点,L1)->+到达(L1,B点)->+引出(B点,L3)->+到达(L3,C点)...
->的(A点,中心#A)->的(B点,中心#B)->的(C点,中心#C)...
->的(L1,起点#1)->的(L1,终点#1)->的(L3,起点#3)->的(L3,终点#3)...
->+是(中心#A,起点#1)->+是(中心#B,终点#1)->+是(中心#B,起点#3)->+是(中心#C,终点#3)

B点在抛物线上. L2和抛物线相切于B点. 
+上面(B点,抛物线)->+相切(L2,抛物线)->+于(+相切,B点)

B点白色, A点红色, C点绿色
的(B点,面颜色#1)->+[修改内容]"255,255,255"(,面颜色#1)...
->的(A点,面颜色#2)->+[修改内容]"255,0,0"(,面颜色#2)...
->的(C点,面颜色#3)->+[修改内容]"0,255,0"(,面颜色#3)

所有的点, 半径为5
[]=>_re"点"=>的(_re,半径)->+[修改内容]"5"(,半径)

L2和L1的夹角与L2和L3的夹角相同. 
+夹角#1(L2,L1)->+夹角#2(L2,L3)->+相同(+夹角#1,+夹角#2)...
->+[创建角度](,+夹角#1)->+[创建角度](,+夹角#2)



## end
#1131, 1:
1
## end
#1133, 8:
958, 476
## end
#1135, 11:
-600.0, 0.0
## end
#1138, 4:
1150
## end
#1141, 612:
%{
+[M函数](,验证算法)
+[新建阅读窗口](,验证算法)

Reflect_parabola(M函数):...
%}

addpath('C:\Users\cheng\Dropbox\Struct\Structure1.2\Nini\Matlab\optics');

a=1;
b=1;
c=1;

%theta1=linspace(-135,-45,20);
%x_A=0*ones(size(theta1));
%y_A=3*ones(size(theta1));

x_A=linspace(-1,0,20);
y_A=10*ones(size(x_A));
theta1=-90*ones(size(x_A));

[x_B,y_B,theta3]=Reflect_parabola(x_A,y_A,theta1,a,b,c);

t3=linspace(0,3,2)';

x0=linspace(-4,4,1000);
y0=a*x0.^2+b*x0+c;
x1=[x_A;x_B];
y1=[y_A;y_B];
x3=t3*cosd(theta3)+x_B;
y3=t3*sind(theta3)+y_B;

plot(x0,y0,'k',x1,y1,'k',x3,y3,'k',x_A,y_A,'ro',x_B,y_B,'r+')
axis equal


%{
+[M函数](,验证算法)
%}
## end
#1143, 4:
1169
## end
#1146, 488:
%{
+[M函数](,Reflect_parabola)
地址::Matlab\optics\Reflect_parabola.m

+[保存文本](,Reflect_parabola)
%}

function [x_B,y_B,theta3,theta2]=Reflect_parabola(x_A,y_A,theta1,a,b,c)
%a=1;
%b=1;
%c=1;

%theta1=-90;
%x_A=pt_A[1];
%y_A=pt_A[2];

v1=cosd(theta1);
u1=sind(theta1);

x_B=(-(b*v1-u1)+sqrt((2*a*v1.*x_A+b*v1-u1).^2-4*a*v1.^2.*(a*x_A.^2+b*x_A-y_A+c)))/2/a./v1;
x_B(v1==0)=x_A(v1==0);
y_B=a*x_B.^2+b*x_B+c;

tan2=2*a*x_B+b;
theta2=atand(tan2);
theta3=2*theta2-theta1;

end

%{
+[M函数](,验证算法)
%}
## end
#1149, 32:
Matlab\optics\Reflect_parabola.m
## end
#1151, 1110:
%{
+[返回目录](,抛物型柱面镜反射)
+[M函数](,抛物型柱面镜反射)

+[新建阅读窗口](,备份)

Reflection_parabola_3D(M函数):...
备份(M函数):...
+[M函数](,备份)
20210720Debug(M函数):...
+[M函数](,20210720Debug)
%}

addpath('Matlab\space')
addpath('Matlab\optics')

% mirror
a=0.01;
W=20;
H=1;
D=10;

Eulers1=[90,90,0];
Eulers2=[-90,90,0];
r1=[0,0,0];
r2=[150,0,0];


%yi=linspace(-1,1,10)+10;
%xi=50*ones(size(yi));
%zi=-5*ones(size(xi));

%vi_x=-1*ones(size(xi));
%vi_y=-0.4*ones(size(xi));
%vi_z=0.05*ones(size(xi));

t=linspace(0,360,10);

vi_x=-1*ones(size(t));
vi_z=0.01*sind(t);
vi_y=0.01*cosd(t);

xi=50*ones(size(t));
yi=1*ones(size(t));
zi=0*ones(size(t));




[xi2,yi2,zi2,vi2_x,vi2_y,vi2_z]=Reflection_parabola_3D(xi,yi,zi,vi_x,vi_y,vi_z,a,r1,Eulers1);
[xo,yo,zo,vo_x,vo_y,vo_z]=Reflection_parabola_3D(xi2,yi2,zi2,vi2_x,vi2_y,vi2_z,a,r2,Eulers2);

% drawing
x_C=10*vo_x+xo;
y_C=10*vo_y+yo;
z_C=10*vo_z+zo;

clf
hold on
model_para_cylindrical_mirror(a,W,H,D,Eulers1,r1)
model_para_cylindrical_mirror(a,W,H,D,Eulers2,r2)
plot3([xi;xi2;xo;x_C],[yi;yi2;yo;y_C],[zi;zi2;zo;z_C],'r-',...
[xi;x_C],[yi;y_C],[zi;z_C],'ro')
axis equal


%{
+[M函数](,抛物型柱面镜反射)
%}
## end
#1154, 16:
文档\S应用\三维建模.ftxt
## end
#1156, 1809:
%{
+[返回目录](,Reflection_parabola_3D)
+[M函数](,Reflection_parabola_3D)
地址::Matlab\optics\Reflection_parabola_3D.m

+[保存文本](,Reflection_parabola_3D)

测试(M函数):...
%}
function [xo,yo,zo,vo_x,vo_y,vo_z]=Reflection_parabola_3D(xi,yi,zi,vi_x,vi_y,vi_z,a,r0,Eulers)
% a=1; 
% r0=[0,0,0];

alpha=Eulers(1);
beta=Eulers(2);
gamma=Eulers(3);


%xi=linspace(-1,1,10);
%yi=0*ones(size(xi));
%zi=10*ones(size(xi));

%vi_x=0*ones(size(xi));
%vi_y=1*ones(size(xi));
%vi_z=-1*ones(size(xi));


% local frame
fx=[
-sind(gamma)*sind(alpha)*cosd(beta)+cosd(gamma)*cosd(alpha)
sind(gamma)*cosd(alpha)*cosd(beta)+cosd(gamma)*sind(alpha)
sind(gamma)*sind(beta)]';

fy=[
-cosd(gamma)*sind(alpha)*cosd(beta)-sind(gamma)*cosd(alpha)
cosd(gamma)*cosd(alpha)*cosd(beta)-sind(gamma)*sind(alpha)
cosd(gamma)*sind(beta)]';

fz=[
sind(alpha)*sind(beta)
-cosd(alpha)*sind(beta)
cosd(beta)]';

DX=xi-r0(1);
DY=yi-r0(2);
DZ=zi-r0(3);


x_A=fx(1)*DX+fx(2)*DY+fx(3)*DZ;
y_A=fy(1)*DX+fy(2)*DY+fy(3)*DZ;
z_A=fz(1)*DX+fz(2)*DY+fz(3)*DZ;

v_x=fx(1)*vi_x+fx(2)*vi_y+fx(3)*vi_z;
v_y=fy(1)*vi_x+fy(2)*vi_y+fy(3)*vi_z;
v_z=fz(1)*vi_x+fz(2)*vi_y+fz(3)*vi_z;



judge=4*a.*v_x.^2.*(a*x_A.^2-z_A)./(2*a*v_x.*v_z.*x_A-v_z.^2);

t1=(-(2*a*v_x.*x_A-v_z)+sqrt((2*a*v_x.*x_A-v_z).^2-4*a*v_x.^2.*(a*x_A.^2-z_A)))/2/a./v_x.^2;
% t1(v_x==0)=(a*x_A(v_x==0).^2-z_A(v_x==0))./v_z(v_x==0);
t1(judge<1e-7)=-(a*x_A(judge<1e-7).^2-z_A(judge<1e-7))./(2*a*v_x(judge<1e-7).*x_A(judge<1e-7)-v_z(judge<1e-7));
x_B=t1.*v_x+x_A;
y_B=t1.*v_y+y_A;
z_B=t1.*v_z+z_A;

v_0=sqrt(v_x.^2+v_z.^2);
theta1=sign(v_z).*acosd(v_x./v_0);
theta2=atand(2*a*x_B);
theta3=2*theta2-theta1;

v_x2=cosd(theta3);
v_y2=v_y;
v_z2=sind(theta3);

[xo,yo,zo]=transform_3D(r0,alpha,beta,gamma,x_B,y_B,z_B);
[vo_x,vo_y,vo_z]=transform_3D([0,0,0],alpha,beta,gamma,v_x2,v_y2,v_z2);

end


%{
+[M函数](,抛物型柱面镜反射)
%}
## end
#1159, 38:
Matlab\optics\Reflection_parabola_3D.m
## end
#1161, 2312:
%{
+[返回目录](,备份)
+[M函数](,备份)
%}

addpath('C:\Users\cheng\Dropbox\Struct\Structure1.2\Nini\Matlab\space')
addpath('C:\Users\cheng\Dropbox\Struct\Structure1.2\Nini\Matlab\optics')

a=0.1; 
r0=[0,0,0];


alpha=90;
beta=90;
gamma=0;

yi=linspace(-5,5,10);
xi=50*ones(size(yi));
zi=0*ones(size(xi));

vi_x=-1*ones(size(xi));
vi_y=0*ones(size(xi));
vi_z=0.1*ones(size(xi));


% alpha=0;
% beta=0;
% gamma=0;
% 
% xi=linspace(-5,5,10);
% yi=0*ones(size(xi));
% zi=50*ones(size(xi));
% 
% vi_x=0*ones(size(xi));
% vi_y=0.1*ones(size(xi));
% vi_z=-1*ones(size(xi));

% local frame
fx=[
-sind(gamma)*sind(alpha)*cosd(beta)+cosd(gamma)*cosd(alpha)
sind(gamma)*cosd(alpha)*cosd(beta)+cosd(gamma)*sind(alpha)
sind(gamma)*sind(beta)]';

fy=[
-cosd(gamma)*sind(alpha)*cosd(beta)-sind(gamma)*cosd(alpha)
cosd(gamma)*cosd(alpha)*cosd(beta)-sind(gamma)*sind(alpha)
cosd(gamma)*sind(beta)]';

fz=[
sind(alpha)*sind(beta)
-cosd(alpha)*sind(beta)
cosd(beta)]';

DX=xi-r0(1);
DY=yi-r0(2);
DZ=zi-r0(3);


x_A=fx(1)*DX+fx(2)*DY+fx(3)*DZ;
y_A=fy(1)*DX+fy(2)*DY+fy(3)*DZ;
z_A=fz(1)*DX+fz(2)*DY+fz(3)*DZ;

v_x=fx(1)*vi_x+fx(2)*vi_y+fx(3)*vi_z;
v_y=fy(1)*vi_x+fy(2)*vi_y+fy(3)*vi_z;
v_z=fz(1)*vi_x+fz(2)*vi_y+fz(3)*vi_z;




t1=(-(2*a*v_x.*x_A-v_z)+sqrt((2*a*v_x.*x_A-v_z).^2-4*a*v_x.^2.*(a*x_A.^2-z_A)))/2/a./v_x.^2;
t1(v_x==0)=(a*x_A(v_x==0).^2-z_A(v_x==0))./v_z(v_x==0);
x_B=t1.*v_x+x_A;
y_B=t1.*v_y+y_A;
z_B=t1.*v_z+z_A;

v_0=sqrt(v_x.^2+v_z.^2);
theta1=sign(v_z).*acosd(v_x./v_0);
theta2=atand(2*a*x_B);
theta3=2*theta2-theta1;

v_x2=cosd(theta3);
v_y2=v_y;
v_z2=sind(theta3);


[xo,yo,zo]=transform_3D(r0,alpha,beta,gamma,x_B,y_B,z_B);
[vo_x,vo_y,vo_z]=transform_3D([0,0,0],alpha,beta,gamma,v_x2,v_y2,v_z2);


% drawing
x_C1=10*vo_x+xo;
y_C1=10*vo_y+yo;
z_C1=10*vo_z+zo;

x_C=10*v_x2+x_B;
y_C=10*v_y2+y_B;
z_C=10*v_z2+z_B;

x=linspace(-2,2,10);
y=linspace(-20,20,10);

[Y0,X0]=meshgrid(y,x);
Z0=a*X0.^2;
[X,Y,Z]=transform_3D(r0,alpha,beta,gamma,X0,Y0,Z0);

clf
subplot(1,2,1)
hold on
plot3(X,Y,Z,'b-',X',Y',Z','b-')
plot3([xi;xo;x_C1],[yi;yo;y_C1],[zi;zo;z_C1],'ro-')
% plot3([xo;x_C],[yo;y_C],[zo;z_C],'ro-')
% plot(X,Z,'b-')
% plot([x_A;x_B;x_C],[z_A;z_B;z_C],'ro-')
axis equal

subplot(1,2,2)
hold on
plot3(X0,Y0,Z0,'b-',X0',Y0',Z0','b-')
plot3([x_A;x_B;x_C],[y_A;y_B;y_C],[z_A;z_B;z_C],'ro-')
axis equal




%{
+[M函数](,抛物型柱面镜反射)
%}
## end
#1162, 4:
1167
## end
#1164, 4:
1169
## end
#1166, 4:
1186
## end
#1169, 851:
<!--
+[返回目录](,平面镜反射公式)
+[H函数](,平面镜反射公式)

Reflection_plane_3D(M函数):...

直线交点::文档\数学问题\直线交点.ftxt
+[打开文件](+新窗口,直线交点)
-->

<u><b>3D plane</b></u><br>
The plane function is, 
$$
a (x-x_0) + b (y-y_0) +c (z-z_0) = 0
$$
If the plane is facing the z-axis, for the Euler angles \((\alpha, \beta, \gamma)\), then, 
$$
\hat{s}=(a,b,c)
=
(cos(\alpha) sin(\beta)
, 
-sin(\alpha) sin(\beta)
, 
cos(\beta))
$$
Then, for a line, 
$$
\vec{r}=\vec{v}_1 t +\vec{r}_A
$$
The intersection point \(B\) of the plane and line is, 
$$
a (v_1 t_B+x_A-x_0) + b (v_2 t_B+y_A-y_0) +c (v_3 t_B+z_A-z_0) = 0
$$$$
(av_1 + b v_2 + c v_3)t_B 
=
a (x_0-x_A) + b (y_0-y_A) +c (z_0-z_A) 
$$$$
t_B 
=
\frac{a (x_0-x_A) + b (y_0-y_A) +c (z_0-z_A)}
{av_1 + b v_2 + c v_3}
$$
The reflection direction is, 
$$
\vec{v}_2=\vec{v}_1-2 (\hat{s}\cdot\vec{v}_1) \hat{s}
$$

<!--
+[H函数](,平面镜反射公式)
-->
## end
#1172, 619:
%{
+[返回目录](,Reflection_plane_3D)
+[M函数](,Reflection_plane_3D)
地址::Matlab\optics\Reflection_plane_3D.m

测试(M函数):...

+[保存文本](,Reflection_plane_3D)
%}
function [x_B,y_B,z_B,v2_x,v2_y,v2_z]=Reflection_plane_3D(x_A,y_A,z_A,v1_x,v1_y,v1_z,r0,Eulers)
% r0=[0,0,0];

alpha=Eulers(1);
beta=Eulers(2);
gamma=Eulers(3);

s=[sind(alpha)*sind(beta), -cosd(alpha)*sind(beta), cosd(beta)];
A=s(1)*v1_x+s(2)*v1_y+s(3)*v1_z;

t_B=(s(1)*(r0(1)-x_A)+s(2)*(r0(2)-y_A)+s(3)*(r0(3)-z_A))./A;
x_B=v1_x.*t_B+x_A;
y_B=v1_y.*t_B+y_A;
z_B=v1_z.*t_B+z_A;

v2_x=v1_x-2*A*s(1);
v2_y=v1_y-2*A*s(2);
v2_z=v1_z-2*A*s(3);

end


%{
+[M函数](,抛物型柱面镜反射)
%}
## end
#1175, 35:
Matlab\optics\Reflection_plane_3D.m
## end
#1177, 602:
%{
+[M函数](,测试)
%}

clf
addpath('Matlab\space')
addpath('Matlab\optics')

% mirror
W=30;
H=30;
D=1;

Eulers1=[9,10,0];
r1=[0,0,0];

t=linspace(0,360,10);

vi_x=0.1*sind(t);
vi_y=0.2*cosd(t);
vi_z=-5*ones(size(t));

xi=0*ones(size(t));
yi=0*ones(size(t));
zi=20*ones(size(t));


[xo,yo,zo,vo_x,vo_y,vo_z]=Reflection_plane_3D(xi,yi,zi,vi_x,vi_y,vi_z,r1,Eulers1);
% drawing
x_C=10*vo_x+xo;
y_C=10*vo_y+yo;
z_C=10*vo_z+zo;

clf
hold on
model_rectangle_mirror(W,H,D,Eulers1,r1)
plot3([xi;xo;x_C],[yi;yo;y_C],[zi;zo;z_C],'r-',...
[xi;x_C],[yi;y_C],[zi;z_C],'ro')
xlabel('X')
ylabel('Y')
zlabel('Z')
axis equal
## end
#1180, 16:
文档\S应用\网页画板.ftxt
## end
#1181, 4:
1921
## end
#1184, 395:
+[返回目录](,场景测试)
场景测试->的(计算波前,场景测试)->+[新建阅读窗口](,计算波前)
参考::文档\设计文档\Booster光路.ftxt
+[打开文件](+新窗口,参考)



就是一条光路, 依次经过G1,CM1,BBO,CM2,G2. 
然后把这个场景的三维模型以及光线追踪代码写出来. 

场景:...
+[新建阅读窗口](,场景)
场景画板:...
+[逻辑结构转光路](场景,场景画板)
+[设置结构](,场景画板)
+[删除结构](,场景画板)
+[画板](+新画板,场景画板)
是([动词库],动词)->+[打开文件](+新窗口,动词)

Blender输出::
地址::文档\输出\20210722\test1.py
+[有](Blender输出,地址)
+[逻辑结构转3D场景](场景,Blender输出)->+[保存文本](,Blender输出)


## end
#1186, 22:
文档\设计文档\Booster光路.ftxt
## end
#1188, 2343:
+[返回目录](,场景)
+[显示星图](,场景)
+[设置结构](,场景)

+[matlab]"clf;hold on;axis equal"(Matlab,)->+[逻辑结构转光线追踪](场景,+[显示])

+[设置结构](,柱面镜)
+[三维柱面镜](柱面镜,)

[]=>宽=>+[修改内容]"0.1"(,宽)


+光路

光路经过G1,CM1,BBO,CM2,G2. 
+G1->+CM1->+BBO->+CM2->+G2=>[那](_,)=>+经过(光路,_)
光路=>经过(光路,_)=>+在(_,+空间点)

这些元件的位置如下, 
在(BBO,空间点)->+[修改内容]"0,0,0"(,空间点)
+[相对]"-10,0,0"(BBO,CM1)
+[相对]"10,0,0"(BBO,CM2)
+[相对]"10,-2,0"(CM1,G1)
+[相对]"-10,2,0"(CM2,G2)

显示元件位置. 
+[matlab]"clf"(Matlab,)->+[显示光路](+[matlab],光路)

CM都反射了光路
光路=>经过(光路,_re)->_re"CM"=>+反射(_re,光路)
G也都反射了光路
光路=>经过(光路,_re)->_re"G"=>+反射(_re,光路)


BBO是晶体, 有长宽高. G1和G2都是光栅, 有长宽高. CM1和CM2都是柱面镜, 有长宽高和焦距. 
+的(+晶体,+长)->+的(+晶体,+宽)->+的(+晶体,+高)->+是(BBO,+晶体);
+的(+光栅,+长)->+的(+光栅,+宽)->+的(+光栅,+高)->+是(G1,+光栅)->+是(G2,+光栅);
+的(+柱面镜,+长)->+的(+柱面镜,+宽)->+的(+柱面镜,+高)->+的(+柱面镜,+焦距)...
->+是(CM1,+柱面镜)->+是(CM2,+柱面镜);

BBO,G1,G2,CM1,CM2都朝着某个方向
BBO->G1->G2->CM1->CM2=>[那](_,)=>+朝着(_,+方向)->+方向"0,0,0"

+[设置结构](,光栅)


+[matlab]"clf;hold on;axis equal"(Matlab,)->+[逻辑结构转光线追踪](场景,+[显示])
[]=>宽=>+[修改内容]"0.1"(,宽)

CM1的方向调整为"90,90,0", CM2的方向调整为"-90,90,0"
朝着(G1,方向)->+[修改内容]"-95.5,90,0"(,方向)
朝着(CM1,方向)->+[修改内容]"83,90,0"(,方向)
朝着(BBO,方向)->+[修改内容]"-90,90,0"(,方向)
朝着(CM2,方向)->+[修改内容]"-96,90,0"(,方向)->+[matlab]"clf;hold on;axis equal"(Matlab,)->+[逻辑结构转光线追踪](场景,+[显示])
朝着(G2,方向)->+[修改内容]"95.5,90,0"(,方向)

柱面镜(形状,位置) 反射 入射光线(位置,方向), 为 出射光线(位置,方向)
+柱面镜(柱面镜,CM1)->+光线(+位置,+方向)->+位置"-10,-2,0"->+方向"1,0,0"...
->+[反射](+柱面镜,+光线)->+[为](+[反射],+光线)...
->+[del](,+光线)->+[del](,+位置)->+[del](,+方向)->+[del](,+柱面镜)

+柱面镜(柱面镜,CM1)->+[反射代码](+柱面镜,+[显示])->+[del](,+柱面镜)

+光栅(光栅,G1)->+光线(+位置,+方向)->+位置"-10,-2,0"->+方向"1,0,0"...
->+[反射](+光栅,+光线)->+[为](+[反射],+光线)...
->+[del](,+光线)->+[del](,+位置)->+[del](,+方向)->+[del](,+光栅)

+[设置结构](,柱面镜)

光路=>经过(光路,)=>+[显示](,经过)

+[逻辑结构转光线显示](场景,+[显示])
+[逻辑结构转光线追踪](场景,+[显示])->+[显示]


+的(光路,+输入)->+在(+输入,+空间点#1)...
->+的(光路,+输出)->+在(+输出,+空间点#2)

在(输入,空间点)->+[修改内容]"-1000,-2,0"(,空间点)
在(输出,空间点)->+[修改内容]"1000,2,0"(,空间点)

+[逻辑结构转3D场景](场景,+[显示])

光路=>新节点(光路,)=>+[del](,新节点)
光路=>新节点(光路,)=>+[显示](,新节点)

+[三维柱面镜](CM1,柱面镜)->+[显示](,+[Blender])->+[Blender](+[三维柱面镜],)

[]=>长=>+[修改标题]"宽"(,长)
[]=>厚度"1"=>+[修改标题]"宽"(,厚度)
[]=>宽=>+[显示](,宽)
[]=>高=>+[显示](,高)
[]=>厚度=>+[显示](,厚度)


+[蒙卡元件代码](G1,+[显示])
+[逻辑结构转波前模拟](场景,+[临时文本])->+[M函数](,+[临时文本])
+[反射代码](G1,+[显示])
+[逻辑结构转光线追踪](场景,+[显示])
+[逻辑结构转光线追踪](场景,+[临时文本])
+[逻辑结构转光线追踪](场景,+[临时文本])->+[M函数](,+[临时文本])

是(CM1,柱面镜)

+[显示星图](,场景)
## end
#1212, 13:
文档\S应用\星图.txt
## end
#1223, 13:
0.0, 2.0, 0.0
## end
#1225, 14:
10.0, 0.0, 0.0
## end
#1227, 5:
0,0,0
## end
#1229, 15:
-10.0, 0.0, 0.0
## end
#1231, 14:
0.0, -2.0, 0.0
## end
#1238, 21:
+[返回目录](,场景画板)

CM1:

## end
#1257, 1:
1
## end
#1259, 8:
958, 476
## end
#1261, 9:
0.0, 50.0
## end
#1273, 1:
1
## end
#1275, 3:
0.1
## end
#1277, 1:
1
## end
#1291, 1:
1
## end
#1293, 3:
0.1
## end
#1295, 1:
1
## end
#1311, 1:
1
## end
#1313, 1:
1
## end
#1315, 3:
0.1
## end
#1317, 1:
1
## end
#1330, 8:
-96,90,0
## end
#1332, 7:
83,90,0
## end
#1334, 9:
95.5,90,0
## end
#1336, 10:
-95.5,90,0
## end
#1338, 8:
-90,90,0
## end
#1341, 16:
文档\S应用\三维建模.ftxt
## end
#1365, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#1368, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#1371, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#1374, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#1377, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#1392, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#1398, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#1399, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#1400, 2:
圆形
## end
#1401, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#1404, 14:
+[返回目录]
+[内容]

## end
#1405, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#1408, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1410, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#1420, 1:
4
## end
#1421, 10:
0.0, -40.0
## end
#1422, 2:
10
## end
#1423, 18:
-24.55999832281032
## end
#1424, 11:
255,255,255
## end
#1425, 5:
0,0,0
## end
#1426, 8:
DashLine
## end
#1427, 1:
2
## end
#1428, 2:
G2
## end
#1442, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#1448, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#1449, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#1450, 2:
圆形
## end
#1451, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#1454, 14:
+[返回目录]
+[内容]

## end
#1455, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#1458, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1460, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#1470, 1:
4
## end
#1471, 11:
200.0, -0.0
## end
#1472, 2:
10
## end
#1473, 18:
-24.55999832281032
## end
#1474, 11:
255,255,255
## end
#1475, 5:
0,0,0
## end
#1476, 8:
DashLine
## end
#1477, 1:
2
## end
#1478, 3:
CM2
## end
#1492, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#1498, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#1499, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#1500, 2:
圆形
## end
#1501, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#1504, 14:
+[返回目录]
+[内容]

## end
#1505, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#1508, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1510, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#1520, 1:
4
## end
#1521, 9:
0.0, -0.0
## end
#1522, 2:
10
## end
#1523, 18:
-24.55999832281032
## end
#1524, 11:
255,255,255
## end
#1525, 5:
0,0,0
## end
#1526, 8:
DashLine
## end
#1527, 1:
2
## end
#1528, 3:
BBO
## end
#1542, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#1548, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#1549, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#1550, 2:
圆形
## end
#1551, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#1554, 14:
+[返回目录]
+[内容]

## end
#1555, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#1558, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1560, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#1570, 1:
4
## end
#1571, 12:
-200.0, -0.0
## end
#1572, 2:
10
## end
#1573, 18:
-24.55999832281032
## end
#1574, 11:
255,255,255
## end
#1575, 5:
0,0,0
## end
#1576, 8:
DashLine
## end
#1577, 1:
2
## end
#1578, 3:
CM1
## end
#1592, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#1598, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#1599, 1044:
"""
+[返回目录](,画图)
+[返回目录](,图形)
+[新建阅读窗口](,图形)

输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


dx=np.array([-np.sin(theta),-np.cos(theta)])
dy=np.array([-np.cos(theta),np.sin(theta)])

pt0=np.array(pt)
pt1=pt0+dx*r
pt2=pt0+dx*r+dy*d
pt3=pt0-dx*r+dy*d
pt4=pt0-dx*r

x=[pt1[0],pt2[0],pt3[0],pt4[0],pt1[0]]
y=[pt1[1],pt2[1],pt3[1],pt4[1],pt1[1]]

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt0[0]-area,pt0[1]+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#1600, 2:
圆形
## end
#1601, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#1604, 14:
+[返回目录]
+[内容]

## end
#1605, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#1608, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1610, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#1620, 1:
4
## end
#1621, 9:
0.0, 40.0
## end
#1622, 2:
10
## end
#1623, 18:
-24.55999832281032
## end
#1624, 11:
255,255,255
## end
#1625, 5:
0,0,0
## end
#1626, 8:
DashLine
## end
#1627, 1:
2
## end
#1628, 2:
G1
## end
#1630, 163:
+[返回目录](,光线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

焦点::0.7
直径::70

画图:...
选中区域:...
HTML:...
+[创建输入](直径,选中区域)
的(画图,输入)->+[有](HTML,输入)

## end
#1632, 163:
+[返回目录](,光线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

焦点::0.7
直径::70

画图:...
选中区域:...
HTML:...
+[创建输入](直径,选中区域)
的(画图,输入)->+[有](HTML,输入)

## end
#1634, 163:
+[返回目录](,光线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

焦点::0.7
直径::70

画图:...
选中区域:...
HTML:...
+[创建输入](直径,选中区域)
的(画图,输入)->+[有](HTML,输入)

## end
#1636, 163:
+[返回目录](,光线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

焦点::0.7
直径::70

画图:...
选中区域:...
HTML:...
+[创建输入](直径,选中区域)
的(画图,输入)->+[有](HTML,输入)

## end
#1638, 163:
+[返回目录](,光线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

焦点::0.7
直径::70

画图:...
选中区域:...
HTML:...
+[创建输入](直径,选中区域)
的(画图,输入)->+[有](HTML,输入)

## end
#1652, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1658, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1659, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1660, 2:
直线
## end
#1661, 362:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and (d<直径[0]/4 or d<5):
    state=True
else:
    state=False

## end
#1665, 49:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0
直径::70

## end
#1669, 14:
+[返回目录]
+[内容]

## end
#1670, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1672, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1673, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1675, 46:
线颜色::0,0,0
线型::DashLine
线粗细::2
焦点::0.7
直径::70

## end
#1683, 12:
-273.0, 39.0
## end
#1684, 9:
0.0, 40.0
## end
#1685, 7:
255,0,0
## end
#1686, 1:
1
## end
#1687, 9:
SolidLine
## end
#1688, 3:
100
## end
#1689, 1:
5
## end
#1702, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1708, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1709, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1710, 2:
直线
## end
#1711, 362:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and (d<直径[0]/4 or d<5):
    state=True
else:
    state=False

## end
#1715, 49:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0
直径::70

## end
#1719, 14:
+[返回目录]
+[内容]

## end
#1720, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1722, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1723, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1725, 46:
线颜色::0,0,0
线型::DashLine
线粗细::2
焦点::0.7
直径::70

## end
#1733, 9:
0.0, 40.0
## end
#1734, 12:
-200.0, -0.0
## end
#1735, 7:
255,0,0
## end
#1736, 1:
1
## end
#1737, 9:
SolidLine
## end
#1738, 3:
100
## end
#1739, 1:
5
## end
#1752, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1758, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1759, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1760, 2:
直线
## end
#1761, 362:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and (d<直径[0]/4 or d<5):
    state=True
else:
    state=False

## end
#1765, 49:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0
直径::70

## end
#1769, 14:
+[返回目录]
+[内容]

## end
#1770, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1772, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1773, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1775, 46:
线颜色::0,0,0
线型::DashLine
线粗细::2
焦点::0.7
直径::70

## end
#1783, 12:
-200.0, -0.0
## end
#1784, 11:
200.0, -0.0
## end
#1785, 7:
255,0,0
## end
#1786, 1:
1
## end
#1787, 9:
SolidLine
## end
#1788, 3:
100
## end
#1789, 1:
5
## end
#1802, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1808, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1809, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1810, 2:
直线
## end
#1811, 362:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and (d<直径[0]/4 or d<5):
    state=True
else:
    state=False

## end
#1815, 49:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0
直径::70

## end
#1819, 14:
+[返回目录]
+[内容]

## end
#1820, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1822, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1823, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1825, 46:
线颜色::0,0,0
线型::DashLine
线粗细::2
焦点::0.7
直径::70

## end
#1833, 11:
200.0, -0.0
## end
#1834, 10:
0.0, -40.0
## end
#1835, 7:
255,0,0
## end
#1836, 1:
1
## end
#1837, 9:
SolidLine
## end
#1838, 3:
100
## end
#1839, 1:
5
## end
#1852, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1858, 1029:
"""
+[返回目录](,画图)
输入:...
输出:...

图形:...

+[新建阅读窗口](,图形)

"""
pt1=np.array(起点)
pt2=np.array(终点)

D=直径[0]
F=焦点[0]


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0 or 线颜色=='None':
    qp.setBrush(QBrush())
    pen=QPen()
else:
    faceColor=线颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],120)))
    pen=QPen(QColor(faceColor[0],faceColor[1],faceColor[2]),lineWidth)




r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
f=r*F
dx=(pt2-pt1)/r
dy=np.array([dx[1],-dx[0]])

D1=D
D2=D/F*(F-1)

pt01=pt1+dy*D1/2
pt02=pt2+dy*D2/2
pt03=pt2-dy*D2/2
pt04=pt1-dy*D1/2

x=[pt01[0],pt02[0],pt03[0],pt04[0]]
y=[pt01[1],pt02[1],pt03[1],pt04[1]]

path=QPainterPath()
path2=QPainterPath()
for i in range(len(x)):
    if i==0 or i==2:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])

    if i==0:
        path2.moveTo(x[i],y[i])
    else:
        path2.lineTo(x[i],y[i])


qp.setPen(QPen(QColor(0,0,255,0)))
qp.drawPath(path2)

qp.setPen(pen)
qp.drawPath(path)


qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#1859, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#1860, 2:
直线
## end
#1861, 362:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and (d<直径[0]/4 or d<5):
    state=True
else:
    state=False

## end
#1865, 49:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0
直径::70

## end
#1869, 14:
+[返回目录]
+[内容]

## end
#1870, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#1872, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#1873, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#1875, 46:
线颜色::0,0,0
线型::DashLine
线粗细::2
焦点::0.7
直径::70

## end
#1883, 10:
0.0, -40.0
## end
#1884, 12:
257.0, -40.0
## end
#1885, 7:
255,0,0
## end
#1886, 1:
1
## end
#1887, 9:
SolidLine
## end
#1888, 3:
100
## end
#1889, 1:
5
## end
#1893, 17:
文档\S应用\绘制光路图.ftxt
## end
#1894, 4:
1937
## end
#1904, 8:
1000,2,0
## end
#1908, 10:
-1000,-2,0
## end
#1928, 14:
0.0, -2.0, 0.0
## end
#1929, 15:
-10.0, 0.0, 0.0
## end
#1930, 14:
10.0, 0.0, 0.0
## end
#1931, 13:
0.0, 2.0, 0.0
## end
#1932, 5:
0,0,0
## end
#1933, 4:
1952
## end
#1936, 16:
文档\S应用\光路场景.ftxt
## end
#1937, 4:
1983
## end
#1940, 140:
+[返回目录](,对比高斯光束)

高斯光束::文档\物理问题\高斯光束.ftxt
+[打开文件](+新窗口,高斯光束)

高斯光束解析解(html):...
+[H函数](,高斯光束解析解)
菲涅尔积分(html):...
+[H函数](,菲涅尔积分)
蒙卡模拟:...




## end
#1942, 17:
文档\物理问题\高斯光束.ftxt
## end
#1944, 831:
<!--
+[H函数](,高斯光束解析解)
参考::https://en.wikipedia.org/wiki/Gaussian_beam
+[打开网页](,参考)
-->

According to the Wikipedia(%参考), 
the equation is, 
$$
\mathbf{E}(r,z)=E_0\hat{\mathbf{x}}
\frac{w_0}{w(z)}
exp\left(\frac{-r^2}{w(z)^2}\right)
exp\left(-i
\left(
kz+k\frac{r^2}{2R(z)}-\psi(z)
\right)\right)
$$
In the equation, \(k\) is the wave number of the beam. The \(w_0\) is the waist of the beam. The \(E_0\) is the peak intensity. <br>
Other functions in the equation are, 
$$
w(z)=w_0\sqrt{1+\left(
\frac{z}{z_R}
\right)^2}
,\ 
z_R=\frac{\pi w_0^2 n}{\lambda}
$$
The \(n\) is the refractive index of the medium. <br>
The curvature \(R(z)\) is,
$$
R(z)=z\left[
1+\left(
\frac{z_R}{z}
\right)^2
\right]
$$
The Gouy phase is, 
$$
\psi(z)=arctan\left(
\frac{z}{z_R}
\right)
$$



<!--
光场分布函数(M函数):...
+[M函数](,光场分布函数)

+[H函数](,高斯光束解析解)
-->
## end
#1947, 868:
%{
+[返回目录](,光场分布函数)
GaussianBeam(M函数):...
存档(M函数):...

+[M函数](,光场分布函数)
%}

addpath('Matlab\optics');

clf
physics_constant;
lm=800e-9;
w0=0.01e-3;
E0=1;
n=1;

z1=-0.0005;
z2=0.0005;
r1=5*w0;

sz=[-1e-3,0,2e-3,5e-3];
sx=linspace(-r1,r1,500);
sy=linspace(-r1,r1,500);
[SX,SY]=meshgrid(sx,sy);
SR=sqrt(SX.^2+SY.^2);

r=linspace(-r1,r1,500);
z=linspace(z1,z2,510);
[R,Z]=meshgrid(r,z);

E=GaussianBeam(Z,R,lm,w0,E0,n);

subplot(2,1,1)
I=abs(E).^2;
surf(R/1e-3,Z/1e-3,I./max(I')'); %#ok<UDIM>
% surf(R/1e-3,Z/1e-3,real(E));
shading interp
xlabel('r [mm]')
ylabel('z [mm]')
view([90,90])

n=length(sz);
for i=1:n
subplot(2,n,n+i)
    
E=GaussianBeam(sz(i),SR,lm,w0,E0,n);
I=abs(E).^2;

surf(SX/1e-3,SY/1e-3,I)
shading interp
xlabel('X [mm]')
ylabel('Y [mm]')
view([90,90])
axis equal
title(sprintf('z=%.2f mm',sz(i)/1e-3))
end
%plot(Z,rRc)
%axis equal

%{
+[M函数](,光场分布函数)
%}
## end
#1953, 441:
%{
+[返回目录](,GaussianBeam)
地址::Matlab\optics\GaussianBeam.m
+[保存文本](,GaussianBeam)

+[M函数](,GaussianBeam)
%}

function E=GaussianBeam(Z,R,lm,w0,E0,n)
    physics_constant;
    %lm=800e-9;
    %w0=0.01e-3;
    %E0=1;
    %n=1;
    
    zR=pi*w0^2*n/lm;
    k=2*pi/lm;
    
    psi=atan(Z/zR);
    rRc=Z./(Z.^2+zR.^2);
    w=w0*sqrt(1+(Z/zR).^2);
    E=E0*w0./w.*exp(-R.^2./w.^2).*exp(-1i*(k*Z+k*(R.^2/2.*rRc)-psi));

end

%{
+[M函数](,光场分布函数)
%}
## end
#1956, 28:
Matlab\optics\GaussianBeam.m
## end
#1958, 1060:
%{
+[返回目录](,光场分布函数)

+[M函数](,光场分布函数)
GaussianBeam(M函数):...
存档(M函数):
%}

physics_constant;
lm=800e-9;
w0=0.01e-3;
E0=1;
n=1;

zR=pi*w0^2*n/lm;
k=2*pi/lm;
z1=-0.0005;
z2=0.0005;
r1=5*w0;

sz=[0,1e-3];
sx=linspace(-r1,r1,500);
sy=linspace(-r1,r1,500);
[SX,SY]=meshgrid(sx,sy);
SR=sqrt(SX.^2+SY.^2);

r=linspace(-r1,r1,500);
z=linspace(z1,z2,510);
[R,Z]=meshgrid(r,z);

psi=atan(Z/zR);
rRc=Z./(Z.^2+zR.^2);
w=w0*sqrt(1+(Z/zR).^2);
E=E0*w0./w.*exp(-R.^2./w.^2).*exp(-1i*(k*Z+k*(R.^2/2.*rRc)-psi));


subplot(2,1,1)
I=abs(E).^2;
surf(R/1e-3,Z/1e-3,I./max(I')'); %#ok<UDIM>
% surf(R/1e-3,Z/1e-3,real(E));
shading interp
xlabel('r [mm]')
ylabel('z [mm]')
view([90,90])

n=length(sz);
for i=1:n
subplot(2,n,n+i)
    
psi=atan(sz(i)/zR);
rRc=sz(i)./(sz(i).^2+zR.^2);
w=w0*sqrt(1+(sz(i)/zR).^2);
E=E0*w0./w.*exp(-SR.^2./w.^2).*exp(-1i*(k*sz(i)+k*(SR.^2/2.*rRc)-psi));

I=abs(E).^2;

surf(SX/1e-3,SY/1e-3,I)
shading interp
xlabel('X [mm]')
ylabel('Y [mm]')
view([90,90])
axis equal
title(sprintf('z=%.2f mm',sz(i)/1e-3))
end
%plot(Z,rRc)
%axis equal

%{
+[M函数](,光场分布函数)
%}
## end
#1961, 43:
https://en.wikipedia.org/wiki/Gaussian_beam
## end
#1964, 4:
1979
## end
#1967, 5816:
<!--
+[H函数](,菲涅尔积分)
记住菲涅尔积分(节点)
参考::https://en.wikipedia.org/wiki/Fresnel_diffraction
参考2::https://ischebeck.net/presentations/Zemax.pdf

Jackson::file:///C:/Users/cheng/Desktop/paper/Books/Jackson.pdf#page=503
+[打开网页](,Jackson)
-->

I want to get the Gaussion beam solution by using Fresnel integral. Let's start from the Maxwell's equations. <br>
<br>
<b><u>Wave equation</u></b><br>
$$
\begin{cases}
\nabla \cdot \mathbf{E}=\rho/\epsilon_0
, &
\nabla \times \mathbf{E}=-\partial \mathbf{B}/\partial t
\\
\nabla \cdot \mathbf{B}=0
, &
\nabla \times \mathbf{B}=\mu_0 \mathbf{J}+\mu_0\epsilon_0 
\partial \mathbf{E}/\partial t

\end{cases}
$$

If there isn't any free electrons or space currents, then, 
$$
\begin{cases}
\nabla \cdot \mathbf{E}=0
, &
\nabla \times \mathbf{E}=-\partial \mathbf{B}/\partial t
\\
\nabla \cdot \mathbf{B}=0
, &
\nabla \times \mathbf{B}=\mu\epsilon
\partial \mathbf{E}/\partial t

\end{cases}
$$

It's easy to get a wave equation from this, 
$$
\nabla \times (\nabla \times \mathbf{E})
=
-\partial(\nabla \times \mathbf{B})/\partial t
$$
$$
\nabla \cdot (\nabla \cdot \mathbf{E})
-
\nabla^2 \mathbf{E}
=
-\mu\epsilon\partial^2 \mathbf{E}/\partial t^2
$$
$$
\nabla^2 \mathbf{E}
-\mu\epsilon\partial^2 \mathbf{E}/\partial t^2
=0
$$
For the single frequency solution, the equation will be,
$$
\nabla^2 \mathbf{E}
-k_0^2 \mathbf{E}
=0
$$

<br>
<b><u>Green function of the wave equation</u></b><br>
The Green function should satisfied the following equation, 
$$
\nabla^2 G(\vec{r};\vec{r}_0)
-k^2 G(\vec{r};\vec{r}_0)
=\delta^{(3)}(\vec{r}-\vec{r}_0)
$$
Or we can write it in this way,
$$
\nabla^2 G - k_0^2 G
=\delta(x-x_0)\delta(y-y_0)\delta(z-z_0)
$$
By Fourier transform, 
$$
(k_x^2+k_y^2+k_z^2) G_k - k_0^2 G_k
=e^{-i \vec{k}\cdot \vec{r}_0}
$$$$
G_k=\frac{e^{-i \vec{k}\cdot \vec{r}_0}}
{(k_x^2+k_y^2+k_z^2)-k_0^2}
$$
For inverse Fourier transform, we have,
$$
G(x,y,z)=\iiint dk_x dk_y dk_z
\ G_k 
exp(i\vec{k}\cdot \vec{r})
\\
=\iiint dk_x dk_y dk_z
\ 
\frac{e^{i \vec{k}\cdot(\vec{r}-\vec{r}_0)}}
{(k_x^2+k_y^2+k_z^2)-k_0^2}
\\
\equiv
\iiint dk_x dk_y dk_z
\ 
\frac{e^{i \vec{k}\cdot\Delta \vec{r}}}
{(k_x^2+k_y^2+k_z^2)-k_0^2}
$$



Assuming the source \(\Delta \vec{r}=(0,0,\Delta z)\) is on the z-axis, then, 
$$
\frac{e^{i \vec{k}\cdot\Delta \vec{r}}}
{(k_x^2+k_y^2+k_z^2)-k_0^2}

=\frac{e^{-i k_z \Delta z}}
{(k_x^2+k_y^2+k_z^2)-k_0^2}

=\frac{e^{-i k\ cos(\theta) \Delta z}}
{k^2-k_0^2}
$$
By transforming from Cartesian coordinates to spherical coordinates, the integral becomes, 
$$
G(x,y,z)=
\iiint dk_x dk_y dk_z
\ 
\frac{e^{i \vec{k}\cdot\Delta \vec{r}}}
{(k_x^2+k_y^2+k_z^2)-k_0^2}
\\=
\iiint k^2 dk\ sin(\theta)d\theta\ d\phi
\ 
\frac{e^{-i k\ cos(\theta) \Delta z}}
{k^2-k_0^2}

\\=
-2\pi
\int_0^{\infty} dk\ 
\frac{k^2}
{k^2-k_0^2}
\int_0^{\pi} d(cos\theta)
e^{-i k\ cos\theta \Delta z}

\\=
2\pi
\int_0^{\infty} dk\ 
\frac{k^2}
{k^2-k_0^2}
\left[
\frac{1}{ik \Delta z}
e^{-i k\ cos\theta \Delta z}
\right]^{\pi}_{0}

\\=
2\pi
\int_0^{\infty} dk\ 
\frac{k^2}
{k^2-k_0^2}
\left[
\frac{
e^{i k\ r}
-
e^{-i k\ r}
}
{ik r}
\right]
(\Delta z \equiv r)



\\=

\frac{
2\pi
}
{i r}
\int_0^{\infty} dk\ 
\frac{k}
{k^2-k_0^2}
\left[
e^{i k\ r}
-
e^{-i k\ r}
\right]
$$
OK, then we have, 
$$
G(x,y,z)
=
\frac{
2\pi
}
{i r}
\int_{-\infty}^{\infty} dk\ 
\frac{k e^{i k\ r}}
{k^2-k_0^2}
=\frac{e^{ik_0 r}}{r}
$$
<br>
<b><u>Solution from the Green function</u></b><br>
The wave equations for a general solution and the Green function are, 
$$
(\nabla'^2+k_0^2)\psi(\mathbf{x}')=0
$$$$
(\nabla'^2+k_0^2)G(\mathbf{x}',\mathbf{x})=\delta(\mathbf{x}'-\mathbf{x})
$$
Then we have an equation,
$$
\delta(\mathbf{x}'-\mathbf{x}) \psi(\mathbf{x}')
=
\psi(\mathbf{x}')\nabla'^2 G(\mathbf{x}',\mathbf{x})
-G(\mathbf{x}',\mathbf{x})\nabla'^2 \psi(\mathbf{x}')
$$
$$
\psi(\mathbf{x})
=\iiint dV'\ 
\delta(\mathbf{x}'-\mathbf{x}) \psi(\mathbf{x}')
\\
=\iiint 
[\psi(\mathbf{x}')\nabla'^2 G(\mathbf{x}',\mathbf{x})
-G(\mathbf{x}',\mathbf{x})\nabla'^2 \psi(\mathbf{x}')] dV'
\\
=\iiint \nabla'\cdot
[\psi(\mathbf{x}')\nabla' G(\mathbf{x}',\mathbf{x})
-G(\mathbf{x}',\mathbf{x})\nabla' \psi(\mathbf{x}')] dV'
\\
=\oint
[\psi(\mathbf{x}')\nabla' G(\mathbf{x}',\mathbf{x})
-G(\mathbf{x}',\mathbf{x})\nabla' \psi(\mathbf{x}')]\cdot \mathbf{n}' da'
$$
<b><u>Generalized Kirchhoff integral</u></b><br>
Since in our cases, the integral surface is an infinite plane. We can use the Dirichlet Green function to make \(\nabla G_D=0\) at all points on the surface. The form of Dirichlet Green function here is, 
$$
G_D(\mathbf{x};\mathbf{x}')=\frac{1}{4\pi}
\left(
\frac{e^{ikr}}{r}-
\frac{e^{ikr'}}{r'}
\right)
$$$$
r=\sqrt{(x-x')^2+(y-y')^2+(z-z')^2}
$$$$
r'=\sqrt{(x-x')^2+(y-y')^2+(z+z')^2}
$$
while the plane is at \(z=0\). 
Then the generalized Kirchhoff integral is,
$$
\psi(\mathbf{x})
=
\oint
\psi(\mathbf{x}')\nabla' G(\mathbf{x}',\mathbf{x})\cdot \mathbf{n}' da'
$$$$
\nabla' G(x',y',z'=0;x,y,z)
=
\frac{1}{4\pi}
\nabla' 
\left(
\frac{e^{ikr}}{r}-
\frac{e^{ikr'}}{r'}
\right)
$$
We have,
$$
\nabla \frac{e^{ikr}}{r}
=
\frac{e^{ikr}}{r}(ik-\frac{1}{r})\hat{r}
=
ik \frac{e^{ikr}}{r}(1+\frac{i}{k r})\hat{r}
$$
According to the geometry, \(\hat{n}\cdot\hat{r}=-\hat{n}\cdot\hat{r}'\), then we have, 
$$
\psi(\mathbf{x})
=
\frac{1}{4\pi}
\oint
\psi(\mathbf{x}')
\nabla' 
\left(
\frac{e^{ikr}}{r}-
\frac{e^{ikr'}}{r'}
\right)
\cdot \mathbf{n}' da'
\\
=
\frac{ik}{2\pi}
\oint
\psi(\mathbf{x}')
\frac{e^{ikr}}{r}
\left(
1+\frac{i}{k r}
\right)
\hat{r}
\cdot \mathbf{n}' da'
$$

Comparing to (10.85) in Jackson page 481, we should modify the result by a minus,
$$
\psi(\mathbf{x})

=
-\frac{ik}{2\pi}
\oint
\psi(\mathbf{x}')
\frac{e^{ikr}}{r}
\left(
1+\frac{i}{k r}
\right)
\hat{r}
\cdot \mathbf{n}' da'
$$
The Gaussian beam solution is tested here. 

<!--
+[H函数](,菲涅尔积分)
正向积分(M函数):...
+[M函数](,正向积分)
-->
## end
#1972, 49:
https://en.wikipedia.org/wiki/Fresnel_diffraction
## end
#1974, 45:
https://ischebeck.net/presentations/Zemax.pdf
## end
#1976, 1183:
%{
+[M函数](,正向积分)

备份:...
+[新建阅读窗口](,备份)
WavefrontPropagation(M函数):...
+[新建阅读窗口](,WavefrontPropagation)
透镜组场景(M函数):...
+[M函数](,透镜组场景)
figure
%}


clf
addpath('Matlab\optics')
physics_constant;
lm=800e-9;
w0=0.002e-3;
A0=1;
n=1;

z0=-0.1e-3;
sz=0.3e-2;

D=0.1e-3;

k=2*pi/lm;

x0=linspace(-D/5,D/5,100);
y0=linspace(-D/5,D/5,100);

[Y0,X0]=meshgrid(y0,x0);
Z0=z0*ones(size(X0));
R0=sqrt(X0.^2+Y0.^2);
E0=GaussianBeam(Z0,R0,lm,w0,A0,n);


x=linspace(-D/2,D/2,50);
y=linspace(-D/2,D/2,50);

dx=x(2)-x(1);
dy=y(2)-y(1);

[Y,X]=meshgrid(y,x);
Z=sz*ones(size(X));

R=sqrt(X.^2+Y.^2);
E1=GaussianBeam(Z,R,lm,w0,A0,n);
E=WavefrontPropagation(X,Y,Z,E0,X0,Y0,Z0,lm,dx,dy);


subplot(1,2,1)
surf(X0/1e-3,Y0/1e-3,abs(E0))
view(0,90)
xlabel('X [mm]')
ylabel('Y [mm]')
title(sprintf('Source: z=%.2f mm',z0/1e-3))
axis equal
shading interp

subplot(2,2,2)
surf(X/1e-3,Y/1e-3,real(E))
view(0,90)
xlabel('X [mm]')
ylabel('Y [mm]')
title(sprintf('Field(simulation): z=%.2f mm',sz/1e-3))
axis equal
shading interp

subplot(2,2,4)
surf(X/1e-3,Y/1e-3,real(E1))
view(0,90)
xlabel('X [mm]')
ylabel('Y [mm]')
title(sprintf('Field(theory): z=%.2f mm',sz/1e-3))
axis equal
shading interp



%{
+[M函数](,正向积分)
%}
## end
#1978, 4:
1986
## end
#1981, 63:
file:///C:/Users/cheng/Desktop/paper/Books/Jackson.pdf#page=503
## end
#1982, 4:
2005
## end
#1985, 1441:
%{
+[M函数](,正向积分)

备份:...
+[新建阅读窗口](,备份)
WavefrontPropagation(M函数):...
+[新建阅读窗口](,WavefrontPropagation)
%}


clf
addpath('Matlab\optics')
physics_constant;
lm=800e-9;
w0=0.002e-3;
A0=1;
n=1;

z0=-0.1e-3;
sz=0.e-3;

D=0.1e-3;

k=2*pi/lm;

x0=linspace(-D/5,D/5,100);
y0=linspace(-D/5,D/5,100);

[Y0,X0]=meshgrid(y0,x0);
Z0=z0*ones(size(X0));
R0=sqrt(X0.^2+Y0.^2);
%E0=ones(size(X0));
E0=GaussianBeam(Z0,R0,lm,w0,A0,n);


x=linspace(-D/2,D/2,50);
y=linspace(-D/2,D/2,50);

dx=x(2)-x(1);
dy=y(2)-y(1);

[Y,X]=meshgrid(y,x);
Z=sz*ones(size(X));

R=sqrt(X.^2+Y.^2);
E1=GaussianBeam(Z,R,lm,w0,A0,n);

E=zeros(size(X));
for i=1:size(X,1)
    for j=1:size(X,2)
        DR=sqrt((X(i,j)-X0).^2+(Y(i,j)-Y0).^2+(Z(i,j)-Z0).^2);

Ktheta=abs(Z(i,j)-Z0)./DR;

        dE=1i*k/2/pi*E0.*exp(-1i*k*DR).*(1+1i/k./DR).*Ktheta;
        E(i,j)=sum(sum(dE))*dx*dy;
    end
end

%{
subplot(1,3,1)
plot3(X0,Y0,Z0,'b+',X,Y,Z,'r.')
axis equal
%}

subplot(1,2,1)
surf(X0/1e-3,Y0/1e-3,abs(E0))
view(0,90)
xlabel('X [mm]')
ylabel('Y [mm]')
title(sprintf('Source: z=%.2f mm',z0/1e-3))
axis equal
shading interp

subplot(2,2,2)
surf(X/1e-3,Y/1e-3,real(E))
view(0,90)
xlabel('X [mm]')
ylabel('Y [mm]')
title(sprintf('Field(simulation): z=%.2f mm',sz/1e-3))
% axis equal
shading interp

subplot(2,2,4)
surf(X/1e-3,Y/1e-3,real(E1))
view(0,90)
xlabel('X [mm]')
ylabel('Y [mm]')
title(sprintf('Field(theory): z=%.2f mm',sz/1e-3))
% axis equal
shading interp



%{
+[M函数](,正向积分)
%}
## end
#1987, 225:
+[返回目录](,蒙卡模拟)

做蒙卡模拟的话, 需要考虑清楚怎么用随机分布. 
我现在的打算是, 对发射方向和发射位置取均匀的随机分布. 

测试发射轨迹(M函数):...
+[新建阅读窗口](,测试发射轨迹)
例子_高斯光束(M函数):...
+[新建阅读窗口](,例子_高斯光束)
+[M函数](,例子_高斯光束)
柱面镜模拟(M函数):...

解决一下柱面镜的问题. 
抛物镜反射公式:...
+[新建阅读窗口](,抛物镜反射公式)




## end
#1989, 673:
%{
+[M函数](,测试发射轨迹)
%}


D=1e-3;
Dtheta=0.1;
N=1000000;
z0=0*ones(1,N);
z1=1*ones(1,N);

x=linspace(-1e-3,1e-3,50);
y=linspace(-1e-3,1e-3,50);
[X,Y]=meshgrid(x,y);
density=zeros(size(X));


theta=random('Uniform',0,Dtheta/2,1,N);
phi=random('Uniform',0,360,1,N);
x0=random('Uniform',-D/2,D/2,1,N);
y0=random('Uniform',-D/2,D/2,1,N);

kx=sind(theta).*cosd(phi);
ky=sind(theta).*sind(phi);
kz=cosd(theta);

Dz=z1-z0;

x1=x0+kx./kz.*Dz;
y1=y0+ky./kz.*Dz;

for i=1:size(X,1)-1
for j=1:size(X,2)-1
I=find(x1>=X(i,j)&x1<X(i,j+1) & y1>=Y(i,j)&y1<Y(i+1,j));
density(i,j)=numel(I);
end
end


% plot3([x0;x1],[y0;y1],[z0;z1],'r.-')
surf(X,Y,density)
view(90,90)

%{
+[M函数](,测试发射轨迹)
%}
## end
#1992, 1618:
%{
+[M函数](,例子_高斯光束)

备份:...
+[新建阅读窗口](,备份)
%}


clf
addpath('Matlab\optics')
physics_constant;
lm=800e-9;
w0=0.02;
A0=1;
n=1;

z0=-0.1;
sz=0.e-3;

D=0.3;
Dtheta=0.01;
N=100000;

k=2*pi/lm;

x0=linspace(-D/5,D/5,100);
y0=linspace(-D/5,D/5,100);

[X0,Y0]=meshgrid(x0,y0);
Z0=z0*ones(size(X0));
R0=sqrt(X0.^2+Y0.^2);
E0=GaussianBeam(Z0,R0,lm,w0,A0,n);


x=linspace(-D/2,D/2,50);
y=linspace(-D/2,D/2,50);

[X,Y]=meshgrid(x,y);
Z=sz*ones(size(X));
R=sqrt(X.^2+Y.^2);
E1=GaussianBeam(Z,R,lm,w0,A0,n);



z1=z0*ones(1,N);
z2=sz*ones(1,N);

theta=random('Uniform',0,Dtheta/2,1,N);
phi=random('Uniform',0,360,1,N);
x1=random('Uniform',-D/2,D/2,1,N);
y1=random('Uniform',-D/2,D/2,1,N);

kx=sind(theta).*cosd(phi);
ky=sind(theta).*sind(phi);
kz=cosd(theta);

Dz=z2-z1;

x2=x1+kx./kz.*Dz;
y2=y1+ky./kz.*Dz;
r1=sqrt(x1.^2+y1.^2);
r12=sqrt((x1-x2).^2+(y1-y2).^2+(z1-z2).^2);
e1=GaussianBeam(z1,r1,lm,w0,A0,n);

E=zeros(size(X));

for i=1:size(X,1)-1
for j=1:size(X,2)-1
I=find(x2>=X(i,j)&x2<X(i,j+1) & y2>=Y(i,j)&y2<Y(i+1,j));
e2=1i*k/2/pi*e1(I).*exp(-1i*k*r12(I)).*(1+1i/k./r12(I));
E(i,j)=sum(e2);
end
end

subplot(1,2,1)
surf(X0/1e-3,Y0/1e-3,abs(E0))
view(0,90)
xlabel('X [mm]')
ylabel('Y [mm]')
title(sprintf('Source: z=%.2f mm',z0/1e-3))
axis equal
shading interp

subplot(2,2,2)
surf(X/1e-3,Y/1e-3,real(E))
view(0,90)
xlabel('X [mm]')
ylabel('Y [mm]')
title(sprintf('Field(simulation): z=%.2f mm',sz/1e-3))
% axis equal
shading interp

subplot(2,2,4)
surf(X/1e-3,Y/1e-3,real(E1))
view(0,90)
xlabel('X [mm]')
ylabel('Y [mm]')
title(sprintf('Field(theory): z=%.2f mm',sz/1e-3))
% axis equal
shading interp



%{
+[M函数](,正向积分)
%}
## end
#1994, 4:
2005
## end
#1997, 2244:
%{
+[M函数](,柱面镜模拟)

显示场景(M函数):...
+[M函数](,显示场景)
平面镜对比_r(M函数):...
平面镜扰动(M函数):...
%}

clf

addpath('Matlab\space')
addpath('Matlab\optics')

% beam
physics_constant;
lm=800e-9;
w0=0.02;
A0=1;
n=1;

xs=20;
xf=35;

Dz=0.5;
Dz2=0.5;
Dtheta=0.0001;
N=10000;

% mirror
a=0.05;
W=20;
H=1;
D=10;

Eulers1=[90,90,0];
r1=[0,5,0];


% Gaussian
k=2*pi/lm;

y0=linspace(-Dz/5,Dz/5,100);
z0=linspace(-Dz/5,Dz/5,100);

[Y0,Z0]=meshgrid(y0,z0);
X0=xs*ones(size(Y0));
R0=sqrt(Y0.^2+Z0.^2);
E0=GaussianBeam(0,R0,lm,w0,A0,n);


y=linspace(-Dz2/2,Dz2/2,50);
z=linspace(-Dz2/2,Dz2/2,50);

[Y,Z]=meshgrid(y,z);
E=zeros(size(Y));
density=zeros(size(Y));

for kj=1

    x1=xs*ones(1,N);
    x2=xf*ones(1,N);

    theta=random('Uniform',180-Dtheta/2,180,1,N);
    phi=random('Uniform',0,360,1,N);
    y1=random('Uniform',-Dz/2,Dz/2,1,N);
    z1=random('Uniform',-Dz/2,Dz/2,1,N);

    k1_y=sind(theta).*cosd(phi);
    k1_z=sind(theta).*sind(phi);
    k1_x=cosd(theta);



    % [xi,yi,zi,ki_x,ki_y,ki_z]=Reflection_plane_3D(x1,y1,z1,k1_x,k1_y,k1_z,r1,Eulers1);
    [xi,yi,zi,ki_x,ki_y,ki_z]=Reflection_parabola_3D(x1,y1,z1,k1_x,k1_y,k1_z,a,r1,Eulers1);

    Dx=x2-xi;
    y2=yi+ki_y./ki_x.*Dx;
    z2=zi+ki_z./ki_x.*Dx;

    r1=sqrt(y1.^2+z1.^2);
    r1i=sqrt((x1-xi).^2+(y1-yi).^2+(z1-zi).^2);
    ri2=sqrt((x2-xi).^2+(y2-yi).^2+(z2-zi).^2);
    r12=r1i+ri2;
    e1=GaussianBeam(0,r1,lm,w0,A0,n);

    y2_m=y2-mean(y2);
    z2_m=z2-mean(z2);


    for i=1:size(Y,1)-1
        for j=1:size(Y,2)-1
            I=find(y2_m>=Y(i,j)&y2_m<Y(i,j+1) & z2_m>=Z(i,j)&z2_m<Z(i+1,j));
            e2=1i*k/2/pi*e1(I).*exp(-1i*k*r12(I)).*(1+1i/k./r12(I));
            E(i,j)=E(i,j)+sum(e2);
            density(i,j)=density(i,j)+numel(I);
        end
    end

end

subplot(1,3,1)
surf(Y0,Z0,abs(E0))
view(0,90)
xlabel('X [m]')
ylabel('Y [m]')
title(sprintf('Source: z=%.2f m',xs))
axis equal
shading interp

subplot(1,3,2)
surf(Y,Z,density/max(max(real(density))))
view(0,90)
xlabel('X [m]')
ylabel('Y [m]')
title(sprintf('density: x=%.2f m',xf))
% axis equal
% shading interp

subplot(1,3,3)
surf(Y+mean(y2),Z+mean(z2),abs(E)/max(max(abs(E))))
view(0,90)
xlabel('X [m]')
ylabel('Y [m]')
title(sprintf('Field(simulation): x=%.2f m',xf))
axis equal
shading interp


%{
+[M函数](,柱面镜模拟)
%}
## end
#2000, 965:
%{
+[M函数](,显示场景)
%}

addpath('Matlab\space')
addpath('Matlab\optics')

% beam
physics_constant;
lm=800e-9;
w0=0.005e-3;
A0=1;
n=1;

xs=20;
xf=25;

Dz=1;
Dtheta=0.0001;
N=100;

% mirror
a=0.001;
W=20;
H=1;
D=10;

Eulers1=[90,90,0];
r1=[0,5,0];


k=2*pi/lm;

x1=xs*ones(1,N);
x2=xf*ones(1,N);

theta=random('Uniform',180-Dtheta/2,180,1,N);
phi=random('Uniform',0,360,1,N);
y1=random('Uniform',-Dz/2,Dz/2,1,N);
z1=random('Uniform',-Dz/2,Dz/2,1,N);

k1_y=sind(theta).*cosd(phi);
k1_z=sind(theta).*sind(phi);
k1_x=cosd(theta);



[xi,yi,zi,ki_x,ki_y,ki_z]=Reflection_parabola_3D(x1,y1,z1,k1_x,k1_y,k1_z,a,r1,Eulers1);

% drawing
Dx=x2-xi;
y2=yi+ki_y./ki_x.*Dx;
z2=zi+ki_z./ki_x.*Dx;

r1=sqrt(y1.^2+z1.^2);
r1i=sqrt((x1-xi).^2+(y1-yi).^2+(z1-zi).^2);
ri2=sqrt((x2-xi).^2+(y2-yi).^2+(z2-zi).^2);
e1=GaussianBeam(0,r1,lm,w0,A0,n);


clf
hold on
model_para_cylindrical_mirror(a,W,H,D,Eulers1,r1)
plot3([x1;xi;x2],[y1;yi;y2],[z1;zi;z2],'ro-')
axis equal


%{
+[M函数](,显示场景)
%}
## end
#2004, 877:
%{
+[M函数](,20210720Debug)
%}

addpath('Matlab\space')
addpath('Matlab\optics')

% beam
physics_constant;


xs=20;
xf=25;

Dz=1;
Dtheta=0.0001;
N=1;

% mirror
a=0.001;
W=20;
H=1;
D=10;

Eulers1=[90,90,0];
r1=[0,5,0];



x1=xs*ones(1,N);
x2=xf*ones(1,N);

%{
theta=random('Uniform',180-Dtheta/2,180,1,N)
phi=random('Uniform',0,360,1,N)
y1=random('Uniform',-Dz/2,Dz/2,1,N)
z1=random('Uniform',-Dz/2,Dz/2,1,N)
%}

%{
+[M函数](,20210720Debug)
%}

%%{
theta=180-3e-5;
phi=93;
y1=0.3775;
z1=0.3061;
%}


k1_y=sind(theta).*cosd(phi);
k1_z=sind(theta).*sind(phi);
k1_x=cosd(theta);



[xi,yi,zi,ki_x,ki_y,ki_z]=Reflection_parabola_3D(x1,y1,z1,k1_x,k1_y,k1_z,a,r1,Eulers1);

% drawing
Dx=x2-xi;
y2=yi+ki_y./ki_x.*Dx;
z2=zi+ki_z./ki_x.*Dx;

clf
hold on
model_para_cylindrical_mirror(a,W,H,D,Eulers1,r1)
plot3([x1;xi;x2],[y1;yi;y2],[z1;zi;z2],'ro-')
axis equal


%{
+[M函数](,20210720Debug)
%}
## end
#2006, 4:
2021
## end
#2009, 1929:
%{
+[返回目录](,Reflection_parabola_3D)
+[M函数](,测试)
%}

clf
addpath('Matlab\space')
addpath('Matlab\optics')

theta=180-3e-5;
phi=93;

a=0.001;
W=20;
H=1;
D=10;

Eulers=[90,90,0];
r0=[0,5,0];

x2=25;
xi=20;
yi=0.3775;
zi=0.3061;

alpha=Eulers(1);
beta=Eulers(2);
gamma=Eulers(3);

vi_x=cosd(theta);
vi_y=sind(theta).*cosd(phi);
vi_z=sind(theta).*sind(phi);



% local frame
fx=[
-sind(gamma)*sind(alpha)*cosd(beta)+cosd(gamma)*cosd(alpha)
sind(gamma)*cosd(alpha)*cosd(beta)+cosd(gamma)*sind(alpha)
sind(gamma)*sind(beta)]';

fy=[
-cosd(gamma)*sind(alpha)*cosd(beta)-sind(gamma)*cosd(alpha)
cosd(gamma)*cosd(alpha)*cosd(beta)-sind(gamma)*sind(alpha)
cosd(gamma)*sind(beta)]';

fz=[
sind(alpha)*sind(beta)
-cosd(alpha)*sind(beta)
cosd(beta)]';

DX=xi-r0(1);
DY=yi-r0(2);
DZ=zi-r0(3);


x_A=fx(1)*DX+fx(2)*DY+fx(3)*DZ;
y_A=fy(1)*DX+fy(2)*DY+fy(3)*DZ;
z_A=fz(1)*DX+fz(2)*DY+fz(3)*DZ;

v_x=fx(1)*vi_x+fx(2)*vi_y+fx(3)*vi_z;
v_y=fy(1)*vi_x+fy(2)*vi_y+fy(3)*vi_z;
v_z=fz(1)*vi_x+fz(2)*vi_y+fz(3)*vi_z;




judge=4*a.*v_x.^2.*(a*x_A.^2-z_A)./(2*a*v_x.*v_z.*x_A-v_z.^2);

t1=(-(2*a*v_x.*x_A-v_z)+sqrt((2*a*v_x.*x_A-v_z).^2-4*a*v_x.^2.*(a*x_A.^2-z_A)))/2/a./v_x.^2;
% t1(v_x==0)=(a*x_A(v_x==0).^2-z_A(v_x==0))./v_z(v_x==0);
t1(judge<1e-7)=-(a*x_A(judge<1e-7).^2-z_A(judge<1e-7))./(2*a*v_x(judge<1e-7).*x_A(judge<1e-7)-v_z(judge<1e-7));


x_B=t1.*v_x+x_A;
y_B=t1.*v_y+y_A;
z_B=t1.*v_z+z_A;

v_0=sqrt(v_x.^2+v_z.^2);
theta1=sign(v_z).*acosd(v_x./v_0);
theta2=atand(2*a*x_B);
theta3=2*theta2-theta1;

v_x2=cosd(theta3);
v_y2=v_y;
v_z2=sind(theta3);

[xo,yo,zo]=transform_3D(r0,alpha,beta,gamma,x_B,y_B,z_B);
[vo_x,vo_y,vo_z]=transform_3D([0,0,0],alpha,beta,gamma,v_x2,v_y2,v_z2);


Dx=x2-xo;
y2=yo+vo_y./vo_x.*Dx;
z2=zo+vo_z./vo_x.*Dx;

subplot(1,2,1)
plot3([x_A;x_B],[y_A;y_B],[z_A;z_B],'o')

subplot(1,2,2);
hold on
model_para_cylindrical_mirror(a,W,H,D,Eulers,r0);
plot3([xi;xo;x2],[yi;yo;y2],[zi;zo;z2],'ro-');
axis equal



%{
+[M函数](,测试)
%}
## end
#2011, 4:
2033
## end
#2014, 1674:
%{
+[M函数](,直接模拟)
%}


clf
addpath('Matlab\optics')
physics_constant;
lm=800e-9;
w0=0.05;
A0=1;
n=1;

z0=-20;
sz=10;

D=0.5;
Dtheta=0.01;
N=1000000;

k=2*pi/lm;

x0=linspace(-D/5,D/5,100);
y0=linspace(-D/5,D/5,100);

[X0,Y0]=meshgrid(x0,y0);
Z0=z0*ones(size(X0));
R0=sqrt(X0.^2+Y0.^2);
E0=GaussianBeam(Z0,R0,lm,w0,A0,n);


x=linspace(-D/2,D/2,50);
y=linspace(-D/2,D/2,50);

[X,Y]=meshgrid(x,y);
Z=sz*ones(size(X));
R=sqrt(X.^2+Y.^2);
E1=GaussianBeam(Z,R,lm,w0,A0,n);



z1=z0*ones(1,N);
z2=sz*ones(1,N);

theta=random('Uniform',0,Dtheta/2,1,N);
phi=random('Uniform',0,360,1,N);
x1=random('Uniform',-D/2,D/2,1,N);
y1=random('Uniform',-D/2,D/2,1,N);

kx=sind(theta).*cosd(phi);
ky=sind(theta).*sind(phi);
kz=cosd(theta);

Dz=z2-z1;

x2=x1+kx./kz.*Dz;
y2=y1+ky./kz.*Dz;
r1=sqrt(x1.^2+y1.^2);
r12=sqrt((x1-x2).^2+(y1-y2).^2+(z1-z2).^2);
e1=GaussianBeam(z1,r1,lm,w0,A0,n);

E=zeros(size(X));
density=zeros(size(X));

for i=1:size(X,1)-1
    for j=1:size(X,2)-1
        I=find(x2>=X(i,j)&x2<X(i,j+1) & y2>=Y(i,j)&y2<Y(i+1,j));
        e2=1i*k/2/pi*e1(I).*exp(-1i*k*r12(I)).*(1+1i/k./r12(I));
        E(i,j)=sum(e2);
        density(i,j)=numel(I);
    end
end

subplot(1,3,1)
surf(X0,Y0,abs(E0))
view(0,90)
xlabel('X [m]')
ylabel('Y [m]')
title(sprintf('Source: z=%.2f m',z0))
axis equal
shading interp

subplot(1,3,2)
surf(X,Y,real(density)/max(max(real(density))))
view(0,90)
xlabel('X [m]')
ylabel('Y [m]')
title(sprintf('Field(simulation): z=%.2f m',sz))
axis equal
% shading interp

subplot(1,3,3)
surf(X,Y,real(E)/max(max(real(E))))
view(0,90)
xlabel('X [m]')
ylabel('Y [m]')
title(sprintf('Field(simulation): z=%.2f m',sz))
axis equal
% shading interp




%{
+[M函数](,直接模拟)
%}
## end
#2017, 1501:
%{
+[M函数](,柱面镜模拟)

显示场景(M函数):...
+[M函数](,显示场景)
%}

clf

addpath('Matlab\space')
addpath('Matlab\optics')

% beam
physics_constant;
lm=800e-9;
w0=0.05;
A0=1;
n=1;

xs=20;
xf=10;

Dz=0.5;
Dz2=0.5;
Dtheta=0.000001;
N=100;

% mirror
a=0.000001;
W=20;
H=1;
D=10;

Eulers1=[90,90,0];
r1=[0,5,0];


% Gaussian
k=2*pi/lm;

y0=linspace(-Dz/5,Dz/5,100);
z0=linspace(-Dz/5,Dz/5,100);

[Y0,Z0]=meshgrid(y0,z0);
X0=xs*ones(size(Y0));
R0=sqrt(Y0.^2+Z0.^2);
E0=GaussianBeam(0,R0,lm,w0,A0,n);


y=linspace(-Dz2/2,Dz2/2,50);
z=linspace(-Dz2/2,Dz2/2,50);

[Y,Z]=meshgrid(y,z);


x1=xs*ones(1,N);
x2=xf*ones(1,N);

theta=random('Uniform',180-Dtheta/2,180,1,N);
phi=random('Uniform',0,360,1,N);
y1=random('Uniform',-Dz/2,Dz/2,1,N);
z1=random('Uniform',-Dz/2,Dz/2,1,N);

k1_y=sind(theta).*cosd(phi);
k1_z=sind(theta).*sind(phi);
k1_x=cosd(theta);



[xi0,yi0,zi0,ki0_x,ki0_y,ki0_z]=Reflection_plane_3D(x1,y1,z1,k1_x,k1_y,k1_z,r1,Eulers1);
[xi,yi,zi,ki_x,ki_y,ki_z]=Reflection_parabola_3D(x1,y1,z1,k1_x,k1_y,k1_z,a,r1,Eulers1);

Dx=x2-xi;
y2=yi+ki_y./ki_x.*Dx;
z2=zi+ki_z./ki_x.*Dx;

Dx=x2-xi0;
x20=x2;
y20=yi0+ki0_y./ki0_x.*Dx;
z20=zi0+ki0_z./ki0_x.*Dx;

r1i=sqrt((x1-xi).^2+(y1-yi).^2+(z1-zi).^2);
ri2=sqrt((x2-xi).^2+(y2-yi).^2+(z2-zi).^2);
r12=r1i+ri2;

r1i=sqrt((x1-xi0).^2+(y1-yi0).^2+(z1-zi0).^2);
ri2=sqrt((x20-xi0).^2+(y20-yi0).^2+(z20-zi0).^2);
r120=r1i+ri2;

%plot(xi0,xi)
%plot(yi0,yi)
%plot(zi0,zi)

%plot(ki0_x,ki_x)
%plot(ki0_y,ki_y)
%plot(ki0_z,ki_z)

subplot(1,2,1)
plot(r12)

subplot(1,2,2)
plot(r120)




## end
#2020, 2111:
%{
+[M函数](,柱面镜模拟)

显示场景(M函数):...
+[M函数](,显示场景)
平面镜对比_r(M函数):...

%}

clf

addpath('Matlab\space')
addpath('Matlab\optics')

% beam
physics_constant;
lm=800e-9;
w0=0.05;
A0=1;
n=1;

xs=20;
xf=10;

Dz=0.5;
Dz2=0.5;
Dtheta=0.000001;
N=1000000;

% mirror
a=0.00001;
W=20;
H=1;
D=10;

Eulers1=[90,90,0];
r1=[0,5,0];


% Gaussian
k=2*pi/lm;

y0=linspace(-Dz/5,Dz/5,100);
z0=linspace(-Dz/5,Dz/5,100);

[Y0,Z0]=meshgrid(y0,z0);
X0=xs*ones(size(Y0));
R0=sqrt(Y0.^2+Z0.^2);
E0=GaussianBeam(0,R0,lm,w0,A0,n);


y=linspace(-Dz2/2,Dz2/2,50);
z=linspace(-Dz2/2,Dz2/2,50);

[Y,Z]=meshgrid(y,z);


x1=xs*ones(1,N);
x2=xf*ones(1,N);

theta=random('Uniform',180-Dtheta/2,180,1,N);
phi=random('Uniform',0,360,1,N);
y1=random('Uniform',-Dz/2,Dz/2,1,N);
z1=random('Uniform',-Dz/2,Dz/2,1,N);

k1_y=sind(theta).*cosd(phi);
k1_z=sind(theta).*sind(phi);
k1_x=cosd(theta);



[xi,yi,zi,ki_x,ki_y,ki_z]=Reflection_plane_3D(x1,y1,z1,k1_x,k1_y,k1_z,r1,Eulers1);
%[xi,yi,zi,ki_x,ki_y,ki_z]=Reflection_parabola_3D(x1,y1,z1,k1_x,k1_y,k1_z,a,r1,Eulers1);

Dx=x2-xi;
y2=yi+ki_y./ki_x.*Dx;
z2=zi+ki_z./ki_x.*Dx;

r1=sqrt(y1.^2+z1.^2);
r1i=sqrt((x1-xi).^2+(y1-yi).^2+(z1-zi).^2);
ri2=sqrt((x2-xi).^2+(y2-yi).^2+(z2-zi).^2);
r12=r1i+ri2;
r12=r12-rand(1,N)*1e-4;
e1=GaussianBeam(0,r1,lm,w0,A0,n);

E=zeros(size(Y));
density=zeros(size(Y));
y2_m=y2-mean(y2);
z2_m=z2-mean(z2);


for i=1:size(Y,1)-1
    for j=1:size(Y,2)-1
        I=find(y2_m>=Y(i,j)&y2_m<Y(i,j+1) & z2_m>=Z(i,j)&z2_m<Z(i+1,j));
        e2=1i*k/2/pi*e1(I).*exp(-1i*k*r12(I)).*(1+1i/k./r12(I));
        E(i,j)=sum(e2);
        density(i,j)=numel(I);
    end
end

subplot(1,3,1)
surf(Y0,Z0,abs(E0))
view(0,90)
xlabel('X [m]')
ylabel('Y [m]')
title(sprintf('Source: z=%.2f m',xs))
axis equal
shading interp

subplot(1,3,2)
surf(Y,Z,density/max(max(real(density))))
view(0,90)
xlabel('X [m]')
ylabel('Y [m]')
title(sprintf('density: x=%.2f m',xf))
% axis equal
% shading interp

subplot(1,3,3)
surf(Y+mean(y2),Z+mean(z2),abs(E)/max(max(abs(E))))
view(0,90)
xlabel('X [m]')
ylabel('Y [m]')
title(sprintf('Field(simulation): x=%.2f m',xf))
axis equal
shading interp



%{
+[M函数](,柱面镜模拟)
%}
## end
#2022, 4:
2073
## end
#2025, 74:
+[返回目录](,动词)
+[粘贴](,动词)

逻辑结构转波前模拟:...
蒙卡元件代码:...

+[新建阅读窗口](,逻辑结构转波前模拟)


## end
#2026, 205:

% %[元件名]
[xo,yo,zo,ko_x,ko_y,ko_z]=%[元件反射](xi,yi,zi,ki_x,ki_y,ki_z,1/4/%[焦距],%[位置],%[欧拉角]);
rio=sqrt((xo-xi).^2+(yo-yi).^2+(zo-zi).^2);
r12=r12+rio;
xi=xo;
yi=yo;
zi=zo;
ki_x=ko_x;
ki_y=ko_y;
ki_z=ko_z;


## end
#2027, 1969:
%{
+[M函数](,%[标题])
%}

clf
clear

addpath('Matlab\space')
addpath('Matlab\optics')

% beam
physics_constant;
lm=800e-9;
w0=0.02;
A0=1;
n=1;

xs=20;
xf=35;

Dz=0.5;
Dz2=0.5;
Dtheta=0.0001;
N=1000000;


% Gaussian
k=2*pi/lm;

y0=linspace(-Dz/5,Dz/5,100);
z0=linspace(-Dz/5,Dz/5,100);

[Y0,Z0]=meshgrid(y0,z0);
X0=xs*ones(size(Y0));
R0=sqrt(Y0.^2+Z0.^2);
E0=GaussianBeam(0,R0,lm,w0,A0,n);


y=linspace(-Dz2/2,Dz2/2,50);
z=linspace(-Dz2/2,Dz2/2,50);

[Y,Z]=meshgrid(y,z);
E=zeros(size(Y));
density=zeros(size(Y));

for kj=1

    x1=xs*ones(1,N);
    x2=xf*ones(1,N);

    theta=random('Uniform',180-Dtheta/2,180,1,N);
    phi=random('Uniform',0,360,1,N);
    y1=random('Uniform',-Dz/2,Dz/2,1,N);
    z1=random('Uniform',-Dz/2,Dz/2,1,N);

    k1_y=sind(theta).*cosd(phi);
    k1_z=sind(theta).*sind(phi);
    k1_x=cosd(theta);

r12=zeros(1,N);
xi=x1;
yi=y1;
zi=z1;
ki_x=k1_x;
ki_y=k1_y;
ki_z=k1_z;
%元件场景

    Dx=x2-xi;
    y2=yi+ki_y./ki_x.*Dx;
    z2=zi+ki_z./ki_x.*Dx;

    r1=sqrt(y1.^2+z1.^2);
    ri2=sqrt((x2-xi).^2+(y2-yi).^2+(z2-zi).^2);
    r12=r12+ri2;
    e1=GaussianBeam(0,r1,lm,w0,A0,n);

    y2_m=y2-mean(y2);
    z2_m=z2-mean(z2);


    for i=1:size(Y,1)-1
        for j=1:size(Y,2)-1
            I=find(y2_m>=Y(i,j)&y2_m<Y(i,j+1) & z2_m>=Z(i,j)&z2_m<Z(i+1,j));
            e2=1i*k/2/pi*e1(I).*exp(-1i*k*r12(I)).*(1+1i/k./r12(I));
            E(i,j)=E(i,j)+sum(e2);
            density(i,j)=density(i,j)+numel(I);
        end
    end

end

subplot(1,3,1)
surf(Y0,Z0,abs(E0))
view(0,90)
xlabel('X [m]')
ylabel('Y [m]')
title(sprintf('Source: z=%.2f m',xs))
axis equal
shading interp

subplot(1,3,2)
surf(Y,Z,density/max(max(real(density))))
view(0,90)
xlabel('X [m]')
ylabel('Y [m]')
title(sprintf('density: x=%.2f m',xf))
% axis equal
% shading interp

subplot(1,3,3)
surf(Y+mean(y2),Z+mean(z2),abs(E)/max(max(abs(E))))
view(0,90)
xlabel('X [m]')
ylabel('Y [m]')
title(sprintf('Field(simulation): x=%.2f m',xf))
axis equal
shading interp


%{
+[M函数](,%[标题])
%}
## end
#2029, 311:

_代码->代码(_代码,)->光线(_前,_后)->_前->_后(,)...
->在(_前,空间点#1)->在(_后,空间点#2)...
->+[临时文本]"laser_prototype('Laser',[%输入],[%输出],0.1,(1,0,0,1),25.0)
"...
->+[修改内容](空间点#1,+输入)->+[修改内容](空间点#2,+输出)...
->+[模板文本](+[临时文本],+[临时文本])...
->+[.](+[模板文本],+输入)->+[del](,+输入)...
->+[.](+[模板文本],+输出)->+[del](,+输出)...
->+[增加内容](+[临时文本],_代码)
## end
#2032, 356:

_元件->元件(_元件,)->_代码->代码(_代码,)...
->在(_元件,空间点)->朝着(_元件,方向)...
->是(_元件,_类型):
    ->[is](_类型,光栅)->+[三维光栅](_元件,光栅)->+[Blender](+[三维光栅],)...
->+[增加内容]"%s
"(+[Blender],_代码),
    ->[is](_类型,晶体)->+[三维光栅](_元件,晶体)->+[Blender](+[三维光栅],)...
->+[增加内容]"%s
"(+[Blender],_代码),
    ->[is](_类型,柱面镜)->+[三维柱面镜](_元件,柱面镜)->+[Blender](+[三维柱面镜],)...
->+[增加内容]"%s
"(+[Blender],_代码)
## end
#2041, 601:
"""
+[返回目录](,操作序列)
+[新建阅读窗口](,操作序列)

"""

[]=>_=>+[标题](_,)->+[显示](,+[标题])

_光路->光路(_光路,)...
->+光线光路->+元件=>的(_光路,_节点):
    ->经过(,_节点)=>+[有](+元件,_节点),
    ->经过(_节点,)=>+[有](+光线光路,_节点);


_代码->代码(_代码,)...
->光线光路=>的(光线光路,_光路):
    =>的(_光路,输出)->输出,
    =>的(_光路,输入)->输入;


元件场景(,)...
->+[临时文本]->光线光路=>的(光线光路,_光路)=>[]{
    []=>经过(_光路,_元件)->_元件(,)...
    =>+[蒙卡元件代码](_元件,+[增加内容])->+[增加内容](,+[临时文本])
}->+[修改内容](+[临时文本],元件场景);


_代码->代码(_代码,)...
->+[模板文本](蒙卡整体模板,_代码)->+[.](+[模板文本],元件场景);


+[del](,光线光路)->+[del](,元件)=>新节点=>+[del](,新节点);


"""
元件场景::
蒙卡整体模板:...
蒙卡元件模板:...
+[新建阅读窗口](,蒙卡整体模板)

+[设置结构](,操作序列)

"""
## end
#2043, 328:
"""
+[返回目录](,逻辑结构转波前模拟)
+[复制结构](,逻辑结构转波前模拟)
+[新建阅读窗口](,操作序列)
操作序列(S代码):...

"""

+逻辑结构转波前模拟(_光路,_代码)->+[del](,+逻辑结构转波前模拟)...
->的(逻辑结构转波前模拟,操作序列)...
->+[S函数](_光路,操作序列)->+[的](+[S函数],_光路)->+[光路](_光路,)...
->+[的](+[S函数],+输出)->+代码(+输出,)->+[del](,+代码)...

->+[标题](_代码,)->+[模板文本](+输出,_代码)...
->+[.](+[模板文本],+[标题])...

->+[del](,+输出)




## end
#2046, 1459:
"""
+[返回目录](,蒙卡元件代码)

反射代码

M代码:...
+[新建阅读窗口](,M代码)


"""

+蒙卡元件代码(_元件,_代码)->+[del](,+蒙卡元件代码)...
->的(蒙卡元件代码,M代码)->+[修改内容](M代码,+[临时文本])...
->+[模板文本](+[临时文本],+[临时文本])...

->是(_元件,_形状)->在(_元件,_空间点)->朝着(_元件,_方向)...
->+[标题](_元件,)...

->[]{
    []:
    ->[is](_形状,光栅)->光栅->+元件"[%位置],[%方向]"...
    ->+[修改内容](_空间点,+位置#1)->+[修改内容](_方向,+方向#1)...
    ->+[模板文本]#1(+[临时文本],+[临时文本])...
    ->+[.](+[模板文本]#1,+[标题])...
    ->+[.](+[模板文本]#1,+位置#1)->+[del](,+位置#1)...
    ->+[.](+[模板文本]#1,+方向#1)->+[del](,+方向#1)...
    ->+[.](+[模板文本],+元件)->+[del](,+元件)...
    ->+[.](+[模板文本],+函数#1)->+函数#1"Reflection_plane_3D"->+[del](,+函数#1),
    
    
    ->[is](_形状,柱面镜)->柱面镜->的(_形状,焦距)->焦距(,)...
    ->+元件"1/4/%焦距,[%位置],[%方向]"...
    ->+[修改内容](_空间点,+位置#2)->+[修改内容](_方向,+方向#2)...
    ->+[模板文本]#2(+[临时文本],+[临时文本])...
    ->+[.](+[模板文本]#2,+[标题])...
    ->+[.](+[模板文本]#2,焦距)...
    ->+[.](+[模板文本]#2,+位置#2)->+[del](,+位置#2)...
    ->+[.](+[模板文本]#2,+方向#2)->+[del](,+方向#2)...
    ->+[.](+[模板文本],+元件)->+[del](,+元件)...
    ->+[.](+[模板文本],+函数#2)->+函数#2"Reflection_parabola_3D"->+[del](,+函数#2),
    
    
    ->[is](_形状,反射镜)->反射镜->+元件"[%位置],[%方向]"...
    ->+[修改内容](_空间点,+位置#3)->+[修改内容](_方向,+方向#3)...
    ->+[模板文本]#3(+[临时文本],+[临时文本])...
    ->+[.](+[模板文本]#3,+[标题])...
    ->+[.](+[模板文本]#3,+位置#3)->+[del](,+位置#3)...
    ->+[.](+[模板文本]#3,+方向#3)->+[del](,+方向#3)...
    ->+[.](+[模板文本],+元件)->+[del](,+元件)...
    ->+[.](+[模板文本],+函数#3)->+函数#3"Reflection_plane_3D"->+[del](,+函数#3)
}...

->+[增加内容](+[临时文本],_代码)


## end
#2048, 181:

% %[标题]
[xo,yo,zo,ko_x,ko_y,ko_z]=%函数(xi,yi,zi,ki_x,ki_y,ki_z,%元件);
rio=sqrt((xo-xi).^2+(yo-yi).^2+(zo-zi).^2);
r12=r12+rio;
xi=xo;
yi=yo;
zi=zo;
ki_x=ko_x;
ki_y=ko_y;
ki_z=ko_z;


## end
#2052, 5303:

import bpy
from bpy import context, data, ops
from mathutils import Euler, Matrix, Quaternion, Vector
import numpy as np

pi=np.pi


def lens_prototype(name,D,dc,R1,R2):

    # D=1*2.54e-2
    # dc=4e-3
    # R1=1
    # R2=1
    
    N1=200
    N2=200
    N=N1+N2
    
    theta1=np.arcsin(D/2/R1)
    theta2=np.arcsin(D/2/R2)
    de=dc-R1*(1-np.cos(theta1))-R2*(1-np.cos(theta2))
    z01=-R1*np.cos(theta1)
    z02=R2*np.cos(theta2)-de
    
    t1=np.linspace(0,theta1,N1)
    t2=np.linspace(-theta2,0,N2)+np.pi
    
    x1=R1*np.sin(t1)
    z1=R1*np.cos(t1)+z01
    x2=R2*np.sin(t2)
    z2=R2*np.cos(t2)+z02
    
    x=np.concatenate((x1,x2))
    z=np.concatenate((z1,z2))
    y=0*z
    
    ops.curve.primitive_bezier_curve_add(enter_editmode=True)
    #ops.curve.primitive_nurbs_path_add(enter_editmode=True)
    ops.curve.subdivide(number_cuts=N-2)
    ops.object.mode_set(mode='OBJECT')
    curve=context.active_object
    curve.name=name
    bez_points = curve.data.splines[0].bezier_points
    
    for i in range(0,N):
        bez_points[i].co=Vector((x[i],y[i],z[i]))
        if i>0:
            bez_points[i].handle_left_type='VECTOR'
        if i<N-1:
            bez_points[i].handle_right_type='VECTOR'
    
    screw=curve.modifiers.new(name='Screw',type='SCREW')
    screw.axis='Z'
    screw.angle=2*np.pi
    screw.render_steps=64
    screw.steps=64

    return curve


def mirror_prototype(name,D,dc):
    bpy.ops.mesh.primitive_cylinder_add(radius=D/2,depth=dc)
    mirror=bpy.context.selected_objects[0]
    mirror.name=name
    return mirror

def mirror_rect_prototype(name,W,H,d):
    bpy.ops.mesh.primitive_cube_add(scale=(H,W,d))
    mirror=bpy.context.selected_objects[0]
    mirror.name=name
    return mirror


def cylindrical_mirror_prototype(name,D,dc,f,H):

    # D=1*2.54e-2
    # dc=2e-3
    # f=1
    # H=0.5*2.54e-2

    n=50
    N=4*n
    R=2*f
    theta0=np.arcsin(D/2/R)
    z0=R

    t=np.linspace(-theta0,theta0,N-2)
    
    x1=R*np.sin(t)
    z1=-R*np.cos(t)+z0
    
    x=np.concatenate((x1,[D/2,-D/2]))
    z=np.concatenate((z1,[-dc,-dc]))
    y=0*z-H/2
    
    ops.curve.primitive_bezier_circle_add(enter_editmode=True)
    #ops.curve.primitive_nurbs_path_add(enter_editmode=True)
    ops.curve.subdivide(number_cuts=n-1)
    ops.object.mode_set(mode='OBJECT')
    curve=context.active_object
    curve.name=name
    bez_points = curve.data.splines[0].bezier_points
    
    print(bez_points,len(bez_points))
    
    for i in range(0,N):
        bez_points[i].co=Vector((x[i],y[i],z[i]))
        bez_points[i].handle_left_type='VECTOR'
        bez_points[i].handle_right_type='VECTOR'
    
    screw=curve.modifiers.new(name='Screw',type='SCREW')
    screw.axis='Y'
    screw.angle=0
    screw.screw_offset=H
    screw.render_steps=64
    screw.steps=64

    return curve

def laser_prototype(name,pt0,pt1,d,color,strength):

    # pt0=[0,0,0]
    # pt1=[1,1,10]
    
    x=[pt0[0],pt1[0]]
    y=[pt0[1],pt1[1]]
    z=[pt0[2],pt1[2]]
    N=2
    
    ops.curve.primitive_bezier_curve_add(enter_editmode=True)
    #ops.curve.primitive_nurbs_path_add(enter_editmode=True)
    ops.object.mode_set(mode='OBJECT')
    curve=context.active_object
    curve.name=name
    bez_points = curve.data.splines[0].bezier_points
    
    for i in range(0,N):
        bez_points[i].co=Vector((x[i],y[i],z[i]))
        bez_points[i].handle_left_type='VECTOR'
        bez_points[i].handle_right_type='VECTOR'
    
    curve.data.bevel_depth=d
    
    mat=bpy.data.materials.new(name="laser_light")
    mat.use_nodes=True
    nodes=mat.node_tree.nodes
    
    nodes.clear()
    
    # create emission node
    node_emission = nodes.new(type='ShaderNodeEmission')
    node_emission.inputs[0].default_value = color  # green RGBA
    node_emission.inputs[1].default_value = strength # strength
    node_emission.location = 0,0
    
    # create output node
    node_output = nodes.new(type='ShaderNodeOutputMaterial')   
    node_output.location = 400,0
    links = mat.node_tree.links
    link = links.new(node_emission.outputs[0], node_output.inputs[0])
    
    curve.data.materials.append(mat)


M=mirror_rect_prototype('G2',1,1,0.1)
angles=np.deg2rad(np.array((95.5,90,0)))
M.rotation_euler=(angles[1],angles[2],angles[0])
M.location=(0.0, 2.0, 0.0)


M=cylindrical_mirror_prototype('CM2',1,0.1,1,1)
angles=np.deg2rad(np.array((-96,90,0)))
M.rotation_euler=(angles[1],angles[2],angles[0])
M.location=(10.0, 0.0, 0.0)

M=mirror_rect_prototype('BBO',1,1,0.1)
angles=np.deg2rad(np.array((-90,90,0)))
M.rotation_euler=(angles[1],angles[2],angles[0])
M.location=(0,0,0)


M=cylindrical_mirror_prototype('CM1',1,0.1,1,1)
angles=np.deg2rad(np.array((83,90,0)))
M.rotation_euler=(angles[1],angles[2],angles[0])
M.location=(-10.0, 0.0, 0.0)

M=mirror_rect_prototype('G1',1,1,0.1)
angles=np.deg2rad(np.array((-95.5,90,0)))
M.rotation_euler=(angles[1],angles[2],angles[0])
M.location=(0.0, -2.0, 0.0)

laser_prototype('Laser',[0.0, -2.0, 0.0],[-10.0, 0.0, 0.0],0.1,(1,0,0,1),25.0)
laser_prototype('Laser',[-10.0, 0.0, 0.0],[10.0, 0.0, 0.0],0.1,(1,0,0,1),25.0)
laser_prototype('Laser',[10.0, 0.0, 0.0],[0.0, 2.0, 0.0],0.1,(1,0,0,1),25.0)
laser_prototype('Laser',[0.0, 2.0, 0.0],[1000,2,0],0.1,(1,0,0,1),25.0)
laser_prototype('Laser',[-1000,-2,0],[0.0, -2.0, 0.0],0.1,(1,0,0,1),25.0)

## end
#2054, 23:
文档\输出\20210722\test1.py
## end
#2056, 4:
2064
## end
#2058, 4:
2066
## end
#2060, 4:
2068
## end
#2062, 4:
2064
## end
#2064, 4:
2066
## end
#2066, 4:
2077
## end
#2069, 600:
%{
+[M函数](,WavefrontPropagation)
地址::Matlab\optics\WavefrontPropagation.m
+[保存M函数](,WavefrontPropagation)
记住WavefrontPropagation(节点)
%}

function E=WavefrontPropagation(X,Y,Z,E0,X0,Y0,Z0,lm,dx,dy)

physics_constant;

if nargin<9
    dx=1;
end
if nargin<10
    dy=1;
end

x=reshape(X,1,numel(X));
y=reshape(Y,1,numel(Y));
z=reshape(Z,1,numel(Z));
E=zeros(size(x));

k=2*pi/lm;

for i=1:length(x)
    DR=sqrt((x(i)-X0).^2+(y(i)-Y0).^2+(z(i)-Z0).^2);
    Ktheta=abs(z(i)-Z0)./DR;

    dE=1i*k/2/pi*E0.*exp(-1i*k*DR).*(1+1i/k./DR).*Ktheta;
    E(i)=sum(sum(dE))*dx*dy;
end

E=reshape(E,size(X));

end




## end
#2072, 36:
Matlab\optics\WavefrontPropagation.m
## end
#2074, 976:
%{
+[M函数](,透镜组场景)
将透镜组场景(节点)记作当前问题
Nini, 计算波前的当前问题是什么?
%}


clf
addpath('Matlab\optics')
physics_constant;

% light
lm=800e-9;
w0=0.002e-3;
A0=1;
n=1;

% scene
z0=-0.1e-3;
z1=0.e-3;
z2=0.2e-3;
z3=0.3e-3;

D=0.1e-3;


x0=linspace(-D/2,D/2,50);
y0=linspace(-D/2,D/2,50);
[Y0,X0]=meshgrid(y0,x0);
dx0=x0(2)-x0(1);
dy0=y0(2)-y0(1);

x=linspace(-D/2,D/2,50);
y=linspace(-D/2,D/2,50);
[Y,X]=meshgrid(y,x);

Z0=z0*ones(size(X0));
Z1=z1*ones(size(X));
Z2=z2*ones(size(X));
Z3=z3*ones(size(X));


R0=sqrt(X0.^2+Y0.^2);
E0=GaussianBeam(Z0,R0,lm,w0,A0,n);
E01=GaussianBeam(Z1,R0,lm,w0,A0,n);
E02=GaussianBeam(Z2,R0,lm,w0,A0,n);
E03=GaussianBeam(Z3,R0,lm,w0,A0,n);


E1=WavefrontPropagation(X,Y,Z1,E0,X0,Y0,Z0,lm,dx0,dy0);
E2=WavefrontPropagation(X,Y,Z2,E1,X,Y,Z1,lm,dx0,dy0);
E3=WavefrontPropagation(X,Y,Z3,E2,X,Y,Z2,lm,dx0,dy0);


% surf(X/1e-3,Y/1e-3,abs(E2))
surf(X/1e-3,Y/1e-3,real(E2))
view(0,90)
xlabel('X [mm]')
ylabel('Y [mm]')
% axis equal
shading interp



%{
+[M函数](,透镜组场景)
%}
## end
#2077, 17:
文档\数学问题\直线交点.ftxt
## end
#2078, 4:
2080
## end
#2086, 4:
2090
## end
#2090, 4:
2092
## end
#2095, 16:
Nini, 打开透镜波前(文件)
## end
#2096, 4:
2098
## end
#2098, 4:
2100
## end
#2101, 4:
2107
## end
### 结束