### 节点
地址, 的, 结构化文本, 目录, 的, 的, 节点数目统计, 的, 测试LaTeX, 20221201, 的, 的, 测试文本, 的, 文本内容, 的, 操作, 的, 想法, 的, 工具库, 的, 文本结构化, 的, 降临规则, 的, 召唤规则, 的, 简化内容, 的, 分析段落, 的, P代码, 的, 输出结构, 20221202, 的, 的, 库, 的, 描述结构, 的, P代码, 的, 段落, 的, P代码, 的, P代码2, 的, 生成章节, 的, 描述结构, 的, 库, 的, 段落, 的, P代码, 的, P代码2, 的, P代码, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 文本, 的, 公式结构, 的, 保存, 的, 测试, 手, A, 的, B, 的, C, 的, 的, 头部, 的, 描述结构, 的, 图例, 库, P代码, 的, 收集信息, 图例, 的, 的, 描述结构, 的, 的, 图片结构, 的, 手, 的, P代码, 的, [1]., 的, [2]., 表达式, 的, 公式, 表达式, 的, 公式, 的, [0]., 的, [3]., 的, [4]., 的, [5]., 的, [6]., 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, 表达式, 的, 公式, 的, LaTeX库, 的, PR模板, 的, PR模板_简化, 的, 引用模板, 的, 引用模板_简化, 的, 文本转换_docx, 的, 召唤规则, 的, 降临规则, 的, 章节内容, 的, 输出文本, 的, 描述结构, 的, 库, 的, 生成标题, 的, 生成概述, 的, 生成章节, 的, L模板, 的, L模板, 的, 描述结构, 的, 库, 的, 文本结构, 的, 公式结构, 的, 图片结构, 的, L模板, 的, L模板, 的, L模板, 的, 整理内容, 召唤规则, 的, 文本转换, 的, L模板, 手, 召唤规则, 的, 文本结构化, 的, 整理结构, 的, 生成作者, 的, 库, 的, 描述结构, 的, P代码, 的, P代码2, 的, 通讯作者, 的, 普通作者, 的, L模板, 的, L模板, 的, 引用文章, 的, 描述结构, 的, P代码, 的, 设置引用, 的, 参考1, 的, 引用, 的, 模板库, 的, 文章, 的, 会议, 的, P代码, 的, fig.1_, 图片, 的, fig.2_, 图片, 的, fig.3_, 图片, 的, fig.4_, 图片, 的, fig.5_, 图片, 的, P代码, 的, 整理图片, 的, P代码, 的, P代码2, 一级标题, 的, 文本, 的, 二级标题, 的, 二级标题, 的, 二级标题, 的, 二级标题, 的, 二级标题, 的, 二级标题, 的, 二级标题, 的, 二级标题, 的, 二级标题, 的, 题目, 的, 题目, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 题目, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 的, 然后, 公式, 的, 的, 然后, 公式, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 的, 然后, 公式, 的, 的, 然后, 文本, 的, 的, 然后, 公式, 的, 的, 然后, 文本, 的, LaTeX, 的, 名字, 的, LaTeX, 的, 名字, 的, LaTeX, 的, 名字, 的, LaTeX, 的, 名字, 的, 题目, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 题目, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 的, 然后, 图片, 的, 的, 然后, 文本, 的, 的, 然后, 公式, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 的, 然后, 公式, 的, 的, 然后, 图片, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 目标地址, 的, 源地址, 的, 图例, 的, 名字, 的, LaTeX, 的, 名字, 的, LaTeX, 的, 名字, 的, 目标地址, 的, 源地址, 的, 图例, 的, 名字, 的, 题目, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 的, 然后, 图片, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 目标地址, 的, 源地址, 的, 图例, 的, 名字, 的, 题目, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 的, 然后, 图片, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 目标地址, 的, 源地址, 的, 图例, 的, 名字, 的, 题目, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 题目, 的, 的, 然后, 文本, 的, 题目, 的, 的, 地址, 的, P代码, 的, 的, 测试word, 的, 测试代码, 的, 参考, 打开网页, 的, 插入分数, 的, 参考, P代码2, P代码, 的, 的, 整理图片, P代码, 会议, 文章, 的, 的, 模板库, 的, 的, 设置引用, P代码, 的, 描述结构, 的, 的, 引用文章, P代码, L模板, 的, 的, 整理内容, P代码2, P代码, 的, 的, 描述结构, L模板, 的, 普通作者, L模板, 的, 通讯作者, 的, 的, 库, 的, 的, 生成作者, L模板, P代码, L模板, 的, 的, 图片结构, L模板, 的, 公式结构, 文本结构, 的, 的, 的, 库, 描述结构, 的, 的, 的, 生成附录, L模板, 的, 生成概述, L模板, 的, 生成标题, 的, 的, 的, 的, 库, 描述结构, 的, 的, 章节内容, 的, 的, 的, 的, 降临规则, 召唤规则, 的, 的, 文本转换_md, 的, 的, L模板, 手, 召唤规则, 的, 文本转换_docx, 的, 输出docx, 的, 手, 召唤规则, 的, 文本结构化, 召唤规则, 的, 文本转换_docx, 的, P代码, 的, P代码, 的, L模板2, 的, 保存L模板, 的, P代码, 手, 的, P代码, 描述结构, P代码, 的, 文本结构, L模板2, P代码, L模板, 的, 的, 的, 公式结构, L模板, P代码, 的, 的, SVG结构, 的, 的, 的, 库, L模板, 的, 的, 的, 生成章节, 的, 的, 测试, 测试, 的, P代码, 的, 整理引用, 的, 的, 预印本, 的, L模板3, 的, 测试, 的, 保存, 的, P代码, 召唤规则, 测试2, 测试, 的, 的, P代码, 测试, 的, P代码, 的, 整理引用, 测试2, 测试, 的, 的, P代码, 描述结构, L模板, L模板2, P代码, L模板, 的, 的, 的, 表格结构, L模板3, L模板, 保存, 测试, 的, 的, P代码, L模板2, 的, 的, 的, 的, 公式结构, P代码, 的, 文本结构, 的, 的, 的, 库, 描述结构, 的, 的, 的, 生成章节, L模板, 的, 生成标题, L模板, 的, 生成概述, 描述结构, P代码, 的, 文本结构, L模板2, P代码, L模板, 的, 的, 的, 公式结构, L模板, P代码, 的, 的, 图片结构, 的, 的, 的, 保存_库, L模板, 的, 的, 的, 生成附录, L模板, 的, 通讯作者, L模板, 的, 普通作者, 的, 的, 库, P代码, P代码2, 的, 的, 描述结构, 的, 的, 生成作者, 的, 的, 的, 的, 的, 库, 的, 的, 章节内容, L模板, P代码, 的, 的, 整理内容, P代码, 的, 描述结构, 预印本, 文章, 会议, 的, 的, 的, 模板库, P代码, 的, 的, 设置引用, 的, 的, 引用文章, P代码, P代码2, 的, 的, 整理图片, 的, 的, 的, 的, 的, 降临规则, 的, 的, 文本转换, 的, 召唤规则, 的, 文本转换_博客, 的, 输出页面, 的, 模板, 的, P代码, 的, 测试文本, 的, 文本结构, 一级标题, 的, 二级标题, 的, 题目, 的, 的, 然后, 文本, 的, 的, 然后, 公式, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 的, 然后, 图片, 的, 的, 然后, 文本, 的, 的, 然后, 图片, 的, 题目, 的, 的, 输出博客, 的, 保存, 测试2, 测试, 的, 的, P代码, 的, 整理表格引用, 的, 测试2, 测试, 的, 的, P代码, 的, 整理公式引用, 的, 的, 保存, 的, 保存, 手, 的, 设置公式, P代码, L模板, 的, 的, 程序结构, 的, 测试, 的, P代码, 的, 收集图例, 的, 的, 保存, 的, 模板2, 的, 描述结构, 手, 模板2, P代码, L模板, 的, 的, 的, 3D结构, 的, 的, 结构转文本, 的, 增加, 的, 文本结构_插入尾部, 的, 文本结构_插入, 的, 测试parser, 的, 句子规则, 的, 公式规则, 的, python规则, 的, 解析Parser结构, 的, 库, 的, P代码, 的, 目录, 的, 规则, 的, 模式, 的, 语句, 的, 单元, 的, 标点, 的, P代码, 的, parser规则, 的, 测试规则, 的, 保存, 的, 结构, P代码, 的, 词语, 的, 的, 保存, 的, 生成Parser代码_快速, 的, 召唤规则, 的, 降临规则, 的, 生成结构, 的, 结构变换, 的, 生成代码, 的, 描述结构, 的, 库, 的, 设置函数, 的, 描述结构, 的, 库, 的, 情况0, 的, 单元0, 手, 召唤规则, 的, 生成Parser代码, 的, 设置条目, 的, 设置情况, 设置单元, 的, 的, 条目模板, 的, 单元模板, 的, 单元模板2, 的, 本体, 的, 本体2, 的, 本体3, 的, 或许_结尾, 的, 情况模板, 的, 情况模板2, 的, 模板, 的, 文本缩进, 的, P代码, 的, P代码, 的, 增加, 的, 新建1, 的, 新建2, 的, 词性表, 的, 保存, 的, P代码, 的, 或许_开头, 手, 的, 例句转句子, 的, 模板1, 的, 模板2, 的, 模板3, 的, 收集例句, 的, 生成例句代码, 的, 召唤规则, 的, 降临规则, 的, 生成结构, 的, 结构变换, 的, 生成代码, 的, P代码, 的, P代码2, 的, 描述结构, 的, 库, 的, 句子模块, 的, 模板, 的, 模块, 的, 生成模板, 的, 生成代码, 的, 枚举模块, 的, 单词模块, 的, 模块, 的, 模块, 召唤规则, 的, 生成例句代码, 的, 句子模块, 的, 模块, 的, 设置变量, 的, 描述结构, 的, P代码, 的, 整理模板, 的, 生成引用, 的, 模板0, 模板0, 的, 生成模板库, 的, 的, 或许_补充, 的, 增加2, 的, 单位表, 打开网页, 的, 显示parser结构_代码, 的, P代码, 的, 保存, 的, 本体2a, 手, L模板, P代码, L模板2, 的, 的, 的, 图片结构, 的, 的, 测试, 测试2, 的, 的, P代码, 的, 整理图片引用, 的, L模板, P代码, L模板2, 的, 的, 的, 图片结构, 的, 的, 保存, 的, 解析Parser结构_代码, 的, 规则, 的, P代码, 的, P代码2, 显示parser结构, 的, 手, 的, 保存, 的, P代码1, 模板, 的, 生成代码, 本体2a, 增加2, 保存, 的, 或许_补充, 或许_开头, 新建2, 新建1, 增加, P代码, 或许_结尾, 本体3, 本体2, 本体, 单元模板2, 单元模板, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 设置单元, 保存, P代码, 情况模板2, 情况模板, 的, 的, 的, 的, 设置情况, 条目模板, 的, 设置条目, 的, 的, 的, 库, 单元0, 情况0, 的, 的, 描述结构, 的, 的, 设置函数, 的, 库, 描述结构, 的, 的, 结构变换, 生成结构, 的, 的, 的, 降临规则, 召唤规则, 的, 的, 生成Parser代码, 的, 的, 下一条, 召唤规则, 的, 生成Parser代码_快速, 的, 对比文本, 手, 的, 结构图_代码, 的, P代码, P函数, 的, 规则, 的, 函数定义, P函数, 的, 默认定义, P函数, 的, 测试结构图, 的, 测试代码, 的, 结构, 的, 分析结构图结构, 整理结构, P代码b, P代码3, 测试, 的, P代码2, P代码, 的, 的, 的, 的, 写模块, 的, 描述模块, 的, 库, 收集块, 的, 描述结构, 的, 的, 生成结构, 的, 的, 降临规则, 召唤规则, 的, 的, 一般结构转结构文字, 的, 的, 流程图, 手, 召唤规则, 的, 一般结构转流程图, 的, 收集行, 的, 收集点, 的, 参考, 手, 的, P代码_自身, 的, P代码_传递, 的, P代码_内部, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 运算模块, 样式, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 运算模块, 样式, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 运算模块, 样式, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 运算模块, 样式, y, 的, x, 的, 长度, 的, 宽度, 的, 的, 运算模块, 样式, 的, P代码_自身, 的, P代码_内部, 召唤规则, P代码_自身, P代码_内部, P代码_内部, P代码_传递, P代码_自身, 的, 的, 的, 收集点, 的, 的, 收集行, 的, 的, 收集块, 的, 描述结构, P代码, 测试, 的, P代码2, P代码3, P代码b, 的, 的, 的, 的, 写模块, 的, 描述模块, 的, 库, 的, 的, 生成结构, 整理结构, 连线类型, 的, 绘制模块, 的, 描述结构, M代码, 的, 画if结尾, M代码, 的, 画顺序, M代码, 的, 画if开头, 的, 的, 的, 库, 的, 的, 模块连线, 保存, M代码3, M代码0, M代码2, M代码, 的, 的, 的, 的, 的, 布置支路, M代码3, M代码0, M代码2, M代码, 的, 的, 的, 的, 布置运算, 绘制分支, 的, 的, 的, 库, 保存, 的, 模块类型, 的, 绘制模块, 的, 描述结构, 的, 的, 布置位置, 的, 的, 的, 的, 降临规则, 的, 的, 一般结构转分类图, 的, 整理结构, 模块连线, 布置位置, 生成结构, 的, M代码2b, 的, 绘制运算, 的, M代码, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 空间点, 的, M代码, 手, 召唤规则, 的, 一般结构转结构文字, 保存, 的, 模块类型, 的, 绘制模块, 的, 描述结构, M代码, 的, 绘制运算, M代码, 的, 绘制分支, M代码, M代码2, M代码0, M代码3, 的, 的, 的, 的, 布置运算, M代码2b, M代码, M代码2, M代码0, M代码3, 保存, 的, 的, 的, 的, 的, 的, 布置支路, 的, 的, 的, 的, 库, 的, 的, 布置位置, M代码, 的, 画if开头, M代码, 的, 画顺序, M代码, 的, 画if结尾, 的, 的, 的, 库, 连线类型, 的, 绘制模块, 的, 描述结构, 的, 的, 模块连线, 整理结构, P代码b, P代码3, 测试, 的, P代码2, P代码, 的, 的, 的, 的, 写模块, 的, 描述模块, 的, 库, P代码_自身, P代码_传递, P代码_内部, 的, 的, 的, 收集点, P代码_内部, 的, 的, 收集行, P代码_自身, 的, 的, 收集块, 的, 描述结构, 的, 的, 生成结构, 的, 的, 的, 的, 降临规则, 召唤规则, 的, 的, 一般结构转流程图, 的, 召唤规则, 的, 一般结构转分类图, 的, 保存, 的, H代码, 的, 测试md, 的, 样本md, 的, md模板, 召唤规则, 保存, 描述结构, 的, 的, 设置关联, P代码, css1, 的, 的, 设置css, js2, js1, P代码, 的, 的, 的, 设置js, P代码, 正文模板, 的, 的, 设置index, 的, 的, 的, 的, 库, 描述结构, P代码, 的, 的, 的, 整体架构, 测试, 的, P代码, 的, 整理引用, 描述结构, L模板, L模板2, P代码, L模板, 的, 的, 的, 图片结构, L模板, P代码, 模板2, 的, 的, 的, 3D结构, L模板, 保存, 的, P代码, L模板2, 的, 的, 的, 表格结构, 描述结构, P代码, 模板, 的, 的, 的, 输出页面, 模板2, P代码, L模板, 的, 的, 的, SVG结构, 设置公式, L模板3, L模板, 保存, 测试, 的, 的, P代码, L模板2, 的, 的, 的, 的, 的, 公式结构, P代码, 的, 文本结构, 的, 的, 的, 的, 的, 的, 的, 库, 描述结构, 的, 的, 的, 生成章节, L模板, 的, 生成标题, L模板, 的, 生成概述, 描述结构, P代码, 的, 文本结构, L模板2, P代码, L模板, 的, 的, 的, 公式结构, L模板, P代码, 的, 的, 图片结构, 的, 的, 的, 库, L模板, 的, 的, 的, 生成附录, L模板, 的, 通讯作者, L模板, 的, 普通作者, 的, 的, 库, P代码, P代码2, 的, 的, 描述结构, 的, 的, 生成作者, 的, 的, 的, 的, 的, 库, 的, 的, 章节内容, 保存, L模板, P代码, 的, 的, 的, 整理内容, P代码, 的, 描述结构, 预印本, 文章, 会议, 的, 的, 的, 模板库, P代码, 的, 的, 设置引用, 的, 的, 引用文章, P代码, 保存, 的, P代码2, 的, 的, 整理图片, 的, 的, 的, 的, 的, 的, 降临规则, 的, 的, 文本转换_博客, 的, 的, 文本内容, 的, 输出报告, 的, fig.1_, 图片, 的, fig.2_, 图片, 的, fig.3_, 图片, 的, 文本结构, 一级标题, 的, 二级标题, 的, 二级标题, 的, 题目, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 的, 然后, 文本, 的, 的, 然后, 图片, 的, 目标地址, 的, 源地址, 的, 位置, 的, 类型, 的, 图例, 的, 名字, 的, 题目, 的, 的, 然后, 图片, 的, 的, 然后, 图片, 的, 目标地址, 的, 源地址, 的, 位置, 的, 类型, 的, 图例, 的, 名字, 的, 目标地址, 的, 源地址, 的, 位置, 的, 类型, 的, 图例, 的, 名字, 的, 题目, 的, 的, 然后, 召唤规则, 的, 文本转换_md, 的, 保存, 的, 整理地址, 的, P代码, 的, P代码2, 地址, 的, L模板, 保存, 的, P代码, 的, 的, 表格结构, 的, 
### 关联
#, 2#0, #, #, 3#2, 3#6, #, 2#8, #, #, 6#9, 2#12, #, 12#14, #, 2#16, #, 2#18, #, 2#20, #, 20#22, #, 22#24, #, 22#26, #, 24#28, #, 24#30, #, 28#32, #, 12#34, #, #, 6#35, 30#38, #, 30#40, #, 40#42, #, 40#44, #, 44#46, #, 40#48, #, 38#50, #, 50#52, #, 50#54, #, 52#56, #, 52#58, #, 52#60, #, 56#62, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, #, 54#142, #, 50#144, #, 50#146, #, #146, #, 146#148, #, 146#150, #, 146#152, 146#155, 146#148, 142#157, #, 157#159, #, #, #, 163#161, #, #, 167#163, 167#164, #, 170#160, 170#167, #, 54#170, #14, 157#174, #, 14#176, #, 14#178, #, #, 176#179, 176#, #, 178#182, 178#, 14#186, #, 14#188, #, 14#190, #, 14#192, #, 14#194, #, #, 186#195, 186#, #, 188#198, 188#, #, 190#201, 190#, #, 192#204, 192#, #, 194#207, 194#, 2#211, #, 211#213, #, 211#215, #, 211#217, #, 211#219, #, 20#221, #, 221#223, #, 221#225, #, 225#227, #, 12#229, #, 227#231, #, 227#233, #, 233#235, #, 233#237, #, 233#239, #, 235#241, #, 237#243, #, 239#245, #, 239#247, #, 247#249, #, 247#251, #, 247#253, #, 239#255, #, 251#257, #, 253#259, #, 225#261, #, #, 264#262, #, 261#266, #, #20, #, 270#268, #, 24#272, #, 233#274, #, 274#276, #, 274#278, #, 278#280, #, 278#282, #, 276#284, #, 276#286, #, 284#288, #, 286#290, #, 225#292, #, 292#294, #, 294#296, #, 292#298, #, 14#300, #, 14#302, 300#, 298#304, #, 304#306, #, 304#308, #, 298#310, #, 14#312, #, 312#, 14#315, #, 315#, 14#318, #, 318#, 14#321, #, 321#, 14#324, #, 324#, 253#327, #, 225#329, #, 329#331, #, 329#333, #, #, 34#334, #, 34#336, #, 34#338, #, 34#340, #, 34#342, #, 34#344, #, 34#346, #, 34#348, #, 34#350, #, 34#352, #, 34#354, #, 354#356, #, 352#358, 352#361, 358#362, #, 352#362, 352#365, 362#366, #, 352#366, 352#369, 366#370, #, 352#370, 352#373, 370#374, #, 352#374, 352#377, 374#378, #, 352#378, 352#381, 378#382, #, 352#382, 352#385, 382#386, #, 352#386, #, 350#388, 350#391, 388#392, #, 350#392, 350#395, 392#396, #, 350#396, 350#399, 396#400, #, 350#400, 350#403, 400#404, #, 350#404, 350#407, 404#408, #, 350#408, 350#411, 408#412, #, 350#412, 350#415, 412#416, #, 350#416, 350#419, 416#420, #, 350#420, 350#423, 420#424, #, 350#424, 350#427, 424#428, #, 350#428, 350#431, 428#432, #, 350#432, #, 428#434, #, 428#436, #, 420#438, #, 420#440, #, 408#442, #, 408#444, #, 404#446, #, 404#448, #, 348#450, 348#453, 450#454, #, 348#454, 348#457, 454#458, #, 348#458, 348#461, 458#462, #, 348#462, 348#465, 462#466, #, 348#466, 348#469, 466#470, #, 348#470, #, 346#472, 346#475, 472#476, #, 346#476, 346#479, 476#480, #, 346#480, 346#483, 480#484, #, 346#484, 346#487, 484#488, #, 346#488, 346#491, 488#492, #, 346#492, 346#495, 492#496, #, 346#496, 346#499, 496#500, #, 346#500, 346#503, 500#504, #, 346#504, 346#507, 504#508, #, 346#508, 346#511, 508#512, #, 346#512, 346#515, 512#516, #, 346#516, 346#519, 516#520, #, 346#520, 346#523, 520#524, #, 346#524, 346#527, 524#528, #, 346#528, 346#531, 528#532, #, 346#532, 346#535, 532#536, #, 346#536, #, 516#538, #, 516#540, #, 516#542, #, 516#544, #, 512#546, #, 512#548, #, 500#550, #, 500#552, #, 492#554, #, 492#556, #, 492#558, #, 492#560, #, 344#562, 344#565, 562#566, #, 344#566, 344#569, 566#570, #, 344#570, 344#573, 570#574, #, 344#574, 344#577, 574#578, #, 344#578, 344#581, 578#582, #, 344#582, 344#585, 582#586, #, 344#586, 344#589, 586#590, #, 344#590, 344#593, 590#594, #, 344#594, 344#597, 594#598, #, 344#598, 344#601, 598#602, #, 344#602, #, 582#604, #, 582#606, #, 582#608, #, 582#610, #, 342#612, 342#615, 612#616, #, 342#616, 342#619, 616#620, #, 342#620, 342#623, 620#624, #, 342#624, 342#627, 624#628, #, 342#628, 342#631, 628#632, #, 342#632, 342#635, 632#636, #, 342#636, 342#639, 636#640, #, 342#640, 342#643, 640#644, #, 342#644, 342#647, 644#648, #, 342#648, #, 640#650, #, 640#652, #, 640#654, #, 640#656, #, 340#658, 340#661, 658#662, #, 340#662, 340#665, 662#666, #, 340#666, 340#669, 666#670, #, 340#670, #, 338#672, 338#675, 672#676, #, 338#676, #, 334#678, 12#681, #, 261#683, #, 229#681, 2#686, #, 686#688, #, 688#690, #, #690, 688#693, #, 693#695, #, #, #, 700#696, 700#697, #, #, #, #, 706#702, 706#703, #, 709#701, 709#706, #, #, 712#710, #, 715#709, 715#712, #, #, #, 720#716, 720#717, #, #, #, 725#721, 725#722, #, #, 728#726, #, #, 731#729, #, 734#728, 734#731, #, 737#725, 737#734, #, #, #, #, 743#739, 743#740, #, #, 746#744, #, #, 751#743, 751#746, 751#747, #, #, 756#738, 756#751, 756#752, #, #, 759#757, #, #, 762#760, #, 767#737, 767#756, 767#759, 767#762, #, #, 771#767, 771#768, #, 776#700, 776#715, 776#720, 776#771, #, #, 780#776, 780#777, #, 20#780, 249#783, #, #20, #, 787#785, #, 12#789, #, 789#681, #20, #, 794#792, #, #, 797#795, #, 249#799, #, 746#801, #, 746#803, #, 251#805, #, 251#807, #, #20, 747#810, #, #, #, 814#812, #, #, #, #, 821#815, 821#816, 821#817, #, #, #, 826#822, 826#823, #, 830#814, 830#821, 830#826, #, #, 835#811, 835#830, 835#831, #, 767#835, 161#838, #, #, 841#839, #, 843#841, #, 776#843, 706#846, #, 821#848, #, 816#850, #, 816#852, #, 170#854, #, #, #, #, 860#856, 860#857, #, #, 863#861, #, 865#863, #, #, #, 870#866, 870#867, #, #, #, #, #, #, 879#873, 879#874, 879#875, #, #, #, #, #, 886#882, 886#883, #, #, 892#880, 892#881, 892#886, 892#887, #, #, 895#893, #, 899#879, 899#892, 899#895, #, #, 904#872, 904#899, 904#900, #, #, 907#905, #, #, 910#908, #, #, #, 914#912, #, #, #, #, 921#915, 921#916, 921#917, #, #, #, 926#922, 926#923, #, 930#914, 930#921, 930#926, #, #, 935#911, 935#930, 935#931, #, #, 938#936, #, #, 941#939, #, 944#938, 944#941, #, #, #, 949#945, 949#946, #, 952#944, 952#949, #, 958#904, 958#907, 958#910, 958#935, 958#952, #, 961#871, 961#958, #, #, #, 966#962, 966#963, #, #, 969#967, #, #, #, #, 976#970, 976#971, 976#972, #, #, 980#976, 980#977, #, 983#969, 983#980, #, #, #, 988#984, 988#985, #, 994#865, 994#961, 994#966, 994#983, 994#988, #, 997#855, 997#994, #, 20#997, #, 1001#999, #, 830#1003, #, 1003#1005, #, 1003#1007, #, 20#1009, #, 20#1011, #, #, 1011#1012, #, 1011#1014, #, 1014#1016, 1014#1019, 1016#1020, #, 1014#1020, 1014#1023, 1020#1024, #, 1014#1024, 1014#1027, 1024#1028, #, 1014#1028, 1014#1031, 1028#1032, #, 1014#1032, 1014#1035, 1032#1036, #, 1014#1036, 1014#1039, 1036#1040, #, 1014#1040, 1014#1043, 1040#1044, #, 1014#1044, 1014#1047, 1044#1048, #, 1014#1048, #, 1012#1050, 20#1053, #, 966#1055, #, #, #, 1060#1056, 1060#1057, #, 1062#1060, #, 994#1062, #, #, 1068#1064, 1068#1065, #, 1070#1068, #, 994#1070, 720#1073, #, 696#1075, #, #20, 821#1078, #, #, #, 1083#1079, 1083#1080, #, 830#1083, #, 1087#1085, #, 1089#1087, #, 167#1089, 1087#1092, #, 826#1094, #, 1003#1096, #, #20, #, #, #, 1104#1098, 1104#1099, 1104#1100, #, 830#1104, 16#1107, #, 1107#1109, #, 16#1111, #, 16#1113, #, 2#1115, #, 1115#1117, #, 1115#1119, #, 1115#1121, #, 18#1123, #, 1123#1125, #, 1123#1127, #, 1125#1129, #, 1125#1131, #, 1125#1133, #, 1125#1135, #, 1125#1137, #, 1125#1139, #, 1139#1141, #, 1115#1143, #, 1115#1145, #, 1137#1147, #, 1115#1149, #, #, 1152#1150, #, 1125#1152, 1141#1155, #, 20#1157, #, 1157#1159, #, 1157#1161, #, 1161#1163, #, 1161#1165, #, 1161#1167, #, 1165#1169, #, 1165#1171, #, 1171#1173, #, 1173#1175, #, 1173#1177, #, 1175#1179, #, 1175#1181, #, #20, #, 1185#1183, #, 1177#1187, #, 1177#1189, #, #, 1177#1190, 1187#1193, #, 1190#1195, #, 1190#1197, #, 1190#1199, #, 1190#1201, #, 1190#1203, #, 1190#1205, #, 1189#1207, #, 1189#1209, #, 1167#1211, #, 1107#1213, #, 1213#1215, #, 1190#1217, #, 1190#1219, #, 1190#1221, #, 1190#1223, #, 2#1225, #, 1107#1227, #, 1107#1229, #, 1190#1231, #, #20, 16#1234, #, 1234#1236, #, 1234#1238, #, 1234#1240, #, 16#1242, #, 20#1244, #, 1244#1246, #, 1244#1248, #, 1248#1250, #, 1248#1252, #, 1248#1254, #, 1250#1256, #, 1250#1258, #, 1252#1260, #, 1252#1262, #, 1262#1264, #, 1252#1266, #, 1264#1268, #, 1264#1270, #, 1264#1272, #, 1272#1274, #, 1272#1276, #, 1276#1278, #, 1274#1280, #, #, 1283#1281, #, 1272#1285, #, 1285#1287, #, 1248#1289, #, 1289#1291, #, 1291#1293, #, 1248#1295, #, 1295#1297, #, 1297#1299, #, #, 1302#1300, #, 1295#1302, 1190#1305, #, 1190#1307, #, 2#1309, #, #1309, 16#1312, #, 1189#1314, #, 1189#1316, #, 1190#1318, #, #20, #, #, #, 1326#1320, 1326#1321, 1326#1322, #, 899#1326, 935#899, #, #, 1333#1329, 1333#1330, #, 1335#1333, #, 994#1335, #, #, #, 1343#1337, 1343#1338, 1343#1339, #, 830#1343, 1079#1346, #, 18#1348, #, 1348#1350, #, 1348#1352, #, 1348#1354, #, #, 16#1355, #20, 1305#1359, #, 1348#1361, #, #, 1364#1362, #, #, #, #, 1369#1367, #, #, #, #, #, #, #, #, #, #, #, #, 1395#1365, 1395#1366, 1395#1369, 1395#1370, 1395#1371, 1395#1372, 1395#1373, 1395#1374, 1395#1375, 1395#1376, 1395#1377, 1395#1378, 1395#1379, 1395#1380, #, #, #, #, #, 1404#1396, 1404#1397, 1404#1398, 1404#1399, #, #, 1407#1405, #, 1411#1395, 1411#1404, 1411#1407, #, #, #, 1416#1412, 1416#1413, #, 1419#1411, 1419#1416, #, 1421#1419, #, #, 1425#1421, 1425#1422, #, #, 1430#1364, 1430#1425, 1430#1426, #, #, 1434#1430, 1434#1431, #, 20#1434, 1169#1437, #, #, 1440#1438, #, 1115#1442, #, #20, 18#1445, #, 1445#1447, #, 1447#, 1447#1450, #, 1447#1452, #, 1452#, 1447#1455, #, 1455#, 2#1458, #, 1458#1460, #, 1458#1462, #, 16#1464, #, #, #, #, #, 1470#1468, #, #, 1476#1466, 1476#1467, 1476#1470, 1476#1471, #, 1478#1476, #, 1480#1478, #, #, 1483#1481, #, 1486#1480, 1486#1483, #, 1489#1465, 1489#1486, #, #, 1493#1489, 1493#1490, #, 20#1493, 1458#1496, #, #20, #, 1500#1498, #, 1481#1502, #, 1502#1504, #, 1458#1506, #, #20, 1504#1509, #, 1504#1511, #, 1502#1513, #, #, 1523#1514, #, 1523#1516, #, 1523#1518, #, 1523#1520, 1523#1524, #, 1523#, #, 1534#1525, #, 1534#1527, #, 1534#1529, #, 1534#1531, 1534#1535, #, 1534#, #, 1545#1536, #, 1545#1538, #, 1545#1540, #, 1545#1542, 1545#1546, #, 1545#, #, 1556#1547, #, 1556#1549, #, 1556#1551, #, 1556#1553, 1556#1557, #, 1556#, #, 1567#1558, #, 1567#1560, #, 1567#1562, #, 1567#1564, 1567#1568, #, 1567#, 1481#1570, #, 1504#1572, #, #, #, #, #, #, #, 1582#1576, 1582#1577, 1582#1578, #, 1585#1575, 1585#1582, #, 1588#1574, 1588#1585, #, 1590#1588, #, #, #, 1594#1592, #, #, #, 1601#1591, 1601#1594, 1601#1595, 1601#1596, #, 1603#1601, #, 1605#1603, #, 1608#1590, 1608#1605, #, #, #, 1612#1610, #, 1614#1612, #, #, 1617#1615, #, #, 1620#1618, #, #, 1623#1621, #, 1627#1617, 1627#1620, 1627#1623, #, 1630#1614, 1630#1627, #, #, #, #, #, #, 1641#1631, 1641#1632, 1641#1633, 1641#1634, 1641#1635, #, #, #, #, #, 1650#1642, 1650#1643, 1650#1644, 1650#1645, #, #, 1655#1641, 1655#1650, 1655#1651, #, #, 1658#1656, #, 1660#1658, #, 1662#1660, #, 1665#1655, 1665#1662, #, 1670#1608, 1670#1609, 1670#1630, 1670#1665, #, 1673#1573, 1673#1670, #, 20#1673, 1462#1496, 1462#1496, 1462#1496, 1462#1496, 1641#1680, #, 1655#1682, #, 1682#1684, #, #, #, #, #, #, #, #, 1651#1693, #, #20, #, 1697#1695, #, #, 1700#1698, #, 1702#1700, #, 1704#1702, #, #, 1707#1705, #, #, 1710#1708, #, #, #, #, #, 1719#1711, 1719#1712, 1719#1713, 1719#1714, #, #, #, #, #, #, #, 1732#1720, 1732#1721, 1732#1722, 1732#1723, 1732#1724, 1732#1725, #, 1737#1707, 1737#1710, 1737#1719, 1737#1732, #, 1740#1704, 1740#1737, #, #, 1743#1741, #, #, 1746#1744, #, #, 1749#1747, #, 1753#1743, 1753#1746, 1753#1749, #, #, 1756#1754, #, 1758#1756, #, 1761#1753, 1761#1758, #, #, #, #, #, 1767#1765, #, #, 1773#1763, 1773#1764, 1773#1767, 1773#1768, #, 1775#1773, #, 1777#1775, #, #, #, #, 1784#1778, 1784#1779, 1784#1780, #, #, 1788#1784, 1788#1785, #, #, 1792#1788, 1792#1789, #, 1794#1792, #, 1797#1777, 1797#1794, #, 1802#1740, 1802#1761, 1802#1762, 1802#1797, #, #, 1806#1802, 1806#1803, #, 20#1806, #, 1810#1808, #, 1610#1812, #, 1458#1814, #, 2#1816, #, 1816#1818, #, 1816#1820, #, #, #, #, 1826#1822, 1826#1823, #, #, #, 1831#1827, 1831#1828, #, #, #, #, 1838#1832, 1838#1833, 1838#1834, #, #, #, 1843#1839, 1843#1840, #, 1848#1826, 1848#1831, 1848#1838, 1848#1843, #, #, #, 1854#1848, 1854#1849, 1854#1850, #, #, 1857#1855, #, 1859#1857, #, #, #, #, #, #, 1868#1862, 1868#1863, 1868#1864, #, #, #, #, 1875#1869, 1875#1870, 1875#1871, #, #, #, 1879#1877, #, #, 1884#1876, 1884#1879, 1884#1880, #, #, #, #, 1891#1885, 1891#1886, 1891#1887, #, #, #, #, 1898#1892, 1898#1893, 1898#1894, #, #, #, #, #, #, 1906#1902, 1906#1903, #, #, 1913#1899, 1913#1900, 1913#1901, 1913#1906, 1913#1907, #, #, 1916#1914, #, 1924#1868, 1924#1875, 1924#1884, 1924#1891, 1924#1898, 1924#1913, 1924#1916, #, #, 1929#1861, 1929#1924, 1929#1925, #, #, 1932#1930, #, #, 1935#1933, #, #, #, 1939#1937, #, #, #, #, 1946#1940, 1946#1941, 1946#1942, #, #, #, 1951#1947, 1951#1948, #, 1955#1939, 1955#1946, 1955#1951, #, #, 1960#1936, 1960#1955, 1960#1956, #, #, 1963#1961, #, #, 1966#1964, #, 1969#1963, 1969#1966, #, #, #, 1974#1970, 1974#1971, #, 1977#1969, 1977#1974, #, 1983#1929, 1983#1932, 1983#1935, 1983#1960, 1983#1977, #, 1986#1860, 1986#1983, #, #, #, #, 1993#1987, 1993#1988, 1993#1989, #, #, 1996#1994, #, #, #, #, 2003#1997, 2003#1998, 2003#1999, #, #, 2007#2003, 2007#2004, #, 2010#1996, 2010#2007, #, #, #, 2014#2012, #, 2017#2011, 2017#2014, #, 2024#1854, 2024#1859, 2024#1986, 2024#1993, 2024#2010, 2024#2017, #, 2027#1821, 2027#2024, #, 20#2027, 1816#2030, #, 1816#2032, #, 2030#2034, #, 2034#, 2030#2037, #, 2037#, 2030#2040, #, 2040#, 1816#2043, #, #, 2043#2044, #, 2043#2046, #, 2043#2048, #, 2048#2050, 2048#2053, 2050#2054, #, 2048#2054, 2048#2057, 2054#2058, #, 2048#2058, 2048#2061, 2058#2062, #, 2048#2062, 2048#2065, 2062#2066, #, 2048#2066, #, 2066#2068, #, 2066#2070, #, 2066#2072, #, 2066#2074, #, 2066#2076, #, 2066#2078, #, 2046#2080, 2046#2083, 2080#2084, #, 2046#2084, 2046#2087, 2084#2088, #, 2046#2088, #, 2088#2090, #, 2088#2092, #, 2088#2094, #, 2088#2096, #, 2088#2098, #, 2088#2100, #, 2084#2102, #, 2084#2104, #, 2084#2106, #, 2084#2108, #, 2084#2110, #, 2084#2112, #, 2044#2114, 2043#2117, 2046#2048, #, 2120#2118, #, 700#2122, #, 776#2124, #, 2124#2126, #, 2124#2128, #, #, 2032#2129, #, #, 2134#2132, #, 2137#2131, 2137#2134, #, 830#2137, 
### 内容
#0, 17:
文档\S应用\结构化文本.ftxt
## end
#2, 562:
+[返回目录](,结构化文本)
地址::文档\S应用\结构化文本.ftxt

操作:...
+[设置动词](,操作)
想法:...
+[设置名词](,想法)
工具库:...
+[新建阅读窗口](,工具库)
+[新建阅读窗口](,想法)
+[新建阅读窗口](,操作)

LaTeX库:...
+[新建阅读窗口](,LaTeX库)

Nini, 导入论文基本信息的库
Nini, 导入论文索引的库

Nini, 打开能谱仪论文(文件)
Nini, 打开空间关系(文件)
Nini, 打开论文索引(文件)
Nini, 打开论文基本信息(文件)


测试LaTeX:...
测试文本:...
测试word:...
测试md:...
+[新建阅读窗口](,测试文本)
+[新建阅读窗口](,测试word)
+[新建阅读窗口](,测试md)

测试parser:...
测试结构图:...
+[新建阅读窗口](,测试结构图)
+[新建阅读窗口](,测试parser)
词性表::https://github.com/ssvivian/WebstersDictionary/blob/master/dictionary.json
单位表::https://texdoc.org/serve/siunitx/0
+[打开网页](,单位表)

## end
#3, 49:
结构化文本:...
创建于 20221201

节点数目统计::
+[设置结构](,节点数目统计)
## end
#8, 17950:
<!--
+[H函数](,测试LaTeX)
-->

$$
\documentclass{article}
\usepackage[a4paper, portrait, margin=1.1811in]{geometry}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{helvet}
\usepackage{etoolbox}
\usepackage{graphicx}
\usepackage{titlesec}
\usepackage{caption}
\usepackage{booktabs}
\usepackage{xcolor} 
\usepackage[colorlinks, citecolor=cyan]{hyperref}
\usepackage{caption}
\captionsetup[figure]{name=Figure}
\graphicspath{ {./images/} }
\usepackage{scrextend}
\usepackage{fancyhdr}
\usepackage{graphicx}
\newcounter{lemma}
\newtheorem{lemma}{Lemma}
\newcounter{theorem}
\newtheorem{theorem}{Theorem}

\fancypagestyle{plain}{
	\fancyhf{}
	\renewcommand{\headrulewidth}{0pt}
	\renewcommand{\familydefault}{\sfdefault}
	
	\lhead{\color{cyan}\small \textbf{KOMPUTASI: JURNAL ILMIAH ILMU KOMPUTER DAN MATEMATIKA}\\ \color{black}
	\textit{Vol. XX (X)  (XXXX), XX-XX, p-ISSN: 693-7554, e-ISSN:2654-3990}\\ }
	%\rhead{p-ISSN: 693-7554 \\ e-ISSN:2654-3990}
	%\rfoot{\thepage} --> Show the page number
	
}

%\pagestyle{plain}
\makeatletter
\patchcmd{\@maketitle}{\LARGE \@title}{\fontsize{16}{19.2}\selectfont\@title}{}{}
\makeatother

\usepackage{authblk}
\renewcommand\Authfont{\fontsize{10}{10.8}\selectfont}
\renewcommand\Affilfont{\fontsize{10}{10.8}\selectfont}
\renewcommand*{\Authsep}{, }
\renewcommand*{\Authand}{, }
\renewcommand*{\Authands}{, }
\setlength{\affilsep}{2em}  
\newsavebox\affbox
\author[1]{\textbf{Fisrt author}}
\author[2]{\textbf{Second author}}
\author[3]{\textbf{Third author}}
\author[4*]{\textbf{Fourth author}}
\affil[1,2]{ Study Program, Faculty, University
	Bogor, West Java, 16143, Indonesia
}
\affil[3]{ Department of Computer Science, Faculty of Mathematics and Natural Science, Pakuan University, 
	Bogor, West Java, 16143, Indonesia
}
\affil[4]{ Department of Mathematical Sciences, Faculty of Science,
	Universiti Teknologi Malaysia,
	81310 Johor Bahru,
	Johor, Malaysia
}

\titlespacing\section{0pt}{12pt plus 4pt minus 2pt}{0pt plus 2pt minus 2pt}
\titlespacing\subsection{12pt}{12pt plus 4pt minus 2pt}{0pt plus 2pt minus 2pt}
\titlespacing\subsubsection{12pt}{12pt plus 4pt minus 2pt}{0pt plus 2pt minus 2pt}


\titleformat{\section}{\normalfont\fontsize{10}{15}\bfseries}{\thesection.}{1em}{}
\titleformat{\subsection}{\normalfont\fontsize{10}{15}\bfseries}{\thesubsection.}{1em}{}
\titleformat{\subsubsection}{\normalfont\fontsize{10}{15}\bfseries}{\thesubsubsection.}{1em}{}

\titleformat{\author}{\normalfont\fontsize{10}{15}\bfseries}{\thesection}{1em}{}

\title{\textbf{\huge Title of the Manuscript}\\
	(Center, Bold, Times New Roman 14, maximum 15 words in english)}
\date{}    

\begin{document}

\pagestyle{headings}	
\newpage
\setcounter{page}{1}
\renewcommand{\thepage}{\arabic{page}}


	
\captionsetup[figure]{labelfont={bf},labelformat={default},labelsep=period,name={Figure }}	\captionsetup[table]{labelfont={bf},labelformat={default},labelsep=period,name={Table }}
\setlength{\parskip}{0.5em}
	
\maketitle
	
\noindent\rule{15cm}{0.5pt}
	\begin{abstract}
		\textbf{Abstract }consists of objectives, methods, findings, and research contributions in 150 to 250 words which contains the main conclusions and provides important information and is accompanied by \textbf{5 keywords}. Furthermore, the determination of keywords needs to pay attention to important words contained in the title and abstract, separated by a semicolon. \textbf{The novelty} in this paper briefly explains why no one else has adequately researched the question. Then \textbf{the results} are made a list of the empirical findings and write the discussion in one or two sentences. \\ \\
		\let\thefootnote\relax\footnotetext{
			\small $^{*}$\textbf{Corresponding author.} \textit{
				\textit{E-mail address: \color{cyan}author4@email.com}}\\
			\color{black} Received: xx xxxxx 20xx,\quad
			Accepted: xx xxxxx 20xx and available online XX July 2022 \\
			\color{cyan} https://doi.org/10.1016/j.compeleceng.2021.107553
			
		}
		\textbf{\textit{Keywords}}: \textit{Keyword 1; keyword 2; keyword 3; keyword 4; keyword 5}
	\end{abstract}
\noindent\rule{15cm}{0.4pt}

\section{Introduction (10pt, bold)}
The introduction is about 400-600 words and provides background information, previous references related to the main topic, reason, purpose of the research, and the novelty of the research.  Content should be relatively non-technical, but clear enough for a knowledgeable reader to understand the manuscript’s contribution. Explain what the purpose of the research is and why the research was conducted the main body of the article should begin with an introduction, which provides further details on the purpose of the paper, motivation, research methods, and findings. For citations use numbering which must be used for reference titles, for example, citations for journals consisting of 1 article  \cite{Septiawan1} or two articles \cite{Septiawan2}, \cite{Lucy}, while for writing citations of more than two articles \cite{Gingold} - \cite{Morikawa}.

In writing a bibliography using the IEEE style, the conditions are numbered, as follows: \cite{Septiawan1}, in order from the first citation to the last. References with IEEE style use a numeric number placed in a square box for the reference taken and put it at the end of the sentence. The numeric numbers located in the square box are made the same as the bibliography on the final page of the scientific paper.

\section{Methods (10pt, bold)}
The methods section describes the steps followed in the execution of the study and also provides a brief justification for the research methods used. A chronological explanation of the research, including research design, research procedures (in the form of algorithms, codes, or others), how the procedures are to obtain and test data \cite{Lo} - \cite{Hang}. The description of the research has been supported by references, so that the implementation can be accepted scientifically [6]. Figure are presented in the center, as shown below and are cited in the manuscript. An example of a membership function graph can be seen in Figure \ref{table1}.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\textwidth]{images/gambar3.PNG}
	\caption{Font 10pt and center not bold for captions except for the words "Figure"}
	\label{fig1}
\end{figure}

Each image (photos, graphs, and diagrams) in the article must be accompanied by a caption/image title and sequential image numbers, written below the image in the middle position. Images must be directly relevant to the article and are always referenced in the article referred to as Figur \ref{table1}, where the capital letters are capitalized.

\subsection{Table (10pt, bold)}
Writing tables are numbered followed by the title of the table above the table, centered, 1 spaced with a short and precise title. Consider the example in Table \ref{table1}
\begin{table}[h]
	\centering
	\caption{Font 10pt and center not bold for captions except for the words "Table"}
	\label{table1}
	\begin{tabular}{@{}cccc@{}}
		\toprule
		\textbf{Characteristics}& \textbf{Description }& \textbf{Frequency }& \textbf{Percentage} \\
		\midrule
		Gender & Male & 198 & 80.2\% \\
		& Female & 49 & 19.8\% \\
		Entry & 2018 & 54 & 21.9\% \\
		& 2019 & 64 & 25.9\% \\
		& 2020 & 59 & 23.9\% \\
		& 2021 & 70 & 28.3\% \\
		MBKM & Yes & 217 & 87.9\% \\
		& No & 30 & 12.1\% \\
		& Total & 247 & 100\% \\
		\bottomrule
	\end{tabular}
\end{table}


\subsection{Figure (10pt, bold)}
Image writing techniques in scientific papers must also be symmetrical in the middle. So the settings are not aligned right or left, but in the center. This helps tidy up the position of the image or photo so that it appears side by side well with the description text as in Figure \ref{fig2}.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\textwidth]{images/figur2.PNG}
	\caption{Font 10pt and center not bold for captions except for the words "Figure"  }
	\label{fig2}
\end{figure}


\section{Result and Discussion (10pt, bold)}
The results obtained are data or facts obtained from research. Important data or facts that cannot be clearly narrated can be displayed in the form of tables or pictures or other illustrations. If the results are presented in the form of tables or figures, they do not need to be described at length. The discussion is a review of the results, explaining the meaning of the research results, conformity with the results or previous research, the role of the results in solving the problems mentioned in the introduction, and the possibility.

This section is the most important part of your article. The following are things that you must pay attention to in writing the results and the research results must be clear and concise, the data presented has been processed (not raw data), set forth in the form of narratives, tables or pictures, and given easy-to-understand explanations. It is important to highlight differences between your results or findings and those of previous publications by other researchers. It is important to be compared with related references.
\subsection{Equation (10pt, bold)}
Mathematical equations must be numbered sequentially and starting with (1) until the end of the paper including the appendix. This numbering must begin and end with an opening and closing parenthesis and right align. Add one blank space above and below the Eq. \ref{Eq1}.
\begin{eqnarray}
	\chi(L(\Gamma); \lambda)=(\lambda+2)^{m-n}\chi(\Gamma;\lambda+2-k)
	\label{Eq1}
\end{eqnarray}
For example, from Eq. \ref{Eq2} it is derived again the next mathematical equation
\begin{eqnarray}
	\chi(L(\Gamma); \lambda)=\det (\lambda I_{m}-A_{L})
		\label{Eq2}
\end{eqnarray}
Or there is the next mathematical Eq. \ref{Eq3} as below
\begin{eqnarray}
\det(D_{0}D_{0}^{t})=\sum_{|U|=n-1} \det(D_{U})\det(D_{U}^{t})
	\label{Eq3}
\end{eqnarray}
\subsection{Therema (10pt, bold)}
The schema for writing definitions, theorems, lemmas, and proofs conforms to and follows the template below.

\begin{theorem}
	 Theorem is a statement about mathematics that still requires proof and the statement can be shown to have a truth value or is also true.
\end{theorem}

\subsubsection{Lemma (10pt, bold)}
\begin{lemma}
	An entry is a word or phrase entered in the dictionary beyond the definition given in the entry
\end{lemma}

\section{Conclusion (10pt, bold)}
The author presents brief conclusions from the results of research with suggestions for advanced researchers or general readers. A conclusion may review the main points of the paper, do not replicate the abstract as the conclusion. Conclusions must identify the results obtained in a clear and unambiguous manner, the author should provide the answer to the question: is this a problem with error, method, validity, and or otherwise?

\section{Acknowledgement (if any)}
Contains an acknowledgment of thanks to an agency if this research was funded or supported by that agency, or if there were parties who significantly assisted directly in the research or writing of this article. If the party is already listed as the author, then there is no need to mention it again in this Acknowledgment
\bibliographystyle{IEEEtran}

%\bibliography{template} %-->reference list is on the template.bib file
\begin{thebibliography}{1.7} 
	\bibitem[1]{Septiawan1} \color{cyan}R. R. Septiawan, “An ODE control system of a rigid body on an ocean wave for a surfer simulation in the SPH method,” \textit{The Science Reports of Kanazawa University}, vol. 62, pp. 51–68, 2018. [Online]. Available: http://scirep.w3.kanazawa-u.ac.jp/articles/62-004.pdf. \color{black}
	\bibitem[2]{Septiawan2} \color{cyan}R. R. Septiawan, S. Viridi, and Suprijadi, “The Effect of Particle Size Ratio on Porosity of a Particles Deposition Process,” \textit{Key Engineering Materials,} vol. 675–676, pp. 647–650, 2016. [Online]. Available: https://www.scientific.net/KEM.675-676.647. \color{black}
	\bibitem[3]{Lucy} \color{cyan}L. B. Lucy, “A numerical approach to the testing of the fission hypothesis,” \textit{The astronomical journal}, vol. 82, pp. 1013–1024, 1977. \color{black}
	\bibitem[4]{Gingold} \color{cyan}R. A. Gingold and J. J. Monaghan, “Smoothed particle hydrodynamics: theory and application to non-spherical stars,” \textit{Monthly Notices of the Royal Astronomical Society}, vol. 181, no. 3, pp. 375–389, 1977. [Online]. Available:  https://academic.oup.com/mnras/article/181/3/375/988212. \color{black}
	\bibitem[5]{Supriadi} \color{cyan}Suprijadi, F. Faizal, and R. R. Septiawan, “Computational Study on Melting Process Using Smoothed Particle Hydrodynamics,” Journal of Modern Physics, vol. 05, no. 03, pp. 112–116, 2014. [Online]. Available: https://www.scirp.org/pdf/JMP2014022411463120.pdf.\color{black}
	\bibitem[6]{Septiawan3} \color{cyan}R. R. Septiawan, H. Abdillah, Novitrian, and Suprijadi, “Preliminary Study on Liquid Natural Convection by Temperature Differences,” 2015. [Online]. Available: https://www.atlantis-press.com/proceedings/icaet-14/16166.\color{black}
	\bibitem[7]{Morikawa}\color{cyan}D. Morikawa, M. Asai, N. Idris, Y. Imoto, and M. Isshiki, “Improvements in highly viscous fluid simulation using a fully implicit SPH method,” \textit{Computational Particle Mechanics}, vol. 6, no. 4, pp. 529–544, 2019. [Online]. Available: https://link.springer.com/article/10.1007/s40571-019-00231-6.\color{black}
	\bibitem[8]{Lo} \color{cyan}E. Y.M. Lo and S. Shao, “Simulation of near-shore solitary wave mechanics by an incompressible SPH method,” \textit{Applied Ocean Research}, vol. 24, no. 5, pp. 275–286, 2002. [Online]. Available: https://www.sciencedirect.com/science/article/abs/pii/S0141118703000026.\color{black}
	\bibitem[9]{Dalrymple} \color{cyan}R. A. Dalrymple and B. D. Rogers, “Numerical modeling of water waves with the SPH method,” Coastal Engineering, vol. 53, no. 2–3, pp. 141–147, 2006. [Online]. Available: https://www.sciencedirect.com/science/article/abs/pii/S0378383905001304.\color{black}
	\bibitem[10]{Yan} \color{cyan}X. Yan, Y.-T. Jiang, C.-F. Li, R. R. Martin, and S.-M. Hu, “Multiphase SPH simulation for interactive fluids and solids,” ACM Transactions on Graphics, vol. 35, no. 4, pp. 1–11, 2016. [Online]. Available: https://dl.acm.org/doi/10.1145/2897824.2925897.\color{black}
	\bibitem[11]{Antocy} \color{cyan}C. Antoci, M. Gallati, and S. Sibilla, “Numerical simulation of fluid–structure interaction by SPH,” Computers and Structures, vol. 85, no. 11–14, pp. 879–890, 2007. [Online]. Available: https://www.sciencedirect.com/science/article/abs/pii/S0045794907000132.\color{black}
	\bibitem[12]{Monaghan1} \color{cyan}J. J. Monaghan, A. Kos, and N. Issa, “Fluid Motion Generated by Impact,” Journal of Waterway, Port, Coastal, and Ocean Engineering, vol. 129, no. 6, pp. 250–259, 2003. [Online]. Available: https://ascelibrary.org/doi/10.1061/\%28ASCE\%290733-950X\%282003\%29129\%3A6\%28250\%29.\color{black}
	\bibitem[13]{Akinci} \color{cyan}N. Akinci, M. Ihmsen, G. Akinci, B. Solenthaler, and M. Teschner, “Versatile rigid-fluid coupling for incompressible SPH,” ACM \textit{Transactions on Graphics}, vol. 31, no. 4, pp. 1–8, 2012. [Online]. Available: https://dl.acm.org/doi/10.1145/2185520.2185558. \color{black}
	\bibitem[14]{Liu} \color{cyan}G. R. Liu and M. B. Liu, \textit{Smoothed Particle Hydrodynamics}. Singapore: World Scientific Publishing Co Pte Ltd, 2003. doi: 10.1142/5340. \color{black}
	\bibitem[15]{John} \color{cyan}John F. Wendt, \textit{Computational Fluid Dynamics}. Berlin, Heidelberg: Springer Berlin Heidelberg, 2009. doi: 10.1007/978-3-540-85056-4.\color{black}
	\bibitem[16]{Lattanzio} \color{cyan}J. J. Monaghan and J. C. Lattanzio, “A refined particle method for astrophysical problems,” \textit{Astron Astrophys}, vol. 149, pp. 135–143, 1985.\color{black}
	\bibitem[17]{Batchelor}\color{cyan}G. K. Batchelor, \textit{An Introduction to Fluid Dynamics.} Cambridge: Cambridge University Press, 2000. doi: 10.1017/CBO9780511800955.\color{black}
	\bibitem[18]{Monaghan2} \color{cyan}J. J. Monaghan, “Simulating Free Surface Flows with SPH,” \textit{Journal of Computational Physics}, vol. 110, no. 2, pp. 399–406, 1994. [Online]. Available: https://www.sciencedirect.com/science/article/pii/S0021999184710345.\color{black}
	\bibitem[19]{Managhan3} \color{cyan}J. J. Monaghan, “Smoothed particle hydrodynamics,” \textit{Reports on Progress in Physics}, vol. 68, no. 8, pp. 1703–1759, 2005. [Online]. Available: https://iopscience.iop.org/article/10.1088/0034-4885/68/8/R01.\color{black}
	\bibitem[20]{Rao} \color{cyan}A. Rao, Dynamics of Particles and Rigid Bodies. Cambridge: Cambridge University Press, 2005. doi: 10.1017/CBO9780511805455.\color{black}
	\bibitem[21]{Ogata1} \color{cyan}K. Ogata, \textit{Discrete-Time Control Systems (2nd Ed.)}. USA: Prentice-Hall, Inc., 1995.\color{black}
	\bibitem[22]{Ogata2} \color{cyan}K. Ogata, \textit{Modern Control Engineering,} 5th ed. Pearson, 2009.\color{black}
	\bibitem[23]{Hang} \color{cyan}J.-X. Xu, C.-C. Hang, and C. Liu, “Parallel structure and tuning of a fuzzy PID controller,” Automatica, vol. 36, no. 5, pp. 673–684, 2000. [Online]. Available: https://www.sciencedirect.com/science/article/abs/pii/S0005109899001922.\color{black}
	
\end{thebibliography}
\textbf{Reference list format}\\
The reference list format is based on the IEEE and should appear at the end of the article, covering only the literature actually cited in the manuscript. Authors should use reference management tools such as Mendeley, End Note and Grammarly. Reference writing rules:
\begin{itemize}
	\item  References used within the last 10 years.
	\item Using the numbering that should be used for the reference title.
	\item Last name and year must be used for each reference citation.
	\item All references must be cited in the paper.
	\item Journal and conference names should be italicized.
	\item  The title of the book must be italicized.
\end{itemize}
.

\end{document}
$$

## end
#9, 2:
57
## end
#12, 461:
地址::文档\论文\test
+[有](输出docx,地址)
创建"文档\论文\test"

文本内容:...
输出结构:...
输出文本:...
+[H函数](,文本内容)
+[删除结构](,输出结构)
+[设置结构](,输出结构)
+[删除结构](,输出文本)
+[设置结构](,输出文本)
输出结构=>的(输出结构,一级标题)=>+[设置结构](,一级标题)
输出结构=>的(输出结构,二级标题)=>+[设置结构](,二级标题)
输出结构=>的(输出结构,二级标题)->的(二级标题,公式)=>+[设置结构](,公式)
输出结构=>的(输出结构,二级标题)->的(二级标题,图片)=>+[设置结构](,图片)

+[召唤星辰]"文本结构化"(文本内容,输出结构)
+[召唤星辰]"结构文本转LaTeX"(输出结构,输出文本)->+[.](输出结构,文本内容)


输出docx:...
+[召唤星辰]"结构文本转docx"(输出结构,输出docx)->+[.](输出结构,文本内容)
+[P函数](,输出docx)

## end
#14, 17400:
<!--
参考1(引用)::file:///C:/Users/cheng/Desktop/paper/Spectrometer/Nak08.pdf#page=1


[2].:
+[H函数](,正文)
exp
Nini, 打开双屏幕能谱(文件)
-->
<h1>Compact high-resolution multi-GeV electron spectrometer for PW-laser-driven plasma accelerators and approximate trajectory method for spectrum analysis</h1>
Xiantao, Aaron, Rafal, Mike*

<h2>Abstract</h2>
For the past decade, laser-plasma accelerators (LPAs) of ~ mm to ~ cm length have provided compact sources of nearly mono-energetic, highly directional electron bunches with energy as high as 1 GeV.  With the advent of petawatt scale lasers, these accelerators are now poised to go well beyond 1GeV energies.  In contrast to the large scale accelerator facilities, the LPA’s will be compact devices, requiring compact electron spectrometers adapted to the unique properties of the LPA electron bunches.  We report a compact high resolution spectrometer adapted to these conditions.  

<h2>Introduction</h2>
For the past decade, laser-plasma accelerators (LPAs) of ~ mm to ~ cm length have provided compact sources of nearly mono-energetic, highly directional electron bunches [Esa09] with energy as high as 1 GeV [Lee06].  The electron energy spectrum is generally measured with a standard magnetic spectrometer, in which a dipole magnetic field of typically ~1 T over cm dimensions, readily available from commercially available permanent magnets, deflects the trajectories of electrons emerging from the LPA [Nakamura07].  The deflected electrons are then detected 10 to 100 cm downstream of the magnet on a fluorescing screen, thereby mapping electron energy to displacement on the detector.  Because of the low angular divergence (typically a few mrad) of electrons from quasi-mono-energetic LPAs and the relatively large deflection angles (typically > 10o) of sub-GeV electrons achievable with small permanent magnets, the angular spread of electrons entering the magnetic field has played a minor role in the energy analysis of LPA electrons, except for energies approaching ~ 1 GeV [Pollock09, Clayton10]. <br>
  
The recent emergence of PW-class lasers has now ushered in a new era of quasi-mono-energetic laser-plasma acceleration (LPA) to multi-GeV electron bunches [Wang13, Kim13].  This new range of electron energy raises new challenges to the accurate measurement of electron energy, because the deflection angle becomes comparable to the initial angular spread.  For example, a 5 GeV electron bends only ??? mrad in a 1 T field of 5 cm extent.  An uncertainty of ?? mrad in the electron launch angle from the LPA can therefore result in uncertainty in the energy approaching 100%. The possibilities of energy-dependent launch angles and of uncertainty in the launch location due to multi-cm length of multi-GeV LPAs further complicate the analysis.  A brute force solution to these problems is to use stronger and/or larger magnets.  However, this compromises the principal virtues of LPAs – compactness and low expense. <br>

In this paper, we present an electron spectrometer suitable for PW LPA experiments that measures the energy spectrum of multi-GeV electrons with an accuracy of a few percent using permanent magnets no larger or more expensive than those typical of sub-GeV electron spectrometers.  Our spectrometer builds upon a “two-screen” concept introduced by [Pollock09, Clayton10] to deconvolve launch angle variations from energy variations... [summary description].  However, our spectrometer goes well beyond the two-screen method  [describe how].  The paper is organized as follows:  Section 2 provides an overview of the problem of multi-GeV electron energy analysis. Section 3 describes the set-up of our spectrometer, and analyzes the interaction of electrons and x-rays with its key components.  Section 4 presents an analysis of electron energy spectra for several shots with different characteristics.  Section 5 discusses.  Section 6 summarizes the main findings. <br>


<!--
Nini, 打开双屏幕能谱(文件)
Nini, 打开双屏幕能谱的双屏幕问题(节点)
Nini, 双屏幕能谱的双屏幕问题是什么?
+[H函数](,正文)

[0].

fig.1_(图片):
fig.1_的宽度是"700"
+[新建阅读窗口](,fig.1_)

fig.1_画图:...
F1画图::C:\Users\cheng\Dropbox\Struct\Structure1.2.1\Nini\output\paper\spectrometer\SecII\figs.pptx
10
-->
<h2>Two-screen method problem</h2>
The two-screen method is one of the most popular ways to measure LWFA electrons. In this method, electrons were usually deflected by a permanent dipole magnet and imaged by two screens at different locations after the magnet. 
In theory, any electron trajectories could be determined uniquely by three points in the space. <br>
In reality, the features on two screens might not be comparable, because of the divergency of electrons which always existed. For example, the electron beams could be a single peak image on the first screen, which it might be two peaks on the second screen. <br>
On the other hand, it is very important to find the correct correlated points on the screens to measure the spectrum of high energy electrons. A small error in the position measure would cause large errors in the spectrum measure, especially when the energy reaching \(10\ GeV\) level. <br>

For example, in the simulation, the IP2 was separated from the magnet by 800 mm and the IP1was separated by 3000 mm. The real spectrum had two peaks. The center of one was at \(E_1=10\ GeV\), and the other one was at \(E_2=3.7\ GeV\). The divergencies of the electrons were \(\sigma=3.0\ mrad\). <br>
There was two peaks on the IP1, while only one peak showed on the IP2. <br>
%fig.1_
<br>
<br>
<i>
Fig.1. (a) is the setup of a typical two-screen spectrometer. (a1) is the real spectrum of electrons. (a2) is the image on the IP2 screen. (a3) is the image on the IP1 screen. (a2) and (a3) are obtained from a GEANT4 simulation. <br>
(b) shows the intensity curves on both screens. The intensity is integrated over the Y-axis.
</i>
<br>
<br>
If we used the maximum point on the IP2 and the maximum point on the IP1 to define the trajectory, the energy of the trajectory would be \(18.56\ GeV\), while the real energy should be \(10\ GeV\).
<br>



As a result, we proposed a new design of spectrometer by using two sets of Tungsten fiducials with an image plate, instead of two screens. The fiducial would scatter electrons going through it and leaving a shadow on the image plate, which would provide two points on the trajectories.

<!--
Nini, 打开LWFA11数据分析(文件)
Nini, 打开LWFA11数据分析的实验参数(节点)
Nini, 打开能谱仪校正的实例分析(节点)
Nini, 能谱仪校正的实例分析是什么?
+[H函数](,正文)
XiaoMing::file:///C:/Users/cheng/Desktop/paper/LWFA/Xiaoming13.pdf
fiducial参数::https://utexas.app.box.com/file/855108479337
+[打开网页](,fiducial参数)
+[打开网页](,XiaoMing)

[1].:
fig.3_(图片):
2815.5-2672
-->
<h2>Experiment setup</h2>
In the experiments, the dipole magnet was placed 143.5 mm behind the gas cell. The magnetic field was equal to 1.48 T with 50 mm for the width. 

The <band> SR image plate (IP) was place 2672 mm after the magnet. The pixel size for the image plate was 50 um. The IP was scanned by XX, after every shot. <br>
Both sets of fiducials were consisted of 8 Tungsten wires with 0.127 mm for the diameter. The first set of fiducial was away from the IP by 1442 mm, which was closer to the magnet and the second set of fiducials are 934 mm from the IP, which was closer to the IP. 
The experiment setup is showed in the fig.3.<br>
%fig.3_<br>
<LWFA parameters>
There were many things done to increase the position measurement accuracies of different components. 
Two sets of fiducials were attach with the image plate holder by a stainless steel frame to increase the accuracy of position measurement. The accuracies of positions for fiducials and IP holder were XX mm. <br>
Fiducials were Tungsten wires, because the heavy element material could scatter more electrons with a small diameter shape. GEANT4 simulations were used to help us study the properties of electrons scattering, which will be discussed in the next Sec.<br>
The source locations could shifted randomly because of the laser pointing drifting. The IP position could also changed, because of the small gap between the holder and the IP. Those uncertainties were unavoidable, so we proposed a Betatron shadow calibration to calibrate both of locations. It will be discussed in the next next Sec.


<!--
Nini, 打开阴影形状(文件)
Nini, 阴影形状的算法是什么?
Nini, 阴影形状的fiducial散射是什么?
Nini, 打开阴影形状的fiducial散射(节点)

Nini, 打开能谱仪模拟(文件)
Nini, 打开能谱仪模拟的fiducial阴影(节点)
Nini, 能谱仪模拟的fiducial阴影是什么?
Nini, 导入公式结构的库. Nini, 导入公式分析器的库

+[新建阅读窗口](,阴影形状画图)
+[新建阅读窗口](,散射角画图)
+[新建阅读窗口](,曲线数据)
曲线数据(M函数):...
散射角画图(M函数):...
创建"output\paper\spectrometer\SecV"
在"output\paper\spectrometer\SecIV\fig1.png"处, 保存当前图像
Nini, 打开动词(库)
阴影形状画图(M函数):...
(是阴影形状的一维分布图)
+[打开]"output\paper\spectrometer\SecIV"

[0].(公式):...
将"\sigma=\Delta/L"记作(0)式

fig.5_(图片):...
fig.5_的宽度是"800"
Nini, 打开公式结构的句子库(节点)

+[H函数](,正文)
-->
<h2>Fiducial electrons scattering</h2>
For fiducial design, it is a tradeoff to project a thin shadow and a high constrast one. To project high constrast shadows, the fiducials need to be thick enough to scatter electrons by a large angle, while it needs to be thin to make the shadow thin as well. As a result, a heavy element material, for example Tungsten, is preferred. <br>
Both the angular spread and the energy spread will affect the shadow constrast, which might be very different for different electron source. But the most fundamental requirement for the shadow formation is that the electrons scattered by fiducials should fall into pixels on the IP other than the original pixel. <br>

We studied the scattering of electrons with different energy by different diameter of Tungsten wires by GEANT4 simulations. For monoenergetic electron inputs, the angular distributions of scattered electrons are Gaussian distributions, according to simluations. 
The standard deviation of the distribution is a function of the input energy. The functions were found through simulations and results were showed in fig.4. <br>

<br>
%fig.4_
<br>
<i>
Fig.4. (a) shows \(\sigma\) as functions of E. Tungsten wires with diameter, D=0.050 mm, 0.127 mm, 0.200 mm, 0.400 mm and 0.800 mm were studied.<br>
(b) is one of simulation results. 10 GeV electrons were scattered by a 0.127 mm Tungsten wire in this simulation. The figure shows the angular distribution of scattered electrons. The dots are simulation data, and the solid line is a Gaussian function, which is \(g(\theta)=A\ exp(-\theta^2/\sigma^2)\).
</i>
<br><br>

For 0.127 Tungsten wires, the standard deviation \(\sigma\) as a function of input energy can be expressed as following,
%[1].


<!--
[1].:
-->

The shadow shape was also studied by simulations. The results were showed in fig.5. From the simulation, we learned that the shadow shape was determined by the divergency, \(\sigma\), v.s. the pixel size, \(\Delta\), over the separation, \(L\), between the wire and the IP. <br>
To obtain a clear shadow on the IP, the condition is,
%[0].

<br>
%fig.5_
<br>
<i>
Fig.5. the shadow shapes of a 0.127 mm Tungsten wire were studied for different spectrums and different wire positions. It was Gaussian spectrum for all simulation. The peak energies were 4.313 GeV, 8.67 GeV, 17.55 GeV, 36.0 GeV and 75.9 GeV for (i1)-(i5), wihch were corresponding to \(\sigma\)=0.8, 0.4, 0.2, 0.1 and 0.05 mrad. <br>
The pixel size was 0.05 mm in simulations. Let's say the separation between the wire and the IP is L. Then L=500 mm, 250 mm and 125 mm for (a)'s, (b)'s and (c)'s, which corresponding to \(\Delta\)/L=0.1, 0.2 and 0.4 mrad. 
</i>
<br><br>

In fact, the shadow shape is different for different electron energies. 
For low-energy electrons, a fiducial projected a pit on the spectrum image. But for high-energy electrons, there were two peaks around the pit, which weren't there in the original spectrum. <br>
The explanation is the high-energy electrons were scattered within a small angular range. Most of electrons were still falling on the IP around their original positions. Although in the origianl position, the intensity was lower, those places around the shadow had higher intensity, because the scattered electrons added intensity to those areas. <br>
This phenomenon can be an evident of high energy electrons observation in a experiment. 



<!--
Nini, 打开能谱仪校正(文件)
Nini, 能谱仪校正的实例分析是什么?

+[H函数](,正文)
-->
<h2>Betatron calibration</h2>
LWFA electrons always came with Betatron radiations because of the oscillation caused by the focusing field. Since the most of Betatron radiations were generated by electrons in the end of acceleration process, the radiation sources were also the sources of electrons. 
The SR IP is also able to record the X-ray intensities, and the same sets of fiducials also block X-rays from Betatron radiations leaving shadows on the IP. It is straight forward to connect fiducials and their correlated shadows, and to locate the source by crossing points of all trajectories. <br>
The X-ray shadows are distinguishable from electron shadows, because the image of Betatron radiations are distinguishable from electrons. X-rays are not deflected by the magnet and will be imaged in the center area of the IP. And divergencies of Betatron radiations are much larger than electrons', as a result, electron shadows can only appear in the center area in the veritcal axis. <br>
The two rows of fiducials can help with calibrating the IP position relative to the source. According to the simple geometric relations, if there were errors in IP positions, either longitudinal or tranversal, the two rows of fiducials would produce two sets of crossing points. Then it is an obvious calibration by moving the IP position to make the two sets as one. The accuracy of this calibration can be calculated from the geometric relations. <br>
From our experiments, the waist of the Betatron radiation trajectories is usually couple hundreds of micro-meters. 


<!--
Nini, 打开能谱仪模拟(文件)
Nini, 能谱仪模拟的近似轨迹是什么?
Nini, 打开能谱仪模拟的近似轨迹(节点)

[6].(公式):
+[H函数](,正文)
-->
<h2>Approximate trajectory method and accuracy analysis</h2>
Traditionally, the motion of electrons in a dipole magnet can be simplified as in an uniform magnetic field, since the trajectory is not sensitive to the shape of the distribution but only to the total magnetic flux. In an uniform magnetic field, the trajectory is two straight lines in the free space connecting by an arc in the magnetic field. <br>
Here we proposed a further simplified method by assuming the field width to be infinitesimal, which keeping the total magentic flux constant. In this situation, the arc trajectory shrinked to a single point. The whole trajectory only consists of two straight lines connecting at the magnet position, or the center of the original magnetic field. <br>
The difference in the directions between the two lines is determined by electron energy, by the following equations,<br>
%[2].
%[3].
<br>
This method is accurate in the case of high energy electron trajectories. For example,
<br>
We built a simply equation to analyze the accuracy of the spectrometer base on this method. <br>
%[4].
<br>
The maximum accuracy of this kind of spectrometers (for example, two-screen spectrometers) can also be calculated. 
%[5].
<br>
We also developed a formula to calculate the spectrum image for electrons with any spectrums and any angular distributions. The calculated results were compared with GEANT4 simulations.




<!--
Nini, 打开能谱仪模拟(文件)
Nini, 能谱仪模拟的轫致辐射是什么?

在"文档\物理问题\轫致辐射.ftxt"处, 新建轫致辐射
Nini, 打开轫致辐射(文件)

验证误差(M函数):...
+[H函数](,正文)
-->
<h2>Radiation method</h2>
There may be a better design for high energy electron spectrometer base on bremsstrahlung radiations. Instead of fiducials, a thin Al foil can be put before the magnet to generate bremsstrahlung radiations. The X-rays will keep the electron launch angle before the magnet without deflected by the magnet, and will be recorded by the same IP. The distance from the radiation center to any points on the IP can reveal the deflection angle of electron through the magnet directly. <br>
It is impossible to make an accurate launch angle measurement with the Betatron radiation only, because: 1. the anguler spread of Betatron radiation is too large. 2. the direction of Betatron radiation is not necessarily same as the electrons.<br>
It is important to measure the X-rays and electrons on a same IP, because there will be no uncertainties on the relative separation between X-rays and electrons. The accuracy of this spectrometer is insensitive to the absolute position of the IP and the source (the Al foil position here). For example, .<br>
It can also be proved by the method introduced in the last section. <br>
<br>
The light element material is preferred, because it has less effects on the spectrum and angular profile of electrons. We also used GEANT4 to study the properties of Al foil scattering. <br>
<br>
In addition to keep the launch angle information, it also keeps the angular distribution according to GEANT4 simulations. <br>
<br>
It is even possible to retrieve the real spectrum of electrons from the convolution of divergencies, based on the formula in last section. Although it may be unnecessary. 

 
<!--
+[H函数](,正文)
-->
<h2>Summary</h2>


<!--
[6].:
fig.3_(图片)::C:\Users\cheng\Dropbox\Struct\Structure1.2.1\Nini\output\paper\spectrometer\13975\calibration\fig1.png

fig.4_->fig.3_->+[修改内容](fig.3_,fig.4_)->+[修改内容](fig.4_,fig.3_)

将"a[i+1]=a[i]+2"记作为式(6)

+[H函数](,文本内容)
-->
## end
#16, 175:
Nini, 打开词典(文件)
Nini, 打开公式分析器(文件)

结构转文本:...
文本结构_插入尾部:...
文本结构_插入:...

例句转句子:...
收集例句:...

显示parser结构:...
显示parser结构_代码:...
将条目"显示parser结构"复制为条目"显示parser结构_代码"

分析结构图结构:...



## end
#18, 72:


解析Parser结构:...
解析Parser结构_代码:...
+[新建阅读窗口](,解析Parser结构)

结构图_代码:...



## end
#20, 694:
Nini, 打开天书(文件)
Nini, 打开网页画板(文件)

文本结构化:...
文本转换:...
+[新建阅读窗口](,文本结构化)
+[新建阅读窗口](,文本转换)
封印'文本转换'
封印'文本结构化'

文本转换_docx:...
+[新建阅读窗口](,文本转换_docx)
封印'文本转换_docx'

文本转换_博客:...
文本转换_md:...
+[新建阅读窗口](,文本转换_博客)
+[新建阅读窗口](,文本转换_md)
封印'文本转换_md'
将条目"文本转换_博客"复制为条目"文本转换_md"

生成Parser代码:...
生成Parser代码_快速:...
生成例句代码:...
+[新建阅读窗口](,生成Parser代码_快速)
+[新建阅读窗口](,生成Parser代码)
+[新建阅读窗口](,生成例句代码)
封印'生成Parser代码_快速'
封印'生成Parser代码'
封印'生成例句代码'


Nini, 打开动作(库)
Nini, 打开词典(文件)
输出博客:...
+[删除结构](,文本结构)->+[召唤星辰]"文本结构化"(测试文本,文本结构)
文本结构=>的(文本结构,二级标题)=>+[设置结构](,二级标题)
文本结构:...
测试文本:...


一般结构转流程图:...
一般结构转分类图:...
一般结构转结构文字:...
将条目"一般结构转流程图"复制为条目"一般结构转分类图"
+[新建阅读窗口](,一般结构转流程图)
+[新建阅读窗口](,一般结构转分类图)
封印'一般结构转流程图'
封印'一般结构转分类图'



## end
#22, 23:


召唤规则:...
降临规则:...




## end
#24, 30:


简化内容:...
分析段落:...
整理结构:...


## end
#26, 229:
"""
Nini, 打开天书(文件)
Nini, 打开人体模型(文件)

"""

+召唤规则(_媒介,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_凭依)...

->[==]"文本结构化"(,召唤星辰)...
    ->+整理结构(_媒介,_凭依)->+的(操作,+整理结构)...
    ->+分析段落(_媒介,_凭依)->+的(操作,+分析段落)...
    ->+简化内容(_媒介,_凭依)->+的(操作,+简化内容)




## end
#28, 151:
"""
P代码:...

"""
+简化内容(_媒介,_凭依)->+[del](,+简化内容)...
->的(简化内容,P代码)...

->+[python](Python,_凭依)->+[code](+[python],P代码)...
->+[s]"text"(+[python],_媒介)




## end
#30, 456:
"""
描述结构:...
库:...
Nini, 打开人体模型(文件)
+[新建阅读窗口](,描述结构)

"""
+分析段落(_媒介,_凭依)->+[del](,+分析段落)...
->的(分析段落,描述结构)->的(分析段落,库)...
->的(库,生成章节#0)...

->+[code]([想],描述结构)->[想](,_凭依)...
->结构([想],)...
->[]{
    []=>的(结构,章节)->章节->类型(章节,)...
    =>+的(_凭依,+章节)->[m_text](章节,+章节)->+是(章节,+章节)->+[del](,+是)...
        ->+[修改标题](,+章节)->[m_text](类型,+[修改标题])
}...

->操作([想],)...
->[]{
    []=>的(操作,生成章节)->生成章节(,章节)->章节->是(章节,_章节)...
    =>+[做](_媒介,_章节)->+[code](+[做],生成章节#0)
}



## end
#32, 623:
"""
记住"Python"
print(re.sub(r'[\s]','','t e s t'))

"""

import re

i=0
j=0
ans=''
while True:
    if i+4<len(text) and text[i:i+4]=='<!--':
        i=i+4
        while True:
            if i+3<len(text) and text[i:i+3]=='-->':
                i+=3
                break
            elif i>=len(text):
                break
            else:
                i+=1
    else:
        ans+=text[i]

    if i<len(text)-1:
        i+=1
    else:
        break

ans=re.sub(r'<br>','\n',ans)
ans=re.sub(r'<i>','',ans)
ans=re.sub(r'</i>','',ans)
ans=re.sub(r'\n\s*\n','\n',ans)


"""
Nini, 打开词典(文件)
Nini, 打开公式分析器(文件)
记住"Python"

"""
## end
#34, 15293:
<h1>Compact high-resolution multi-GeV electron spectrometer for PW-laser-driven plasma accelerators and approximate trajectory method for spectrum analysis</h1>
Xiantao, Aaron, Rafal, Mike*
<h2>Abstract</h2>
For the past decade, laser-plasma accelerators (LPAs) of ~ mm to ~ cm length have provided compact sources of nearly mono-energetic, highly directional electron bunches with energy as high as 1 GeV.  With the advent of petawatt scale lasers, these accelerators are now poised to go well beyond 1GeV energies.  In contrast to the large scale accelerator facilities, the LPA’s will be compact devices, requiring compact electron spectrometers adapted to the unique properties of the LPA electron bunches.  We report a compact high resolution spectrometer adapted to these conditions.  
<h2>Introduction</h2>
For the past decade, laser-plasma accelerators (LPAs) of ~ mm to ~ cm length have provided compact sources of nearly mono-energetic, highly directional electron bunches [Esa09] with energy as high as 1 GeV [Lee06].  The electron energy spectrum is generally measured with a standard magnetic spectrometer, in which a dipole magnetic field of typically ~1 T over cm dimensions, readily available from commercially available permanent magnets, deflects the trajectories of electrons emerging from the LPA [Nakamura07].  The deflected electrons are then detected 10 to 100 cm downstream of the magnet on a fluorescing screen, thereby mapping electron energy to displacement on the detector.  Because of the low angular divergence (typically a few mrad) of electrons from quasi-mono-energetic LPAs and the relatively large deflection angles (typically > 10o) of sub-GeV electrons achievable with small permanent magnets, the angular spread of electrons entering the magnetic field has played a minor role in the energy analysis of LPA electrons, except for energies approaching ~ 1 GeV [Pollock09, Clayton10]. 
The recent emergence of PW-class lasers has now ushered in a new era of quasi-mono-energetic laser-plasma acceleration (LPA) to multi-GeV electron bunches [Wang13, Kim13].  This new range of electron energy raises new challenges to the accurate measurement of electron energy, because the deflection angle becomes comparable to the initial angular spread.  For example, a 5 GeV electron bends only ??? mrad in a 1 T field of 5 cm extent.  An uncertainty of ?? mrad in the electron launch angle from the LPA can therefore result in uncertainty in the energy approaching 100%. The possibilities of energy-dependent launch angles and of uncertainty in the launch location due to multi-cm length of multi-GeV LPAs further complicate the analysis.  A brute force solution to these problems is to use stronger and/or larger magnets.  However, this compromises the principal virtues of LPAs – compactness and low expense. 
In this paper, we present an electron spectrometer suitable for PW LPA experiments that measures the energy spectrum of multi-GeV electrons with an accuracy of a few percent using permanent magnets no larger or more expensive than those typical of sub-GeV electron spectrometers.  Our spectrometer builds upon a “two-screen” concept introduced by [Pollock09, Clayton10] to deconvolve launch angle variations from energy variations... [summary description].  However, our spectrometer goes well beyond the two-screen method  [describe how].  The paper is organized as follows:  Section 2 provides an overview of the problem of multi-GeV electron energy analysis. Section 3 describes the set-up of our spectrometer, and analyzes the interaction of electrons and x-rays with its key components.  Section 4 presents an analysis of electron energy spectra for several shots with different characteristics.  Section 5 discusses.  Section 6 summarizes the main findings. 
<h2>Two-screen method problem</h2>
The two-screen method is one of the most popular ways to measure LWFA electrons. In this method, electrons were usually deflected by a permanent dipole magnet and imaged by two screens at different locations after the magnet. 
In theory, any electron trajectories could be determined uniquely by three points in the space. 
In reality, the features on two screens might not be comparable, because of the divergency of electrons which always existed. For example, the electron beams could be a single peak image on the first screen, which it might be two peaks on the second screen. 
On the other hand, it is very important to find the correct correlated points on the screens to measure the spectrum of high energy electrons. A small error in the position measure would cause large errors in the spectrum measure, especially when the energy reaching \(10\ GeV\) level. 
For example, in the simulation, the IP2 was separated from the magnet by 800 mm and the IP1was separated by 3000 mm. The real spectrum had two peaks. The center of one was at \(E_1=10\ GeV\), and the other one was at \(E_2=3.7\ GeV\). The divergencies of the electrons were \(\sigma=3.0\ mrad\). 
There was two peaks on the IP1, while only one peak showed on the IP2. 
%fig.1_
Fig.1. (a) is the setup of a typical two-screen spectrometer. (a1) is the real spectrum of electrons. (a2) is the image on the IP2 screen. (a3) is the image on the IP1 screen. (a2) and (a3) are obtained from a GEANT4 simulation. 
(b) shows the intensity curves on both screens. The intensity is integrated over the Y-axis.
If we used the maximum point on the IP2 and the maximum point on the IP1 to define the trajectory, the energy of the trajectory would be \(18.56\ GeV\), while the real energy should be \(10\ GeV\).
As a result, we proposed a new design of spectrometer by using two sets of Tungsten fiducials with an image plate, instead of two screens. The fiducial would scatter electrons going through it and leaving a shadow on the image plate, which would provide two points on the trajectories.
<h2>Experiment setup</h2>
In the experiments, the dipole magnet was placed 143.5 mm behind the gas cell. The magnetic field was equal to 1.48 T with 50 mm for the width. 
The <band> SR image plate (IP) was place 2672 mm after the magnet. The pixel size for the image plate was 50 um. The IP was scanned by XX, after every shot. 
Both sets of fiducials were consisted of 8 Tungsten wires with 0.127 mm for the diameter. The first set of fiducial was away from the IP by 1442 mm, which was closer to the magnet and the second set of fiducials are 934 mm from the IP, which was closer to the IP. 
The experiment setup is showed in the fig.3.
%fig.3_
<LWFA parameters>
There were many things done to increase the position measurement accuracies of different components. 
Two sets of fiducials were attach with the image plate holder by a stainless steel frame to increase the accuracy of position measurement. The accuracies of positions for fiducials and IP holder were XX mm. 
Fiducials were Tungsten wires, because the heavy element material could scatter more electrons with a small diameter shape. GEANT4 simulations were used to help us study the properties of electrons scattering, which will be discussed in the next Sec.
The source locations could shifted randomly because of the laser pointing drifting. The IP position could also changed, because of the small gap between the holder and the IP. Those uncertainties were unavoidable, so we proposed a Betatron shadow calibration to calibrate both of locations. It will be discussed in the next next Sec.
<h2>Fiducial electrons scattering</h2>
For fiducial design, it is a tradeoff to project a thin shadow and a high constrast one. To project high constrast shadows, the fiducials need to be thick enough to scatter electrons by a large angle, while it needs to be thin to make the shadow thin as well. As a result, a heavy element material, for example Tungsten, is preferred. 
Both the angular spread and the energy spread will affect the shadow constrast, which might be very different for different electron source. But the most fundamental requirement for the shadow formation is that the electrons scattered by fiducials should fall into pixels on the IP other than the original pixel. 
We studied the scattering of electrons with different energy by different diameter of Tungsten wires by GEANT4 simulations. For monoenergetic electron inputs, the angular distributions of scattered electrons are Gaussian distributions, according to simluations. 
The standard deviation of the distribution is a function of the input energy. The functions were found through simulations and results were showed in fig.4. 
%fig.4_
Fig.4. (a) shows \(\sigma\) as functions of E. Tungsten wires with diameter, D=0.050 mm, 0.127 mm, 0.200 mm, 0.400 mm and 0.800 mm were studied.
(b) is one of simulation results. 10 GeV electrons were scattered by a 0.127 mm Tungsten wire in this simulation. The figure shows the angular distribution of scattered electrons. The dots are simulation data, and the solid line is a Gaussian function, which is \(g(\theta)=A\ exp(-\theta^2/\sigma^2)\).
For 0.127 Tungsten wires, the standard deviation \(\sigma\) as a function of input energy can be expressed as following,
%[1].
The shadow shape was also studied by simulations. The results were showed in fig.5. From the simulation, we learned that the shadow shape was determined by the divergency, \(\sigma\), v.s. the pixel size, \(\Delta\), over the separation, \(L\), between the wire and the IP. 
To obtain a clear shadow on the IP, the condition is,
%[0].
%fig.5_
Fig.5. the shadow shapes of a 0.127 mm Tungsten wire were studied for different spectrums and different wire positions. It was Gaussian spectrum for all simulation. The peak energies were 4.313 GeV, 8.67 GeV, 17.55 GeV, 36.0 GeV and 75.9 GeV for (i1)-(i5), wihch were corresponding to \(\sigma\)=0.8, 0.4, 0.2, 0.1 and 0.05 mrad. 
The pixel size was 0.05 mm in simulations. Let's say the separation between the wire and the IP is L. Then L=500 mm, 250 mm and 125 mm for (a)'s, (b)'s and (c)'s, which corresponding to \(\Delta\)/L=0.1, 0.2 and 0.4 mrad. 
In fact, the shadow shape is different for different electron energies. 
For low-energy electrons, a fiducial projected a pit on the spectrum image. But for high-energy electrons, there were two peaks around the pit, which weren't there in the original spectrum. 
The explanation is the high-energy electrons were scattered within a small angular range. Most of electrons were still falling on the IP around their original positions. Although in the origianl position, the intensity was lower, those places around the shadow had higher intensity, because the scattered electrons added intensity to those areas. 
This phenomenon can be an evident of high energy electrons observation in a experiment. 
<h2>Betatron calibration</h2>
LWFA electrons always came with Betatron radiations because of the oscillation caused by the focusing field. Since the most of Betatron radiations were generated by electrons in the end of acceleration process, the radiation sources were also the sources of electrons. 
The SR IP is also able to record the X-ray intensities, and the same sets of fiducials also block X-rays from Betatron radiations leaving shadows on the IP. It is straight forward to connect fiducials and their correlated shadows, and to locate the source by crossing points of all trajectories. 
The X-ray shadows are distinguishable from electron shadows, because the image of Betatron radiations are distinguishable from electrons. X-rays are not deflected by the magnet and will be imaged in the center area of the IP. And divergencies of Betatron radiations are much larger than electrons', as a result, electron shadows can only appear in the center area in the veritcal axis. 
The two rows of fiducials can help with calibrating the IP position relative to the source. According to the simple geometric relations, if there were errors in IP positions, either longitudinal or tranversal, the two rows of fiducials would produce two sets of crossing points. Then it is an obvious calibration by moving the IP position to make the two sets as one. The accuracy of this calibration can be calculated from the geometric relations. 
From our experiments, the waist of the Betatron radiation trajectories is usually couple hundreds of micro-meters. 
<h2>Approximate trajectory method and accuracy analysis</h2>
Traditionally, the motion of electrons in a dipole magnet can be simplified as in an uniform magnetic field, since the trajectory is not sensitive to the shape of the distribution but only to the total magnetic flux. In an uniform magnetic field, the trajectory is two straight lines in the free space connecting by an arc in the magnetic field. 
Here we proposed a further simplified method by assuming the field width to be infinitesimal, which keeping the total magentic flux constant. In this situation, the arc trajectory shrinked to a single point. The whole trajectory only consists of two straight lines connecting at the magnet position, or the center of the original magnetic field. 
The difference in the directions between the two lines is determined by electron energy, by the following equations,
%[2].
%[3].
This method is accurate in the case of high energy electron trajectories. For example,
We built a simply equation to analyze the accuracy of the spectrometer base on this method. 
%[4].
The maximum accuracy of this kind of spectrometers (for example, two-screen spectrometers) can also be calculated. 
%[5].
We also developed a formula to calculate the spectrum image for electrons with any spectrums and any angular distributions. The calculated results were compared with GEANT4 simulations.
<h2>Radiation method</h2>
There may be a better design for high energy electron spectrometer base on bremsstrahlung radiations. Instead of fiducials, a thin Al foil can be put before the magnet to generate bremsstrahlung radiations. The X-rays will keep the electron launch angle before the magnet without deflected by the magnet, and will be recorded by the same IP. The distance from the radiation center to any points on the IP can reveal the deflection angle of electron through the magnet directly. 
It is impossible to make an accurate launch angle measurement with the Betatron radiation only, because: 1. the anguler spread of Betatron radiation is too large. 2. the direction of Betatron radiation is not necessarily same as the electrons.
It is important to measure the X-rays and electrons on a same IP, because there will be no uncertainties on the relative separation between X-rays and electrons. The accuracy of this spectrometer is insensitive to the absolute position of the IP and the source (the Al foil position here). For example, .
It can also be proved by the method introduced in the last section. 
The light element material is preferred, because it has less effects on the spectrum and angular profile of electrons. We also used GEANT4 to study the properties of Al foil scattering. 
In addition to keep the launch angle information, it also keeps the angular distribution according to GEANT4 simulations. 
It is even possible to retrieve the real spectrum of electrons from the convolution of divergencies, based on the formula in last section. Although it may be unnecessary. 
<h2>Summary</h2>

## end
#35, 3:
540
## end
#38, 16:


生成章节:...






## end
#40, 563:
"""
P代码:...
P代码2:...
段落:...

"""

+描述结构(,_凭依)->+[del](,+描述结构)...
->的(描述结构,P代码)->的(描述结构,P代码2)->的(描述结构,段落)...
->+操作(+描述结构,)->+结构(+描述结构,)...

->+[.]"text_paper"([python],_凭依)...
->+[code]([python],P代码)->[python](Python,)...

->+[.]([想],+操作)->+[.]([想],+结构)->+[code]([想],段落)...
->+不终止->+[code]([python]#2,P代码2)...

=>[python]#2(Python,+不终止)->[想](,_凭依)->章节([想],)->类型([想],)...
=>+的(+结构,+章节)->[m_text](章节,+章节)...
->+类型(+章节,)->[m_text](类型,+类型)...

->[]{
    []:->[==]"一级标题"(,类型)->+生成章节(,+章节)->+的(+操作,+生成章节),
    ->[==]"二级标题"(,类型)->+生成章节(,+章节)->+的(+操作,+生成章节),
    ->[]
}



## end
#42, 76:
"""
记住"Python"

"""


list_sec=text_paper.split('\n')
list_i=0
state=True



## end
#44, 221:
"""
P代码:...
+[新建阅读窗口](,P代码)

"""

+段落(,_凭依)->.(+段落,操作)->.(+段落,结构)...
->的(段落,P代码)...

->+章节(+段落,)->+类型(+段落,)...
->+[o]"text_sec"([python],+章节)->+[o]"type_sec"([python],+类型)...
->+[code]([python],P代码)->[python](Python,)




## end
#46, 774:
"""


"""

state=True
while True:
    if list_i>=len(list_sec):
        type_sec='结束'
        break
    text_sec=list_sec[list_i]
    list_i+=1
    if text_sec!='':
        break

if type_sec=='结束':
    state=False
elif len(text_sec)>4 and text_sec[0:4]=='<h2>':
    text_sec=text_sec[4:]
    text_sec=text_sec[0:-5]
    type_sec='二级标题'
    while True:
        if list_i>=len(list_sec):
            break
        elif len(text_sec)>3 and list_sec[list_i][0:3]=='<h1':
            break
        elif len(text_sec)>3 and list_sec[list_i][0:3]=='<h2':
            break
        text_sec+="\n"+list_sec[list_i]
        list_i+=1

elif len(text_sec)>4 and text_sec[0:4]=='<h1>':
    text_sec=text_sec[4:]
    text_sec=text_sec[0:-5]
    type_sec='一级标题'
else:
    type_sec='文本'



## end
#48, 43:
"""


"""

state=(list_i<len(list_sec))




## end
#50, 666:
"""
描述结构:...
库:...
+[新建阅读窗口](,描述结构)

保存:...
测试:...
+[新建阅读窗口](,测试)

"""

+生成章节(_媒介,_章节)->+[del](,+生成章节)...
->的(生成章节,描述结构)->的(生成章节,库)...

->+[code]([想],描述结构)->[想](,_章节)...
->结构([想],)...
->[]{
    []=>的(结构,章节)->章节->类型(章节,)...
    =>+的(_章节,+章节)->[m_text](章节,+章节)->+是(章节,+章节)->+[del](,+是)...
    ->+[修改标题](,+章节)->[m_text](类型,+[修改标题])...
    ->+[下一个](结构,+章节)->+下一个(结构,章节#0)->章节#0->+[del](,+下一个):
        ->头部(结构,)->+然后(章节#0,+章节)->+的(_章节,+然后),
        ->+头部(结构,)->+[del](,+头部)
}...

->操作([想],)...
->[]{
    []=>的(操作,_操作)->_操作(_主语,_宾语)->_主语->_宾语=>[说](,_操作)...
    ->的(库,_条目)->_条目->[eq](_条目,_操作)->是(_宾语,_节点)...
        ->+[做](_主语,_节点)->+[code](+[做],_条目)->+[.](+[做],_媒介)
}




## end
#52, 565:
"""
P代码:...
P代码2:...
段落:...

"""

+描述结构(,_凭依)->+[del](,+描述结构)...
->的(描述结构,P代码)->的(描述结构,P代码2)->的(描述结构,段落)...
->+操作(+描述结构,)->+结构(+描述结构,)...

->+[.]"text_paper"([python],_凭依)...
->+[code]([python],P代码)->[python](Python,)...

->+[.]([想],+操作)->+[.]([想],+结构)->+[code]([想],段落)...
->+不终止->+[code]([python]#2,P代码2)...

=>[python]#2(Python,+不终止)->[想](,_凭依)->章节([想],)->类型([想],)...
=>+的(+结构,+章节)->[m_text](章节,+章节)...
->+类型(+章节,)->[m_text](类型,+类型)...

->[]{
    []:->[==]"图片"(,类型)->+图片结构(_凭依,+章节)->+的(+操作,+图片结构),
    ->[==]"公式"(,类型)->+公式结构(_凭依,+章节)->+的(+操作,+公式结构),
    ->[]
}



## end
#54, 60:


图片结构:...
公式结构:...
将条目"图片结构"复制为条目"公式结构"
将公式结构的"图片"替换为"公式"


## end
#56, 219:
"""
P代码:...
+[新建阅读窗口](,P代码)

"""

+段落(,_凭依)->.(+段落,操作)->.(+段落,结构)...
->的(段落,P代码)...

->+章节(+段落,)->+类型(+段落,)...
->+[o]"text_sec"([python],+章节)->+[o]"type_sec"([python],+类型)...
->+[code]([python],P代码)->[python](Python,)


## end
#58, 76:
"""
记住"Python"

"""


list_sec=text_paper.split('\n')
list_i=0
state=True



## end
#60, 41:
"""


"""

state=(list_i<len(list_sec))


## end
#62, 468:
"""


"""

state=True
while True:
    if list_i>=len(list_sec):
        type_sec='结束'
        break
    text_sec=list_sec[list_i]
    list_i+=1
    if text_sec!='':
        break

if type_sec=='结束':
    state=False
elif list_i==1:
    type_sec='题目'
elif len(text_sec)>4 and text_sec[0:4]=='%fig':
    type_sec='图片'
elif len(text_sec)>2 and text_sec[0:2]=='%[':
    type_sec='公式'
elif len(text_sec)>1 and text_sec[0:1]=='%':
    type_sec='图片'
else:
    type_sec='文本'



## end
#63, 7:
Summary
## end
#64, 16:
Radiation method
## end
#65, 478:
There may be a better design for high energy electron spectrometer base on bremsstrahlung radiations. Instead of fiducials, a thin Al foil can be put before the magnet to generate bremsstrahlung radiations. The X-rays will keep the electron launch angle before the magnet without deflected by the magnet, and will be recorded by the same IP. The distance from the radiation center to any points on the IP can reveal the deflection angle of electron through the magnet directly. 
## end
#66, 243:
It is impossible to make an accurate launch angle measurement with the Betatron radiation only, because: 1. the anguler spread of Betatron radiation is too large. 2. the direction of Betatron radiation is not necessarily same as the electrons.
## end
#67, 304:
It is important to measure the X-rays and electrons on a same IP, because there will be no uncertainties on the relative separation between X-rays and electrons. The accuracy of this spectrometer is insensitive to the absolute position of the IP and the source (the Al foil position here). For example, .
## end
#68, 68:
It can also be proved by the method introduced in the last section. 
## end
#69, 186:
The light element material is preferred, because it has less effects on the spectrum and angular profile of electrons. We also used GEANT4 to study the properties of Al foil scattering. 
## end
#70, 122:
In addition to keep the launch angle information, it also keeps the angular distribution according to GEANT4 simulations. 
## end
#71, 171:
It is even possible to retrieve the real spectrum of electrons from the convolution of divergencies, based on the formula in last section. Although it may be unnecessary. 
## end
#72, 51:
Approximate trajectory method and accuracy analysis
## end
#73, 346:
Traditionally, the motion of electrons in a dipole magnet can be simplified as in an uniform magnetic field, since the trajectory is not sensitive to the shape of the distribution but only to the total magnetic flux. In an uniform magnetic field, the trajectory is two straight lines in the free space connecting by an arc in the magnetic field. 
## end
#74, 346:
Here we proposed a further simplified method by assuming the field width to be infinitesimal, which keeping the total magentic flux constant. In this situation, the arc trajectory shrinked to a single point. The whole trajectory only consists of two straight lines connecting at the magnet position, or the center of the original magnetic field. 
## end
#75, 116:
The difference in the directions between the two lines is determined by electron energy, by the following equations,
## end
#76, 5:
%[2].
## end
#77, 5:
%[3].
## end
#78, 86:
This method is accurate in the case of high energy electron trajectories. For example,
## end
#79, 92:
We built a simply equation to analyze the accuracy of the spectrometer base on this method. 
## end
#80, 5:
%[4].
## end
#81, 115:
The maximum accuracy of this kind of spectrometers (for example, two-screen spectrometers) can also be calculated. 
## end
#82, 5:
%[5].
## end
#83, 185:
We also developed a formula to calculate the spectrum image for electrons with any spectrums and any angular distributions. The calculated results were compared with GEANT4 simulations.
## end
#84, 20:
Betatron calibration
## end
#85, 269:
LWFA electrons always came with Betatron radiations because of the oscillation caused by the focusing field. Since the most of Betatron radiations were generated by electrons in the end of acceleration process, the radiation sources were also the sources of electrons. 
## end
#86, 296:
The SR IP is also able to record the X-ray intensities, and the same sets of fiducials also block X-rays from Betatron radiations leaving shadows on the IP. It is straight forward to connect fiducials and their correlated shadows, and to locate the source by crossing points of all trajectories. 
## end
#87, 386:
The X-ray shadows are distinguishable from electron shadows, because the image of Betatron radiations are distinguishable from electrons. X-rays are not deflected by the magnet and will be imaged in the center area of the IP. And divergencies of Betatron radiations are much larger than electrons', as a result, electron shadows can only appear in the center area in the veritcal axis. 
## end
#88, 449:
The two rows of fiducials can help with calibrating the IP position relative to the source. According to the simple geometric relations, if there were errors in IP positions, either longitudinal or tranversal, the two rows of fiducials would produce two sets of crossing points. Then it is an obvious calibration by moving the IP position to make the two sets as one. The accuracy of this calibration can be calculated from the geometric relations. 
## end
#89, 115:
From our experiments, the waist of the Betatron radiation trajectories is usually couple hundreds of micro-meters. 
## end
#90, 29:
Fiducial electrons scattering
## end
#91, 335:
For fiducial design, it is a tradeoff to project a thin shadow and a high constrast one. To project high constrast shadows, the fiducials need to be thick enough to scatter electrons by a large angle, while it needs to be thin to make the shadow thin as well. As a result, a heavy element material, for example Tungsten, is preferred. 
## end
#92, 313:
Both the angular spread and the energy spread will affect the shadow constrast, which might be very different for different electron source. But the most fundamental requirement for the shadow formation is that the electrons scattered by fiducials should fall into pixels on the IP other than the original pixel. 
## end
#93, 262:
We studied the scattering of electrons with different energy by different diameter of Tungsten wires by GEANT4 simulations. For monoenergetic electron inputs, the angular distributions of scattered electrons are Gaussian distributions, according to simluations. 
## end
#94, 157:
The standard deviation of the distribution is a function of the input energy. The functions were found through simulations and results were showed in fig.4. 
## end
#95, 7:
%fig.4_
## end
#96, 3:
<i>
## end
#97, 144:
Fig.4. (a) shows \(\sigma\) as functions of E. Tungsten wires with diameter, D=0.050 mm, 0.127 mm, 0.200 mm, 0.400 mm and 0.800 mm were studied.
## end
#98, 303:
(b) is one of simulation results. 10 GeV electrons were scattered by a 0.127 mm Tungsten wire in this simulation. The figure shows the angular distribution of scattered electrons. The dots are simulation data, and the solid line is a Gaussian function, which is \(g(\theta)=A\ exp(-\theta^2/\sigma^2)\).
## end
#99, 4:
</i>
## end
#100, 120:
For 0.127 Tungsten wires, the standard deviation \(\sigma\) as a function of input energy can be expressed as following,
## end
#101, 5:
%[1].
## end
#102, 274:
The shadow shape was also studied by simulations. The results were showed in fig.5. From the simulation, we learned that the shadow shape was determined by the divergency, \(\sigma\), v.s. the pixel size, \(\Delta\), over the separation, \(L\), between the wire and the IP. 
## end
#103, 53:
To obtain a clear shadow on the IP, the condition is,
## end
#104, 5:
%[0].
## end
#105, 7:
%fig.5_
## end
#106, 3:
<i>
## end
#107, 330:
Fig.5. the shadow shapes of a 0.127 mm Tungsten wire were studied for different spectrums and different wire positions. It was Gaussian spectrum for all simulation. The peak energies were 4.313 GeV, 8.67 GeV, 17.55 GeV, 36.0 GeV and 75.9 GeV for (i1)-(i5), wihch were corresponding to \(\sigma\)=0.8, 0.4, 0.2, 0.1 and 0.05 mrad. 
## end
#108, 222:
The pixel size was 0.05 mm in simulations. Let's say the separation between the wire and the IP is L. Then L=500 mm, 250 mm and 125 mm for (a)'s, (b)'s and (c)'s, which corresponding to \(\Delta\)/L=0.1, 0.2 and 0.4 mrad. 
## end
#109, 4:
</i>
## end
#110, 72:
In fact, the shadow shape is different for different electron energies. 
## end
#111, 190:
For low-energy electrons, a fiducial projected a pit on the spectrum image. But for high-energy electrons, there were two peaks around the pit, which weren't there in the original spectrum. 
## end
#112, 347:
The explanation is the high-energy electrons were scattered within a small angular range. Most of electrons were still falling on the IP around their original positions. Although in the origianl position, the intensity was lower, those places around the shadow had higher intensity, because the scattered electrons added intensity to those areas. 
## end
#113, 88:
This phenomenon can be an evident of high energy electrons observation in a experiment. 
## end
#114, 16:
Experiment setup
## end
#115, 144:
In the experiments, the dipole magnet was placed 143.5 mm behind the gas cell. The magnetic field was equal to 1.48 T with 50 mm for the width. 
## end
#116, 157:
The <band> SR image plate (IP) was place 2672 mm after the magnet. The pixel size for the image plate was 50 um. The IP was scanned by XX, after every shot. 
## end
#117, 264:
Both sets of fiducials were consisted of 8 Tungsten wires with 0.127 mm for the diameter. The first set of fiducial was away from the IP by 1442 mm, which was closer to the magnet and the second set of fiducials are 934 mm from the IP, which was closer to the IP. 
## end
#118, 44:
The experiment setup is showed in the fig.3.
## end
#119, 7:
%fig.3_
## end
#120, 17:
<LWFA parameters>
## end
#121, 101:
There were many things done to increase the position measurement accuracies of different components. 
## end
#122, 207:
Two sets of fiducials were attach with the image plate holder by a stainless steel frame to increase the accuracy of position measurement. The accuracies of positions for fiducials and IP holder were XX mm. 
## end
#123, 250:
Fiducials were Tungsten wires, because the heavy element material could scatter more electrons with a small diameter shape. GEANT4 simulations were used to help us study the properties of electrons scattering, which will be discussed in the next Sec.
## end
#124, 333:
The source locations could shifted randomly because of the laser pointing drifting. The IP position could also changed, because of the small gap between the holder and the IP. Those uncertainties were unavoidable, so we proposed a Betatron shadow calibration to calibrate both of locations. It will be discussed in the next next Sec.
## end
#125, 25:
Two-screen method problem
## end
#126, 226:
The two-screen method is one of the most popular ways to measure LWFA electrons. In this method, electrons were usually deflected by a permanent dipole magnet and imaged by two screens at different locations after the magnet. 
## end
#127, 96:
In theory, any electron trajectories could be determined uniquely by three points in the space. 
## end
#128, 258:
In reality, the features on two screens might not be comparable, because of the divergency of electrons which always existed. For example, the electron beams could be a single peak image on the first screen, which it might be two peaks on the second screen. 
## end
#129, 286:
On the other hand, it is very important to find the correct correlated points on the screens to measure the spectrum of high energy electrons. A small error in the position measure would cause large errors in the spectrum measure, especially when the energy reaching \(10\ GeV\) level. 
## end
#130, 296:
For example, in the simulation, the IP2 was separated from the magnet by 800 mm and the IP1was separated by 3000 mm. The real spectrum had two peaks. The center of one was at \(E_1=10\ GeV\), and the other one was at \(E_2=3.7\ GeV\). The divergencies of the electrons were \(\sigma=3.0\ mrad\). 
## end
#131, 71:
There was two peaks on the IP1, while only one peak showed on the IP2. 
## end
#132, 7:
%fig.1_
## end
#133, 3:
<i>
## end
#134, 229:
Fig.1. (a) is the setup of a typical two-screen spectrometer. (a1) is the real spectrum of electrons. (a2) is the image on the IP2 screen. (a3) is the image on the IP1 screen. (a2) and (a3) are obtained from a GEANT4 simulation. 
## end
#135, 92:
(b) shows the intensity curves on both screens. The intensity is integrated over the Y-axis.
## end
#136, 4:
</i>
## end
#137, 197:
If we used the maximum point on the IP2 and the maximum point on the IP1 to define the trajectory, the energy of the trajectory would be \(18.56\ GeV\), while the real energy should be \(10\ GeV\).
## end
#138, 285:
As a result, we proposed a new design of spectrometer by using two sets of Tungsten fiducials with an image plate, instead of two screens. The fiducial would scatter electrons going through it and leaving a shadow on the image plate, which would provide two points on the trajectories.
## end
#139, 12:
Introduction
## end
#140, 33:
High energy electron spectrometer
## end
#142, 261:
"""
描述结构:...
+[新建阅读窗口](,描述结构)

"""

+公式结构(_凭依,_公式)->+[del](,+公式结构)...
->的(公式结构,描述结构)...

->.(+公式结构,_媒介)...
->+[code]([想],描述结构)->[想](_媒介,_公式)...
->操作([想],)...
->的(操作,名字)->+的(_公式,+名字)->[m_text](名字,+名字)...
->的(操作,LaTeX)->+的(_公式,+LaTeX)->[m_text](LaTeX,+LaTeX)





## end
#144, 692:
"""
描述结构:...
库:...
+[新建阅读窗口](,描述结构)


"""

+生成章节(_媒介,_章节)->+[del](,+生成章节)...
->的(生成章节,描述结构)->的(生成章节,库)...

->+[code]([想],描述结构)->[想](,_章节)...
->结构([想],)...
->[]{
    []=>的(结构,章节)->章节->类型(章节,)...
    =>+的(_章节,+章节)->[m_text](章节,+章节)->+是(章节,+章节)->+[del](,+是)...
    ->+[修改标题](,+章节)->[m_text](类型,+[修改标题])...
    ->[]{
        []:->上一个(结构,)->+上一个(结构,章节#0)->章节#0->+[del](,+上一个)...
            ->+[上一个](结构,+章节)->+然后(章节#0,+章节)->+的(_章节,+然后)...
            ->+[消息窗口]"!!"(,章节#0)->+[显示](,+然后),
        ->+[上一个](结构,+章节)
    }
}...

->操作([想],)...
->[]{
    []=>的(操作,_操作)->_操作(_主语,_宾语)->_主语->_宾语=>[说](,_操作)...
    ->的(库,_条目)->_条目->[eq](_条目,_操作)->是(_宾语,_节点)...
        ->+[做](_主语,_节点)->+[code](+[做],_条目)
}




## end
#146, 767:
+[设置结构](,测试)

有A, B和C

测试->的(测试,_A)->+[下一个A](测试,_A)->+下一个A(测试,_B)->+[显示](,_B)
测试->的(测试,_A)->+[下一个A](测试,_A)->+下一个A(测试,_B)->+[显示](,_A)

测试=>的(测试,_A)=>+[下一个A](测试,_A)->+下一个A(测试,_B)->+[显示](,_B)->+[del](,+下一个A)

测试=>的(测试,_A)=>+下一个A(测试,_B)->+[下一个A](测试,_A)->+[显示](,_B)->+[del](,+下一个A)


测试=>的(测试,_A)=>[]{
[]:->下一个A(测试,)->+下一个A(测试,_B)->_B->+[显示](,下一个A),
->+[下一个A](测试,_A)->+[显示](,_A)}

测试->+[下一个A](测试,C)=>的(测试,_A)=>[]{
[]:->+[下一个A](测试,_A)->+下一个A(测试,_B)->_B->+[显示](,_B),
->+[显示](,_A)}

测试->+[下一个A](测试,C)=>的(测试,_A)=>[]:
->下一个A(测试,)->+[下一个A](测试,_A)->+下一个A(测试,_B)->_B->+[显示](,_B),
->+[下一个A](测试,_A)->+[显示](,_A)


测试=>的(测试,_A)=>+[下一个A](测试,_A)...
->+下一个A(测试,_B)->+[del](,+下一个A)->[]:
->头部(测试,)->+[显示](,_A)->+[显示](,_B),
->+头部(测试,_A)


Nini, 打开结构语言Debug(文件)
测试=>的(测试,下一个A)=>+[del](,下一个A)
## end
#157, 310:
"""
P代码:...
+[修改标题]"收集公式"(,收集图例)
+[删除结构](,收集公式)->+[del](,收集公式)

"""
+描述结构(_媒介,_公式)->+操作(+描述结构,)...
->的(描述结构,P代码)...

->+的(+操作,+名字)->+的(+操作,+LaTeX)...
->+[s]"name_formula"([python],_公式)->+[code]([python],P代码)...
->[python](Python,+名字)...

->的(_媒介,_表达式)->[标题](_表达式,)->[==](+名字,[标题])...
->[m_text](_表达式,+LaTeX)



## end
#161, 817:
"""
记住"Python"
测试:...
+[P函数](,P代码)
name='%fig.1_*[t]'
print(re.split('\*?\[[bt]\]',name),name)
fig_info=''
a=re.match('(\*?)(\[[bt]\])?',fig_info)
print(fig_info,a.group(1),a.group(2))
print(fig_info,fig_a,fig_type,fig_pos)

if fig_a.group(2)=='[t]':
    fig_pos='t'
elif fig_a.group(2)=='[b]':
    fig_pos='b'
else:
    fig_pos='b'


"""
import re

state=True
name0=name_fig[1:]
name=re.split('\*?\[[bt]\]',name0)[0]
if name[-1]=="*":
    name=name[0:-1]
fig_info=name0[len(name):]

fig_a=re.match('(\*?)(\[[bt]\])?',fig_info)
if fig_a==None:
    fig_type='normal'
    fig_pos='[b]'
else:
    if fig_a.group(1)=='*':
        fig_type='wide'
    else:
        fig_type='normal'
    
    if fig_a.group(2)=='[t]':
        fig_pos='t'
    elif fig_a.group(2)=='[b]':
        fig_pos='b'
    else:
        fig_pos='b'



## end
#163, 108:
"""
P代码:...

"""

+收集信息(,_图片)->.(+收集信息,操作)...
->的(收集信息,P代码)...

->+[code]([python],P代码)->[python](Python,)


## end
#167, 609:
"""
收集图例:...
收集信息:...
将条目"收集图例"复制为条目"收集信息"
print(text_fig)
+[新建阅读窗口](,收集信息)

"""
+描述结构(,_图片)->+操作(+描述结构,)...
->的(描述结构,收集图例)...

->+的(+操作,+名字)->+的(+操作,+图例)...
->+的(+操作,+类型)->+的(+操作,+位置)...

->+[.]"name_fig"([python],_图片)->[python]"text_fig=''
state=True"(Python,)...

->+[.]([想],+操作)->+[code]([想],收集信息)->[想](,_图片)...
->+[.]([想]#2,+操作)->+[code]([想]#2,收集图例)->[想]#2(,_图片)...

->+[o]"name1"([python]#2,+名字)->+[o]"text_fig1"([python]#2,+图例)...
->+[o]"fig_type1"([python]#2,+类型)->+[o]"fig_pos1"([python]#2,+位置)...
->[python]#2"name1=name
text_fig1=text_fig
fig_pos1=fig_pos
fig_type1=fig_type
state=True"(Python,)



## end
#170, 1246:
"""
描述结构:...
库:...
P代码:...
+[新建阅读窗口](,描述结构)

"""

+图片结构(_凭依,_图片)->+[del](,+图片结构)...
->的(图片结构,描述结构)->的(图片结构,库)...

->.(+图片结构,_媒介)...
->+[code]([想],描述结构)->[想](,_图片)...
->操作([想],)...
    ->的(操作,名字)->+的(_图片,+名字)->[m_text](名字,+名字)...
    ->的(操作,图例)->+的(_图片,+图例)->[m_text](图例,+图例)...
    ->的(操作,类型)->+的(_图片,+类型)->[m_text](类型,+类型)...
    ->的(操作,位置)->+的(_图片,+位置)->[m_text](位置,+位置)...

->的(_媒介,_图片节点)->[标题](_图片节点,)->[==]([标题],名字)...
->[]{
    []:->图片(_图片节点,)...
        ->+的(_图片,+源地址)->[m_text](_图片节点,+源地址)...
        ->+的(_图片,+目标地址),

    ->表格(_图片节点,)->+[修改标题]"表格"(,_图片)...
        ->+的(_图片,+内容#1)->[m_text](_图片节点,+内容#1),
    ->程序(_图片节点,)->+[修改标题]"程序"(,_图片)...
        ->+的(_图片,+内容#1b)->[m_text](_图片节点,+内容#1b),

    ->3D(_图片节点,)->+的(_图片,+内容)->+的(_图片,+3D)->[]{
        []:->的(_图片节点,H代码)->H代码(,)...
            ->+[三维场景转ThreeJS_模块](_图片节点,H代码)...
            ->+[修改内容](H代码,+内容),
        ->+[修改内容](_图片节点,+内容)
    },
    ->SVG(_图片节点,)->+的(_图片,+内容#2)->+的(_图片,+SVG)->[]{
        []:->的(_图片节点,H代码)->H代码(,)...
            ->+[PPT场景转H代码](_图片节点,H代码)...
            ->+[修改内容](H代码,+内容#2),
        ->+[修改内容](_图片节点,+内容#2)
    },
    ->[]
}...

->[]{
    []:->的(操作,结尾)->结尾(,_结尾)->然后(,_结尾)->+[左连](然后,_图片),
    ->[]
}...
->[]{
    []=>的(操作,删除)->删除(,_删除)=>+[del](,_删除)
}



## end
#174, 47:
"""


"""

state=True
ans=name_formula[1:]





## end
#176, 3:
x=1
## end
#178, 7:
x=a+b+y
## end
#179, 3:
x=1
## end
#182, 7:
x=a+b+y
## end
#186, 14:
E=m_{e}\ c^{2}
## end
#188, 37:
p=\sqrt{E^{2}/c^{2}-m_{e}^{2}\ c^{2}}
## end
#190, 18:
f(x)=a\ x^{2}+b\ x
## end
#192, 12:
P\ V=n\ R\ T
## end
#194, 19:
a\ _{i+1}=a\ _{i}+2
## end
#195, 9:
E=m_e*c^2
## end
#198, 26:
p=\sqrt{E^2/c^2-m_e^2*c^2}
## end
#201, 14:
f(x)=a*x^2+b*x
## end
#204, 9:
P*V=n*R*T
## end
#207, 13:
a[i+1]=a[i]+2
## end
#211, 64:


PR模板:...
PR模板_简化:...
引用模板:...
引用模板_简化:...
+[新建阅读窗口](,引用模板)




## end
#213, 32041:
table
% ****** Start of file apssamp.tex ******
%\ref
%   This file is part of the APS files in the REVTeX 4.2 distribution.
%   Version 4.2a of REVTeX, December 2014
%
%   Copyright (c) 2014 The American Physical Society.
%
%   See the REVTeX 4 README file for restrictions and more information.
%
% TeX'ing this file requires that you have AMS-LaTeX 2.0 installed
% as well as the rest of the prerequisites for REVTeX 4.2
%
% See the REVTeX 4 README file
% It also requires running BibTeX. The commands are as follows:
%
%  1)  latex apssamp.tex
%  2)  bibtex apssamp
%  3)  latex apssamp.tex
%  4)  latex apssamp.tex
%
\documentclass[%
 reprint,
%superscriptaddress,
%groupedaddress,
%unsortedaddress,
%runinaddress,
%frontmatterverbose, 
%preprint,
%preprintnumbers,
%nofootinbib,
%nobibnotes,
%bibnotes,
 amsmath,amssymb,
 aps,
%pra,
%prb,
%rmp,
%prstab,
%prstper,
%floatfix,
]{revtex4-2}

\usepackage{graphicx}% Include figure files
\usepackage{dcolumn}% Align table columns on decimal point
\usepackage{bm}% bold math
%\usepackage{hyperref}% add hypertext capabilities
%\usepackage[mathlines]{lineno}% Enable numbering of text and display math
%\linenumbers\relax % Commence numbering lines

%\usepackage[showframe,%Uncomment any one of the following lines to test 
%%scale=0.7, marginratio={1:1, 2:3}, ignoreall,% default settings
%%text={7in,10in},centering,
%%margin=1.5in,
%%total={6.5in,8.75in}, top=1.2in, left=0.9in, includefoot,
%%height=10in,a5paper,hmargin={3cm,0.8in},
%]{geometry}

\begin{document}

\preprint{APS/123-QED}

\title{Manuscript Title:\\with Forced Linebreak}% Force line breaks with \\
\thanks{A footnote to the article title}%

\author{Ann Author}
 \altaffiliation[Also at ]{Physics Department, XYZ University.}%Lines break automatically or can be forced with \\
\author{Second Author}%
 \email{Second.Author@institution.edu}
\affiliation{%
 Authors' institution and/or address\\
 This line break forced with \textbackslash\textbackslash
}%

\collaboration{MUSO Collaboration}%\noaffiliation

\author{Charlie Author}
 \homepage{http://www.Second.institution.edu/~Charlie.Author}
\affiliation{
 Second institution and/or address\\
 This line break forced% with \\
}%
\affiliation{
 Third institution, the second for Charlie Author
}%
\author{Delta Author}
\affiliation{%
 Authors' institution and/or address\\
 This line break forced with \textbackslash\textbackslash
}%

\collaboration{CLEO Collaboration}%\noaffiliation

\date{\today}% It is always \today, today,
             %  but any date may be explicitly specified

\begin{abstract}
An article usually includes an abstract, a concise summary of the work
covered at length in the main body of the article. 
\begin{description}
\item[Usage]
Secondary publications and information retrieval purposes.
\item[Structure]
You may use the \texttt{description} environment to structure your abstract;
use the optional argument of the \verb+\item+ command to give the category of each item. 
\end{description}
\end{abstract}

%\keywords{Suggested keywords}%Use showkeys class option if keyword
                              %display desired
\maketitle

%\tableofcontents

\section{\label{sec:level1}First-level heading:\protect\\ The line
break was forced \lowercase{via} \textbackslash\textbackslash}

This sample document demonstrates proper use of REV\TeX~4.2 (and
\LaTeXe) in mansucripts prepared for submission to APS
journals. Further information can be found in the REV\TeX~4.2
documentation included in the distribution or available at
\url{http://journals.aps.org/revtex/}.

When commands are referred to in this example file, they are always
shown with their required arguments, using normal \TeX{} format. In
this format, \verb+#1+, \verb+#2+, etc. stand for required
author-supplied arguments to commands. For example, in
\verb+\section{#1}+ the \verb+#1+ stands for the title text of the
author's section heading, and in \verb+\title{#1}+ the \verb+#1+
stands for the title text of the paper.

Line breaks in section headings at all levels can be introduced using
\textbackslash\textbackslash. A blank input line tells \TeX\ that the
paragraph has ended. Note that top-level section headings are
automatically uppercased. If a specific letter or word should appear in
lowercase instead, you must escape it using \verb+\lowercase{#1}+ as
in the word ``via'' above.

\subsection{\label{sec:level2}Second-level heading: Formatting}

This file may be formatted in either the \texttt{preprint} or
\texttt{reprint} style. \texttt{reprint} format mimics final journal output. 
Either format may be used for submission purposes. \texttt{letter} sized paper should
be used when submitting to APS journals.

\subsubsection{Wide text (A level-3 head)}
The \texttt{widetext} environment will make the text the width of the
full page, as on page~\pageref{eq:wideeq}. (Note the use the
\verb+\pageref{#1}+ command to refer to the page number.) 
\paragraph{Note (Fourth-level head is run in)}
The width-changing commands only take effect in two-column formatting. 
There is no effect if text is in a single column.

\subsection{\label{sec:citeref}Citations and References}
A citation in text uses the command \verb+\cite{#1}+ or
\verb+\onlinecite{#1}+ and refers to an entry in the bibliography. 
An entry in the bibliography is a reference to another document.

\subsubsection{Citations}
Because REV\TeX\ uses the \verb+natbib+ package of Patrick Daly, 
the entire repertoire of commands in that package are available for your document;
see the \verb+natbib+ documentation for further details. Please note that
REV\TeX\ requires version 8.31a or later of \verb+natbib+.

\paragraph{Syntax}
The argument of \verb+\cite+ may be a single \emph{key}, 
or may consist of a comma-separated list of keys.
The citation \emph{key} may contain 
letters, numbers, the dash (-) character, or the period (.) character. 
New with natbib 8.3 is an extension to the syntax that allows for 
a star (*) form and two optional arguments on the citation key itself.
The syntax of the \verb+\cite+ command is thus (informally stated)
\begin{quotation}\flushleft\leftskip1em
\verb+\cite+ \verb+{+ \emph{key} \verb+}+, or\\
\verb+\cite+ \verb+{+ \emph{optarg+key} \verb+}+, or\\
\verb+\cite+ \verb+{+ \emph{optarg+key} \verb+,+ \emph{optarg+key}\ldots \verb+}+,
\end{quotation}\noindent
where \emph{optarg+key} signifies 
\begin{quotation}\flushleft\leftskip1em
\emph{key}, or\\
\texttt{*}\emph{key}, or\\
\texttt{[}\emph{pre}\texttt{]}\emph{key}, or\\
\texttt{[}\emph{pre}\texttt{]}\texttt{[}\emph{post}\texttt{]}\emph{key}, or even\\
\texttt{*}\texttt{[}\emph{pre}\texttt{]}\texttt{[}\emph{post}\texttt{]}\emph{key}.
\end{quotation}\noindent
where \emph{pre} and \emph{post} is whatever text you wish to place 
at the beginning and end, respectively, of the bibliographic reference
(see Ref.~[\onlinecite{witten2001}] and the two under Ref.~[\onlinecite{feyn54}]).
(Keep in mind that no automatic space or punctuation is applied.)
It is highly recommended that you put the entire \emph{pre} or \emph{post} portion 
within its own set of braces, for example: 
\verb+\cite+ \verb+{+ \texttt{[} \verb+{+\emph{text}\verb+}+\texttt{]}\emph{key}\verb+}+.
The extra set of braces will keep \LaTeX\ out of trouble if your \emph{text} contains the comma (,) character.

The star (*) modifier to the \emph{key} signifies that the reference is to be 
merged with the previous reference into a single bibliographic entry, 
a common idiom in APS and AIP articles (see below, Ref.~[\onlinecite{epr}]). 
When references are merged in this way, they are separated by a semicolon instead of 
the period (full stop) that would otherwise appear.

\paragraph{Eliding repeated information}
When a reference is merged, some of its fields may be elided: for example, 
when the author matches that of the previous reference, it is omitted. 
If both author and journal match, both are omitted.
If the journal matches, but the author does not, the journal is replaced by \emph{ibid.},
as exemplified by Ref.~[\onlinecite{epr}]. 
These rules embody common editorial practice in APS and AIP journals and will only
be in effect if the markup features of the APS and AIP Bib\TeX\ styles is employed.

\paragraph{The options of the cite command itself}
Please note that optional arguments to the \emph{key} change the reference in the bibliography, 
not the citation in the body of the document. 
For the latter, use the optional arguments of the \verb+\cite+ command itself:
\verb+\cite+ \texttt{*}\allowbreak
\texttt{[}\emph{pre-cite}\texttt{]}\allowbreak
\texttt{[}\emph{post-cite}\texttt{]}\allowbreak
\verb+{+\emph{key-list}\verb+}+.

\subsubsection{Example citations}
By default, citations are numerical\cite{Beutler1994}.
Author-year citations are used when the journal is RMP. 
To give a textual citation, use \verb+\onlinecite{#1}+: 
Refs.~\onlinecite{[][{, and references therein}]witten2001,Bire82}. 
By default, the \texttt{natbib} package automatically sorts your citations into numerical order and ``compresses'' runs of three or more consecutive numerical citations.
REV\TeX\ provides the ability to automatically change the punctuation when switching between journal styles that provide citations in square brackets and those that use a superscript style instead. This is done through the \texttt{citeautoscript} option. For instance, the journal style \texttt{prb} automatically invokes this option because \textit{Physical 
Review B} uses superscript-style citations. The effect is to move the punctuation, which normally comes after a citation in square brackets, to its proper position before the superscript. 
To illustrate, we cite several together 
\cite{[See the explanation of time travel in ]feyn54,*[The classical relativistic treatment of ][ is a relative classic]epr,witten2001,Berman1983,Davies1998,Bire82}, 
and once again in different order (Refs.~\cite{epr,feyn54,Bire82,Berman1983,witten2001,Davies1998}). 
Note that the citations were both compressed and sorted. Futhermore, running this sample file under the \texttt{prb} option will move the punctuation to the correct place.

When the \verb+prb+ class option is used, the \verb+\cite{#1}+ command
displays the reference's number as a superscript rather than in
square brackets. Note that the location of the \verb+\cite{#1}+
command should be adjusted for the reference style: the superscript
references in \verb+prb+ style must appear after punctuation;
otherwise the reference must appear before any punctuation. This
sample was written for the regular (non-\texttt{prb}) citation style.
The command \verb+\onlinecite{#1}+ in the \texttt{prb} style also
displays the reference on the baseline.

\subsubsection{References}
A reference in the bibliography is specified by a \verb+\bibitem{#1}+ command
with the same argument as the \verb+\cite{#1}+ command.
\verb+\bibitem{#1}+ commands may be crafted by hand or, preferably,
generated by Bib\TeX. 
REV\TeX~4.2 includes Bib\TeX\ style files
\verb+apsrev4-2.bst+, \verb+apsrmp4-2.bst+ appropriate for
\textit{Physical Review} and \textit{Reviews of Modern Physics},
respectively.

\subsubsection{Example references}
This sample file employs the \verb+\bibliography+ command, 
which formats the \texttt{\jobname .bbl} file
and specifies which bibliographic databases are to be used by Bib\TeX\ 
(one of these should be by arXiv convention \texttt{\jobname .bib}).
Running Bib\TeX\ (via \texttt{bibtex \jobname}) 
after the first pass of \LaTeX\ produces the file
\texttt{\jobname .bbl} which contains the automatically formatted
\verb+\bibitem+ commands (including extra markup information via
\verb+\bibinfo+ and \verb+\bibfield+ commands). 
If not using Bib\TeX, you will have to create the \verb+thebibiliography+ environment 
and its \verb+\bibitem+ commands by hand.

Numerous examples of the use of the APS bibliographic entry types appear in the bibliography of this sample document.
You can refer to the \texttt{\jobname .bib} file, 
and compare its information to the formatted bibliography itself.

\subsection{Footnotes}%
Footnotes, produced using the \verb+\footnote{#1}+ command, 
usually integrated into the bibliography alongside the other entries.
Numerical citation styles do this%
%\footnote{Automatically placing footnotes into the bibliography requires using BibTeX to compile the bibliography.};
author-year citation styles place the footnote at the bottom of the text column.
Note: due to the method used to place footnotes in the bibliography, 
\emph{you must re-run Bib\TeX\ every time you change any of your document's footnotes}. 

\section{Math and Equations}
Inline math may be typeset using the \verb+$+ delimiters. Bold math
symbols may be achieved using the \verb+bm+ package and the
\verb+\bm{#1}+ command it supplies. For instance, a bold $\alpha$ can
be typeset as \verb+$\bm{\alpha}$+ giving $\bm{\alpha}$. Fraktur and
Blackboard (or open face or double struck) characters should be
typeset using the \verb+\mathfrak{#1}+ and \verb+\mathbb{#1}+ commands
respectively. Both are supplied by the \texttt{amssymb} package. For
example, \verb+$\mathbb{R}$+ gives $\mathbb{R}$ and
\verb+$\mathfrak{G}$+ gives $\mathfrak{G}$

In \LaTeX\ there are many different ways to display equations, and a
few preferred ways are noted below. Displayed math will center by
default. Use the class option \verb+fleqn+ to flush equations left.

Below we have numbered single-line equations; this is the most common
type of equation in \textit{Physical Review}:
\begin{eqnarray}
\chi_+(p)\alt{\bf [}2|{\bf p}|(|{\bf p}|+p_z){\bf ]}^{-1/2}
\left(
\begin{array}{c}
|{\bf p}|+p_z\\
px+ip_y
\end{array}\right)\;,
\\
\left\{%
 \openone234567890abc123\alpha\beta\gamma\delta1234556\alpha\beta
 \frac{1\sum^{a}_{b}}{A^2}%
\right\}%
\label{eq:one}.
\end{eqnarray}
Note the open one in Eq.~(\ref{eq:one}).

Not all numbered equations will fit within a narrow column this
way. The equation number will move down automatically if it cannot fit
on the same line with a one-line equation:
\begin{equation}
\left\{
 ab12345678abc123456abcdef\alpha\beta\gamma\delta1234556\alpha\beta
 \frac{1\sum^{a}_{b}}{A^2}%
\right\}.
\end{equation}

When the \verb+\label{#1}+ command is used [cf. input for
Eq.~(\ref{eq:one})], the equation can be referred to in text without
knowing the equation number that \TeX\ will assign to it. Just
use \verb+\ref{#1}+, where \verb+#1+ is the same name that used in
the \verb+\label{#1}+ command.

Unnumbered single-line equations can be typeset
using the \verb+\[+, \verb+\]+ format:
\[g^+g^+ \rightarrow g^+g^+g^+g^+ \dots ~,~~q^+q^+\rightarrow
q^+g^+g^+ \dots ~. \]


\subsection{Multiline equations}

Multiline equations are obtained by using the \verb+eqnarray+
environment.  Use the \verb+\nonumber+ command at the end of each line
to avoid assigning a number:
\begin{eqnarray}
{\cal M}=&&ig_Z^2(4E_1E_2)^{1/2}(l_i^2)^{-1}
\delta_{\sigma_1,-\sigma_2}
(g_{\sigma_2}^e)^2\chi_{-\sigma_2}(p_2)\nonumber\\
&&\times
[\epsilon_jl_i\epsilon_i]_{\sigma_1}\chi_{\sigma_1}(p_1),
\end{eqnarray}
\begin{eqnarray}
\sum \vert M^{\text{viol}}_g \vert ^2&=&g^{2n-4}_S(Q^2)~N^{n-2}
        (N^2-1)\nonumber \\
 & &\times \left( \sum_{i<j}\right)
  \sum_{\text{perm}}
 \frac{1}{S_{12}}
 \frac{1}{S_{12}}
 \sum_\tau c^f_\tau~.
\end{eqnarray}
\textbf{Note:} Do not use \verb+\label{#1}+ on a line of a multiline
equation if \verb+\nonumber+ is also used on that line. Incorrect
cross-referencing will result. Notice the use \verb+\text{#1}+ for
using a Roman font within a math environment.

To set a multiline equation without \emph{any} equation
numbers, use the \verb+\begin{eqnarray*}+,
\verb+\end{eqnarray*}+ format:
\begin{eqnarray*}
\sum \vert M^{\text{viol}}_g \vert ^2&=&g^{2n-4}_S(Q^2)~N^{n-2}
        (N^2-1)\\
 & &\times \left( \sum_{i<j}\right)
 \left(
  \sum_{\text{perm}}\frac{1}{S_{12}S_{23}S_{n1}}
 \right)
 \frac{1}{S_{12}}~.
\end{eqnarray*}

To obtain numbers not normally produced by the automatic numbering,
use the \verb+\tag{#1}+ command, where \verb+#1+ is the desired
equation number. For example, to get an equation number of
(\ref{eq:mynum}),
\begin{equation}
g^+g^+ \rightarrow g^+g^+g^+g^+ \dots ~,~~q^+q^+\rightarrow
q^+g^+g^+ \dots ~. \tag{2.6$'$}\label{eq:mynum}
\end{equation}

\paragraph{A few notes on \texttt{tag}s} 
\verb+\tag{#1}+ requires the \texttt{amsmath} package. 
Place the \verb+\tag{#1}+ command before the \verb+\label{#1}+, if any. 
The numbering produced by \verb+\tag{#1}+ \textit{does not affect} 
the automatic numbering in REV\TeX; 
therefore, the number must be known ahead of time, 
and it must be manually adjusted if other equations are added. 
\verb+\tag{#1}+ works with both single-line and multiline equations. 
\verb+\tag{#1}+ should only be used in exceptional cases---%
do not use it to number many equations in your paper. 
Please note that this feature of the \texttt{amsmath} package
is \emph{not} compatible with the \texttt{hyperref} (6.77u) package.

Enclosing display math within
\verb+\begin{subequations}+ and \verb+\end{subequations}+ will produce
a set of equations that are labeled with letters, as shown in
Eqs.~(\ref{subeq:1}) and (\ref{subeq:2}) below.
You may include any number of single-line and multiline equations,
although it is probably not a good idea to follow one display math
directly after another.
\begin{subequations}
\label{eq:whole}
\begin{eqnarray}
{\cal M}=&&ig_Z^2(4E_1E_2)^{1/2}(l_i^2)^{-1}
(g_{\sigma_2}^e)^2\chi_{-\sigma_2}(p_2)\nonumber\\
&&\times
[\epsilon_i]_{\sigma_1}\chi_{\sigma_1}(p_1).\label{subeq:2}
\end{eqnarray}
\begin{equation}
\left\{
 abc123456abcdef\alpha\beta\gamma\delta1234556\alpha\beta
 \frac{1\sum^{a}_{b}}{A^2}
\right\},\label{subeq:1}
\end{equation}
\end{subequations}
Giving a \verb+\label{#1}+ command directly after the \verb+\begin{subequations}+, 
allows you to reference all the equations in the \texttt{subequations} environment. 
For example, the equations in the preceding subequations environment were
Eqs.~(\ref{eq:whole}).

\subsubsection{Wide equations}
The equation that follows is set in a wide format, i.e., it spans the full page. 
The wide format is reserved for long equations
that cannot easily be set in a single column:
\begin{widetext}
\begin{equation}
{\cal R}^{(\text{d})}=
 g_{\sigma_2}^e
 \left(
   \frac{[\Gamma^Z(3,21)]_{\sigma_1}}{Q_{12}^2-M_W^2}
  +\frac{[\Gamma^Z(13,2)]_{\sigma_1}}{Q_{13}^2-M_W^2}
 \right)
 + x_WQ_e
 \left(
   \frac{[\Gamma^\gamma(3,21)]_{\sigma_1}}{Q_{12}^2-M_W^2}
  +\frac{[\Gamma^\gamma(13,2)]_{\sigma_1}}{Q_{13}^2-M_W^2}
 \right)\;. 
 \label{eq:wideeq}
\end{equation}
\end{widetext}
This is typed to show how the output appears in wide format.
(Incidentally, since there is no blank line between the \texttt{equation} environment above 
and the start of this paragraph, this paragraph is not indented.)

\section{Cross-referencing}
REV\TeX{} will automatically number such things as
sections, footnotes, equations, figure captions, and table captions. 
In order to reference them in text, use the
\verb+\label{#1}+ and \verb+\ref{#1}+ commands. 
To reference a particular page, use the \verb+\pageref{#1}+ command.

The \verb+\label{#1}+ should appear 
within the section heading, 
within the footnote text, 
within the equation, or 
within the table or figure caption. 
The \verb+\ref{#1}+ command
is used in text at the point where the reference is to be displayed.  
Some examples: Section~\ref{sec:level1} on page~\pageref{sec:level1},
Table~\ref{tab:table1},%
\begin{table}[b]%The best place to locate the table environment is directly after its first reference in text
\caption{\label{tab:table1}%
A table that fits into a single column of a two-column layout. 
Note that REV\TeX~4 adjusts the intercolumn spacing so that the table fills the
entire width of the column. Table captions are numbered
automatically. 
This table illustrates left-, center-, decimal- and right-aligned columns,
along with the use of the \texttt{ruledtabular} environment which sets the 
Scotch (double) rules above and below the alignment, per APS style.
}
\begin{ruledtabular}
\begin{tabular}{lcdr}
\textrm{Left\footnote{Note a.}}&
\textrm{Centered\footnote{Note b.}}&
\multicolumn{1}{c}{\textrm{Decimal}}&
\textrm{Right}\\
\colrule
1 & 2 & 3.001 & 4\\
10 & 20 & 30 & 40\\
100 & 200 & 300.0 & 400\\
\end{tabular}
\end{ruledtabular}
\end{table}
and Fig.~\ref{fig:epsart}.%
\begin{figure}[b]
\includegraphics{fig_1}% Here is how to import EPS art
\caption{\label{fig:epsart} A figure caption. The figure captions are
automatically numbered.}
\end{figure}

\section{Floats: Figures, Tables, Videos, etc.}
Figures and tables are usually allowed to ``float'', which means that their
placement is determined by \LaTeX, while the document is being typeset. 

Use the \texttt{figure} environment for a figure, the \texttt{table} environment for a table.
In each case, use the \verb+\caption+ command within to give the text of the
figure or table caption along with the \verb+\label+ command to provide
a key for referring to this figure or table.
The typical content of a figure is an image of some kind; 
that of a table is an alignment.%
\begin{figure*}
\includegraphics{fig_2}% Here is how to import EPS art
\caption{\label{fig:wide}Use the figure* environment to get a wide
figure that spans the page in \texttt{twocolumn} formatting.}
\end{figure*}
\begin{table*}
\caption{\label{tab:table3}This is a wide table that spans the full page
width in a two-column layout. It is formatted using the
\texttt{table*} environment. It also demonstates the use of
\textbackslash\texttt{multicolumn} in rows with entries that span
more than one column.}
\begin{ruledtabular}
\begin{tabular}{ccccc}
 &\multicolumn{2}{c}{$D_{4h}^1$}&\multicolumn{2}{c}{$D_{4h}^5$}\\
 Ion&1st alternative&2nd alternative&lst alternative
&2nd alternative\\ \hline
 K&$(2e)+(2f)$&$(4i)$ &$(2c)+(2d)$&$(4f)$ \\
 Mn&$(2g)$\footnote{The $z$ parameter of these positions is $z\sim\frac{1}{4}$.}
 &$(a)+(b)+(c)+(d)$&$(4e)$&$(2a)+(2b)$\\
 Cl&$(a)+(b)+(c)+(d)$&$(2g)$\footnotemark[1]
 &$(4e)^{\text{a}}$\\
 He&$(8r)^{\text{a}}$&$(4j)^{\text{a}}$&$(4g)^{\text{a}}$\\
 Ag& &$(4k)^{\text{a}}$& &$(4h)^{\text{a}}$\\
\end{tabular}
\end{ruledtabular}
\end{table*}

Insert an image using either the \texttt{graphics} or
\texttt{graphix} packages, which define the \verb+\includegraphics{#1}+ command.
(The two packages differ in respect of the optional arguments 
used to specify the orientation, scaling, and translation of the image.) 
To create an alignment, use the \texttt{tabular} environment. 

The best place to locate the \texttt{figure} or \texttt{table} environment
is immediately following its first reference in text; this sample document
illustrates this practice for Fig.~\ref{fig:epsart}, which
shows a figure that is small enough to fit in a single column. 

In exceptional cases, you will need to move the float earlier in the document, as was done
with Table~\ref{tab:table3}: \LaTeX's float placement algorithms need to know
about a full-page-width float earlier. 

Fig.~\ref{fig:wide}
has content that is too wide for a single column,
so the \texttt{figure*} environment has been used.%
\begin{table}[b]
\caption{\label{tab:table4}%
Numbers in columns Three--Five are aligned with the ``d'' column specifier 
(requires the \texttt{dcolumn} package). 
Non-numeric entries (those entries without a ``.'') in a ``d'' column are aligned on the decimal point. 
Use the ``D'' specifier for more complex layouts. }
\begin{ruledtabular}
\begin{tabular}{ccddd}
One&Two&
\multicolumn{1}{c}{\textrm{Three}}&
\multicolumn{1}{c}{\textrm{Four}}&
\multicolumn{1}{c}{\textrm{Five}}\\
%\mbox{Three}&\mbox{Four}&\mbox{Five}\\
\hline
one&two&\mbox{three}&\mbox{four}&\mbox{five}\\
He&2& 2.77234 & 45672. & 0.69 \\
C\footnote{Some tables require footnotes.}
  &C\footnote{Some tables need more than one footnote.}
  & 12537.64 & 37.66345 & 86.37 \\
\end{tabular}
\end{ruledtabular}
\end{table}

The content of a table is typically a \texttt{tabular} environment, 
giving rows of type in aligned columns. 
Column entries separated by \verb+&+'s, and 
each row ends with \textbackslash\textbackslash. 
The required argument for the \texttt{tabular} environment
specifies how data are aligned in the columns. 
For instance, entries may be centered, left-justified, right-justified, aligned on a decimal
point. 
Extra column-spacing may be be specified as well, 
although REV\TeX~4 sets this spacing so that the columns fill the width of the
table. Horizontal rules are typeset using the \verb+\hline+
command. The doubled (or Scotch) rules that appear at the top and
bottom of a table can be achieved enclosing the \texttt{tabular}
environment within a \texttt{ruledtabular} environment. Rows whose
columns span multiple columns can be typeset using the
\verb+\multicolumn{#1}{#2}{#3}+ command (for example, see the first
row of Table~\ref{tab:table3}).%

Tables~\ref{tab:table1}, \ref{tab:table3}, \ref{tab:table4}, and \ref{tab:table2}%
\begin{table}[b]
\caption{\label{tab:table2}
A table with numerous columns that still fits into a single column. 
Here, several entries share the same footnote. 
Inspect the \LaTeX\ input for this table to see exactly how it is done.}
\begin{ruledtabular}
\begin{tabular}{cccccccc}
 &$r_c$ (\AA)&$r_0$ (\AA)&$\kappa r_0$&
 &$r_c$ (\AA) &$r_0$ (\AA)&$\kappa r_0$\\
\hline
Cu& 0.800 & 14.10 & 2.550 &Sn\footnotemark[1]
& 0.680 & 1.870 & 3.700 \\
Ag& 0.990 & 15.90 & 2.710 &Pb\footnotemark[2]
& 0.450 & 1.930 & 3.760 \\
Au& 1.150 & 15.90 & 2.710 &Ca\footnotemark[3]
& 0.750 & 2.170 & 3.560 \\
Mg& 0.490 & 17.60 & 3.200 &Sr\footnotemark[4]
& 0.900 & 2.370 & 3.720 \\
Zn& 0.300 & 15.20 & 2.970 &Li\footnotemark[2]
& 0.380 & 1.730 & 2.830 \\
Cd& 0.530 & 17.10 & 3.160 &Na\footnotemark[5]
& 0.760 & 2.110 & 3.120 \\
Hg& 0.550 & 17.80 & 3.220 &K\footnotemark[5]
&  1.120 & 2.620 & 3.480 \\
Al& 0.230 & 15.80 & 3.240 &Rb\footnotemark[3]
& 1.330 & 2.800 & 3.590 \\
Ga& 0.310 & 16.70 & 3.330 &Cs\footnotemark[4]
& 1.420 & 3.030 & 3.740 \\
In& 0.460 & 18.40 & 3.500 &Ba\footnotemark[5]
& 0.960 & 2.460 & 3.780 \\
Tl& 0.480 & 18.90 & 3.550 & & & & \\
\end{tabular}
\end{ruledtabular}
\footnotetext[1]{Here's the first, from Ref.~\onlinecite{feyn54}.}
\footnotetext[2]{Here's the second.}
\footnotetext[3]{Here's the third.}
\footnotetext[4]{Here's the fourth.}
\footnotetext[5]{And etc.}
\end{table}
show various effects.
A table that fits in a single column employs the \texttt{table}
environment. 
Table~\ref{tab:table3} is a wide table, set with the \texttt{table*} environment. 
Long tables may need to break across pages. 
The most straightforward way to accomplish this is to specify
the \verb+[H]+ float placement on the \texttt{table} or
\texttt{table*} environment. 
However, the \LaTeXe\ package \texttt{longtable} allows headers and footers to be specified for each page of the table. 
A simple example of the use of \texttt{longtable} can be found
in the file \texttt{summary.tex} that is included with the REV\TeX~4
distribution.

There are two methods for setting footnotes within a table (these
footnotes will be displayed directly below the table rather than at
the bottom of the page or in the bibliography). The easiest
and preferred method is just to use the \verb+\footnote{#1}+
command. This will automatically enumerate the footnotes with
lowercase roman letters. However, it is sometimes necessary to have
multiple entries in the table share the same footnote. In this case,
there is no choice but to manually create the footnotes using
\verb+\footnotemark[#1]+ and \verb+\footnotetext[#1]{#2}+.
\texttt{\#1} is a numeric value. Each time the same value for
\texttt{\#1} is used, the same mark is produced in the table. The
\verb+\footnotetext[#1]{#2}+ commands are placed after the \texttt{tabular}
environment. Examine the \LaTeX\ source and output for
Tables~\ref{tab:table1} and \ref{tab:table2}
for examples.

Video~\ref{vid:PRSTPER.4.010101} 
illustrates several features new with REV\TeX4.2,
starting with the \texttt{video} environment, which is in the same category with
\texttt{figure} and \texttt{table}.%
\begin{video}
\href{http://prst-per.aps.org/multimedia/PRSTPER/v4/i1/e010101/e010101_vid1a.mpg}{\includegraphics{vid_1a}}%
 \quad
\href{http://prst-per.aps.org/multimedia/PRSTPER/v4/i1/e010101/e010101_vid1b.mpg}{\includegraphics{vid_1b}}
 \setfloatlink{http://link.aps.org/multimedia/PRSTPER/v4/i1/e010101}%
 \caption{\label{vid:PRSTPER.4.010101}%
  Students explain their initial idea about Newton's third law to a teaching assistant. 
  Clip (a): same force.
  Clip (b): move backwards.
 }%
\end{video}
The \verb+\setfloatlink+ command causes the title of the video to be a hyperlink to the
indicated URL; it may be used with any environment that takes the \verb+\caption+
command.
The \verb+\href+ command has the same significance as it does in the context of
the \texttt{hyperref} package: the second argument is a piece of text to be 
typeset in your document; the first is its hyperlink, a URL.

\textit{Physical Review} style requires that the initial citation of
figures or tables be in numerical order in text, so don't cite
Fig.~\ref{fig:wide} until Fig.~\ref{fig:epsart} has been cited.

\begin{acknowledgments}
We wish to acknowledge the support of the author community in using
REV\TeX{}, offering suggestions and encouragement, testing new versions,
\dots.
\end{acknowledgments}

\appendix

\section{Appendixes}

To start the appendixes, use the \verb+\appendix+ command.
This signals that all following section commands refer to appendixes
instead of regular sections. Therefore, the \verb+\appendix+ command
should be used only once---to setup the section commands to act as
appendixes. Thereafter normal section commands are used. The heading
for a section can be left empty. For example,
\begin{verbatim}
\appendix
\section{}
\end{verbatim}
will produce an appendix heading that says ``APPENDIX A'' and
\begin{verbatim}
\appendix
\section{Background}
\end{verbatim}
will produce an appendix heading that says ``APPENDIX A: BACKGROUND''
(note that the colon is set automatically).

If there is only one appendix, then the letter ``A'' should not
appear. This is suppressed by using the star version of the appendix
command (\verb+\appendix*+ in the place of \verb+\appendix+).

\section{A little more on appendixes}

Observe that this appendix was started by using
\begin{verbatim}
\section{A little more on appendixes}
\end{verbatim}

Note the equation number in an appendix:
\begin{equation}
E=mc^2.
\end{equation}

\subsection{\label{app:subsec}A subsection in an appendix}

You can use a subsection or subsubsection in an appendix. Note the
numbering: we are now in Appendix~\ref{app:subsec}.

Note the equation numbers in this appendix, produced with the
subequations environment:
\begin{subequations}
\begin{eqnarray}
E&=&mc, \label{appa}
\\
E&=&mc^2, \label{appb}
\\
E&\agt& mc^3. \label{appc}
\end{eqnarray}
\end{subequations}
They turn out to be Eqs.~(\ref{appa}), (\ref{appb}), and (\ref{appc}).

% The \nocite command causes all entries in a bibliography to be printed out
% whether or not they are actually referenced in the text. This is appropriate
% for the sample file to show the different styles of references, but authors
% most likely will not want to use it.
\nocite{*}

%\bibliography{apssamp}
\bibliography{apssamp1}% Produces the bibliography via BibTeX.

\begin{filecontents}{apssamp1.bib}

@ARTICLE{epr,
   author       = "A. Einstein and {\relax Yu} Podolsky and N. Rosen", 
   collaboration = "EPR",
   year         = "1935", 
   journal      = "Phys.\ Rev.", 
   volume       = "47", 
   pages        = "777",
}

@ARTICLE{Berman1983,
   author       = "G. P. Berman, Jr. and F. M. Izrailev, Jr.",
   title        = "Stability of nonlinear modes",
   journal      = "Physica D",
   volume       = "88", 
   pages        = "445",
   year         = "1983",
}

\end{filecontents}

\end{document}
%
% ****** End of file apssamp.tex ******







## end
#215, 2845:
\documentclass[%
 reprint,
%superscriptaddress,
%groupedaddress,
%unsortedaddress,
%runinaddress,
%frontmatterverbose, 
%preprint,
%preprintnumbers,
%nofootinbib,
%nobibnotes,
%bibnotes,
 amsmath,amssymb,
 aps,
%pra,
%prb,
%rmp,
%prstab,
%prstper,
%floatfix,
]{revtex4-2}

\usepackage{graphicx}% Include figure files
\usepackage{dcolumn}% Align table columns on decimal point
\usepackage{bm}% bold math
%\usepackage{hyperref}% add hypertext capabilities
%\usepackage[mathlines]{lineno}% Enable numbering of text and display math
%\linenumbers\relax % Commence numbering lines

%\usepackage[showframe,%Uncomment any one of the following lines to test 
%%scale=0.7, marginratio={1:1, 2:3}, ignoreall,% default settings
%%text={7in,10in},centering,
%%margin=1.5in,
%%total={6.5in,8.75in}, top=1.2in, left=0.9in, includefoot,
%%height=10in,a5paper,hmargin={3cm,0.8in},
%]{geometry}

\begin{document}

\preprint{APS/123-QED}

\title{%标题}

\author{%作者}
\email{%邮箱}
\affiliation{%地址}

\date{\today}

\begin{abstract}
%概述
\end{abstract}

\maketitle


\section{\label{sec:level1}%一级标题}
%内容
\subsection{\label{sec:level2}%二级标题}
%内容
\subsubsection{%三级标题}
%内容
\paragraph{%四级标题}
%内容
\subsection{\label{sec:citeref}%二级标题}
%内容
\subsection{\label{sec:%引用名}%二级标题}
%内容
\subsection{%二级标题}
%内容

\section{Math and Equations}
$%内部等式$
Note the open one in Eq.~(\ref{eq:%公式引用}).

\begin{equation}
%公式
\label{eq:%公式引用}.
\end{equation}

\begin{widetext}
\begin{equation}
%宽边公式
\end{equation}
\end{widetext}


\begin{table}
\begin{ruledtabular}
\begin{tabular}{lcdr}
\textrm{Left\footnote{Note a.}}&
\textrm{Centered\footnote{Note b.}}&
\multicolumn{1}{c}{\textrm{Decimal}}&
\textrm{Right}\\
\colrule
1 & 2 & 3.001 & 4\\
10 & 20 & 30 & 40\\
100 & 200 & 300.0 & 400\\
\end{tabular}
\end{ruledtabular}
\end{table}


Table~\ref{tab:table1},%
and Fig.~\ref{fig:%图片引用名}.%


\begin{figure}[b]
\includegraphics{fig_1}
\caption{\label{fig:%图片引用名}%图例}
\end{figure}


%宽边图片
\begin{figure*}
\includegraphics{fig_2}
\caption{\label{fig:%图片引用名}%图例}
\end{figure*}


\begin{acknowledgments}
%致谢
\end{acknowledgments}

\appendix

\section{%附录标题}
\section{%附录标题}
\subsection{\label{app:%引用名}%附录二级标题}

\nocite{*}
%\bibliography{apssamp}
\bibliography{apssamp1}% Produces the bibliography via BibTeX.

\begin{filecontents}{apssamp1.bib}

@ARTICLE{epr,
   author       = "A. Einstein and {\relax Yu} Podolsky and N. Rosen", 
   collaboration = "EPR",
   year         = "1935", 
   journal      = "Phys.\ Rev.", 
   volume       = "47", 
   pages        = "777",
}

@ARTICLE{Berman1983,
   author       = "G. P. Berman, Jr. and F. M. Izrailev, Jr.",
   title        = "Stability of nonlinear modes",
   journal      = "Physica D",
   volume       = "88", 
   pages        = "445",
   year         = "1983",
}

\end{filecontents}

\end{document}
%
% ****** End of file apssamp.tex ******







## end
#217, 13426:
@PREAMBLE{
 "\providecommand{\noopsort}[1]{}" 
 # "\providecommand{\singleletter}[1]{#1}%" 
}

@BOOK{Bire82,
   author       = {N. D. Birell and P. C. W. Davies},
   year         = 1982,
   title        = {Quantum Fields in Curved Space},
   publisher    = {Cambridge University Press}
}

@ARTICLE{feyn54,
   author       = "R. P. Feynman",
   year         = "1954",
   journal      = "Phys.\ Rev.",
   volume       = "94",
   pages        = "262",
}

@ARTICLE{epr,
   author       = "A. Einstein and {\relax Yu} Podolsky and N. Rosen", 
   collaboration = "EPR",
   year         = "1935", 
   journal      = "Phys.\ Rev.", 
   volume       = "47", 
   pages        = "777",
}

@ARTICLE{Berman1983,
   author       = "G. P. Berman, Jr. and F. M. Izrailev, Jr.",
   title        = "Stability of nonlinear modes",
   journal      = "Physica D",
   volume       = "88", 
   pages        = "445",
   year         = "1983",
}

@ARTICLE{Davies1998,
   author       = "E. B. Davies and L. Parns", 
   title        = "Trapped modes in acoustic waveguides", 
   journal      = "Q. J. Mech. Appl. Math.", 
   volume       = "51", 
   pages        = "477--492", 
   year         = "1988", 
}

@MISC{witten2001,
   author       = "Edward Witten",
   eprint       = "hep-th/0106109",
   year         = "2001",
}

@INBOOK{Beutler1994,
   author       = "E. Beutler", 
   editor       = "E. Beutler and M. A. Lichtman and B. W. Coller and T. S. Kipps", 
   booktitle    = "Williams Hematology", 
   chapter      = "7", 
   pages        = "654--662",
   publisher    = "McGraw-Hill", 
   year         = "1994", 

   edition      = "5", 
   address      = "New York", 
   volume       = "2", 
}

@INCOLLECTION{Beutler1994a,
   author       = "E. Beutler", 
   editor       = "E. Beutler and M. A. Lichtman and B. W. Coller and T. S. Kipps", 
   booktitle    = "Williams Hematology", 
   chapter      = "7", 
   pages        = "654--662",
   publisher    = "McGraw-Hill", 
   year         = "1994", 

   edition      = "5", 
   address      = "New York", 
   volume       = "2", 
}

@INBOOK{inbook-full,
   author    = "Donald E. Knuth",
   booktitle = "Fundamental Algorithms",
   volume    = 1,
   series    = "The Art of Computer Programming",
   publisher = "Addison-Wesley",
   address   = "Reading, Massachusetts",
   edition   = "Second",
   month     = "10~" # jan,
   year      = "\noopsort{1973b}1973",
   type      = "Section",
   chapter   = "1.2",
   pages     = "10--119",
   note      = "A full INBOOK entry",
}

@ARTICLE{Smith2005,
   author       = "J. S. Smith and G. W. Johnson", 
   journal      = "Philos. Trans. R. Soc. London, Ser. B", 
   title        = "", 
   year         = "2005", 

   volume       = "777", 
   pages        = "1395",
}

@UNPUBLISHED{Smith2010,
   author       = "W. J. Smith and T. J. Johnson and B. G. Miller", 
   title        = "Surface chemistry and preferential crystal orientation on a silicon surface", 
   note         = "{J. Appl. Phys.} (unpublished)", 
   
   month        = "", 
   year         = "2010",
}

@UNPUBLISHED{Smith2010a,
   author       = "V. K. Smith and K. Johnson and M. O. Klein", 
   title        = "Surface chemistry and preferential crystal orientation on a silicon surface", 
   note         = "{J. Appl. Phys.} (submitted)", 
   
   month        = "", 
   year         = "2010",
}

@UNPUBLISHED{unpublished-full,
   author = "Ulrich {\"{U}}nderwood and Ned {\~N}et and Paul {\={P}}ot",
   title = "Lower Bounds for Wishful Research Results",
   month = nov # ", " # dec,
   year = 1988,
   note = "Talk at Fanstord University (A full UNPUBLISHED entry)",
}

@MISC{JohnsonMillerSmith2007, 

   author       = "M. P. Johnson and K. L. Miller and K. Smith", 
   title        = "", 
   howpublished = "personal communication", 
   month        = "1~" # may, 
   year         = "2007", 
   note         = "",
}

@PROCEEDINGS{Smith2007, 
   title        = "AIP Conf. Proc.", 
   year         = "2007", 
   
   editor       = "J. Smith", 
   volume       = "841", 
   number       = "21", 
   series       = "", 
   address      = "", 
   month        = "", 
   organization = "", 
   publisher    = "", 
   note         = "", 
}

@PROCEEDINGS{proceedings-full,
   editor = "Wizard V. Oz and Mihalis Yannakakis",
   title = "Proc. Fifteenth Annual",
   number = 17,
   series = "All ACM Conferences",
   month = mar,
   year = 1983,
   address = "Boston",
   organization = "ACM",
   publisher = "Academic Press",
   note = "A full PROCEEDINGS entry",
}

@UNPUBLISHED{Burstyn2004,
   author       = "Y. Burstyn", 
   title        = "{Proceedings of the 5th International Molecular Beam Epitaxy Conference, Santa Fe, NM}", 
   note         = "(unpublished)", 
   
   month        = "5--8~" # oct, 
   year         = "2004",
}

@PROCEEDINGS{Quinn2001, 
   title        = "{Proceedings of the 2003 Particle  Accelerator Conference, Portland, OR, 12-16 May 2005}", 
   year         = "2001", 
   
   editor       = "B. Quinn", 
   address      = "New York", 
   publisher    = "Wiley", 
   note         = "Albeit the conference was held in 2005, it was the 2003 conference, and  the proceedings were published in 2001; go figure", 
}

@ARTICLE{Agarwal2001,
   author       = "A. G. Agarwal", 
   title        = "{Proceedings of the Fifth Low Temperature Conference, Madison, WI, 1999}", 
   journal      = "Semiconductors", 
   year         = "2001", 

   volume       = "66", 
   pages        = "1238", 
}

@ARTICLE{SmithDA01,
   author       = "R. Smith",
   title        = "Hummingbirds are our friends",
   journal      = {J. Appl. Phys. (these proceedings)},
   year         = "2001",
   volume       = "",
   number       = "",
   pages        = "",
   month        = "",
   note         = "Abstract No. DA-01",
}

@ARTICLE{Smith2007a, 
   author       = "J. Smith", 
   title        = "", 
   journal      = "Proc. SPIE", 
   year         = "2007", 

   volume       = "124", 
   pages        = "367", 
   note         = "Required title is missing", 
}

@TECHREPORT{techreport-full,
   author = "Tom T{\'{e}}rrific",
   title = "An {$O(n \log n / \! \log\log n)$} Sorting Algorithm",
   institution = "Fanstord University",
   type = "Wishful Research Result",
   number = "7",
   address = "Computer Science Department, Fanstord, California",
   month = oct,
   year = 1988,
   note = "A full TECHREPORT entry",
}

@TECHREPORT{Nelson1999, 
   author       = "J. Nelson", 
   type         = "{TWI Report}", 
   number       = "666/1999",
   institution  = "", 
   year         = jan # "~1999", 
   
   note         = "Required institution missing", 
}

@TECHREPORT{Fields2005, 
   author       = "W. K. Fields", 
   type         = "{ECE Report No.}", 
   number       = "AL944",
   institution  = "", 
   year         = "2005", 
   
   note         = "Required institution missing", 
}

@ARTICLE{Cons22, 
   author        = "Constantin Aniculaesei and Thanh Ha and Samuel Yoffe and others", 
   title         = "High-charge 10 GeV electron acceleration in a 10 cm nanoparticleassisted wakefield accelerator", 
   journal = {ArXiv e-prints},
   archivePrefix = "arXiv",
   eprint        = {2207.11492},
   primaryClass  = "plasm-ph",
   year          = "2022",
}

@MISC{Zalkins2008, 

   author       = "Y. M. Zalkins", 
   title        = "", 
   howpublished = "e-print arXiv:cond-mat/040426", 
   month        = "", 
   year         = "2008", 
   note         = "",
}

@MISC{Nelson2005, 

   author       = "J. Nelson", 
   howpublished = "{U.S. Patent No.} 5,693,000", 
   year         = "12~" # dec # "~2005", 
}

@MASTERSTHESIS{Nelson1999a,
   author       = "J. K. Nelson", 
   title        = "", 
   school       = "New York University", 
   year         = "1999", 
   
   type         = "M.{S}. thesis", 
   address      = "", 
   month        = "", 
   note         = "", 
}

@MASTERSTHESIS{mastersthesis-full,
   author = "{\'{E}}douard Masterly",
   title = "Mastering Thesis Writing",
   school = "Stanford University",
   type = "Master's project",
   address = "English Department",
   month = jun # "-" # aug,
   year = 1988,
   note = "A full MASTERSTHESIS entry",
}

@PHDTHESIS{Smith2003,
   author       = "S. M. Smith", 
   title        = "", 
   school       = "Massachusetts Institute of  Technology", 
   year         = "2003", 
   
   type         = "{Ph.D.} thesis", 
   address      = "", 
   month        = "", 
   note         = "", 
}

@ARTICLE{KawaLin2003,
   author       = "S. R. Kawa and S.-J. Lin", 
   title        = "", 
   journal      = "J. Geophys. Res.", 
   year         = "2003", 

   volume       = "108", 
   number       = "D6", 
   pages        = "4201", 
   month        = "", 
   note         = "{DOI:10.1029/2002JD002268}", 
}

@PHDTHESIS{phdthesis-full,
   author = "F. Phidias Phony-Baloney",
   title = "Fighting Fire with Fire: Festooning {F}rench Phrases",
   school = "Fanstord University",
   type = "{PhD} Dissertation",
   address = "Department of French",
   month = jun # "-" # aug,
   year = 1988,
   note = "A full PHDTHESIS entry",
}

@BOOK{book-full,
   author = "Donald E. Knuth",
   title = "Seminumerical Algorithms",
   volume = 2,
   series = "The Art of Computer Programming",
   publisher = "Addison-Wesley",
   address = "Reading, Massachusetts",
   edition = "Second",
   month = "10~" # jan,
   year = "\noopsort{1973c}1981",
   note = "A full BOOK entry",
}

@BOOKLET{booklet-full,
   author = "Jill C. Knvth",
   title = "The Programming of Computer Art",
   howpublished = "Vernier Art Center",
   address = "Stanford, California",
   month = feb,
   year = 1988,
   note = "A full BOOKLET entry",
}

@INBOOK{ballagh2000,
   author    = "R. Ballagh and C.M. Savage",
   editor    = "C.M. Savage and M. Das",
   title     = "Bose-Einstein condensation: from atomic physics to quantum fluids, Proceedings of the 13th Physics Summer School",
   year      = "2000",
   publisher = "World Scientific",
   address   = "Singapore",
   eprint    = "cond-mat/0008070",
}

@INCOLLECTION{ballagh2000a,
   author    = "R. Ballagh and C.M. Savage",
   title     = "Bose-Einstein condensation: from atomic physics to quantum fluids",
   editor    = "C.M. Savage and M. Das",
   booktitle = "Proceedings of the 13th Physics Summer School",
   year      = "2000",
   publisher = "World Scientific",
   address   = "Singapore",
   eprint    = "cond-mat/0008070",
}

@inBook{Magnetism,
   author    = "W. Opechowski and R. Guccione",
   title     = "Introduction to the Theory of Normal Metals",
   volume    = "IIa",
   pages     = "105",
   editor    = "G. T. Rado and H. Suhl",
   booktitle = "Magnetism",
   publisher = "Academic Press",
   address   = "New York",
   year      = "1965",
}

@INCOLLECTION{Magnetisma,
   author    = "W. Opechowski and R. Guccione",
   title     = "Introduction to the Theory of Normal Metals",
   editor    = "G. T. Rado and H. Suhl",
   booktitle = "Magnetism",
   volume    = "IIa",
   pages     = "105",
   publisher = "Academic Press",
   address   = "New York",
   year      = "1965",
}

@INPROCEEDINGS{Magnetismb,
   author    = "W. Opechowski and R. Guccione",
   title     = "Introduction to the Theory of Normal Metals",
   editor    = "G. T. Rado and H. Suhl",
   booktitle = "Magnetism",
   volume    = "IIa",
   pages     = "105",
   publisher = "Academic Press",
   address   = "New York",
   year      = "1965",
}

@INBOOK{Smith80,
   author    = "J. M. Smith",
   title     = "Molecular Dynamics",
   publisher = "Academic",
   year      = "1980",
   address   = "New York",
   editor    = "C. Brown",
}

@article{ZS71,
   author    = "V. E. Zakharov and A. B. Shabat",
   title     = "Exact theory of two-dimensional self-focusing and one-dimensional self-modulation of waves in nonlinear media",
   journal   = "Zh. Eksp. Teor. Fiz.",
   volume    = "61",
   year      = "1971",
   pages     = "118--134",
   translation = "Sov. Phys. JETP \textbf{34}, 62 (1972)"
}

@INCOLLECTION{Smith80a,
   author    = "J. M. Smith",
   booktitle = "Molecular Dynamics",
   editor    = "C. Brown",
   publisher = "Academic",
   year      = "1980",
   address   = "New York",
}

@INCOLLECTION{incollection-full,
   author = "Daniel D. Lincoll",
   title = "Semigroups of Recurrences",
   editor = "David J. Lipcoll and D. H. Lawrie and A. H. Sameh",
   booktitle = "High Speed Computer and Algorithm Organization",
   number = 23,
   series = "Fast Computers",
   chapter = 3,
   type = "Part",
   pages = "179--183",
   publisher = "Academic Press",
   address = "New York",
   edition = "Third",
   month = sep,
   year = 1977,
   note = "A full INCOLLECTION entry",
}

@INPROCEEDINGS{inproceedings-full,
   author = "Alfred V. Oaho and Jeffrey D. Ullman and Mihalis Yannakakis",
   title = "On Notions of Information Transfer in {VLSI} Circuits",
   editor = "Wizard V. Oz and Mihalis Yannakakis",
   booktitle = "Proc. Fifteenth Annual ACM",
   bookaddress = "Boston, 1982", 
   number = 17,
   series = "All ACM Conferences",
   pages = "133--139",
   month = mar,
   year = 1983,
   address = "New York",
   organization = "ACM",
   publisher = "Academic Press",
   note = "A full INPROCEDINGS entry",
}

@MANUAL{manual-full,
   author = "Larry Manmaker",
   title = "The Definitive Computer Manual",
   organization = "Chips-R-Us",
   address = "Silicon Valley",
   edition = "Silver",
   month = apr # "-" # may,
   year = 1986,
   note = "A full MANUAL entry",
}

## end
#219, 13050:
@PREAMBLE{
 "\providecommand{\noopsort}[1]{}" 
 # "\providecommand{\singleletter}[1]{#1}%" 
}

@BOOK{Bire82,
   author       = {N. D. Birell and P. C. W. Davies},
   year         = 1982,
   title        = {Quantum Fields in Curved Space},
   publisher    = {Cambridge University Press}
}

@ARTICLE{feyn54,
   author       = "R. P. Feynman",
   year         = "1954",
   journal      = "Phys.\ Rev.",
   volume       = "94",
   pages        = "262",
}

@ARTICLE{epr,
   author       = "A. Einstein and {\relax Yu} Podolsky and N. Rosen", 
   collaboration = "EPR",
   year         = "1935", 
   journal      = "Phys.\ Rev.", 
   volume       = "47", 
   pages        = "777",
}

@ARTICLE{Berman1983,
   author       = "G. P. Berman, Jr. and F. M. Izrailev, Jr.",
   title        = "Stability of nonlinear modes",
   journal      = "Physica D",
   volume       = "88", 
   pages        = "445",
   year         = "1983",
}

@ARTICLE{Davies1998,
   author       = "E. B. Davies and L. Parns", 
   title        = "Trapped modes in acoustic waveguides", 
   journal      = "Q. J. Mech. Appl. Math.", 
   volume       = "51", 
   pages        = "477--492", 
   year         = "1988", 
}

@MISC{witten2001,
   author       = "Edward Witten",
   eprint       = "hep-th/0106109",
   year         = "2001",
}

@INBOOK{Beutler1994,
   author       = "E. Beutler", 
   editor       = "E. Beutler and M. A. Lichtman and B. W. Coller and T. S. Kipps", 
   booktitle    = "Williams Hematology", 
   chapter      = "7", 
   pages        = "654--662",
   publisher    = "McGraw-Hill", 
   year         = "1994", 

   edition      = "5", 
   address      = "New York", 
   volume       = "2", 
}

@INCOLLECTION{Beutler1994a,
   author       = "E. Beutler", 
   editor       = "E. Beutler and M. A. Lichtman and B. W. Coller and T. S. Kipps", 
   booktitle    = "Williams Hematology", 
   chapter      = "7", 
   pages        = "654--662",
   publisher    = "McGraw-Hill", 
   year         = "1994", 

   edition      = "5", 
   address      = "New York", 
   volume       = "2", 
}

@INBOOK{inbook-full,
   author    = "Donald E. Knuth",
   booktitle = "Fundamental Algorithms",
   volume    = 1,
   series    = "The Art of Computer Programming",
   publisher = "Addison-Wesley",
   address   = "Reading, Massachusetts",
   edition   = "Second",
   month     = "10~" # jan,
   year      = "\noopsort{1973b}1973",
   type      = "Section",
   chapter   = "1.2",
   pages     = "10--119",
   note      = "A full INBOOK entry",
}

@ARTICLE{Smith2005,
   author       = "J. S. Smith and G. W. Johnson", 
   journal      = "Philos. Trans. R. Soc. London, Ser. B", 
   title        = "", 
   year         = "2005", 

   volume       = "777", 
   pages        = "1395",
}

@UNPUBLISHED{Smith2010,
   author       = "W. J. Smith and T. J. Johnson and B. G. Miller", 
   title        = "Surface chemistry and preferential crystal orientation on a silicon surface", 
   note         = "{J. Appl. Phys.} (unpublished)", 
   
   month        = "", 
   year         = "2010",
}

@UNPUBLISHED{Smith2010a,
   author       = "V. K. Smith and K. Johnson and M. O. Klein", 
   title        = "Surface chemistry and preferential crystal orientation on a silicon surface", 
   note         = "{J. Appl. Phys.} (submitted)", 
   
   month        = "", 
   year         = "2010",
}

@UNPUBLISHED{unpublished-full,
   author = "Ulrich {\"{U}}nderwood and Ned {\~N}et and Paul {\={P}}ot",
   title = "Lower Bounds for Wishful Research Results",
   month = nov # ", " # dec,
   year = 1988,
   note = "Talk at Fanstord University (A full UNPUBLISHED entry)",
}

@MISC{JohnsonMillerSmith2007, 

   author       = "M. P. Johnson and K. L. Miller and K. Smith", 
   title        = "", 
   howpublished = "personal communication", 
   month        = "1~" # may, 
   year         = "2007", 
   note         = "",
}

@PROCEEDINGS{Smith2007, 
   title        = "AIP Conf. Proc.", 
   year         = "2007", 
   
   editor       = "J. Smith", 
   volume       = "841", 
   number       = "21", 
   series       = "", 
   address      = "", 
   month        = "", 
   organization = "", 
   publisher    = "", 
   note         = "", 
}

@PROCEEDINGS{proceedings-full,
   editor = "Wizard V. Oz and Mihalis Yannakakis",
   title = "Proc. Fifteenth Annual",
   number = 17,
   series = "All ACM Conferences",
   month = mar,
   year = 1983,
   address = "Boston",
   organization = "ACM",
   publisher = "Academic Press",
   note = "A full PROCEEDINGS entry",
}

@UNPUBLISHED{Burstyn2004,
   author       = "Y. Burstyn", 
   title        = "{Proceedings of the 5th International Molecular Beam Epitaxy Conference, Santa Fe, NM}", 
   note         = "(unpublished)", 
   
   month        = "5--8~" # oct, 
   year         = "2004",
}

@PROCEEDINGS{Quinn2001, 
   title        = "{Proceedings of the 2003 Particle  Accelerator Conference, Portland, OR, 12-16 May 2005}", 
   year         = "2001", 
   
   editor       = "B. Quinn", 
   address      = "New York", 
   publisher    = "Wiley", 
   note         = "Albeit the conference was held in 2005, it was the 2003 conference, and  the proceedings were published in 2001; go figure", 
}

@ARTICLE{Agarwal2001,
   author       = "A. G. Agarwal", 
   title        = "{Proceedings of the Fifth Low Temperature Conference, Madison, WI, 1999}", 
   journal      = "Semiconductors", 
   year         = "2001", 

   volume       = "66", 
   pages        = "1238", 
}

@ARTICLE{SmithDA01,
   author       = "R. Smith",
   title        = "Hummingbirds are our friends",
   journal      = {J. Appl. Phys. (these proceedings)},
   year         = "2001",
   volume       = "",
   number       = "",
   pages        = "",
   month        = "",
   note         = "Abstract No. DA-01",
}

@ARTICLE{Smith2007a, 
   author       = "J. Smith", 
   title        = "", 
   journal      = "Proc. SPIE", 
   year         = "2007", 

   volume       = "124", 
   pages        = "367", 
   note         = "Required title is missing", 
}

@TECHREPORT{techreport-full,
   author = "Tom T{\'{e}}rrific",
   title = "An {$O(n \log n / \! \log\log n)$} Sorting Algorithm",
   institution = "Fanstord University",
   type = "Wishful Research Result",
   number = "7",
   address = "Computer Science Department, Fanstord, California",
   month = oct,
   year = 1988,
   note = "A full TECHREPORT entry",
}

@TECHREPORT{Nelson1999, 
   author       = "J. Nelson", 
   type         = "{TWI Report}", 
   number       = "666/1999",
   institution  = "", 
   year         = jan # "~1999", 
   
   note         = "Required institution missing", 
}

@TECHREPORT{Fields2005, 
   author       = "W. K. Fields", 
   type         = "{ECE Report No.}", 
   number       = "AL944",
   institution  = "", 
   year         = "2005", 
   
   note         = "Required institution missing", 
}

@MISC{Zalkins2008, 

   author       = "Y. M. Zalkins", 
   title        = "", 
   howpublished = "e-print arXiv:cond-mat/040426", 
   month        = "", 
   year         = "2008", 
   note         = "",
}

@MISC{Nelson2005, 

   author       = "J. Nelson", 
   howpublished = "{U.S. Patent No.} 5,693,000", 
   year         = "12~" # dec # "~2005", 
}

@MASTERSTHESIS{Nelson1999a,
   author       = "J. K. Nelson", 
   title        = "", 
   school       = "New York University", 
   year         = "1999", 
   
   type         = "M.{S}. thesis", 
   address      = "", 
   month        = "", 
   note         = "", 
}

@MASTERSTHESIS{mastersthesis-full,
   author = "{\'{E}}douard Masterly",
   title = "Mastering Thesis Writing",
   school = "Stanford University",
   type = "Master's project",
   address = "English Department",
   month = jun # "-" # aug,
   year = 1988,
   note = "A full MASTERSTHESIS entry",
}

@PHDTHESIS{Smith2003,
   author       = "S. M. Smith", 
   title        = "", 
   school       = "Massachusetts Institute of  Technology", 
   year         = "2003", 
   
   type         = "{Ph.D.} thesis", 
   address      = "", 
   month        = "", 
   note         = "", 
}

@ARTICLE{KawaLin2003,
   author       = "S. R. Kawa and S.-J. Lin", 
   title        = "", 
   journal      = "J. Geophys. Res.", 
   year         = "2003", 

   volume       = "108", 
   number       = "D6", 
   pages        = "4201", 
   month        = "", 
   note         = "{DOI:10.1029/2002JD002268}", 
}

@PHDTHESIS{phdthesis-full,
   author = "F. Phidias Phony-Baloney",
   title = "Fighting Fire with Fire: Festooning {F}rench Phrases",
   school = "Fanstord University",
   type = "{PhD} Dissertation",
   address = "Department of French",
   month = jun # "-" # aug,
   year = 1988,
   note = "A full PHDTHESIS entry",
}

@BOOK{book-full,
   author = "Donald E. Knuth",
   title = "Seminumerical Algorithms",
   volume = 2,
   series = "The Art of Computer Programming",
   publisher = "Addison-Wesley",
   address = "Reading, Massachusetts",
   edition = "Second",
   month = "10~" # jan,
   year = "\noopsort{1973c}1981",
   note = "A full BOOK entry",
}

@BOOKLET{booklet-full,
   author = "Jill C. Knvth",
   title = "The Programming of Computer Art",
   howpublished = "Vernier Art Center",
   address = "Stanford, California",
   month = feb,
   year = 1988,
   note = "A full BOOKLET entry",
}

@INBOOK{ballagh2000,
   author    = "R. Ballagh and C.M. Savage",
   editor    = "C.M. Savage and M. Das",
   title     = "Bose-Einstein condensation: from atomic physics to quantum fluids, Proceedings of the 13th Physics Summer School",
   year      = "2000",
   publisher = "World Scientific",
   address   = "Singapore",
   eprint    = "cond-mat/0008070",
}

@INCOLLECTION{ballagh2000a,
   author    = "R. Ballagh and C.M. Savage",
   title     = "Bose-Einstein condensation: from atomic physics to quantum fluids",
   editor    = "C.M. Savage and M. Das",
   booktitle = "Proceedings of the 13th Physics Summer School",
   year      = "2000",
   publisher = "World Scientific",
   address   = "Singapore",
   eprint    = "cond-mat/0008070",
}

@inBook{Magnetism,
   author    = "W. Opechowski and R. Guccione",
   title     = "Introduction to the Theory of Normal Metals",
   volume    = "IIa",
   pages     = "105",
   editor    = "G. T. Rado and H. Suhl",
   booktitle = "Magnetism",
   publisher = "Academic Press",
   address   = "New York",
   year      = "1965",
}

@INCOLLECTION{Magnetisma,
   author    = "W. Opechowski and R. Guccione",
   title     = "Introduction to the Theory of Normal Metals",
   editor    = "G. T. Rado and H. Suhl",
   booktitle = "Magnetism",
   volume    = "IIa",
   pages     = "105",
   publisher = "Academic Press",
   address   = "New York",
   year      = "1965",
}

@INPROCEEDINGS{Magnetismb,
   author    = "W. Opechowski and R. Guccione",
   title     = "Introduction to the Theory of Normal Metals",
   editor    = "G. T. Rado and H. Suhl",
   booktitle = "Magnetism",
   volume    = "IIa",
   pages     = "105",
   publisher = "Academic Press",
   address   = "New York",
   year      = "1965",
}

@INBOOK{Smith80,
   author    = "J. M. Smith",
   title     = "Molecular Dynamics",
   publisher = "Academic",
   year      = "1980",
   address   = "New York",
   editor    = "C. Brown",
}

@article{ZS71,
   author    = "V. E. Zakharov and A. B. Shabat",
   title     = "Exact theory of two-dimensional self-focusing and one-dimensional self-modulation of waves in nonlinear media",
   journal   = "Zh. Eksp. Teor. Fiz.",
   volume    = "61",
   year      = "1971",
   pages     = "118--134",
   translation = "Sov. Phys. JETP \textbf{34}, 62 (1972)"
}

@INCOLLECTION{Smith80a,
   author    = "J. M. Smith",
   booktitle = "Molecular Dynamics",
   editor    = "C. Brown",
   publisher = "Academic",
   year      = "1980",
   address   = "New York",
}

@INCOLLECTION{incollection-full,
   author = "Daniel D. Lincoll",
   title = "Semigroups of Recurrences",
   editor = "David J. Lipcoll and D. H. Lawrie and A. H. Sameh",
   booktitle = "High Speed Computer and Algorithm Organization",
   number = 23,
   series = "Fast Computers",
   chapter = 3,
   type = "Part",
   pages = "179--183",
   publisher = "Academic Press",
   address = "New York",
   edition = "Third",
   month = sep,
   year = 1977,
   note = "A full INCOLLECTION entry",
}

@INPROCEEDINGS{inproceedings-full,
   author = "Alfred V. Oaho and Jeffrey D. Ullman and Mihalis Yannakakis",
   title = "On Notions of Information Transfer in {VLSI} Circuits",
   editor = "Wizard V. Oz and Mihalis Yannakakis",
   booktitle = "Proc. Fifteenth Annual ACM",
   bookaddress = "Boston, 1982", 
   number = 17,
   series = "All ACM Conferences",
   pages = "133--139",
   month = mar,
   year = 1983,
   address = "New York",
   organization = "ACM",
   publisher = "Academic Press",
   note = "A full INPROCEDINGS entry",
}

@MANUAL{manual-full,
   author = "Larry Manmaker",
   title = "The Definitive Computer Manual",
   organization = "Chips-R-Us",
   address = "Silicon Valley",
   edition = "Silver",
   month = apr # "-" # may,
   year = 1986,
   note = "A full MANUAL entry",
}

## end
#221, 24:


召唤规则:...
降临规则:...





## end
#223, 356:
"""
Nini, 打开人体模型(文件)
Nini, 打开CBS(文件)

"""

+召唤规则(_媒介,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_凭依)...

->[==]"结构文本转docx"(,召唤星辰)...
    ->+整理图片(_媒介,_凭依)->+的(操作,+整理图片)...
    ->+整理内容(_媒介,_凭依)->+的(操作,+整理内容)...

->[]{
    []=>的(_媒介,_章节)->_章节=>+章节内容(_章节,_凭依)->+的(操作,+章节内容)
}...
->[]{
    []:->.(_媒介,_原始结构)->_原始结构(,)...
        ->+引用文章(_原始结构,_凭依)->+的(操作,+引用文章),
    ->[]
}

## end
#225, 80:
有什么

引用文章:...
章节内容:...
整理内容:...
整理图片:...
+[新建阅读窗口](,章节内容)
将'引用文章'的"作者"替换为"文章"



## end
#227, 309:
"""
描述结构:...
库:...
+[新建阅读窗口](,库)

"""
+章节内容(_章节结构,_文本)->+[del](,+章节内容)...
->的(章节内容,描述结构)->的(章节内容,库)...

->+[code]([想],描述结构)->[想](_章节结构,_文本)...
->操作([想],)...
->[]{
    []=>的(操作,_操作)->_操作(_主语,_宾语)->_主语->_宾语(,)...
    =>[说](,_操作)...
        ->的(库,_条目)->_条目->[eq](_条目,_操作)->+[做](_主语,_宾语)->+[code](+[做],_条目)
}





## end
#229, 18016:
\documentclass[%
 reprint,
%superscriptaddress,
%groupedaddress,
%unsortedaddress,
%runinaddress,
%frontmatterverbose, 
%preprint,
%preprintnumbers,
%nofootinbib,
%nobibnotes,
%bibnotes,
 amsmath,amssymb,
 aps,
%pra,
%prb,
%rmp,
%prstab,
%prstper,
%floatfix,
]{revtex4-2}

\usepackage{graphicx}% Include figure files
\usepackage{dcolumn}% Align table columns on decimal point
\usepackage{bm}% bold math
%\usepackage{hyperref}% add hypertext capabilities
%\usepackage[mathlines]{lineno}% Enable numbering of text and display math
%\linenumbers\relax % Commence numbering lines

%\usepackage[showframe,%Uncomment any one of the following lines to test 
%%scale=0.7, marginratio={1:1, 2:3}, ignoreall,% default settings
%%text={7in,10in},centering,
%%margin=1.5in,
%%total={6.5in,8.75in}, top=1.2in, left=0.9in, includefoot,
%%height=10in,a5paper,hmargin={3cm,0.8in},
%]{geometry}

\begin{document}

\preprint{APS/123-QED}

\title{Compact high-resolution multi-GeV electron spectrometer for PW-laser-driven plasma accelerators and approximate trajectory method for spectrum analysis}


\author{Xiantao Cheng}
\affiliation{University of Texas at Austin, Department of Physics, Austin, Texas 78712-1081, USA}

\author{Aaron. C. Bernstein}
\affiliation{University of Texas at Austin, Department of Physics, Austin, Texas 78712-1081, USA}

\author{Rafal Zgadzaj}
\affiliation{University of Texas at Austin, Department of Physics, Austin, Texas 78712-1081, USA}

\author{Michael C. Downer}
\email{}
\affiliation{University of Texas at Austin, Department of Physics, Austin, Texas 78712-1081, USA}

\date{\today}

\begin{abstract}
For the past decade, laser-plasma accelerators (LPAs) of ~ mm to ~ cm length have provided compact sources of nearly mono-energetic, highly directional electron bunches with energy as high as 1 GeV.  With the advent of petawatt scale lasers, these accelerators are now poised to go well beyond 1GeV energies.  In contrast to the large scale accelerator facilities, the LPA’s will be compact devices, requiring compact electron spectrometers adapted to the unique properties of the LPA electron bunches.  We report a compact high resolution spectrometer adapted to these conditions.  
\end{abstract}


\maketitle


\section{Introduction}
For the past decade, laser-plasma accelerators (LPAs) of ~ mm to ~ cm length have provided compact sources of nearly mono-energetic, highly directional electron bunches [Esa09] with energy as high as 1 GeV [Lee06].  The electron energy spectrum is generally measured with a standard magnetic spectrometer, in which a dipole magnetic field of typically ~1 T over cm dimensions, readily available from commercially available permanent magnets, deflects the trajectories of electrons emerging from the LPA [Nakamura07].  The deflected electrons are then detected 10 to 100 cm downstream of the magnet on a fluorescing screen, thereby mapping electron energy to displacement on the detector.  Because of the low angular divergence (typically a few mrad) of electrons from quasi-mono-energetic LPAs and the relatively large deflection angles (typically > 10o) of sub-GeV electrons achievable with small permanent magnets, the angular spread of electrons entering the magnetic field has played a minor role in the energy analysis of LPA electrons, except for energies approaching ~ 1 GeV [Pollock09, Clayton10]. The recent emergence of PW-class lasers has now ushered in a new era of quasi-mono-energetic laser-plasma acceleration (LPA) to multi-GeV electron bunches [Wang13, Kim13].  This new range of electron energy raises new challenges to the accurate measurement of electron energy, because the deflection angle becomes comparable to the initial angular spread.  For example, a 5 GeV electron bends only ??? mrad in a 1 T field of 5 cm extent.  An uncertainty of ?? mrad in the electron launch angle from the LPA can therefore result in uncertainty in the energy approaching 100\%. The possibilities of energy-dependent launch angles and of uncertainty in the launch location due to multi-cm length of multi-GeV LPAs further complicate the analysis.  A brute force solution to these problems is to use stronger and/or larger magnets.  However, this compromises the principal virtues of LPAs – compactness and low expense. In this paper, we present an electron spectrometer suitable for PW LPA experiments that measures the energy spectrum of multi-GeV electrons with an accuracy of a few percent using permanent magnets no larger or more expensive than those typical of sub-GeV electron spectrometers.  Our spectrometer builds upon a “two-screen” concept introduced by [Pollock09, Clayton10] to deconvolve launch angle variations from energy variations... [summary description].  However, our spectrometer goes well beyond the two-screen method  [describe how].  The paper is organized as follows:  Section 2 provides an overview of the problem of multi-GeV electron energy analysis. Section 3 describes the set-up of our spectrometer, and analyzes the interaction of electrons and x-rays with its key components.  Section 4 presents an analysis of electron energy spectra for several shots with different characteristics.  Section 5 discusses.  Section 6 summarizes the main findings. 


\section{Two-screen method problem}
The two-screen method is one of the most popular ways to measure LWFA electrons. In this method, electrons were usually deflected by a permanent dipole magnet and imaged by two screens at different locations after the magnet. In theory, any electron trajectories could be determined uniquely by three points in the space. In reality, the features on two screens might not be comparable, because of the divergency of electrons which always existed. For example, the electron beams could be a single peak image on the first screen, which it might be two peaks on the second screen. On the other hand, it is very important to find the correct correlated points on the screens to measure the spectrum of high energy electrons. A small error in the position measure would cause large errors in the spectrum measure, especially when the energy reaching \(10\ GeV\) level. For example, in the simulation, the IP2 was separated from the magnet by 800 mm and the IP1was separated by 3000 mm. The real spectrum had two peaks. The center of one was at \(E_1=10\ GeV\), and the other one was at \(E_2=3.7\ GeV\). The divergencies of the electrons were \(\sigma=3.0\ mrad\). There was two peaks on the IP1, while only one peak showed on the IP2. 
\begin{figure}[b]
\includegraphics[width=0.45\textwidth]{fig.1_}
\caption{\label{fig:fig.1_}Fig.1. (a) is the setup of a typical two-screen spectrometer. (a1) is the real spectrum of electrons. (a2) is the image on the IP2 screen. (a3) is the image on the IP1 screen. (a2) and (a3) are obtained from a GEANT4 simulation. 
(b) shows the intensity curves on both screens. The intensity is integrated over the Y-axis.}
\end{figure}


If we used the maximum point on the IP2 and the maximum point on the IP1 to define the trajectory, the energy of the trajectory would be \(18.56\ GeV\), while the real energy should be \(10\ GeV\).As a result, we proposed a new design of spectrometer by using two sets of Tungsten fiducials with an image plate, instead of two screens. The fiducial would scatter electrons going through it and leaving a shadow on the image plate, which would provide two points on the trajectories.


\section{Experiment setup}
In the experiments, the dipole magnet was placed 143.5 mm behind the gas cell. The magnetic field was equal to 1.48 T with 50 mm for the width. The <band> SR image plate (IP) was place 2672 mm after the magnet. The pixel size for the image plate was 50 um. The IP was scanned by XX, after every shot. Both sets of fiducials were consisted of 8 Tungsten wires with 0.127 mm for the diameter. The first set of fiducial was away from the IP by 1442 mm, which was closer to the magnet and the second set of fiducials are 934 mm from the IP, which was closer to the IP. The experiment setup is showed in the fig.3.
\begin{figure}[b]
\includegraphics[width=0.45\textwidth]{fig.3_}
\caption{\label{fig:fig.3_}}
\end{figure}


<LWFA parameters>There were many things done to increase the position measurement accuracies of different components. Two sets of fiducials were attach with the image plate holder by a stainless steel frame to increase the accuracy of position measurement. The accuracies of positions for fiducials and IP holder were XX mm. Fiducials were Tungsten wires, because the heavy element material could scatter more electrons with a small diameter shape. GEANT4 simulations were used to help us study the properties of electrons scattering, which will be discussed in the next Sec.The source locations could shifted randomly because of the laser pointing drifting. The IP position could also changed, because of the small gap between the holder and the IP. Those uncertainties were unavoidable, so we proposed a Betatron shadow calibration to calibrate both of locations. It will be discussed in the next next Sec.


\section{Fiducial electrons scattering}
For fiducial design, it is a tradeoff to project a thin shadow and a high constrast one. To project high constrast shadows, the fiducials need to be thick enough to scatter electrons by a large angle, while it needs to be thin to make the shadow thin as well. As a result, a heavy element material, for example Tungsten, is preferred. Both the angular spread and the energy spread will affect the shadow constrast, which might be very different for different electron source. But the most fundamental requirement for the shadow formation is that the electrons scattered by fiducials should fall into pixels on the IP other than the original pixel. We studied the scattering of electrons with different energy by different diameter of Tungsten wires by GEANT4 simulations. For monoenergetic electron inputs, the angular distributions of scattered electrons are Gaussian distributions, according to simluations. The standard deviation of the distribution is a function of the input energy. The functions were found through simulations and results were showed in fig.4. 
\begin{figure}[b]
\includegraphics[width=0.45\textwidth]{fig.4_}
\caption{\label{fig:fig.4_}Fig.4. (a) shows \(\sigma\) as functions of E. Tungsten wires with diameter, D=0.050 mm, 0.127 mm, 0.200 mm, 0.400 mm and 0.800 mm were studied.
(b) is one of simulation results. 10 GeV electrons were scattered by a 0.127 mm Tungsten wire in this simulation. The figure shows the angular distribution of scattered electrons. The dots are simulation data, and the solid line is a Gaussian function, which is \(g(\theta)=A\ exp(-\theta^2/\sigma^2)\).}
\end{figure}


For 0.127 Tungsten wires, the standard deviation \(\sigma\) as a function of input energy can be expressed as following,
\begin{equation}
x=1
\label{eq:[1].}
\end{equation}

The shadow shape was also studied by simulations. The results were showed in fig.5. From the simulation, we learned that the shadow shape was determined by the divergency, \(\sigma\), v.s. the pixel size, \(\Delta\), over the separation, \(L\), between the wire and the IP. To obtain a clear shadow on the IP, the condition is,
\begin{equation}
E=m_{e}\ c^{2}
\label{eq:[0].}
\end{equation}


\begin{figure}[b]
\includegraphics[width=0.45\textwidth]{fig.5_}
\caption{\label{fig:fig.5_}Fig.5. the shadow shapes of a 0.127 mm Tungsten wire were studied for different spectrums and different wire positions. It was Gaussian spectrum for all simulation. The peak energies were 4.313 GeV, 8.67 GeV, 17.55 GeV, 36.0 GeV and 75.9 GeV for (i1)-(i5), wihch were corresponding to \(\sigma\)=0.8, 0.4, 0.2, 0.1 and 0.05 mrad. }
\end{figure}


The pixel size was 0.05 mm in simulations. Let's say the separation between the wire and the IP is L. Then L=500 mm, 250 mm and 125 mm for (a)'s, (b)'s and (c)'s, which corresponding to \(\Delta\)/L=0.1, 0.2 and 0.4 mrad. In fact, the shadow shape is different for different electron energies. For low-energy electrons, a fiducial projected a pit on the spectrum image. But for high-energy electrons, there were two peaks around the pit, which weren't there in the original spectrum. The explanation is the high-energy electrons were scattered within a small angular range. Most of electrons were still falling on the IP around their original positions. Although in the origianl position, the intensity was lower, those places around the shadow had higher intensity, because the scattered electrons added intensity to those areas. This phenomenon can be an evident of high energy electrons observation in a experiment. 


\section{Betatron calibration}
LWFA electrons always came with Betatron radiations because of the oscillation caused by the focusing field. Since the most of Betatron radiations were generated by electrons in the end of acceleration process, the radiation sources were also the sources of electrons. The SR IP is also able to record the X-ray intensities, and the same sets of fiducials also block X-rays from Betatron radiations leaving shadows on the IP. It is straight forward to connect fiducials and their correlated shadows, and to locate the source by crossing points of all trajectories. The X-ray shadows are distinguishable from electron shadows, because the image of Betatron radiations are distinguishable from electrons. X-rays are not deflected by the magnet and will be imaged in the center area of the IP. And divergencies of Betatron radiations are much larger than electrons', as a result, electron shadows can only appear in the center area in the veritcal axis. The two rows of fiducials can help with calibrating the IP position relative to the source. According to the simple geometric relations, if there were errors in IP positions, either longitudinal or tranversal, the two rows of fiducials would produce two sets of crossing points. Then it is an obvious calibration by moving the IP position to make the two sets as one. The accuracy of this calibration can be calculated from the geometric relations. From our experiments, the waist of the Betatron radiation trajectories is usually couple hundreds of micro-meters. 


\section{Approximate trajectory method and accuracy analysis}
Traditionally, the motion of electrons in a dipole magnet can be simplified as in an uniform magnetic field, since the trajectory is not sensitive to the shape of the distribution but only to the total magnetic flux. In an uniform magnetic field, the trajectory is two straight lines in the free space connecting by an arc in the magnetic field. Here we proposed a further simplified method by assuming the field width to be infinitesimal, which keeping the total magentic flux constant. In this situation, the arc trajectory shrinked to a single point. The whole trajectory only consists of two straight lines connecting at the magnet position, or the center of the original magnetic field. The difference in the directions between the two lines is determined by electron energy, by the following equations,
\begin{equation}
x=a+b+y
\label{eq:[2].}
\end{equation}


\begin{equation}
p=\sqrt{E^{2}/c^{2}-m_{e}^{2}\ c^{2}}
\label{eq:[3].}
\end{equation}

This method is accurate in the case of high energy electron trajectories. For example,We built a simply equation to analyze the accuracy of the spectrometer base on this method. 
\begin{equation}
f(x)=a\ x^{2}+b\ x
\label{eq:[4].}
\end{equation}

The maximum accuracy of this kind of spectrometers (for example, two-screen spectrometers) can also be calculated. 
\begin{equation}
P\ V=n\ R\ T
\label{eq:[5].}
\end{equation}

We also developed a formula to calculate the spectrum image for electrons with any spectrums and any angular distributions. The calculated results were compared with GEANT4 simulations.


\section{Radiation method}
There may be a better design for high energy electron spectrometer base on bremsstrahlung radiations. Instead of fiducials, a thin Al foil can be put before the magnet to generate bremsstrahlung radiations. The X-rays will keep the electron launch angle before the magnet without deflected by the magnet, and will be recorded by the same IP. The distance from the radiation center to any points on the IP can reveal the deflection angle of electron through the magnet directly. It is impossible to make an accurate launch angle measurement with the Betatron radiation only, because: 1. the anguler spread of Betatron radiation is too large. 2. the direction of Betatron radiation is not necessarily same as the electrons.It is important to measure the X-rays and electrons on a same IP, because there will be no uncertainties on the relative separation between X-rays and electrons. The accuracy of this spectrometer is insensitive to the absolute position of the IP and the source (the Al foil position here). For example, .It can also be proved by the method introduced in the last section. The light element material is preferred, because it has less effects on the spectrum and angular profile of electrons. We also used GEANT4 to study the properties of Al foil scattering. In addition to keep the launch angle information, it also keeps the angular distribution according to GEANT4 simulations. It is even possible to retrieve the real spectrum of electrons from the convolution of divergencies, based on the formula in last section. Although it may be unnecessary. 


\section{Summary}






\nocite{*}

\bibliography{apssamp1}

\begin{filecontents}{apssamp1.bib}

@ARTICLE{参考1,
   author       = "K. Nakamura and W. Wan and N. Ybarrolaza and D. Syversrud and J. Wallig and W. P. Leemans",
   title        = "Broadband single-shot electron spectrometer for GeV-class laser-plasma-based accelerators",
   journal      = "Review of Scientific Instruments",
   volume       = "79", 
   pages        = "053301",
   year         = "2008",
}

\end{filecontents}

\end{document}
%
% ****** End of file apssamp.tex ******







## end
#231, 384:
"""


"""
+描述结构(_章节结构,_文本)->+操作(+描述结构,)...

->[]{
    []:->[is](_章节结构,一级标题)->一级标题(,)...
        ->+生成标题(一级标题,_文本)->+的(+操作,+生成标题),
    ->[is](_章节结构,文本)->文本(,)...
        ->+生成作者(文本,_文本)->+的(+操作,+生成作者),
    ->[is](_章节结构,_章节)->_章节->的(_章节,题目)->[==]"Abstract"(,题目)...
        ->+生成概述(_章节,_文本)->+的(+操作,+生成概述),
    ->[is](_章节结构,二级标题)->二级标题(,)...
        ->+生成章节(二级标题,_文本)->+的(+操作,+生成章节)
}



## end
#233, 60:


生成标题:...
生成作者:...
生成概述:...
生成章节:...

将'生成作者'的"章节"替换为"作者"


## end
#235, 144:
"""
L模板:...

"""

+生成标题(一级标题,_文本)->+[del](,+生成标题)...
->的(生成标题,L模板)...

->+的(_文本,+标题)...

->的(一级标题,题目)...
->+[模板文本](L模板,+标题)->+[.](+[模板文本],题目)



## end
#237, 199:
"""
L模板:...

"""

+生成概述(二级标题,_文本)->+[del](,+生成概述)...
->的(生成概述,L模板)...

->+的(_文本,+概述)...

->+[临时文本]->[]{
    []=>的(二级标题,文本)->文本=>+[增加内容2](文本,+[临时文本])
}...

->+[模板文本](L模板,+概述)->+[.](+[模板文本],+[临时文本])



## end
#239, 438:
"""
描述结构:...
库:...
L模板:...
+[新建阅读窗口](,描述结构)

"""

+生成章节(_章节,_文本)->+[del](,+生成章节)...
->的(生成章节,描述结构)->的(生成章节,库)...
->的(生成章节,L模板)...

->+的(_文本,+章节)...
->+[code]([想],描述结构)->[想](_章节,)...

->操作([想],)...
->+[临时文本]#内容->[]{
    []=>的(操作,_操作)->_操作(_主语,)->_主语(,)...
    =>[说](,_操作)->的(库,_条目)->[eq](_条目,_操作)...
    ->+[做](_主语,+[临时文本]#内容)->+[code](+[做],_条目)
}...

->的(_章节,题目)...
->+[模板文本](L模板,+章节)...
->+[.]"内容"(+[模板文本],+[临时文本]#内容)->+[.](+[模板文本],题目)


## end
#241, 31:
document.add_heading('%题目', 0)

## end
#243, 40:
p = document.add_paragraph('%[临时文本]\n')

## end
#245, 259:
"""


"""

+描述结构(_章节,)->+操作(+描述结构,)...

->[]{
    []=>的(_章节,_节点)->_节点=>[]:
        ->[is](_节点,文本)->文本->+文本结构(_节点,)->+的(+操作,+文本结构),
        ->[is](_节点,公式)->公式->+公式结构(_节点,)->+的(+操作,+公式结构),
        ->[is](_节点,图片)->图片->+图片结构(_节点,)->+的(+操作,+图片结构),
        ->[]
}


## end
#247, 33:


文本结构:...
公式结构:...
图片结构:...





## end
#249, 259:
"""
P代码:...
L模板:...

"""

+文本结构(_节点,_内容)->+[del](,+文本结构)...
->的(文本结构,L模板)->的(文本结构,P代码)...

->+[python](Python,+[临时文本]#内容)->+[code](+[python],P代码)...
->+[.]"text_pt"(+[python],_节点)...

->+[模板文本](L模板,+[增加内容2])->+[增加内容2](,_内容)...
->+[.]"内容"(+[模板文本],+[临时文本]#内容)


## end
#251, 330:
"""
P代码:...
L模板:...
保存L模板:...

"""

+公式结构(_节点,_内容)->+[del](,+公式结构)...
->的(公式结构,L模板)->的(公式结构,P代码)...

->的(_节点,名字)->的(_节点,LaTeX)...

->+[python](Python,+[临时文本]#LaTeX)->+[code](+[python],P代码)...
->+[.]"text_pt"(+[python],LaTeX)...

->+[模板文本](L模板,+[增加内容2])->+[增加内容2](,_内容)...
->+[.](+[模板文本],名字)->+[.]"LaTeX"(+[模板文本],+[临时文本]#LaTeX)




## end
#253, 370:
"""
P代码:...
L模板:...

"""

+图片结构(_节点,_内容)->+[del](,+图片结构)...
->的(图片结构,L模板)->的(图片结构,P代码)...

->的(_节点,名字)->的(_节点,图例)->的(_节点,源地址)...
->的(_节点,目标地址)...
->+[python](Python,目标地址)->+[code](+[python],P代码)...
->+[.]"source_dir"(+[python],源地址)->+[.]"fig_name"(+[python],名字)...

->+[模板文本](L模板,+[增加内容2])->+[增加内容2](,_内容)...
->+[.](+[模板文本],名字)->+[.](+[模板文本],图例)...
->+[.](+[模板文本],目标地址)

## end
#255, 42:
document.add_heading('%题目', level=1)
%内容


## end
#257, 44:
p = document.add_paragraph("""%LaTeX\n""")


## end
#259, 90:
document.add_picture('%目标地址', width=Inches(4.25))
p = document.add_paragraph("""%图例\n""")

## end
#261, 545:
"""
P代码:...
L模板:...

"""

+整理内容(_媒介,_内容)->+[del](,+整理内容)...
->的(整理内容,L模板)->的(整理内容,P代码)...

->+[临时文本]#章节->[]{
    []=>的(_内容,章节)->章节=>+[增加内容](章节,+[临时文本]#章节)
}...
->+[python](Python,+[临时文本]#章节)->+[code](+[python],P代码)...
->+[s]"file_text"(+[python],+[临时文本]#章节)...

->+[模板文本](L模板,_内容)...
->+[.]"章节"(+[模板文本],+[临时文本]#章节)...
->[]{
    []:->的(_内容,标题)->标题->+[.](+[模板文本],标题),->[]
}...
->[]{
    []:->的(_内容,作者)->作者->+[.](+[模板文本],作者),->[]
}...
->[]{
    []:->的(_内容,概述)->概述->+[.](+[模板文本],概述),->[]
}...
->[]{
    []:->的(_内容,引用)->引用->+[.](+[模板文本],引用),->[]
}



## end
#262, 223:
"""
Nini, 打开人体模型(文件)
Nini, 打开CBS(文件)

"""

+召唤规则(_媒介,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_凭依)...

->[==]"结构文本转LaTeX"(,召唤星辰)...
    ->+整理内容(_媒介,_凭依)->+的(操作,+整理内容)...

->[]{
    []=>的(_媒介,_章节)->_章节=>+章节内容(_章节,_凭依)->+的(操作,+章节内容)
}


## end
#264, 5238:
文本转换#0"

召唤规则:...
降临规则:...




"(,)
的#1""(文本转换#0,召唤规则#2)
召唤规则#2"\"\"\"
Nini, 打开人体模型(文件)
Nini, 打开CBS(文件)

\"\"\"

+召唤规则(_媒介,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_凭依)...

->[==]\"结构文本转LaTeX\"(,召唤星辰)...
    ->+整理内容(_媒介,_凭依)->+的(操作,+整理内容)...

->[]{
    []=>的(_媒介,_章节)->_章节=>+章节内容(_章节,_凭依)->+的(操作,+章节内容)
}

"(,)
的#3""(召唤规则#2,新窗口#4)
新窗口#4""(CBS,)
的#5""(新窗口#4,m_compiler#6)
m_compiler#6""(,compiler)
的#7""(新窗口#4,m_port#8)
m_port#8""(,端口)
的#9""(新窗口#4,m_event#10)
m_event#10""(,event)
的#11""(新窗口#4,m_readPtr#12)
m_readPtr#12""(,)
的#13""(新窗口#4,m_cursor#14)
m_cursor#14"10,10"(,)
的#15""(新窗口#4,m_x#16)
m_x#16"1"(,)
的#17""(新窗口#4,m_y#18)
m_y#18"38"(,)
的#19""(新窗口#4,m_height#20)
m_height#20"476"(,)
的#21""(新窗口#4,m_width#22)
m_width#22"957"(,)
的#23""(文本转换#0,降临规则#24)
降临规则#24"

章节内容:...
整理内容:...


"(,)
的#25""(降临规则#24,章节内容#26)
章节内容#26"\"\"\"
描述结构:...
库:...
+[新建阅读窗口](,库)

\"\"\"
+章节内容(_章节结构,_文本)->+[del](,+章节内容)...
->的(章节内容,描述结构)->的(章节内容,库)...

->+[code]([想],描述结构)->[想](_章节结构,_文本)...
->操作([想],)...
->[]{
    []=>的(操作,_操作)->_操作(_主语,_宾语)->_主语->_宾语(,)...
    =>[说](,_操作)...
        ->的(库,_条目)->_条目->[eq](_条目,_操作)->+[做](_主语,_宾语)->+[code](+[做],_条目)
}




"(,)
的#27""(章节内容#26,描述结构#28)
描述结构#28"\"\"\"


\"\"\"
+描述结构(_章节结构,_文本)->+操作(+描述结构,)...

->[]{
    []:->[is](_章节结构,一级标题)->一级标题(,)...
        ->+生成标题(一级标题,_文本)->+的(+操作,+生成标题),
    ->[is](_章节结构,_章节)->_章节->的(_章节,题目)->[==]\"Abstract\"(,题目)...
        ->+生成概述(_章节,_文本)->+的(+操作,+生成概述),
    ->[is](_章节结构,二级标题)->二级标题(,)...
        ->+生成章节(二级标题,_文本)->+的(+操作,+生成章节)
}


"(,)
的#29""(章节内容#26,库#30)
库#30"

生成标题:...
生成概述:...
生成章节:...



"(,)
的#31""(库#30,生成标题#32)
生成标题#32"\"\"\"
L模板:...

\"\"\"

+生成标题(一级标题,_文本)->+[del](,+生成标题)...
->的(生成标题,L模板)...

->+的(_文本,+标题)...

->的(一级标题,题目)...
->+[模板文本](L模板,+标题)->+[.](+[模板文本],题目)


"(,)
的#33""(生成标题#32,L模板#34)
L模板#34"\title{%题目}
"(,)
的#35""(库#30,生成概述#36)
生成概述#36"\"\"\"
L模板:...

\"\"\"

+生成概述(二级标题,_文本)->+[del](,+生成概述)...
->的(生成概述,L模板)...

->+的(_文本,+概述)...

->+[临时文本]->[]{
    []=>的(二级标题,文本)->文本=>+[增加内容2](文本,+[临时文本])
}...

->+[模板文本](L模板,+概述)->+[.](+[模板文本],+[临时文本])


"(,)
的#37""(生成概述#36,L模板#38)
L模板#38"\begin{abstract}
%[临时文本]
\end{abstract}
"(,)
的#39""(库#30,生成章节#40)
生成章节#40"\"\"\"
描述结构:...
库:...
L模板:...
+[新建阅读窗口](,描述结构)

\"\"\"

+生成章节(_章节,_文本)->+[del](,+生成章节)...
->的(生成章节,描述结构)->的(生成章节,库)...
->的(生成章节,L模板)...

->+的(_文本,+章节)...
->+[code]([想],描述结构)->[想](_章节,)...

->操作([想],)...
->+[临时文本]#内容->[]{
    []=>的(操作,_操作)->_操作(_主语,)->_主语(,)...
    =>[说](,_操作)->的(库,_条目)->[eq](_条目,_操作)...
        ->+[做](_主语,+[临时文本]#内容)->+[code](+[做],_条目)
}...

->的(_章节,题目)...
->+[模板文本](L模板,+章节)...
->+[.]\"内容\"(+[模板文本],+[临时文本]#内容)->+[.](+[模板文本],题目)

"(,)
的#41""(生成章节#40,描述结构#42)
描述结构#42"\"\"\"


\"\"\"

+描述结构(_章节,)->+操作(+描述结构,)...

->[]{
    []=>的(_章节,_节点)->_节点=>[]:
        ->[is](_节点,文本)->文本->+文本结构(_节点,)->+的(+操作,+文本结构),
        ->[is](_节点,公式)->公式->+公式结构(_节点,)->+的(+操作,+公式结构),
        ->[is](_节点,图片)->图片->+图片结构(_节点,)->+的(+操作,+图片结构),
        ->[]
}

"(,)
的#43""(生成章节#40,库#44)
库#44"

文本结构:...
公式结构:...
图片结构:...




"(,)
的#45""(库#44,文本结构#46)
文本结构#46"\"\"\"


\"\"\"

+文本结构(_节点,_内容)->+[del](,+文本结构)...

->+[增加内容2](_节点,_内容)

"(,)
的#47""(库#44,公式结构#48)
公式结构#48"\"\"\"
L模板:...

\"\"\"

+公式结构(_节点,_内容)->+[del](,+公式结构)...
->的(公式结构,L模板)...

->的(_节点,名字)->的(_节点,LaTeX)...
->+[模板文本](L模板,+[增加内容2])->+[增加内容2](,_内容)...
->+[.](+[模板文本],名字)->+[.](+[模板文本],LaTeX)

"(,)
的#49""(公式结构#48,L模板#50)
L模板#50"
\begin{equation}
%LaTeX
\label{eq:%名字}
\end{equation}

"(,)
的#51""(库#44,图片结构#52)
图片结构#52"\"\"\"
L模板:...

\"\"\"

+图片结构(_节点,_内容)->+[del](,+图片结构)...
->的(图片结构,L模板)...

->的(_节点,名字)->的(_节点,图例)...
->+[模板文本](L模板,+[增加内容2])->+[增加内容2](,_内容)...
->+[.](+[模板文本],名字)->+[.](+[模板文本],图例)

"(,)
的#53""(图片结构#52,L模板#54)
L模板#54"
\begin{figure}[b]
\includegraphics{fig_1}
\caption{\label{fig:%名字}%图例}
\end{figure}


"(,)
的#55""(生成章节#40,L模板#56)
L模板#56"
\section{%题目}
%内容

"(,)
的#57""(降临规则#24,整理内容#58)
整理内容#58"\"\"\"
L模板:...

\"\"\"

+整理内容(_媒介,_内容)->+[del](,+整理内容)...
->的(整理内容,L模板)...

->+[临时文本]#章节->[]{
    []=>的(_内容,章节)->章节=>+[增加内容](章节,+[临时文本]#章节)
}...
->+[模板文本](L模板,_内容)...
->+[.]\"章节\"(+[模板文本],+[临时文本]#章节)...
->[]{
    []:->的(_内容,标题)->标题->+[.](+[模板文本],标题),->[]
}...
->[]{
    []:->的(_内容,概述)->概述->+[.](+[模板文本],概述),->[]
}...

->+[设置结构](,_内容)...
->+[删除结构](,_内容)


"(,)
的#59""(整理内容#58,L模板#60)
L模板#60"\documentclass[%
 reprint,
%superscriptaddress,
%groupedaddress,
%unsortedaddress,
%runinaddress,
%frontmatterverbose, 
%preprint,
%preprintnumbers,
%nofootinbib,
%nobibnotes,
%bibnotes,
 amsmath,amssymb,
 aps,
%pra,
%prb,
%rmp,
%prstab,
%prstper,
%floatfix,
]{revtex4-2}

\usepackage{graphicx}% Include figure files
\usepackage{dcolumn}% Align table columns on decimal point
\usepackage{bm}% bold math
%\usepackage{hyperref}% add hypertext capabilities
%\usepackage[mathlines]{lineno}% Enable numbering of text and display math
%\linenumbers\relax % Commence numbering lines

%\usepackage[showframe,%Uncomment any one of the following lines to test 
%%scale=0.7, marginratio={1:1, 2:3}, ignoreall,% default settings
%%text={7in,10in},centering,
%%margin=1.5in,
%%total={6.5in,8.75in}, top=1.2in, left=0.9in, includefoot,
%%height=10in,a5paper,hmargin={3cm,0.8in},
%]{geometry}

\begin{document}

\preprint{APS/123-QED}

%标题
\date{\today}

%概述

\maketitle

%章节

\bibliography{apssamp}

\end{document}
%
% ****** End of file apssamp.tex ******






"(,)

## end
#266, 216:

from docx import Document
from docx.shared import Inches
from docx.oxml import parse_xml

document = Document()

%标题
p = document.add_paragraph('%作者\n')

%概述
%章节


document.add_page_break()
document.save('%地址')





## end
#268, 214:
"""
Nini, 打开人体模型(文件)

"""

+召唤规则(_媒介,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_凭依)...

->[==]"文本结构化"(,召唤星辰)...
    ->+整理结构(_媒介,_凭依)->+的(操作,+整理结构)...
    ->+分析段落(_媒介,_凭依)->+的(操作,+分析段落)...
    ->+简化内容(_媒介,_凭依)->+的(操作,+简化内容)




## end
#270, 10181:
文本结构化#0"

召唤规则:...
降临规则:...



"(,)
的#1""(文本结构化#0,降临规则#2)
降临规则#2"

简化内容:...
分析段落:...
整理结构:...

"(,)
的#3""(降临规则#2,简化内容#4)
简化内容#4"\"\"\"
P代码:...

\"\"\"
+简化内容(_媒介,_凭依)->+[del](,+简化内容)...
->的(简化内容,P代码)...

->+[python](Python,_凭依)->+[code](+[python],P代码)...
->+[s]\"text\"(+[python],_媒介)



"(,)
的#5""(简化内容#4,P代码#6)
P代码#6"\"\"\"
记住\"Python\"
print(re.sub(r'[\s]','','t e s t'))

\"\"\"

import re

i=0
j=0
ans=''
while True:
    if i+4<len(text) and text[i:i+4]=='<!--':
        i=i+4
        while True:
            if i+3<len(text) and text[i:i+3]=='-->':
                i+=3
                break
            elif i>=len(text):
                break
            else:
                i+=1
    else:
        ans+=text[i]

    if i<len(text)-1:
        i+=1
    else:
        break

ans=re.sub(r'<br>','\n',ans)
ans=re.sub(r'<i>','',ans)
ans=re.sub(r'</i>','',ans)
ans=re.sub(r'\n\s*\n','\n',ans)


\"\"\"
Nini, 打开词典(文件)
Nini, 打开公式分析器(文件)
记住\"Python\"

\"\"\""(,)
的#7""(降临规则#2,分析段落#8)
分析段落#8"\"\"\"
描述结构:...
库:...
Nini, 打开人体模型(文件)
+[新建阅读窗口](,描述结构)

\"\"\"
+分析段落(_媒介,_凭依)->+[del](,+分析段落)...
->的(分析段落,描述结构)->的(分析段落,库)...
->的(库,生成章节#0)...

->+[code]([想],描述结构)->[想](,_凭依)...
->结构([想],)...
->[]{
    []=>的(结构,章节)->章节->类型(章节,)...
    =>+的(_凭依,+章节)->[m_text](章节,+章节)->+是(章节,+章节)->+[del](,+是)...
        ->+[修改标题](,+章节)->[m_text](类型,+[修改标题])
}...

->操作([想],)...
->[]{
    []=>的(操作,生成章节)->生成章节(,章节)->章节->是(章节,_章节)...
    =>+[做](_媒介,_章节)->+[code](+[做],生成章节#0)
}


"(,)
的#9""(分析段落#8,库#10)
库#10"

生成章节:...





"(,)
的#11""(库#10,生成章节#12)
生成章节#12"\"\"\"
描述结构:...
库:...
+[新建阅读窗口](,描述结构)

保存:...
测试:...
+[新建阅读窗口](,测试)

\"\"\"

+生成章节(_媒介,_章节)->+[del](,+生成章节)...
->的(生成章节,描述结构)->的(生成章节,库)...

->+[code]([想],描述结构)->[想](,_章节)...
->结构([想],)...
->[]{
    []=>的(结构,章节)->章节->类型(章节,)...
    =>+的(_章节,+章节)->[m_text](章节,+章节)->+是(章节,+章节)->+[del](,+是)...
    ->+[修改标题](,+章节)->[m_text](类型,+[修改标题])...
    ->+[下一个](结构,+章节)->+下一个(结构,章节#0)->章节#0->+[del](,+下一个):
        ->头部(结构,)->+然后(章节#0,+章节)->+的(_章节,+然后),
        ->+头部(结构,)->+[del](,+头部)
}...

->操作([想],)...
->[]{
    []=>的(操作,_操作)->_操作(_主语,_宾语)->_主语->_宾语=>[说](,_操作)...
    ->的(库,_条目)->_条目->[eq](_条目,_操作)->是(_宾语,_节点)...
        ->+[做](_主语,_节点)->+[code](+[做],_条目)->+[.](+[做],_媒介)
}



"(,)
的#13""(生成章节#12,描述结构#14)
描述结构#14"\"\"\"
P代码:...
P代码2:...
段落:...

\"\"\"

+描述结构(,_凭依)->+[del](,+描述结构)...
->的(描述结构,P代码)->的(描述结构,P代码2)->的(描述结构,段落)...
->+操作(+描述结构,)->+结构(+描述结构,)...

->+[.]\"text_paper\"([python],_凭依)...
->+[code]([python],P代码)->[python](Python,)...

->+[.]([想],+操作)->+[.]([想],+结构)->+[code]([想],段落)...
->+不终止->+[code]([python]#2,P代码2)...

=>[python]#2(Python,+不终止)->[想](,_凭依)->章节([想],)->类型([想],)...
=>+的(+结构,+章节)->[m_text](章节,+章节)...
->+类型(+章节,)->[m_text](类型,+类型)...

->[]{
    []:->[==]\"图片\"(,类型)->+图片结构(_凭依,+章节)->+的(+操作,+图片结构),
    ->[==]\"公式\"(,类型)->+公式结构(_凭依,+章节)->+的(+操作,+公式结构),
    ->[]
}


"(,)
的#15""(描述结构#14,段落#16)
段落#16"\"\"\"
P代码:...
+[新建阅读窗口](,P代码)

\"\"\"

+段落(,_凭依)->.(+段落,操作)->.(+段落,结构)...
->的(段落,P代码)...

->+章节(+段落,)->+类型(+段落,)...
->+[o]\"text_sec\"([python],+章节)->+[o]\"type_sec\"([python],+类型)...
->+[code]([python],P代码)->[python](Python,)

"(,)
的#17""(段落#16,P代码#18)
P代码#18"\"\"\"


\"\"\"

state=True
while True:
    if list_i>=len(list_sec):
        type_sec='结束'
        break
    text_sec=list_sec[list_i]
    list_i+=1
    if text_sec!='':
        break

if type_sec=='结束':
    state=False
elif list_i==1:
    type_sec='题目'
elif len(text_sec)>4 and text_sec[0:4]=='%fig':
    type_sec='图片'
elif len(text_sec)>2 and text_sec[0:2]=='%[':
    type_sec='公式'
else:
    type_sec='文本'


"(,)
的#19""(描述结构#14,P代码#20)
P代码#20"\"\"\"
记住\"Python\"

\"\"\"


list_sec=text_paper.split('\n')
list_i=0
state=True


"(,)
的#21""(描述结构#14,P代码2#22)
P代码2#22"\"\"\"


\"\"\"

state=(list_i<len(list_sec))

"(,)
的#23""(生成章节#12,库#24)
库#24"

图片结构:...
公式结构:...
将条目\"图片结构\"复制为条目\"公式结构\"
将公式结构的\"图片\"替换为\"公式\"

"(,)
的#25""(库#24,公式结构#26)
公式结构#26"\"\"\"
描述结构:...
+[新建阅读窗口](,描述结构)

\"\"\"

+公式结构(_凭依,_公式)->+[del](,+公式结构)...
->的(公式结构,描述结构)...

->.(+公式结构,_媒介)...
->+[code]([想],描述结构)->[想](_媒介,_公式)...
->操作([想],)...
->的(操作,名字)->+的(_公式,+名字)->[m_text](名字,+名字)...
->的(操作,LaTeX)->+的(_公式,+LaTeX)->[m_text](LaTeX,+LaTeX)




"(,)
的#27""(公式结构#26,描述结构#28)
描述结构#28"\"\"\"
P代码:...
+[修改标题]\"收集公式\"(,收集图例)
+[删除结构](,收集公式)->+[del](,收集公式)

\"\"\"
+描述结构(_媒介,_公式)->+操作(+描述结构,)...
->的(描述结构,P代码)...

->+的(+操作,+名字)->+的(+操作,+LaTeX)...
->+[s]\"name_formula\"([python],_公式)->+[code]([python],P代码)...
->[python](Python,+名字)...

->的(_媒介,_表达式)->[标题](_表达式,)->[==](+名字,[标题])...
->[m_text](_表达式,+LaTeX)


"(,)
的#29""(描述结构#28,图例#30)
图例#30""(,)
的#31""(描述结构#28,P代码#32)
P代码#32"\"\"\"


\"\"\"

state=True
ans=name_formula[1:]




"(,)
的#33""(库#24,图片结构#34)
图片结构#34"\"\"\"
描述结构:...
库:...
+[新建阅读窗口](,描述结构)

\"\"\"

+图片结构(_凭依,_图片)->+[del](,+图片结构)...
->的(图片结构,描述结构)->的(图片结构,库)...

->.(+图片结构,_媒介)...
->+[code]([想],描述结构)->[想](,_图片)...
->操作([想],)...
->的(操作,名字)->+的(_图片,+名字)->[m_text](名字,+名字)...
->的(操作,图例)->+的(_图片,+图例)->[m_text](图例,+图例)...

->的(_媒介,_图片节点)->图片(_图片节点,)->[标题](_图片节点,)->[==]([标题],名字)...
->+的(_图片,+源地址)->[m_text](_图片节点,+源地址)...
->+的(_图片,+目标地址)...

->[]{
    []:->的(操作,结尾)->结尾(,_结尾)->然后(,_结尾)->+[左连](然后,_图片),
    ->[]
}...
->[]{
    []=>的(操作,删除)->删除(,_删除)=>+[del](,_删除)
}


"(,)
的#35""(图片结构#34,库#36)
库#36""(,)
的#37""(图片结构#34,描述结构#38)
描述结构#38"\"\"\"
收集图例:...
print(text_fig)

\"\"\"
+描述结构(,_图片)->+操作(+描述结构,)...
->的(描述结构,收集图例)...

->+的(+操作,+名字)->+的(+操作,+图例)...

->+[.]\"name_fig\"([python],_图片)->[python]\"text_fig=''
state=True\"(Python,)...

->+[.]([想],+操作)->+[code]([想],收集图例)->[想](,_图片)...

->+[o]\"name1\"([python]#2,+名字)->+[o]\"text_fig1\"([python]#2,+图例)...
->[python]#2\"name1=name
text_fig1=text_fig
state=True\"(Python,)


"(,)
的#39""(描述结构#38,收集图例#40)
收集图例#40"\"\"\"
P代码:...

\"\"\"

+收集图例(,_图片)->.(+收集图例,操作)...
->的(收集图例,P代码)...

->[]{
    []:->然后(_图片,_图例)->_图例->+[.]\"text_f\"([python],_图例)...
        ->+[code]([python],P代码)->[python](Python,)...
        ->+[.]([想],操作)->+[code]([想],收集图例)->[想](,_图例)...
        ->+删除(操作,然后)->+的(操作,+删除)...
        ->+删除(操作,_图例)->+的(操作,+删除),
    ->然后(_图片,_图例1)->_图例1->+结尾(,_图例1)->+的(操作,+结尾),
    ->[]
}


"(,)
的#41""(收集图例#40,P代码#42)
P代码#42"\"\"\"
记住\"Python\"

\"\"\"

state=True
name=name_fig[1:]

if text_f[0:4]=='Fig.':
    text_fig=text_f
elif text_f[0]=='(':
    text_fig+='\n'+text_f
else:
    state=False


"(,)
的#43""(描述结构#38,图例#44)
图例#44""(,)
的#45""(生成章节#12,保存#46)
保存#46"\"\"\"
描述结构:...
库:...
+[新建阅读窗口](,描述结构)


\"\"\"

+生成章节(_媒介,_章节)->+[del](,+生成章节)...
->的(生成章节,描述结构)->的(生成章节,库)...

->+[code]([想],描述结构)->[想](,_章节)...
->结构([想],)...
->[]{
    []=>的(结构,章节)->章节->类型(章节,)...
    =>+的(_章节,+章节)->[m_text](章节,+章节)->+是(章节,+章节)->+[del](,+是)...
    ->+[修改标题](,+章节)->[m_text](类型,+[修改标题])...
    ->[]{
        []:->上一个(结构,)->+上一个(结构,章节#0)->章节#0->+[del](,+上一个)...
            ->+[上一个](结构,+章节)->+然后(章节#0,+章节)->+的(_章节,+然后)...
            ->+[消息窗口]\"!!\"(,章节#0)->+[显示](,+然后),
        ->+[上一个](结构,+章节)
    }
}...

->操作([想],)...
->[]{
    []=>的(操作,_操作)->_操作(_主语,_宾语)->_主语->_宾语=>[说](,_操作)...
    ->的(库,_条目)->_条目->[eq](_条目,_操作)->是(_宾语,_节点)...
        ->+[做](_主语,_节点)->+[code](+[做],_条目)
}



"(,)
的#47""(生成章节#12,测试#48)
测试#48"+[设置结构](,测试)

有A, B和C

测试->的(测试,_A)->+[下一个A](测试,_A)->+下一个A(测试,_B)->+[显示](,_B)
测试->的(测试,_A)->+[下一个A](测试,_A)->+下一个A(测试,_B)->+[显示](,_A)

测试=>的(测试,_A)=>+[下一个A](测试,_A)->+下一个A(测试,_B)->+[显示](,_B)->+[del](,+下一个A)

测试=>的(测试,_A)=>+下一个A(测试,_B)->+[下一个A](测试,_A)->+[显示](,_B)->+[del](,+下一个A)


测试=>的(测试,_A)=>[]{
[]:->下一个A(测试,)->+下一个A(测试,_B)->_B->+[显示](,下一个A),
->+[下一个A](测试,_A)->+[显示](,_A)}

测试->+[下一个A](测试,C)=>的(测试,_A)=>[]{
[]:->+[下一个A](测试,_A)->+下一个A(测试,_B)->_B->+[显示](,_B),
->+[显示](,_A)}

测试->+[下一个A](测试,C)=>的(测试,_A)=>[]:
->下一个A(测试,)->+[下一个A](测试,_A)->+下一个A(测试,_B)->_B->+[显示](,_B),
->+[下一个A](测试,_A)->+[显示](,_A)


测试=>的(测试,_A)=>+[下一个A](测试,_A)...
->+下一个A(测试,_B)->+[del](,+下一个A)->[]:
->头部(测试,)->+[显示](,_A)->+[显示](,_B),
->+头部(测试,_A)


Nini, 打开结构语言Debug(文件)
测试=>的(测试,下一个A)=>+[del](,下一个A)"(,)
的#49""(测试#48,A#50)
A#50""(,)
的#51""(测试#48,B#52)
B#52""(,)
的#53""(测试#48,C#54)
C#54""(,)
的#55""(测试#48,头部#56)
头部#56""(测试#48,A#50)
的#57""(分析段落#8,描述结构#58)
描述结构#58"\"\"\"
P代码:...
P代码2:...
段落:...

\"\"\"

+描述结构(,_凭依)->+[del](,+描述结构)...
->的(描述结构,P代码)->的(描述结构,P代码2)->的(描述结构,段落)...
->+操作(+描述结构,)->+结构(+描述结构,)...

->+[.]\"text_paper\"([python],_凭依)...
->+[code]([python],P代码)->[python](Python,)...

->+[.]([想],+操作)->+[.]([想],+结构)->+[code]([想],段落)...
->+不终止->+[code]([python]#2,P代码2)...

=>[python]#2(Python,+不终止)->[想](,_凭依)->章节([想],)->类型([想],)...
=>+的(+结构,+章节)->[m_text](章节,+章节)...
->+类型(+章节,)->[m_text](类型,+类型)...

->[]{
    []:->[==]\"一级标题\"(,类型)->+生成章节(,+章节)->+的(+操作,+生成章节),
    ->[==]\"二级标题\"(,类型)->+生成章节(,+章节)->+的(+操作,+生成章节),
    ->[]
}


"(,)
的#59""(描述结构#58,P代码#60)
P代码#60"\"\"\"
记住\"Python\"

\"\"\"


list_sec=text_paper.split('\n')
list_i=0
state=True


"(,)
的#61""(描述结构#58,段落#62)
段落#62"\"\"\"
P代码:...
+[新建阅读窗口](,P代码)

\"\"\"

+段落(,_凭依)->.(+段落,操作)->.(+段落,结构)...
->的(段落,P代码)...

->+章节(+段落,)->+类型(+段落,)...
->+[o]\"text_sec\"([python],+章节)->+[o]\"type_sec\"([python],+类型)...
->+[code]([python],P代码)->[python](Python,)



"(,)
的#63""(段落#62,P代码#64)
P代码#64"\"\"\"


\"\"\"

state=True
while True:
    if list_i>=len(list_sec):
        type_sec='结束'
        break
    text_sec=list_sec[list_i]
    list_i+=1
    if text_sec!='':
        break

if type_sec=='结束':
    state=False
elif len(text_sec)>4 and text_sec[0:4]=='<h2>':
    text_sec=text_sec[4:]
    text_sec=text_sec[0:-5]
    type_sec='二级标题'
    while True:
        if list_i>=len(list_sec):
            break
        elif len(text_sec)>2 and list_sec[list_i][0:2]=='<h':
            break
        text_sec+=\"\n\"+list_sec[list_i]
        list_i+=1

elif len(text_sec)>4 and text_sec[0:4]=='<h1>':
    text_sec=text_sec[4:]
    text_sec=text_sec[0:-5]
    type_sec='一级标题'
else:
    type_sec='文本'


"(,)
的#65""(描述结构#58,P代码2#66)
P代码2#66"\"\"\"


\"\"\"

state=(list_i<len(list_sec))



"(,)
的#67""(降临规则#2,整理结构#68)
整理结构#68"\"\"\"


\"\"\"
+整理结构(,_凭依)->+[del](,+整理结构)...

->的(_凭依,召唤规则)->+[删除结构](,召唤规则)->+[del](,召唤规则)...
->的(_凭依,降临规则)->+[删除结构](,降临规则)->+[del](,降临规则)


"(,)
的#69""(文本结构化#0,召唤规则#70)
召唤规则#70"\"\"\"
Nini, 打开人体模型(文件)

\"\"\"

+召唤规则(_媒介,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_凭依)...

->[==]\"文本结构化\"(,召唤星辰)...
    ->+整理结构(_媒介,_凭依)->+的(操作,+整理结构)...
    ->+分析段落(_媒介,_凭依)->+的(操作,+分析段落)...
    ->+简化内容(_媒介,_凭依)->+的(操作,+简化内容)



"(,)

## end
#272, 293:
"""


"""
+整理结构(,_凭依)->+[del](,+整理结构)...

->的(_凭依,召唤规则)->+[删除结构](,召唤规则)->+[del](,召唤规则)...
->的(_凭依,降临规则)->+[删除结构](,降临规则)->+[del](,降临规则)...

=>的(_凭依,二级标题)->二级标题=>[]:
->上一个(+整理结构,)->+上一个(+整理结构,_章节)->_章节->+[del](,+上一个)...
    ->+[上一个](+整理结构,二级标题)->+然后(_章节,二级标题)->+的(_凭依,+然后),
->+[上一个](+整理结构,二级标题)

## end
#274, 428:
"""
描述结构:...
库:...

"""

+生成作者(_作者,_文本)->+[del](,+生成作者)...
->的(生成作者,描述结构)->的(生成作者,库)...
->的(库,通讯作者)->的(库,普通作者)...

->+的(_文本,+作者)...
->+[code]([想],描述结构)->[想](_作者,)...

->操作([想],)...
->+[临时文本]#内容->[]{
    []=>的(操作,作者)->作者(类型,)->类型(,)...
    =>+[获取作者信息](,+作者A)->[m_text](作者,+[获取作者信息])...
    ->+[做](+作者A,+作者)...
    ->+[删除结构](,+作者A)->+[del](,+作者A)->[]:
        ->[==]"通讯"(,类型)->+[code](+[做],通讯作者),
        ->+[code](+[做],普通作者)
}



## end
#276, 40:


通讯作者:...
普通作者:...
将'普通作者'的"通讯"替换为"普通"

## end
#278, 347:
"""
P代码:...
P代码2:...

"""

+描述结构(_作者,)->+操作(+描述结构,)...
->的(描述结构,P代码)->的(描述结构,P代码2)...

->+[.]"text_au"([python],_作者)...
->+[code]([python],P代码)->[python](Python,)...
->+[code]([python]#2,P代码2)...

->+不终止=>[python]"state=(list_i<len(list_au))"(Python,+不终止)...
=>+的(+操作,+作者)->+作者(+类型,)...
->+[o]"type_name"([python]#2,+类型)->[python]#2(Python,+作者)



## end
#280, 70:
"""
记住"Python"

"""

state=True
list_au=text_au.split(', ')
list_i=0


## end
#282, 134:
"""


"""

name=list_au[list_i]
list_i+=1
if name[-1]=='*':
    name=name[0:-1]
    type_name='通讯'
else:
    type_name="普通"
ans=name


## end
#284, 230:
"""
L模板:...

"""
+通讯作者(_A,_输出)->+[del](,+通讯作者)...
->的(通讯作者,L模板)...

->的(_A,名)->的(_A,姓)->的(_A,单位)->的(_A,邮箱)...

->+[模板文本](L模板,+[增加内容2])->+[增加内容2](,_输出)...
->+[.](+[模板文本],名)->+[.](+[模板文本],姓)...
->+[.](+[模板文本],单位)->+[.](+[模板文本],邮箱)


## end
#286, 212:
"""
L模板:...

"""
+普通作者(_A,_输出)->+[del](,+普通作者)...
->的(普通作者,L模板)...

->的(_A,名)->的(_A,姓)->的(_A,单位)->的(_A,邮箱)...

->+[模板文本](L模板,+[增加内容2])->+[增加内容2](,_输出)...
->+[.](+[模板文本],名)->+[.](+[模板文本],姓)...
->+[.](+[模板文本],单位)


## end
#288, 8:
%名 %姓*, 
## end
#290, 7:
%名 %姓, 
## end
#292, 426:
"""
描述结构:...
设置引用:...
+[新建阅读窗口](,描述结构)

"""

+引用文章(_文章,_文本)->+[del](,+引用文章)...
->的(引用文章,描述结构)->的(引用文章,设置引用)...

->+的(_文本,+引用)...
->+[code]([想],描述结构)->[想](_文章,)...

->操作([想],)...
->+[临时文本]#内容->[]{
    []=>的(操作,文章)->文章(_节点,)->_节点(,)...
    =>+[获取论文信息](+[临时文本],+文章A)->[m_text](文章,+[临时文本])...
        ->[标题](_节点,)->[m_text]([标题],+文章A)...
        ->+[做](+文章A,+引用)->+[code](+[做],设置引用)...
        ->+[删除结构](,+文章A)->+[del](,+文章A)
}



## end
#294, 203:
"""
P代码:...

"""

+描述结构(_文章,)->+操作(+描述结构,)...
->的(描述结构,P代码)...

=>的(_文章,_节点)->引用(_节点,)...
=>+的(+操作,+文章)->+文章(_节点,)...
->+[.]"paper_link"([python],_节点)->+[code]([python],P代码)...
->[python](Python,+文章)




## end
#296, 61:
"""
记住"Python"

"""

ans=paper_link.split('#')[0]
state=True

## end
#298, 505:
"""
P代码:...
模板库:...

"""

+设置引用(文章A,引用)->+[del](,+设置引用)...
->的(设置引用,模板库)->的(设置引用,P代码)...

->的(文章A,类型)->的(文章A,作者)...
->+[python](Python,作者)->+[code](+[python],P代码)...
->+[s]"text_aus"(+[python],作者)...

->+[模板文本](,+[增加内容2])->+[增加内容2](,引用)...
->[]{
    []:->[==]"ARTICLE"(,类型)->的(模板库,文章#0)->+[code](+[模板文本],文章#0),
    ->[==]"PROCEEDING"(,类型)->的(模板库,会议#0)->+[code](+[模板文本],会议#0),
    ->的(模板库,文章#1)->+[code](+[模板文本],文章#1)
}...

->+[.]"引用名"(+[模板文本],文章A)...
->[]{
    []=>的(文章A,_性质)->_性质=>+[.](+[模板文本],_性质)
}




## end
#300, 66:
file:///C:/Users/cheng/Desktop/paper/Spectrometer/Nak08.pdf#page=1
## end
#304, 18:


文章:...
会议:...



## end
#306, 169:

@ARTICLE{%引用名,
   author       = "%作者",
   title        = "%标题",
   journal      = "%期刊",
   volume       = "%编号", 
   pages        = "%页数",
   year         = "%年份",
}

## end
#308, 211:

@PROCEEDINGS{%引用名,
   title = "%标题",
   number = "%编号",
   editor = "", 

   series = "All ACM Conferences",
   month = "",
   year = "%年份",
   address = "%地址",
   organization = "%组织",
   publisher = "%会议",
}

## end
#310, 154:
"""
记住"Python"

"""

# print(text_aus)
# print(text_aus.split(', '))
# print(' and '.join(text_aus.split(', ')))
ans=' and '.join(text_aus.split(', '))



## end
#312, 88:
C:\Users\cheng\Dropbox\Struct\Structure1.2.1\Nini\output\paper\spectrometer\SecII\F1.png
## end
#315, 95:
C:\Users\cheng\Dropbox\Struct\Structure1.2.1\Nini\output\paper\spectrometer\two_screen\fig6.png
## end
#318, 102:
C:\Users\cheng\Dropbox\Struct\Structure1.2.1\Nini\output\paper\spectrometer\13975\calibration\fig1.png
## end
#321, 90:
C:\Users\cheng\Dropbox\Struct\Structure1.2.1\Nini\output\paper\spectrometer\SecIV\fig1.png
## end
#324, 90:
C:\Users\cheng\Dropbox\Struct\Structure1.2.1\Nini\output\paper\spectrometer\SecIV\fig2.png
## end
#327, 165:
"""
记住"Python"
print(source_dir.replace('\\','\\\\'))

"""

fig_type=source_dir.split('.')[-1]
# ans='\\'+fig_name+'.'+fig_type
ans=source_dir.replace('\\','\\\\')


## end
#329, 373:
"""
P代码:...
P代码2:...

"""

+整理图片(_媒介,_凭依)->+[del](,+整理图片)...
->的(整理图片,P代码)->的(整理图片,P代码2)...

->的#0(_凭依,地址)->+[标题](_凭依,)...
->+[python](Python,+[临时文本])->+[code](+[python],P代码)...
->+[.]"file_name"(+[python],+[标题])->+[.]"folder_dir"(+[python],地址)...

->+[模板文本](_凭依,_凭依)->+[.]"地址"(+[模板文本],+[临时文本])...
->+[P函数](,_凭依)...

->+[del](,的#0)...
->+[删除结构](,_凭依)...
->+[有](_凭依,地址)





## end
#331, 88:
"""


"""


output_dir="%s\\text.docx"%(folder_dir)
ans=output_dir.replace('\\','\\\\')

## end
#333, 204:
"""
import shutil
shutil.copy(src_dir,"%s\\fig.png"%(folder_dir))

"""

import shutil
# print(src_dir,tar_dir)
# ans="%s\%s.tex"%(folder_dir,file_name)
shutil.copy(src_dir,"%s\\%s"%(folder_dir,tar_dir))


## end
#334, 151:
Compact high-resolution multi-GeV electron spectrometer for PW-laser-driven plasma accelerators and approximate trajectory method for spectrum analysis
## end
#336, 28:
Xiantao, Aaron, Rafal, Mike*
## end
#338, 592:
Abstract
For the past decade, laser-plasma accelerators (LPAs) of ~ mm to ~ cm length have provided compact sources of nearly mono-energetic, highly directional electron bunches with energy as high as 1 GeV.  With the advent of petawatt scale lasers, these accelerators are now poised to go well beyond 1GeV energies.  In contrast to the large scale accelerator facilities, the LPA’s will be compact devices, requiring compact electron spectrometers adapted to the unique properties of the LPA electron bunches.  We report a compact high resolution spectrometer adapted to these conditions.  
## end
#340, 3000:
Introduction
For the past decade, laser-plasma accelerators (LPAs) of ~ mm to ~ cm length have provided compact sources of nearly mono-energetic, highly directional electron bunches [Esa09] with energy as high as 1 GeV [Lee06].  The electron energy spectrum is generally measured with a standard magnetic spectrometer, in which a dipole magnetic field of typically ~1 T over cm dimensions, readily available from commercially available permanent magnets, deflects the trajectories of electrons emerging from the LPA [Nakamura07].  The deflected electrons are then detected 10 to 100 cm downstream of the magnet on a fluorescing screen, thereby mapping electron energy to displacement on the detector.  Because of the low angular divergence (typically a few mrad) of electrons from quasi-mono-energetic LPAs and the relatively large deflection angles (typically > 10o) of sub-GeV electrons achievable with small permanent magnets, the angular spread of electrons entering the magnetic field has played a minor role in the energy analysis of LPA electrons, except for energies approaching ~ 1 GeV [Pollock09, Clayton10]. 
The recent emergence of PW-class lasers has now ushered in a new era of quasi-mono-energetic laser-plasma acceleration (LPA) to multi-GeV electron bunches [Wang13, Kim13].  This new range of electron energy raises new challenges to the accurate measurement of electron energy, because the deflection angle becomes comparable to the initial angular spread.  For example, a 5 GeV electron bends only ??? mrad in a 1 T field of 5 cm extent.  An uncertainty of ?? mrad in the electron launch angle from the LPA can therefore result in uncertainty in the energy approaching 100%. The possibilities of energy-dependent launch angles and of uncertainty in the launch location due to multi-cm length of multi-GeV LPAs further complicate the analysis.  A brute force solution to these problems is to use stronger and/or larger magnets.  However, this compromises the principal virtues of LPAs – compactness and low expense. 
In this paper, we present an electron spectrometer suitable for PW LPA experiments that measures the energy spectrum of multi-GeV electrons with an accuracy of a few percent using permanent magnets no larger or more expensive than those typical of sub-GeV electron spectrometers.  Our spectrometer builds upon a “two-screen” concept introduced by [Pollock09, Clayton10] to deconvolve launch angle variations from energy variations... [summary description].  However, our spectrometer goes well beyond the two-screen method  [describe how].  The paper is organized as follows:  Section 2 provides an overview of the problem of multi-GeV electron energy analysis. Section 3 describes the set-up of our spectrometer, and analyzes the interaction of electrons and x-rays with its key components.  Section 4 presents an analysis of electron energy spectra for several shots with different characteristics.  Section 5 discusses.  Section 6 summarizes the main findings. 
## end
#342, 2079:
Two-screen method problem
The two-screen method is one of the most popular ways to measure LWFA electrons. In this method, electrons were usually deflected by a permanent dipole magnet and imaged by two screens at different locations after the magnet. 
In theory, any electron trajectories could be determined uniquely by three points in the space. 
In reality, the features on two screens might not be comparable, because of the divergency of electrons which always existed. For example, the electron beams could be a single peak image on the first screen, which it might be two peaks on the second screen. 
On the other hand, it is very important to find the correct correlated points on the screens to measure the spectrum of high energy electrons. A small error in the position measure would cause large errors in the spectrum measure, especially when the energy reaching \(10\ GeV\) level. 
For example, in the simulation, the IP2 was separated from the magnet by 800 mm and the IP1was separated by 3000 mm. The real spectrum had two peaks. The center of one was at \(E_1=10\ GeV\), and the other one was at \(E_2=3.7\ GeV\). The divergencies of the electrons were \(\sigma=3.0\ mrad\). 
There was two peaks on the IP1, while only one peak showed on the IP2. 
%fig.1_
Fig.1. (a) is the setup of a typical two-screen spectrometer. (a1) is the real spectrum of electrons. (a2) is the image on the IP2 screen. (a3) is the image on the IP1 screen. (a2) and (a3) are obtained from a GEANT4 simulation. 
(b) shows the intensity curves on both screens. The intensity is integrated over the Y-axis.
If we used the maximum point on the IP2 and the maximum point on the IP1 to define the trajectory, the energy of the trajectory would be \(18.56\ GeV\), while the real energy should be \(10\ GeV\).
As a result, we proposed a new design of spectrometer by using two sets of Tungsten fiducials with an image plate, instead of two screens. The fiducial would scatter electrons going through it and leaving a shadow on the image plate, which would provide two points on the trajectories.
## end
#344, 1550:
Experiment setup
In the experiments, the dipole magnet was placed 143.5 mm behind the gas cell. The magnetic field was equal to 1.48 T with 50 mm for the width. 
The <band> SR image plate (IP) was place 2672 mm after the magnet. The pixel size for the image plate was 50 um. The IP was scanned by XX, after every shot. 
Both sets of fiducials were consisted of 8 Tungsten wires with 0.127 mm for the diameter. The first set of fiducial was away from the IP by 1442 mm, which was closer to the magnet and the second set of fiducials are 934 mm from the IP, which was closer to the IP. 
The experiment setup is showed in the fig.3.
%fig.3_
<LWFA parameters>
There were many things done to increase the position measurement accuracies of different components. 
Two sets of fiducials were attach with the image plate holder by a stainless steel frame to increase the accuracy of position measurement. The accuracies of positions for fiducials and IP holder were XX mm. 
Fiducials were Tungsten wires, because the heavy element material could scatter more electrons with a small diameter shape. GEANT4 simulations were used to help us study the properties of electrons scattering, which will be discussed in the next Sec.
The source locations could shifted randomly because of the laser pointing drifting. The IP position could also changed, because of the small gap between the holder and the IP. Those uncertainties were unavoidable, so we proposed a Betatron shadow calibration to calibrate both of locations. It will be discussed in the next next Sec.
## end
#346, 3282:
Fiducial electrons scattering
For fiducial design, it is a tradeoff to project a thin shadow and a high constrast one. To project high constrast shadows, the fiducials need to be thick enough to scatter electrons by a large angle, while it needs to be thin to make the shadow thin as well. As a result, a heavy element material, for example Tungsten, is preferred. 
Both the angular spread and the energy spread will affect the shadow constrast, which might be very different for different electron source. But the most fundamental requirement for the shadow formation is that the electrons scattered by fiducials should fall into pixels on the IP other than the original pixel. 
We studied the scattering of electrons with different energy by different diameter of Tungsten wires by GEANT4 simulations. For monoenergetic electron inputs, the angular distributions of scattered electrons are Gaussian distributions, according to simluations. 
The standard deviation of the distribution is a function of the input energy. The functions were found through simulations and results were showed in fig.4. 
%fig.4_
Fig.4. (a) shows \(\sigma\) as functions of E. Tungsten wires with diameter, D=0.050 mm, 0.127 mm, 0.200 mm, 0.400 mm and 0.800 mm were studied.
(b) is one of simulation results. 10 GeV electrons were scattered by a 0.127 mm Tungsten wire in this simulation. The figure shows the angular distribution of scattered electrons. The dots are simulation data, and the solid line is a Gaussian function, which is \(g(\theta)=A\ exp(-\theta^2/\sigma^2)\).
For 0.127 Tungsten wires, the standard deviation \(\sigma\) as a function of input energy can be expressed as following,
%[1].
The shadow shape was also studied by simulations. The results were showed in fig.5. From the simulation, we learned that the shadow shape was determined by the divergency, \(\sigma\), v.s. the pixel size, \(\Delta\), over the separation, \(L\), between the wire and the IP. 
To obtain a clear shadow on the IP, the condition is,
%[0].
%fig.5_
Fig.5. the shadow shapes of a 0.127 mm Tungsten wire were studied for different spectrums and different wire positions. It was Gaussian spectrum for all simulation. The peak energies were 4.313 GeV, 8.67 GeV, 17.55 GeV, 36.0 GeV and 75.9 GeV for (i1)-(i5), wihch were corresponding to \(\sigma\)=0.8, 0.4, 0.2, 0.1 and 0.05 mrad. 
The pixel size was 0.05 mm in simulations. Let's say the separation between the wire and the IP is L. Then L=500 mm, 250 mm and 125 mm for (a)'s, (b)'s and (c)'s, which corresponding to \(\Delta\)/L=0.1, 0.2 and 0.4 mrad. 
In fact, the shadow shape is different for different electron energies. 
For low-energy electrons, a fiducial projected a pit on the spectrum image. But for high-energy electrons, there were two peaks around the pit, which weren't there in the original spectrum. 
The explanation is the high-energy electrons were scattered within a small angular range. Most of electrons were still falling on the IP around their original positions. Although in the origianl position, the intensity was lower, those places around the shadow had higher intensity, because the scattered electrons added intensity to those areas. 
This phenomenon can be an evident of high energy electrons observation in a experiment. 
## end
#348, 1540:
Betatron calibration
LWFA electrons always came with Betatron radiations because of the oscillation caused by the focusing field. Since the most of Betatron radiations were generated by electrons in the end of acceleration process, the radiation sources were also the sources of electrons. 
The SR IP is also able to record the X-ray intensities, and the same sets of fiducials also block X-rays from Betatron radiations leaving shadows on the IP. It is straight forward to connect fiducials and their correlated shadows, and to locate the source by crossing points of all trajectories. 
The X-ray shadows are distinguishable from electron shadows, because the image of Betatron radiations are distinguishable from electrons. X-rays are not deflected by the magnet and will be imaged in the center area of the IP. And divergencies of Betatron radiations are much larger than electrons', as a result, electron shadows can only appear in the center area in the veritcal axis. 
The two rows of fiducials can help with calibrating the IP position relative to the source. According to the simple geometric relations, if there were errors in IP positions, either longitudinal or tranversal, the two rows of fiducials would produce two sets of crossing points. Then it is an obvious calibration by moving the IP position to make the two sets as one. The accuracy of this calibration can be calculated from the geometric relations. 
From our experiments, the waist of the Betatron radiation trajectories is usually couple hundreds of micro-meters. 
## end
#350, 1368:
Approximate trajectory method and accuracy analysis
Traditionally, the motion of electrons in a dipole magnet can be simplified as in an uniform magnetic field, since the trajectory is not sensitive to the shape of the distribution but only to the total magnetic flux. In an uniform magnetic field, the trajectory is two straight lines in the free space connecting by an arc in the magnetic field. 
Here we proposed a further simplified method by assuming the field width to be infinitesimal, which keeping the total magentic flux constant. In this situation, the arc trajectory shrinked to a single point. The whole trajectory only consists of two straight lines connecting at the magnet position, or the center of the original magnetic field. 
The difference in the directions between the two lines is determined by electron energy, by the following equations,
%[2].
%[3].
This method is accurate in the case of high energy electron trajectories. For example,
We built a simply equation to analyze the accuracy of the spectrometer base on this method. 
%[4].
The maximum accuracy of this kind of spectrometers (for example, two-screen spectrometers) can also be calculated. 
%[5].
We also developed a formula to calculate the spectrum image for electrons with any spectrums and any angular distributions. The calculated results were compared with GEANT4 simulations.
## end
#352, 1595:
Radiation method
There may be a better design for high energy electron spectrometer base on bremsstrahlung radiations. Instead of fiducials, a thin Al foil can be put before the magnet to generate bremsstrahlung radiations. The X-rays will keep the electron launch angle before the magnet without deflected by the magnet, and will be recorded by the same IP. The distance from the radiation center to any points on the IP can reveal the deflection angle of electron through the magnet directly. 
It is impossible to make an accurate launch angle measurement with the Betatron radiation only, because: 1. the anguler spread of Betatron radiation is too large. 2. the direction of Betatron radiation is not necessarily same as the electrons.
It is important to measure the X-rays and electrons on a same IP, because there will be no uncertainties on the relative separation between X-rays and electrons. The accuracy of this spectrometer is insensitive to the absolute position of the IP and the source (the Al foil position here). For example, .
It can also be proved by the method introduced in the last section. 
The light element material is preferred, because it has less effects on the spectrum and angular profile of electrons. We also used GEANT4 to study the properties of Al foil scattering. 
In addition to keep the launch angle information, it also keeps the angular distribution according to GEANT4 simulations. 
It is even possible to retrieve the real spectrum of electrons from the convolution of divergencies, based on the formula in last section. Although it may be unnecessary. 
## end
#354, 8:
Summary

## end
#356, 7:
Summary
## end
#358, 16:
Radiation method
## end
#362, 478:
There may be a better design for high energy electron spectrometer base on bremsstrahlung radiations. Instead of fiducials, a thin Al foil can be put before the magnet to generate bremsstrahlung radiations. The X-rays will keep the electron launch angle before the magnet without deflected by the magnet, and will be recorded by the same IP. The distance from the radiation center to any points on the IP can reveal the deflection angle of electron through the magnet directly. 
## end
#366, 243:
It is impossible to make an accurate launch angle measurement with the Betatron radiation only, because: 1. the anguler spread of Betatron radiation is too large. 2. the direction of Betatron radiation is not necessarily same as the electrons.
## end
#370, 304:
It is important to measure the X-rays and electrons on a same IP, because there will be no uncertainties on the relative separation between X-rays and electrons. The accuracy of this spectrometer is insensitive to the absolute position of the IP and the source (the Al foil position here). For example, .
## end
#374, 68:
It can also be proved by the method introduced in the last section. 
## end
#378, 186:
The light element material is preferred, because it has less effects on the spectrum and angular profile of electrons. We also used GEANT4 to study the properties of Al foil scattering. 
## end
#382, 122:
In addition to keep the launch angle information, it also keeps the angular distribution according to GEANT4 simulations. 
## end
#386, 171:
It is even possible to retrieve the real spectrum of electrons from the convolution of divergencies, based on the formula in last section. Although it may be unnecessary. 
## end
#388, 51:
Approximate trajectory method and accuracy analysis
## end
#392, 346:
Traditionally, the motion of electrons in a dipole magnet can be simplified as in an uniform magnetic field, since the trajectory is not sensitive to the shape of the distribution but only to the total magnetic flux. In an uniform magnetic field, the trajectory is two straight lines in the free space connecting by an arc in the magnetic field. 
## end
#396, 346:
Here we proposed a further simplified method by assuming the field width to be infinitesimal, which keeping the total magentic flux constant. In this situation, the arc trajectory shrinked to a single point. The whole trajectory only consists of two straight lines connecting at the magnet position, or the center of the original magnetic field. 
## end
#400, 116:
The difference in the directions between the two lines is determined by electron energy, by the following equations,
## end
#404, 5:
%[2].
## end
#408, 5:
%[3].
## end
#412, 86:
This method is accurate in the case of high energy electron trajectories. For example,
## end
#416, 92:
We built a simply equation to analyze the accuracy of the spectrometer base on this method. 
## end
#420, 5:
%[4].
## end
#424, 115:
The maximum accuracy of this kind of spectrometers (for example, two-screen spectrometers) can also be calculated. 
## end
#428, 5:
%[5].
## end
#432, 185:
We also developed a formula to calculate the spectrum image for electrons with any spectrums and any angular distributions. The calculated results were compared with GEANT4 simulations.
## end
#434, 12:
P\ V=n\ R\ T
## end
#436, 4:
[5].
## end
#438, 18:
f(x)=a\ x^{2}+b\ x
## end
#440, 4:
[4].
## end
#442, 37:
p=\sqrt{E^{2}/c^{2}-m_{e}^{2}\ c^{2}}
## end
#444, 4:
[3].
## end
#446, 7:
x=a+b+y
## end
#448, 4:
[2].
## end
#450, 20:
Betatron calibration
## end
#454, 269:
LWFA electrons always came with Betatron radiations because of the oscillation caused by the focusing field. Since the most of Betatron radiations were generated by electrons in the end of acceleration process, the radiation sources were also the sources of electrons. 
## end
#458, 296:
The SR IP is also able to record the X-ray intensities, and the same sets of fiducials also block X-rays from Betatron radiations leaving shadows on the IP. It is straight forward to connect fiducials and their correlated shadows, and to locate the source by crossing points of all trajectories. 
## end
#462, 386:
The X-ray shadows are distinguishable from electron shadows, because the image of Betatron radiations are distinguishable from electrons. X-rays are not deflected by the magnet and will be imaged in the center area of the IP. And divergencies of Betatron radiations are much larger than electrons', as a result, electron shadows can only appear in the center area in the veritcal axis. 
## end
#466, 449:
The two rows of fiducials can help with calibrating the IP position relative to the source. According to the simple geometric relations, if there were errors in IP positions, either longitudinal or tranversal, the two rows of fiducials would produce two sets of crossing points. Then it is an obvious calibration by moving the IP position to make the two sets as one. The accuracy of this calibration can be calculated from the geometric relations. 
## end
#470, 115:
From our experiments, the waist of the Betatron radiation trajectories is usually couple hundreds of micro-meters. 
## end
#472, 29:
Fiducial electrons scattering
## end
#476, 335:
For fiducial design, it is a tradeoff to project a thin shadow and a high constrast one. To project high constrast shadows, the fiducials need to be thick enough to scatter electrons by a large angle, while it needs to be thin to make the shadow thin as well. As a result, a heavy element material, for example Tungsten, is preferred. 
## end
#480, 313:
Both the angular spread and the energy spread will affect the shadow constrast, which might be very different for different electron source. But the most fundamental requirement for the shadow formation is that the electrons scattered by fiducials should fall into pixels on the IP other than the original pixel. 
## end
#484, 262:
We studied the scattering of electrons with different energy by different diameter of Tungsten wires by GEANT4 simulations. For monoenergetic electron inputs, the angular distributions of scattered electrons are Gaussian distributions, according to simluations. 
## end
#488, 157:
The standard deviation of the distribution is a function of the input energy. The functions were found through simulations and results were showed in fig.4. 
## end
#492, 7:
%fig.4_
## end
#496, 120:
For 0.127 Tungsten wires, the standard deviation \(\sigma\) as a function of input energy can be expressed as following,
## end
#500, 5:
%[1].
## end
#504, 274:
The shadow shape was also studied by simulations. The results were showed in fig.5. From the simulation, we learned that the shadow shape was determined by the divergency, \(\sigma\), v.s. the pixel size, \(\Delta\), over the separation, \(L\), between the wire and the IP. 
## end
#508, 53:
To obtain a clear shadow on the IP, the condition is,
## end
#512, 5:
%[0].
## end
#516, 7:
%fig.5_
## end
#520, 222:
The pixel size was 0.05 mm in simulations. Let's say the separation between the wire and the IP is L. Then L=500 mm, 250 mm and 125 mm for (a)'s, (b)'s and (c)'s, which corresponding to \(\Delta\)/L=0.1, 0.2 and 0.4 mrad. 
## end
#524, 72:
In fact, the shadow shape is different for different electron energies. 
## end
#528, 190:
For low-energy electrons, a fiducial projected a pit on the spectrum image. But for high-energy electrons, there were two peaks around the pit, which weren't there in the original spectrum. 
## end
#532, 347:
The explanation is the high-energy electrons were scattered within a small angular range. Most of electrons were still falling on the IP around their original positions. Although in the origianl position, the intensity was lower, those places around the shadow had higher intensity, because the scattered electrons added intensity to those areas. 
## end
#536, 88:
This phenomenon can be an evident of high energy electrons observation in a experiment. 
## end
#538, 101:
C:\\Users\\cheng\\Dropbox\\Struct\\Structure1.2.1\\Nini\\output\\paper\\spectrometer\\SecIV\\fig2.png
## end
#540, 90:
C:\Users\cheng\Dropbox\Struct\Structure1.2.1\Nini\output\paper\spectrometer\SecIV\fig2.png
## end
#542, 330:
Fig.5. the shadow shapes of a 0.127 mm Tungsten wire were studied for different spectrums and different wire positions. It was Gaussian spectrum for all simulation. The peak energies were 4.313 GeV, 8.67 GeV, 17.55 GeV, 36.0 GeV and 75.9 GeV for (i1)-(i5), wihch were corresponding to \(\sigma\)=0.8, 0.4, 0.2, 0.1 and 0.05 mrad. 
## end
#544, 6:
fig.5_
## end
#546, 14:
E=m_{e}\ c^{2}
## end
#548, 4:
[0].
## end
#550, 3:
x=1
## end
#552, 4:
[1].
## end
#554, 101:
C:\\Users\\cheng\\Dropbox\\Struct\\Structure1.2.1\\Nini\\output\\paper\\spectrometer\\SecIV\\fig1.png
## end
#556, 90:
C:\Users\cheng\Dropbox\Struct\Structure1.2.1\Nini\output\paper\spectrometer\SecIV\fig1.png
## end
#558, 448:
Fig.4. (a) shows \(\sigma\) as functions of E. Tungsten wires with diameter, D=0.050 mm, 0.127 mm, 0.200 mm, 0.400 mm and 0.800 mm were studied.
(b) is one of simulation results. 10 GeV electrons were scattered by a 0.127 mm Tungsten wire in this simulation. The figure shows the angular distribution of scattered electrons. The dots are simulation data, and the solid line is a Gaussian function, which is \(g(\theta)=A\ exp(-\theta^2/\sigma^2)\).
## end
#560, 6:
fig.4_
## end
#562, 16:
Experiment setup
## end
#566, 144:
In the experiments, the dipole magnet was placed 143.5 mm behind the gas cell. The magnetic field was equal to 1.48 T with 50 mm for the width. 
## end
#570, 157:
The <band> SR image plate (IP) was place 2672 mm after the magnet. The pixel size for the image plate was 50 um. The IP was scanned by XX, after every shot. 
## end
#574, 264:
Both sets of fiducials were consisted of 8 Tungsten wires with 0.127 mm for the diameter. The first set of fiducial was away from the IP by 1442 mm, which was closer to the magnet and the second set of fiducials are 934 mm from the IP, which was closer to the IP. 
## end
#578, 44:
The experiment setup is showed in the fig.3.
## end
#582, 7:
%fig.3_
## end
#586, 17:
<LWFA parameters>
## end
#590, 101:
There were many things done to increase the position measurement accuracies of different components. 
## end
#594, 207:
Two sets of fiducials were attach with the image plate holder by a stainless steel frame to increase the accuracy of position measurement. The accuracies of positions for fiducials and IP holder were XX mm. 
## end
#598, 250:
Fiducials were Tungsten wires, because the heavy element material could scatter more electrons with a small diameter shape. GEANT4 simulations were used to help us study the properties of electrons scattering, which will be discussed in the next Sec.
## end
#602, 333:
The source locations could shifted randomly because of the laser pointing drifting. The IP position could also changed, because of the small gap between the holder and the IP. Those uncertainties were unavoidable, so we proposed a Betatron shadow calibration to calibrate both of locations. It will be discussed in the next next Sec.
## end
#604, 114:
C:\\Users\\cheng\\Dropbox\\Struct\\Structure1.2.1\\Nini\\output\\paper\\spectrometer\\13975\\calibration\\fig1.png
## end
#606, 102:
C:\Users\cheng\Dropbox\Struct\Structure1.2.1\Nini\output\paper\spectrometer\13975\calibration\fig1.png
## end
#610, 6:
fig.3_
## end
#612, 25:
Two-screen method problem
## end
#616, 226:
The two-screen method is one of the most popular ways to measure LWFA electrons. In this method, electrons were usually deflected by a permanent dipole magnet and imaged by two screens at different locations after the magnet. 
## end
#620, 96:
In theory, any electron trajectories could be determined uniquely by three points in the space. 
## end
#624, 258:
In reality, the features on two screens might not be comparable, because of the divergency of electrons which always existed. For example, the electron beams could be a single peak image on the first screen, which it might be two peaks on the second screen. 
## end
#628, 286:
On the other hand, it is very important to find the correct correlated points on the screens to measure the spectrum of high energy electrons. A small error in the position measure would cause large errors in the spectrum measure, especially when the energy reaching \(10\ GeV\) level. 
## end
#632, 296:
For example, in the simulation, the IP2 was separated from the magnet by 800 mm and the IP1was separated by 3000 mm. The real spectrum had two peaks. The center of one was at \(E_1=10\ GeV\), and the other one was at \(E_2=3.7\ GeV\). The divergencies of the electrons were \(\sigma=3.0\ mrad\). 
## end
#636, 71:
There was two peaks on the IP1, while only one peak showed on the IP2. 
## end
#640, 7:
%fig.1_
## end
#644, 197:
If we used the maximum point on the IP2 and the maximum point on the IP1 to define the trajectory, the energy of the trajectory would be \(18.56\ GeV\), while the real energy should be \(10\ GeV\).
## end
#648, 285:
As a result, we proposed a new design of spectrometer by using two sets of Tungsten fiducials with an image plate, instead of two screens. The fiducial would scatter electrons going through it and leaving a shadow on the image plate, which would provide two points on the trajectories.
## end
#650, 99:
C:\\Users\\cheng\\Dropbox\\Struct\\Structure1.2.1\\Nini\\output\\paper\\spectrometer\\SecII\\F1.png
## end
#652, 88:
C:\Users\cheng\Dropbox\Struct\Structure1.2.1\Nini\output\paper\spectrometer\SecII\F1.png
## end
#654, 322:
Fig.1. (a) is the setup of a typical two-screen spectrometer. (a1) is the real spectrum of electrons. (a2) is the image on the IP2 screen. (a3) is the image on the IP1 screen. (a2) and (a3) are obtained from a GEANT4 simulation. 
(b) shows the intensity curves on both screens. The intensity is integrated over the Y-axis.
## end
#656, 6:
fig.1_
## end
#658, 12:
Introduction
## end
#662, 1106:
For the past decade, laser-plasma accelerators (LPAs) of ~ mm to ~ cm length have provided compact sources of nearly mono-energetic, highly directional electron bunches [Esa09] with energy as high as 1 GeV [Lee06].  The electron energy spectrum is generally measured with a standard magnetic spectrometer, in which a dipole magnetic field of typically ~1 T over cm dimensions, readily available from commercially available permanent magnets, deflects the trajectories of electrons emerging from the LPA [Nakamura07].  The deflected electrons are then detected 10 to 100 cm downstream of the magnet on a fluorescing screen, thereby mapping electron energy to displacement on the detector.  Because of the low angular divergence (typically a few mrad) of electrons from quasi-mono-energetic LPAs and the relatively large deflection angles (typically > 10o) of sub-GeV electrons achievable with small permanent magnets, the angular spread of electrons entering the magnetic field has played a minor role in the energy analysis of LPA electrons, except for energies approaching ~ 1 GeV [Pollock09, Clayton10]. 
## end
#666, 915:
The recent emergence of PW-class lasers has now ushered in a new era of quasi-mono-energetic laser-plasma acceleration (LPA) to multi-GeV electron bunches [Wang13, Kim13].  This new range of electron energy raises new challenges to the accurate measurement of electron energy, because the deflection angle becomes comparable to the initial angular spread.  For example, a 5 GeV electron bends only ??? mrad in a 1 T field of 5 cm extent.  An uncertainty of ?? mrad in the electron launch angle from the LPA can therefore result in uncertainty in the energy approaching 100%. The possibilities of energy-dependent launch angles and of uncertainty in the launch location due to multi-cm length of multi-GeV LPAs further complicate the analysis.  A brute force solution to these problems is to use stronger and/or larger magnets.  However, this compromises the principal virtues of LPAs – compactness and low expense. 
## end
#670, 964:
In this paper, we present an electron spectrometer suitable for PW LPA experiments that measures the energy spectrum of multi-GeV electrons with an accuracy of a few percent using permanent magnets no larger or more expensive than those typical of sub-GeV electron spectrometers.  Our spectrometer builds upon a “two-screen” concept introduced by [Pollock09, Clayton10] to deconvolve launch angle variations from energy variations... [summary description].  However, our spectrometer goes well beyond the two-screen method  [describe how].  The paper is organized as follows:  Section 2 provides an overview of the problem of multi-GeV electron energy analysis. Section 3 describes the set-up of our spectrometer, and analyzes the interaction of electrons and x-rays with its key components.  Section 4 presents an analysis of electron energy spectra for several shots with different characteristics.  Section 5 discusses.  Section 6 summarizes the main findings. 
## end
#672, 8:
Abstract
## end
#676, 583:
For the past decade, laser-plasma accelerators (LPAs) of ~ mm to ~ cm length have provided compact sources of nearly mono-energetic, highly directional electron bunches with energy as high as 1 GeV.  With the advent of petawatt scale lasers, these accelerators are now poised to go well beyond 1GeV energies.  In contrast to the large scale accelerator facilities, the LPA’s will be compact devices, requiring compact electron spectrometers adapted to the unique properties of the LPA electron bunches.  We report a compact high resolution spectrometer adapted to these conditions.  
## end
#678, 151:
Compact high-resolution multi-GeV electron spectrometer for PW-laser-driven plasma accelerators and approximate trajectory method for spectrum analysis
## end
#681, 10:
文档\论文\test
## end
#683, 82:
"""
print("112%13%1".replace('%','\\%'))

"""

ans=file_text.replace('%','\\%')



## end
#686, 14:



测试代码:...



## end
#688, 1847:
"""
参考::https://python-docx.readthedocs.io/en/latest/
+[打开网页](,参考)
记住"Python"
+[打开]"文档\论文\test"

+[P函数](,测试代码)
插入分数:...

"""

from docx import Document
from docx.shared import Inches
from docx.oxml import parse_xml

document = Document()

document.add_heading('Document Title', 0)

p = document.add_paragraph('A plain paragraph having some ')
p.add_run('bold').bold = True
p.add_run(' and some ')
p.add_run('italic.').italic = True

document.add_heading('Heading, level 1', level=1)
document.add_paragraph('Intense quote', style='Intense Quote')

document.add_paragraph(
    'first item in unordered list', style='List Bullet'
)
document.add_paragraph(
    'first item in ordered list', style='List Number'
)

document.add_picture('文档\\论文\\test\\fig.1_.png', width=Inches(1.25))

records = (
    (3, '101', 'Spam'),
    (7, '422', 'Eggs'),
    (4, '631', 'Spam, spam, eggs, and spam')
)

table = document.add_table(rows=1, cols=3)
hdr_cells = table.rows[0].cells
hdr_cells[0].text = 'Qty'
hdr_cells[1].text = 'Id'
hdr_cells[2].text = 'Desc'
for qty, id, desc in records:
    row_cells = table.add_row().cells
    row_cells[0].text = str(qty)
    row_cells[1].text = id
    row_cells[2].text = desc


p = document.add_paragraph('\n')
omml_xml = '<p xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><m:oMathPara><m:oMath><m:r><m:t>\sqrt{a+b}</m:t></m:r></m:oMath></m:oMathPara></p>'
omml_el = parse_xml(omml_xml)[0]
p._p.append(omml_el)
p = document.add_paragraph('\n')


omml_xml = '<p xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><m:oMathPara><m:oMath><m:r><m:t>\sqrt{c+d}</m:t></m:r></m:oMath></m:oMathPara></p>'
omml_el = parse_xml(omml_xml)[0]
p._p.append(omml_el)

p = document.add_paragraph('A plain paragraph having some ')


document.add_page_break()

document.save('文档\\论文\\test\\demo.docx')




## end
#690, 45:
https://python-docx.readthedocs.io/en/latest/
## end
#693, 1550:
"""
参考::https://learn.microsoft.com/en-us/archive/blogs/murrays/mathml-and-ecma-math-omml
+[P函数](,插入分数)

print(omml_el)
print(p._p)

"""


from docx import Document
from docx.oxml import parse_xml

document = Document()

p = document.add_paragraph()
# omml_xml = '<p xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><m:oMathPara><m:oMath><m:f><m:num><m:r><m:t>1</m:t></m:r></m:num><m:den><m:r><m:t>2</m:t></m:r></m:den></m:f></m:oMath></m:oMathPara></p>'

omml_xml = '<p xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><m:oMathPara><m:oMath><m:f><m:num><m:r><m:t>a+b/d*b^2</m:t></m:r></m:num></m:f><m:f>1+2+3</m:f></m:oMath></m:oMathPara></p>'

omml_xml = '<p xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><m:oMathPara><m:oMath><m:r><m:t>a+b/d\\times b^2</m:t></m:r></m:oMath></m:oMathPara></p>'

omml_xml = '<p xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><m:oMathPara><m:oMath><m:r><m:t>a+b/d\\times \\alpha ^2+(a+b)/(c+d)</m:t></m:r></m:oMath></m:oMathPara></p>'

omml_xml = '<p xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><m:oMathPara><m:oMath><m:r><m:t>a+b/d\\times \\alpha ^2+\\frac{a+b}{c+d}</m:t></m:r></m:oMath></m:oMathPara></p>'

omml_xml = '<p xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><m:oMathPara><m:oMath><m:r><m:t>\sqrt{a+b}</m:t></m:r></m:oMath></m:oMathPara></p>'

omml_el = parse_xml(omml_xml)[0]
p._p.append(omml_el)

document.save('demo.docx')

document.save('文档\\论文\\test\\demo1.docx')



## end
#695, 81:
https://learn.microsoft.com/en-us/archive/blogs/murrays/mathml-and-ecma-math-omml
## end
#696, 144:
"""
import shutil
shutil.copy(src_dir,"%s\\fig.png"%(folder_dir))
保存:...

"""

import os
os.system("cp %s %s/%s"%(src_dir,folder_dir,tar_dir))


## end
#697, 129:
"""
记住"Python"
print(folder_dir.split('/')[0:-1])

"""

import os
cmd_folder="mkdir %s/res"%(folder_dir)
os.system(cmd_folder)



## end
#700, 608:
"""
P代码:...
P代码2:...
+[新建阅读窗口](,P代码)

保存:...

"""

+整理图片(_媒介,_凭依)->+[del](,+整理图片)...
->的(整理图片,P代码)->的(整理图片,P代码2)...

->的#0(_凭依,地址)->+[标题](_凭依,)...
->+[python](Python,+[临时文本])->+[code](+[python],P代码)...
->+[.]"file_name"(+[python],+[标题])->+[.]"folder_dir"(+[python],地址)...

->[]{
    []=>的(_媒介,二级标题)->二级标题->的(二级标题,图片)...
    ->的(图片,源地址)->的(图片,目标地址)->[]{[]=>[==](源地址,目标地址)}...
        =>+[python](Python,)->+[code](+[python],P代码2)...
        ->+[.]"src_dir"(+[python],源地址)->+[.]"tar_dir"(+[python],目标地址)...
        ->+[.]"folder_dir"(+[python],地址)
}...

->+[del](,的#0)...
->+[删除结构](,_凭依)...
->+[有](_凭依,地址)





## end
#701, 296:
"""
记住"Python"

print(text_aus)
print(list_aus)

"""

# print(text_aus)
# print(text_aus.split(', '))
# print(' and '.join(text_aus.split(', ')))

list_aus0=text_aus.split(', ')
if len(list_aus0)>3:
    list_aus=list_aus0[0:3]+['others']
else:
    list_aus=list_aus0
ans=' and '.join(list_aus)



## end
#702, 213:

@PROCEEDINGS{%引用名,
   title = "%标题",
   number = "%编号",
   editor = "", 

   series = "All ACM Conferences",
   month = "",
   year = "%年份",
   address = "%城市地址",
   organization = "%组织",
   publisher = "%会议",
}

## end
#703, 169:

@ARTICLE{%引用名,
   author       = "%作者",
   title        = "%标题",
   journal      = "%期刊",
   volume       = "%编号", 
   pages        = "%页数",
   year         = "%年份",
}

## end
#706, 25:


文章:...
会议:...
预印本:...


## end
#709, 568:
"""
P代码:...
模板库:...

"""

+设置引用(文章A,引用)->+[del](,+设置引用)...
->的(设置引用,模板库)->的(设置引用,P代码)...

->的(文章A,类型)->的(文章A,作者)...
->+[python](Python,作者)->+[code](+[python],P代码)...
->+[s]"text_aus"(+[python],作者)...

->+[模板文本](,+[增加内容2])->+[增加内容2](,引用)...
->[]{
    []:->[==]"ARTICLE"(,类型)->的(模板库,文章#0)->+[code](+[模板文本],文章#0),
    ->[==]"PROCEEDINGS"(,类型)->的(模板库,会议#0)->+[code](+[模板文本],会议#0),
    ->[==]"ArXiv"(,类型)->的(模板库,预印本#0)->+[code](+[模板文本],预印本#0),
    ->的(模板库,文章#1)->+[code](+[模板文本],文章#1)
}...

->+[.]"引用名"(+[模板文本],文章A)...
->[]{
    []=>的(文章A,_性质)->_性质=>+[.](+[模板文本],_性质)
}




## end
#710, 61:
"""
记住"Python"

"""

ans=paper_link.split('#')[0]
state=True

## end
#712, 203:
"""
P代码:...

"""

+描述结构(_文章,)->+操作(+描述结构,)...
->的(描述结构,P代码)...

=>的(_文章,_节点)->引用(_节点,)...
=>+的(+操作,+文章)->+文章(_节点,)...
->+[.]"paper_link"([python],_节点)->+[code]([python],P代码)...
->[python](Python,+文章)




## end
#715, 426:
"""
描述结构:...
设置引用:...
+[新建阅读窗口](,描述结构)

"""

+引用文章(_文章,_文本)->+[del](,+引用文章)...
->的(引用文章,描述结构)->的(引用文章,设置引用)...

->+的(_文本,+引用)...
->+[code]([想],描述结构)->[想](_文章,)...

->操作([想],)...
->+[临时文本]#内容->[]{
    []=>的(操作,文章)->文章(_节点,)->_节点(,)...
    =>+[获取论文信息](+[临时文本],+文章A)->[m_text](文章,+[临时文本])...
        ->[标题](_节点,)->[m_text]([标题],+文章A)...
        ->+[做](+文章A,+引用)->+[code](+[做],设置引用)...
        ->+[删除结构](,+文章A)->+[del](,+文章A)
}



## end
#716, 82:
"""
print("112%13%1".replace('%','\\%'))

"""

ans=file_text.replace('%','\\%')



## end
#717, 23:

%标题
%作者

%概述


%章节




## end
#720, 312:
"""


"""

+整理内容(_媒介,_内容)->+[del](,+整理内容)...

->+[临时文本]->的(_内容,地址#0)->的(_内容,文件名)->[]{
    []=>的(_内容,_章节)->的(_章节,地址)=>+[增加内容2](地址#0,地址)...
        ->+[增加内容](_章节,+[临时文本])
}...

->+[修改内容](+[临时文本],_内容)...
->+[模板文本]"%地址/%文件名"(,+[临时文本]#地址)...
    ->+[.](+[模板文本],地址#0)->+[.](+[模板文本],文件名)...
->+[保存文本](+[临时文本]#地址,_内容)



## end
#721, 134:
"""


"""

name=list_au[list_i]
list_i+=1
if name[-1]=='*':
    name=name[0:-1]
    type_name='通讯'
else:
    type_name="普通"
ans=name


## end
#722, 70:
"""
记住"Python"

"""

state=True
list_au=text_au.split(', ')
list_i=0


## end
#725, 347:
"""
P代码:...
P代码2:...

"""

+描述结构(_作者,)->+操作(+描述结构,)...
->的(描述结构,P代码)->的(描述结构,P代码2)...

->+[.]"text_au"([python],_作者)...
->+[code]([python],P代码)->[python](Python,)...
->+[code]([python]#2,P代码2)...

->+不终止=>[python]"state=(list_i<len(list_au))"(Python,+不终止)...
=>+的(+操作,+作者)->+作者(+类型,)...
->+[o]"type_name"([python]#2,+类型)->[python]#2(Python,+作者)



## end
#726, 34:

\author{%名 %姓}
\affiliation{%单位}

## end
#728, 212:
"""
L模板:...

"""
+普通作者(_A,_输出)->+[del](,+普通作者)...
->的(普通作者,L模板)...

->的(_A,名)->的(_A,姓)->的(_A,单位)->的(_A,邮箱)...

->+[模板文本](L模板,+[增加内容2])->+[增加内容2](,_输出)...
->+[.](+[模板文本],名)->+[.](+[模板文本],姓)...
->+[.](+[模板文本],单位)


## end
#729, 46:

\author{%名 %姓}
\email{%邮箱}
\affiliation{%单位}

## end
#731, 230:
"""
L模板:...

"""
+通讯作者(_A,_输出)->+[del](,+通讯作者)...
->的(通讯作者,L模板)...

->的(_A,名)->的(_A,姓)->的(_A,单位)->的(_A,邮箱)...

->+[模板文本](L模板,+[增加内容2])->+[增加内容2](,_输出)...
->+[.](+[模板文本],名)->+[.](+[模板文本],姓)...
->+[.](+[模板文本],单位)->+[.](+[模板文本],邮箱)


## end
#734, 40:


通讯作者:...
普通作者:...
将'普通作者'的"通讯"替换为"普通"

## end
#737, 428:
"""
描述结构:...
库:...

"""

+生成作者(_作者,_文本)->+[del](,+生成作者)...
->的(生成作者,描述结构)->的(生成作者,库)...
->的(库,通讯作者)->的(库,普通作者)...

->+的(_文本,+作者)...
->+[code]([想],描述结构)->[想](_作者,)...

->操作([想],)...
->+[临时文本]#内容->[]{
    []=>的(操作,作者)->作者(类型,)->类型(,)...
    =>+[获取作者信息](,+作者A)->[m_text](作者,+[获取作者信息])...
    ->+[做](+作者A,+作者)...
    ->+[删除结构](,+作者A)->+[del](,+作者A)->[]:
        ->[==]"通讯"(,类型)->+[code](+[做],通讯作者),
        ->+[code](+[做],普通作者)
}



## end
#738, 16:

\appendix
%内容


## end
#739, 89:
"""
记住"Python"

"""

fig_type=source_dir.split('.')[-1]
ans='\\'+fig_name+'.'+fig_type



## end
#740, 107:

\begin{figure}[b]
\includegraphics[width=0.45\textwidth]{%名字}
\caption{\label{fig:%名字}%图例}
\end{figure}



## end
#743, 347:
"""
P代码:...
L模板:...

"""

+图片结构(_节点,_内容)->+[del](,+图片结构)...
->的(图片结构,L模板)->的(图片结构,P代码)...

->的(_节点,名字)->的(_节点,图例)->的(_节点,源地址)...
->的(_节点,目标地址)...
->+[python](Python,目标地址)->+[code](+[python],P代码)...
->+[.]"source_dir"(+[python],源地址)->+[.]"fig_name"(+[python],名字)...

->+[模板文本](L模板,+[增加内容2])->+[增加内容2](,_内容)...
->+[.](+[模板文本],名字)->+[.](+[模板文本],图例)


## end
#744, 56:

\begin{equation}
%LaTeX
\label{eq:%名字}
\end{equation}


## end
#746, 373:
"""
P代码:...
L模板:...
L模板2:...

"""

+公式结构(_节点,_内容)->+[del](,+公式结构)...
->的(公式结构,L模板)->的(公式结构,L模板2)...
->的(公式结构,P代码)...

->的(_节点,名字)->的(_节点,LaTeX)...
->+[模板文本](,+[增加内容2])->+[增加内容2](,_内容)...
->+[.](+[模板文本],名字)->+[.](+[模板文本],LaTeX)...

->[]{+[.]"LaTeX_text0"([python],LaTeX)->+[code]([python],P代码)->[python](Python,)}:
    ->+[code](+[模板文本],L模板2),
    ->>+[code](+[模板文本],L模板)



## end
#747, 184:
"""
P代码:...

"""

+文本结构(_节点,_内容)->+[del](,+文本结构)...
->的(文本结构,P代码)...

->+[python](Python,+[增加内容2])->+[code](+[python],P代码)...
->+[.]"text_context"(+[python],_节点)...

->+[增加内容2](,_内容)


## end
#751, 33:


文本结构:...
公式结构:...
图片结构:...





## end
#752, 259:
"""


"""

+描述结构(_章节,)->+操作(+描述结构,)...

->[]{
    []=>的(_章节,_节点)->_节点=>[]:
        ->[is](_节点,文本)->文本->+文本结构(_节点,)->+的(+操作,+文本结构),
        ->[is](_节点,公式)->公式->+公式结构(_节点,)->+的(+操作,+公式结构),
        ->[is](_节点,图片)->图片->+图片结构(_节点,)->+的(+操作,+图片结构),
        ->[]
}


## end
#756, 438:
"""
描述结构:...
库:...
L模板:...
+[新建阅读窗口](,描述结构)

"""

+生成附录(_章节,_文本)->+[del](,+生成附录)...
->的(生成附录,描述结构)->的(生成附录,库)...
->的(生成附录,L模板)...

->+的(_文本,+章节)...
->+[code]([想],描述结构)->[想](_章节,)...

->操作([想],)...
->+[临时文本]#内容->[]{
    []=>的(操作,_操作)->_操作(_主语,)->_主语(,)...
    =>[说](,_操作)->的(库,_条目)->[eq](_条目,_操作)...
    ->+[做](_主语,+[临时文本]#内容)->+[code](+[做],_条目)
}...

->的(_章节,题目)...
->+[模板文本](L模板,+章节)...
->+[.]"内容"(+[模板文本],+[临时文本]#内容)->+[.](+[模板文本],题目)


## end
#757, 8:
%[临时文本]

## end
#759, 199:
"""
L模板:...

"""

+生成概述(二级标题,_文本)->+[del](,+生成概述)...
->的(生成概述,L模板)...

->+的(_文本,+概述)...

->+[临时文本]->[]{
    []=>的(二级标题,文本)->文本=>+[增加内容2](文本,+[临时文本])
}...

->+[模板文本](L模板,+概述)->+[.](+[模板文本],+[临时文本])



## end
#760, 6:
# %题目

## end
#762, 217:
"""
L模板:...

"""

+生成标题(一级标题,_文本)->+[del](,+生成标题)...
->的(生成标题,L模板)...

->+的(_文本,+标题)->+的(+标题,+地址)->+地址"/pages/title.html"...
    ->+的(+标题,+原型)->+原型(+标题,一级标题)...

->的(一级标题,题目)...
->+[模板文本](L模板,+标题)->+[.](+[模板文本],题目)



## end
#767, 89:


生成标题:...
生成作者:...
生成概述:...
生成章节:...
生成附录:...
将条目"生成章节"复制为条目"生成附录"
将'生成作者'的"章节"替换为"作者"


## end
#768, 491:
"""


"""
+描述结构(_章节结构,_文本)->+操作(+描述结构,)...

->[]{
    []:->[is](_章节结构,一级标题)->一级标题(,)...
        ->+生成标题(一级标题,_文本)->+的(+操作,+生成标题),
    ->[is](_章节结构,文本)->文本(,)...
        ->+生成作者(文本,_文本)->+的(+操作,+生成作者),
    ->[is](_章节结构,_章节)->_章节->的(_章节,题目)->[==]"Abstract"(,题目)...
        ->+生成概述(_章节,_文本)->+的(+操作,+生成概述),
    ->[is](_章节结构,_附录)->_附录->的(_附录,题目#2)->[==]"Appendix"(,题目#2)...
        ->+生成附录(_附录,_文本)->+的(+操作,+生成附录),
    ->[is](_章节结构,二级标题)->二级标题(,)...
        ->+生成章节(二级标题,_文本)->+的(+操作,+生成章节)
}



## end
#771, 309:
"""
描述结构:...
库:...
+[新建阅读窗口](,库)

"""
+章节内容(_章节结构,_文本)->+[del](,+章节内容)...
->的(章节内容,描述结构)->的(章节内容,库)...

->+[code]([想],描述结构)->[想](_章节结构,_文本)...
->操作([想],)...
->[]{
    []=>的(操作,_操作)->_操作(_主语,_宾语)->_主语->_宾语(,)...
    =>[说](,_操作)...
        ->的(库,_条目)->_条目->[eq](_条目,_操作)->+[做](_主语,_宾语)->+[code](+[做],_条目)
}





## end
#776, 108:
+[粘贴](,降临规则)

整理地址:...
引用文章:...
章节内容:...

整理引用:...
整理内容:...
整理图片:...
+[新建阅读窗口](,章节内容)
将'引用文章'的"作者"替换为"文章"



## end
#777, 467:
"""
Nini, 打开人体模型(文件)
Nini, 打开CBS(文件)
    ->+整体架构(_媒介,_凭依)->+的(操作,+整体架构)...

"""

+召唤规则(_媒介,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_凭依)...

->[==]"结构文本转md"(,召唤星辰)...
    ->+整理图片(_媒介,_凭依)->+的(操作,+整理图片)...
    ->+整理内容(_媒介,_凭依)->+的(操作,+整理内容)...
    ->+整理引用(_媒介,_凭依)->+的(操作,+整理引用)...


->[]{
    []=>的(_媒介,_章节)->_章节=>+章节内容(_章节,_凭依)->+的(操作,+章节内容)
}...
->[]{
    []:->.(_媒介,_原始结构)->_原始结构(,)...
        ->+引用文章(_原始结构,_凭依)->+的(操作,+引用文章),
    ->[]
}...
->+整理地址(_媒介,_凭依)->+的(操作,+整理地址)



## end
#780, 24:


召唤规则:...
降临规则:...





## end
#783, 40:
p = document.add_paragraph("""%内容\n""")

## end
#785, 356:
"""
Nini, 打开人体模型(文件)
Nini, 打开CBS(文件)

"""

+召唤规则(_媒介,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_凭依)...

->[==]"结构文本转docx"(,召唤星辰)...
    ->+整理图片(_媒介,_凭依)->+的(操作,+整理图片)...
    ->+整理内容(_媒介,_凭依)->+的(操作,+整理内容)...

->[]{
    []=>的(_媒介,_章节)->_章节=>+章节内容(_章节,_凭依)->+的(操作,+章节内容)
}...
->[]{
    []:->.(_媒介,_原始结构)->_原始结构(,)...
        ->+引用文章(_原始结构,_凭依)->+的(操作,+引用文章),
    ->[]
}

## end
#787, 10155:
文本转换_docx#0"

召唤规则:...
降临规则:...




"(,)
的#1""(文本转换_docx#0,召唤规则#2)
召唤规则#2"\"\"\"
Nini, 打开人体模型(文件)
Nini, 打开CBS(文件)

\"\"\"

+召唤规则(_媒介,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_凭依)...

->[==]\"结构文本转docx\"(,召唤星辰)...
    ->+整理图片(_媒介,_凭依)->+的(操作,+整理图片)...
    ->+整理内容(_媒介,_凭依)->+的(操作,+整理内容)...

->[]{
    []=>的(_媒介,_章节)->_章节=>+章节内容(_章节,_凭依)->+的(操作,+章节内容)
}...
->[]{
    []:->.(_媒介,_原始结构)->_原始结构(,)...
        ->+引用文章(_原始结构,_凭依)->+的(操作,+引用文章),
    ->[]
}
"(,)
的#3""(文本转换_docx#0,降临规则#4)
降临规则#4"有什么

引用文章:...
章节内容:...
整理内容:...
整理图片:...
+[新建阅读窗口](,章节内容)
将'引用文章'的\"作者\"替换为\"文章\"


"(,)
的#5""(降临规则#4,章节内容#6)
章节内容#6"\"\"\"
描述结构:...
库:...
+[新建阅读窗口](,库)

\"\"\"
+章节内容(_章节结构,_文本)->+[del](,+章节内容)...
->的(章节内容,描述结构)->的(章节内容,库)...

->+[code]([想],描述结构)->[想](_章节结构,_文本)...
->操作([想],)...
->[]{
    []=>的(操作,_操作)->_操作(_主语,_宾语)->_主语->_宾语(,)...
    =>[说](,_操作)...
        ->的(库,_条目)->_条目->[eq](_条目,_操作)->+[做](_主语,_宾语)->+[code](+[做],_条目)
}




"(,)
的#7""(章节内容#6,描述结构#8)
描述结构#8"\"\"\"


\"\"\"
+描述结构(_章节结构,_文本)->+操作(+描述结构,)...

->[]{
    []:->[is](_章节结构,一级标题)->一级标题(,)...
        ->+生成标题(一级标题,_文本)->+的(+操作,+生成标题),
    ->[is](_章节结构,文本)->文本(,)...
        ->+生成作者(文本,_文本)->+的(+操作,+生成作者),
    ->[is](_章节结构,_章节)->_章节->的(_章节,题目)->[==]\"Abstract\"(,题目)...
        ->+生成概述(_章节,_文本)->+的(+操作,+生成概述),
    ->[is](_章节结构,二级标题)->二级标题(,)...
        ->+生成章节(二级标题,_文本)->+的(+操作,+生成章节)
}


"(,)
的#9""(章节内容#6,库#10)
库#10"

生成标题:...
生成作者:...
生成概述:...
生成章节:...

将'生成作者'的\"章节\"替换为\"作者\"

"(,)
的#11""(库#10,生成标题#12)
生成标题#12"\"\"\"
L模板:...

\"\"\"

+生成标题(一级标题,_文本)->+[del](,+生成标题)...
->的(生成标题,L模板)...

->+的(_文本,+标题)...

->的(一级标题,题目)...
->+[模板文本](L模板,+标题)->+[.](+[模板文本],题目)


"(,)
的#13""(生成标题#12,L模板#14)
L模板#14"document.add_heading('%题目', 0)
"(,)
的#15""(库#10,生成概述#16)
生成概述#16"\"\"\"
L模板:...

\"\"\"

+生成概述(二级标题,_文本)->+[del](,+生成概述)...
->的(生成概述,L模板)...

->+的(_文本,+概述)...

->+[临时文本]->[]{
    []=>的(二级标题,文本)->文本=>+[增加内容2](文本,+[临时文本])
}...

->+[模板文本](L模板,+概述)->+[.](+[模板文本],+[临时文本])


"(,)
的#17""(生成概述#16,L模板#18)
L模板#18"p = document.add_paragraph('%[临时文本]\n')
"(,)
的#19""(库#10,生成章节#20)
生成章节#20"\"\"\"
描述结构:...
库:...
L模板:...
+[新建阅读窗口](,描述结构)

\"\"\"

+生成章节(_章节,_文本)->+[del](,+生成章节)...
->的(生成章节,描述结构)->的(生成章节,库)...
->的(生成章节,L模板)...

->+的(_文本,+章节)...
->+[code]([想],描述结构)->[想](_章节,)...

->操作([想],)...
->+[临时文本]#内容->[]{
    []=>的(操作,_操作)->_操作(_主语,)->_主语(,)...
    =>[说](,_操作)->的(库,_条目)->[eq](_条目,_操作)...
    ->+[做](_主语,+[临时文本]#内容)->+[code](+[做],_条目)
}...

->的(_章节,题目)...
->+[模板文本](L模板,+章节)...
->+[.]\"内容\"(+[模板文本],+[临时文本]#内容)->+[.](+[模板文本],题目)

"(,)
的#21""(生成章节#20,描述结构#22)
描述结构#22"\"\"\"


\"\"\"

+描述结构(_章节,)->+操作(+描述结构,)...

->[]{
    []=>的(_章节,_节点)->_节点=>[]:
        ->[is](_节点,文本)->文本->+文本结构(_节点,)->+的(+操作,+文本结构),
        ->[is](_节点,公式)->公式->+公式结构(_节点,)->+的(+操作,+公式结构),
        ->[is](_节点,图片)->图片->+图片结构(_节点,)->+的(+操作,+图片结构),
        ->[]
}

"(,)
的#23""(生成章节#20,库#24)
库#24"

文本结构:...
公式结构:...
图片结构:...




"(,)
的#25""(库#24,文本结构#26)
文本结构#26"\"\"\"
L模板:...

\"\"\"

+文本结构(_节点,_内容)->+[del](,+文本结构)...
->的(文本结构,L模板)...

->+[模板文本](L模板,+[增加内容2])->+[增加内容2](,_内容)...
->+[.]\"内容\"(+[模板文本],_节点)

"(,)
的#27""(文本结构#26,L模板#28)
L模板#28"p = document.add_paragraph(\"\"\"%内容\n\"\"\")
"(,)
的#29""(库#24,公式结构#30)
公式结构#30"\"\"\"
L模板:...

\"\"\"

+公式结构(_节点,_内容)->+[del](,+公式结构)...
->的(公式结构,L模板)...

->的(_节点,名字)->的(_节点,LaTeX)...
->+[模板文本](L模板,+[增加内容2])->+[增加内容2](,_内容)...
->+[.](+[模板文本],名字)->+[.](+[模板文本],LaTeX)

"(,)
的#31""(公式结构#30,L模板#32)
L模板#32"
omml_xml = '<p xmlns:m=\"http://schemas.openxmlformats.org/officeDocument/2006/math\"><m:oMathPara><m:oMath><m:r><m:t>%LaTeX</m:t></m:r></m:oMath></m:oMathPara></p>'
omml_el = parse_xml(omml_xml)[0]
p._p.append(omml_el)
p = document.add_paragraph('\n')

"(,)
的#33""(库#24,图片结构#34)
图片结构#34"\"\"\"
P代码:...
L模板:...

\"\"\"

+图片结构(_节点,_内容)->+[del](,+图片结构)...
->的(图片结构,L模板)->的(图片结构,P代码)...

->的(_节点,名字)->的(_节点,图例)->的(_节点,源地址)...
->的(_节点,目标地址)...
->+[python](Python,目标地址)->+[code](+[python],P代码)...
->+[.]\"source_dir\"(+[python],源地址)->+[.]\"fig_name\"(+[python],名字)...

->+[模板文本](L模板,+[增加内容2])->+[增加内容2](,_内容)...
->+[.](+[模板文本],名字)->+[.](+[模板文本],图例)...
->+[.](+[模板文本],目标地址)
"(,)
的#35""(图片结构#34,L模板#36)
L模板#36"document.add_picture('%目标地址', width=Inches(4.25))
p = document.add_paragraph(\"\"\"%图例\n\"\"\")
"(,)
的#37""(图片结构#34,P代码#38)
P代码#38"\"\"\"
记住\"Python\"
print(source_dir.replace('\\','\\\\'))

\"\"\"

fig_type=source_dir.split('.')[-1]
# ans='\\'+fig_name+'.'+fig_type
ans=source_dir.replace('\\','\\\\')

"(,)
的#39""(生成章节#20,L模板#40)
L模板#40"document.add_heading('%题目', level=1)
%内容

"(,)
的#41""(库#10,生成作者#42)
生成作者#42"\"\"\"
描述结构:...
库:...

\"\"\"

+生成作者(_作者,_文本)->+[del](,+生成作者)...
->的(生成作者,描述结构)->的(生成作者,库)...
->的(库,通讯作者)->的(库,普通作者)...

->+的(_文本,+作者)...
->+[code]([想],描述结构)->[想](_作者,)...

->操作([想],)...
->+[临时文本]#内容->[]{
    []=>的(操作,作者)->作者(类型,)->类型(,)...
    =>+[获取作者信息](,+作者A)->[m_text](作者,+[获取作者信息])...
    ->+[做](+作者A,+作者)...
    ->+[删除结构](,+作者A)->+[del](,+作者A)->[]:
        ->[==]\"通讯\"(,类型)->+[code](+[做],通讯作者),
        ->+[code](+[做],普通作者)
}


"(,)
的#43""(生成作者#42,库#44)
库#44"

通讯作者:...
普通作者:...
将'普通作者'的\"通讯\"替换为\"普通\"
"(,)
的#45""(库#44,通讯作者#46)
通讯作者#46"\"\"\"
L模板:...

\"\"\"
+通讯作者(_A,_输出)->+[del](,+通讯作者)...
->的(通讯作者,L模板)...

->的(_A,名)->的(_A,姓)->的(_A,单位)->的(_A,邮箱)...

->+[模板文本](L模板,+[增加内容2])->+[增加内容2](,_输出)...
->+[.](+[模板文本],名)->+[.](+[模板文本],姓)...
->+[.](+[模板文本],单位)->+[.](+[模板文本],邮箱)

"(,)
的#47""(通讯作者#46,L模板#48)
L模板#48"%名 %姓, "(,)
的#49""(库#44,普通作者#50)
普通作者#50"\"\"\"
L模板:...

\"\"\"
+普通作者(_A,_输出)->+[del](,+普通作者)...
->的(普通作者,L模板)...

->的(_A,名)->的(_A,姓)->的(_A,单位)->的(_A,邮箱)...

->+[模板文本](L模板,+[增加内容2])->+[增加内容2](,_输出)...
->+[.](+[模板文本],名)->+[.](+[模板文本],姓)...
->+[.](+[模板文本],单位)

"(,)
的#51""(普通作者#50,L模板#52)
L模板#52"%名 %姓*"(,)
的#53""(生成作者#42,描述结构#54)
描述结构#54"\"\"\"
P代码:...
P代码2:...

\"\"\"

+描述结构(_作者,)->+操作(+描述结构,)...
->的(描述结构,P代码)->的(描述结构,P代码2)...

->+[.]\"text_au\"([python],_作者)...
->+[code]([python],P代码)->[python](Python,)...
->+[code]([python]#2,P代码2)...

->+不终止=>[python]\"state=(list_i<len(list_au))\"(Python,+不终止)...
=>+的(+操作,+作者)->+作者(+类型,)...
->+[o]\"type_name\"([python]#2,+类型)->[python]#2(Python,+作者)


"(,)
的#55""(描述结构#54,P代码#56)
P代码#56"\"\"\"
记住\"Python\"

\"\"\"

state=True
list_au=text_au.split(', ')
list_i=0

"(,)
的#57""(描述结构#54,P代码2#58)
P代码2#58"\"\"\"


\"\"\"

name=list_au[list_i]
list_i+=1
if name[-1]=='*':
    name=name[0:-1]
    type_name='通讯'
else:
    type_name=\"普通\"
ans=name

"(,)
的#59""(降临规则#4,整理内容#60)
整理内容#60"\"\"\"
P代码:...
L模板:...

\"\"\"

+整理内容(_媒介,_内容)->+[del](,+整理内容)...
->的(整理内容,L模板)->的(整理内容,P代码)...

->+[临时文本]#章节->[]{
    []=>的(_内容,章节)->章节=>+[增加内容](章节,+[临时文本]#章节)
}...
->+[python](Python,+[临时文本]#章节)->+[code](+[python],P代码)...
->+[s]\"file_text\"(+[python],+[临时文本]#章节)...

->+[模板文本](L模板,_内容)...
->+[.]\"章节\"(+[模板文本],+[临时文本]#章节)...
->[]{
    []:->的(_内容,标题)->标题->+[.](+[模板文本],标题),->[]
}...
->[]{
    []:->的(_内容,作者)->作者->+[.](+[模板文本],作者),->[]
}...
->[]{
    []:->的(_内容,概述)->概述->+[.](+[模板文本],概述),->[]
}...
->[]{
    []:->的(_内容,引用)->引用->+[.](+[模板文本],引用),->[]
}


"(,)
的#61""(整理内容#60,L模板#62)
L模板#62"
from docx import Document
from docx.shared import Inches
from docx.oxml import parse_xml

document = Document()

%标题
p = document.add_paragraph('%作者\n')

%概述
%章节


document.add_page_break()
document.save('%地址')




"(,)
的#63""(整理内容#60,P代码#64)
P代码#64"\"\"\"
print(\"112%13%1\".replace('%','\\%'))

\"\"\"

ans=file_text.replace('%','\\%')


"(,)
的#65""(降临规则#4,引用文章#66)
引用文章#66"\"\"\"
描述结构:...
设置引用:...
+[新建阅读窗口](,描述结构)

\"\"\"

+引用文章(_文章,_文本)->+[del](,+引用文章)...
->的(引用文章,描述结构)->的(引用文章,设置引用)...

->+的(_文本,+引用)...
->+[code]([想],描述结构)->[想](_文章,)...

->操作([想],)...
->+[临时文本]#内容->[]{
    []=>的(操作,文章)->文章(_节点,)->_节点(,)...
    =>+[获取论文信息](+[临时文本],+文章A)->[m_text](文章,+[临时文本])...
        ->[标题](_节点,)->[m_text]([标题],+文章A)...
        ->+[做](+文章A,+引用)->+[code](+[做],设置引用)...
        ->+[删除结构](,+文章A)->+[del](,+文章A)
}


"(,)
的#67""(引用文章#66,描述结构#68)
描述结构#68"\"\"\"
P代码:...

\"\"\"

+描述结构(_文章,)->+操作(+描述结构,)...
->的(描述结构,P代码)...

=>的(_文章,_节点)->引用(_节点,)...
=>+的(+操作,+文章)->+文章(_节点,)...
->+[.]\"paper_link\"([python],_节点)->+[code]([python],P代码)...
->[python](Python,+文章)



"(,)
的#69""(描述结构#68,P代码#70)
P代码#70"\"\"\"
记住\"Python\"

\"\"\"

ans=paper_link.split('#')[0]
state=True
"(,)
的#71""(引用文章#66,设置引用#72)
设置引用#72"\"\"\"
P代码:...
模板库:...

\"\"\"

+设置引用(文章A,引用)->+[del](,+设置引用)...
->的(设置引用,模板库)->的(设置引用,P代码)...

->的(文章A,类型)->的(文章A,作者)...
->+[python](Python,作者)->+[code](+[python],P代码)...
->+[s]\"text_aus\"(+[python],作者)...

->+[模板文本](,+[增加内容2])->+[增加内容2](,引用)...
->[]{
    []:->[==]\"ARTICLE\"(,类型)->的(模板库,文章#0)->+[code](+[模板文本],文章#0),
    ->[==]\"PROCEEDING\"(,类型)->的(模板库,会议#0)->+[code](+[模板文本],会议#0),
    ->的(模板库,文章#1)->+[code](+[模板文本],文章#1)
}...

->+[.]\"引用名\"(+[模板文本],文章A)...
->[]{
    []=>的(文章A,_性质)->_性质=>+[.](+[模板文本],_性质)
}



"(,)
的#73""(设置引用#72,模板库#74)
模板库#74"

文章:...
会议:...


"(,)
的#75""(模板库#74,文章#76)
文章#76"
@ARTICLE{%引用名,
   author       = \"%作者\",
   title        = \"%标题\",
   journal      = \"%期刊\",
   volume       = \"%编号\", 
   pages        = \"%页数\",
   year         = \"%年份\",
}
"(,)
的#77""(模板库#74,会议#78)
会议#78"
@PROCEEDINGS{%引用名,
   title = \"%标题\",
   number = \"%编号\",
   editor = \"\", 

   series = \"All ACM Conferences\",
   month = \"\",
   year = \"%年份\",
   address = \"%地址\",
   organization = \"%组织\",
   publisher = \"%会议\",
}
"(,)
的#79""(设置引用#72,P代码#80)
P代码#80"\"\"\"
记住\"Python\"

\"\"\"

# print(text_aus)
# print(text_aus.split(', '))
# print(' and '.join(text_aus.split(', ')))
ans=' and '.join(text_aus.split(', '))


"(,)
的#81""(降临规则#4,整理图片#82)
整理图片#82"\"\"\"
P代码:...
P代码2:...

\"\"\"

+整理图片(_媒介,_凭依)->+[del](,+整理图片)...
->的(整理图片,P代码)->的(整理图片,P代码2)...

->的#0(_凭依,地址)->+[标题](_凭依,)...
->+[python](Python,+[临时文本])->+[code](+[python],P代码)...
->+[.]\"file_name\"(+[python],+[标题])->+[.]\"folder_dir\"(+[python],地址)...

->+[模板文本](_凭依,_凭依)->+[.]\"地址\"(+[模板文本],+[临时文本])...
->+[P函数](,_凭依)...

->+[del](,的#0)...
->+[删除结构](,_凭依)...
->+[有](_凭依,地址)




"(,)
的#83""(整理图片#82,P代码#84)
P代码#84"\"\"\"


\"\"\"


output_dir=\"%s\\text.docx\"%(folder_dir)
ans=output_dir.replace('\\','\\\\')
"(,)
的#85""(整理图片#82,P代码2#86)
P代码2#86"\"\"\"
import shutil
shutil.copy(src_dir,\"%s\\fig.png\"%(folder_dir))

\"\"\"

import shutil
# print(src_dir,tar_dir)
# ans=\"%s\%s.tex\"%(folder_dir,file_name)
shutil.copy(src_dir,\"%s\\%s\"%(folder_dir,tar_dir))

"(,)

## end
#789, 19810:

from docx import Document
from docx.shared import Inches
from docx.oxml import parse_xml

document = Document()

document.add_heading('Compact high-resolution multi-GeV electron spectrometer for PW-laser-driven plasma accelerators and approximate trajectory method for spectrum analysis', 0)

p = document.add_paragraph('\n')

p = document.add_paragraph('For the past decade, laser-plasma accelerators (LPAs) of ~ mm to ~ cm length have provided compact sources of nearly mono-energetic, highly directional electron bunches with energy as high as 1 GeV.  With the advent of petawatt scale lasers, these accelerators are now poised to go well beyond 1GeV energies.  In contrast to the large scale accelerator facilities, the LPA’s will be compact devices, requiring compact electron spectrometers adapted to the unique properties of the LPA electron bunches.  We report a compact high resolution spectrometer adapted to these conditions.  \n')

document.add_heading('Introduction', level=1)
p = document.add_paragraph("""For the past decade, laser-plasma accelerators (LPAs) of ~ mm to ~ cm length have provided compact sources of nearly mono-energetic, highly directional electron bunches [Esa09] with energy as high as 1 GeV [Lee06].  The electron energy spectrum is generally measured with a standard magnetic spectrometer, in which a dipole magnetic field of typically ~1 T over cm dimensions, readily available from commercially available permanent magnets, deflects the trajectories of electrons emerging from the LPA [Nakamura07].  The deflected electrons are then detected 10 to 100 cm downstream of the magnet on a fluorescing screen, thereby mapping electron energy to displacement on the detector.  Because of the low angular divergence (typically a few mrad) of electrons from quasi-mono-energetic LPAs and the relatively large deflection angles (typically > 10o) of sub-GeV electrons achievable with small permanent magnets, the angular spread of electrons entering the magnetic field has played a minor role in the energy analysis of LPA electrons, except for energies approaching ~ 1 GeV [Pollock09, Clayton10]. \n""")
p = document.add_paragraph("""The recent emergence of PW-class lasers has now ushered in a new era of quasi-mono-energetic laser-plasma acceleration (LPA) to multi-GeV electron bunches [Wang13, Kim13].  This new range of electron energy raises new challenges to the accurate measurement of electron energy, because the deflection angle becomes comparable to the initial angular spread.  For example, a 5 GeV electron bends only ??? mrad in a 1 T field of 5 cm extent.  An uncertainty of ?? mrad in the electron launch angle from the LPA can therefore result in uncertainty in the energy approaching 100\%. The possibilities of energy-dependent launch angles and of uncertainty in the launch location due to multi-cm length of multi-GeV LPAs further complicate the analysis.  A brute force solution to these problems is to use stronger and/or larger magnets.  However, this compromises the principal virtues of LPAs – compactness and low expense. \n""")
p = document.add_paragraph("""In this paper, we present an electron spectrometer suitable for PW LPA experiments that measures the energy spectrum of multi-GeV electrons with an accuracy of a few percent using permanent magnets no larger or more expensive than those typical of sub-GeV electron spectrometers.  Our spectrometer builds upon a “two-screen” concept introduced by [Pollock09, Clayton10] to deconvolve launch angle variations from energy variations... [summary description].  However, our spectrometer goes well beyond the two-screen method  [describe how].  The paper is organized as follows:  Section 2 provides an overview of the problem of multi-GeV electron energy analysis. Section 3 describes the set-up of our spectrometer, and analyzes the interaction of electrons and x-rays with its key components.  Section 4 presents an analysis of electron energy spectra for several shots with different characteristics.  Section 5 discusses.  Section 6 summarizes the main findings. \n""")


document.add_heading('Two-screen method problem', level=1)
p = document.add_paragraph("""The two-screen method is one of the most popular ways to measure LWFA electrons. In this method, electrons were usually deflected by a permanent dipole magnet and imaged by two screens at different locations after the magnet. \n""")
p = document.add_paragraph("""In theory, any electron trajectories could be determined uniquely by three points in the space. \n""")
p = document.add_paragraph("""In reality, the features on two screens might not be comparable, because of the divergency of electrons which always existed. For example, the electron beams could be a single peak image on the first screen, which it might be two peaks on the second screen. \n""")
p = document.add_paragraph("""On the other hand, it is very important to find the correct correlated points on the screens to measure the spectrum of high energy electrons. A small error in the position measure would cause large errors in the spectrum measure, especially when the energy reaching \(10\ GeV\) level. \n""")
p = document.add_paragraph("""For example, in the simulation, the IP2 was separated from the magnet by 800 mm and the IP1was separated by 3000 mm. The real spectrum had two peaks. The center of one was at \(E_1=10\ GeV\), and the other one was at \(E_2=3.7\ GeV\). The divergencies of the electrons were \(\sigma=3.0\ mrad\). \n""")
p = document.add_paragraph("""There was two peaks on the IP1, while only one peak showed on the IP2. \n""")
document.add_picture('C:\\Users\\cheng\\Dropbox\\Struct\\Structure1.2.1\\Nini\\output\\paper\\spectrometer\\SecII\\F1.png', width=Inches(4.25))
p = document.add_paragraph("""Fig.1. (a) is the setup of a typical two-screen spectrometer. (a1) is the real spectrum of electrons. (a2) is the image on the IP2 screen. (a3) is the image on the IP1 screen. (a2) and (a3) are obtained from a GEANT4 simulation. 
(b) shows the intensity curves on both screens. The intensity is integrated over the Y-axis.\n""")
p = document.add_paragraph("""If we used the maximum point on the IP2 and the maximum point on the IP1 to define the trajectory, the energy of the trajectory would be \(18.56\ GeV\), while the real energy should be \(10\ GeV\).\n""")
p = document.add_paragraph("""As a result, we proposed a new design of spectrometer by using two sets of Tungsten fiducials with an image plate, instead of two screens. The fiducial would scatter electrons going through it and leaving a shadow on the image plate, which would provide two points on the trajectories.\n""")


document.add_heading('Experiment setup', level=1)
p = document.add_paragraph("""In the experiments, the dipole magnet was placed 143.5 mm behind the gas cell. The magnetic field was equal to 1.48 T with 50 mm for the width. \n""")
p = document.add_paragraph("""The <band> SR image plate (IP) was place 2672 mm after the magnet. The pixel size for the image plate was 50 um. The IP was scanned by XX, after every shot. \n""")
p = document.add_paragraph("""Both sets of fiducials were consisted of 8 Tungsten wires with 0.127 mm for the diameter. The first set of fiducial was away from the IP by 1442 mm, which was closer to the magnet and the second set of fiducials are 934 mm from the IP, which was closer to the IP. \n""")
p = document.add_paragraph("""The experiment setup is showed in the fig.3.\n""")
document.add_picture('C:\\Users\\cheng\\Dropbox\\Struct\\Structure1.2.1\\Nini\\output\\paper\\spectrometer\\13975\\calibration\\fig1.png', width=Inches(4.25))
p = document.add_paragraph("""\n""")
p = document.add_paragraph("""<LWFA parameters>\n""")
p = document.add_paragraph("""There were many things done to increase the position measurement accuracies of different components. \n""")
p = document.add_paragraph("""Two sets of fiducials were attach with the image plate holder by a stainless steel frame to increase the accuracy of position measurement. The accuracies of positions for fiducials and IP holder were XX mm. \n""")
p = document.add_paragraph("""Fiducials were Tungsten wires, because the heavy element material could scatter more electrons with a small diameter shape. GEANT4 simulations were used to help us study the properties of electrons scattering, which will be discussed in the next Sec.\n""")
p = document.add_paragraph("""The source locations could shifted randomly because of the laser pointing drifting. The IP position could also changed, because of the small gap between the holder and the IP. Those uncertainties were unavoidable, so we proposed a Betatron shadow calibration to calibrate both of locations. It will be discussed in the next next Sec.\n""")


document.add_heading('Fiducial electrons scattering', level=1)
p = document.add_paragraph("""For fiducial design, it is a tradeoff to project a thin shadow and a high constrast one. To project high constrast shadows, the fiducials need to be thick enough to scatter electrons by a large angle, while it needs to be thin to make the shadow thin as well. As a result, a heavy element material, for example Tungsten, is preferred. \n""")
p = document.add_paragraph("""Both the angular spread and the energy spread will affect the shadow constrast, which might be very different for different electron source. But the most fundamental requirement for the shadow formation is that the electrons scattered by fiducials should fall into pixels on the IP other than the original pixel. \n""")
p = document.add_paragraph("""We studied the scattering of electrons with different energy by different diameter of Tungsten wires by GEANT4 simulations. For monoenergetic electron inputs, the angular distributions of scattered electrons are Gaussian distributions, according to simluations. \n""")
p = document.add_paragraph("""The standard deviation of the distribution is a function of the input energy. The functions were found through simulations and results were showed in fig.4. \n""")
document.add_picture('C:\\Users\\cheng\\Dropbox\\Struct\\Structure1.2.1\\Nini\\output\\paper\\spectrometer\\SecIV\\fig1.png', width=Inches(4.25))
p = document.add_paragraph("""Fig.4. (a) shows \(\sigma\) as functions of E. Tungsten wires with diameter, D=0.050 mm, 0.127 mm, 0.200 mm, 0.400 mm and 0.800 mm were studied.
(b) is one of simulation results. 10 GeV electrons were scattered by a 0.127 mm Tungsten wire in this simulation. The figure shows the angular distribution of scattered electrons. The dots are simulation data, and the solid line is a Gaussian function, which is \(g(\theta)=A\ exp(-\theta^2/\sigma^2)\).\n""")
p = document.add_paragraph("""For 0.127 Tungsten wires, the standard deviation \(\sigma\) as a function of input energy can be expressed as following,\n""")

omml_xml = '<p xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><m:oMathPara><m:oMath><m:r><m:t>x=1</m:t></m:r></m:oMath></m:oMathPara></p>'
omml_el = parse_xml(omml_xml)[0]
p._p.append(omml_el)
p = document.add_paragraph('\n')

p = document.add_paragraph("""The shadow shape was also studied by simulations. The results were showed in fig.5. From the simulation, we learned that the shadow shape was determined by the divergency, \(\sigma\), v.s. the pixel size, \(\Delta\), over the separation, \(L\), between the wire and the IP. \n""")
p = document.add_paragraph("""To obtain a clear shadow on the IP, the condition is,\n""")

omml_xml = '<p xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><m:oMathPara><m:oMath><m:r><m:t>E=m_{e}\ c^{2}</m:t></m:r></m:oMath></m:oMathPara></p>'
omml_el = parse_xml(omml_xml)[0]
p._p.append(omml_el)
p = document.add_paragraph('\n')

document.add_picture('C:\\Users\\cheng\\Dropbox\\Struct\\Structure1.2.1\\Nini\\output\\paper\\spectrometer\\SecIV\\fig2.png', width=Inches(4.25))
p = document.add_paragraph("""Fig.5. the shadow shapes of a 0.127 mm Tungsten wire were studied for different spectrums and different wire positions. It was Gaussian spectrum for all simulation. The peak energies were 4.313 GeV, 8.67 GeV, 17.55 GeV, 36.0 GeV and 75.9 GeV for (i1)-(i5), wihch were corresponding to \(\sigma\)=0.8, 0.4, 0.2, 0.1 and 0.05 mrad. \n""")
p = document.add_paragraph("""The pixel size was 0.05 mm in simulations. Let's say the separation between the wire and the IP is L. Then L=500 mm, 250 mm and 125 mm for (a)'s, (b)'s and (c)'s, which corresponding to \(\Delta\)/L=0.1, 0.2 and 0.4 mrad. \n""")
p = document.add_paragraph("""In fact, the shadow shape is different for different electron energies. \n""")
p = document.add_paragraph("""For low-energy electrons, a fiducial projected a pit on the spectrum image. But for high-energy electrons, there were two peaks around the pit, which weren't there in the original spectrum. \n""")
p = document.add_paragraph("""The explanation is the high-energy electrons were scattered within a small angular range. Most of electrons were still falling on the IP around their original positions. Although in the origianl position, the intensity was lower, those places around the shadow had higher intensity, because the scattered electrons added intensity to those areas. \n""")
p = document.add_paragraph("""This phenomenon can be an evident of high energy electrons observation in a experiment. \n""")


document.add_heading('Betatron calibration', level=1)
p = document.add_paragraph("""LWFA electrons always came with Betatron radiations because of the oscillation caused by the focusing field. Since the most of Betatron radiations were generated by electrons in the end of acceleration process, the radiation sources were also the sources of electrons. \n""")
p = document.add_paragraph("""The SR IP is also able to record the X-ray intensities, and the same sets of fiducials also block X-rays from Betatron radiations leaving shadows on the IP. It is straight forward to connect fiducials and their correlated shadows, and to locate the source by crossing points of all trajectories. \n""")
p = document.add_paragraph("""The X-ray shadows are distinguishable from electron shadows, because the image of Betatron radiations are distinguishable from electrons. X-rays are not deflected by the magnet and will be imaged in the center area of the IP. And divergencies of Betatron radiations are much larger than electrons', as a result, electron shadows can only appear in the center area in the veritcal axis. \n""")
p = document.add_paragraph("""The two rows of fiducials can help with calibrating the IP position relative to the source. According to the simple geometric relations, if there were errors in IP positions, either longitudinal or tranversal, the two rows of fiducials would produce two sets of crossing points. Then it is an obvious calibration by moving the IP position to make the two sets as one. The accuracy of this calibration can be calculated from the geometric relations. \n""")
p = document.add_paragraph("""From our experiments, the waist of the Betatron radiation trajectories is usually couple hundreds of micro-meters. \n""")


document.add_heading('Approximate trajectory method and accuracy analysis', level=1)
p = document.add_paragraph("""Traditionally, the motion of electrons in a dipole magnet can be simplified as in an uniform magnetic field, since the trajectory is not sensitive to the shape of the distribution but only to the total magnetic flux. In an uniform magnetic field, the trajectory is two straight lines in the free space connecting by an arc in the magnetic field. \n""")
p = document.add_paragraph("""Here we proposed a further simplified method by assuming the field width to be infinitesimal, which keeping the total magentic flux constant. In this situation, the arc trajectory shrinked to a single point. The whole trajectory only consists of two straight lines connecting at the magnet position, or the center of the original magnetic field. \n""")
p = document.add_paragraph("""The difference in the directions between the two lines is determined by electron energy, by the following equations,\n""")

omml_xml = '<p xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><m:oMathPara><m:oMath><m:r><m:t>x=a+b+y</m:t></m:r></m:oMath></m:oMathPara></p>'
omml_el = parse_xml(omml_xml)[0]
p._p.append(omml_el)
p = document.add_paragraph('\n')


omml_xml = '<p xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><m:oMathPara><m:oMath><m:r><m:t>p=\sqrt{E^{2}/c^{2}-m_{e}^{2}\ c^{2}}</m:t></m:r></m:oMath></m:oMathPara></p>'
omml_el = parse_xml(omml_xml)[0]
p._p.append(omml_el)
p = document.add_paragraph('\n')

p = document.add_paragraph("""This method is accurate in the case of high energy electron trajectories. For example,\n""")
p = document.add_paragraph("""We built a simply equation to analyze the accuracy of the spectrometer base on this method. \n""")

omml_xml = '<p xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><m:oMathPara><m:oMath><m:r><m:t>f(x)=a\ x^{2}+b\ x</m:t></m:r></m:oMath></m:oMathPara></p>'
omml_el = parse_xml(omml_xml)[0]
p._p.append(omml_el)
p = document.add_paragraph('\n')

p = document.add_paragraph("""The maximum accuracy of this kind of spectrometers (for example, two-screen spectrometers) can also be calculated. \n""")

omml_xml = '<p xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><m:oMathPara><m:oMath><m:r><m:t>P\ V=n\ R\ T</m:t></m:r></m:oMath></m:oMathPara></p>'
omml_el = parse_xml(omml_xml)[0]
p._p.append(omml_el)
p = document.add_paragraph('\n')

p = document.add_paragraph("""We also developed a formula to calculate the spectrum image for electrons with any spectrums and any angular distributions. The calculated results were compared with GEANT4 simulations.\n""")


document.add_heading('Radiation method', level=1)
p = document.add_paragraph("""There may be a better design for high energy electron spectrometer base on bremsstrahlung radiations. Instead of fiducials, a thin Al foil can be put before the magnet to generate bremsstrahlung radiations. The X-rays will keep the electron launch angle before the magnet without deflected by the magnet, and will be recorded by the same IP. The distance from the radiation center to any points on the IP can reveal the deflection angle of electron through the magnet directly. \n""")
p = document.add_paragraph("""It is impossible to make an accurate launch angle measurement with the Betatron radiation only, because: 1. the anguler spread of Betatron radiation is too large. 2. the direction of Betatron radiation is not necessarily same as the electrons.\n""")
p = document.add_paragraph("""It is important to measure the X-rays and electrons on a same IP, because there will be no uncertainties on the relative separation between X-rays and electrons. The accuracy of this spectrometer is insensitive to the absolute position of the IP and the source (the Al foil position here). For example, .\n""")
p = document.add_paragraph("""It can also be proved by the method introduced in the last section. \n""")
p = document.add_paragraph("""The light element material is preferred, because it has less effects on the spectrum and angular profile of electrons. We also used GEANT4 to study the properties of Al foil scattering. \n""")
p = document.add_paragraph("""In addition to keep the launch angle information, it also keeps the angular distribution according to GEANT4 simulations. \n""")
p = document.add_paragraph("""It is even possible to retrieve the real spectrum of electrons from the convolution of divergencies, based on the formula in last section. Although it may be unnecessary. \n""")


document.add_heading('Summary', level=1)





document.add_page_break()
document.save('文档\\论文\\test\\text.docx')





## end
#792, 229:
"""
Nini, 打开天书(文件)
Nini, 打开人体模型(文件)

"""

+召唤规则(_媒介,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_凭依)...

->[==]"文本结构化"(,召唤星辰)...
    ->+整理结构(_媒介,_凭依)->+的(操作,+整理结构)...
    ->+分析段落(_媒介,_凭依)->+的(操作,+分析段落)...
    ->+简化内容(_媒介,_凭依)->+的(操作,+简化内容)




## end
#794, 10196:
文本结构化#0"

召唤规则:...
降临规则:...



"(,)
的#1""(文本结构化#0,降临规则#2)
降临规则#2"

简化内容:...
分析段落:...
整理结构:...

"(,)
的#3""(降临规则#2,简化内容#4)
简化内容#4"\"\"\"
P代码:...

\"\"\"
+简化内容(_媒介,_凭依)->+[del](,+简化内容)...
->的(简化内容,P代码)...

->+[python](Python,_凭依)->+[code](+[python],P代码)...
->+[s]\"text\"(+[python],_媒介)



"(,)
的#5""(简化内容#4,P代码#6)
P代码#6"\"\"\"
记住\"Python\"
print(re.sub(r'[\s]','','t e s t'))

\"\"\"

import re

i=0
j=0
ans=''
while True:
    if i+4<len(text) and text[i:i+4]=='<!--':
        i=i+4
        while True:
            if i+3<len(text) and text[i:i+3]=='-->':
                i+=3
                break
            elif i>=len(text):
                break
            else:
                i+=1
    else:
        ans+=text[i]

    if i<len(text)-1:
        i+=1
    else:
        break

ans=re.sub(r'<br>','\n',ans)
ans=re.sub(r'<i>','',ans)
ans=re.sub(r'</i>','',ans)
ans=re.sub(r'\n\s*\n','\n',ans)


\"\"\"
Nini, 打开词典(文件)
Nini, 打开公式分析器(文件)
记住\"Python\"

\"\"\""(,)
的#7""(降临规则#2,分析段落#8)
分析段落#8"\"\"\"
描述结构:...
库:...
Nini, 打开人体模型(文件)
+[新建阅读窗口](,描述结构)

\"\"\"
+分析段落(_媒介,_凭依)->+[del](,+分析段落)...
->的(分析段落,描述结构)->的(分析段落,库)...
->的(库,生成章节#0)...

->+[code]([想],描述结构)->[想](,_凭依)...
->结构([想],)...
->[]{
    []=>的(结构,章节)->章节->类型(章节,)...
    =>+的(_凭依,+章节)->[m_text](章节,+章节)->+是(章节,+章节)->+[del](,+是)...
        ->+[修改标题](,+章节)->[m_text](类型,+[修改标题])
}...

->操作([想],)...
->[]{
    []=>的(操作,生成章节)->生成章节(,章节)->章节->是(章节,_章节)...
    =>+[做](_媒介,_章节)->+[code](+[做],生成章节#0)
}


"(,)
的#9""(分析段落#8,库#10)
库#10"

生成章节:...





"(,)
的#11""(库#10,生成章节#12)
生成章节#12"\"\"\"
描述结构:...
库:...
+[新建阅读窗口](,描述结构)

保存:...
测试:...
+[新建阅读窗口](,测试)

\"\"\"

+生成章节(_媒介,_章节)->+[del](,+生成章节)...
->的(生成章节,描述结构)->的(生成章节,库)...

->+[code]([想],描述结构)->[想](,_章节)...
->结构([想],)...
->[]{
    []=>的(结构,章节)->章节->类型(章节,)...
    =>+的(_章节,+章节)->[m_text](章节,+章节)->+是(章节,+章节)->+[del](,+是)...
    ->+[修改标题](,+章节)->[m_text](类型,+[修改标题])...
    ->+[下一个](结构,+章节)->+下一个(结构,章节#0)->章节#0->+[del](,+下一个):
        ->头部(结构,)->+然后(章节#0,+章节)->+的(_章节,+然后),
        ->+头部(结构,)->+[del](,+头部)
}...

->操作([想],)...
->[]{
    []=>的(操作,_操作)->_操作(_主语,_宾语)->_主语->_宾语=>[说](,_操作)...
    ->的(库,_条目)->_条目->[eq](_条目,_操作)->是(_宾语,_节点)...
        ->+[做](_主语,_节点)->+[code](+[做],_条目)->+[.](+[做],_媒介)
}



"(,)
的#13""(生成章节#12,描述结构#14)
描述结构#14"\"\"\"
P代码:...
P代码2:...
段落:...

\"\"\"

+描述结构(,_凭依)->+[del](,+描述结构)...
->的(描述结构,P代码)->的(描述结构,P代码2)->的(描述结构,段落)...
->+操作(+描述结构,)->+结构(+描述结构,)...

->+[.]\"text_paper\"([python],_凭依)...
->+[code]([python],P代码)->[python](Python,)...

->+[.]([想],+操作)->+[.]([想],+结构)->+[code]([想],段落)...
->+不终止->+[code]([python]#2,P代码2)...

=>[python]#2(Python,+不终止)->[想](,_凭依)->章节([想],)->类型([想],)...
=>+的(+结构,+章节)->[m_text](章节,+章节)...
->+类型(+章节,)->[m_text](类型,+类型)...

->[]{
    []:->[==]\"图片\"(,类型)->+图片结构(_凭依,+章节)->+的(+操作,+图片结构),
    ->[==]\"公式\"(,类型)->+公式结构(_凭依,+章节)->+的(+操作,+公式结构),
    ->[]
}


"(,)
的#15""(描述结构#14,段落#16)
段落#16"\"\"\"
P代码:...
+[新建阅读窗口](,P代码)

\"\"\"

+段落(,_凭依)->.(+段落,操作)->.(+段落,结构)...
->的(段落,P代码)...

->+章节(+段落,)->+类型(+段落,)...
->+[o]\"text_sec\"([python],+章节)->+[o]\"type_sec\"([python],+类型)...
->+[code]([python],P代码)->[python](Python,)

"(,)
的#17""(段落#16,P代码#18)
P代码#18"\"\"\"


\"\"\"

state=True
while True:
    if list_i>=len(list_sec):
        type_sec='结束'
        break
    text_sec=list_sec[list_i]
    list_i+=1
    if text_sec!='':
        break

if type_sec=='结束':
    state=False
elif list_i==1:
    type_sec='题目'
elif len(text_sec)>4 and text_sec[0:4]=='%fig':
    type_sec='图片'
elif len(text_sec)>2 and text_sec[0:2]=='%[':
    type_sec='公式'
else:
    type_sec='文本'


"(,)
的#19""(描述结构#14,P代码#20)
P代码#20"\"\"\"
记住\"Python\"

\"\"\"


list_sec=text_paper.split('\n')
list_i=0
state=True


"(,)
的#21""(描述结构#14,P代码2#22)
P代码2#22"\"\"\"


\"\"\"

state=(list_i<len(list_sec))

"(,)
的#23""(生成章节#12,库#24)
库#24"

图片结构:...
公式结构:...
将条目\"图片结构\"复制为条目\"公式结构\"
将公式结构的\"图片\"替换为\"公式\"

"(,)
的#25""(库#24,公式结构#26)
公式结构#26"\"\"\"
描述结构:...
+[新建阅读窗口](,描述结构)

\"\"\"

+公式结构(_凭依,_公式)->+[del](,+公式结构)...
->的(公式结构,描述结构)...

->.(+公式结构,_媒介)...
->+[code]([想],描述结构)->[想](_媒介,_公式)...
->操作([想],)...
->的(操作,名字)->+的(_公式,+名字)->[m_text](名字,+名字)...
->的(操作,LaTeX)->+的(_公式,+LaTeX)->[m_text](LaTeX,+LaTeX)




"(,)
的#27""(公式结构#26,描述结构#28)
描述结构#28"\"\"\"
P代码:...
+[修改标题]\"收集公式\"(,收集图例)
+[删除结构](,收集公式)->+[del](,收集公式)

\"\"\"
+描述结构(_媒介,_公式)->+操作(+描述结构,)...
->的(描述结构,P代码)...

->+的(+操作,+名字)->+的(+操作,+LaTeX)...
->+[s]\"name_formula\"([python],_公式)->+[code]([python],P代码)...
->[python](Python,+名字)...

->的(_媒介,_表达式)->[标题](_表达式,)->[==](+名字,[标题])...
->[m_text](_表达式,+LaTeX)


"(,)
的#29""(描述结构#28,图例#30)
图例#30""(,)
的#31""(描述结构#28,P代码#32)
P代码#32"\"\"\"


\"\"\"

state=True
ans=name_formula[1:]




"(,)
的#33""(库#24,图片结构#34)
图片结构#34"\"\"\"
描述结构:...
库:...
+[新建阅读窗口](,描述结构)

\"\"\"

+图片结构(_凭依,_图片)->+[del](,+图片结构)...
->的(图片结构,描述结构)->的(图片结构,库)...

->.(+图片结构,_媒介)...
->+[code]([想],描述结构)->[想](,_图片)...
->操作([想],)...
->的(操作,名字)->+的(_图片,+名字)->[m_text](名字,+名字)...
->的(操作,图例)->+的(_图片,+图例)->[m_text](图例,+图例)...

->的(_媒介,_图片节点)->图片(_图片节点,)->[标题](_图片节点,)->[==]([标题],名字)...
->+的(_图片,+源地址)->[m_text](_图片节点,+源地址)...
->+的(_图片,+目标地址)...

->[]{
    []:->的(操作,结尾)->结尾(,_结尾)->然后(,_结尾)->+[左连](然后,_图片),
    ->[]
}...
->[]{
    []=>的(操作,删除)->删除(,_删除)=>+[del](,_删除)
}


"(,)
的#35""(图片结构#34,库#36)
库#36""(,)
的#37""(图片结构#34,描述结构#38)
描述结构#38"\"\"\"
收集图例:...
print(text_fig)

\"\"\"
+描述结构(,_图片)->+操作(+描述结构,)...
->的(描述结构,收集图例)...

->+的(+操作,+名字)->+的(+操作,+图例)...

->+[.]\"name_fig\"([python],_图片)->[python]\"text_fig=''
state=True\"(Python,)...

->+[.]([想],+操作)->+[code]([想],收集图例)->[想](,_图片)...

->+[o]\"name1\"([python]#2,+名字)->+[o]\"text_fig1\"([python]#2,+图例)...
->[python]#2\"name1=name
text_fig1=text_fig
state=True\"(Python,)


"(,)
的#39""(描述结构#38,收集图例#40)
收集图例#40"\"\"\"
P代码:...

\"\"\"

+收集图例(,_图片)->.(+收集图例,操作)...
->的(收集图例,P代码)...

->[]{
    []:->然后(_图片,_图例)->_图例->+[.]\"text_f\"([python],_图例)...
        ->+[code]([python],P代码)->[python](Python,)...
        ->+[.]([想],操作)->+[code]([想],收集图例)->[想](,_图例)...
        ->+删除(操作,然后)->+的(操作,+删除)...
        ->+删除(操作,_图例)->+的(操作,+删除),
    ->然后(_图片,_图例1)->_图例1->+结尾(,_图例1)->+的(操作,+结尾),
    ->[]
}


"(,)
的#41""(收集图例#40,P代码#42)
P代码#42"\"\"\"
记住\"Python\"

\"\"\"

state=True
name=name_fig[1:]

if text_f[0:4]=='Fig.':
    text_fig=text_f
elif text_f[0]=='(':
    text_fig+='\n'+text_f
else:
    state=False


"(,)
的#43""(描述结构#38,图例#44)
图例#44""(,)
的#45""(生成章节#12,保存#46)
保存#46"\"\"\"
描述结构:...
库:...
+[新建阅读窗口](,描述结构)


\"\"\"

+生成章节(_媒介,_章节)->+[del](,+生成章节)...
->的(生成章节,描述结构)->的(生成章节,库)...

->+[code]([想],描述结构)->[想](,_章节)...
->结构([想],)...
->[]{
    []=>的(结构,章节)->章节->类型(章节,)...
    =>+的(_章节,+章节)->[m_text](章节,+章节)->+是(章节,+章节)->+[del](,+是)...
    ->+[修改标题](,+章节)->[m_text](类型,+[修改标题])...
    ->[]{
        []:->上一个(结构,)->+上一个(结构,章节#0)->章节#0->+[del](,+上一个)...
            ->+[上一个](结构,+章节)->+然后(章节#0,+章节)->+的(_章节,+然后)...
            ->+[消息窗口]\"!!\"(,章节#0)->+[显示](,+然后),
        ->+[上一个](结构,+章节)
    }
}...

->操作([想],)...
->[]{
    []=>的(操作,_操作)->_操作(_主语,_宾语)->_主语->_宾语=>[说](,_操作)...
    ->的(库,_条目)->_条目->[eq](_条目,_操作)->是(_宾语,_节点)...
        ->+[做](_主语,_节点)->+[code](+[做],_条目)
}



"(,)
的#47""(生成章节#12,测试#48)
测试#48"+[设置结构](,测试)

有A, B和C

测试->的(测试,_A)->+[下一个A](测试,_A)->+下一个A(测试,_B)->+[显示](,_B)
测试->的(测试,_A)->+[下一个A](测试,_A)->+下一个A(测试,_B)->+[显示](,_A)

测试=>的(测试,_A)=>+[下一个A](测试,_A)->+下一个A(测试,_B)->+[显示](,_B)->+[del](,+下一个A)

测试=>的(测试,_A)=>+下一个A(测试,_B)->+[下一个A](测试,_A)->+[显示](,_B)->+[del](,+下一个A)


测试=>的(测试,_A)=>[]{
[]:->下一个A(测试,)->+下一个A(测试,_B)->_B->+[显示](,下一个A),
->+[下一个A](测试,_A)->+[显示](,_A)}

测试->+[下一个A](测试,C)=>的(测试,_A)=>[]{
[]:->+[下一个A](测试,_A)->+下一个A(测试,_B)->_B->+[显示](,_B),
->+[显示](,_A)}

测试->+[下一个A](测试,C)=>的(测试,_A)=>[]:
->下一个A(测试,)->+[下一个A](测试,_A)->+下一个A(测试,_B)->_B->+[显示](,_B),
->+[下一个A](测试,_A)->+[显示](,_A)


测试=>的(测试,_A)=>+[下一个A](测试,_A)...
->+下一个A(测试,_B)->+[del](,+下一个A)->[]:
->头部(测试,)->+[显示](,_A)->+[显示](,_B),
->+头部(测试,_A)


Nini, 打开结构语言Debug(文件)
测试=>的(测试,下一个A)=>+[del](,下一个A)"(,)
的#49""(测试#48,A#50)
A#50""(,)
的#51""(测试#48,B#52)
B#52""(,)
的#53""(测试#48,C#54)
C#54""(,)
的#55""(测试#48,头部#56)
头部#56""(测试#48,A#50)
的#57""(分析段落#8,描述结构#58)
描述结构#58"\"\"\"
P代码:...
P代码2:...
段落:...

\"\"\"

+描述结构(,_凭依)->+[del](,+描述结构)...
->的(描述结构,P代码)->的(描述结构,P代码2)->的(描述结构,段落)...
->+操作(+描述结构,)->+结构(+描述结构,)...

->+[.]\"text_paper\"([python],_凭依)...
->+[code]([python],P代码)->[python](Python,)...

->+[.]([想],+操作)->+[.]([想],+结构)->+[code]([想],段落)...
->+不终止->+[code]([python]#2,P代码2)...

=>[python]#2(Python,+不终止)->[想](,_凭依)->章节([想],)->类型([想],)...
=>+的(+结构,+章节)->[m_text](章节,+章节)...
->+类型(+章节,)->[m_text](类型,+类型)...

->[]{
    []:->[==]\"一级标题\"(,类型)->+生成章节(,+章节)->+的(+操作,+生成章节),
    ->[==]\"二级标题\"(,类型)->+生成章节(,+章节)->+的(+操作,+生成章节),
    ->[]
}


"(,)
的#59""(描述结构#58,P代码#60)
P代码#60"\"\"\"
记住\"Python\"

\"\"\"


list_sec=text_paper.split('\n')
list_i=0
state=True


"(,)
的#61""(描述结构#58,段落#62)
段落#62"\"\"\"
P代码:...
+[新建阅读窗口](,P代码)

\"\"\"

+段落(,_凭依)->.(+段落,操作)->.(+段落,结构)...
->的(段落,P代码)...

->+章节(+段落,)->+类型(+段落,)...
->+[o]\"text_sec\"([python],+章节)->+[o]\"type_sec\"([python],+类型)...
->+[code]([python],P代码)->[python](Python,)



"(,)
的#63""(段落#62,P代码#64)
P代码#64"\"\"\"


\"\"\"

state=True
while True:
    if list_i>=len(list_sec):
        type_sec='结束'
        break
    text_sec=list_sec[list_i]
    list_i+=1
    if text_sec!='':
        break

if type_sec=='结束':
    state=False
elif len(text_sec)>4 and text_sec[0:4]=='<h2>':
    text_sec=text_sec[4:]
    text_sec=text_sec[0:-5]
    type_sec='二级标题'
    while True:
        if list_i>=len(list_sec):
            break
        elif len(text_sec)>2 and list_sec[list_i][0:2]=='<h':
            break
        text_sec+=\"\n\"+list_sec[list_i]
        list_i+=1

elif len(text_sec)>4 and text_sec[0:4]=='<h1>':
    text_sec=text_sec[4:]
    text_sec=text_sec[0:-5]
    type_sec='一级标题'
else:
    type_sec='文本'


"(,)
的#65""(描述结构#58,P代码2#66)
P代码2#66"\"\"\"


\"\"\"

state=(list_i<len(list_sec))



"(,)
的#67""(降临规则#2,整理结构#68)
整理结构#68"\"\"\"


\"\"\"
+整理结构(,_凭依)->+[del](,+整理结构)...

->的(_凭依,召唤规则)->+[删除结构](,召唤规则)->+[del](,召唤规则)...
->的(_凭依,降临规则)->+[删除结构](,降临规则)->+[del](,降临规则)


"(,)
的#69""(文本结构化#0,召唤规则#70)
召唤规则#70"\"\"\"
Nini, 打开天书(文件)
Nini, 打开人体模型(文件)

\"\"\"

+召唤规则(_媒介,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_凭依)...

->[==]\"文本结构化\"(,召唤星辰)...
    ->+整理结构(_媒介,_凭依)->+的(操作,+整理结构)...
    ->+分析段落(_媒介,_凭依)->+的(操作,+分析段落)...
    ->+简化内容(_媒介,_凭依)->+的(操作,+简化内容)



"(,)

## end
#795, 356:
"""
Nini, 打开人体模型(文件)
Nini, 打开CBS(文件)

"""

+召唤规则(_媒介,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_凭依)...

->[==]"结构文本转docx"(,召唤星辰)...
    ->+整理图片(_媒介,_凭依)->+的(操作,+整理图片)...
    ->+整理内容(_媒介,_凭依)->+的(操作,+整理内容)...

->[]{
    []=>的(_媒介,_章节)->_章节=>+章节内容(_章节,_凭依)->+的(操作,+章节内容)
}...
->[]{
    []:->.(_媒介,_原始结构)->_原始结构(,)...
        ->+引用文章(_原始结构,_凭依)->+的(操作,+引用文章),
    ->[]
}

## end
#797, 10814:
文本转换_docx#0"

召唤规则:...
降临规则:...




"(,)
的#1""(文本转换_docx#0,召唤规则#2)
召唤规则#2"\"\"\"
Nini, 打开人体模型(文件)
Nini, 打开CBS(文件)

\"\"\"

+召唤规则(_媒介,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_凭依)...

->[==]\"结构文本转docx\"(,召唤星辰)...
    ->+整理图片(_媒介,_凭依)->+的(操作,+整理图片)...
    ->+整理内容(_媒介,_凭依)->+的(操作,+整理内容)...

->[]{
    []=>的(_媒介,_章节)->_章节=>+章节内容(_章节,_凭依)->+的(操作,+章节内容)
}...
->[]{
    []:->.(_媒介,_原始结构)->_原始结构(,)...
        ->+引用文章(_原始结构,_凭依)->+的(操作,+引用文章),
    ->[]
}
"(,)
的#3""(文本转换_docx#0,降临规则#4)
降临规则#4"有什么

引用文章:...
章节内容:...
整理内容:...
整理图片:...
+[新建阅读窗口](,章节内容)
将'引用文章'的\"作者\"替换为\"文章\"


"(,)
的#5""(降临规则#4,章节内容#6)
章节内容#6"\"\"\"
描述结构:...
库:...
+[新建阅读窗口](,库)

\"\"\"
+章节内容(_章节结构,_文本)->+[del](,+章节内容)...
->的(章节内容,描述结构)->的(章节内容,库)...

->+[code]([想],描述结构)->[想](_章节结构,_文本)...
->操作([想],)...
->[]{
    []=>的(操作,_操作)->_操作(_主语,_宾语)->_主语->_宾语(,)...
    =>[说](,_操作)...
        ->的(库,_条目)->_条目->[eq](_条目,_操作)->+[做](_主语,_宾语)->+[code](+[做],_条目)
}




"(,)
的#7""(章节内容#6,描述结构#8)
描述结构#8"\"\"\"


\"\"\"
+描述结构(_章节结构,_文本)->+操作(+描述结构,)...

->[]{
    []:->[is](_章节结构,一级标题)->一级标题(,)...
        ->+生成标题(一级标题,_文本)->+的(+操作,+生成标题),
    ->[is](_章节结构,文本)->文本(,)...
        ->+生成作者(文本,_文本)->+的(+操作,+生成作者),
    ->[is](_章节结构,_章节)->_章节->的(_章节,题目)->[==]\"Abstract\"(,题目)...
        ->+生成概述(_章节,_文本)->+的(+操作,+生成概述),
    ->[is](_章节结构,二级标题)->二级标题(,)...
        ->+生成章节(二级标题,_文本)->+的(+操作,+生成章节)
}


"(,)
的#9""(章节内容#6,库#10)
库#10"

生成标题:...
生成作者:...
生成概述:...
生成章节:...

将'生成作者'的\"章节\"替换为\"作者\"

"(,)
的#11""(库#10,生成标题#12)
生成标题#12"\"\"\"
L模板:...

\"\"\"

+生成标题(一级标题,_文本)->+[del](,+生成标题)...
->的(生成标题,L模板)...

->+的(_文本,+标题)...

->的(一级标题,题目)...
->+[模板文本](L模板,+标题)->+[.](+[模板文本],题目)


"(,)
的#13""(生成标题#12,L模板#14)
L模板#14"document.add_heading('%题目', 0)
"(,)
的#15""(库#10,生成概述#16)
生成概述#16"\"\"\"
L模板:...

\"\"\"

+生成概述(二级标题,_文本)->+[del](,+生成概述)...
->的(生成概述,L模板)...

->+的(_文本,+概述)...

->+[临时文本]->[]{
    []=>的(二级标题,文本)->文本=>+[增加内容2](文本,+[临时文本])
}...

->+[模板文本](L模板,+概述)->+[.](+[模板文本],+[临时文本])


"(,)
的#17""(生成概述#16,L模板#18)
L模板#18"p = document.add_paragraph('%[临时文本]\n')
"(,)
的#19""(库#10,生成章节#20)
生成章节#20"\"\"\"
描述结构:...
库:...
L模板:...
+[新建阅读窗口](,描述结构)

\"\"\"

+生成章节(_章节,_文本)->+[del](,+生成章节)...
->的(生成章节,描述结构)->的(生成章节,库)...
->的(生成章节,L模板)...

->+的(_文本,+章节)...
->+[code]([想],描述结构)->[想](_章节,)...

->操作([想],)...
->+[临时文本]#内容->[]{
    []=>的(操作,_操作)->_操作(_主语,)->_主语(,)...
    =>[说](,_操作)->的(库,_条目)->[eq](_条目,_操作)...
    ->+[做](_主语,+[临时文本]#内容)->+[code](+[做],_条目)
}...

->的(_章节,题目)...
->+[模板文本](L模板,+章节)...
->+[.]\"内容\"(+[模板文本],+[临时文本]#内容)->+[.](+[模板文本],题目)

"(,)
的#21""(生成章节#20,描述结构#22)
描述结构#22"\"\"\"


\"\"\"

+描述结构(_章节,)->+操作(+描述结构,)...

->[]{
    []=>的(_章节,_节点)->_节点=>[]:
        ->[is](_节点,文本)->文本->+文本结构(_节点,)->+的(+操作,+文本结构),
        ->[is](_节点,公式)->公式->+公式结构(_节点,)->+的(+操作,+公式结构),
        ->[is](_节点,图片)->图片->+图片结构(_节点,)->+的(+操作,+图片结构),
        ->[]
}

"(,)
的#23""(生成章节#20,库#24)
库#24"

文本结构:...
公式结构:...
图片结构:...




"(,)
的#25""(库#24,文本结构#26)
文本结构#26"\"\"\"
P代码:...
L模板:...

\"\"\"

+文本结构(_节点,_内容)->+[del](,+文本结构)...
->的(文本结构,L模板)->的(文本结构,P代码)...

->+[python](Python,+[临时文本]#内容)->+[code](+[python],P代码)...
->+[.]\"text_pt\"(+[python],_节点)...

->+[模板文本](L模板,+[增加内容2])->+[增加内容2](,_内容)...
->+[.]\"内容\"(+[模板文本],+[临时文本]#内容)

"(,)
的#27""(文本结构#26,L模板#28)
L模板#28"p = document.add_paragraph(\"\"\"%内容\n\"\"\")
"(,)
的#29""(文本结构#26,P代码#30)
P代码#30"\"\"\"
text_0='\\a'
print(text_0.replace('\\','\\\\'))
print(text_0)

\"\"\"

ans=text_pt.replace('\\','\\\\')

"(,)
的#31""(库#24,公式结构#32)
公式结构#32"\"\"\"
P代码:...
L模板:...
保存L模板:...

\"\"\"

+公式结构(_节点,_内容)->+[del](,+公式结构)...
->的(公式结构,L模板)->的(公式结构,P代码)...

->的(_节点,名字)->的(_节点,LaTeX)...

->+[python](Python,+[临时文本]#LaTeX)->+[code](+[python],P代码)...
->+[.]\"text_pt\"(+[python],LaTeX)...

->+[模板文本](L模板,+[增加内容2])->+[增加内容2](,_内容)...
->+[.](+[模板文本],名字)->+[.]\"LaTeX\"(+[模板文本],+[临时文本]#LaTeX)



"(,)
的#33""(公式结构#32,L模板#34)
L模板#34"p = document.add_paragraph(\"\"\"%LaTeX\n\"\"\")

"(,)
的#35""(公式结构#32,保存L模板#36)
保存L模板#36"
omml_xml = '<p xmlns:m=\"http://schemas.openxmlformats.org/officeDocument/2006/math\"><m:oMathPara><m:oMath><m:r><m:t>%LaTeX</m:t></m:r></m:oMath></m:oMathPara></p>'
omml_el = parse_xml(omml_xml)[0]
p._p.append(omml_el)
p = document.add_paragraph('\n')

"(,)
的#37""(公式结构#32,P代码#38)
P代码#38"\"\"\"
text_0='\\a'
print(text_0.replace('\\','\\\\'))
print(text_0)

\"\"\"

ans=text_pt.replace('\\','\\\\')

"(,)
的#39""(库#24,图片结构#40)
图片结构#40"\"\"\"
P代码:...
L模板:...

\"\"\"

+图片结构(_节点,_内容)->+[del](,+图片结构)...
->的(图片结构,L模板)->的(图片结构,P代码)...

->的(_节点,名字)->的(_节点,图例)->的(_节点,源地址)...
->的(_节点,目标地址)...
->+[python](Python,目标地址)->+[code](+[python],P代码)...
->+[.]\"source_dir\"(+[python],源地址)->+[.]\"fig_name\"(+[python],名字)...

->+[模板文本](L模板,+[增加内容2])->+[增加内容2](,_内容)...
->+[.](+[模板文本],名字)->+[.](+[模板文本],图例)...
->+[.](+[模板文本],目标地址)
"(,)
的#41""(图片结构#40,L模板#42)
L模板#42"document.add_picture('%目标地址', width=Inches(4.25))
p = document.add_paragraph(\"\"\"%图例\n\"\"\")
"(,)
的#43""(图片结构#40,P代码#44)
P代码#44"\"\"\"
记住\"Python\"
print(source_dir.replace('\\','\\\\'))

\"\"\"

fig_type=source_dir.split('.')[-1]
# ans='\\'+fig_name+'.'+fig_type
ans=source_dir.replace('\\','\\\\')

"(,)
的#45""(生成章节#20,L模板#46)
L模板#46"document.add_heading('%题目', level=1)
%内容

"(,)
的#47""(库#10,生成作者#48)
生成作者#48"\"\"\"
描述结构:...
库:...

\"\"\"

+生成作者(_作者,_文本)->+[del](,+生成作者)...
->的(生成作者,描述结构)->的(生成作者,库)...
->的(库,通讯作者)->的(库,普通作者)...

->+的(_文本,+作者)...
->+[code]([想],描述结构)->[想](_作者,)...

->操作([想],)...
->+[临时文本]#内容->[]{
    []=>的(操作,作者)->作者(类型,)->类型(,)...
    =>+[获取作者信息](,+作者A)->[m_text](作者,+[获取作者信息])...
    ->+[做](+作者A,+作者)...
    ->+[删除结构](,+作者A)->+[del](,+作者A)->[]:
        ->[==]\"通讯\"(,类型)->+[code](+[做],通讯作者),
        ->+[code](+[做],普通作者)
}


"(,)
的#49""(生成作者#48,库#50)
库#50"

通讯作者:...
普通作者:...
将'普通作者'的\"通讯\"替换为\"普通\"
"(,)
的#51""(库#50,通讯作者#52)
通讯作者#52"\"\"\"
L模板:...

\"\"\"
+通讯作者(_A,_输出)->+[del](,+通讯作者)...
->的(通讯作者,L模板)...

->的(_A,名)->的(_A,姓)->的(_A,单位)->的(_A,邮箱)...

->+[模板文本](L模板,+[增加内容2])->+[增加内容2](,_输出)...
->+[.](+[模板文本],名)->+[.](+[模板文本],姓)...
->+[.](+[模板文本],单位)->+[.](+[模板文本],邮箱)

"(,)
的#53""(通讯作者#52,L模板#54)
L模板#54"%名 %姓*, "(,)
的#55""(库#50,普通作者#56)
普通作者#56"\"\"\"
L模板:...

\"\"\"
+普通作者(_A,_输出)->+[del](,+普通作者)...
->的(普通作者,L模板)...

->的(_A,名)->的(_A,姓)->的(_A,单位)->的(_A,邮箱)...

->+[模板文本](L模板,+[增加内容2])->+[增加内容2](,_输出)...
->+[.](+[模板文本],名)->+[.](+[模板文本],姓)...
->+[.](+[模板文本],单位)

"(,)
的#57""(普通作者#56,L模板#58)
L模板#58"%名 %姓, "(,)
的#59""(生成作者#48,描述结构#60)
描述结构#60"\"\"\"
P代码:...
P代码2:...

\"\"\"

+描述结构(_作者,)->+操作(+描述结构,)...
->的(描述结构,P代码)->的(描述结构,P代码2)...

->+[.]\"text_au\"([python],_作者)...
->+[code]([python],P代码)->[python](Python,)...
->+[code]([python]#2,P代码2)...

->+不终止=>[python]\"state=(list_i<len(list_au))\"(Python,+不终止)...
=>+的(+操作,+作者)->+作者(+类型,)...
->+[o]\"type_name\"([python]#2,+类型)->[python]#2(Python,+作者)


"(,)
的#61""(描述结构#60,P代码#62)
P代码#62"\"\"\"
记住\"Python\"

\"\"\"

state=True
list_au=text_au.split(', ')
list_i=0

"(,)
的#63""(描述结构#60,P代码2#64)
P代码2#64"\"\"\"


\"\"\"

name=list_au[list_i]
list_i+=1
if name[-1]=='*':
    name=name[0:-1]
    type_name='通讯'
else:
    type_name=\"普通\"
ans=name

"(,)
的#65""(降临规则#4,整理内容#66)
整理内容#66"\"\"\"
P代码:...
L模板:...

\"\"\"

+整理内容(_媒介,_内容)->+[del](,+整理内容)...
->的(整理内容,L模板)->的(整理内容,P代码)...

->+[临时文本]#章节->[]{
    []=>的(_内容,章节)->章节=>+[增加内容](章节,+[临时文本]#章节)
}...
->+[python](Python,+[临时文本]#章节)->+[code](+[python],P代码)...
->+[s]\"file_text\"(+[python],+[临时文本]#章节)...

->+[模板文本](L模板,_内容)...
->+[.]\"章节\"(+[模板文本],+[临时文本]#章节)...
->[]{
    []:->的(_内容,标题)->标题->+[.](+[模板文本],标题),->[]
}...
->[]{
    []:->的(_内容,作者)->作者->+[.](+[模板文本],作者),->[]
}...
->[]{
    []:->的(_内容,概述)->概述->+[.](+[模板文本],概述),->[]
}...
->[]{
    []:->的(_内容,引用)->引用->+[.](+[模板文本],引用),->[]
}


"(,)
的#67""(整理内容#66,L模板#68)
L模板#68"
from docx import Document
from docx.shared import Inches
from docx.oxml import parse_xml

document = Document()

%标题
p = document.add_paragraph('%作者\n')

%概述
%章节


document.add_page_break()
document.save('%地址')




"(,)
的#69""(整理内容#66,P代码#70)
P代码#70"\"\"\"
print(\"112%13%1\".replace('%','\\%'))

\"\"\"

ans=file_text.replace('%','\\%')


"(,)
的#71""(降临规则#4,引用文章#72)
引用文章#72"\"\"\"
描述结构:...
设置引用:...
+[新建阅读窗口](,描述结构)

\"\"\"

+引用文章(_文章,_文本)->+[del](,+引用文章)...
->的(引用文章,描述结构)->的(引用文章,设置引用)...

->+的(_文本,+引用)...
->+[code]([想],描述结构)->[想](_文章,)...

->操作([想],)...
->+[临时文本]#内容->[]{
    []=>的(操作,文章)->文章(_节点,)->_节点(,)...
    =>+[获取论文信息](+[临时文本],+文章A)->[m_text](文章,+[临时文本])...
        ->[标题](_节点,)->[m_text]([标题],+文章A)...
        ->+[做](+文章A,+引用)->+[code](+[做],设置引用)...
        ->+[删除结构](,+文章A)->+[del](,+文章A)
}


"(,)
的#73""(引用文章#72,描述结构#74)
描述结构#74"\"\"\"
P代码:...

\"\"\"

+描述结构(_文章,)->+操作(+描述结构,)...
->的(描述结构,P代码)...

=>的(_文章,_节点)->引用(_节点,)...
=>+的(+操作,+文章)->+文章(_节点,)...
->+[.]\"paper_link\"([python],_节点)->+[code]([python],P代码)...
->[python](Python,+文章)



"(,)
的#75""(描述结构#74,P代码#76)
P代码#76"\"\"\"
记住\"Python\"

\"\"\"

ans=paper_link.split('#')[0]
state=True
"(,)
的#77""(引用文章#72,设置引用#78)
设置引用#78"\"\"\"
P代码:...
模板库:...

\"\"\"

+设置引用(文章A,引用)->+[del](,+设置引用)...
->的(设置引用,模板库)->的(设置引用,P代码)...

->的(文章A,类型)->的(文章A,作者)...
->+[python](Python,作者)->+[code](+[python],P代码)...
->+[s]\"text_aus\"(+[python],作者)...

->+[模板文本](,+[增加内容2])->+[增加内容2](,引用)...
->[]{
    []:->[==]\"ARTICLE\"(,类型)->的(模板库,文章#0)->+[code](+[模板文本],文章#0),
    ->[==]\"PROCEEDING\"(,类型)->的(模板库,会议#0)->+[code](+[模板文本],会议#0),
    ->的(模板库,文章#1)->+[code](+[模板文本],文章#1)
}...

->+[.]\"引用名\"(+[模板文本],文章A)...
->[]{
    []=>的(文章A,_性质)->_性质=>+[.](+[模板文本],_性质)
}



"(,)
的#79""(设置引用#78,模板库#80)
模板库#80"

文章:...
会议:...


"(,)
的#81""(模板库#80,文章#82)
文章#82"
@ARTICLE{%引用名,
   author       = \"%作者\",
   title        = \"%标题\",
   journal      = \"%期刊\",
   volume       = \"%编号\", 
   pages        = \"%页数\",
   year         = \"%年份\",
}
"(,)
的#83""(模板库#80,会议#84)
会议#84"
@PROCEEDINGS{%引用名,
   title = \"%标题\",
   number = \"%编号\",
   editor = \"\", 

   series = \"All ACM Conferences\",
   month = \"\",
   year = \"%年份\",
   address = \"%地址\",
   organization = \"%组织\",
   publisher = \"%会议\",
}
"(,)
的#85""(设置引用#78,P代码#86)
P代码#86"\"\"\"
记住\"Python\"

\"\"\"

# print(text_aus)
# print(text_aus.split(', '))
# print(' and '.join(text_aus.split(', ')))
ans=' and '.join(text_aus.split(', '))


"(,)
的#87""(降临规则#4,整理图片#88)
整理图片#88"\"\"\"
P代码:...
P代码2:...

\"\"\"

+整理图片(_媒介,_凭依)->+[del](,+整理图片)...
->的(整理图片,P代码)->的(整理图片,P代码2)...

->的#0(_凭依,地址)->+[标题](_凭依,)...
->+[python](Python,+[临时文本])->+[code](+[python],P代码)...
->+[.]\"file_name\"(+[python],+[标题])->+[.]\"folder_dir\"(+[python],地址)...

->+[模板文本](_凭依,_凭依)->+[.]\"地址\"(+[模板文本],+[临时文本])...
->+[P函数](,_凭依)...

->+[del](,的#0)...
->+[删除结构](,_凭依)...
->+[有](_凭依,地址)




"(,)
的#89""(整理图片#88,P代码#90)
P代码#90"\"\"\"


\"\"\"


output_dir=\"%s\\text.docx\"%(folder_dir)
ans=output_dir.replace('\\','\\\\')
"(,)
的#91""(整理图片#88,P代码2#92)
P代码2#92"\"\"\"
import shutil
shutil.copy(src_dir,\"%s\\fig.png\"%(folder_dir))

\"\"\"

import shutil
# print(src_dir,tar_dir)
# ans=\"%s\%s.tex\"%(folder_dir,file_name)
shutil.copy(src_dir,\"%s\\%s\"%(folder_dir,tar_dir))

"(,)

## end
#799, 106:
"""
text_0='\\a'
print(text_0.replace('\\','\\\\'))
print(text_0)

"""

ans=text_pt.replace('\\','\\\\')


## end
#801, 671:
"""
记住"Python"
LaTeX_text0="\frac{\sigma_E}{E}\approx \frac{1}{\beta-\theta}*\sqrt{(\frac{L_0+L_1}{L_0*L_2})^{2}*\sigma_s^{2}+(\frac{L_0+L_1+L_2}{L_0*L_2})^{2}*\sigma_f^{2}+(\frac{1}{L_0})^{2}*\sigma_o^{2}}"


LaTeX_text0="\begin{cases}\n\sigma=A_{3}/E^{3}+A_{2}/E^{2}+A_{1}/E+A_{0}\\\\ A_{3}=-4.583\times 10^{3}\ MeV^{3}\ rad\\ A_{2}=34.984\ MeV^{2}\ rad\\ A_{1}=3.421\ MeV\ rad\\\\ A_{0}=4.925\times 10^{-6}\ rad\n\end{cases}\n"

LaTeX_text0=""

print(len(LaTeX_text0)>100,len(LaTeX_text0))
print(LaTeX_text0.split('\n'))
print(list_eqs)

"""

list_eqs=LaTeX_text0.split('\\\\')

state=False
for eqn in list_eqs:
    if len(eqn)>110:
        state=True
        break



## end
#803, 88:

\begin{widetext}
\begin{equation}
%LaTeX
\label{eq:%名字}
\end{equation}
\end{widetext}


## end
#805, 253:

omml_xml = '<p xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math"><m:oMathPara><m:oMath><m:r><m:t>%LaTeX</m:t></m:r></m:oMath></m:oMathPara></p>'
omml_el = parse_xml(omml_xml)[0]
p._p.append(omml_el)
p = document.add_paragraph('\n')


## end
#807, 106:
"""
text_0='\\a'
print(text_0.replace('\\','\\\\'))
print(text_0)

"""

ans=text_pt.replace('\\','\\\\')


## end
#810, 169:
"""
print(text_context)

"""

if len(text_context)>4 and text_context[0:4]=='<h3>':
    ans='\\section{%s}\n\n'%(text_context[4:-5])
else:
    ans=text_context+'\n\n'



## end
#811, 485:
"""


"""

+描述结构(_章节,_文本)->+操作(+描述结构,)...

->[]{
    []=>的(_章节,_节点)->_节点=>[]:
        ->[is](_节点,文本)->文本->+文本结构(_节点,)->+的(+操作,+文本结构),
        ->[is](_节点,公式)->公式->+公式结构(_节点,)->+的(+操作,+公式结构),
        ->的(_节点,3D)->3D->+3D结构(_节点,)->+的(+操作,+3D结构),
        ->的(_节点,SVG)->SVG->+SVG结构(_节点,)->+的(+操作,+SVG结构),

        ->[is](_节点,图片)->图片->+图片结构(_节点,)->+的(+操作,+图片结构),
        ->[is](_节点,表格)->表格->+表格结构(_节点,)->+的(+操作,+表格结构),
        ->[is](_节点,程序)->程序->+程序结构(_节点,)->+的(+操作,+程序结构),
        ->[]
}


## end
#812, 158:
"""
print(text_context)

"""

if len(text_context)>4 and text_context[0:4]=='<h3>':
    ans='### %s\n'%(text_context[4:-5])
else:
    ans=text_context+'\n'



## end
#814, 184:
"""
P代码:...

"""

+文本结构(_节点,_内容)->+[del](,+文本结构)...
->的(文本结构,P代码)...

->+[python](Python,+[增加内容2])->+[code](+[python],P代码)...
->+[.]"text_context"(+[python],_节点)...

->+[增加内容2](,_内容)


## end
#815, 25:

$$
%LaTeX
\tag{%名字}
$$


## end
#816, 626:
"""
记住"Python"
测试:...
保存:...
print(LaTeX_text0)
print(re.sub('\n+$','',LaTeX_text0))
LaTeX_text

txt=r'I_{scatter}=\frac{1}{L_{2}}\ \int_{}^{}{d\theta\ }{S(E_{f}(\theta))\ f(\theta)\ \frac{\partial E_{f}}{\partial \theta}\ exp(-\frac{\alpha^{2}}{\sigma_{s}(E_{f}(\theta))^{2}})}'
print(txt.replace('\ ','\\\\ \n',1))


"""

state=True
ans=1
if len(LaTeX_text0)<150 or 'cases' in LaTeX_text0:
    LaTeX_text=LaTeX_text0
    ans=1
elif len(LaTeX_text0)<200:
    LaTeX_text=LaTeX_text0.replace('\ ','\\\\ \n',1)
    ans=3
else:
    LaTeX_text=LaTeX_text0
    ans=2

LaTeX_text=re.sub('\n+$','',LaTeX_text)
print(LaTeX_text,ans)


## end
#817, 25:

$$
%LaTeX
\tag{%名字}
$$


## end
#821, 664:
"""
P代码:...
设置公式:...
L模板:短公式...
L模板2:长公式...
L模板3:多行...

"""

+公式结构(_节点,_内容)->+[del](,+公式结构)...
->的(公式结构,L模板)->的(公式结构,L模板2)->的(公式结构,L模板3)...
->的(公式结构,P代码)->的(公式结构,设置公式)...

->的(_节点,名字)->的(_节点,LaTeX)...

->+[python](Python,+[临时文本]#名字)...
    ->+[code](+[python],设置公式)->+[.]"name"(+[python],名字)...

->+[模板文本](,+[增加内容2])->+[增加内容2](,_内容)...
->+[.]"名字"(+[模板文本],+[临时文本]#名字)...
->+[.]"LaTeX"(+[模板文本],+[临时文本]#t)...

->+[.]"LaTeX_text0"([python],LaTeX)...
->+[o]"LaTeX_text"([python],+[临时文本]#t)...
->+[code]([python],P代码)->[python](Python,+[临时文本]):
    ->[==]"1"(,+[临时文本])->+[code](+[模板文本],L模板),
    ->[==]"2"(,+[临时文本])->+[code](+[模板文本],L模板2),
    ->+[code](+[模板文本],L模板3)



## end
#822, 20:
<img src=".%目标地址"/>

## end
#823, 51:
"""
记住"Python"

"""

ans="/res/%s.svg"%(fig_name)


## end
#826, 542:
"""
P代码:...
L模板:...
模板2:...

"""

+SVG结构(_节点,_内容)->+[del](,+SVG结构)...
->的(SVG结构,L模板)->的(SVG结构,模板2)->的(SVG结构,P代码)...

->."输出"(+SVG结构,_输出)->的(_输出,地址)...

->的(_节点,名字)->的(_节点,内容)...
->+的(_节点,+目标地址)...

->+[python](Python,+目标地址)->+[code](+[python],P代码)...
->+[.]"fig_name"(+[python],名字)->+[.]"address"(+[python],地址)...

->+[模板文本](,+[增加内容2])->+[增加内容2](,_内容)...
->+[code](+[模板文本],L模板)...
->+[.](+[模板文本],+目标地址)->+[.](+[模板文本],名字)...

->+[模板文本](模板2,+[临时文本])->+[.](+[模板文本],内容)...
->+[增加内容](地址,+[保存文本])->+[增加内容](+目标地址,+[保存文本])...
    ->+[保存文本](,+[临时文本])

## end
#830, 124:


文本结构:...
公式结构:...
图片结构:...

3D结构:...
SVG结构:...
将条目"3D结构"复制为条目"SVG结构"

表格结构:...
程序结构:...
将条目"表格结构"复制为条目"程序结构"

输出页面:...




## end
#831, 11:
## %题目
%内容

## end
#835, 540:
"""
描述结构:...
库:...
L模板:...
+[新建阅读窗口](,描述结构)

"""

+生成章节(_章节,_文本)->+[del](,+生成章节)...
->的(生成章节,描述结构)->的(生成章节,库)...
->的(生成章节,L模板)->的(库,输出页面)...

->+的(_文本,+章节)->+的(+章节,+原型)->+原型(+章节,_章节)...
->+[code]([想],描述结构)->[想](_章节,+章节)...

->操作([想],)...
->+[临时文本]#内容->[]{
    []=>的(操作,_操作)->_操作(_主语,)->_主语(,)...
    =>[说](,_操作)->的(库,_条目)->[eq](_条目,_操作)...
    ->+[做](_主语,+[临时文本]#内容)->+[code](+[做],_条目)->+[.]"输出"(+[做],_文本)
}...

->的(_章节,题目)...
->+[模板文本](L模板,+章节)...
->+[.]"内容"(+[模板文本],+[临时文本]#内容)->+[.](+[模板文本],题目)...

->+[做](_章节,+章节)->+[code](+[做],输出页面)



## end
#838, 284:
"""
记住"Python"
+[P函数](,测试)
text_fig=''
text_f='Fig.X test'

"""
import re

fig_pat='Fig.[a-zA-Z_\.]* '
a=re.match(fig_pat,text_f)

if text_f[0:4]=='Fig.':
    i=a.span()[1]
    text_fig=text_f[i:]
elif text_f[0]=='(':
    text_fig+='\n'+text_f
else:
    state=False

print(text_fig)


## end
#839, 543:
"""
+[P函数](,测试)
Nini, 打开公式分析器(文件)

"""

list_lk=['a1','a2','c1']
paper_text="""
[a1,a2]
[1].
[c1],[c1]

"""

import re

link_pat='\[([a-zA-Z]+\d*)(, ?[a-zA-Z]+\d*)*\]'
i=0
out_text=''

while True:
    if i>=len(paper_text):
        break
    a=re.match(link_pat,paper_text[i:])
    if a!=None and a.group(1) in list_lk:
        new_text='\\cite{%s}'%(a.group()[1:-1])
        di0=a.span()[1]
        out_text+=new_text
        i+=di0-1
    else:
        out_text+=paper_text[i]

    i+=1

print(out_text)


"""
print(a.span())
+[P函数](,测试)

"""
## end
#841, 422:
"""
记住"Python"
测试:...

"""

import re

link_pat='\[([a-zA-Z]+\d*)(, ?[a-zA-Z]+\d*)*\]'
i=0
out_text=''

while True:
    if i>=len(paper_text):
        break
    a=re.match(link_pat,paper_text[i:])
    if a!=None and a.group(1) in list_lk:
        new_text='\\cite{%s}'%(a.group()[1:-1])
        di0=a.span()[1]
        out_text+=new_text
        i+=di0-1
    else:
        out_text+=paper_text[i]
    i+=1

ans=out_text



## end
#843, 390:
"""
P代码:...
print(list_lk)
print(paper_text)

"""

+整理引用(_媒介,_文本)->+[del](,+整理引用)...
->的(整理引用,P代码)...

->.(_媒介,_文章)...
->+[python]"list_lk=[]"(Python,)->[]{
    []=>的(_文章,_节点)->_节点->引用(_节点,)...
    =>+[标题](_节点,)->+[python]"list_lk.append(name)"(Python,)...
        ->+[s]"name"(+[python],+[标题])
}...

->+[python](Python,_文本)->+[code](+[python],P代码)...
->+[s]"paper_text"(+[python],_文本)





## end
#846, 217:

@ARTICLE{%引用名, 
   author        = "%作者", 
   title         = "%标题", 
   journal = {ArXiv e-prints},
   archivePrefix = "arXiv",
   eprint        = {%eprint},
   primaryClass  = "%类别",
   year          = "%日期",
}




## end
#848, 24:

$$
%LaTeX
\tag{%名字}
$$

## end
#850, 525:
LaTeX_text0="\frac{\sigma_E}{E}\approx \frac{1}{\beta-\theta}*\sqrt{(\frac{L_0+L_1}{L_0*L_2})^{2}*\sigma_s^{2}+(\frac{L_0+L_1+L_2}{L_0*L_2})^{2}*\sigma_f^{2}+(\frac{1}{L_0})^{2}*\sigma_o^{2}}"


LaTeX_text0="\begin{cases}\n\sigma=A_{3}/E^{3}+A_{2}/E^{2}+A_{1}/E+A_{0}\\\\ A_{3}=-4.583\times 10^{3}\ MeV^{3}\ rad\\ A_{2}=34.984\ MeV^{2}\ rad\\ A_{1}=3.421\ MeV\ rad\\\\ A_{0}=4.925\times 10^{-6}\ rad\n\end{cases}\n"

LaTeX_text0=""

print(len(LaTeX_text0)>100,len(LaTeX_text0))
print(LaTeX_text0.split('\n'))
print(list_eqs)

## end
#852, 172:
"""
记住"Python"
测试:...
print(LaTeX_text0)

"""

list_eqs=LaTeX_text0.split('\\\\')

state=False
for eqn in list_eqs:
    if len(eqn)>110:
        state=True
        break



## end
#855, 521:
"""
Nini, 打开人体模型(文件)
Nini, 打开CBS(文件)

"""

+召唤规则(_媒介,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_凭依)...

->[==]"结构文本转LaTeX"(,召唤星辰)...
    ->+整理图片(_媒介,_凭依)->+的(操作,+整理图片)...
    ->+整理公式引用(_媒介,_凭依)->+的(操作,+整理公式引用)...
    ->+整理表格引用(_媒介,_凭依)->+的(操作,+整理表格引用)...
    ->+整理图片引用(_媒介,_凭依)->+的(操作,+整理图片引用)...
    ->+整理引用(_媒介,_凭依)->+的(操作,+整理引用)...
    ->+整理内容(_媒介,_凭依)->+的(操作,+整理内容)...

->[]{
    []=>的(_媒介,_章节)->_章节=>+章节内容(_章节,_凭依)->+的(操作,+章节内容)
}...
->[]{
    []:->.(_媒介,_原始结构)->_原始结构(,)...
        ->+引用文章(_原始结构,_凭依)->+的(操作,+引用文章),
    ->[]
}

## end
#856, 890:
"""
+[P函数](,测试2)
print(list_lk)

"""

import re

paper_text="""
The algorithm of recovering complete electron trajectories from source to detector is schematically shown in Fig.[_setup1]. In Fig.[_setup1], 

"""

link_pat='([fF])ig.\[([a-zA-Z0-9_\.]+)\]'
link_pat2='Figure \[([a-zA-Z0-9_\.]+)\]'
i=0
out_text=''

while True:
    if i>=len(paper_text):
        break
    a=re.match(link_pat,paper_text[i:])
    a2=re.match(link_pat2,paper_text[i:])
    if a!=None and a.group(2) in list_lk:
        new_text='%sig.~\\ref{fig:%s}'%(a.group(1),a.group(2))
        di0=a.span()[1]
        out_text+=new_text
        i+=di0-1
    elif a2!=None and a2.group(1) in list_lk:
        new_text='Figure ~\\ref{fig:%s}'%(a2.group(1))
        di0=a.span()[1]
        out_text+=new_text
        i+=di0-1
    else:
        out_text+=paper_text[i]
    i+=1

ans=out_text

print(paper_text)
print(out_text)

## end
#857, 543:
"""
+[P函数](,测试)
Nini, 打开公式分析器(文件)

"""

list_lk=['a1','a2','c1']
paper_text="""
[a1,a2]
[1].
[c1],[c1]

"""

import re

link_pat='\[([a-zA-Z]+\d*)(, ?[a-zA-Z]+\d*)*\]'
i=0
out_text=''

while True:
    if i>=len(paper_text):
        break
    a=re.match(link_pat,paper_text[i:])
    if a!=None and a.group(1) in list_lk:
        new_text='\\cite{%s}'%(a.group()[1:-1])
        di0=a.span()[1]
        out_text+=new_text
        i+=di0-1
    else:
        out_text+=paper_text[i]

    i+=1

print(out_text)


"""
print(a.span())
+[P函数](,测试)

"""
## end
#860, 692:
"""
记住"Python"
测试:...
测试2:...

"""

import re

link_pat='([fF])ig.\[([a-zA-Z0-9_\.]+)\]'
link_pat2='Figure \[([a-zA-Z0-9_\.]+)\]'
i=0
out_text=''

while True:
    if i>=len(paper_text):
        break
    a=re.match(link_pat,paper_text[i:])
    a2=re.match(link_pat2,paper_text[i:])
    if a!=None and a.group(2) in list_lk:
        new_text='%sig.~\\ref{fig:%s}'%(a.group(1),a.group(2))
        di0=a.span()[1]
        out_text+=new_text
        i+=di0-1
    elif a2!=None and a2.group(1) in list_lk:
        new_text='Figure ~\\ref{fig:%s}'%(a2.group(1))
        di0=a2.span()[1]
        out_text+=new_text
        i+=di0-1
    else:
        out_text+=paper_text[i]
    i+=1

ans=out_text



## end
#861, 543:
"""
+[P函数](,测试)
Nini, 打开公式分析器(文件)

"""

list_lk=['a1','a2','c1']
paper_text="""
[a1,a2]
[1].
[c1],[c1]

"""

import re

link_pat='\[([a-zA-Z]+\d*)(, ?[a-zA-Z]+\d*)*\]'
i=0
out_text=''

while True:
    if i>=len(paper_text):
        break
    a=re.match(link_pat,paper_text[i:])
    if a!=None and a.group(1) in list_lk:
        new_text='\\cite{%s}'%(a.group()[1:-1])
        di0=a.span()[1]
        out_text+=new_text
        i+=di0-1
    else:
        out_text+=paper_text[i]

    i+=1

print(out_text)


"""
print(a.span())
+[P函数](,测试)

"""
## end
#863, 430:
"""
记住"Python"
测试:...

"""

import re

link_pat='\[([a-zA-Z_]+[_\d]*)(, ?[a-zA-Z_]+[_\d]*)*\]'
i=0
out_text=''

while True:
    if i>=len(paper_text):
        break
    a=re.match(link_pat,paper_text[i:])
    if a!=None and a.group(1) in list_lk:
        new_text='\\cite{%s}'%(a.group()[1:-1])
        di0=a.span()[1]
        out_text+=new_text
        i+=di0-1
    else:
        out_text+=paper_text[i]
    i+=1

ans=out_text



## end
#865, 390:
"""
P代码:...
print(list_lk)
print(paper_text)

"""

+整理引用(_媒介,_文本)->+[del](,+整理引用)...
->的(整理引用,P代码)...

->.(_媒介,_文章)...
->+[python]"list_lk=[]"(Python,)->[]{
    []=>的(_文章,_节点)->_节点->引用(_节点,)...
    =>+[标题](_节点,)->+[python]"list_lk.append(name)"(Python,)...
        ->+[s]"name"(+[python],+[标题])
}...

->+[python](Python,_文本)->+[code](+[python],P代码)...
->+[s]"paper_text"(+[python],_文本)





## end
#866, 763:
"""
+[P函数](,测试2)
print(list_lk)

"""

import re

link_pat='([eE])qn.(\[[a-zA-Z0-9_\.]+\]\.)'
link_pat2='Equation (\[[a-zA-Z0-9_\.]+\]\.)'
i=0
out_text=''
paper_text="""
Eqn.[4].

"""

while True:
    if i>=len(paper_text):
        break
    a=re.match(link_pat,paper_text[i:])
    a2=re.match(link_pat2,paper_text[i:])
    if a!=None and a.group(2) in list_lk:
        new_text='%sqn.~\\ref{eq:%s}'%(a.group(1),a.group(2))
        di0=a.span()[1]
        out_text+=new_text
        i+=di0-1
    elif a2!=None and a2.group(1) in list_lk:
        new_text='Equation ~\\ref{eq:%s}'%(a2.group(1))
        di0=a2.span()[1]
        out_text+=new_text
        i+=di0-1
    else:
        out_text+=paper_text[i]
    i+=1

ans=out_text

print(paper_text)
print(out_text)


## end
#867, 543:
"""
+[P函数](,测试)
Nini, 打开公式分析器(文件)

"""

list_lk=['a1','a2','c1']
paper_text="""
[a1,a2]
[1].
[c1],[c1]

"""

import re

link_pat='\[([a-zA-Z]+\d*)(, ?[a-zA-Z]+\d*)*\]'
i=0
out_text=''

while True:
    if i>=len(paper_text):
        break
    a=re.match(link_pat,paper_text[i:])
    if a!=None and a.group(1) in list_lk:
        new_text='\\cite{%s}'%(a.group()[1:-1])
        di0=a.span()[1]
        out_text+=new_text
        i+=di0-1
    else:
        out_text+=paper_text[i]

    i+=1

print(out_text)


"""
print(a.span())
+[P函数](,测试)

"""
## end
#870, 700:
"""
记住"Python"
测试:...
测试2:...

"""

import re

link_pat='([eE])qn?\.(\[[a-zA-Z0-9_\.]+\]\.)'
link_pat2='Equation (\[[a-zA-Z0-9_\.]+\]\.)'
i=0
out_text=''

while True:
    if i>=len(paper_text):
        break
    a=re.match(link_pat,paper_text[i:])
    a2=re.match(link_pat2,paper_text[i:])
    if a!=None and a.group(2) in list_lk:
        new_text='%sqn.~\\ref{eq:%s}'%(a.group(1),a.group(2))
        di0=a.span()[1]
        out_text+=new_text
        i+=di0-1
    elif a2!=None and a2.group(1) in list_lk:
        new_text='Equation ~\\ref{eq:%s}'%(a2.group(1))
        di0=a2.span()[1]
        out_text+=new_text
        i+=di0-1
    else:
        out_text+=paper_text[i]
    i+=1

ans=out_text



## end
#871, 491:
"""


"""
+描述结构(_章节结构,_文本)->+操作(+描述结构,)...

->[]{
    []:->[is](_章节结构,一级标题)->一级标题(,)...
        ->+生成标题(一级标题,_文本)->+的(+操作,+生成标题),
    ->[is](_章节结构,文本)->文本(,)...
        ->+生成作者(文本,_文本)->+的(+操作,+生成作者),
    ->[is](_章节结构,_章节)->_章节->的(_章节,题目)->[==]"Abstract"(,题目)...
        ->+生成概述(_章节,_文本)->+的(+操作,+生成概述),
    ->[is](_章节结构,_附录)->_附录->的(_附录,题目#2)->[==]"Appendix"(,题目#2)...
        ->+生成附录(_附录,_文本)->+的(+操作,+生成附录),
    ->[is](_章节结构,二级标题)->二级标题(,)...
        ->+生成章节(二级标题,_文本)->+的(+操作,+生成章节)
}



## end
#872, 20:

\section{%题目}
%内容


## end
#873, 104:

\begin{figure*}
\includegraphics[width=0.9 \textwidth]{%名字}
\caption{\label{fig:%名字}%图例}
\end{figure*}

## end
#874, 708:
"""
记住"Python"
print(np.max([1,2]))
+[P函数](,P代码)
txt_out[-1]
print(txt_out)
text=txt_in

"""
import numpy as np
import re

rows=txt_in.split('\n')
txt_out=''
type_out=''
len_max=0

for row in rows:
    row0=re.sub('; *','',row)
    if row0=='':
        continue
    list_ele=re.split('[,] *',row0)

    len_max=np.max([len_max,len(list_ele)])

    if txt_out=='':
        for txt_ele in list_ele:
            txt_out+="\n\\textrm{%s}&"%(txt_ele)
        txt_out=txt_out[0:-1]
        txt_out+='\\\\\n\\colrule'
    else:
        for txt_ele in list_ele:
            txt_out+=" %s &"%(txt_ele)
        txt_out=txt_out[0:-1]
        txt_out+='\\\\\n'

for i in range(len_max):
    type_out+='c'

ans=txt_out



## end
#875, 143:

\begin{table}[%位置]
\caption{\label{tab:%名字}%图例}
\begin{ruledtabular}
\begin{tabular}{%格式}
%内容
\end{tabular}
\end{ruledtabular}
\end{table}




## end
#879, 570:
"""
P代码:...
L模板:...
L模板2:...

"""

+表格结构(_节点,_内容)->+[del](,+表格结构)...
->的(表格结构,L模板)->的(表格结构,L模板2)->的(表格结构,P代码)...

->的(_节点,类型)->的(_节点,位置)...
->的(_节点,名字)->的(_节点,图例)...
->的(_节点,内容)...
->+[python](Python,+[临时文本])->+[code](+[python],P代码)...
->+[.]"txt_in"(+[python],内容)->+[.]"fig_name"(+[python],名字)...

->+[模板文本](,+[增加内容2])->+[增加内容2](,_内容)...
->+[.](+[模板文本],名字)->+[.](+[模板文本],图例)->+[.](+[模板文本],位置)...
->+[.]"内容"(+[模板文本],+[临时文本])...
->+[o]"type_out"(+[python],+格式)->+[.](+[模板文本],+格式)->+[del](,+格式)...
->[]:

->[==]"normal"(,类型)->+[code](+[模板文本],L模板),
->+[code](+[模板文本],L模板2)

## end
#880, 56:

\begin{multline}
%LaTeX
\label{eq:%名字}
\end{multline}


## end
#881, 56:

\begin{equation}
%LaTeX
\label{eq:%名字}
\end{equation}


## end
#882, 172:
"""
记住"Python"
测试:...
print(LaTeX_text0)

"""

list_eqs=LaTeX_text0.split('\\\\')

state=False
for eqn in list_eqs:
    if len(eqn)>110:
        state=True
        break



## end
#883, 525:
LaTeX_text0="\frac{\sigma_E}{E}\approx \frac{1}{\beta-\theta}*\sqrt{(\frac{L_0+L_1}{L_0*L_2})^{2}*\sigma_s^{2}+(\frac{L_0+L_1+L_2}{L_0*L_2})^{2}*\sigma_f^{2}+(\frac{1}{L_0})^{2}*\sigma_o^{2}}"


LaTeX_text0="\begin{cases}\n\sigma=A_{3}/E^{3}+A_{2}/E^{2}+A_{1}/E+A_{0}\\\\ A_{3}=-4.583\times 10^{3}\ MeV^{3}\ rad\\ A_{2}=34.984\ MeV^{2}\ rad\\ A_{1}=3.421\ MeV\ rad\\\\ A_{0}=4.925\times 10^{-6}\ rad\n\end{cases}\n"

LaTeX_text0=""

print(len(LaTeX_text0)>100,len(LaTeX_text0))
print(LaTeX_text0.split('\n'))
print(list_eqs)

## end
#886, 626:
"""
记住"Python"
测试:...
保存:...
print(LaTeX_text0)
print(re.sub('\n+$','',LaTeX_text0))
LaTeX_text

txt=r'I_{scatter}=\frac{1}{L_{2}}\ \int_{}^{}{d\theta\ }{S(E_{f}(\theta))\ f(\theta)\ \frac{\partial E_{f}}{\partial \theta}\ exp(-\frac{\alpha^{2}}{\sigma_{s}(E_{f}(\theta))^{2}})}'
print(txt.replace('\ ','\\\\ \n',1))


"""

state=True
ans=1
if len(LaTeX_text0)<150 or 'cases' in LaTeX_text0:
    LaTeX_text=LaTeX_text0
    ans=1
elif len(LaTeX_text0)<200:
    LaTeX_text=LaTeX_text0.replace('\ ','\\\\ \n',1)
    ans=3
else:
    LaTeX_text=LaTeX_text0
    ans=2

LaTeX_text=re.sub('\n+$','',LaTeX_text)
print(LaTeX_text,ans)


## end
#887, 88:

\begin{widetext}
\begin{equation}
%LaTeX
\label{eq:%名字}
\end{equation}
\end{widetext}


## end
#892, 530:
"""
P代码:...
L模板:短公式...
L模板2:长公式...
L模板3:多行...

"""

+公式结构(_节点,_内容)->+[del](,+公式结构)...
->的(公式结构,L模板)->的(公式结构,L模板2)->的(公式结构,L模板3)...
->的(公式结构,P代码)...

->的(_节点,名字)->的(_节点,LaTeX)...
->+[模板文本](,+[增加内容2])->+[增加内容2](,_内容)...
->+[.](+[模板文本],名字)->+[.]"LaTeX"(+[模板文本],+[临时文本]#t)...

->+[.]"LaTeX_text0"([python],LaTeX)...
->+[o]"LaTeX_text"([python],+[临时文本]#t)...
->+[code]([python],P代码)->[python](Python,+[临时文本]):
    ->[==]"1"(,+[临时文本])->+[code](+[模板文本],L模板),
    ->[==]"2"(,+[临时文本])->+[code](+[模板文本],L模板2),
    ->+[code](+[模板文本],L模板3)



## end
#893, 172:
"""
print(text_context)

"""

if len(text_context)>4 and text_context[0:4]=='<h3>':
    ans='\\subsection{%s}\n\n'%(text_context[4:-5])
else:
    ans=text_context+'\n\n'



## end
#895, 184:
"""
P代码:...

"""

+文本结构(_节点,_内容)->+[del](,+文本结构)...
->的(文本结构,P代码)...

->+[python](Python,+[增加内容2])->+[code](+[python],P代码)...
->+[.]"text_context"(+[python],_节点)...

->+[增加内容2](,_内容)


## end
#899, 62:


文本结构:...
公式结构:...
图片结构:...
表格结构:...
将条目"图片结构"复制为条目"表格结构"




## end
#900, 315:
"""


"""

+描述结构(_章节,)->+操作(+描述结构,)...

->[]{
    []=>的(_章节,_节点)->_节点=>[]:
        ->[is](_节点,文本)->文本->+文本结构(_节点,)->+的(+操作,+文本结构),
        ->[is](_节点,公式)->公式->+公式结构(_节点,)->+的(+操作,+公式结构),
        ->[is](_节点,图片)->图片->+图片结构(_节点,)->+的(+操作,+图片结构),
        ->[is](_节点,表格)->表格->+表格结构(_节点,)->+的(+操作,+表格结构),
        ->[]
}


## end
#904, 439:
"""
描述结构:...
库:...
L模板:...
+[新建阅读窗口](,描述结构)

"""

+生成章节(_章节,_文本)->+[del](,+生成章节)...
->的(生成章节,描述结构)->的(生成章节,L模板)...
->的(生成章节,库)...


->+的(_文本,+章节)...
->+[code]([想],描述结构)->[想](_章节,)...

->操作([想],)...
->+[临时文本]#内容->[]{
    []=>的(操作,_操作)->_操作(_主语,)->_主语(,)...
    =>[说](,_操作)->的(库,_条目)->[eq](_条目,_操作)...
    ->+[做](_主语,+[临时文本]#内容)->+[code](+[做],_条目)
}...

->的(_章节,题目)...
->+[模板文本](L模板,+章节)...
->+[.]"内容"(+[模板文本],+[临时文本]#内容)->+[.](+[模板文本],题目)


## end
#905, 12:
\title{%题目}

## end
#907, 144:
"""
L模板:...

"""

+生成标题(一级标题,_文本)->+[del](,+生成标题)...
->的(生成标题,L模板)...

->+的(_文本,+标题)...

->的(一级标题,题目)...
->+[模板文本](L模板,+标题)->+[.](+[模板文本],题目)



## end
#908, 40:
\begin{abstract}
%[临时文本]
\end{abstract}

## end
#910, 199:
"""
L模板:...

"""

+生成概述(二级标题,_文本)->+[del](,+生成概述)...
->的(生成概述,L模板)...

->+的(_文本,+概述)...

->+[临时文本]->[]{
    []=>的(二级标题,文本)->文本=>+[增加内容2](文本,+[临时文本])
}...

->+[模板文本](L模板,+概述)->+[.](+[模板文本],+[临时文本])



## end
#911, 315:
"""


"""

+描述结构(_章节,)->+操作(+描述结构,)...

->[]{
    []=>的(_章节,_节点)->_节点=>[]:
        ->[is](_节点,文本)->文本->+文本结构(_节点,)->+的(+操作,+文本结构),
        ->[is](_节点,公式)->公式->+公式结构(_节点,)->+的(+操作,+公式结构),
        ->[is](_节点,图片)->图片->+图片结构(_节点,)->+的(+操作,+图片结构),
        ->[is](_节点,表格)->表格->+表格结构(_节点,)->+的(+操作,+表格结构),
        ->[]
}


## end
#912, 169:
"""
print(text_context)

"""

if len(text_context)>4 and text_context[0:4]=='<h3>':
    ans='\\section{%s}\n\n'%(text_context[4:-5])
else:
    ans=text_context+'\n\n'



## end
#914, 184:
"""
P代码:...

"""

+文本结构(_节点,_内容)->+[del](,+文本结构)...
->的(文本结构,P代码)...

->+[python](Python,+[增加内容2])->+[code](+[python],P代码)...
->+[.]"text_context"(+[python],_节点)...

->+[增加内容2](,_内容)


## end
#915, 88:

\begin{widetext}
\begin{equation}
%LaTeX
\label{eq:%名字}
\end{equation}
\end{widetext}


## end
#916, 671:
"""
记住"Python"
LaTeX_text0="\frac{\sigma_E}{E}\approx \frac{1}{\beta-\theta}*\sqrt{(\frac{L_0+L_1}{L_0*L_2})^{2}*\sigma_s^{2}+(\frac{L_0+L_1+L_2}{L_0*L_2})^{2}*\sigma_f^{2}+(\frac{1}{L_0})^{2}*\sigma_o^{2}}"


LaTeX_text0="\begin{cases}\n\sigma=A_{3}/E^{3}+A_{2}/E^{2}+A_{1}/E+A_{0}\\\\ A_{3}=-4.583\times 10^{3}\ MeV^{3}\ rad\\ A_{2}=34.984\ MeV^{2}\ rad\\ A_{1}=3.421\ MeV\ rad\\\\ A_{0}=4.925\times 10^{-6}\ rad\n\end{cases}\n"

LaTeX_text0=""

print(len(LaTeX_text0)>100,len(LaTeX_text0))
print(LaTeX_text0.split('\n'))
print(list_eqs)

"""

list_eqs=LaTeX_text0.split('\\\\')

state=False
for eqn in list_eqs:
    if len(eqn)>110:
        state=True
        break



## end
#917, 56:

\begin{equation}
%LaTeX
\label{eq:%名字}
\end{equation}


## end
#921, 373:
"""
P代码:...
L模板:...
L模板2:...

"""

+公式结构(_节点,_内容)->+[del](,+公式结构)...
->的(公式结构,L模板)->的(公式结构,L模板2)...
->的(公式结构,P代码)...

->的(_节点,名字)->的(_节点,LaTeX)...
->+[模板文本](,+[增加内容2])->+[增加内容2](,_内容)...
->+[.](+[模板文本],名字)->+[.](+[模板文本],LaTeX)...

->[]{+[.]"LaTeX_text0"([python],LaTeX)->+[code]([python],P代码)->[python](Python,)}:
    ->+[code](+[模板文本],L模板2),
    ->>+[code](+[模板文本],L模板)



## end
#922, 107:

\begin{figure}[b]
\includegraphics[width=0.45\textwidth]{%名字}
\caption{\label{fig:%名字}%图例}
\end{figure}



## end
#923, 89:
"""
记住"Python"

"""

fig_type=source_dir.split('.')[-1]
ans='\\'+fig_name+'.'+fig_type



## end
#926, 347:
"""
P代码:...
L模板:...

"""

+图片结构(_节点,_内容)->+[del](,+图片结构)...
->的(图片结构,L模板)->的(图片结构,P代码)...

->的(_节点,名字)->的(_节点,图例)->的(_节点,源地址)...
->的(_节点,目标地址)...
->+[python](Python,目标地址)->+[code](+[python],P代码)...
->+[.]"source_dir"(+[python],源地址)->+[.]"fig_name"(+[python],名字)...

->+[模板文本](L模板,+[增加内容2])->+[增加内容2](,_内容)...
->+[.](+[模板文本],名字)->+[.](+[模板文本],图例)


## end
#930, 33:


文本结构:...
公式结构:...
图片结构:...





## end
#931, 16:

\appendix
%内容


## end
#935, 586:
"""
描述结构:...
库:...
L模板:...
+[新建阅读窗口](,描述结构)

保存_库:...
+[修改标题]"保存_库"(,库)
库

"""

+生成附录(_章节,_文本)->+[del](,+生成附录)...
->的(生成附录,描述结构)->的(生成附录,L模板)...
->的(生成附录,保存_库)...
->的(库#0,生成附录)->的(库#0,生成章节)->的(生成章节,库)...

->+的(_文本,+章节)...
->+[code]([想],描述结构)->[想](_章节,)...

->操作([想],)...
->+[临时文本]#内容->[]{
    []=>的(操作,_操作)->_操作(_主语,)->_主语(,)...
    =>[说](,_操作)->的(库,_条目)->[eq](_条目,_操作)...
    ->+[做](_主语,+[临时文本]#内容):
        ->[is](_条目,文本结构)->的(保存_库,文本结构#0)->+[code](+[做],文本结构#0),
        ->+[code](+[做],_条目)
}...

->的(_章节,题目)...
->+[模板文本](L模板,+章节)...
->+[.]"内容"(+[模板文本],+[临时文本]#内容)->+[.](+[模板文本],题目)


## end
#936, 46:

\author{%名 %姓}
\email{%邮箱}
\affiliation{%单位}

## end
#938, 230:
"""
L模板:...

"""
+通讯作者(_A,_输出)->+[del](,+通讯作者)...
->的(通讯作者,L模板)...

->的(_A,名)->的(_A,姓)->的(_A,单位)->的(_A,邮箱)...

->+[模板文本](L模板,+[增加内容2])->+[增加内容2](,_输出)...
->+[.](+[模板文本],名)->+[.](+[模板文本],姓)...
->+[.](+[模板文本],单位)->+[.](+[模板文本],邮箱)


## end
#939, 34:

\author{%名 %姓}
\affiliation{%单位}

## end
#941, 212:
"""
L模板:...

"""
+普通作者(_A,_输出)->+[del](,+普通作者)...
->的(普通作者,L模板)...

->的(_A,名)->的(_A,姓)->的(_A,单位)->的(_A,邮箱)...

->+[模板文本](L模板,+[增加内容2])->+[增加内容2](,_输出)...
->+[.](+[模板文本],名)->+[.](+[模板文本],姓)...
->+[.](+[模板文本],单位)


## end
#944, 40:


通讯作者:...
普通作者:...
将'普通作者'的"通讯"替换为"普通"

## end
#945, 70:
"""
记住"Python"

"""

state=True
list_au=text_au.split(', ')
list_i=0


## end
#946, 134:
"""


"""

name=list_au[list_i]
list_i+=1
if name[-1]=='*':
    name=name[0:-1]
    type_name='通讯'
else:
    type_name="普通"
ans=name


## end
#949, 347:
"""
P代码:...
P代码2:...

"""

+描述结构(_作者,)->+操作(+描述结构,)...
->的(描述结构,P代码)->的(描述结构,P代码2)...

->+[.]"text_au"([python],_作者)...
->+[code]([python],P代码)->[python](Python,)...
->+[code]([python]#2,P代码2)...

->+不终止=>[python]"state=(list_i<len(list_au))"(Python,+不终止)...
=>+的(+操作,+作者)->+作者(+类型,)...
->+[o]"type_name"([python]#2,+类型)->[python]#2(Python,+作者)



## end
#952, 428:
"""
描述结构:...
库:...

"""

+生成作者(_作者,_文本)->+[del](,+生成作者)...
->的(生成作者,描述结构)->的(生成作者,库)...
->的(库,通讯作者)->的(库,普通作者)...

->+的(_文本,+作者)...
->+[code]([想],描述结构)->[想](_作者,)...

->操作([想],)...
->+[临时文本]#内容->[]{
    []=>的(操作,作者)->作者(类型,)->类型(,)...
    =>+[获取作者信息](,+作者A)->[m_text](作者,+[获取作者信息])...
    ->+[做](+作者A,+作者)...
    ->+[删除结构](,+作者A)->+[del](,+作者A)->[]:
        ->[==]"通讯"(,类型)->+[code](+[做],通讯作者),
        ->+[code](+[做],普通作者)
}



## end
#958, 107:


生成标题:...
生成作者:...
生成概述:...
生成章节:...
生成附录:...
+[新建阅读窗口](,生成附录)
将条目"生成章节"复制为条目"生成附录"
将'生成作者'的"章节"替换为"作者"



## end
#961, 309:
"""
描述结构:...
库:...
+[新建阅读窗口](,库)

"""
+章节内容(_章节结构,_文本)->+[del](,+章节内容)...
->的(章节内容,描述结构)->的(章节内容,库)...

->+[code]([想],描述结构)->[想](_章节结构,_文本)...
->操作([想],)...
->[]{
    []=>的(操作,_操作)->_操作(_主语,_宾语)->_主语->_宾语(,)...
    =>[说](,_操作)...
        ->的(库,_条目)->_条目->[eq](_条目,_操作)->+[做](_主语,_宾语)->+[code](+[做],_条目)
}





## end
#962, 1148:
\documentclass[%
 reprint,
%superscriptaddress,
%groupedaddress,
%unsortedaddress,
%runinaddress,
%frontmatterverbose, 
%preprint,
%preprintnumbers,
%nofootinbib,
%nobibnotes,
%bibnotes,
 amsmath,amssymb,
 aps,
%pra,
%prb,
%rmp,
%prstab,
%prstper,
%floatfix,
]{revtex4-2}

\usepackage{siunitx}
\usepackage{graphicx}% Include figure files
\usepackage{dcolumn}% Align table columns on decimal point
\usepackage{bm}% bold math
%\usepackage{hyperref}% add hypertext capabilities
%\usepackage[mathlines]{lineno}% Enable numbering of text and display math
%\linenumbers\relax % Commence numbering lines

%\usepackage[showframe,%Uncomment any one of the following lines to test 
%%scale=0.7, marginratio={1:1, 2:3}, ignoreall,% default settings
%%text={7in,10in},centering,
%%margin=1.5in,
%%total={6.5in,8.75in}, top=1.2in, left=0.9in, includefoot,
%%height=10in,a5paper,hmargin={3cm,0.8in},
%]{geometry}

\begin{document}

\preprint{APS/123-QED}

%标题
%作者
\date{\today}

%概述

\maketitle

%章节



\nocite{*}

\bibliography{apssamp1}

\begin{filecontents}{apssamp1.bib}
%引用
\end{filecontents}

\end{document}
%
% ****** End of file apssamp.tex ******







## end
#963, 82:
"""
print("112%13%1".replace('%','\\%'))

"""

ans=file_text.replace('%','\\%')



## end
#966, 553:
"""
P代码:...
L模板:...

保存:...

"""

+整理内容(_媒介,_内容)->+[del](,+整理内容)...
->的(整理内容,L模板)->的(整理内容,P代码)...

->+[临时文本]#章节->[]{
    []=>的(_内容,章节)->章节=>+[增加内容](章节,+[临时文本]#章节)
}...
->+[python](Python,+[临时文本]#章节)->+[code](+[python],P代码)...
->+[s]"file_text"(+[python],+[临时文本]#章节)...

->+[模板文本](L模板,_内容)...
->+[.]"章节"(+[模板文本],+[临时文本]#章节)...
->[]{
    []:->的(_内容,标题)->标题->+[.](+[模板文本],标题),->[]
}...
->[]{
    []:->的(_内容,作者)->作者->+[.](+[模板文本],作者),->[]
}...
->[]{
    []:->的(_内容,概述)->概述->+[.](+[模板文本],概述),->[]
}...
->[]{
    []:->的(_内容,引用)->引用->+[.](+[模板文本],引用),->[]
}



## end
#967, 61:
"""
记住"Python"

"""

ans=paper_link.split('#')[0]
state=True

## end
#969, 203:
"""
P代码:...

"""

+描述结构(_文章,)->+操作(+描述结构,)...
->的(描述结构,P代码)...

=>的(_文章,_节点)->引用(_节点,)...
=>+的(+操作,+文章)->+文章(_节点,)...
->+[.]"paper_link"([python],_节点)->+[code]([python],P代码)...
->[python](Python,+文章)




## end
#970, 217:

@ARTICLE{%引用名, 
   author        = "%作者", 
   title         = "%标题", 
   journal = {ArXiv e-prints},
   archivePrefix = "arXiv",
   eprint        = {%eprint},
   primaryClass  = "%类别",
   year          = "%日期",
}




## end
#971, 169:

@ARTICLE{%引用名,
   author       = "%作者",
   title        = "%标题",
   journal      = "%期刊",
   volume       = "%编号", 
   pages        = "%页数",
   year         = "%年份",
}

## end
#972, 213:

@PROCEEDINGS{%引用名,
   title = "%标题",
   number = "%编号",
   editor = "", 

   series = "All ACM Conferences",
   month = "",
   year = "%年份",
   address = "%城市地址",
   organization = "%组织",
   publisher = "%会议",
}

## end
#976, 25:


文章:...
会议:...
预印本:...


## end
#977, 296:
"""
记住"Python"

print(text_aus)
print(list_aus)

"""

# print(text_aus)
# print(text_aus.split(', '))
# print(' and '.join(text_aus.split(', ')))

list_aus0=text_aus.split(', ')
if len(list_aus0)>3:
    list_aus=list_aus0[0:3]+['others']
else:
    list_aus=list_aus0
ans=' and '.join(list_aus)



## end
#980, 568:
"""
P代码:...
模板库:...

"""

+设置引用(文章A,引用)->+[del](,+设置引用)...
->的(设置引用,模板库)->的(设置引用,P代码)...

->的(文章A,类型)->的(文章A,作者)...
->+[python](Python,作者)->+[code](+[python],P代码)...
->+[s]"text_aus"(+[python],作者)...

->+[模板文本](,+[增加内容2])->+[增加内容2](,引用)...
->[]{
    []:->[==]"ARTICLE"(,类型)->的(模板库,文章#0)->+[code](+[模板文本],文章#0),
    ->[==]"PROCEEDINGS"(,类型)->的(模板库,会议#0)->+[code](+[模板文本],会议#0),
    ->[==]"ArXiv"(,类型)->的(模板库,预印本#0)->+[code](+[模板文本],预印本#0),
    ->的(模板库,文章#1)->+[code](+[模板文本],文章#1)
}...

->+[.]"引用名"(+[模板文本],文章A)...
->[]{
    []=>的(文章A,_性质)->_性质=>+[.](+[模板文本],_性质)
}




## end
#983, 426:
"""
描述结构:...
设置引用:...
+[新建阅读窗口](,描述结构)

"""

+引用文章(_文章,_文本)->+[del](,+引用文章)...
->的(引用文章,描述结构)->的(引用文章,设置引用)...

->+的(_文本,+引用)...
->+[code]([想],描述结构)->[想](_文章,)...

->操作([想],)...
->+[临时文本]#内容->[]{
    []=>的(操作,文章)->文章(_节点,)->_节点(,)...
    =>+[获取论文信息](+[临时文本],+文章A)->[m_text](文章,+[临时文本])...
        ->[标题](_节点,)->[m_text]([标题],+文章A)...
        ->+[做](+文章A,+引用)->+[code](+[做],设置引用)...
        ->+[删除结构](,+文章A)->+[del](,+文章A)
}



## end
#984, 62:
"""
print(folder_dir)

"""


ans="%s\\text.tex"%(folder_dir)


## end
#985, 263:
"""
import shutil
shutil.copy(src_dir,"%s\\fig.png"%(folder_dir))
print(tar_dir)

"""

# import shutil
import os

os.system("mkdir %s/res/"%(folder_dir))
os.system("cp %s %s/%s"%(src_dir,folder_dir,tar_dir))

# shutil.copy(src_dir,"%s\\%s"%(folder_dir,tar_dir))


## end
#988, 601:
"""
P代码:...
P代码2:...

"""

+整理图片(_媒介,_凭依)->+[del](,+整理图片)...
->的(整理图片,P代码)->的(整理图片,P代码2)...

->的#0(_凭依,地址)->+[标题](_凭依,)...
->+[python](Python,+[临时文本])->+[code](+[python],P代码)...
->+[.]"file_name"(+[python],+[标题])->+[.]"folder_dir"(+[python],地址)...
->+[保存文本](+[临时文本],_凭依)...

->[]{
    []=>的(_媒介,二级标题)->二级标题->的(二级标题,图片)->[]{的(图片,源地址)}...
    =>的(图片,源地址)->的(图片,目标地址)...
        ->+[python](Python,)->+[code](+[python],P代码2)...
        ->+[.]"src_dir"(+[python],源地址)->+[.]"tar_dir"(+[python],目标地址)...
        ->+[.]"folder_dir"(+[python],地址)
}...

->+[del](,的#0)...
->+[删除结构](,_凭依)...
->+[有](_凭依,地址)





## end
#994, 180:
+[粘贴](,降临规则)

引用文章:...
章节内容:...
整理引用:...
整理图片引用:...
整理表格引用:...
整理公式引用:...
将条目"整理图片引用"复制为条目"整理表格引用"
(Eq.~(\ref{eq:[4].}))


整理内容:...
整理图片:...
+[新建阅读窗口](,章节内容)
将'引用文章'的"作者"替换为"文章"



## end
#997, 24:


召唤规则:...
降临规则:...





## end
#999, 476:
"""
Nini, 打开人体模型(文件)
Nini, 打开CBS(文件)

"""

+召唤规则(_媒介,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_凭依)...

->[==]"结构文本转博客"(,召唤星辰)...
    ->+整理图片(_媒介,_凭依)->+的(操作,+整理图片)...
    ->+整理公式引用(_媒介,_凭依)->+的(操作,+整理公式引用)...
    ->+整理图片引用(_媒介,_凭依)->+的(操作,+整理图片引用)...
    ->+整理引用(_媒介,_凭依)->+的(操作,+整理引用)...
    ->+整理内容(_媒介,_凭依)->+的(操作,+整理内容)...

->[]{
    []=>的(_媒介,_章节)->_章节=>+章节内容(_章节,_凭依)->+的(操作,+章节内容)
}...
->[]{
    []:->.(_媒介,_原始结构)->_原始结构(,)...
        ->+引用文章(_原始结构,_凭依)->+的(操作,+引用文章),
    ->[]
}

## end
#1001, 23891:
文本转换_博客#0"

召唤规则:...
降临规则:...




"(,)
的#1""(文本转换_博客#0,降临规则#2)
降临规则#2"有什么

引用文章:...
章节内容:...
整理内容:...
整理引用:...
整理图片引用:...
整理公式引用:...
将条目\"整理图片引用\"复制为条目\"整理公式引用\"
(Eq.~(\ref{eq:[4].}))


整理图片:...
+[新建阅读窗口](,章节内容)
将'引用文章'的\"作者\"替换为\"文章\"


"(,)
的#3""(降临规则#2,整理图片#4)
整理图片#4"\"\"\"
P代码:...
P代码2:...
->+[删除结构](,_凭依)...


\"\"\"

+整理图片(_媒介,_凭依)->+[del](,+整理图片)...
->的(整理图片,P代码)->的(整理图片,P代码2)...

->的#0(_凭依,地址)->+[标题](_凭依,)...
->+[python](Python,+[临时文本])->+[code](+[python],P代码)...
->+[.]\"file_name\"(+[python],+[标题])->+[.]\"folder_dir\"(+[python],地址)...
->+[保存文本](+[临时文本],_凭依)...

->[]{
    []=>的(_媒介,二级标题)->二级标题->的(二级标题,图片)...
    ->的(图片,源地址)->的(图片,目标地址)...
        =>+[python](Python,)->+[code](+[python],P代码2)...
        ->+[.]\"src_dir\"(+[python],源地址)->+[.]\"tar_dir\"(+[python],目标地址)...
        ->+[.]\"folder_dir\"(+[python],地址)
}...

->+[del](,的#0)...
->的(_凭依,召唤规则)->+[删除结构](,召唤规则)->+[del](,召唤规则)...
->的(_凭依,降临规则)->+[删除结构](,降临规则)->+[del](,降临规则)...
->+[有](_凭依,地址)




"(,)
的#5""(整理图片#4,P代码2#6)
P代码2#6"\"\"\"
import shutil
shutil.copy(src_dir,\"%s\\fig.png\"%(folder_dir))

\"\"\"

import shutil
# print(src_dir,tar_dir)
# ans=\"%s\%s.tex\"%(folder_dir,file_name)
shutil.copy(src_dir,\"%s\\%s\"%(folder_dir,tar_dir))

"(,)
的#7""(整理图片#4,P代码#8)
P代码#8"\"\"\"


\"\"\"


ans=\"%s\\text.tex\"%(folder_dir)

"(,)
的#9""(降临规则#2,引用文章#10)
引用文章#10"\"\"\"
描述结构:...
设置引用:...
+[新建阅读窗口](,描述结构)

\"\"\"

+引用文章(_文章,_文本)->+[del](,+引用文章)...
->的(引用文章,描述结构)->的(引用文章,设置引用)...

->+的(_文本,+引用)...
->+[code]([想],描述结构)->[想](_文章,)...

->操作([想],)...
->+[临时文本]#内容->[]{
    []=>的(操作,文章)->文章(_节点,)->_节点(,)...
    =>+[获取论文信息](+[临时文本],+文章A)->[m_text](文章,+[临时文本])...
        ->[标题](_节点,)->[m_text]([标题],+文章A)...
        ->+[做](+文章A,+引用)->+[code](+[做],设置引用)...
        ->+[删除结构](,+文章A)->+[del](,+文章A)
}


"(,)
的#11""(引用文章#10,设置引用#12)
设置引用#12"\"\"\"
P代码:...
模板库:...

\"\"\"

+设置引用(文章A,引用)->+[del](,+设置引用)...
->的(设置引用,模板库)->的(设置引用,P代码)...

->的(文章A,类型)->的(文章A,作者)...
->+[python](Python,作者)->+[code](+[python],P代码)...
->+[s]\"text_aus\"(+[python],作者)...

->+[模板文本](,+[增加内容2])->+[增加内容2](,引用)...
->[]{
    []:->[==]\"ARTICLE\"(,类型)->的(模板库,文章#0)->+[code](+[模板文本],文章#0),
    ->[==]\"PROCEEDINGS\"(,类型)->的(模板库,会议#0)->+[code](+[模板文本],会议#0),
    ->[==]\"ArXiv\"(,类型)->的(模板库,预印本#0)->+[code](+[模板文本],预印本#0),
    ->的(模板库,文章#1)->+[code](+[模板文本],文章#1)
}...

->+[.]\"引用名\"(+[模板文本],文章A)...
->[]{
    []=>的(文章A,_性质)->_性质=>+[.](+[模板文本],_性质)
}



"(,)
的#13""(设置引用#12,P代码#14)
P代码#14"\"\"\"
记住\"Python\"

print(text_aus)
print(list_aus)

\"\"\"

# print(text_aus)
# print(text_aus.split(', '))
# print(' and '.join(text_aus.split(', ')))

list_aus0=text_aus.split(', ')
if len(list_aus0)>3:
    list_aus=list_aus0[0:3]+['others']
else:
    list_aus=list_aus0
ans=' and '.join(list_aus)


"(,)
的#15""(设置引用#12,模板库#16)
模板库#16"

文章:...
会议:...
预印本:...

"(,)
的#17""(模板库#16,会议#18)
会议#18"
@PROCEEDINGS{%引用名,
   title = \"%标题\",
   number = \"%编号\",
   editor = \"\", 

   series = \"All ACM Conferences\",
   month = \"\",
   year = \"%年份\",
   address = \"%城市地址\",
   organization = \"%组织\",
   publisher = \"%会议\",
}
"(,)
的#19""(模板库#16,文章#20)
文章#20"
@ARTICLE{%引用名,
   author       = \"%作者\",
   title        = \"%标题\",
   journal      = \"%期刊\",
   volume       = \"%编号\", 
   pages        = \"%页数\",
   year         = \"%年份\",
}
"(,)
的#21""(模板库#16,预印本#22)
预印本#22"
@ARTICLE{%引用名, 
   author        = \"%作者\", 
   title         = \"%标题\", 
   journal = {ArXiv e-prints},
   archivePrefix = \"arXiv\",
   eprint        = {%eprint},
   primaryClass  = \"%类别\",
   year          = \"%日期\",
}



"(,)
的#23""(引用文章#10,描述结构#24)
描述结构#24"\"\"\"
P代码:...

\"\"\"

+描述结构(_文章,)->+操作(+描述结构,)...
->的(描述结构,P代码)...

=>的(_文章,_节点)->引用(_节点,)...
=>+的(+操作,+文章)->+文章(_节点,)...
->+[.]\"paper_link\"([python],_节点)->+[code]([python],P代码)...
->[python](Python,+文章)



"(,)
的#25""(描述结构#24,P代码#26)
P代码#26"\"\"\"
记住\"Python\"

\"\"\"

ans=paper_link.split('#')[0]
state=True
"(,)
的#27""(降临规则#2,整理内容#28)
整理内容#28"\"\"\"
P代码:...
L模板:...

\"\"\"

+整理内容(_媒介,_内容)->+[del](,+整理内容)...
->的(整理内容,L模板)->的(整理内容,P代码)...

->+[临时文本]#章节->[]{
    []=>的(_内容,章节)->章节=>+[增加内容](章节,+[临时文本]#章节)
}...
->+[python](Python,+[临时文本]#章节)->+[code](+[python],P代码)...
->+[s]\"file_text\"(+[python],+[临时文本]#章节)...

->+[模板文本](L模板,_内容)...
->+[.]\"章节\"(+[模板文本],+[临时文本]#章节)...
->[]{
    []:->的(_内容,标题)->标题->+[.](+[模板文本],标题),->[]
}...
->[]{
    []:->的(_内容,作者)->作者->+[.](+[模板文本],作者),->[]
}...
->[]{
    []:->的(_内容,概述)->概述->+[.](+[模板文本],概述),->[]
}...
->[]{
    []:->的(_内容,引用)->引用->+[.](+[模板文本],引用),->[]
}


"(,)
的#29""(整理内容#28,P代码#30)
P代码#30"\"\"\"
print(\"112%13%1\".replace('%','\\%'))

\"\"\"

ans=file_text.replace('%','\\%')


"(,)
的#31""(整理内容#28,L模板#32)
L模板#32"
%标题
%作者

%概述


%章节



"(,)
的#33""(降临规则#2,章节内容#34)
章节内容#34"\"\"\"
描述结构:...
库:...
+[新建阅读窗口](,库)

\"\"\"
+章节内容(_章节结构,_文本)->+[del](,+章节内容)...
->的(章节内容,描述结构)->的(章节内容,库)...

->+[code]([想],描述结构)->[想](_章节结构,_文本)...
->操作([想],)...
->[]{
    []=>的(操作,_操作)->_操作(_主语,_宾语)->_主语->_宾语(,)...
    =>[说](,_操作)...
        ->的(库,_条目)->_条目->[eq](_条目,_操作)->+[做](_主语,_宾语)->+[code](+[做],_条目)
}




"(,)
的#35""(章节内容#34,库#36)
库#36"

生成标题:...
生成作者:...
生成概述:...
生成章节:...
生成附录:...
将条目\"生成章节\"复制为条目\"生成附录\"
将'生成作者'的\"章节\"替换为\"作者\"

"(,)
的#37""(库#36,生成作者#38)
生成作者#38"\"\"\"
描述结构:...
库:...

\"\"\"

+生成作者(_作者,_文本)->+[del](,+生成作者)...
->的(生成作者,描述结构)->的(生成作者,库)...
->的(库,通讯作者)->的(库,普通作者)...

->+的(_文本,+作者)...
->+[code]([想],描述结构)->[想](_作者,)...

->操作([想],)...
->+[临时文本]#内容->[]{
    []=>的(操作,作者)->作者(类型,)->类型(,)...
    =>+[获取作者信息](,+作者A)->[m_text](作者,+[获取作者信息])...
    ->+[做](+作者A,+作者)...
    ->+[删除结构](,+作者A)->+[del](,+作者A)->[]:
        ->[==]\"通讯\"(,类型)->+[code](+[做],通讯作者),
        ->+[code](+[做],普通作者)
}


"(,)
的#39""(生成作者#38,描述结构#40)
描述结构#40"\"\"\"
P代码:...
P代码2:...

\"\"\"

+描述结构(_作者,)->+操作(+描述结构,)...
->的(描述结构,P代码)->的(描述结构,P代码2)...

->+[.]\"text_au\"([python],_作者)...
->+[code]([python],P代码)->[python](Python,)...
->+[code]([python]#2,P代码2)...

->+不终止=>[python]\"state=(list_i<len(list_au))\"(Python,+不终止)...
=>+的(+操作,+作者)->+作者(+类型,)...
->+[o]\"type_name\"([python]#2,+类型)->[python]#2(Python,+作者)


"(,)
的#41""(描述结构#40,P代码2#42)
P代码2#42"\"\"\"


\"\"\"

name=list_au[list_i]
list_i+=1
if name[-1]=='*':
    name=name[0:-1]
    type_name='通讯'
else:
    type_name=\"普通\"
ans=name

"(,)
的#43""(描述结构#40,P代码#44)
P代码#44"\"\"\"
记住\"Python\"

\"\"\"

state=True
list_au=text_au.split(', ')
list_i=0

"(,)
的#45""(生成作者#38,库#46)
库#46"

通讯作者:...
普通作者:...
将'普通作者'的\"通讯\"替换为\"普通\"
"(,)
的#47""(库#46,普通作者#48)
普通作者#48"\"\"\"
L模板:...

\"\"\"
+普通作者(_A,_输出)->+[del](,+普通作者)...
->的(普通作者,L模板)...

->的(_A,名)->的(_A,姓)->的(_A,单位)->的(_A,邮箱)...

->+[模板文本](L模板,+[增加内容2])->+[增加内容2](,_输出)...
->+[.](+[模板文本],名)->+[.](+[模板文本],姓)...
->+[.](+[模板文本],单位)

"(,)
的#49""(普通作者#48,L模板#50)
L模板#50"
\author{%名 %姓}
\affiliation{%单位}
"(,)
的#51""(库#46,通讯作者#52)
通讯作者#52"\"\"\"
L模板:...

\"\"\"
+通讯作者(_A,_输出)->+[del](,+通讯作者)...
->的(通讯作者,L模板)...

->的(_A,名)->的(_A,姓)->的(_A,单位)->的(_A,邮箱)...

->+[模板文本](L模板,+[增加内容2])->+[增加内容2](,_输出)...
->+[.](+[模板文本],名)->+[.](+[模板文本],姓)...
->+[.](+[模板文本],单位)->+[.](+[模板文本],邮箱)

"(,)
的#53""(通讯作者#52,L模板#54)
L模板#54"
\author{%名 %姓}
\email{%邮箱}
\affiliation{%单位}
"(,)
的#55""(库#36,生成附录#56)
生成附录#56"\"\"\"
描述结构:...
库:...
L模板:...
+[新建阅读窗口](,描述结构)

\"\"\"

+生成附录(_章节,_文本)->+[del](,+生成附录)...
->的(生成附录,描述结构)->的(生成附录,库)...
->的(生成附录,L模板)...

->+的(_文本,+章节)...
->+[code]([想],描述结构)->[想](_章节,)...

->操作([想],)...
->+[临时文本]#内容->[]{
    []=>的(操作,_操作)->_操作(_主语,)->_主语(,)...
    =>[说](,_操作)->的(库,_条目)->[eq](_条目,_操作)...
    ->+[做](_主语,+[临时文本]#内容)->+[code](+[做],_条目)
}...

->的(_章节,题目)...
->+[模板文本](L模板,+章节)...
->+[.]\"内容\"(+[模板文本],+[临时文本]#内容)->+[.](+[模板文本],题目)

"(,)
的#57""(生成附录#56,L模板#58)
L模板#58"
\appendix
%内容

"(,)
的#59""(生成附录#56,库#60)
库#60"

文本结构:...
公式结构:...
图片结构:...




"(,)
的#61""(库#60,图片结构#62)
图片结构#62"\"\"\"
P代码:...
L模板:...

\"\"\"

+图片结构(_节点,_内容)->+[del](,+图片结构)...
->的(图片结构,L模板)->的(图片结构,P代码)...

->的(_节点,名字)->的(_节点,图例)->的(_节点,源地址)...
->的(_节点,目标地址)...
->+[python](Python,目标地址)->+[code](+[python],P代码)...
->+[.]\"source_dir\"(+[python],源地址)->+[.]\"fig_name\"(+[python],名字)...

->+[模板文本](L模板,+[增加内容2])->+[增加内容2](,_内容)...
->+[.](+[模板文本],名字)->+[.](+[模板文本],图例)

"(,)
的#63""(图片结构#62,P代码#64)
P代码#64"\"\"\"
记住\"Python\"

\"\"\"

fig_type=source_dir.split('.')[-1]
ans='\\'+fig_name+'.'+fig_type


"(,)
的#65""(图片结构#62,L模板#66)
L模板#66"
\begin{figure}[b]
\includegraphics[width=0.45\textwidth]{%名字}
\caption{\label{fig:%名字}%图例}
\end{figure}


"(,)
的#67""(库#60,公式结构#68)
公式结构#68"\"\"\"
P代码:...
L模板:...
L模板2:...

\"\"\"

+公式结构(_节点,_内容)->+[del](,+公式结构)...
->的(公式结构,L模板)->的(公式结构,L模板2)...
->的(公式结构,P代码)...

->的(_节点,名字)->的(_节点,LaTeX)...
->+[模板文本](,+[增加内容2])->+[增加内容2](,_内容)...
->+[.](+[模板文本],名字)->+[.](+[模板文本],LaTeX)...

->[]{+[.]\"LaTeX_text0\"([python],LaTeX)->+[code]([python],P代码)->[python](Python,)}:
    ->+[code](+[模板文本],L模板2),
    ->>+[code](+[模板文本],L模板)


"(,)
的#69""(公式结构#68,L模板#70)
L模板#70"
\begin{equation}
%LaTeX
\label{eq:%名字}
\end{equation}

"(,)
的#71""(公式结构#68,P代码#72)
P代码#72"\"\"\"
记住\"Python\"
LaTeX_text0=\"\frac{\sigma_E}{E}\approx \frac{1}{\beta-\theta}*\sqrt{(\frac{L_0+L_1}{L_0*L_2})^{2}*\sigma_s^{2}+(\frac{L_0+L_1+L_2}{L_0*L_2})^{2}*\sigma_f^{2}+(\frac{1}{L_0})^{2}*\sigma_o^{2}}\"


LaTeX_text0=\"\begin{cases}\n\sigma=A_{3}/E^{3}+A_{2}/E^{2}+A_{1}/E+A_{0}\\\\ A_{3}=-4.583\times 10^{3}\ MeV^{3}\ rad\\ A_{2}=34.984\ MeV^{2}\ rad\\ A_{1}=3.421\ MeV\ rad\\\\ A_{0}=4.925\times 10^{-6}\ rad\n\end{cases}\n\"

LaTeX_text0=\"\"

print(len(LaTeX_text0)>100,len(LaTeX_text0))
print(LaTeX_text0.split('\n'))
print(list_eqs)

\"\"\"

list_eqs=LaTeX_text0.split('\\\\')

state=False
for eqn in list_eqs:
    if len(eqn)>110:
        state=True
        break


"(,)
的#73""(公式结构#68,L模板2#74)
L模板2#74"
\begin{widetext}
\begin{equation}
%LaTeX
\label{eq:%名字}
\end{equation}
\end{widetext}

"(,)
的#75""(库#60,文本结构#76)
文本结构#76"\"\"\"
P代码:...

\"\"\"

+文本结构(_节点,_内容)->+[del](,+文本结构)...
->的(文本结构,P代码)...

->+[python](Python,+[增加内容2])->+[code](+[python],P代码)...
->+[.]\"text_context\"(+[python],_节点)...

->+[增加内容2](,_内容)

"(,)
的#77""(文本结构#76,P代码#78)
P代码#78"\"\"\"
print(text_context)

\"\"\"

if len(text_context)>4 and text_context[0:4]=='<h3>':
    ans='\\section{%s}\n\n'%(text_context[4:-5])
else:
    ans=text_context+'\n\n'


"(,)
的#79""(生成附录#56,描述结构#80)
描述结构#80"\"\"\"


\"\"\"

+描述结构(_章节,)->+操作(+描述结构,)...

->[]{
    []=>的(_章节,_节点)->_节点=>[]:
        ->[is](_节点,文本)->文本->+文本结构(_节点,)->+的(+操作,+文本结构),
        ->[is](_节点,公式)->公式->+公式结构(_节点,)->+的(+操作,+公式结构),
        ->[is](_节点,图片)->图片->+图片结构(_节点,)->+的(+操作,+图片结构),
        ->[]
}

"(,)
的#81""(库#36,生成概述#82)
生成概述#82"\"\"\"
L模板:...

\"\"\"

+生成概述(二级标题,_文本)->+[del](,+生成概述)...
->的(生成概述,L模板)...

->+的(_文本,+概述)...

->+[临时文本]->[]{
    []=>的(二级标题,文本)->文本=>+[增加内容2](文本,+[临时文本])
}...

->+[模板文本](L模板,+概述)->+[.](+[模板文本],+[临时文本])


"(,)
的#83""(生成概述#82,L模板#84)
L模板#84"%[临时文本]
"(,)
的#85""(库#36,生成标题#86)
生成标题#86"\"\"\"
L模板:...

\"\"\"

+生成标题(一级标题,_文本)->+[del](,+生成标题)...
->的(生成标题,L模板)...

->+的(_文本,+标题)...

->的(一级标题,题目)...
->+[模板文本](L模板,+标题)->+[.](+[模板文本],题目)


"(,)
的#87""(生成标题#86,L模板#88)
L模板#88"<h1>%题目</h1>

"(,)
的#89""(库#36,生成章节#90)
生成章节#90"\"\"\"
描述结构:...
库:...
L模板:...
+[新建阅读窗口](,描述结构)

\"\"\"

+生成章节(_章节,_文本)->+[del](,+生成章节)...
->的(生成章节,描述结构)->的(生成章节,库)...
->的(生成章节,L模板)->的(库,输出页面)...

->+的(_文本,+章节)...
->+[code]([想],描述结构)->[想](_章节,+章节)...

->操作([想],)...
->+[临时文本]#内容->[]{
    []=>的(操作,_操作)->_操作(_主语,)->_主语(,)...
    =>[说](,_操作)->的(库,_条目)->[eq](_条目,_操作)...
    ->+[做](_主语,+[临时文本]#内容)->+[code](+[做],_条目)
}...

->的(_章节,题目)...
->+[模板文本](L模板,+章节)...
->+[.]\"内容\"(+[模板文本],+[临时文本]#内容)->+[.](+[模板文本],题目)...

->+[做](_章节,+章节)->+[code](+[做],输出页面)


"(,)
的#91""(生成章节#90,描述结构#92)
描述结构#92"\"\"\"


\"\"\"

+描述结构(_章节,_文本)->+操作(+描述结构,)...

->[]{
    []=>的(_章节,_节点)->_节点=>[]:
        ->[is](_节点,文本)->文本->+文本结构(_节点,)->+的(+操作,+文本结构),
        ->[is](_节点,公式)->公式->+公式结构(_节点,)->+的(+操作,+公式结构),
        ->[is](_节点,图片)->图片->+图片结构(_节点,)->+的(+操作,+图片结构),
        ->[]
}

"(,)
的#93""(生成章节#90,库#94)
库#94"

文本结构:...
公式结构:...
图片结构:...
输出页面:...



"(,)
的#95""(库#94,文本结构#96)
文本结构#96"\"\"\"
P代码:...

\"\"\"

+文本结构(_节点,_内容)->+[del](,+文本结构)...
->的(文本结构,P代码)...

->+[python](Python,+[增加内容2])->+[code](+[python],P代码)...
->+[.]\"text_context\"(+[python],_节点)...

->+[增加内容2](,_内容)

"(,)
的#97""(文本结构#96,P代码#98)
P代码#98"\"\"\"
print(text_context)

\"\"\"

if len(text_context)>4 and text_context[0:4]=='<h3>':
    ans='<h2>%s</h2>\n\n'%(text_context[4:-5])
else:
    ans=text_context+'<br>\n'


"(,)
的#99""(库#94,公式结构#100)
公式结构#100"\"\"\"
P代码:...
L模板:短公式...
L模板2:长公式...
L模板3:多行...

\"\"\"

+公式结构(_节点,_内容)->+[del](,+公式结构)...
->的(公式结构,L模板)->的(公式结构,L模板2)->的(公式结构,L模板3)...
->的(公式结构,P代码)...

->的(_节点,名字)->的(_节点,LaTeX)...
->+[模板文本](,+[增加内容2])->+[增加内容2](,_内容)...
->+[.](+[模板文本],名字)->+[.]\"LaTeX\"(+[模板文本],+[临时文本]#t)...

->+[.]\"LaTeX_text0\"([python],LaTeX)...
->+[o]\"LaTeX_text\"([python],+[临时文本]#t)...
->+[code]([python],P代码)->[python](Python,+[临时文本]):
    ->[==]\"1\"(,+[临时文本])->+[code](+[模板文本],L模板),
    ->[==]\"2\"(,+[临时文本])->+[code](+[模板文本],L模板2),
    ->+[code](+[模板文本],L模板3)


"(,)
的#101""(公式结构#100,L模板2#102)
L模板2#102"
$$
%LaTeX
\tag{%名字}
$$

"(,)
的#103""(公式结构#100,P代码#104)
P代码#104"\"\"\"
记住\"Python\"
测试:...
保存:...
print(LaTeX_text0)
print(re.sub('\n+$','',LaTeX_text0))
LaTeX_text

txt=r'I_{scatter}=\frac{1}{L_{2}}\ \int_{}^{}{d\theta\ }{S(E_{f}(\theta))\ f(\theta)\ \frac{\partial E_{f}}{\partial \theta}\ exp(-\frac{\alpha^{2}}{\sigma_{s}(E_{f}(\theta))^{2}})}'
print(txt.replace('\ ','\\\\ \n',1))


\"\"\"

state=True
ans=1
if len(LaTeX_text0)<150 or 'cases' in LaTeX_text0:
    LaTeX_text=LaTeX_text0
    ans=1
elif len(LaTeX_text0)<200:
    LaTeX_text=LaTeX_text0.replace('\ ','\\\\ \n',1)
    ans=3
else:
    LaTeX_text=LaTeX_text0
    ans=2

LaTeX_text=re.sub('\n+$','',LaTeX_text)
print(LaTeX_text,ans)

"(,)
的#105""(P代码#104,测试#106)
测试#106"LaTeX_text0=\"\frac{\sigma_E}{E}\approx \frac{1}{\beta-\theta}*\sqrt{(\frac{L_0+L_1}{L_0*L_2})^{2}*\sigma_s^{2}+(\frac{L_0+L_1+L_2}{L_0*L_2})^{2}*\sigma_f^{2}+(\frac{1}{L_0})^{2}*\sigma_o^{2}}\"


LaTeX_text0=\"\begin{cases}\n\sigma=A_{3}/E^{3}+A_{2}/E^{2}+A_{1}/E+A_{0}\\\\ A_{3}=-4.583\times 10^{3}\ MeV^{3}\ rad\\ A_{2}=34.984\ MeV^{2}\ rad\\ A_{1}=3.421\ MeV\ rad\\\\ A_{0}=4.925\times 10^{-6}\ rad\n\end{cases}\n\"

LaTeX_text0=\"\"

print(len(LaTeX_text0)>100,len(LaTeX_text0))
print(LaTeX_text0.split('\n'))
print(list_eqs)
"(,)
的#107""(P代码#104,保存#108)
保存#108"\"\"\"
记住\"Python\"
测试:...
print(LaTeX_text0)

\"\"\"

list_eqs=LaTeX_text0.split('\\\\')

state=False
for eqn in list_eqs:
    if len(eqn)>110:
        state=True
        break


"(,)
的#109""(公式结构#100,L模板#110)
L模板#110"
$$
%LaTeX
\tag{%名字}
$$

"(,)
的#111""(公式结构#100,L模板3#112)
L模板3#112"
$$
%LaTeX
\tag{%名字}
$$
"(,)
的#113""(库#94,图片结构#114)
图片结构#114"\"\"\"
P代码:...
L模板:...
L模板2:...

\"\"\"

+图片结构(_节点,_内容)->+[del](,+图片结构)...
->的(图片结构,L模板)->的(图片结构,L模板2)->的(图片结构,P代码)...

->的(_节点,类型)->的(_节点,位置)...
->的(_节点,名字)->的(_节点,图例)->的(_节点,源地址)...
->的(_节点,目标地址)...
->+[python](Python,目标地址)->+[code](+[python],P代码)...
->+[.]\"source_dir\"(+[python],源地址)->+[.]\"fig_name\"(+[python],名字)...

->+[模板文本](,+[增加内容2])->+[增加内容2](,_内容)...
->+[.](+[模板文本],名字)->+[.](+[模板文本],图例)->+[.](+[模板文本],位置):

->[==]\"normal\"(,类型)->+[code](+[模板文本],L模板),
->+[code](+[模板文本],L模板2)
"(,)
的#115""(图片结构#114,L模板#116)
L模板#116"
\begin{figure}[%位置]
\includegraphics[width=0.45\textwidth]{%名字}
\caption{\label{fig:%名字}%图例}
\end{figure}


"(,)
的#117""(图片结构#114,P代码#118)
P代码#118"\"\"\"
记住\"Python\"

\"\"\"

fig_type=source_dir.split('.')[-1]
ans='\\'+fig_name+'.'+fig_type


"(,)
的#119""(图片结构#114,L模板2#120)
L模板2#120"
\begin{figure*}
\includegraphics[width=0.9 \textwidth]{%名字}
\caption{\label{fig:%名字}%图例}
\end{figure*}
"(,)
的#121""(库#94,输出页面#122)
输出页面#122"\"\"\"
P代码:...
模板:...

\"\"\"
+输出页面(_节点,_章节)->+[del](,+输出页面)...
->的(输出页面,模板)->的(输出页面,P代码)...

->的(_节点,题目)->+的(_章节,+地址)...
->+[python](Python,+地址)->+[code](+[python],P代码)...
->+[.]\"name0\"(+[python],题目)


"(,)
的#123""(输出页面#122,模板#124)
模板#124""(,)
的#125""(输出页面#122,P代码#126)
P代码#126"\"\"\"
记住\"Python\"
str0='1 1 1'
print(str0,str0.replace(' ','_'))

\"\"\"

name=name0.replace(' ','_')
ans='/pages/%s.html'%(name)
print(ans)

"(,)
的#127""(生成章节#90,L模板#128)
L模板#128"
<h1>%题目</h1>
%内容

"(,)
的#129""(章节内容#34,描述结构#130)
描述结构#130"\"\"\"


\"\"\"
+描述结构(_章节结构,_文本)->+操作(+描述结构,)...

->[]{
    []:->[is](_章节结构,一级标题)->一级标题(,)...
        ->+生成标题(一级标题,_文本)->+的(+操作,+生成标题),
    ->[is](_章节结构,文本)->文本(,)...
        ->+生成作者(文本,_文本)->+的(+操作,+生成作者),
    ->[is](_章节结构,_章节)->_章节->的(_章节,题目)->[==]\"Abstract\"(,题目)...
        ->+生成概述(_章节,_文本)->+的(+操作,+生成概述),
    ->[is](_章节结构,_附录)->_附录->的(_附录,题目#2)->[==]\"Appendix\"(,题目#2)...
        ->+生成附录(_附录,_文本)->+的(+操作,+生成附录),
    ->[is](_章节结构,二级标题)->二级标题(,)...
        ->+生成章节(二级标题,_文本)->+的(+操作,+生成章节)
}


"(,)
的#131""(降临规则#2,整理公式引用#132)
整理公式引用#132"\"\"\"
P代码:...
+[P函数](,P代码)
print(list_lk)
print(paper_text)

\"\"\"

+整理公式引用(_媒介,_文本)->+[del](,+整理公式引用)...
->的(整理公式引用,P代码)...

->.(_媒介,_文章)...
->+[python]\"list_lk=[]\"(Python,)->[]{
    []=>的(_文章,_节点)->_节点->公式(_节点,)...
    =>+[标题](_节点,)->+[python]\"list_lk.append(name)\"(Python,)...
        ->+[s]\"name\"(+[python],+[标题])
}...

->+[python](Python,_文本)->+[code](+[python],P代码)...
->+[s]\"paper_text\"(+[python],_文本)


"(,)
的#133""(整理公式引用#132,P代码#134)
P代码#134"\"\"\"
记住\"Python\"
测试:...
测试2:...

\"\"\"

import re

link_pat='([eE])qn?\.(\[[a-zA-Z0-9_\.]+\]\.)'
link_pat2='Equation (\[[a-zA-Z0-9_\.]+\]\.)'
i=0
out_text=''

while True:
    if i>=len(paper_text):
        break
    a=re.match(link_pat,paper_text[i:])
    a2=re.match(link_pat2,paper_text[i:])
    if a!=None and a.group(2) in list_lk:
        new_text='%sqn.~\\ref{eq:%s}'%(a.group(1),a.group(2))
        di0=a.span()[1]
        out_text+=new_text
        i+=di0-1
    elif a2!=None and a2.group(1) in list_lk:
        new_text='Equation ~\\ref{eq:%s}'%(a2.group(1))
        di0=a2.span()[1]
        out_text+=new_text
        i+=di0-1
    else:
        out_text+=paper_text[i]
    i+=1

ans=out_text


"(,)
的#135""(P代码#134,测试#136)
测试#136"\"\"\"
+[P函数](,测试)
Nini, 打开公式分析器(文件)

\"\"\"

list_lk=['a1','a2','c1']
paper_text=\"\"\"
[a1,a2]
[1].
[c1],[c1]

\"\"\"

import re

link_pat='\[([a-zA-Z]+\d*)(, ?[a-zA-Z]+\d*)*\]'
i=0
out_text=''

while True:
    if i>=len(paper_text):
        break
    a=re.match(link_pat,paper_text[i:])
    if a!=None and a.group(1) in list_lk:
        new_text='\\cite{%s}'%(a.group()[1:-1])
        di0=a.span()[1]
        out_text+=new_text
        i+=di0-1
    else:
        out_text+=paper_text[i]

    i+=1

print(out_text)


\"\"\"
print(a.span())
+[P函数](,测试)

\"\"\""(,)
的#137""(P代码#134,测试2#138)
测试2#138"\"\"\"
+[P函数](,测试2)
print(list_lk)

\"\"\"

import re

link_pat='([eE])qn.(\[[a-zA-Z0-9_\.]+\]\.)'
link_pat2='Equation (\[[a-zA-Z0-9_\.]+\]\.)'
i=0
out_text=''
paper_text=\"\"\"
Eqn.[4].

\"\"\"

while True:
    if i>=len(paper_text):
        break
    a=re.match(link_pat,paper_text[i:])
    a2=re.match(link_pat2,paper_text[i:])
    if a!=None and a.group(2) in list_lk:
        new_text='%sqn.~\\ref{eq:%s}'%(a.group(1),a.group(2))
        di0=a.span()[1]
        out_text+=new_text
        i+=di0-1
    elif a2!=None and a2.group(1) in list_lk:
        new_text='Equation ~\\ref{eq:%s}'%(a2.group(1))
        di0=a2.span()[1]
        out_text+=new_text
        i+=di0-1
    else:
        out_text+=paper_text[i]
    i+=1

ans=out_text

print(paper_text)
print(out_text)

"(,)
的#139""(降临规则#2,整理引用#140)
整理引用#140"\"\"\"
P代码:...
print(list_lk)
print(paper_text)

\"\"\"

+整理引用(_媒介,_文本)->+[del](,+整理引用)...
->的(整理引用,P代码)...

->.(_媒介,_文章)...
->+[python]\"list_lk=[]\"(Python,)->[]{
    []=>的(_文章,_节点)->_节点->引用(_节点,)...
    =>+[标题](_节点,)->+[python]\"list_lk.append(name)\"(Python,)...
        ->+[s]\"name\"(+[python],+[标题])
}...

->+[python](Python,_文本)->+[code](+[python],P代码)...
->+[s]\"paper_text\"(+[python],_文本)




"(,)
的#141""(整理引用#140,P代码#142)
P代码#142"\"\"\"
记住\"Python\"
测试:...

\"\"\"

import re

link_pat='\[([a-zA-Z]+\d*)(, ?[a-zA-Z]+\d*)*\]'
i=0
out_text=''

while True:
    if i>=len(paper_text):
        break
    a=re.match(link_pat,paper_text[i:])
    if a!=None and a.group(1) in list_lk:
        new_text='\\cite{%s}'%(a.group()[1:-1])
        di0=a.span()[1]
        out_text+=new_text
        i+=di0-1
    else:
        out_text+=paper_text[i]
    i+=1

ans=out_text


"(,)
的#143""(P代码#142,测试#144)
测试#144"\"\"\"
+[P函数](,测试)
Nini, 打开公式分析器(文件)

\"\"\"

list_lk=['a1','a2','c1']
paper_text=\"\"\"
[a1,a2]
[1].
[c1],[c1]

\"\"\"

import re

link_pat='\[([a-zA-Z]+\d*)(, ?[a-zA-Z]+\d*)*\]'
i=0
out_text=''

while True:
    if i>=len(paper_text):
        break
    a=re.match(link_pat,paper_text[i:])
    if a!=None and a.group(1) in list_lk:
        new_text='\\cite{%s}'%(a.group()[1:-1])
        di0=a.span()[1]
        out_text+=new_text
        i+=di0-1
    else:
        out_text+=paper_text[i]

    i+=1

print(out_text)


\"\"\"
print(a.span())
+[P函数](,测试)

\"\"\""(,)
的#145""(降临规则#2,整理图片引用#146)
整理图片引用#146"\"\"\"
P代码:...
print(list_lk)
print(paper_text)

\"\"\"

+整理图片引用(_媒介,_文本)->+[del](,+整理图片引用)...
->的(整理图片引用,P代码)...

->.(_媒介,_文章)...
->+[python]\"list_lk=[]\"(Python,)->[]{
    []=>的(_文章,_节点)->_节点->图片(_节点,)...
    =>+[标题](_节点,)->+[python]\"list_lk.append(name)\"(Python,)...
        ->+[s]\"name\"(+[python],+[标题])
}...

->+[python](Python,_文本)->+[code](+[python],P代码)...
->+[s]\"paper_text\"(+[python],_文本)


"(,)
的#147""(整理图片引用#146,P代码#148)
P代码#148"\"\"\"
记住\"Python\"
测试:...
测试2:...

\"\"\"

import re

link_pat='([fF])ig.\[([a-zA-Z0-9_\.]+)\]'
link_pat2='Figure \[([a-zA-Z0-9_\.]+)\]'
i=0
out_text=''

while True:
    if i>=len(paper_text):
        break
    a=re.match(link_pat,paper_text[i:])
    a2=re.match(link_pat2,paper_text[i:])
    if a!=None and a.group(2) in list_lk:
        new_text='%sig.~\\ref{fig:%s}'%(a.group(1),a.group(2))
        di0=a.span()[1]
        out_text+=new_text
        i+=di0-1
    elif a2!=None and a2.group(1) in list_lk:
        new_text='Figure ~\\ref{fig:%s}'%(a2.group(1))
        di0=a2.span()[1]
        out_text+=new_text
        i+=di0-1
    else:
        out_text+=paper_text[i]
    i+=1

ans=out_text


"(,)
的#149""(P代码#148,测试#150)
测试#150"\"\"\"
+[P函数](,测试)
Nini, 打开公式分析器(文件)

\"\"\"

list_lk=['a1','a2','c1']
paper_text=\"\"\"
[a1,a2]
[1].
[c1],[c1]

\"\"\"

import re

link_pat='\[([a-zA-Z]+\d*)(, ?[a-zA-Z]+\d*)*\]'
i=0
out_text=''

while True:
    if i>=len(paper_text):
        break
    a=re.match(link_pat,paper_text[i:])
    if a!=None and a.group(1) in list_lk:
        new_text='\\cite{%s}'%(a.group()[1:-1])
        di0=a.span()[1]
        out_text+=new_text
        i+=di0-1
    else:
        out_text+=paper_text[i]

    i+=1

print(out_text)


\"\"\"
print(a.span())
+[P函数](,测试)

\"\"\""(,)
的#151""(P代码#148,测试2#152)
测试2#152"\"\"\"
+[P函数](,测试2)
print(list_lk)

\"\"\"

import re

paper_text=\"\"\"
The algorithm of recovering complete electron trajectories from source to detector is schematically shown in Fig.[_setup1]. In Fig.[_setup1], 

\"\"\"

link_pat='([fF])ig.\[([a-zA-Z0-9_\.]+)\]'
link_pat2='Figure \[([a-zA-Z0-9_\.]+)\]'
i=0
out_text=''

while True:
    if i>=len(paper_text):
        break
    a=re.match(link_pat,paper_text[i:])
    a2=re.match(link_pat2,paper_text[i:])
    if a!=None and a.group(2) in list_lk:
        new_text='%sig.~\\ref{fig:%s}'%(a.group(1),a.group(2))
        di0=a.span()[1]
        out_text+=new_text
        i+=di0-1
    elif a2!=None and a2.group(1) in list_lk:
        new_text='Figure ~\\ref{fig:%s}'%(a2.group(1))
        di0=a.span()[1]
        out_text+=new_text
        i+=di0-1
    else:
        out_text+=paper_text[i]
    i+=1

ans=out_text

print(paper_text)
print(out_text)
"(,)
的#153""(文本转换_博客#0,召唤规则#154)
召唤规则#154"\"\"\"
Nini, 打开人体模型(文件)
Nini, 打开CBS(文件)

\"\"\"

+召唤规则(_媒介,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_凭依)...

->[==]\"结构文本转博客\"(,召唤星辰)...
    ->+整理图片(_媒介,_凭依)->+的(操作,+整理图片)...
    ->+整理公式引用(_媒介,_凭依)->+的(操作,+整理公式引用)...
    ->+整理图片引用(_媒介,_凭依)->+的(操作,+整理图片引用)...
    ->+整理引用(_媒介,_凭依)->+的(操作,+整理引用)...
    ->+整理内容(_媒介,_凭依)->+的(操作,+整理内容)...

->[]{
    []=>的(_媒介,_章节)->_章节=>+章节内容(_章节,_凭依)->+的(操作,+章节内容)
}...
->[]{
    []:->.(_媒介,_原始结构)->_原始结构(,)...
        ->+引用文章(_原始结构,_凭依)->+的(操作,+引用文章),
    ->[]
}
"(,)

## end
#1003, 250:
"""
描述结构:...
P代码:...
模板:...

"""
+输出页面(_节点,_章节)->+[del](,+输出页面)...
->的(输出页面,模板)->的(输出页面,P代码)...

->的(_节点,题目)->+的(_章节,+地址)...
->+[python](Python,+地址)->+[code](+[python],P代码)...
->+[.]"name0"(+[python],题目)...

->+[模板文本](模板,_章节)->+[.]"内容"(+[模板文本],_章节)


## end
#1005, 3:
%内容
## end
#1007, 136:
"""
记住"Python"
str0='1 1 1'
print(str0,str0.replace(' ','_'))

"""

name=name0.replace(' ','_')
ans='/pages/%s.html'%(name)
print(ans)


## end
#1009, 184:
<!--

-->

<h1>UT^3 radiation safety</h1>

<h2>Beam dump structure</h2>
test<br>
%[1].
test<br>
test<br>
test<br>
%示意图
test<br>
%三维模型


<!--
[1].:
将"a*x^2=b"记作为式(1)

+[H函数](,PPT样本)
-->
## end
#1011, 103:

<h1>UT^3 radiation safety</h1>
<h2>Beam dump structure</h2>
test
%[1].
test
test
test
%示意图
test
%三维模型

## end
#1012, 21:
UT^3 radiation safety
## end
#1014, 62:
Beam dump structure
test
%[1].
test
test
test
%示意图
test
%三维模型

## end
#1016, 19:
Beam dump structure
## end
#1020, 4:
test
## end
#1024, 5:
%[1].
## end
#1028, 4:
test
## end
#1032, 4:
test
## end
#1036, 4:
test
## end
#1040, 4:
%示意图
## end
#1044, 4:
test
## end
#1048, 5:
%三维模型
## end
#1050, 21:
UT^3 radiation safety
## end
#1055, 553:
"""
P代码:...
L模板:...

保存:...

"""

+整理内容(_媒介,_内容)->+[del](,+整理内容)...
->的(整理内容,L模板)->的(整理内容,P代码)...

->+[临时文本]#章节->[]{
    []=>的(_内容,章节)->章节=>+[增加内容](章节,+[临时文本]#章节)
}...
->+[python](Python,+[临时文本]#章节)->+[code](+[python],P代码)...
->+[s]"file_text"(+[python],+[临时文本]#章节)...

->+[模板文本](L模板,_内容)...
->+[.]"章节"(+[模板文本],+[临时文本]#章节)...
->[]{
    []:->的(_内容,标题)->标题->+[.](+[模板文本],标题),->[]
}...
->[]{
    []:->的(_内容,作者)->作者->+[.](+[模板文本],作者),->[]
}...
->[]{
    []:->的(_内容,概述)->概述->+[.](+[模板文本],概述),->[]
}...
->[]{
    []:->的(_内容,引用)->引用->+[.](+[模板文本],引用),->[]
}



## end
#1056, 890:
"""
+[P函数](,测试2)
print(list_lk)

"""

import re

paper_text="""
The algorithm of recovering complete electron trajectories from source to detector is schematically shown in Fig.[_setup1]. In Fig.[_setup1], 

"""

link_pat='([fF])ig.\[([a-zA-Z0-9_\.]+)\]'
link_pat2='Figure \[([a-zA-Z0-9_\.]+)\]'
i=0
out_text=''

while True:
    if i>=len(paper_text):
        break
    a=re.match(link_pat,paper_text[i:])
    a2=re.match(link_pat2,paper_text[i:])
    if a!=None and a.group(2) in list_lk:
        new_text='%sig.~\\ref{fig:%s}'%(a.group(1),a.group(2))
        di0=a.span()[1]
        out_text+=new_text
        i+=di0-1
    elif a2!=None and a2.group(1) in list_lk:
        new_text='Figure ~\\ref{fig:%s}'%(a2.group(1))
        di0=a.span()[1]
        out_text+=new_text
        i+=di0-1
    else:
        out_text+=paper_text[i]
    i+=1

ans=out_text

print(paper_text)
print(out_text)

## end
#1057, 543:
"""
+[P函数](,测试)
Nini, 打开公式分析器(文件)

"""

list_lk=['a1','a2','c1']
paper_text="""
[a1,a2]
[1].
[c1],[c1]

"""

import re

link_pat='\[([a-zA-Z]+\d*)(, ?[a-zA-Z]+\d*)*\]'
i=0
out_text=''

while True:
    if i>=len(paper_text):
        break
    a=re.match(link_pat,paper_text[i:])
    if a!=None and a.group(1) in list_lk:
        new_text='\\cite{%s}'%(a.group()[1:-1])
        di0=a.span()[1]
        out_text+=new_text
        i+=di0-1
    else:
        out_text+=paper_text[i]

    i+=1

print(out_text)


"""
print(a.span())
+[P函数](,测试)

"""
## end
#1060, 721:
"""
记住"Python"
测试:...
测试2:...
print(new_text)
print(i)
print(paper_text)

"""

import re

link_pat='([tT])ab.\[([a-zA-Z0-9_\.]+)\]'
link_pat2='Table \[([a-zA-Z0-9_\.]+)\]'
i=0
out_text=''

while True:
    if i>=len(paper_text):
        break
    a=re.match(link_pat,paper_text[i:])
    a2=re.match(link_pat2,paper_text[i:])
    if a!=None and a.group(2) in list_lk:
        new_text='Table~\\ref{tab:%s}'%(a.group(2))
        di0=a.span()[1]
        out_text+=new_text
        i+=di0-1
    elif a2!=None and a2.group(1) in list_lk:
        new_text='Table~\\ref{tab:%s}'%(a2.group(1))
        di0=a2.span()[1]
        out_text+=new_text
        i+=di0-1
    else:
        out_text+=paper_text[i]
    i+=1

ans=out_text



## end
#1062, 403:
"""
P代码:...
print(list_lk)
print(paper_text)
(表格没有缩写)

"""

+整理表格引用(_媒介,_文本)->+[del](,+整理表格引用)...
->的(整理表格引用,P代码)...

->.(_媒介,_文章)...
->+[python]"list_lk=[]"(Python,)->[]{
    []=>的(_文章,_节点)->_节点->表格(_节点,)...
    =>+[标题](_节点,)->+[python]"list_lk.append(name)"(Python,)...
        ->+[s]"name"(+[python],+[标题])
}...

->+[python](Python,_文本)->+[code](+[python],P代码)...
->+[s]"paper_text"(+[python],_文本)



## end
#1064, 763:
"""
+[P函数](,测试2)
print(list_lk)

"""

import re

link_pat='([eE])qn.(\[[a-zA-Z0-9_\.]+\]\.)'
link_pat2='Equation (\[[a-zA-Z0-9_\.]+\]\.)'
i=0
out_text=''
paper_text="""
Eqn.[4].

"""

while True:
    if i>=len(paper_text):
        break
    a=re.match(link_pat,paper_text[i:])
    a2=re.match(link_pat2,paper_text[i:])
    if a!=None and a.group(2) in list_lk:
        new_text='%sqn.~\\ref{eq:%s}'%(a.group(1),a.group(2))
        di0=a.span()[1]
        out_text+=new_text
        i+=di0-1
    elif a2!=None and a2.group(1) in list_lk:
        new_text='Equation ~\\ref{eq:%s}'%(a2.group(1))
        di0=a2.span()[1]
        out_text+=new_text
        i+=di0-1
    else:
        out_text+=paper_text[i]
    i+=1

ans=out_text

print(paper_text)
print(out_text)


## end
#1065, 543:
"""
+[P函数](,测试)
Nini, 打开公式分析器(文件)

"""

list_lk=['a1','a2','c1']
paper_text="""
[a1,a2]
[1].
[c1],[c1]

"""

import re

link_pat='\[([a-zA-Z]+\d*)(, ?[a-zA-Z]+\d*)*\]'
i=0
out_text=''

while True:
    if i>=len(paper_text):
        break
    a=re.match(link_pat,paper_text[i:])
    if a!=None and a.group(1) in list_lk:
        new_text='\\cite{%s}'%(a.group()[1:-1])
        di0=a.span()[1]
        out_text+=new_text
        i+=di0-1
    else:
        out_text+=paper_text[i]

    i+=1

print(out_text)


"""
print(a.span())
+[P函数](,测试)

"""
## end
#1068, 698:
"""
记住"Python"
测试:...
测试2:...

"""

import re

link_pat='([eE])qn?\.(\[[a-zA-Z0-9_\.]+\]\.)'
link_pat2='Equation (\[[a-zA-Z0-9_\.]+\]\.)'
i=0
out_text=''

while True:
    if i>=len(paper_text):
        break
    a=re.match(link_pat,paper_text[i:])
    a2=re.match(link_pat2,paper_text[i:])
    if a!=None and a.group(2) in list_lk:
        new_text='%sq.~\\ref{eq:%s}'%(a.group(1),a.group(2))
        di0=a.span()[1]
        out_text+=new_text
        i+=di0-1
    elif a2!=None and a2.group(1) in list_lk:
        new_text='Equation~\\ref{eq:%s}'%(a2.group(1))
        di0=a2.span()[1]
        out_text+=new_text
        i+=di0-1
    else:
        out_text+=paper_text[i]
    i+=1

ans=out_text



## end
#1070, 407:
"""
P代码:...
+[P函数](,P代码)
print(list_lk)
print(paper_text)

"""

+整理公式引用(_媒介,_文本)->+[del](,+整理公式引用)...
->的(整理公式引用,P代码)...

->.(_媒介,_文章)...
->+[python]"list_lk=[]"(Python,)->[]{
    []=>的(_文章,_节点)->_节点->公式(_节点,)...
    =>+[标题](_节点,)->+[python]"list_lk.append(name)"(Python,)...
        ->+[s]"name"(+[python],+[标题])
}...

->+[python](Python,_文本)->+[code](+[python],P代码)...
->+[s]"paper_text"(+[python],_文本)



## end
#1073, 545:
"""
P代码:...
L模板:...

"""

+整理内容(_媒介,_内容)->+[del](,+整理内容)...
->的(整理内容,L模板)->的(整理内容,P代码)...

->+[临时文本]#章节->[]{
    []=>的(_内容,章节)->章节=>+[增加内容](章节,+[临时文本]#章节)
}...
->+[python](Python,+[临时文本]#章节)->+[code](+[python],P代码)...
->+[s]"file_text"(+[python],+[临时文本]#章节)...

->+[模板文本](L模板,_内容)...
->+[.]"章节"(+[模板文本],+[临时文本]#章节)...
->[]{
    []:->的(_内容,标题)->标题->+[.](+[模板文本],标题),->[]
}...
->[]{
    []:->的(_内容,作者)->作者->+[.](+[模板文本],作者),->[]
}...
->[]{
    []:->的(_内容,概述)->概述->+[.](+[模板文本],概述),->[]
}...
->[]{
    []:->的(_内容,引用)->引用->+[.](+[模板文本],引用),->[]
}



## end
#1075, 204:
"""
import shutil
shutil.copy(src_dir,"%s\\fig.png"%(folder_dir))

"""

import shutil
# print(src_dir,tar_dir)
# ans="%s\%s.tex"%(folder_dir,file_name)
shutil.copy(src_dir,"%s\\%s"%(folder_dir,tar_dir))


## end
#1078, 104:
"""
记住"Python"

"""

if len(name)>3 and name[0]=='[' and name[-2:]=='].':
    name=name[1:-2]
ans=name


## end
#1079, 60:
"""
记住"Python"
+[P函数](,P代码)
保存:...
txt_in

"""
ans=txt_in



## end
#1080, 15:

```py
%内容
```

## end
#1083, 368:
"""
P代码:...
L模板:...

"""

+程序结构(_节点,_内容)->+[del](,+程序结构)...
->的(程序结构,L模板)->的(程序结构,P代码)...

->的(_节点,类型)->的(_节点,位置)...
->的(_节点,名字)->的(_节点,图例)...
->的(_节点,内容)...
->+[python](Python,+[临时文本])->+[code](+[python],P代码)...
->+[.]"txt_in"(+[python],内容)->+[.]"fig_name"(+[python],名字)...

->+[模板文本](,+[增加内容2])->+[增加内容2](,_内容)...
->+[.]"内容"(+[模板文本],内容)...

->+[code](+[模板文本],L模板)



## end
#1085, 284:
"""
记住"Python"
+[P函数](,测试)
text_fig=''
text_f='Fig.X test'

"""
import re

fig_pat='Fig.[a-zA-Z_\.]* '
a=re.match(fig_pat,text_f)

if text_f[0:4]=='Fig.':
    i=a.span()[1]
    text_fig=text_f[i:]
elif text_f[0]=='(':
    text_fig+='\n'+text_f
else:
    state=False

print(text_fig)


## end
#1087, 258:
"""
记住"Python"
测试:...
+[P函数](,P代码)
保存:...

"""
import re

state=True

fig_pat='Fig\.[a-zA-Z0-9_\.\]\[]* '
a=re.match(fig_pat,text_f)

if a!=None:
    i=a.span()[1]
    text_fig=text_f[i:]
elif text_f[0]=='(':
    text_fig+='\n'+text_f
else:
    state=False


## end
#1089, 371:
"""
P代码:...

"""

+收集图例(,_图片)->.(+收集图例,操作)...
->的(收集图例,P代码)...

->[]{
    []:->然后(_图片,_图例)->_图例->+[.]"text_f"([python],_图例)...
        ->+[code]([python],P代码)->[python](Python,)...
        ->+[.]([想],操作)->+[code]([想],收集图例)->[想](,_图例)...
        ->+删除(操作,然后)->+的(操作,+删除)...
        ->+删除(操作,_图例)->+的(操作,+删除),
    ->然后(_图片,_图例1)->_图例1->+结尾(,_图例1)->+的(操作,+结尾),
    ->[]
}



## end
#1092, 417:

name0=name_fig[1:]
name=re.split('\*?\[[bt]\]',name0)[0]
fig_info=name0[len(name):]

fig_a=re.match('(\*?)(\[[bt]\])?',fig_info)
if fig_a==None:
    fig_type='normal'
    fig_pos='[b]'
else:
    if fig_a.group(1)=='*':
        fig_type='wide'
    else:
        fig_type='normal'
    
    if fig_a.group(2)=='[t]':
        fig_pos='t'
    elif fig_a.group(2)=='[b]':
        fig_pos='b'
    else:
        fig_pos='b'

## end
#1094, 4:
%内容

## end
#1098, 62:
var shape, pt, eulers;

%内容

animate_3D();
world_3D.update();

## end
#1099, 50:
"""
记住"Python"

"""

ans="/res/%s.js"%(fig_name)


## end
#1100, 130:

<div id="%名字" class="w3D"></div>
<script>
world_3D.init("%名字");
</script>
<script type="text/javascript" src="..%目标地址"></script>

## end
#1104, 536:
"""
P代码:...
L模板:...
模板2:...

"""

+3D结构(_节点,_内容)->+[del](,+3D结构)...
->的(3D结构,L模板)->的(3D结构,模板2)->的(3D结构,P代码)...

->."输出"(+3D结构,_输出)->的(_输出,地址)...

->的(_节点,名字)->的(_节点,内容)...
->+的(_节点,+目标地址)...

->+[python](Python,+目标地址)->+[code](+[python],P代码)...
->+[.]"fig_name"(+[python],名字)->+[.]"address"(+[python],地址)...

->+[模板文本](,+[增加内容2])->+[增加内容2](,_内容)...
->+[code](+[模板文本],L模板)...
->+[.](+[模板文本],+目标地址)->+[.](+[模板文本],名字)...

->+[模板文本](模板2,+[临时文本])->+[.](+[模板文本],内容)...
->+[增加内容](地址,+[保存文本])->+[增加内容](+目标地址,+[保存文本])...
    ->+[保存文本](,+[临时文本])

## end
#1107, 1067:
"""
Nini, 打开动词(库)
增加:...
文本缩进:...
+[新建阅读窗口](,增加)

P代码:...

保存:...
(+[修改内容]的效果不太稳定, 改成+[模板文本])
+[修改内容](_节点,+[临时文本]#节点)

"""
+结构转文本(_结构,_输出)->+[del](,+结构转文本)...
->的(结构转文本,增加)->的(结构转文本,文本缩进)...
->的(结构转文本,P代码)...

->+[临时文本]#0->[]{
    []:->插入(_结构,)=>的(插入,_节点)->_节点=>+[结构转文本](_节点,+[临时文本]#节点)...
        ->+[.](+[临时文本]#0,+[临时文本]#节点)...
        ->[标题](_节点,)->[m_text]([标题],+[.])...
        ->[]{
            []:->缩进(插入,_节点)->+[做](缩进,+[临时文本]#节点)->+[code](+[做],文本缩进)...
                ->+[.](+[做],+[临时文本]#节点),
            ->[]
        },
    ->[]
}...

->+[模板文本](_结构,_输出)->[]{
    []=>.(+[临时文本]#0,_节点)->_节点=>+[.](+[模板文本],_节点)->[m_text](.,+[.])
}...

->+[临时文本]->[]{
    []:->顺序(_结构,)->的(顺序,_节点)->[]{[]=>_节点1(,_节点)->的(顺序,_节点1)}...
        ->+[做](_节点,+[临时文本])->+[code](+[做],增加)->+[.](+[做],顺序)...
        ->[]{
            []:->缩进(_结构,顺序)->+[做](缩进,+[临时文本])->+[code](+[做],文本缩进)...
                ->+[.](+[做],+[临时文本]),
            ->[]
        },
    ->[]
}...

->+[python](Python,_输出)->+[code](+[python],P代码)...
->+[s]"text_all"(+[python],_输出)->+[s]"text_in"(+[python],+[临时文本])


## end
#1109, 224:
"""


"""
+增加(_节点,_输出)->+[del](,+增加)...

->.(+增加,顺序)->_节点(,_节点1)...
->+[结构转文本](_节点,+[临时文本])->+[增加内容](+[临时文本],_输出)...

->[]:
    ->_节点1->+[增加内容](顺序,_输出)...
        ->+[做](_节点1,_输出)->+[code](+[做],增加)->+[.](+[做],顺序),
    ->[]


## end
#1111, 285:
"""


"""
+文本结构_插入尾部(_结构,节点#0)->+[del](,+文本结构_插入尾部)...

->[]{
    []:->顺序(_结构,),->+顺序(_结构,)->+的(_结构,+顺序)
}->顺序(_结构,)...
    ->+[修改内容](,顺序)->[m_text](+文本结构_插入尾部,+[修改内容])...

->[]{
    []:->的(顺序,节点)->节点(,_节点)->[]{[]=>_节点}...
        ->+的(顺序,节点#0)->+[右连](节点,节点#0),
    ->+的(顺序,节点#0)
}




## end
#1113, 212:
"""


"""
+文本结构_插入(_结构,_节点#0)->+[del](,+文本结构_插入)...

->[]{
    []:->插入(_结构,),->+插入(_结构,)->+的(_结构,+插入)
}->插入(_结构,)->+的(插入,_节点#0)...

->[]{
    []:->[==](,+文本结构_插入),
    ->+缩进(插入,_节点#0)->[m_text](+文本结构_插入,+缩进)
}



## end
#1115, 717:
Nini, 打开句子结构(文件)
Nini, 打开句子结构(文件)
Nini, 打开公式分析器(文件)
Nini, 打开编程语言parser(文件)

句子规则:...
公式规则:...
python规则:...
parser规则:...
+[新建阅读窗口](,python规则)

目录:[规则] (\\n [目录])?
规则:[词语] : [模式]
模式:[语句] (\| [模式])?
语句:[单元] \?? (\\s [语句])?
单元:\\\[ [词语] \\\]| \\\( [模式] \\\)| [词语]
词语:\[\\w\\d\]\+


测试规则:...
[解析Parser结构]"文本"(+[临时文本],测试规则)
+[新建阅读窗口](,测试规则)
+[显示parser结构](测试规则,结构)
+[显示parser结构_代码](测试规则,结构)
figure

结构:...
+[python](Python,)->+[.]"text222"(+[python],结构)
+[新建阅读窗口](,结构)
将'结构'的"info"替换为"info()"
+[召唤星辰]"生成Parser代码"(测试规则,结构)
+[召唤星辰]"生成Parser代码_快速"(测试规则,结构)
的(结构,结构#1)->+[显示星图](,结构#1)
+[设置结构](,结构)
+[删除结构](,结构)
[解析Parser结构]"文本"(+[临时文本],测试规则)->[记录结构](+[临时文本],)...
->+[导入节点](,结构)->[m_text]([记录结构],+[导入节点])
+[显示星图](,结构)

对比文本:...


## end
#1117, 846:
单句: [被动句]| [把字句]| [普通句]
句子: [复句]| [被动句]| [把字句]| [普通句]
# 普通句: ([介宾短语] , ) ([主语]) [谓语] ([宾语]) ([副词]| [补语])
普通句: ([前缀]) ([主语]) [谓语] ([宾语]) ([副词]| [补语])
被动句: ([介宾短语] , ) [宾语] [状语] 被 [主语] [谓语] ([补语])
把字句: ([介宾短语] , ) ([主语]) [状语] 把|将 ([宾语]) [谓语] ([补语])
主语: ([定语]) 名词| [并列短语]
谓语: ([状语]) 动词| 被 动词 ([副词]| [助词])
宾语: ([定语]) 名词| [并列短语]
定语: (形容词| 数量词| 名词| (短语)) 助词
# 状语: (副词| 形容词| 代词| ([介宾短语])| ([并列短语])) 助词
状语: (副词| 形容词| 代词| [介宾短语]) 助词
# 补语: (动词| 形容词| 数量词| 代词(?)| [介宾短语]| [并列短语]| [述宾短语]) 助词
补语: (形容词| 数量词| 代词(?)| [介宾短语]| [并列短语]| [述宾短语]) 助词

# 短语: (并列短语)| (偏正短语)| (述宾短语)| (述补短语)| (主谓短语)| (介宾短语)
短语: (并列短语)| (偏正短语)| (述补短语)| (主谓短语)| (介宾短语)
# 并列短语: (名词| 形容词) 连词 ((并列短语)| 名词| 形容词)
并列短语: 名词 (连词| , ) ([并列短语]| 名词)
偏正短语: (名词| 形容词) (名词| 动词)
# 述宾短语: 动词 (宾语)
介宾短语: [介词] [名词] ([副词])
述宾短语: 动词 名词
述补短语: 动词 形容词
主谓短语: 名词 (动词|副词)
# 介宾短语: 介词 (宾语)

前缀: [介词] [名词] ([副词]| [述宾短语])
## end
#1119, 748:
算式: 等式...
等式: (-)和式 (等于 等式)...
和式: 乘式 (加减 和式)...
乘式: 项|(特殊表达式 ^ [幂次]) (乘除 乘式)...
特殊表达式: [分式]| [求和式]| [积分式]| [根式]| [偏微分]| [微分]| [矢量] |[矩阵] |[方程组]...

分式: \frac { (-) 和式 } { (-) 和式 }...
+[新建阅读窗口](,分式)
根式: \sqrt { 和式 }...

偏微分:\p { 函数输入 } { 和式 }...
积分式:\int _ { 和式 } ^ { 和式 } { 函数输入 } { 和式 }...
求和式:\sum _ { 和式 } ^ { 和式 } { 函数输入 } { 和式 }...
微分:\d { 和式 }( _ { 变量 })...
# 差分:\D { 和式 }...

矢量:\vec { [变量]| [函数输入] }...
矩阵:\mat { [变量]| [矩阵输入] }...
方程组:\eqs { [矩阵输入] }...
将条目"矩阵"复制为条目"方程组"
+[新建阅读窗口](,矢量)

项: 括号|数字|变量|函数...
括号: \( 和式 \) (幂次)...
数字: 数字|特殊数字 (幂次)...
变量: 字母 (下标) (\[ [矩阵输入] \]) (\( [函数输入] \)) (幂次)...
下标: _ 数字|变量|({ 数字|变量 })...
幂次: ^ (数字|变量|({ 和式 })...
+[新建阅读窗口](,变量)

# 函数输入: [和式] (, 函数输入)...
函数输入: [等式] (, 函数输入)...
矩阵输入: [函数输入] (; [矩阵输入])...
## end
#1121, 490:
程序:(( *n)[语句]\n)|[结束][程序]...
语句:[if]|[for]|[while]|[try]|[def]|[class]|[运算]|[空格]...
语句的"_语句"替换为"结构"

def:def [变量]\([输入]\):\n[程序]...
class:class [变量]\([输入]\):\n[程序]...
try:try:\n[程序]except([条件]):[程序]...
while:while [条件]:\n[程序]...
class的"def"替换为"class"
模块结尾的"匹配模式"替换为"匹配模式_编程"

for:for [变量] in [范围]:\n[程序]...
for的"if"替换为"for"
+[新建阅读窗口](,try)

if:if [条件]:\n[程序][else]?...
输入:[变量],?[输入]?...
+[新建阅读窗口](,if)

运算:~[\s\t\n]+\n...
+[新建阅读窗口](,if)

空格:[\s\t]*\n...
变量:[\w_\d]+...
条件:~:*...
范围:[条件]...

## end
#1123, 412:
"""
P代码:...
库:...
+[新建阅读窗口](,库)

"""

+解析Parser结构(_结构,_节点)...
->的(解析Parser结构,库)->的(解析Parser结构,P代码)...
->的(库,目录)...

->Python->[]{
    []:->[==]"文本"(,+解析Parser结构)->+[.]"code_text"([python],_节点)...
        ->+[code]([python],P代码)->[python](Python,)...
        ->+的(_结构,+入口)->+[code]([想]#1,目录)->[想]#1(_结构,+入口),

    ->的(库,_条目)->_条目->[标题](_条目,)->[==]([标题],+解析Parser结构)...
        ->+[code]([想],_条目)->[想](_结构,_节点)
}


## end
#1125, 157:


目录:[规则] \n [目录]?
规则:[词语] : [模式]
模式:[语句] (\| [模式])?
语句:[单元] \?? (\s [语句])?
单元:(\[ [词语] \]| [标点]| \( [模式] \)) (\{ [词语] \})?

词语:...
标点:...
将条目"词语"复制为条目"标点"


## end
#1127, 42:
"""


"""

text=code_text
i=0
state=True


## end
#1129, 141:
"""
[规则] \n [目录]?

"""
+目录(_结构,入口)...

->[解析Parser结构]"规则"(_结构,入口)...
->[]{
    []:->[匹配模式_通用]"\n\s*"->[解析Parser结构]"目录"(_结构,入口),
    ->[]
}



## end
#1131, 209:
"""
[词语] : [模式]

"""
+规则(_结构,入口)...

->+条目(入口,)->+情况(+条目,)...
->+的(_结构,+条目)->+的(_结构,+情况)...

->[解析Parser结构]"词语"(_结构,+条目)->[匹配模式_通用]"\:\s*"...
    ->内容(+条目,)->[说]"定义条目: "(,内容)...
->[解析Parser结构]"模式"(_结构,+情况)




## end
#1133, 230:
"""
[语句] ( \|\s [模式])?

"""
+模式(_结构,_情况)...

->+单元(_情况,)->+的(_结构,+单元)...

->[解析Parser结构]"语句"(_结构,+单元)...
->[]{
    []{[匹配模式_通用]"\| "}:
        ->+情况(_情况,)->+的(_结构,+情况)...
            ->[解析Parser结构]"模式"(_结构,+情况),
        ->>[]
}



## end
#1135, 264:
"""
[单元] \?? (\s [语句])?

"""
+语句(_结构,单元)...

->[解析Parser结构]"单元"(_结构,单元)...
->[]{
    []:->[匹配模式_通用]"\?"->+或许(单元,)->+的(_结构,+或许),
    ->[]
}...
->[]{
    []{[匹配模式_通用]" "}:
        ->+单元(单元,)->+的(_结构,+单元)...
            ->[解析Parser结构]"语句"(_结构,+单元),
        ->>[]
}



## end
#1137, 525:
"""
(\[ [词语] \]| [标点]| \( [模式] \)) (\{ [词语] \})?
保存:...

"""
+单元(_结构,单元)...

->[]{
    []:->+引用(单元,)->+的(_结构,+引用)...
        ->[匹配模式_通用]"\["->[解析Parser结构]"词语"(_结构,单元)...
        ->[匹配模式_通用]"\]",

    ->+模块(单元,+情况)->+的(_结构,+模块)->+的(_结构,+情况)...
        ->[匹配模式_通用]"\("->[解析Parser结构]"模式"(_结构,+情况)...
        ->[匹配模式_通用]"\)",

    ->+标点(单元,)->+的(_结构,+标点)...
        ->[解析Parser结构]"标点"(_结构,单元)
}...
->[]{
    []:->+节点(单元,)->+的(_结构,+节点)...
        ->[匹配模式_通用]"\{"->[解析Parser结构]"词语"(_结构,+节点)...
        ->[匹配模式_通用]"\}",
    ->[]
}


## end
#1139, 111:
"""
P代码:...

"""

+标点(_结构,_单元)...

->+内容(_单元,)->+的(_结构,+内容)...

->+[code]([python],P代码)->[python](Python,+内容)


## end
#1141, 418:
"""
保存:...

if text[i]=="\\":
    ans+='\\'

"""
i0=i
ans=""
try:
    while True:
        if i>=len(text):
            break
        elif text[i]==" " or text[i]=="\n" or text[i]=="|" or text[i]=="?" or text[i]==")":
            break
        elif text[i]=="{":
            break
        elif text[i]=="\\":
            i+=1
        ans+=text[i]
        i+=1
    state=not (ans=="")
except:
    i=i0
    state=False



## end
#1143, 159:
目录:[规则]{A} (\\n [目录])?
规则:[词语] : [模式]
模式:[语句] (\\\| [模式])?
语句:[单元] \\\?? (\  [语句])?
单元:(\\\[ [词语] \\\]| \\\( [模式] \\\)| [词语]) (\{ [词语] \})?
词语:\[\\w\\d\]\+{词语}
## end
#1145, 713:
program:[code]
code:[block] [code]?
block:\\s* ([cond]| [loop]| [func]| [class]| [normal]| [comm])
class:class\  [name] (: [name])? (;| \{ [codeCl] \};)
codeCl:\\s* (public| private| protected) \ *:\\s* [normal] \\n [codeCl]?
func:[type] [field]? [name] \\\( [input] \\\) (;| \{ [block] \})
cond:if\ *\\\(\ *[cmd]\ *\\\)\\s*\{ [block] \}\\s* [cond2]?
cond2:else\  [cond]| else\ *\{ [block] \}
loop:[loop1]| [loop2]| [loop3]
loop1:for\ *\\\( [cmd] \\\)\ *\{ [block] \}
loop2:while\ *\\\( [cmd] \\\)\ *\{ [block] \}
loop3:do\ *\{ [block] \}\* while\ *\\\( [cmd] \\\)\ *;
comm:/\\* .* \\*/
normal:\\s* [cmd] ;\\s*\n [normal]?
type:[name] \ *
field:[name] \ *::\ *
input:\ * [cmd] \ * (,\ * [cmd])?
name:\\w+
cmd:\\w+
## end
#1147, 382:
"""
\[ [词语] \] |\( [模式] \) | [标点]
保存:...

"""
+单元(_结构,单元)...

->[]{
    []:->+引用(单元,)->+的(_结构,+引用)...
        ->[匹配模式_通用]"\["->[解析Parser结构]"词语"(_结构,单元)...
        ->[匹配模式_通用]"\]",

    ->+模块(单元,+情况)->+的(_结构,+模块)...
        ->[匹配模式_通用]"\("->[解析Parser结构]"模式"(_结构,+情况)...
        ->[匹配模式_通用]"\)",

    ->+标点(单元,)->+的(_结构,+标点)...
        ->[匹配模式_通用]"[^\s]"->[m_text]([匹配模式_通用],+标点)
}



## end
#1149, 18694:
"""
+[P函数](,结构)
print('2'.replace('2','333'))
标点

"""

import re
from body.bone import NetP
from tools import tools_basic

def word_pat_token(code,i,pat):
    text=''

#    pat=pat.replace('\\','\\\\')
    a=re.match(pat,code[i:])
    if a==None:
        state=False
    else:
        di=a.span()[1]
        output_txt=code[i:i+di]
        i+=di
        state=True
        text=output_txt
    
    return [state,i,text]


def parser_token_cmd(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'\w+')
    
    list_pt+=list_new

    if state==False:
        print("cmd:",state)
        return [False,i0,None]
    else:
        print("cmd:",state,pt0.info())
        return [True,i,pt0]

def parser_token_name(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'\w+')
    
    list_pt+=list_new

    if state==False:
        print("name:",state)
        return [False,i0,None]
    else:
        print("name:",state,pt0.info())
        return [True,i,pt0]

def parser_token_input(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r' *')
    if state==True:
        [state,i,pt0]=parser_token_cmd(code,i,list_new)
        if state==True:
            [state,i,text]=word_pat_token(code,i,r' *')
            if state==True:
                i1=i
                state1=True
                list_new1=list_new[:]
                # list_new=[]
                [state,i,text]=word_pat_token(code,i,r', *')
                if state==True:
                    [state,i,pt1]=parser_token_cmd(code,i,list_new)
                    if state==True:
                        pt1.con(pt0,0)
                    else:
                        pt1=pt0
                
                if state==False:
                    i=i1
                    list_new=list_new1
                    state=True
                    state1=False
                # else:
                #     list_new=list_new1+list_new
    
    list_pt+=list_new

    if state==False:
        print("input:",state)
        return [False,i0,None]
    else:
        print("input:",state,pt0.info())
        return [True,i,pt0]

def parser_token_field(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,pt0]=parser_token_name(code,i,list_new)
    if state==True:
        [state,i,text]=word_pat_token(code,i,r' *:: *')
    
    list_pt+=list_new

    if state==False:
        print("field:",state)
        return [False,i0,None]
    else:
        print("field:",state,pt0.info())
        return [True,i,pt0]

def parser_token_type(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,pt0]=parser_token_name(code,i,list_new)
    if state==True:
        [state,i,text]=word_pat_token(code,i,r' *')
    
    list_pt+=list_new

    if state==False:
        print("type:",state)
        return [False,i0,None]
    else:
        print("type:",state,pt0.info())
        return [True,i,pt0]

def parser_token_normal(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'\s*')
    if state==True:
        [state,i,pt0]=parser_token_cmd(code,i,list_new)
        if state==True:
            [state,i,text]=word_pat_token(code,i,r';\s*n')
            if state==True:
                i1=i
                state1=True
                list_new1=list_new[:]
                # list_new=[]
                [state,i,pt1]=parser_token_normal(code,i,list_new)
                if state==True:
                    pt1.con(pt0,0)
                else:
                    pt1=pt0
                if state==False:
                    i=i1
                    list_new=list_new1
                    state=True
                    state1=False
                # else:
                #     list_new=list_new1+list_new
    
    list_pt+=list_new

    if state==False:
        print("normal:",state)
        return [False,i0,None]
    else:
        print("normal:",state,pt0.info())
        return [True,i,pt0]

def parser_token_comm(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'/\*')
    if state==True:
        [state,i,text]=word_pat_token(code,i,r'.*')
        if state==True:
            [state,i,text]=word_pat_token(code,i,r'\*/')
    
    list_pt+=list_new

    if state==False:
        print("comm:",state)
        return [False,i0,None]
    else:
        print("comm:",state,pt0.info())
        return [True,i,pt0]

def parser_token_loop3(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'do *{')
    if state==True:
        [state,i,pt0]=parser_token_block(code,i,list_new)
        if state==True:
            [state,i,text]=word_pat_token(code,i,r'}*')
            if state==True:
                [state,i,text]=word_pat_token(code,i,r'while *\(')
                if state==True:
                    [state,i,pt1]=parser_token_cmd(code,i,list_new)
                    if state==True:
                        pt1.con(pt0,0)
                    else:
                        pt1=pt0
                    if state==True:
                        [state,i,text]=word_pat_token(code,i,r'\) *;')
    
    list_pt+=list_new

    if state==False:
        print("loop3:",state)
        return [False,i0,None]
    else:
        print("loop3:",state,pt0.info())
        return [True,i,pt0]

def parser_token_loop2(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'while *\(')
    if state==True:
        [state,i,pt0]=parser_token_cmd(code,i,list_new)
        if state==True:
            [state,i,text]=word_pat_token(code,i,r'\) *{')
            if state==True:
                [state,i,pt1]=parser_token_block(code,i,list_new)
                if state==True:
                    pt1.con(pt0,0)
                else:
                    pt1=pt0
                if state==True:
                    [state,i,text]=word_pat_token(code,i,r'}')
    
    list_pt+=list_new

    if state==False:
        print("loop2:",state)
        return [False,i0,None]
    else:
        print("loop2:",state,pt0.info())
        return [True,i,pt0]

def parser_token_loop1(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'for *\(')
    if state==True:
        [state,i,pt0]=parser_token_cmd(code,i,list_new)
        if state==True:
            [state,i,text]=word_pat_token(code,i,r'\) *{')
            if state==True:
                [state,i,pt1]=parser_token_block(code,i,list_new)
                if state==True:
                    pt1.con(pt0,0)
                else:
                    pt1=pt0
                if state==True:
                    [state,i,text]=word_pat_token(code,i,r'}')
    
    list_pt+=list_new

    if state==False:
        print("loop1:",state)
        return [False,i0,None]
    else:
        print("loop1:",state,pt0.info())
        return [True,i,pt0]

def parser_token_loop(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,pt0]=parser_token_loop1(code,i,list_new)
    if state==False:
        i=i0
        list_new=list_new0
        [state,i,pt0]=parser_token_loop2(code,i,list_new)
    if state==False:
        i=i0
        list_new=list_new0
        [state,i,pt0]=parser_token_loop3(code,i,list_new)
    
    list_pt+=list_new

    if state==False:
        print("loop:",state)
        return [False,i0,None]
    else:
        print("loop:",state,pt0.info())
        return [True,i,pt0]

def parser_token_cond2(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'else ')
    if state==True:
        [state,i,pt0]=parser_token_cond(code,i,list_new)
    if state==False:
        i=i0
        list_new=list_new0
        [state,i,text]=word_pat_token(code,i,r'else *{')
        if state==True:
            [state,i,pt0]=parser_token_block(code,i,list_new)
            if state==True:
                [state,i,text]=word_pat_token(code,i,r'}')
    
    list_pt+=list_new

    if state==False:
        print("cond2:",state)
        return [False,i0,None]
    else:
        print("cond2:",state,pt0.info())
        return [True,i,pt0]

def parser_token_cond(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'if *\( *[cmd] *\)\s*{')
    if state==True:
        [state,i,pt0]=parser_token_block(code,i,list_new)
        if state==True:
            [state,i,text]=word_pat_token(code,i,r'}\s*')
            if state==True:
                i1=i
                state1=True
                list_new1=list_new[:]
                # list_new=[]
                [state,i,pt1]=parser_token_cond2(code,i,list_new)
                if state==True:
                    pt1.con(pt0,0)
                else:
                    pt1=pt0
                if state==False:
                    i=i1
                    list_new=list_new1
                    state=True
                    state1=False
                # else:
                #     list_new=list_new1+list_new
    
    list_pt+=list_new

    if state==False:
        print("cond:",state)
        return [False,i0,None]
    else:
        print("cond:",state,pt0.info())
        return [True,i,pt0]

def parser_token_func(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,pt0]=parser_token_type(code,i,list_new)
    if state==True:
        i1=i
        state1=True
        list_new1=list_new[:]
        # list_new=[]
        [state,i,pt1]=parser_token_field(code,i,list_new)
        if state==True:
            pt1.con(pt0,0)
        else:
            pt1=pt0
        if state==False:
            i=i1
            list_new=list_new1
            state=True
            state1=False
        # else:
        #     list_new=list_new1+list_new
        if state==True:
            [state,i,pt2]=parser_token_name(code,i,list_new)
            if state==True:
                pt2.con(pt1,0)
            else:
                pt2=pt1
            if state==True:
                [state,i,text]=word_pat_token(code,i,r'\(')
                if state==True:
                    [state,i,pt3]=parser_token_input(code,i,list_new)
                    if state==True:
                        pt3.con(pt2,0)
                    else:
                        pt3=pt2
                    if state==True:
                        [state,i,text]=word_pat_token(code,i,r'\)')
                        if state==True:
                            i4=i
                            list_new4=list_new[:]
                            [state,i,text]=word_pat_token(code,i,r';')
                            if state==False:
                                i=i4
                                list_new=list_new4
                                [state,i,text]=word_pat_token(code,i,r'{')
                                if state==True:
                                    [state,i,pt4]=parser_token_block(code,i,list_new)
                                    if state==True:
                                        pt4.con(pt3,0)
                                    else:
                                        pt4=pt3
                                    if state==True:
                                        [state,i,text]=word_pat_token(code,i,r'}')
                            
    
    list_pt+=list_new

    if state==False:
        print("func:",state)
        return [False,i0,None]
    else:
        print("func:",state,pt0.info())
        return [True,i,pt0]

def parser_token_codeCl(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'\s*')
    if state==True:
        i0=i
        list_new0=list_new[:]
        [state,i,text]=word_pat_token(code,i,r'public')
        if state==False:
            i=i0
            list_new=list_new0
            [state,i,text]=word_pat_token(code,i,r'private')
        if state==False:
            i=i0
            list_new=list_new0
            [state,i,text]=word_pat_token(code,i,r'protected')
        
        if state==True:
            [state,i,text]=word_pat_token(code,i,r' *:\s*')
            if state==True:
                [state,i,pt1]=parser_token_normal(code,i,list_new)
                if state==True:
                    pt1.con(pt0,0)
                else:
                    pt1=pt0
                if state==True:
                    [state,i,text]=word_pat_token(code,i,r'\n')
                    if state==True:
                        i2=i
                        state2=True
                        list_new2=list_new[:]
                        # list_new=[]
                        [state,i,pt2]=parser_token_codeCl(code,i,list_new)
                        if state==True:
                            pt2.con(pt1,0)
                        else:
                            pt2=pt1
                        if state==False:
                            i=i2
                            list_new=list_new2
                            state=True
                            state2=False
                        # else:
                        #     list_new=list_new2+list_new
    
    list_pt+=list_new

    if state==False:
        print("codeCl:",state)
        return [False,i0,None]
    else:
        print("codeCl:",state,pt0.info())
        return [True,i,pt0]

def parser_token_class(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'class ')
    if state==True:
        [state,i,pt0]=parser_token_name(code,i,list_new)
        if state==True:
            i1=i
            state1=True
            list_new1=list_new[:]
            # list_new=[]
            [state,i,text]=word_pat_token(code,i,r':')
            if state==True:
                [state,i,pt1]=parser_token_name(code,i,list_new)
                if state==True:
                    pt1.con(pt0,0)
                else:
                    pt1=pt0
            
            if state==False:
                i=i1
                list_new=list_new1
                state=True
                state1=False
            # else:
            #     list_new=list_new1+list_new
            if state==True:
                i2=i
                list_new2=list_new[:]
                [state,i,text]=word_pat_token(code,i,r';')
                if state==False:
                    i=i2
                    list_new=list_new2
                    [state,i,text]=word_pat_token(code,i,r'{')
                    if state==True:
                        [state,i,pt2]=parser_token_codeCl(code,i,list_new)
                        if state==True:
                            pt2.con(pt1,0)
                        else:
                            pt2=pt1
                        if state==True:
                            [state,i,text]=word_pat_token(code,i,r'};')
                
    
    list_pt+=list_new

    if state==False:
        print("class:",state)
        return [False,i0,None]
    else:
        print("class:",state,pt0.info())
        return [True,i,pt0]

def parser_token_block(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'\s*')
    if state==True:
        i0=i
        list_new0=list_new[:]
        [state,i,pt0]=parser_token_cond(code,i,list_new)
        if state==False:
            i=i0
            list_new=list_new0
            [state,i,pt0]=parser_token_loop(code,i,list_new)
        if state==False:
            i=i0
            list_new=list_new0
            [state,i,pt0]=parser_token_func(code,i,list_new)
        if state==False:
            i=i0
            list_new=list_new0
            [state,i,pt0]=parser_token_class(code,i,list_new)
        if state==False:
            i=i0
            list_new=list_new0
            [state,i,pt0]=parser_token_normal(code,i,list_new)
        if state==False:
            i=i0
            list_new=list_new0
            [state,i,pt0]=parser_token_comm(code,i,list_new)
        
    
    list_pt+=list_new

    if state==False:
        print("block:",state)
        return [False,i0,None]
    else:
        print("block:",state,pt0.info())
        return [True,i,pt0]

def parser_token_code(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,pt0]=parser_token_block(code,i,list_new)
    if state==True:
        i1=i
        state1=True
        list_new1=list_new[:]
        # list_new=[]
        [state,i,pt1]=parser_token_code(code,i,list_new)
        if state==True:
            pt1.con(pt0,0)
        else:
            pt1=pt0
        if state==False:
            i=i1
            list_new=list_new1
            state=True
            state1=False
        # else:
        #     list_new=list_new1+list_new
    
    list_pt+=list_new

    if state==False:
        print("code:",state)
        return [False,i0,None]
    else:
        print("code:",state,pt0.info())
        return [True,i,pt0]

def parser_token_program(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,pt0]=parser_token_code(code,i,list_new)
    
    list_pt+=list_new

    if state==False:
        print("program:",state)
        return [False,i0,None]
    else:
        print("program:",state,pt0.info())
        return [True,i,pt0]


def parser_text2pts(code):
    list_pt0=[]
    [state,i,pt]=parser_token_program(code,0,list_pt0)
    list_pt=[]
    for pt in list_pt0:
        if pt!=None:
                list_pt.append(pt)
    if state==False:
        return ''
    text=tools_basic.writeStdCode([],list_pt)
    return text

#text=parser_text2pts('A:B')
#print(text)



"""
+[P函数](,结构)

"""
## end
#1150, 212:
"""


"""

pat="[\w_\d]+"
try:
    a=re.match(pat,text[i:])
    if a==None:
        state=False
    else:
        di=a.span()[1]
        ans=text[i:i+di]
        i+=di
        state=True
except:
    state=False


## end
#1152, 122:
"""
P代码:...

"""

+词语(_结构,_单元)...

->+内容(_单元,)->+的(_结构,+内容)...

->+[code]([python],P代码)->[python](Python,+内容)->[说](,+内容)


## end
#1155, 239:
"""
保存:...

"""

pat="[\\\,\\w\\d\\?\\[\\]\\(\\):]+"
try:
    a=re.match(pat,text[i:])
    if a==None:
        state=False
    else:
        di=a.span()[1]
        ans=text[i:i+di]
        i+=di
        state=True
except:
    state=False


## end
#1157, 22:


召唤规则:...
降临规则:...



## end
#1159, 206:
"""


"""

+召唤规则(_媒介,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_凭依)...

->[==]"生成Parser代码_快速"(,召唤星辰)...
    ->+生成代码(_媒介,_凭依)->+的(操作,+生成代码)...
    ->+结构变换(_媒介,_凭依)->+的(操作,+结构变换)...
    ->+生成结构(_媒介,_凭依)->+的(操作,+生成结构)




## end
#1161, 46:


生成结构:...
结构变换:...
生成代码:...
+[新建阅读窗口](,生成代码)

## end
#1163, 142:
"""


"""
+生成结构(_媒介,_凭依)->+[del](,+生成结构)...

->+的(_凭依,+结构)...
->[解析Parser结构_代码](,_媒介)...
->+[导入节点](,+结构)->[m_text]([解析Parser结构_代码],+[导入节点])



## end
#1165, 285:
"""
描述结构:...
库:...

"""
+结构变换(_媒介,_凭依)->+[del](,+结构变换)...
->的(结构变换,描述结构)->的(结构变换,库)...

->+[code]([想],描述结构)->[想](_媒介,_凭依)...
->操作([想],)->[]{
    []=>的(操作,_操作)->_操作(_主语,_宾语)->_主语->_宾语=>[说](,_操作)...
        ->的(库,_条目)->_条目->[eq](_条目,_操作)...
        ->+[做](_主语,_宾语)->+[code](+[做],_条目)
}


## end
#1167, 239:
"""
模板:...

"""
+生成代码(_媒介,_凭依)->+[del](,+生成代码)...
->的(生成代码,模板)...

->+[标题](_凭依,)->的(_凭依,结构)->的(结构,起点)...
->起点(,条目)->条目(,内容)...
->+[模板文本](模板,_凭依)...
->+[.](+[模板文本],+[标题])->+[.]"条目"(+[模板文本],内容)...

->+[结构转文本](_凭依,_凭依)...
->+[删除结构](,_凭依)





## end
#1169, 135:
"""
下一条:...

"""
+描述结构(_媒介,_凭依)->+操作(+描述结构,)...

->的(_凭依,结构)...
->的(结构,起点)->起点(,条目)...
->+[code]([想],下一条)->+[.]([想],+操作)->[想](_凭依,条目)


## end
#1171, 12:


设置函数:...


## end
#1173, 365:
"""
描述结构:...
库:...

"""

+设置函数(_条目,_凭依)->+[del](,+设置函数)...
->的(设置函数,描述结构)->的(设置函数,库)...

->+[文本结构_插入尾部](_凭依,+节点)->+[文本结构_插入](+节点,+序号)...
->+的(+节点,+序号)->+序号"0"...

->+[code]([想],描述结构)->[想](_条目,+节点)...
->操作([想],)->[]{
    []=>的(操作,_操作)->_操作(_主语,_宾语)->_主语->_宾语=>[说](,_操作)...
        ->的(库,_条目0)->_条目0->[eq](_条目0,_操作)...
        ->+[做](_主语,_宾语)->+[code](+[做],_条目0)
}



## end
#1175, 162:
"""
情况0:...
单元0:...

"""
+描述结构(_条目,_节点)->+操作(+描述结构,)...

->定义(_条目,情况)->+[code]([想],情况0)...
    ->+[.]([想],+操作)->[想](情况,_节点)...

->+设置条目(_条目,_节点)->+的(+操作,+设置条目)



## end
#1177, 52:


设置单元:...
设置情况:...
设置条目:...
将条目"设置单元"复制为条目"设置条目"



## end
#1179, 495:
"""


"""
+情况0(情况,_节点)->.(+情况0,操作)...
->情况0->的(描述结构,情况0)->的(描述结构,单元0)...

->+[文本结构_插入尾部](_节点,+节点)...
->[投影](,+[文本结构_插入尾部])->[投影](,+节点)...

->的(_节点,序号)->+的(+节点,+序号)->+[文本结构_插入](+节点,+序号)...
->[投影](,+[文本结构_插入])->[投影](,+序号)...
->+[.]"n"([python],序号)->[python]"
state=True
ans=int(n[0]-1)
"(Python,+序号)...

->情况(,单元)->+[code]([想],单元0)...
    ->+[.]([想],操作)->[想](单元,+节点)...
->[]{
    []=>情况#1(情况,)=>+[code]([想]#1,情况0)...
        ->+[.]([想]#1,操作)->[想]#1(情况#1,_节点)
}...

->+设置情况(情况,+节点)->+的(操作,+设置情况)



## end
#1181, 720:
"""


"""
+单元0(单元,_节点)->.(+单元0,操作)...
->单元0->的(描述结构,单元0)->的(描述结构,情况0)...

->+[文本结构_插入](_节点,+单元)...
->[投影](,+[文本结构_插入])->[投影](,+单元)...

->的(_节点,序号)->+的(+单元,+序号)->+[文本结构_插入](+单元,+序号)...
->[投影](,+[文本结构_插入])->[投影](,+序号)...
->+[.]"n"([python],序号)->[python]"
state=True
ans=int(n[0]+1)
"(Python,+序号)...

->单元(,_类型)->[]{
    []:->节点(_类型,内容)->内容(,)...
        ->+[文本结构_插入](+单元,+标题)->[m_text](内容,+标题)...
        ->[投影](,+[文本结构_插入])->[投影](,+标题),
    ->[is](_类型,标点)->标点->[m_text](序号,+序号),
    ->[]
}...

->[]{
    []=>[is](_类型,模块)->模块(,情况)=>+[code]([想]#1,情况0)...
        ->+[.]([想]#1,操作)->[想]#1(情况,+单元)
}...
->[]{
    []=>单元#1(单元,)=>+[code]([想],单元0)...
        ->+[.]([想],操作)->[想](单元#1,+单元)
}...

->+设置单元(单元,+单元)->+的(操作,+设置单元)





## end
#1183, 203:
"""


"""

+召唤规则(_媒介,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_凭依)...

->[==]"生成Parser代码"(,召唤星辰)...
    ->+生成代码(_媒介,_凭依)->+的(操作,+生成代码)...
    ->+结构变换(_媒介,_凭依)->+的(操作,+结构变换)...
    ->+生成结构(_媒介,_凭依)->+的(操作,+生成结构)




## end
#1185, 6587:
生成Parser代码#0"

召唤规则:...
降临规则:...


"(,)
的#1""(生成Parser代码#0,召唤规则#2)
召唤规则#2"\"\"\"


\"\"\"

+召唤规则(_媒介,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_凭依)...

->[==]\"生成Parser代码\"(,召唤星辰)...
    ->+生成代码(_媒介,_凭依)->+的(操作,+生成代码)...
    ->+结构变换(_媒介,_凭依)->+的(操作,+结构变换)...
    ->+生成结构(_媒介,_凭依)->+的(操作,+生成结构)



"(,)
的#3""(生成Parser代码#0,降临规则#4)
降临规则#4"

生成结构:...
结构变换:...
生成代码:...

"(,)
的#5""(降临规则#4,生成结构#6)
生成结构#6"\"\"\"


\"\"\"
+生成结构(_媒介,_凭依)->+[del](,+生成结构)...

->+的(_凭依,+结构)...
->[解析Parser结构]\"文本\"(+[临时文本],_媒介)->[记录结构](+[临时文本],)...
->+[导入节点](,+结构)->[m_text]([记录结构],+[导入节点])


"(,)
的#7""(降临规则#4,结构变换#8)
结构变换#8"\"\"\"
描述结构:...
库:...

\"\"\"
+结构变换(_媒介,_凭依)->+[del](,+结构变换)...
->的(结构变换,描述结构)->的(结构变换,库)...

->+[code]([想],描述结构)->[想](_媒介,_凭依)...
->操作([想],)->[]{
    []=>的(操作,_操作)->_操作(_主语,_宾语)->_主语->_宾语=>[说](,_操作)...
        ->的(库,_条目)->_条目->[eq](_条目,_操作)...
        ->+[做](_主语,_宾语)->+[code](+[做],_条目)
}

"(,)
的#9""(结构变换#8,描述结构#10)
描述结构#10"\"\"\"


\"\"\"
+描述结构(_媒介,_凭依)->+操作(+描述结构,)...

->的(_凭依,结构)...
->的(结构,入口)=>条目(入口,)...
=>+设置函数(条目,_凭依)->+的(+操作,+设置函数)
"(,)
的#11""(结构变换#8,库#12)
库#12"

设置函数:...

"(,)
的#13""(库#12,设置函数#14)
设置函数#14"\"\"\"
描述结构:...
库:...

\"\"\"

+设置函数(_条目,_凭依)->+[del](,+设置函数)...
->的(设置函数,描述结构)->的(设置函数,库)...

->+[文本结构_插入尾部](_凭依,+节点)->+[文本结构_插入](+节点,+序号)...
->+的(+节点,+序号)->+序号\"0\"...

->+[code]([想],描述结构)->[想](_条目,+节点)...
->操作([想],)->[]{
    []=>的(操作,_操作)->_操作(_主语,_宾语)->_主语->_宾语=>[说](,_操作)...
        ->的(库,_条目0)->_条目0->[eq](_条目0,_操作)...
        ->+[做](_主语,_宾语)->+[code](+[做],_条目0)
}


"(,)
的#15""(设置函数#14,描述结构#16)
描述结构#16"\"\"\"
情况0:...
单元0:...

\"\"\"
+描述结构(_条目,_节点)->+操作(+描述结构,)...

->情况(_条目,)->+[code]([想],情况0)...
    ->+[.]([想],+操作)->[想](情况,_节点)...

->+设置条目(_条目,_节点)->+的(+操作,+设置条目)


"(,)
的#17""(描述结构#16,情况0#18)
情况0#18"\"\"\"


\"\"\"
+情况0(情况,_节点)->.(+情况0,操作)...
->情况0->的(描述结构,情况0)->的(描述结构,单元0)...

->+[文本结构_插入尾部](_节点,+节点)...
->[投影](,+[文本结构_插入尾部])->[投影](,+节点)...

->的(_节点,序号)->+的(+节点,+序号)->+[文本结构_插入](+节点,+序号)...
->[投影](,+[文本结构_插入])->[投影](,+序号)...
->+[.]\"n\"([python],序号)->[python]\"
state=True
ans=int(n[0]-1)
\"(Python,+序号)...

->单元(情况,)->+[code]([想],单元0)...
    ->+[.]([想],操作)->[想](单元,+节点)...
->[]{
    []=>情况#1(情况,)=>+[code]([想]#1,情况0)...
        ->+[.]([想]#1,操作)->[想]#1(情况#1,_节点)
}...

->+设置情况(情况,+节点)->+的(操作,+设置情况)


"(,)
的#19""(描述结构#16,单元0#20)
单元0#20"\"\"\"


\"\"\"
+单元0(单元,_节点)->.(+单元0,操作)...
->单元0->的(描述结构,单元0)->的(描述结构,情况0)...

->+[文本结构_插入](_节点,+单元)...
->[投影](,+[文本结构_插入])->[投影](,+单元)...

->的(_节点,序号)->+的(+单元,+序号)->+[文本结构_插入](+单元,+序号)...
->[投影](,+[文本结构_插入])->[投影](,+序号)...
->+[.]\"n\"([python],序号)->[python]\"
state=True
ans=int(n[0]+1)
\"(Python,+序号)...

->[]{
    []=>模块(单元,情况)->情况=>+[code]([想]#1,情况0)...
        ->+[.]([想]#1,操作)->[想]#1(情况,+单元)
}...
->[]{
    []=>单元#1(单元,)=>+[code]([想],单元0)...
        ->+[.]([想],操作)->[想](单元#1,+单元)
}...

->+设置单元(单元,+单元)->+的(操作,+设置单元)




"(,)
的#21""(设置函数#14,库#22)
库#22"

设置单元:...
设置情况:...
设置条目:...
将条目\"设置单元\"复制为条目\"设置条目\"


"(,)
的#23""(库#22,设置条目#24)
设置条目#24"\"\"\"
条目模板:...

\"\"\"
+设置条目(_单元,_节点)->+[del](,+设置条目)...
->的(设置条目,条目模板)...

->内容(_单元,)...
->+[模板文本](条目模板,_节点)->+[.](+[模板文本],内容)...

->[]{
    []:->顺序(_节点,)->+缩进\"    \"(_节点,顺序)->+的(_节点,+缩进),
    ->[]
}
"(,)
的#25""(设置条目#24,条目模板#26)
条目模板#26"
def parser_token_%内容(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]

%s
    list_pt+=list_new

    if state==False:
        print(\"%内容:\",state)
        return [False,i0,None]
    else:
        print(\"%内容:\",state,pt%序号.info())
        return [True,i,pt%序号]
"(,)
的#27""(库#22,设置情况#28)
设置情况#28"\"\"\"
情况模板:...
情况模板2:...

\"\"\"
+设置情况(_情况,_节点)->+[del](,+设置情况)...
->的(设置情况,情况模板)->的(设置情况,情况模板2)...

->_节点->+[模板文本](,_节点)...
->[]{
    []:->节点(,_节点)->+[code](+[模板文本],情况模板2)...
        ->[]{
            []:->插入(_节点,)->的(插入,单元)...
                ->+缩进\"    \"(插入,单元)->+的(_节点,+缩进),
            ->[]
        },
    ->+[code](+[模板文本],情况模板)
}


"(,)
的#29""(设置情况#28,情况模板#30)
情况模板#30"%单元
"(,)
的#31""(设置情况#28,情况模板2#32)
情况模板2#32"if state==False:
    i=i0
    list_new=[]
%单元
"(,)
的#33""(库#22,设置单元#34)
设置单元#34"\"\"\"
本体:...
本体2:...
本体3:...
增加:...
或许:...
单元模板:...
单元模板2:...
P代码:...

\"\"\"
+设置单元(_单元,_节点)->+[del](,+设置单元)...
->的(设置单元,本体)->的(设置单元,本体2)->的(设置单元,本体3)...
->的(设置单元,或许)->的(设置单元,增加)->的(设置单元,P代码)...
->的(设置单元,单元模板)->的(设置单元,单元模板2)...

->+[临时文本]#本体->[]{
    []:->引用(_单元,)->内容(_单元,)...
        ->+[模板文本](本体,+[临时文本]#本体)->+[.](+[模板文本],内容),
    ->标点(_单元,)->内容(_单元,)...
        ->+[模板文本](本体3,+[临时文本]#本体)->+[.](+[模板文本],内容),
    ->模块(_单元,)...
        ->+[模板文本](本体2,+[临时文本]#本体)
}...
->+[临时文本]#或许->[]{
    []:->或许#0(_单元,)->+[修改内容](或许,+[临时文本]#或许),  ->[]
}...

->插入(_节点,)->的(插入,序号)...
->[]{
    []:->模块(_单元,),
    ->+[python](Python,+[增加内容])->+[增加内容](,+[临时文本]#本体)...
        ->+[code](+[python],P代码)->+[.]\"n\"(+[python],序号)
}...

->+[增加内容](+[临时文本]#或许,+[临时文本]#本体)...

->+[模板文本](,_节点)...
->+[.]\"本体\"(+[模板文本],+[临时文本]#本体)...
->[]{
    []:->的(插入,单元)->单元->+[code](+[模板文本],单元模板2)...
        ->+缩进\"    \"(插入,单元)->+的(单元,+缩进),
    ->+[code](+[模板文本],单元模板)
}...

->[]{
    []:->标点(_单元,)->+[增加内容](增加,_节点),
    ->[]
}

"(,)
的#35""(设置单元#34,单元模板#36)
单元模板#36"%本体"(,)
的#37""(设置单元#34,单元模板2#38)
单元模板2#38"%本体
if state==True:
%单元"(,)
的#39""(设置单元#34,本体#40)
本体#40"[state,i,pt%序号]=parser_token_%内容(code,i,list_new)"(,)
的#41""(设置单元#34,本体2#42)
本体2#42"%s"(,)
的#43""(设置单元#34,本体3#44)
本体3#44"[state,i,text]=word_pat_token(code,i,'%内容')
pt%序号=NetP('节点',text)"(,)
的#45""(设置单元#34,或许#46)
或许#46"
state=True"(,)
的#47""(设置单元#34,P代码#48)
P代码#48"\"\"\"
print(\"%或许\")

\"\"\"

ans=text_may
if n[0]>0:
    ans=\"\"\"
if state==True:
    pt%d.con(pt%d,0)%s\"\"\"%(n[0],n[0]-1,text_may)


"(,)
的#49""(设置单元#34,增加#50)
增加#50"
if state==True:
    list_new.append(pt%序号)"(,)
的#51""(降临规则#4,生成代码#52)
生成代码#52"\"\"\"
模板:...

\"\"\"
+生成代码(_媒介,_凭依)->+[del](,+生成代码)...
->的(生成代码,模板)...

->+[标题](_凭依,)->的(_凭依,结构)->的(结构,入口)...
->条目(入口,)->内容(条目,)...
->+[模板文本](模板,_凭依)...
->+[.](+[模板文本],+[标题])->+[.]\"条目\"(+[模板文本],内容)...

->+[结构转文本](_凭依,_凭依)...
->+[删除结构](,_凭依)



"(,)
的#53""(生成代码#52,模板#54)
模板#54"\"\"\"
+[P函数](,%[标题])

\"\"\"

import re
from body.bone import NetP
from tools import tools_basic

def word_pat_token(code,i,pat):
    text=''
    try:
        a=re.match(pat,code[i:])
        if a==None:
            state=False
        else:
            di=a.span()[1]
            output_txt=code[i:i+di]
            i+=di
            state=True
            text=output_txt
    except:
        state=False
    
    return [state,i,text]

%s

def parser_text2pts(code):
    list_pt=[]
    [state,i,pt]=parser_token_%条目(code,0,list_pt)
    if state==False:
        return ''
    text=tools_basic.writeStdCode([],list_pt)
    return text

text=parser_text2pts('A:B')
print(text)

"(,)

## end
#1187, 195:
"""
条目模板:...

"""
+设置条目(_单元,_节点)->+[del](,+设置条目)...
->的(设置条目,条目模板)...

->_单元(,内容)...
->+[模板文本](条目模板,_节点)->+[.](+[模板文本],内容)...

->[]{
    []:->顺序(_节点,)->+缩进"    "(_节点,顺序)->+的(_节点,+缩进),
    ->[]
}

## end
#1189, 455:
"""
情况模板:...
情况模板2:...
P代码:...

保存:...

"""
+设置情况(_情况,_节点)->+[del](,+设置情况)...
->的(设置情况,情况模板)->的(设置情况,情况模板2)...
->的(设置情况,P代码)...

->_节点->[]{
    []:->节点(,_节点)->插入(_节点,)->的(插入,序号)...
        ->+[python](Python,_节点)->+[code](+[python],P代码)...
        ->+[.]"n_pt"(+[python],序号)...
        ->[]{
            []:->插入(_节点,)->的(插入,单元)...
                ->+缩进"    "(插入,单元)->+的(_节点,+缩进),
            ->[]
        },
    ->+[模板文本](,_节点)->+[code](+[模板文本],情况模板)
}



## end
#1190, 2013:
"""
本体:...
本体2:...
本体2a:...
本体3:...
新建1:...
新建2:...
P代码(Python):...
或许_开头:...
或许_结尾:...
或许_补充(Python):...
(我不记得这个有什么用了, 暂时注释掉)
(可能是用来传递代表节点)
单元模板:...
单元模板2:...
增加:...
增加2:...
节点

"""
+设置单元(_单元,_节点)->+[del](,+设置单元)...
->的(设置单元,本体)->的(设置单元,本体3)...
->的(设置单元,本体2)->的(设置单元,本体2a)...
->的(设置单元,或许_开头)->的(设置单元,或许_结尾)->的(设置单元,或许_补充)...
->的(设置单元,P代码)...
->的(设置单元,单元模板)->的(设置单元,单元模板2)...
->的(设置单元,增加)->的(设置单元,增加2)...
->的(设置单元,新建1)->的(设置单元,新建2)...

->_单元(,_类型)->_类型(,)...
->+[临时文本]#本体->[]{
    []:->[is](_类型,引用)->引用(,内容)...
        ->+[模板文本](本体,+[临时文本]#本体)->+[.](+[模板文本],内容),
    ->[is](_类型,标点)->标点(,标点#1)...
        ->+[模板文本](本体3,+[临时文本]#本体)->+[.]"内容"(+[模板文本],标点#1),
    ->[is](_类型,模块)->模块->或许(模块,)...
        ->+[模板文本](本体2a,+[临时文本]#本体),
    ->[is](_类型,模块#2)->模块#2(,)...
        ->+[模板文本](本体2,+[临时文本]#本体)
}...
->[]{
    []:->节点(_类型,)->[]{
        []:->[is](_类型,标点)->标点->+[增加内容](新建2,+[临时文本]#本体),
        ->+[增加内容](新建1,+[临时文本]#本体)
    }, ->[]
}...

->插入(_节点,)->的(插入,序号)...

->+[临时文本]#或许1->+[临时文本]#或许2->+[临时文本]#或许3(,)...
->Python->[]{
    []:->或许#0(_类型,)->+[修改内容](或许_开头,+[临时文本]#或许1)...
        ->+[修改内容](或许_结尾,+[临时文本]#或许2)...
        ->[]{
            []:->节点(_类型,)->+[python](Python,+[临时文本]#或许3)...
                ->+[code](+[python],或许_补充)...
                ->+[.]"n"(+[python],序号)->+[o]"text_out"(+[python],+[增加内容])...
                ->+[增加内容](,+[临时文本]#或许2),
            ->[]
        }, ->[]
}...
->[]{
    []:->[is](_类型,模块)->模块,
    ->[]{[]:->节点(_类型,),->[is](_类型,引用)->引用}...
        ->+[python](Python,+[增加内容])->+[增加内容](,+[临时文本]#本体)...
        ->+[code](+[python],P代码)->+[.]"n"(+[python],序号),
    ->[]
}...

->+[增加内容2](+[临时文本]#或许1,+[临时文本]#本体)...
->+[增加内容](+[临时文本]#或许2,+[临时文本]#本体)...

->+[模板文本](,_节点)...
->+[.]"本体"(+[模板文本],+[临时文本]#本体)...
->[]{
    []:->的(插入,单元)->单元->+[code](+[模板文本],单元模板2)...
        ->+缩进"    "(插入,单元)->+的(单元,+缩进)...
        ->+[增加内容](+[临时文本]#或许3,_节点),
    ->+[code](+[模板文本],单元模板)
}...

->[]{
    []:->节点(_类型,)->[]{
        []:->或许#0(_类型,)->+[增加内容](增加2,_节点),
        ->+[增加内容](增加,_节点)
    },
    ->[]
}


## end
#1193, 325:

def parser_token_%内容(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

%s

    if state==False:
        print("%内容:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("%内容:",state,pt%序号.info())
        return [True,i,pt%序号]

## end
#1195, 3:
%本体
## end
#1197, 23:
%本体
if state==True:
%单元
## end
#1199, 49:
[state,i,pt%序号]=parser_token_%内容(code,i,list_new)
## end
#1201, 33:
i%序号=i
list_new%序号=list_new[:]
%s
## end
#1203, 44:
[state,i,text]=word_pat_token(code,i,r'%内容')
## end
#1205, 131:

if state==False:
    i=i%序号
    list_new=list_new%序号
    state=True
    state%序号=False
# else:
#     list_new=list_new%序号+list_new
## end
#1207, 4:
%单元

## end
#1209, 48:
if state==False:
    i=i%序号
    list_new=[]
%单元

## end
#1211, 784:
"""
+[P函数](,%[标题])
print('2'.replace('2','333'))

"""

import re
from body.bone import NetP
from tools import tools_basic

def word_pat_token(code,i,pat):
    text=''

#    pat=pat.replace('\\','\\\\')
    a=re.match(pat,code[i:])
    if a==None:
        state=False
    else:
        di=a.span()[1]
        output_txt=code[i:i+di]
        i+=di
        state=True
        text=output_txt
    
    return [state,i,text]

%s

def parser_text2pts(code):
    list_pt0=[]
    [state,i,pt]=parser_token_%条目(code,0,list_pt0)
    list_pt=[]
    for pt in list_pt0:
        if pt!=None:
                list_pt.append(pt)
    if state==False:
        return ''
    text=tools_basic.writeStdCode([],list_pt)
    return text

#text=parser_text2pts('A:B')
#print(text)



"""
+[P函数](,%[标题])

"""
## end
#1213, 202:
"""
P代码:...

"""
+文本缩进(_缩进,_文本)->+[del](,+文本缩进)...
->的(文本缩进,P代码)...

->.(+文本缩进,_输出)...
->+[python](Python,_输出)->+[code](+[python],P代码)...
->+[s]"txt_head"(+[python],_缩进)->+[s]"txt_con"(+[python],_文本)



## end
#1215, 86:
"""
记住"Python"

"""
txt_con=txt_head+txt_con
ans=txt_con.replace('\n','\n'+txt_head)


## end
#1217, 160:
"""
print("%或许")
print(n,type_or)

"""

ans=""

if n[0]>0:
    ans+="""
if state==True:
    pt%d.con(pt%d,0)
else:
    pt%d=pt%d"""%(n[0],n[0]-1,n[0],n[0]-1)



## end
#1219, 43:

if state==True:
    list_new.append(pt%序号)
## end
#1221, 51:

if state==True:
    pt%序号=NetP("%标题").con(0,pt%序号)
## end
#1223, 23:

pt%序号=NetP("%标题",text)
## end
#1225, 74:
https://github.com/ssvivian/WebstersDictionary/blob/master/dictionary.json
## end
#1227, 1050:
"""
Nini, 打开动词(库)
增加:...
文本缩进:...
+[新建阅读窗口](,增加)

P代码:...

保存:...
(+[修改内容]的效果不太稳定, 改成+[模板文本])

"""
+结构转文本(_结构,_输出)->+[del](,+结构转文本)...
->的(结构转文本,增加)->的(结构转文本,文本缩进)...
->的(结构转文本,P代码)...

->+[临时文本]#0->[]{
    []:->插入(_结构,)=>的(插入,_节点)->_节点=>+[结构转文本](_节点,_节点)...
        ->+[.](+[临时文本]#0,+[临时文本]#节点)...
        ->[标题](_节点,)->[m_text]([标题],+[.])...
        ->[]{
            []:->缩进(插入,_节点)->+[做](缩进,_节点)->+[code](+[做],文本缩进)...
                ->+[.](+[做],+[临时文本]#节点),
            ->+[修改内容](_节点,+[临时文本]#节点)
        },
    ->[]
}...

->+[模板文本](_结构,_输出)->[]{
    []=>.(+[临时文本]#0,_节点)->_节点=>+[.](+[模板文本],_节点)->[m_text](.,+[.])
}...

->+[临时文本]->[]{
    []:->顺序(_结构,)->的(顺序,_节点)->[]{[]=>_节点1(,_节点)->的(顺序,_节点1)}...
        ->+[做](_节点,+[临时文本])->+[code](+[做],增加)->+[.](+[做],顺序)...
        ->[]{
            []:->缩进(_结构,顺序)->+[做](缩进,+[临时文本])->+[code](+[做],文本缩进)...
                ->+[.](+[做],+[临时文本]),
            ->[]
        },
    ->[]
}...

->+[python](Python,_输出)->+[code](+[python],P代码)...
->+[s]"text_all"(+[python],_输出)->+[s]"text_in"(+[python],+[临时文本])


## end
#1229, 157:
"""
记住"Python"
print(text_all)
print("%s" in text_all)

"""

if "%s" not in text_all:
    ans=text_all+text_in
else:
    ans=text_all.replace('%s',text_in)


## end
#1231, 59:
i%序号=i
state%序号=True
list_new%序号=list_new[:]
# list_new=[]

## end
#1234, 953:
"""
模板1:...
模板2:...
模板3:...

"""
+例句转句子(,_输出)->+[del](,+例句转句子)...
->的(例句转句子,模板1)->的(例句转句子,模板2)->的(例句转句子,模板3)...

->[m_text](模板1,+结构)...
->."变量3"(+例句转句子,_变量3)->[m_text](_变量3,+变量3)...
->+[文本结构_插入](+结构,+变量3)...

->+[文本结构_插入](+结构,+头部)...
->[]{
    []:->+[文本结构_插入](+头部,+枚举)->+[修改内容](模板2,+头部)->[]{
        []->."变量1"(+例句转句子,_变量0)->_变量0->[m_text](_变量0,+节点)...
        ->+顺序","(+枚举,)->+的(+枚举,+顺序)->+[文本结构_插入尾部](+枚举,+节点)...
        =>."变量1"(+例句转句子,_变量)->_变量{[]=>[is](_变量,_变量0)}...
            =>+[文本结构_插入尾部](+枚举,+节点#1)->[m_text](_变量,+节点#1)
    },
    ->[]
}...

->+[文本结构_插入](+结构,+尾部)...
->[]{
    []:->+[文本结构_插入](+尾部,+枚举)->+[修改内容](模板3,+尾部)->[]{
        []->."变量4"(+例句转句子,_变量0)->_变量0->[m_text](_变量0,+节点)...
        ->+顺序","(+枚举,)->+的(+枚举,+顺序)->+[文本结构_插入尾部](+枚举,+节点)...
        =>."变量4"(+例句转句子,_变量)->_变量{[]=>[is](_变量,_变量0)}...
            =>+[文本结构_插入尾部](+枚举,+节点#1)->[m_text](_变量,+节点#1)
    },
    ->[]
}...

->+[结构转文本](+结构,_输出)...
->+[删除结构](,+结构)->+[del](,+结构)




## end
#1236, 12:
%头部计算%变量3%尾部
## end
#1238, 7:
根据%枚举, 
## end
#1240, 11:
, 同时也能得到%枚举
## end
#1242, 12:
"""
例句库

"""
## end
#1244, 22:


召唤规则:...
降临规则:...



## end
#1246, 275:
"""


"""

+召唤规则(_媒介,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_凭依)...

->[==]"生成例句代码"(,召唤星辰)...
    ->+生成代码(_媒介,_凭依)->+的(操作,+生成代码)...
    ->+整理模板(_媒介,_凭依)->+的(操作,+整理模板)...
    ->+结构变换(_媒介,_凭依)->+的(操作,+结构变换)...
    ->+设置变量(_媒介,_凭依)->+的(操作,+设置变量)...
    ->+生成结构(_媒介,_凭依)->+的(操作,+生成结构)




## end
#1248, 49:


生成结构:...
设置变量:...
结构变换:...
整理模板:...
生成代码:...



## end
#1250, 270:
"""
P代码:...
P代码2:...

"""
+生成结构(_媒介,_凭依)->+[del](,+生成结构)...
->的(生成结构,P代码)->的(生成结构,P代码2)...

->+的(_凭依,+结构)...
->+[python]#0(Python,)->+[code](+[python]#0,P代码)...
->+[python]#1(Python,+结构)->+[code](+[python]#1,P代码2)...
->+[.]"code"(+[python]#1,_媒介)...
->+[导入节点](+结构,+结构)


## end
#1252, 315:
"""
描述结构:...
库:...
模板:...
+[新建阅读窗口](,库)

"""

+结构变换(_媒介,_凭依)->+[del](,+结构变换)...
->的(结构变换,模板)->的(结构变换,库)->的(库,句子模块)...

->的(_凭依,结构)->的(结构,起点)->起点(,_起点)->变量(,起点)...
->+的(_凭依,+模板库)...

->+[模板文本](模板,_凭依)->+[.]"句子0"(+[模板文本],变量)...

->+[文本结构_插入](_凭依,+句子模块)...
->+[做](_起点,+句子模块)->+[.]"凭依"(+[做],_凭依)->+[code](+[做],句子模块)




## end
#1254, 110:
"""
模板:...
->的(生成代码,模板)...

"""
+生成代码(_媒介,_凭依)->+[del](,+生成代码)...

->+[结构转文本](_凭依,_凭依)...
->+[删除结构](,_凭依)





## end
#1256, 5372:
"""
+[P函数](,P代码)
print('2'.replace('2','333'))

"""

import re
from body.bone import NetP
from tools import tools_basic

def word_pat_token(code,i,pat):
    text=''

#    pat=pat.replace('\\','\\\\')
    a=re.match(pat,code[i:])
    if a==None:
        state=False
    else:
        di=a.span()[1]
        output_txt=code[i:i+di]
        i+=di
        state=True
        text=output_txt
    
    return [state,i,text]


def parser_token_标点(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]

    [state,i,text]=word_pat_token(code,i,r'[\w\d, ]+')
    pt0=NetP("标点",text)
    if state==True:
        list_new.append(pt0)
    
    list_pt+=list_new

    if state==False:
        print("标点:",state)
        return [False,i0,None]
    else:
        print("标点:",state,pt0.info())
        return [True,i,pt0]

def parser_token_单词(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]

    [state,i,text]=word_pat_token(code,i,r'\[[\w\d]+\]')
    pt0=NetP("单词",text)
    if state==True:
        list_new.append(pt0)
    
    list_pt+=list_new

    if state==False:
        print("单词:",state)
        return [False,i0,None]
    else:
        print("单词:",state,pt0.info())
        return [True,i,pt0]

def parser_token_单元(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]

    [state,i,pt0]=parser_token_单词(code,i,list_new)
    if state==False:
        i=i0
        list_new=[]
        [state,i,pt0]=parser_token_标点(code,i,list_new)
    if state==False:
        i=i0
        list_new=[]
        [state,i,text]=word_pat_token(code,i,r'\(')
        if state==True:
            [state,i,pt0]=parser_token_句子(code,i,list_new)
            if state==True:
                pt0=NetP("句子").con(0,pt0)
            if state==True:
                [state,i,text]=word_pat_token(code,i,r'\)')
            if state==True:
                list_new.append(pt0)
    
    if state==True:
        i1=i
        list_new1=list_new
        list_new=[]
        [state,i,text]=word_pat_token(code,i,r'\?')
        pt1=NetP("或许",text)
        if state==True:
            pt1.con(pt0,0)
        if state==True:
            list_new.append(pt1)
        if state==False:
            i=i1
            list_new=list_new1
            state=True
        else:
            list_new=list_new1+list_new
    
    list_pt+=list_new

    if state==False:
        print("单元:",state)
        return [False,i0,None]
    else:
        print("单元:",state,pt0.info())
        return [True,i,pt0]

def parser_token_短语(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]

    [state,i,pt0]=parser_token_单元(code,i,list_new)
    if state==True:
        i1=i
        list_new1=list_new
        list_new=[]
        [state,i,pt1]=parser_token_标点(code,i,list_new)
        if state==True:
            pt1=NetP("关联1").con(0,pt1)
        if state==True:
            pt1.con(pt0,0)
        if state==True:
            [state,i,text]=word_pat_token(code,i,r'\.\.\.')
            if state==True:
                pt1.con(pt0,0)
            if state==True:
                [state,i,pt2]=parser_token_标点(code,i,list_new)
                if state==True:
                    pt2=NetP("关联2").con(0,pt2)
                if state==True:
                    pt2.con(pt1,0)
                if state==True:
                    [state,i,pt3]=parser_token_单元(code,i,list_new)
                    if state==True:
                        pt3.con(pt2,0)
                if state==True:
                    list_new.append(pt2)
        if state==True:
            list_new.append(pt1)
        
        if state==False:
            i=i1
            list_new=list_new1
            state=True
        else:
            list_new=list_new1+list_new
    
    list_pt+=list_new

    if state==False:
        print("短语:",state)
        return [False,i0,None]
    else:
        print("短语:",state,pt0.info())
        return [True,i,pt0]

def parser_token_句子(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]

    [state,i,pt0]=parser_token_短语(code,i,list_new)
    if state==True:
        i1=i
        list_new1=list_new
        list_new=[]
        [state,i,pt1]=parser_token_句子(code,i,list_new)
        if state==True:
            pt1.con(pt0,0)
        if state==False:
            i=i1
            list_new=list_new1
            state=True
        else:
            list_new=list_new1+list_new
    
    list_pt+=list_new

    if state==False:
        print("句子:",state)
        return [False,i0,None]
    else:
        print("句子:",state,pt0.info())
        return [True,i,pt0]

def parser_token_入口(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]

    [state,i,pt0]=parser_token_句子(code,i,list_new)
    if state==True:
        pt0=NetP("起点").con(0,pt0)
    if state==True:
        list_new.append(pt0)
    
    list_pt+=list_new

    if state==False:
        print("入口:",state)
        return [False,i0,None]
    else:
        print("入口:",state,pt0.info())
        return [True,i,pt0]


def parser_text2pts(code):
    list_pt=[]
    [state,i,pt]=parser_token_入口(code,0,list_pt)
    if state==False:
        return ''
    text=tools_basic.writeStdCode([],list_pt)
    return text

text=parser_text2pts('A:B')
print(text)



"""
+[P函数](,代码)

"""
## end
#1258, 38:
"""


"""

ans=parser_text2pts(code)


## end
#1260, 53:
"""


"""
+描述结构(_凭依,起点)->+操作(+描述结构,)...

->起点(,_起点)


## end
#1262, 29:


句子模块:...
+[新建阅读窗口](,句子模块)


## end
#1264, 375:
"""
模块:...

生成模板:...
生成代码:...

->+[文本结构_插入](_根,+句子模块#0)...

"""
+句子模块(_起点,_根)->+[del](,+句子模块)...
->的(句子模块,生成模板)->的(句子模块,生成代码)...

->."凭依"(+句子模块,_凭依)->_re"句子|起点"(,_起点)...

->的(_凭依,结构)->的(_凭依,模板库)...
->+的(模板库,+模板)->+模板(_re,)->+[做](_起点,+模板)...
    ->+[code](+[做],生成模板)->+[.]"结构"(+[做],结构)...
->+[做](_起点,_根)->+[code](+[做],生成代码)...
    ->+[.]"凭依"(+[做],_凭依)->+[.]"句子"(+[做],_re)





## end
#1266, 145:
"""
%模板库

"""
+例句(,_输出)->+[del](,+例句)...
%引用模板...

->+[修改内容](模板_%句子0,+%句子0)...

%句子模块

->+[结构转文本](+%句子0,_输出)...
->+[删除结构](,+%句子0)->+[del](,+结构)


## end
#1268, 69:
->."%变量"(+例句,_%变量)->[m_text](_%变量,+%变量)...
->+[文本结构_插入](+%句子,+%变量)



## end
#1270, 417:
"""


"""
+生成模板(_起点,模板)->+[del](,+生成模板)...

->."结构"(+生成模板,结构)...
->[]{
    []:->[is](_起点,标点)->标点->+[增加内容](标点,模板),
    ->[is](_起点,单词)->单词->[]{
        []:->关联1(单词,)->+[增加内容]"%枚举"(,模板),
        ->+[增加内容]"%"(单词,模板)
    },
    ->[is](_起点,句子)->句子->+[增加内容]"%句子"(,模板),
    ->[]
}...
->[]{
    []:->关联1(_起点,),
    ->_re"单词|句子|标点"(_起点,)->的(结构,_re)...
        ->+[做](_re,模板)->+[code](+[做],生成模板)->+[.]"结构"(+[做],结构),
    ->[]
}


## end
#1272, 650:
"""
枚举模块:...
单词模块:...
句子模块:...

"""
+生成代码(_起点,_根)->+[del](,+生成代码)...
->的(生成代码,句子模块)->的(生成代码,枚举模块)->的(生成代码,单词模块)...

->."句子"(+生成代码,_句子)...
->."凭依"(+生成代码,_凭依)->的(_凭依,结构)...
->[]{
    []:->[is](_起点,单词)->单词->[]{
        []:->关联1(单词,)...
            ->+[做](单词,_根)->+[code](+[做],枚举模块)->+[.]"句子"(+[做],_句子),
        ->+[做](单词,_根)->+[code](+[做],单词模块)->+[.]"句子"(+[做],_句子)
    },
    ->[is](_起点,句子)->+[做](句子,_根)...
        ->+[code](+[做],句子模块)->+[.]"凭依"(+[做],_凭依)->+[.]"句子"(+[做],_句子),
    ->[]
}...
->[]{
    []:->关联1(_起点,),
    ->_re"单词|标点|句子"(_起点,)->的(结构,_re)->+[做](_re,_根)...
        ->+[code](+[做],生成代码)->+[.]"凭依"(+[做],_凭依)->+[.]"句子"(+[做],_句子),
    ->[]
}


## end
#1274, 233:
"""
模块:...

"""
+枚举模块(单词,_根)->+[del](,+枚举模块)...
->的(枚举模块,模块)...

->."句子"(+枚举模块,_句子)->变量(,_句子)...
->关联1(单词,标点)...

->+[文本结构_插入尾部](_根,+节点)...
->+[模板文本](模块,+节点)...
->+[.]"变量"(+[模板文本],单词)->+[.]"句子"(+[模板文本],变量)...
->+[.]"标点"(+[模板文本],标点)


## end
#1276, 191:
"""
模块:...

"""
+单词模块(单词,_根)->+[del](,+单词模块)...
->的(单词模块,模块)...

->."句子"(+单词模块,_句子)->变量(,_句子)...

->+[文本结构_插入尾部](_根,+节点)...
->+[模板文本](模块,+节点)...
->+[.]"变量"(+[模板文本],单词)->+[.]"句子"(+[模板文本],变量)


## end
#1278, 70:
->."%变量"(+例句,_%变量)->[m_text](_%变量,+%变量)...
->+[文本结构_插入](+%句子,+%变量)...

## end
#1280, 259:
->+[文本结构_插入](%句子,+枚举)->[]{
    []->."%变量"(+例句,_%变量0)->_%变量0->[m_text](_%变量0,+节点)...
    ->+顺序"%标点"(+枚举,)->+的(+枚举,+顺序)->+[文本结构_插入尾部](+枚举,+节点)...
    =>."%变量"(+例句,_%变量)->_%变量{[]=>[is](_%变量,_%变量0)}...
        =>+[文本结构_插入尾部](+枚举,+节点#1)->[m_text](_%变量,+节点#1)
}...

## end
#1281, 275:
"""


"""

+召唤规则(_媒介,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_凭依)...

->[==]"生成例句代码"(,召唤星辰)...
    ->+生成代码(_媒介,_凭依)->+的(操作,+生成代码)...
    ->+整理模板(_媒介,_凭依)->+的(操作,+整理模板)...
    ->+结构变换(_媒介,_凭依)->+的(操作,+结构变换)...
    ->+设置变量(_媒介,_凭依)->+的(操作,+设置变量)...
    ->+生成结构(_媒介,_凭依)->+的(操作,+生成结构)




## end
#1283, 12371:
生成例句代码#0"

召唤规则:...
降临规则:...


"(,)
的#1""(生成例句代码#0,召唤规则#2)
召唤规则#2"\"\"\"


\"\"\"

+召唤规则(_媒介,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_凭依)...

->[==]\"生成例句代码\"(,召唤星辰)...
    ->+生成代码(_媒介,_凭依)->+的(操作,+生成代码)...
    ->+整理模板(_媒介,_凭依)->+的(操作,+整理模板)...
    ->+结构变换(_媒介,_凭依)->+的(操作,+结构变换)...
    ->+设置变量(_媒介,_凭依)->+的(操作,+设置变量)...
    ->+生成结构(_媒介,_凭依)->+的(操作,+生成结构)



"(,)
的#3""(生成例句代码#0,降临规则#4)
降临规则#4"

生成结构:...
设置变量:...
结构变换:...
整理模板:...
生成代码:...


"(,)
的#5""(降临规则#4,生成结构#6)
生成结构#6"\"\"\"
P代码:...
P代码2:...

\"\"\"
+生成结构(_媒介,_凭依)->+[del](,+生成结构)...
->的(生成结构,P代码)->的(生成结构,P代码2)...

->+的(_凭依,+结构)...
->+[python]#0(Python,)->+[code](+[python]#0,P代码)...
->+[python]#1(Python,+结构)->+[code](+[python]#1,P代码2)...
->+[.]\"code\"(+[python]#1,_媒介)...
->+[导入节点](+结构,+结构)

"(,)
的#7""(生成结构#6,P代码#8)
P代码#8"\"\"\"
+[P函数](,P代码)
print('2'.replace('2','333'))

\"\"\"

import re
from body.bone import NetP
from tools import tools_basic

def word_pat_token(code,i,pat):
    text=''

#    pat=pat.replace('\\','\\\\')
    a=re.match(pat,code[i:])
    if a==None:
        state=False
    else:
        di=a.span()[1]
        output_txt=code[i:i+di]
        i+=di
        state=True
        text=output_txt
    
    return [state,i,text]


def parser_token_标点(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]

    [state,i,text]=word_pat_token(code,i,r'[\w\d, ]+')
    pt0=NetP(\"标点\",text)
    if state==True:
        list_new.append(pt0)
    
    list_pt+=list_new

    if state==False:
        print(\"标点:\",state)
        return [False,i0,None]
    else:
        print(\"标点:\",state,pt0.info())
        return [True,i,pt0]

def parser_token_单词(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]

    [state,i,text]=word_pat_token(code,i,r'\[[\w\d]+\]')
    pt0=NetP(\"单词\",text)
    if state==True:
        list_new.append(pt0)
    
    list_pt+=list_new

    if state==False:
        print(\"单词:\",state)
        return [False,i0,None]
    else:
        print(\"单词:\",state,pt0.info())
        return [True,i,pt0]

def parser_token_单元(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]

    [state,i,pt0]=parser_token_单词(code,i,list_new)
    if state==False:
        i=i0
        list_new=[]
        [state,i,pt0]=parser_token_标点(code,i,list_new)
    if state==False:
        i=i0
        list_new=[]
        [state,i,text]=word_pat_token(code,i,r'\(')
        if state==True:
            [state,i,pt0]=parser_token_句子(code,i,list_new)
            if state==True:
                pt0=NetP(\"句子\").con(0,pt0)
            if state==True:
                [state,i,text]=word_pat_token(code,i,r'\)')
            if state==True:
                list_new.append(pt0)
    
    if state==True:
        i1=i
        list_new1=list_new
        list_new=[]
        [state,i,text]=word_pat_token(code,i,r'\?')
        pt1=NetP(\"或许\",text)
        if state==True:
            pt1.con(pt0,0)
        if state==True:
            list_new.append(pt1)
        if state==False:
            i=i1
            list_new=list_new1
            state=True
        else:
            list_new=list_new1+list_new
    
    list_pt+=list_new

    if state==False:
        print(\"单元:\",state)
        return [False,i0,None]
    else:
        print(\"单元:\",state,pt0.info())
        return [True,i,pt0]

def parser_token_短语(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]

    [state,i,pt0]=parser_token_单元(code,i,list_new)
    if state==True:
        i1=i
        list_new1=list_new
        list_new=[]
        [state,i,pt1]=parser_token_标点(code,i,list_new)
        if state==True:
            pt1=NetP(\"关联1\").con(0,pt1)
        if state==True:
            pt1.con(pt0,0)
        if state==True:
            [state,i,text]=word_pat_token(code,i,r'\.\.\.')
            if state==True:
                pt1.con(pt0,0)
            if state==True:
                [state,i,pt2]=parser_token_标点(code,i,list_new)
                if state==True:
                    pt2=NetP(\"关联2\").con(0,pt2)
                if state==True:
                    pt2.con(pt1,0)
                if state==True:
                    [state,i,pt3]=parser_token_单元(code,i,list_new)
                    if state==True:
                        pt3.con(pt2,0)
                if state==True:
                    list_new.append(pt2)
        if state==True:
            list_new.append(pt1)
        
        if state==False:
            i=i1
            list_new=list_new1
            state=True
        else:
            list_new=list_new1+list_new
    
    list_pt+=list_new

    if state==False:
        print(\"短语:\",state)
        return [False,i0,None]
    else:
        print(\"短语:\",state,pt0.info())
        return [True,i,pt0]

def parser_token_句子(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]

    [state,i,pt0]=parser_token_短语(code,i,list_new)
    if state==True:
        i1=i
        list_new1=list_new
        list_new=[]
        [state,i,pt1]=parser_token_句子(code,i,list_new)
        if state==True:
            pt1.con(pt0,0)
        if state==False:
            i=i1
            list_new=list_new1
            state=True
        else:
            list_new=list_new1+list_new
    
    list_pt+=list_new

    if state==False:
        print(\"句子:\",state)
        return [False,i0,None]
    else:
        print(\"句子:\",state,pt0.info())
        return [True,i,pt0]

def parser_token_入口(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]

    [state,i,pt0]=parser_token_句子(code,i,list_new)
    if state==True:
        pt0=NetP(\"起点\").con(0,pt0)
    if state==True:
        list_new.append(pt0)
    
    list_pt+=list_new

    if state==False:
        print(\"入口:\",state)
        return [False,i0,None]
    else:
        print(\"入口:\",state,pt0.info())
        return [True,i,pt0]


def parser_text2pts(code):
    list_pt=[]
    [state,i,pt]=parser_token_入口(code,0,list_pt)
    if state==False:
        return ''
    text=tools_basic.writeStdCode([],list_pt)
    return text

text=parser_text2pts('A:B')
print(text)



\"\"\"
+[P函数](,代码)

\"\"\""(,)
的#9""(生成结构#6,P代码2#10)
P代码2#10"\"\"\"


\"\"\"

ans=parser_text2pts(code)

"(,)
的#11""(降临规则#4,结构变换#12)
结构变换#12"\"\"\"
描述结构:...
库:...
模板:...
+[新建阅读窗口](,库)

\"\"\"

+结构变换(_媒介,_凭依)->+[del](,+结构变换)...
->的(结构变换,模板)->的(结构变换,库)->的(库,句子模块)...

->的(_凭依,结构)->的(结构,起点)->起点(,_起点)->变量(,起点)...
->+的(_凭依,+模板库)...

->+[模板文本](模板,_凭依)->+[.]\"句子0\"(+[模板文本],变量)...

->+[文本结构_插入](_凭依,+句子模块)...
->+[做](_起点,+句子模块)->+[.]\"凭依\"(+[做],_凭依)->+[code](+[做],句子模块)



"(,)
的#13""(结构变换#12,描述结构#14)
描述结构#14"\"\"\"


\"\"\"
+描述结构(_凭依,起点)->+操作(+描述结构,)...

->起点(,_起点)

"(,)
的#15""(结构变换#12,库#16)
库#16"

句子模块:...
+[新建阅读窗口](,句子模块)

"(,)
的#17""(库#16,句子模块#18)
句子模块#18"\"\"\"
模块:...

生成模板:...
生成代码:...

->+[文本结构_插入](_根,+句子模块#0)...

\"\"\"
+句子模块(_起点,_根)->+[del](,+句子模块)...
->的(句子模块,生成模板)->的(句子模块,生成代码)...

->.\"凭依\"(+句子模块,_凭依)->_re\"句子|起点\"(,_起点)...

->的(_凭依,结构)->的(_凭依,模板库)...
->+的(模板库,+模板)->+模板(_re,)->+[做](_起点,+模板)...
    ->+[code](+[做],生成模板)->+[.]\"结构\"(+[做],结构)...
->+[做](_起点,_根)->+[code](+[做],生成代码)...
    ->+[.]\"凭依\"(+[做],_凭依)->+[.]\"句子\"(+[做],_re)




"(,)
的#19""(句子模块#18,模块#20)
模块#20"->.\"%变量\"(+例句,_%变量)->[m_text](_%变量,+%变量)...
->+[文本结构_插入](+%句子,+%变量)


"(,)
的#21""(句子模块#18,生成模板#22)
生成模板#22"\"\"\"


\"\"\"
+生成模板(_起点,模板)->+[del](,+生成模板)...

->.\"结构\"(+生成模板,结构)...
->[]{
    []:->[is](_起点,标点)->标点->+[增加内容](标点,模板),
    ->[is](_起点,单词)->单词->[]{
        []:->关联1(单词,)->+[增加内容]\"%枚举\"(,模板),
        ->+[增加内容]\"%\"(单词,模板)
    },
    ->[is](_起点,句子)->句子->+[增加内容]\"%句子\"(,模板),
    ->[]
}...
->[]{
    []:->关联1(_起点,),
    ->_re\"单词|句子|标点\"(_起点,)->的(结构,_re)...
        ->+[做](_re,模板)->+[code](+[做],生成模板)->+[.]\"结构\"(+[做],结构),
    ->[]
}

"(,)
的#23""(句子模块#18,生成代码#24)
生成代码#24"\"\"\"
枚举模块:...
单词模块:...
句子模块:...

\"\"\"
+生成代码(_起点,_根)->+[del](,+生成代码)...
->的(生成代码,句子模块)->的(生成代码,枚举模块)->的(生成代码,单词模块)...

->.\"句子\"(+生成代码,_句子)...
->.\"凭依\"(+生成代码,_凭依)->的(_凭依,结构)...
->[]{
    []:->[is](_起点,单词)->单词->[]{
        []:->关联1(单词,)...
            ->+[做](单词,_根)->+[code](+[做],枚举模块)->+[.]\"句子\"(+[做],_句子),
        ->+[做](单词,_根)->+[code](+[做],单词模块)->+[.]\"句子\"(+[做],_句子)
    },
    ->[is](_起点,句子)->+[做](句子,_根)...
        ->+[code](+[做],句子模块)->+[.]\"凭依\"(+[做],_凭依)->+[.]\"句子\"(+[做],_句子),
    ->[]
}...
->[]{
    []:->关联1(_起点,),
    ->_re\"单词|标点|句子\"(_起点,)->的(结构,_re)->+[做](_re,_根)...
        ->+[code](+[做],生成代码)->+[.]\"凭依\"(+[做],_凭依)->+[.]\"句子\"(+[做],_句子),
    ->[]
}

"(,)
的#25""(生成代码#24,枚举模块#26)
枚举模块#26"\"\"\"
模块:...

\"\"\"
+枚举模块(单词,_根)->+[del](,+枚举模块)...
->的(枚举模块,模块)...

->.\"句子\"(+枚举模块,_句子)->变量(,_句子)...
->关联1(单词,标点)...

->+[文本结构_插入尾部](_根,+节点)...
->+[模板文本](模块,+节点)...
->+[.]\"变量\"(+[模板文本],单词)->+[.]\"句子\"(+[模板文本],变量)...
->+[.]\"标点\"(+[模板文本],标点)

"(,)
的#27""(枚举模块#26,模块#28)
模块#28"->+[文本结构_插入](%句子,+枚举)->[]{
    []->.\"%变量\"(+例句,_%变量0)->_%变量0->[m_text](_%变量0,+节点)...
    ->+顺序\"%标点\"(+枚举,)->+的(+枚举,+顺序)->+[文本结构_插入尾部](+枚举,+节点)...
    =>.\"%变量\"(+例句,_%变量)->_%变量{[]=>[is](_%变量,_%变量0)}...
        =>+[文本结构_插入尾部](+枚举,+节点#1)->[m_text](_%变量,+节点#1)
}...
"(,)
的#29""(生成代码#24,单词模块#30)
单词模块#30"\"\"\"
模块:...

\"\"\"
+单词模块(单词,_根)->+[del](,+单词模块)...
->的(单词模块,模块)...

->.\"句子\"(+单词模块,_句子)->变量(,_句子)...

->+[文本结构_插入尾部](_根,+节点)...
->+[模板文本](模块,+节点)...
->+[.]\"变量\"(+[模板文本],单词)->+[.]\"句子\"(+[模板文本],变量)

"(,)
的#31""(单词模块#30,模块#32)
模块#32"->.\"%变量\"(+例句,_%变量)->[m_text](_%变量,+%变量)...
->+[文本结构_插入](+%句子,+%变量)...
"(,)
的#33""(生成代码#24,句子模块#34)
句子模块#34"\"\"\"
模块:...

\"\"\"
+句子模块(句子,_根)->+[del](,+句子模块)...
->的(句子模块,模块)->的(生成代码,句子模块)->的(句子模块#0,生成代码)...

->.\"句子\"(+句子模块,_句子0)->变量#0(,_句子0)...
->.\"凭依\"(+句子模块,_凭依)->句子(,_句子)->变量(,句子)...

->+[文本结构_插入尾部](_根,+节点)...
->+[模板文本](模块,+节点)...
->+[.]\"变量\"(+[模板文本],变量)->+[.]\"句子0\"(+[模板文本],变量#0)...

->+[文本结构_插入]\"    \"(+节点,+句子模板)->+句子模板\"[]\"...
->+[做](_句子,+句子模板)->+[code](+[做],句子模块#0)...
    ->+[.]\"凭依\"(+[做],_凭依)->+[.]\"句子\"(+[做],句子)


"(,)
的#35""(句子模块#34,模块#36)
模块#36"->+[文本结构_插入](+%句子0,+%变量)->+[修改内容](模板_%变量,+%变量)...
->[]{
%句子模板
    ->[]
}...
"(,)
的#37""(结构变换#12,模板#38)
模板#38"\"\"\"
%模板库

\"\"\"
+例句(,_输出)->+[del](,+例句)...
%引用模板

->+[修改内容](模板_%句子0,+%句子0)...

%句子模块

->+[结构转文本](+%句子0,_输出)...
->+[删除结构](,+%句子0)->+[del](,+结构)

"(,)
的#39""(降临规则#4,生成代码#40)
生成代码#40"\"\"\"
模板:...
->的(生成代码,模板)...

\"\"\"
+生成代码(_媒介,_凭依)->+[del](,+生成代码)...

->+[结构转文本](_凭依,_凭依)...
->+[删除结构](,_凭依)




"(,)
的#41""(降临规则#4,设置变量#42)
设置变量#42"\"\"\"
描述结构:...

\"\"\"

+设置变量(_题目,_代码)->+[del](,+设置变量)...
->的(设置变量,描述结构)...

->[]{
    []:->的(_代码,命名空间)->命名空间=>的(命名空间,_名字)=>+[del](,_名字),
    ->+的(_代码,+命名空间)
}->的(_代码,命名空间)->的(_代码,结构)...

->+[code]([想],描述结构)->[想](,结构)...

->操作([想],)...
->[]{
    []=>的(操作,_操作)->_操作(,_物体)->_物体(,)...
    =>+的(命名空间,+变量)->+变量(,_物体)->[m_text](_操作,+变量)
}


"(,)
的#43""(设置变量#42,描述结构#44)
描述结构#44"\"\"\"
P代码:...

\"\"\"

+描述结构(,结构)->+操作(+描述结构,)...
->的(描述结构,P代码)...

->[python]\"var_num={}
state=True\"(Python,)...

->[]{
    []=>的(结构,_re)->_re\"句子|起点\"=>+变量名(,_re)->+的(+操作,+变量名)...
        ->[标题](_re,)->+[s]\"name\"([python]#0,[标题])...
        ->+[code]([python]#0,P代码)->[python]#0(Python,+变量名)
}


"(,)
的#45""(描述结构#44,P代码#46)
P代码#46"\"\"\"
记住\"Python\"
Nini, 打开公式分析器(文件)

a=re.search(\"r\",\"ere\")
print(a)
print(re.match(\"[a-zA-Z_0-9]+\",\"212\")==None)

\"\"\"

import re

print(name,var_num)

type=\"varb\"
if \"句子\" in name:
    type=\"句子\"
elif \"起点\" in name:
    type=\"结构\"

n_v=var_num.get(type,0)+1
var_num.update({type:n_v})

ans=\"%s%d\"%(type,n_v)
# ans=\"%d\"%(n_v)
"(,)
的#47""(降临规则#4,整理模板#48)
整理模板#48"\"\"\"
生成模板库:...
生成引用:...
将条目\"生成模板库\"复制为条目\"生成引用\"

\"\"\"
+整理模板(_媒介,_凭依)->+[del](,+整理模板)...
->的(整理模板,生成模板库)->的(整理模板,生成引用)...

->的(_凭依,模板库)...
->+[文本结构_插入](_凭依,+模板库)...
->+[做](模板库,+模板库)->+[code](+[做],生成模板库)...
->+[文本结构_插入](_凭依,+引用模板)...
->+[做](模板库,+引用模板)->+[code](+[做],生成引用)


"(,)
的#49""(整理模板#48,生成引用#50)
生成引用#50"\"\"\"
模板0:...

\"\"\"
+生成引用(_输入,_输出)->+[del](,+生成引用)...
->的(生成引用,模板0)...

->[]{
    []=>的(_输入,模板)->模板(_句子,)->_句子=>变量(,_句子)...
        ->+[模板文本](模板0,+[增加内容])->+[增加内容](,_输出)...
        ->+[.](+[模板文本],变量)
}



"(,)
的#51""(生成引用#50,模板0#52)
模板0#52"->的(例句,模板_%变量)"(,)
的#53""(整理模板#48,生成模板库#54)
生成模板库#54"\"\"\"
模板0:模板_%变量::%模板

\"\"\"
+生成模板库(_输入,_输出)->+[del](,+生成模板库)...
->的(生成模板库,模板0)...

->[]{
    []=>的(_输入,模板)->模板(_句子,)->_句子=>变量(,_句子)...
        ->+[模板文本](模板0,+[增加内容])->+[增加内容](,_输出)...
        ->+[.](+[模板文本],变量)->+[.](+[模板文本],模板)
}



"(,)
的#55""(生成模板库#54,模板0#56)
模板0#56"模板_%变量::%模板
"(,)

## end
#1285, 405:
"""
模块:...

"""
+句子模块(句子,_根)->+[del](,+句子模块)...
->的(句子模块,模块)->的(生成代码,句子模块)->的(句子模块#0,生成代码)...

->."句子"(+句子模块,_句子0)->变量#0(,_句子0)...
->."凭依"(+句子模块,_凭依)->句子(,_句子)->变量(,句子)...

->+[文本结构_插入尾部](_根,+节点)...
->+[模板文本](模块,+节点)...
->+[.]"变量"(+[模板文本],变量)->+[.]"句子0"(+[模板文本],变量#0)...

->+[文本结构_插入]"    "(+节点,+句子模板)->+句子模板"[]"...
->+[做](_句子,+句子模板)->+[code](+[做],句子模块#0)...
    ->+[.]"凭依"(+[做],_凭依)->+[.]"句子"(+[做],句子)



## end
#1287, 76:
->+[文本结构_插入](+%句子0,+%变量)->+[修改内容](模板_%变量,+%变量)...
->[]{
%句子模板
    ->[]
}...

## end
#1289, 330:
"""
描述结构:...

"""

+设置变量(_题目,_代码)->+[del](,+设置变量)...
->的(设置变量,描述结构)...

->[]{
    []:->的(_代码,命名空间)->命名空间=>的(命名空间,_名字)=>+[del](,_名字),
    ->+的(_代码,+命名空间)
}->的(_代码,命名空间)->的(_代码,结构)...

->+[code]([想],描述结构)->[想](,结构)...

->操作([想],)...
->[]{
    []=>的(操作,_操作)->_操作(,_物体)->_物体(,)...
    =>+的(命名空间,+变量)->+变量(,_物体)->[m_text](_操作,+变量)
}



## end
#1291, 291:
"""
P代码:...

"""

+描述结构(,结构)->+操作(+描述结构,)...
->的(描述结构,P代码)...

->[python]"var_num={}
state=True"(Python,)...

->[]{
    []=>的(结构,_re)->_re"句子|起点"=>+变量名(,_re)->+的(+操作,+变量名)...
        ->[标题](_re,)->+[s]"name"([python]#0,[标题])...
        ->+[code]([python]#0,P代码)->[python]#0(Python,+变量名)
}



## end
#1293, 319:
"""
记住"Python"
Nini, 打开公式分析器(文件)

a=re.search("r","ere")
print(a)
print(re.match("[a-zA-Z_0-9]+","212")==None)

"""

import re

print(name,var_num)

type="varb"
if "句子" in name:
    type="句子"
elif "起点" in name:
    type="结构"

n_v=var_num.get(type,0)+1
var_num.update({type:n_v})

ans="%s%d"%(type,n_v)
# ans="%d"%(n_v)

## end
#1295, 268:
"""
生成模板库:...
生成引用:...
将条目"生成模板库"复制为条目"生成引用"

"""
+整理模板(_媒介,_凭依)->+[del](,+整理模板)...
->的(整理模板,生成模板库)->的(整理模板,生成引用)...

->的(_凭依,模板库)...
->+[文本结构_插入](_凭依,+模板库)...
->+[做](模板库,+模板库)->+[code](+[做],生成模板库)...
->+[文本结构_插入](_凭依,+引用模板)...
->+[做](模板库,+引用模板)->+[code](+[做],生成引用)



## end
#1297, 202:
"""
模板0:...

"""
+生成引用(_输入,_输出)->+[del](,+生成引用)...
->的(生成引用,模板0)...

->[]{
    []=>的(_输入,模板)->模板(_句子,)->_句子=>变量(,_句子)...
        ->+[模板文本](模板0,+[增加内容])->+[增加内容](,_输出)...
        ->+[.](+[模板文本],变量)
}




## end
#1299, 14:
->的(例句,模板_%变量)
## end
#1300, 12:
模板_%变量::%模板

## end
#1302, 231:
"""
模板0:模板_%变量::%模板

"""
+生成模板库(_输入,_输出)->+[del](,+生成模板库)...
->的(生成模板库,模板0)...

->[]{
    []=>的(_输入,模板)->模板(_句子,)->_句子=>变量(,_句子)...
        ->+[模板文本](模板0,+[增加内容])->+[增加内容](,_输出)...
        ->+[.](+[模板文本],变量)->+[.](+[模板文本],模板)
}




## end
#1305, 242:
"""
print("%或许")
print(n,type_or)
保存:...

"""

ans="""
#if state%%序号==False:
#    try:
#        pt%d=pt%d
#    except:
#        pt%d=None"""%(n[0],n[0]+1,n[0])

if n[0]>0:
    text_out="""
    pt%d=pt%d"""%(n[0],n[0]-1)
else:
    text_out=""

## end
#1307, 46:

if state%序号==True:
    list_new.append(pt%序号)
## end
#1309, 34:
https://texdoc.org/serve/siunitx/0
## end
#1312, 242:
"""


"""
+显示parser结构_代码(_parser,_结构)->+[del](,+显示parser结构_代码)...

->[解析Parser结构_代码](,_parser)...
->+[删除结构](,_结构)...
->+[导入节点](,_结构)->[m_text]([解析Parser结构_代码],+[导入节点])...
->+[修改内容](,_结构)->[m_text]([解析Parser结构_代码],+[修改内容])...
->+[显示星图](,_结构)


## end
#1314, 102:
"""


"""

ans="""if state==False:
    i=i%d
    list_new=list_new%d
%%单元
"""%(n_pt[0]+1,n_pt[0]+1)



## end
#1316, 358:
"""
情况模板:...
情况模板2:...
P代码:...

"""
+设置情况(_情况,_节点)->+[del](,+设置情况)...
->的(设置情况,情况模板)->的(设置情况,情况模板2)...
->的(设置情况,P代码)...

->_节点->+[模板文本](,_节点)...
->[]{
    []:->节点(,_节点)->+[code](+[模板文本],情况模板2)...
        ->[]{
            []:->插入(_节点,)->的(插入,单元)...
                ->+缩进"    "(插入,单元)->+的(_节点,+缩进),
            ->[]
        },
    ->+[code](+[模板文本],情况模板)
}



## end
#1318, 2:
%s
## end
#1320, 109:

\begin{figure}[%位置]
\includegraphics[width=0.45\textwidth]{%名字}
\caption{\label{fig:%名字}%图例}
\end{figure}



## end
#1321, 93:
"""
记住"Python"

"""

fig_type=source_dir.split('.')[-1]
ans='./res/'+fig_name+'.'+fig_type



## end
#1322, 104:

\begin{figure*}
\includegraphics[width=0.9 \textwidth]{%名字}
\caption{\label{fig:%名字}%图例}
\end{figure*}

## end
#1326, 479:
"""
P代码:...
L模板:...
L模板2:...

"""

+图片结构(_节点,_内容)->+[del](,+图片结构)...
->的(图片结构,L模板)->的(图片结构,L模板2)->的(图片结构,P代码)...

->的(_节点,类型)->的(_节点,位置)...
->的(_节点,名字)->的(_节点,图例)->的(_节点,源地址)...
->的(_节点,目标地址)...
->+[python](Python,目标地址)->+[code](+[python],P代码)...
->+[.]"source_dir"(+[python],源地址)->+[.]"fig_name"(+[python],名字)...

->+[模板文本](,+[增加内容2])->+[增加内容2](,_内容)...
->+[.](+[模板文本],名字)->+[.](+[模板文本],图例)->+[.](+[模板文本],位置):

->[==]"normal"(,类型)->+[code](+[模板文本],L模板),
->+[code](+[模板文本],L模板2)

## end
#1329, 543:
"""
+[P函数](,测试)
Nini, 打开公式分析器(文件)

"""

list_lk=['a1','a2','c1']
paper_text="""
[a1,a2]
[1].
[c1],[c1]

"""

import re

link_pat='\[([a-zA-Z]+\d*)(, ?[a-zA-Z]+\d*)*\]'
i=0
out_text=''

while True:
    if i>=len(paper_text):
        break
    a=re.match(link_pat,paper_text[i:])
    if a!=None and a.group(1) in list_lk:
        new_text='\\cite{%s}'%(a.group()[1:-1])
        di0=a.span()[1]
        out_text+=new_text
        i+=di0-1
    else:
        out_text+=paper_text[i]

    i+=1

print(out_text)


"""
print(a.span())
+[P函数](,测试)

"""
## end
#1330, 890:
"""
+[P函数](,测试2)
print(list_lk)

"""

import re

paper_text="""
The algorithm of recovering complete electron trajectories from source to detector is schematically shown in Fig.[_setup1]. In Fig.[_setup1], 

"""

link_pat='([fF])ig.\[([a-zA-Z0-9_\.]+)\]'
link_pat2='Figure \[([a-zA-Z0-9_\.]+)\]'
i=0
out_text=''

while True:
    if i>=len(paper_text):
        break
    a=re.match(link_pat,paper_text[i:])
    a2=re.match(link_pat2,paper_text[i:])
    if a!=None and a.group(2) in list_lk:
        new_text='%sig.~\\ref{fig:%s}'%(a.group(1),a.group(2))
        di0=a.span()[1]
        out_text+=new_text
        i+=di0-1
    elif a2!=None and a2.group(1) in list_lk:
        new_text='Figure ~\\ref{fig:%s}'%(a2.group(1))
        di0=a.span()[1]
        out_text+=new_text
        i+=di0-1
    else:
        out_text+=paper_text[i]
    i+=1

ans=out_text

print(paper_text)
print(out_text)

## end
#1333, 734:
"""
记住"Python"
测试:...
测试2:...
print(new_text)
print(i)
print(paper_text)

"""

import re

link_pat='([fF])ig.\[([a-zA-Z0-9_\.]+)\]'
link_pat2='Figure \[([a-zA-Z0-9_\.]+)\]'
i=0
out_text=''

while True:
    if i>=len(paper_text):
        break
    a=re.match(link_pat,paper_text[i:])
    a2=re.match(link_pat2,paper_text[i:])
    if a!=None and a.group(2) in list_lk:
        new_text='%sig.~\\ref{fig:%s}'%(a.group(1),a.group(2))
        di0=a.span()[1]
        out_text+=new_text
        i+=di0-1
    elif a2!=None and a2.group(1) in list_lk:
        new_text='Figure~\\ref{fig:%s}'%(a2.group(1))
        di0=a2.span()[1]
        out_text+=new_text
        i+=di0-1
    else:
        out_text+=paper_text[i]
    i+=1

ans=out_text



## end
#1335, 394:
"""
P代码:...
print(list_lk)
print(paper_text)

"""

+整理图片引用(_媒介,_文本)->+[del](,+整理图片引用)...
->的(整理图片引用,P代码)...

->.(_媒介,_文章)...
->+[python]"list_lk=[]"(Python,)->[]{
    []=>的(_文章,_节点)->_节点->图片(_节点,)...
    =>+[标题](_节点,)->+[python]"list_lk.append(name)"(Python,)...
        ->+[s]"name"(+[python],+[标题])
}...

->+[python](Python,_文本)->+[code](+[python],P代码)...
->+[s]"paper_text"(+[python],_文本)



## end
#1337, 32:
<img src="%目标地址" height="200"/>

## end
#1338, 221:
"""
记住"Python"

"""

fig_type=source_dir.split('.')[-1]

if source_dir.startswith("http://"):
    ans=source_dir
elif source_dir.startswith("https://"):
    ans=source_dir
else:
    ans="./res/%s.%s"%(fig_name,fig_type)


## end
#1339, 32:
<img src="%目标地址" width="100%"/>

## end
#1343, 550:
"""
P代码:...
L模板:...
L模板2:...

"""

+图片结构(_节点,_内容)->+[del](,+图片结构)...
->的(图片结构,L模板)->的(图片结构,L模板2)->的(图片结构,P代码)...

->."输出"(+图片结构,_输出)->的(_输出,地址)...

->的(_节点,类型)->的(_节点,位置)...
->的(_节点,名字)->的(_节点,图例)->的(_节点,源地址)...
->的(_节点,目标地址)...

->+[python](Python,目标地址)->+[code](+[python],P代码)...
->+[.]"source_dir"(+[python],源地址)->+[.]"fig_name"(+[python],名字)...
->+[.]"address"(+[python],地址)...

->+[模板文本](,+[增加内容2])->+[增加内容2](,_内容)...
->+[.](+[模板文本],目标地址)->+[.](+[模板文本],图例)->+[.](+[模板文本],位置):

->[==]"normal"(,类型)->+[code](+[模板文本],L模板),
->+[code](+[模板文本],L模板2)


## end
#1346, 648:
"""
记住"Python"
+[P函数](,P代码)

"""
import numpy as np
import re

rows=txt_in.split('\n')
txt_out=''
type_out=''
len_max=0

for row in rows:
    row0=re.sub('; *','',row)
    if row0=='':
        continue
    list_ele=re.split('[,] *',row0)

    len_max=np.max([len_max,len(list_ele)])

    if txt_out=='':
        for txt_ele in list_ele:
            txt_out+="\n\\textrm{%s}&"%(txt_ele)
        txt_out=txt_out[0:-1]
        txt_out+='\\\\\n\\colrule'
    else:
        for txt_ele in list_ele:
            txt_out+=" %s &"%(txt_ele)
        txt_out=txt_out[0:-1]
        txt_out+='\\\\\n'

for i in range(len_max):
    type_out+='c'

ans=txt_out



## end
#1348, 452:
"""
规则:...
P代码:...
P代码1:...
(默认函数)
P代码2:...
+[召唤星辰]"生成Parser代码"(规则,P代码)
+[新建阅读窗口](,规则)
+[新建阅读窗口](,P代码)
有什么

"""
+解析Parser结构_代码(,_parser)...
->的(解析Parser结构_代码,P代码)...
->的(解析Parser结构_代码,P代码1)->的(解析Parser结构_代码,P代码2)...

->[python]"state=True"(Python,)...
->+[code]([python]#a,P代码)->[python]#a(Python,)...
->+[code]([python]#1,P代码1)->[python]#1(Python,)...
->+[code]([python]#0,P代码2)->+[.]"code"([python]#0,_parser)...
->[python]#0(Python,+解析Parser结构_代码)


## end
#1350, 240:
入口:[目录]{起点}
目录:[规则] (\\n [目录])?
规则:[内容]{条目} : [模块]{定义}
模块:[语句]{情况} (\\\|\  [模块])?
语句:[单元]{单元} (\  [语句])?
单元:[单元分类] \\\?{或许}?
单元分类:(\\\[ [内容]{引用} \\\]| \\\( [模块]{模块} \\\)| [标点]{标点}) (\{ [内容]{节点} \})?
内容:\[\\w_\\d\]\+{内容}
标点:\[\\w_\\d\]\+{词语}
## end
#1352, 8854:
"""
+[P函数](,P代码)
print('2'.replace('2','333'))
内容

"""

import re
from body.bone import NetP
from tools import tools_basic

def word_pat_token(code,i,pat):
    text=''

#    pat=pat.replace('\\','\\\\')
    a=re.match(pat,code[i:])
    if a==None:
        state=False
    else:
        di=a.span()[1]
        output_txt=code[i:i+di]
        i+=di
        state=True
        text=output_txt
    
    return [state,i,text]


def parser_token_标点(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'[\w_\d]+')
    pt0=NetP("词语",text)
    if state==True:
        list_new.append(pt0)
    
    list_pt+=list_new

    if state==False:
        print("标点:",state)
        return [False,i0,None]
    else:
        print("标点:",state,pt0.info())
        return [True,i,pt0]

def parser_token_内容(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'[\w_\d]+')
    pt0=NetP("内容",text)
    if state==True:
        list_new.append(pt0)
    
    list_pt+=list_new

    if state==False:
        print("内容:",state)
        return [False,i0,None]
    else:
        print("内容:",state,pt0.info())
        return [True,i,pt0]

def parser_token_单元分类(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    i0=i
    list_new0=list_new[:]
    [state,i,text]=word_pat_token(code,i,r'\[')
    if state==True:
        [state,i,pt0]=parser_token_内容(code,i,list_new)
        if state==True:
            pt0=NetP("引用").con(0,pt0)
        if state==True:
            [state,i,text]=word_pat_token(code,i,r'\]')
        if state==True:
            list_new.append(pt0)
    if state==False:
        i=i0
        list_new=list_new0
        [state,i,text]=word_pat_token(code,i,r'\(')
        if state==True:
            [state,i,pt0]=parser_token_模块(code,i,list_new)
            if state==True:
                pt0=NetP("模块").con(0,pt0)
            if state==True:
                [state,i,text]=word_pat_token(code,i,r'\)')
            if state==True:
                list_new.append(pt0)
    if state==False:
        i=i0
        list_new=list_new0
        [state,i,pt0]=parser_token_标点(code,i,list_new)
        if state==True:
            pt0=NetP("标点").con(0,pt0)
        if state==True:
            list_new.append(pt0)
    
    if state==True:
        i1=i
        state1=True
        list_new1=list_new[:]
        # list_new=[]
        [state,i,text]=word_pat_token(code,i,r'{')
        if state==True:
            [state,i,pt1]=parser_token_内容(code,i,list_new)
            if state==True:
                pt1=NetP("节点").con(0,pt1)
            if state==True:
                pt1.con(pt0,0)
            else:
                pt1=pt0
            if state==True:
                [state,i,text]=word_pat_token(code,i,r'}')
            if state==True:
                list_new.append(pt1)
        
        if state==False:
            i=i1
            list_new=list_new1
            state=True
            state1=False
        # else:
        #     list_new=list_new1+list_new
    
    list_pt+=list_new

    if state==False:
        print("单元分类:",state)
        return [False,i0,None]
    else:
        print("单元分类:",state,pt0.info())
        return [True,i,pt0]

def parser_token_单元(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,pt0]=parser_token_单元分类(code,i,list_new)
    if state==True:
        i1=i
        state1=True
        list_new1=list_new[:]
        # list_new=[]
        [state,i,text]=word_pat_token(code,i,r'\?')
        pt1=NetP("或许",text)
        if state==True:
            pt1.con(pt0,0)
        else:
            pt1=pt0
        if state==False:
            i=i1
            list_new=list_new1
            state=True
            state1=False
        # else:
        #     list_new=list_new1+list_new
        if state1==True:
            list_new.append(pt1)
    
    list_pt+=list_new

    if state==False:
        print("单元:",state)
        return [False,i0,None]
    else:
        print("单元:",state,pt0.info())
        return [True,i,pt0]

def parser_token_语句(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,pt0]=parser_token_单元(code,i,list_new)
    if state==True:
        pt0=NetP("单元").con(0,pt0)
    if state==True:
        i1=i
        state1=True
        list_new1=list_new[:]
        # list_new=[]
        [state,i,text]=word_pat_token(code,i,r' ')
        if state==True:
            [state,i,pt1]=parser_token_语句(code,i,list_new)
            if state==True:
                pt1.con(pt0,0)
            else:
                pt1=pt0
        
        if state==False:
            i=i1
            list_new=list_new1
            state=True
            state1=False
        # else:
        #     list_new=list_new1+list_new
    if state==True:
        list_new.append(pt0)
    
    list_pt+=list_new

    if state==False:
        print("语句:",state)
        return [False,i0,None]
    else:
        print("语句:",state,pt0.info())
        return [True,i,pt0]

def parser_token_模块(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,pt0]=parser_token_语句(code,i,list_new)
    if state==True:
        pt0=NetP("情况").con(0,pt0)
    if state==True:
        i1=i
        state1=True
        list_new1=list_new[:]
        # list_new=[]
        [state,i,text]=word_pat_token(code,i,r'\| ')
        if state==True:
            [state,i,pt1]=parser_token_模块(code,i,list_new)
            if state==True:
                pt1.con(pt0,0)
            else:
                pt1=pt0
        
        if state==False:
            i=i1
            list_new=list_new1
            state=True
            state1=False
        # else:
        #     list_new=list_new1+list_new
    if state==True:
        list_new.append(pt0)
    
    list_pt+=list_new

    if state==False:
        print("模块:",state)
        return [False,i0,None]
    else:
        print("模块:",state,pt0.info())
        return [True,i,pt0]

def parser_token_规则(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,pt0]=parser_token_内容(code,i,list_new)
    if state==True:
        pt0=NetP("条目").con(0,pt0)
    if state==True:
        [state,i,text]=word_pat_token(code,i,r':')
        if state==True:
            [state,i,pt1]=parser_token_模块(code,i,list_new)
            if state==True:
                pt1=NetP("定义").con(0,pt1)
            if state==True:
                pt1.con(pt0,0)
            else:
                pt1=pt0
            if state==True:
                list_new.append(pt1)
    if state==True:
        list_new.append(pt0)
    
    list_pt+=list_new

    if state==False:
        print("规则:",state)
        return [False,i0,None]
    else:
        print("规则:",state,pt0.info())
        return [True,i,pt0]

def parser_token_目录(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,pt0]=parser_token_规则(code,i,list_new)
    if state==True:
        i1=i
        state1=True
        list_new1=list_new[:]
        # list_new=[]
        [state,i,text]=word_pat_token(code,i,r'\n')
        if state==True:
            [state,i,pt1]=parser_token_目录(code,i,list_new)
            if state==True:
                pt1.con(pt0,0)
            else:
                pt1=pt0
        
        if state==False:
            i=i1
            list_new=list_new1
            state=True
            state1=False
        # else:
        #     list_new=list_new1+list_new
    
    list_pt+=list_new

    if state==False:
        print("目录:",state)
        return [False,i0,None]
    else:
        print("目录:",state,pt0.info())
        return [True,i,pt0]

def parser_token_入口(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,pt0]=parser_token_目录(code,i,list_new)
    if state==True:
        pt0=NetP("起点").con(0,pt0)
    if state==True:
        list_new.append(pt0)
    
    list_pt+=list_new

    if state==False:
        print("入口:",state)
        return [False,i0,None]
    else:
        print("入口:",state,pt0.info())
        return [True,i,pt0]


def parser_text2pts(code):
    list_pt0=[]
    [state,i,pt]=parser_token_入口(code,0,list_pt0)
    list_pt=[]
    for pt in list_pt0:
        if pt!=None:
                list_pt.append(pt)
    if state==False:
        return ''
    text=tools_basic.writeStdCode([],list_pt)
    return text

#text=parser_text2pts('A:B')
#print(text)



"""
+[P函数](,P代码)

"""
## end
#1354, 38:
"""


"""

ans=parser_text2pts(code)


## end
#1355, 244:
"""


"""
+显示parser结构(_parser,_结构)->+[del](,+显示parser结构)...

->[解析Parser结构]"文本"(+[临时文本],_parser)->[记录结构](+[临时文本],)...
->+[删除结构](,_结构)...
->+[导入节点](,_结构)->[m_text]([记录结构],+[导入节点])...
->+[修改内容](,_结构)->[m_text]([记录结构],+[修改内容])...
->+[显示星图](,_结构)


## end
#1359, 151:
"""
print("%或许")
print(n,type_or)
保存:...

"""

ans="""
if state%%序号==False:
    try:
        pt%d=pt%d
    else:
        pt%d=None"""%(n[0],n[0]+1)




## end
#1361, 965:
"""


"""

def parser_token_标点(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token_1(code,i)
    pt0=NetP("标点",text)
    if state==True:
        list_new.append(pt0)
    
    list_pt+=list_new

    if state==False:
        print("标点:",state)
        return [False,i0,None]
    else:
        print("标点:",state,pt0.info())
        return [True,i,pt0]



def word_pat_token_1(text,i):
    i0=i
    text_out=""
    try:
        while True:
            if i>=len(text):
                break
            elif text[i]==" " or text[i]=="\n" or text[i]=="|" or text[i]=="?" or text[i]==")":
                break
            elif text[i]=="{":
                break
            elif text[i]=="\\":
                i+=1
            text_out+=text[i]
            i+=1
        state=not (text_out=="")
    except:
        i=i0
        state=False
    return [state,i,text_out]
    

## end
#1362, 784:
"""
+[P函数](,%[标题])
print('2'.replace('2','333'))

"""

import re
from body.bone import NetP
from tools import tools_basic

def word_pat_token(code,i,pat):
    text=''

#    pat=pat.replace('\\','\\\\')
    a=re.match(pat,code[i:])
    if a==None:
        state=False
    else:
        di=a.span()[1]
        output_txt=code[i:i+di]
        i+=di
        state=True
        text=output_txt
    
    return [state,i,text]

%s

def parser_text2pts(code):
    list_pt0=[]
    [state,i,pt]=parser_token_%条目(code,0,list_pt0)
    list_pt=[]
    for pt in list_pt0:
        if pt!=None:
                list_pt.append(pt)
    if state==False:
        return ''
    text=tools_basic.writeStdCode([],list_pt)
    return text

#text=parser_text2pts('A:B')
#print(text)



"""
+[P函数](,%[标题])

"""
## end
#1364, 239:
"""
模板:...

"""
+生成代码(_媒介,_凭依)->+[del](,+生成代码)...
->的(生成代码,模板)...

->+[标题](_凭依,)->的(_凭依,结构)->的(结构,入口)...
->条目(入口,)->内容(条目,)...
->+[模板文本](模板,_凭依)...
->+[.](+[模板文本],+[标题])->+[.]"条目"(+[模板文本],内容)...

->+[结构转文本](_凭依,_凭依)...
->+[删除结构](,_凭依)





## end
#1365, 2:
%s
## end
#1366, 46:

if state%序号==True:
    list_new.append(pt%序号)
## end
#1367, 151:
"""
print("%或许")
print(n,type_or)
保存:...

"""

ans="""
if state%%序号==False:
    try:
        pt%d=pt%d
    else:
        pt%d=None"""%(n[0],n[0]+1)




## end
#1369, 163:
"""
print("%或许")
print(n,type_or)
保存:...

"""

ans="""
#if state%%序号==False:
#    try:
#        pt%d=pt%d
#    except:
#        pt%d=None"""%(n[0],n[0]+1,n[0])




## end
#1370, 59:
i%序号=i
state%序号=True
list_new%序号=list_new[:]
# list_new=[]

## end
#1371, 23:

pt%序号=NetP("%标题",text)
## end
#1372, 51:

if state==True:
    pt%序号=NetP("%标题").con(0,pt%序号)
## end
#1373, 43:

if state==True:
    list_new.append(pt%序号)
## end
#1374, 160:
"""
print("%或许")
print(n,type_or)

"""

ans=""

if n[0]>0:
    ans+="""
if state==True:
    pt%d.con(pt%d,0)
else:
    pt%d=pt%d"""%(n[0],n[0]-1,n[0],n[0]-1)



## end
#1375, 131:

if state==False:
    i=i%序号
    list_new=list_new%序号
    state=True
    state%序号=False
# else:
#     list_new=list_new%序号+list_new
## end
#1376, 44:
[state,i,text]=word_pat_token(code,i,r'%内容')
## end
#1377, 33:
i%序号=i
list_new%序号=list_new[:]
%s
## end
#1378, 49:
[state,i,pt%序号]=parser_token_%内容(code,i,list_new)
## end
#1379, 23:
%本体
if state==True:
%单元
## end
#1380, 3:
%本体
## end
#1395, 1851:
"""
本体:...
本体2:...
本体2a:...
本体3:...
新建1:...
新建2:...
P代码(Python):...
或许_开头:...
或许_结尾:...
或许_补充(Python):...
(我不记得这个有什么用了, 暂时注释掉)
(可能是用来传递代表节点)
单元模板:...
单元模板2:...
增加:...
增加2:...
节点
"""
+设置单元(_单元,_节点)->+[del](,+设置单元)...
->的(设置单元,本体)->的(设置单元,本体3)...
->的(设置单元,本体2)->的(设置单元,本体2a)...
->的(设置单元,或许_开头)->的(设置单元,或许_结尾)->的(设置单元,或许_补充)...
->的(设置单元,P代码)...
->的(设置单元,单元模板)->的(设置单元,单元模板2)...
->的(设置单元,增加)->的(设置单元,增加2)...
->的(设置单元,新建1)->的(设置单元,新建2)...

->+[临时文本]#本体->[]{
    []:->引用(_单元,)->内容(_单元,)...
        ->+[模板文本](本体,+[临时文本]#本体)->+[.](+[模板文本],内容),
    ->标点(_单元,)->内容(_单元,)...
        ->+[模板文本](本体3,+[临时文本]#本体)->+[.](+[模板文本],内容),
    ->模块(_单元,)->或许(_单元,)...
        ->+[模板文本](本体2a,+[临时文本]#本体),
    ->模块(_单元,)...
        ->+[模板文本](本体2,+[临时文本]#本体)
}...
->[]{
    []:->节点(_单元,)->[]{
        []:->标点(_单元,)->+[增加内容](新建2,+[临时文本]#本体),
        ->+[增加内容](新建1,+[临时文本]#本体)
    }, ->[]
}...

->插入(_节点,)->的(插入,序号)...

->+[临时文本]#或许1->+[临时文本]#或许2->+[临时文本]#或许3(,)...
->Python->[]{
    []:->或许#0(_单元,)->+[修改内容](或许_开头,+[临时文本]#或许1)...
        ->+[修改内容](或许_结尾,+[临时文本]#或许2)...
        ->[]{
            []:->节点(_单元,)...
                ->+[python](Python,+[临时文本]#或许3)...
                ->+[code](+[python],或许_补充)->+[.]"n"(+[python],序号),
            ->[]
        }, ->[]
}...
->[]{
    []:->模块(_单元,),
    ->[]{[]:->节点(_单元,),->引用(_单元,)}->+[python](Python,+[增加内容])...
        ->+[增加内容](,+[临时文本]#本体)...
        ->+[code](+[python],P代码)->+[.]"n"(+[python],序号),
    ->[]
}...

->+[增加内容2](+[临时文本]#或许1,+[临时文本]#本体)...
->+[增加内容](+[临时文本]#或许2,+[临时文本]#本体)...

->+[模板文本](,_节点)...
->+[.]"本体"(+[模板文本],+[临时文本]#本体)...
->[]{
    []:->的(插入,单元)->单元->+[code](+[模板文本],单元模板2)...
        ->+缩进"    "(插入,单元)->+的(单元,+缩进)...
        ->+[增加内容](+[临时文本]#或许3,_节点),
    ->+[code](+[模板文本],单元模板)
}...

->[]{
    []:->节点(_单元,)->[]{
        []:->或许#0(_单元,)->+[增加内容](增加2,_节点),
        ->+[增加内容](增加,_节点)
    },
    ->[]
}


## end
#1396, 358:
"""
情况模板:...
情况模板2:...
P代码:...

"""
+设置情况(_情况,_节点)->+[del](,+设置情况)...
->的(设置情况,情况模板)->的(设置情况,情况模板2)...
->的(设置情况,P代码)...

->_节点->+[模板文本](,_节点)...
->[]{
    []:->节点(,_节点)->+[code](+[模板文本],情况模板2)...
        ->[]{
            []:->插入(_节点,)->的(插入,单元)...
                ->+缩进"    "(插入,单元)->+的(_节点,+缩进),
            ->[]
        },
    ->+[code](+[模板文本],情况模板)
}



## end
#1397, 102:
"""


"""

ans="""if state==False:
    i=i%d
    list_new=list_new%d
%%单元
"""%(n_pt[0]+1,n_pt[0]+1)



## end
#1398, 48:
if state==False:
    i=i%序号
    list_new=[]
%单元

## end
#1399, 4:
%单元

## end
#1404, 455:
"""
情况模板:...
情况模板2:...
P代码:...

保存:...

"""
+设置情况(_情况,_节点)->+[del](,+设置情况)...
->的(设置情况,情况模板)->的(设置情况,情况模板2)...
->的(设置情况,P代码)...

->_节点->[]{
    []:->节点(,_节点)->插入(_节点,)->的(插入,序号)...
        ->+[python](Python,_节点)->+[code](+[python],P代码)...
        ->+[.]"n_pt"(+[python],序号)...
        ->[]{
            []:->插入(_节点,)->的(插入,单元)...
                ->+缩进"    "(插入,单元)->+的(_节点,+缩进),
            ->[]
        },
    ->+[模板文本](,_节点)->+[code](+[模板文本],情况模板)
}



## end
#1405, 321:

def parser_token_%内容(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

%s
    list_pt+=list_new

    if state==False:
        print("%内容:",state)
        return [False,i0,None]
    else:
        print("%内容:",state,pt%序号.info())
        return [True,i,pt%序号]

## end
#1407, 195:
"""
条目模板:...

"""
+设置条目(_单元,_节点)->+[del](,+设置条目)...
->的(设置条目,条目模板)...

->内容(_单元,)...
->+[模板文本](条目模板,_节点)->+[.](+[模板文本],内容)...

->[]{
    []:->顺序(_节点,)->+缩进"    "(_节点,顺序)->+的(_节点,+缩进),
    ->[]
}

## end
#1411, 52:


设置单元:...
设置情况:...
设置条目:...
将条目"设置单元"复制为条目"设置条目"



## end
#1412, 692:
"""


"""
+单元0(单元,_节点)->.(+单元0,操作)...
->单元0->的(描述结构,单元0)->的(描述结构,情况0)...

->+[文本结构_插入](_节点,+单元)...
->[投影](,+[文本结构_插入])->[投影](,+单元)...

->的(_节点,序号)->+的(+单元,+序号)->+[文本结构_插入](+单元,+序号)...
->[投影](,+[文本结构_插入])->[投影](,+序号)...
->+[.]"n"([python],序号)->[python]"
state=True
ans=int(n[0]+1)
"(Python,+序号)...

->[]{
    []:->节点(单元,)->内容(节点,)...
        ->+[文本结构_插入](+单元,+标题)->[m_text](内容,+标题)...
        ->[投影](,+[文本结构_插入])->[投影](,+标题),
    ->标点(单元,)->[m_text](序号,+序号),
    ->[]
}...

->[]{
    []=>模块(单元,情况)->情况=>+[code]([想]#1,情况0)...
        ->+[.]([想]#1,操作)->[想]#1(情况,+单元)
}...
->[]{
    []=>单元#1(单元,)=>+[code]([想],单元0)...
        ->+[.]([想],操作)->[想](单元#1,+单元)
}...

->+设置单元(单元,+单元)->+的(操作,+设置单元)





## end
#1413, 495:
"""


"""
+情况0(情况,_节点)->.(+情况0,操作)...
->情况0->的(描述结构,情况0)->的(描述结构,单元0)...

->+[文本结构_插入尾部](_节点,+节点)...
->[投影](,+[文本结构_插入尾部])->[投影](,+节点)...

->的(_节点,序号)->+的(+节点,+序号)->+[文本结构_插入](+节点,+序号)...
->[投影](,+[文本结构_插入])->[投影](,+序号)...
->+[.]"n"([python],序号)->[python]"
state=True
ans=int(n[0]-1)
"(Python,+序号)...

->单元(情况,)->+[code]([想],单元0)...
    ->+[.]([想],操作)->[想](单元,+节点)...
->[]{
    []=>情况#1(情况,)=>+[code]([想]#1,情况0)...
        ->+[.]([想]#1,操作)->[想]#1(情况#1,_节点)
}...

->+设置情况(情况,+节点)->+的(操作,+设置情况)



## end
#1416, 160:
"""
情况0:...
单元0:...

"""
+描述结构(_条目,_节点)->+操作(+描述结构,)...

->情况(_条目,)->+[code]([想],情况0)...
    ->+[.]([想],+操作)->[想](情况,_节点)...

->+设置条目(_条目,_节点)->+的(+操作,+设置条目)



## end
#1419, 365:
"""
描述结构:...
库:...

"""

+设置函数(_条目,_凭依)->+[del](,+设置函数)...
->的(设置函数,描述结构)->的(设置函数,库)...

->+[文本结构_插入尾部](_凭依,+节点)->+[文本结构_插入](+节点,+序号)...
->+的(+节点,+序号)->+序号"0"...

->+[code]([想],描述结构)->[想](_条目,+节点)...
->操作([想],)->[]{
    []=>的(操作,_操作)->_操作(_主语,_宾语)->_主语->_宾语=>[说](,_操作)...
        ->的(库,_条目0)->_条目0->[eq](_条目0,_操作)...
        ->+[做](_主语,_宾语)->+[code](+[做],_条目0)
}



## end
#1421, 12:


设置函数:...


## end
#1422, 111:
"""


"""
+描述结构(_媒介,_凭依)->+操作(+描述结构,)...

->的(_凭依,结构)...
->的(结构,入口)=>条目(入口,)...
=>+设置函数(条目,_凭依)->+的(+操作,+设置函数)

## end
#1425, 285:
"""
描述结构:...
库:...

"""
+结构变换(_媒介,_凭依)->+[del](,+结构变换)...
->的(结构变换,描述结构)->的(结构变换,库)...

->+[code]([想],描述结构)->[想](_媒介,_凭依)...
->操作([想],)->[]{
    []=>的(操作,_操作)->_操作(_主语,_宾语)->_主语->_宾语=>[说](,_操作)...
        ->的(库,_条目)->_条目->[eq](_条目,_操作)...
        ->+[做](_主语,_宾语)->+[code](+[做],_条目)
}


## end
#1426, 159:
"""


"""
+生成结构(_媒介,_凭依)->+[del](,+生成结构)...

->+的(_凭依,+结构)...
->[解析Parser结构]"文本"(+[临时文本],_媒介)->[记录结构](+[临时文本],)...
->+[导入节点](,+结构)->[m_text]([记录结构],+[导入节点])



## end
#1430, 30:


生成结构:...
结构变换:...
生成代码:...


## end
#1431, 203:
"""


"""

+召唤规则(_媒介,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_凭依)...

->[==]"生成Parser代码"(,召唤星辰)...
    ->+生成代码(_媒介,_凭依)->+的(操作,+生成代码)...
    ->+结构变换(_媒介,_凭依)->+的(操作,+结构变换)...
    ->+生成结构(_媒介,_凭依)->+的(操作,+生成结构)




## end
#1434, 22:


召唤规则:...
降临规则:...



## end
#1437, 153:
"""


"""
+下一条(_凭依,条目)->.(+下一条,操作)...

->+设置函数(条目,_凭依)->+的(操作,+设置函数)...
->[]:
    ->条目#2(条目,)->+[code]([想],下一条)->+[.]([想],操作)->[想](_凭依,条目#2),
    ->[]



## end
#1438, 206:
"""


"""

+召唤规则(_媒介,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_凭依)...

->[==]"生成Parser代码_快速"(,召唤星辰)...
    ->+生成代码(_媒介,_凭依)->+的(操作,+生成代码)...
    ->+结构变换(_媒介,_凭依)->+的(操作,+结构变换)...
    ->+生成结构(_媒介,_凭依)->+的(操作,+生成结构)




## end
#1440, 9747:
生成Parser代码_快速#0"

召唤规则:...
降临规则:...


"(,)
的#1""(生成Parser代码_快速#0,召唤规则#2)
召唤规则#2"\"\"\"


\"\"\"

+召唤规则(_媒介,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_凭依)...

->[==]\"生成Parser代码_快速\"(,召唤星辰)...
    ->+生成代码(_媒介,_凭依)->+的(操作,+生成代码)...
    ->+结构变换(_媒介,_凭依)->+的(操作,+结构变换)...
    ->+生成结构(_媒介,_凭依)->+的(操作,+生成结构)



"(,)
的#3""(生成Parser代码_快速#0,降临规则#4)
降临规则#4"

生成结构:...
结构变换:...
生成代码:...
+[新建阅读窗口](,生成代码)
"(,)
的#5""(降临规则#4,生成结构#6)
生成结构#6"\"\"\"


\"\"\"
+生成结构(_媒介,_凭依)->+[del](,+生成结构)...

->+的(_凭依,+结构)...
->[解析Parser结构_代码](,_媒介)...
->+[导入节点](,+结构)->[m_text]([解析Parser结构_代码],+[导入节点])


"(,)
的#7""(降临规则#4,结构变换#8)
结构变换#8"\"\"\"
描述结构:...
库:...

\"\"\"
+结构变换(_媒介,_凭依)->+[del](,+结构变换)...
->的(结构变换,描述结构)->的(结构变换,库)...

->+[code]([想],描述结构)->[想](_媒介,_凭依)...
->操作([想],)->[]{
    []=>的(操作,_操作)->_操作(_主语,_宾语)->_主语->_宾语=>[说](,_操作)...
        ->的(库,_条目)->_条目->[eq](_条目,_操作)...
        ->+[做](_主语,_宾语)->+[code](+[做],_条目)
}

"(,)
的#9""(结构变换#8,描述结构#10)
描述结构#10"\"\"\"
下一条:...

\"\"\"
+描述结构(_媒介,_凭依)->+操作(+描述结构,)...

->的(_凭依,结构)...
->的(结构,起点)->起点(,条目)...
->+[code]([想],下一条)->+[.]([想],+操作)->[想](_凭依,条目)

"(,)
的#11""(描述结构#10,下一条#12)
下一条#12"\"\"\"


\"\"\"
+下一条(_凭依,条目)->.(+下一条,操作)...

->+设置函数(条目,_凭依)->+的(操作,+设置函数)...
->[]:
    ->条目#2(条目,)->+[code]([想],下一条)->+[.]([想],操作)->[想](_凭依,条目#2),
    ->[]


"(,)
的#13""(结构变换#8,库#14)
库#14"

设置函数:...

"(,)
的#15""(库#14,设置函数#16)
设置函数#16"\"\"\"
描述结构:...
库:...

\"\"\"

+设置函数(_条目,_凭依)->+[del](,+设置函数)...
->的(设置函数,描述结构)->的(设置函数,库)...

->+[文本结构_插入尾部](_凭依,+节点)->+[文本结构_插入](+节点,+序号)...
->+的(+节点,+序号)->+序号\"0\"...

->+[code]([想],描述结构)->[想](_条目,+节点)...
->操作([想],)->[]{
    []=>的(操作,_操作)->_操作(_主语,_宾语)->_主语->_宾语=>[说](,_操作)...
        ->的(库,_条目0)->_条目0->[eq](_条目0,_操作)...
        ->+[做](_主语,_宾语)->+[code](+[做],_条目0)
}


"(,)
的#17""(设置函数#16,描述结构#18)
描述结构#18"\"\"\"
情况0:...
单元0:...

\"\"\"
+描述结构(_条目,_节点)->+操作(+描述结构,)...

->定义(_条目,情况)->+[code]([想],情况0)...
    ->+[.]([想],+操作)->[想](情况,_节点)...

->+设置条目(_条目,_节点)->+的(+操作,+设置条目)


"(,)
的#19""(描述结构#18,情况0#20)
情况0#20"\"\"\"


\"\"\"
+情况0(情况,_节点)->.(+情况0,操作)...
->情况0->的(描述结构,情况0)->的(描述结构,单元0)...

->+[文本结构_插入尾部](_节点,+节点)...
->[投影](,+[文本结构_插入尾部])->[投影](,+节点)...

->的(_节点,序号)->+的(+节点,+序号)->+[文本结构_插入](+节点,+序号)...
->[投影](,+[文本结构_插入])->[投影](,+序号)...
->+[.]\"n\"([python],序号)->[python]\"
state=True
ans=int(n[0]-1)
\"(Python,+序号)...

->情况(,单元)->+[code]([想],单元0)...
    ->+[.]([想],操作)->[想](单元,+节点)...
->[]{
    []=>情况#1(情况,)=>+[code]([想]#1,情况0)...
        ->+[.]([想]#1,操作)->[想]#1(情况#1,_节点)
}...

->+设置情况(情况,+节点)->+的(操作,+设置情况)


"(,)
的#21""(描述结构#18,单元0#22)
单元0#22"\"\"\"


\"\"\"
+单元0(单元,_节点)->.(+单元0,操作)...
->单元0->的(描述结构,单元0)->的(描述结构,情况0)...

->+[文本结构_插入](_节点,+单元)...
->[投影](,+[文本结构_插入])->[投影](,+单元)...

->的(_节点,序号)->+的(+单元,+序号)->+[文本结构_插入](+单元,+序号)...
->[投影](,+[文本结构_插入])->[投影](,+序号)...
->+[.]\"n\"([python],序号)->[python]\"
state=True
ans=int(n[0]+1)
\"(Python,+序号)...

->单元(,_类型)->[]{
    []:->节点(_类型,内容)->内容(,)...
        ->+[文本结构_插入](+单元,+标题)->[m_text](内容,+标题)...
        ->[投影](,+[文本结构_插入])->[投影](,+标题),
    ->[is](_类型,标点)->标点->[m_text](序号,+序号),
    ->[]
}...

->[]{
    []=>[is](_类型,模块)->模块(,情况)=>+[code]([想]#1,情况0)...
        ->+[.]([想]#1,操作)->[想]#1(情况,+单元)
}...
->[]{
    []=>单元#1(单元,)=>+[code]([想],单元0)...
        ->+[.]([想],操作)->[想](单元#1,+单元)
}...

->+设置单元(单元,+单元)->+的(操作,+设置单元)




"(,)
的#23""(设置函数#16,库#24)
库#24"

设置单元:...
设置情况:...
设置条目:...
将条目\"设置单元\"复制为条目\"设置条目\"


"(,)
的#25""(库#24,设置条目#26)
设置条目#26"\"\"\"
条目模板:...

\"\"\"
+设置条目(_单元,_节点)->+[del](,+设置条目)...
->的(设置条目,条目模板)...

->_单元(,内容)...
->+[模板文本](条目模板,_节点)->+[.](+[模板文本],内容)...

->[]{
    []:->顺序(_节点,)->+缩进\"    \"(_节点,顺序)->+的(_节点,+缩进),
    ->[]
}
"(,)
的#27""(设置条目#26,条目模板#28)
条目模板#28"
def parser_token_%内容(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

%s
    list_pt+=list_new

    if state==False:
        print(\"%内容:\",state)
        return [False,i0,None]
    else:
        print(\"%内容:\",state,pt%序号.info())
        return [True,i,pt%序号]
"(,)
的#29""(库#24,设置情况#30)
设置情况#30"\"\"\"
情况模板:...
情况模板2:...
P代码:...

保存:...

\"\"\"
+设置情况(_情况,_节点)->+[del](,+设置情况)...
->的(设置情况,情况模板)->的(设置情况,情况模板2)...
->的(设置情况,P代码)...

->_节点->[]{
    []:->节点(,_节点)->插入(_节点,)->的(插入,序号)...
        ->+[python](Python,_节点)->+[code](+[python],P代码)...
        ->+[.]\"n_pt\"(+[python],序号)...
        ->[]{
            []:->插入(_节点,)->的(插入,单元)...
                ->+缩进\"    \"(插入,单元)->+的(_节点,+缩进),
            ->[]
        },
    ->+[模板文本](,_节点)->+[code](+[模板文本],情况模板)
}


"(,)
的#31""(设置情况#30,情况模板#32)
情况模板#32"%单元
"(,)
的#33""(设置情况#30,情况模板2#34)
情况模板2#34"if state==False:
    i=i%序号
    list_new=[]
%单元
"(,)
的#35""(设置情况#30,P代码#36)
P代码#36"\"\"\"


\"\"\"

ans=\"\"\"if state==False:
    i=i%d
    list_new=list_new%d
%%单元
\"\"\"%(n_pt[0]+1,n_pt[0]+1)


"(,)
的#37""(设置情况#30,保存#38)
保存#38"\"\"\"
情况模板:...
情况模板2:...
P代码:...

\"\"\"
+设置情况(_情况,_节点)->+[del](,+设置情况)...
->的(设置情况,情况模板)->的(设置情况,情况模板2)...
->的(设置情况,P代码)...

->_节点->+[模板文本](,_节点)...
->[]{
    []:->节点(,_节点)->+[code](+[模板文本],情况模板2)...
        ->[]{
            []:->插入(_节点,)->的(插入,单元)...
                ->+缩进\"    \"(插入,单元)->+的(_节点,+缩进),
            ->[]
        },
    ->+[code](+[模板文本],情况模板)
}


"(,)
的#39""(库#24,设置单元#40)
设置单元#40"\"\"\"
本体:...
本体2:...
本体2a:...
本体3:...
新建1:...
新建2:...
P代码(Python):...
或许_开头:...
或许_结尾:...
或许_补充(Python):...
(我不记得这个有什么用了, 暂时注释掉)
(可能是用来传递代表节点)
单元模板:...
单元模板2:...
增加:...
增加2:...
节点
\"\"\"
+设置单元(_单元,_节点)->+[del](,+设置单元)...
->的(设置单元,本体)->的(设置单元,本体3)...
->的(设置单元,本体2)->的(设置单元,本体2a)...
->的(设置单元,或许_开头)->的(设置单元,或许_结尾)->的(设置单元,或许_补充)...
->的(设置单元,P代码)...
->的(设置单元,单元模板)->的(设置单元,单元模板2)...
->的(设置单元,增加)->的(设置单元,增加2)...
->的(设置单元,新建1)->的(设置单元,新建2)...

->_单元(,_类型)->_类型(,)...
->+[临时文本]#本体->[]{
    []:->[is](_类型,引用)->引用(,内容)...
        ->+[模板文本](本体,+[临时文本]#本体)->+[.](+[模板文本],内容),
    ->[is](_类型,标点)->标点(,标点#1)...
        ->+[模板文本](本体3,+[临时文本]#本体)->+[.]\"内容\"(+[模板文本],标点#1),
    ->[is](_类型,模块)->模块->或许(模块,)...
        ->+[模板文本](本体2a,+[临时文本]#本体),
    ->[is](_类型,模块#2)->模块#2(,)...
        ->+[模板文本](本体2,+[临时文本]#本体)
}...
->[]{
    []:->节点(_类型,)->[]{
        []:->[is](_类型,标点)->标点->+[增加内容](新建2,+[临时文本]#本体),
        ->+[增加内容](新建1,+[临时文本]#本体)
    }, ->[]
}...

->插入(_节点,)->的(插入,序号)...

->+[临时文本]#或许1->+[临时文本]#或许2->+[临时文本]#或许3(,)...
->Python->[]{
    []:->或许#0(_类型,)->+[修改内容](或许_开头,+[临时文本]#或许1)...
        ->+[修改内容](或许_结尾,+[临时文本]#或许2)...
        ->[]{
            []:->节点(_类型,)...
                ->+[python](Python,+[临时文本]#或许3)...
                ->+[code](+[python],或许_补充)->+[.]\"n\"(+[python],序号),
            ->[]
        }, ->[]
}...
->[]{
    []:->[is](_类型,模块)->模块,
    ->[]{[]:->节点(_类型,),->[is](_类型,引用)->引用}...
        ->+[python](Python,+[增加内容])->+[增加内容](,+[临时文本]#本体)...
        ->+[code](+[python],P代码)->+[.]\"n\"(+[python],序号),
    ->[]
}...

->+[增加内容2](+[临时文本]#或许1,+[临时文本]#本体)...
->+[增加内容](+[临时文本]#或许2,+[临时文本]#本体)...

->+[模板文本](,_节点)...
->+[.]\"本体\"(+[模板文本],+[临时文本]#本体)...
->[]{
    []:->的(插入,单元)->单元->+[code](+[模板文本],单元模板2)...
        ->+缩进\"    \"(插入,单元)->+的(单元,+缩进)...
        ->+[增加内容](+[临时文本]#或许3,_节点),
    ->+[code](+[模板文本],单元模板)
}...

->[]{
    []:->节点(_类型,)->[]{
        []:->或许#0(_类型,)->+[增加内容](增加2,_节点),
        ->+[增加内容](增加,_节点)
    },
    ->[]
}

"(,)
的#41""(设置单元#40,单元模板#42)
单元模板#42"%本体"(,)
的#43""(设置单元#40,单元模板2#44)
单元模板2#44"%本体
if state==True:
%单元"(,)
的#45""(设置单元#40,本体#46)
本体#46"[state,i,pt%序号]=parser_token_%内容(code,i,list_new)"(,)
的#47""(设置单元#40,本体2#48)
本体2#48"i%序号=i
list_new%序号=list_new[:]
%s"(,)
的#49""(设置单元#40,本体3#50)
本体3#50"[state,i,text]=word_pat_token(code,i,r'%内容')"(,)
的#51""(设置单元#40,或许_结尾#52)
或许_结尾#52"
if state==False:
    i=i%序号
    list_new=list_new%序号
    state=True
    state%序号=False
# else:
#     list_new=list_new%序号+list_new"(,)
的#53""(设置单元#40,P代码#54)
P代码#54"\"\"\"
print(\"%或许\")
print(n,type_or)

\"\"\"

ans=\"\"

if n[0]>0:
    ans+=\"\"\"
if state==True:
    pt%d.con(pt%d,0)
else:
    pt%d=pt%d\"\"\"%(n[0],n[0]-1,n[0],n[0]-1)


"(,)
的#55""(设置单元#40,增加#56)
增加#56"
if state==True:
    list_new.append(pt%序号)"(,)
的#57""(设置单元#40,新建1#58)
新建1#58"
if state==True:
    pt%序号=NetP(\"%标题\").con(0,pt%序号)"(,)
的#59""(设置单元#40,新建2#60)
新建2#60"
pt%序号=NetP(\"%标题\",text)"(,)
的#61""(设置单元#40,或许_开头#62)
或许_开头#62"i%序号=i
state%序号=True
list_new%序号=list_new[:]
# list_new=[]
"(,)
的#63""(设置单元#40,或许_补充#64)
或许_补充#64"\"\"\"
print(\"%或许\")
print(n,type_or)
保存:...

\"\"\"

ans=\"\"\"
#if state%%序号==False:
#    try:
#        pt%d=pt%d
#    except:
#        pt%d=None\"\"\"%(n[0],n[0]+1,n[0])



"(,)
的#65""(或许_补充#64,保存#66)
保存#66"\"\"\"
print(\"%或许\")
print(n,type_or)
保存:...

\"\"\"

ans=\"\"\"
if state%%序号==False:
    try:
        pt%d=pt%d
    else:
        pt%d=None\"\"\"%(n[0],n[0]+1)



"(,)
的#67""(设置单元#40,增加2#68)
增加2#68"
if state%序号==True:
    list_new.append(pt%序号)"(,)
的#69""(设置单元#40,本体2a#70)
本体2a#70"%s"(,)
的#71""(降临规则#4,生成代码#72)
生成代码#72"\"\"\"
模板:...

\"\"\"
+生成代码(_媒介,_凭依)->+[del](,+生成代码)...
->的(生成代码,模板)...

->+[标题](_凭依,)->的(_凭依,结构)->的(结构,起点)...
->起点(,条目)->条目(,内容)...
->+[模板文本](模板,_凭依)...
->+[.](+[模板文本],+[标题])->+[.]\"条目\"(+[模板文本],内容)...

->+[结构转文本](_凭依,_凭依)...
->+[删除结构](,_凭依)




"(,)
的#73""(生成代码#72,模板#74)
模板#74"\"\"\"
+[P函数](,%[标题])
print('2'.replace('2','333'))

\"\"\"

import re
from body.bone import NetP
from tools import tools_basic

def word_pat_token(code,i,pat):
    text=''

#    pat=pat.replace('\\','\\\\')
    a=re.match(pat,code[i:])
    if a==None:
        state=False
    else:
        di=a.span()[1]
        output_txt=code[i:i+di]
        i+=di
        state=True
        text=output_txt
    
    return [state,i,text]

%s

def parser_text2pts(code):
    list_pt0=[]
    [state,i,pt]=parser_token_%条目(code,0,list_pt0)
    list_pt=[]
    for pt in list_pt0:
        if pt!=None:
                list_pt.append(pt)
    if state==False:
        return ''
    text=tools_basic.writeStdCode([],list_pt)
    return text

#text=parser_text2pts('A:B')
#print(text)



\"\"\"
+[P函数](,%[标题])

\"\"\""(,)

## end
#1442, 129:
"""
+[P函数](,对比文本)

"""

n=len(text1)

for i in range(n):
    if text1[i]!=text2[i]:
        break
print(i)
print(text1[i:i+30])


## end
#1445, 307:
"""
P代码(P函数):...

"""

+结构图_代码(_程序,)...
->的(结构图_代码,P代码)->的(P代码,函数定义)->的(P代码,默认定义)...

->[python]#3"state=True"(Python,)...
->+[code]([python]#0,函数定义)->[python]#0(Python,)...
->+[code]([python]#1,默认定义)->[python]#1(Python,)...

->+[code]([python],P代码)->+[.]"code"([python],_程序)...
->[python](Python,+结构图_代码)


## end
#1447, 224:
"""
规则:...
规则=>想(规则,)=>+[del](,想)
函数定义(P函数):...
默认定义(P函数):...
+[召唤星辰]"生成Parser代码_快速"(规则,函数定义)
+[召唤星辰]"生成Parser代码"(规则,函数定义)
+[新建阅读窗口](,规则)
+[新建阅读窗口](,函数定义)
+[新建阅读窗口](,默认定义)
'规则'有什么

"""

ans=parser_text2pts(code)
state=True


## end
#1450, 225:
graph:[code]{起点}
code:\\s* [line]{行} (\\s*, [code])?
line:[point]{节点} (->\\s* [line])?
point:[name]{名字} (\\s*\\\( [text] \\\)\\s*){注释}? (\\s*\{\\s* [code] \\s*\}\\s*){子集}?
name:\[\\w\\d_\\~\]+{name}
text:\[\\w\\d_\\~\]+{text}
## end
#1452, 6625:
"""
+[P函数](,函数定义)
print('2'.replace('2','333'))

"""

import re
from body.bone import NetP
from tools import tools_basic

def word_pat_token(code,i,pat):
    text=''

#    pat=pat.replace('\\','\\\\')
    a=re.match(pat,code[i:])
    if a==None:
        state=False
    else:
        di=a.span()[1]
        output_txt=code[i:i+di]
        i+=di
        state=True
        text=output_txt
    
    return [state,i,text]


def parser_token_text(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'[\w\d_\~]+')
    pt0=NetP("text",text)
    if state==True:
        list_new.append(pt0)
    

    if state==False:
        print("text:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("text:",state,pt0.info())
        return [True,i,pt0]

def parser_token_name(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'[\w\d_\~]+')
    pt0=NetP("name",text)
    if state==True:
        list_new.append(pt0)
    

    if state==False:
        print("name:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("name:",state,pt0.info())
        return [True,i,pt0]

def parser_token_point(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,pt0]=parser_token_name(code,i,list_new)
    if state==True:
        pt0=NetP("名字").con(0,pt0)
    if state==True:
        i1=i
        state1=True
        list_new1=list_new[:]
        # list_new=[]
        [state,i,text]=word_pat_token(code,i,r'\s*\(')
        if state==True:
            [state,i,pt1]=parser_token_text(code,i,list_new)
            if state==True:
                pt1.con(pt0,0)
            else:
                pt1=pt0
            if state==True:
                [state,i,text]=word_pat_token(code,i,r'\)\s*')
        
        if state==True:
            pt1=NetP("注释").con(0,pt1)
        if state==False:
            i=i1
            list_new=list_new1
            state=True
            state1=False
        # else:
        #     list_new=list_new1+list_new
            pt1=pt0
        if state==True:
            i2=i
            state2=True
            list_new2=list_new[:]
            # list_new=[]
            [state,i,text]=word_pat_token(code,i,r'\s*{\s*')
            if state==True:
                [state,i,pt2]=parser_token_code(code,i,list_new)
                if state==True:
                    pt2.con(pt1,0)
                else:
                    pt2=pt1
                if state==True:
                    [state,i,text]=word_pat_token(code,i,r'\s*}\s*')
            
            if state==True:
                pt2=NetP("子集").con(0,pt2)
            if state==False:
                i=i2
                list_new=list_new2
                state=True
                state2=False
            # else:
            #     list_new=list_new2+list_new
                pt2=pt1
            if state2==True:
                list_new.append(pt2)
        #if state1==False:
        #    try:
        #        pt1=pt2
        #    except:
        #        pt1=None
        if state1==True:
            list_new.append(pt1)
    if state==True:
        list_new.append(pt0)
    

    if state==False:
        print("point:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("point:",state,pt0.info())
        return [True,i,pt0]

def parser_token_line(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,pt0]=parser_token_point(code,i,list_new)
    if state==True:
        pt0=NetP("节点").con(0,pt0)
    if state==True:
        i1=i
        state1=True
        list_new1=list_new[:]
        # list_new=[]
        [state,i,text]=word_pat_token(code,i,r'->\s*')
        if state==True:
            [state,i,pt1]=parser_token_line(code,i,list_new)
            if state==True:
                pt1.con(pt0,0)
            else:
                pt1=pt0
        
        if state==False:
            i=i1
            list_new=list_new1
            state=True
            state1=False
        # else:
        #     list_new=list_new1+list_new
    if state==True:
        list_new.append(pt0)
    

    if state==False:
        print("line:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("line:",state,pt0.info())
        return [True,i,pt0]

def parser_token_code(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,text]=word_pat_token(code,i,r'\s*')
    if state==True:
        [state,i,pt0]=parser_token_line(code,i,list_new)
        if state==True:
            pt0=NetP("行").con(0,pt0)
        if state==True:
            i1=i
            state1=True
            list_new1=list_new[:]
            # list_new=[]
            [state,i,text]=word_pat_token(code,i,r'\s*,')
            if state==True:
                [state,i,pt1]=parser_token_code(code,i,list_new)
                if state==True:
                    pt1.con(pt0,0)
                else:
                    pt1=pt0
            
            if state==False:
                i=i1
                list_new=list_new1
                state=True
                state1=False
            # else:
            #     list_new=list_new1+list_new
        if state==True:
            list_new.append(pt0)
    

    if state==False:
        print("code:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("code:",state,pt0.info())
        return [True,i,pt0]

def parser_token_graph(code,i,list_pt=None):
    i0=i
    if list_pt==None:
        list_pt=[]
    list_new=[]
    list_new0=list_new

    [state,i,pt0]=parser_token_code(code,i,list_new)
    if state==True:
        pt0=NetP("起点").con(0,pt0)
    if state==True:
        list_new.append(pt0)
    

    if state==False:
        print("graph:",state)
        return [False,i0,None]
    else:
        list_pt+=list_new
        print("graph:",state,pt0.info())
        return [True,i,pt0]


def parser_text2pts(code):
    list_pt0=[]
    [state,i,pt]=parser_token_graph(code,0,list_pt0)
    list_pt=[]
    for pt in list_pt0:
        if pt!=None:
                list_pt.append(pt)
    if state==False:
        return ''
    text=tools_basic.writeStdCode([],list_pt)
    return text

#text=parser_text2pts('A:B')
#print(text)



"""
+[P函数](,函数定义)

"""
## end
#1458, 475:
参考::https://en.wikipedia.org/wiki/Box-drawing_character
+[打开网页](,参考)

测试代码:...
+[新建阅读窗口](,测试代码)

结构:...
+[删除结构](,结构)->+[分析结构图结构](测试代码,结构)->+[显示星图](,结构)
的(结构,起点)->起点(,行)->+观察(+结构块,行)->[描述结构](结构,+观察)...
    ->+[del](,+观察)->+[del](,+结构块)


流程图:...
+[删除结构](,流程图)->+[召唤星辰]"一般结构转结构文字"(结构,流程图)
+[删除结构](,流程图)->+[召唤星辰]"一般结构转流程图"(结构,流程图)
+[删除结构](,流程图)->+[召唤星辰]"一般结构转分类图"(结构,流程图)
的(流程图,结构)->+[显示星图]"2"(,结构)
+[显示PPT场景]"1"(,流程图)
+[H函数](,流程图)

H代码:...
+[PPT场景转H代码](流程图,H代码)
+[H函数](,H代码)



## end
#1460, 209:

lens{
    init,
    set,
    get{
        getShape,
        getRadius,
        getField->field{Ex,Ey,Ez,Bx,By,Bz}
    },
    view,

    vars{
        r,
        R,
        U1,
        U2,
        U3
    }
}


## end
#1462, 1499:
name#0"lens"(,)
name#1"init"(,)
名字#2""(,name#1)
节点#3""(,名字#2)
name#4"set"(,)
名字#5""(,name#4)
节点#6""(,名字#5)
name#7"get"(,)
name#8"getShape"(,)
名字#9""(,name#8)
节点#10""(,名字#9)
name#11"getRadius"(,)
名字#12""(,name#11)
节点#13""(,名字#12)
name#14"getField"(,)
名字#15""(,name#14)
name#16"field"(,)
name#17"Ex"(,)
名字#18""(,name#17)
节点#19""(,名字#18)
name#20"Ey"(,)
名字#21""(,name#20)
节点#22""(,名字#21)
name#23"Ez"(,)
名字#24""(,name#23)
节点#25""(,名字#24)
name#26"Bx"(,)
名字#27""(,name#26)
节点#28""(,名字#27)
name#29"By"(,)
名字#30""(,name#29)
节点#31""(,名字#30)
name#32"Bz"(,)
名字#33""(,name#32)
节点#34""(,名字#33)
行#35""(行#36,节点#34)
行#36""(行#37,节点#31)
行#37""(行#38,节点#28)
行#38""(行#39,节点#25)
行#39""(行#40,节点#22)
行#40""(名字#42,节点#19)
子集#41""(,行#40)
名字#42""(,name#16)
节点#43""(节点#44,名字#42)
节点#44""(,名字#15)
行#45""(行#46,节点#44)
行#46""(行#47,节点#13)
行#47""(名字#49,节点#10)
子集#48""(,行#47)
名字#49""(,name#7)
节点#50""(,名字#49)
name#51"view"(,)
名字#52""(,name#51)
节点#53""(,名字#52)
name#54"vars"(,)
name#55"r"(,)
名字#56""(,name#55)
节点#57""(,名字#56)
name#58"R"(,)
名字#59""(,name#58)
节点#60""(,名字#59)
name#61"U1"(,)
名字#62""(,name#61)
节点#63""(,名字#62)
name#64"U2"(,)
名字#65""(,name#64)
节点#66""(,名字#65)
name#67"U3"(,)
名字#68""(,name#67)
节点#69""(,名字#68)
行#70""(行#71,节点#69)
行#71""(行#72,节点#66)
行#72""(行#73,节点#63)
行#73""(行#74,节点#60)
行#74""(名字#76,节点#57)
子集#75""(,行#74)
名字#76""(,name#54)
节点#77""(,名字#76)
行#78""(行#79,节点#77)
行#79""(行#80,节点#53)
行#80""(行#81,节点#50)
行#81""(行#82,节点#6)
行#82""(名字#84,节点#3)
子集#83""(,行#82)
名字#84""(,name#0)
节点#85""(,名字#84)
行#86""(,节点#85)
起点#87""(,行#86)

## end
#1464, 194:
"""
Nini, 打开公式分析器(文件)
保存:...

"""

+分析结构图结构(_代码,_输出)->+[del](,+分析结构图结构)...

->[结构图_代码](_代码,)...
    ->+[修改内容](,_输出)->[m_text]([结构图_代码],+[修改内容])...
    ->+[导入节点](,_输出)->[m_text]([结构图_代码],+[导入节点])
## end
#1465, 185:
"""


"""
+整理结构(_媒介,_凭依)->+[del](,+整理结构)...

->的(_凭依,召唤规则)->+[删除结构](,召唤规则)->+[del](,召唤规则)...
->的(_凭依,降临规则)->+[删除结构](,降临规则)->+[del](,降临规则)...
->+[修改内容](_凭依,+[显示])->+[显示]->+[删除结构](,_凭依)


## end
#1467, 34:
"""


"""

ans=text_0+"\n"+text_a

## end
#1468, 265:
"""
+[P函数](,测试)

"""
text_a="""
aaa
c
v
"""
text_0=text_a

list_line=text_0.split("\n")
list_ns=[len(line) for line in list_line]
print(list_ns)




"""
+[P函数](,测试)
print('{s:X<{n}}'.format(s="11",n=10))
print(f'{"dog": <10}'+'1')
print(f'{"%s":X<10}'%("AAA"))

"""
## end
#1470, 915:
"""
记住"Python"
+[P函数](,P代码2)
测试:...

"""
import numpy as np

ans=""
pat_line_0="{s:─<{n}}"
pat_line_1="{s: <{n}}"
if text_0!="":
    list_line_0=text_0.split("\n")
    n_0=np.max([len(line) for line in list_line_0])
    l_0=len(list_line_0)
    list_line_a=text_a.split("\n")
    n_a=np.max([len(line) for line in list_line_a])
    l_a=len(list_line_a)

    for i in range(np.max([l_a,l_0])):
        pat_line=pat_line_1

        if i>=l_a:
            line_a=pat_line.format(s=" ",n=n_a)
        else:
            line_a=pat_line.format(s=list_line_a[i],n=n_a)
        
        if i>=l_0:
            line_0=pat_line.format(s=" ",n=n_0)
        else:
            line_0=pat_line.format(s=list_line_0[i],n=n_0)

        if i==0:
            line_a=line_a.replace(" ","─")
            ans+=line_a+"────"+line_0+"\n"
        else:
            ans+=line_a+"    "+line_0+"\n"

    ans=ans[0:-1]
else:
    ans=text_a




## end
#1471, 792:
"""
    text_0=str_a+text_0.replace("\n","\n"+str_a)
print(text_0)
print(text_1)
+[P函数](,P代码)

"""
# print(var_name,pt_name)
if text_0=="":
    ans=var_name
else:
    str_a="├"
    list_line=text_0.split("\n")
    list_line_1=[]
    n_last=0
    for i in range(len(list_line)):
        line=list_line[i]
        if line[0]=="|" or line[0]=="├" or line[0]=="└" or line[0]==" ":
            line="|"+line
        else:
            n_last=i
            line="├"+line
        list_line_1.append(line)
    for i in range(n_last,len(list_line_1)):
        if list_line_1[i][0]=="|":
            list_line_1[i]=' '+list_line_1[i][1:]
        else:
            list_line_1[i]='└'+list_line_1[i][1:]

    text_1="\n".join(list_line_1)
    ans=var_name+"\n"+text_1


"""
print(text_1)
+[P函数](,P代码)

"""
## end
#1476, 845:
"""
P代码:...
P代码b:...
P代码2:...
P代码3:...

"""
+写模块(_文本,_模块)->+[del](,+写模块)...
->的(写模块,P代码)...
->的(写模块,P代码2)->的(写模块,P代码3)...

->+[临时文本]#内部->[]{
    []=>内部(_模块,_模块1)->_模块1=>+[做](+[临时文本]#a,_模块1)...
        ->+[code](+[做],写模块)...
        ->+[python](Python,+[临时文本]#内部)->+[code](+[python],P代码2)...
        ->+[s]"text_a"(+[python],+[临时文本]#a)...
        ->+[s]"text_0"(+[python],+[临时文本]#内部)
}...

->_re"函数|内容|条件"(_模块,)->+[标题](_re,)...
->+[python](Python,_文本)->+[code](+[python],P代码)...
    ->+[s]"var_name"(+[python],_re)->+[s]"pt_name"(+[python],+[标题])...
    ->+[s]"text_0"(+[python],+[临时文本]#内部)...

->[]{
    []:->顺序(_模块,_模块1)->_模块1(,)...
        ->+[做](+[临时文本]#a,_模块1)->+[code](+[做],写模块)...
        ->+[python](Python,_文本)->+[code](+[python],P代码3)...
        ->+[s]"text_a"(+[python],+[临时文本]#a)...
        ->+[s]"text_0"(+[python],_文本),

    ->[]
}

## end
#1478, 105:
"""
写模块:...

"""
+描述模块(_凭依,_模块)->+[del](,+描述模块)...
->的(描述模块,写模块)...

->+[做](_凭依,_模块)->+[code](+[做],写模块)


## end
#1480, 12:

描述模块:...



## end
#1481, 380:
"""
收集行:...
P代码_自身:...

"""
+收集块(结构,观察)...

->观察(,_块)...
    ->+的(结构,+模块#0)->+模块#0"0,1,0,1"->[投影](,+的)->[投影](,+模块#0)...
    ->+的(结构,+内容)->+内容"┐"(+模块#0,)->[投影](,+的)->[投影](,+内容)...
->+[code]([想],收集行)->+[.]([想],+模块#0)->[想](结构,观察)...
->+[o](+收集块,+模块#0)...

->+[code]([python]#0,P代码_自身)...
->+[s]"func_name"([python]#0,+内容)->+[.]"bk0"([python]#0,+模块#0)...
->[python]#0(Python,+模块#0)



## end
#1483, 247:
"""
收集块:...

"""
+描述结构(_媒介,结构)->+操作(+描述结构,)...

->+记录描述(记忆,收集块)...
->的(_媒介,起点)->起点(,_块)->+观察(+结构块,_块)->[描述结构](_媒介,+观察)...
->+[code]([想],收集块)->[想](结构,+观察)->o([想],模块)...
->+起点(,模块)->+的(结构,+起点)->[投影](,+起点)->[投影](,+的)...

->+描述模块(,模块)->+的(+操作,+描述模块)


## end
#1486, 377:
"""
描述结构:...
库:...
+[新建阅读窗口](,库)

"""

+生成结构(_媒介,_凭依)->+[del](,+生成结构)...
->的(生成结构,描述结构)->的(生成结构,库)...

->[]{
    []:->的(_凭依,结构)->结构->+[删除结构](,结构),
    ->+的(_凭依,+结构)
}->的(_凭依,结构)...

->+[code]([想],描述结构)->[想](_媒介,结构)...
->操作([想],)->[]{
    []=>的(操作,_操作)->_操作(,_模块)->_模块=>[说]"操作: "(,_操作)...
        ->的(库,_条目)->_条目->[eq](_条目,_操作)...
        ->+[做](_凭依,_模块)->+[code](+[做],_条目)
}



## end
#1489, 55:


生成结构:...
整理结构:...
+[新建阅读窗口](,生成结构)
+[新建阅读窗口](,模块连线)


## end
#1490, 155:
"""

"""

+召唤规则(_题目,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_代码)...

->[==]"一般结构转结构文字"(,召唤星辰)...

->+整理结构(_题目,_代码)->+的(操作,+整理结构)...
->+生成结构(_题目,_代码)->+的(操作,+生成结构)



## end
#1493, 23:


召唤规则:...
降临规则:...




## end
#1496, 719:
┐
└lens
 └┐
  └init────set────get──────────────────────────────────────────────────────────────view────vars                      
                  └┐                                                                       └┐                        
                   └getShape────getRadius────getField                                       └r────R────U1────U2────U3
                                             field                                                                   
                                             └┐                                                                      
                                              └Ex────Ey────Ez────Bx────By────Bz                                      
## end
#1498, 222:
"""

"""

+召唤规则(_题目,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_代码)...

->[==]"一般结构转流程图"(,召唤星辰)...

->+整理结构(_题目,_代码)->+的(操作,+整理结构)...
->+模块连线(_题目,_代码)->+的(操作,+模块连线)...
->+布置位置(_题目,_代码)->+的(操作,+布置位置)...
->+生成结构(_题目,_代码)->+的(操作,+生成结构)



## end
#1500, 19230:
一般结构转流程图#0"

召唤规则:...
降临规则:...



"(,)
的#1""(一般结构转流程图#0,降临规则#2)
降临规则#2"

生成结构:...
布置位置:...
模块连线:...
整理结构:...
+[新建阅读窗口](,生成结构)
+[新建阅读窗口](,模块连线)

"(,)
的#3""(降临规则#2,布置位置#4)
布置位置#4"\"\"\"
描述结构:...
库:...
+[新建阅读窗口](,库)
+[新建阅读窗口](,描述结构)

\"\"\"

+布置位置(_媒介,_凭依)->+[del](,+布置位置)...
->的(布置位置,描述结构)->的(布置位置,库)...

->的(_凭依,结构)...
->+[code]([想],描述结构)->[想](_媒介,结构)...
->操作([想],)->[]{
    []=>的(操作,_操作)->_操作(,_模块)->_模块=>[说]\"操作: \"(,_操作)...
        ->的(库,_条目)->_条目->[eq](_条目,_操作)...
        ->+[做](_凭依,_模块)->+[code](+[做],_条目)
}


"(,)
的#5""(布置位置#4,描述结构#6)
描述结构#6"\"\"\"
绘制模块:...

\"\"\"
+描述结构(_媒介,结构)->+操作(+描述结构,)...

->的(结构,起点)->起点(,模块)...
->+[code]([想],绘制模块)->+[.]([想],+操作)->[想](结构,模块)


"(,)
的#7""(描述结构#6,绘制模块#8)
绘制模块#8"\"\"\"
模块类型:...

\"\"\"

+绘制模块(结构,模块)->.(+绘制模块,操作)...

->+结构->[]{
    []=>内部(模块,模块#2)->模块#2=>+[code]([想],绘制模块)->+[.]([想],操作)...
        ->[想](结构,模块#2)->结尾([想],模块#3)...
        ->+结尾(模块#2,模块#3)->+的(结构,+结尾)->[投影](,+的)->[投影](,+结尾):
            ->上一个(+结构,)...
                ->+上一个(+结构,模块#1)->模块#1->+[上一个](+结构,模块#2)...
                ->+相邻(模块#1,模块#2)->+的(结构,+相邻)->[投影](,+的)->[投影](,+相邻),
            ->+[上一个](+结构,模块#2)
}...

->[]{
    []:->顺序(模块,模块#2)->模块#2->+[code]([想],绘制模块)->+[.]([想],操作)...
        ->[想](结构,模块#2)->结尾([想],模块#3)->+结尾(+绘制模块,模块#3),
    ->+结尾(+绘制模块,模块)
}...

->+[code]([想]#0,模块类型)->[想]#0(操作,模块)


"(,)
的#9""(绘制模块#8,模块类型#10)
模块类型#10"\"\"\"
->+绘制运算(,模块)->+的(操作,+绘制运算),
    

\"\"\"

+模块类型(操作,模块)...

->[]{
    []:->内容(模块,)->[]{
        []:->[==]\"if\"(,内容)->+绘制如果(,模块)->+的(操作,+绘制如果),
        ->[==]\"else\"(,内容)->+绘制否则(,模块)->+的(操作,+绘制否则),
        ->[==]\"code\"(,内容)->+绘制运算(,模块)->+的(操作,+绘制运算)
    },
    ->条件(模块,)->+绘制条件(,模块)->+的(操作,+绘制条件),
    ->函数(模块,)->+绘制函数(,模块)->+的(操作,+绘制函数),
    ->+绘制运算(,模块)->+的(操作,+绘制运算)
}


"(,)
的#11""(布置位置#4,库#12)
库#12"
绘制如果:...
绘制条件:...
绘制否则:...
+[新建阅读窗口](,绘制如果)
将条目\"绘制条件\"复制为条目\"绘制否则\"

绘制函数:...
将条目\"绘制运算\"复制为条目\"绘制函数\"

绘制运算:...


"(,)
的#13""(库#12,绘制如果#14)
绘制如果#14"\"\"\"
M代码:...
M代码0:...
M代码2:...
M代码3:...

\"\"\"

+绘制如果(_凭依,模块)->+[del](,+绘制如果)...
->的(绘制如果,M代码)->的(绘制如果,M代码2)->的(绘制如果,M代码0)...
->的(绘制如果,M代码3)...

->+的(_凭依,+如果模块)->+在(+如果模块,+空间点)->+是(模块,+如果模块)...
->+的(+如果模块,+在)->+的(+如果模块,+空间点)->+的(模块,+是)...

->+[matlab](Matlab,+空间点)->+[.]\"siz0\"(+[matlab],模块)...
->[]{
    []:->顺序(模块#1,模块)->模块#1->是(模块#1,_模块1)->在(_模块1,空间点#1)...
        ->+[code](+[matlab],M代码)...
        ->+[.]\"siz1\"(+[matlab],模块#1)->+[.]\"pt1\"(+[matlab],空间点#1),

    ->内部(模块#2,模块)->模块#2->是(模块#2,_模块2)->在(_模块2,空间点#2)...
        ->+[code](+[matlab],M代码2)...
        ->+[.]\"siz1\"(+[matlab],模块#2)->+[.]\"pt1\"(+[matlab],空间点#2),

    ->+[code](+[matlab],M代码0)
}...

->+样式\"多边形\"(+如果模块,)->+的(+如果模块,+样式)...
->+的(+如果模块,+宽度)->+的(+如果模块,+长度)...
->+的(+如果模块,+x)->+的(+如果模块,+y)...

->+文字\"if\"->+的(_凭依,+文字)->+的(+如果模块,+文字)...
->+的(+文字,+文字位置)->+文字位置\"居中\"...
->+在(+文字,+空间点#2)->+的(+文字,+在)->+的(+文字,+空间点#2)...

->+[matlab](Matlab,+空间点#2)->+[code](+[matlab],M代码3)...
->+[.]\"pt0\"(+[matlab],+空间点)...
->+[o]\"W\"(+[matlab],+宽度)->+[o]\"L\"(+[matlab],+长度)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)


"(,)
的#15""(绘制如果#14,M代码#16)
M代码#16"%{

%}

ans=[0,-siz1(4)]+pt1;


"(,)
的#17""(绘制如果#14,M代码2#18)
M代码2#18"%{
记住\"Matlab\"
siz0
siz1
%}

ans=[0,-1]+pt1;



"(,)
的#19""(绘制如果#14,M代码0#20)
M代码0#20"%{

%}

ans=[0,0];


"(,)
的#21""(绘制如果#14,M代码3#22)
M代码3#22"%{

%}

W=2;
L=1-0.3;

x=[-1,0,1,0]*W/2;
y=-[1/2,0,1/2,1]*L;

ans=pt0+[0,-1/2]*L;
"(,)
的#23""(库#12,绘制否则#24)
绘制否则#24"\"\"\"
M代码:...
M代码0:...
M代码2:...
M代码3:...

保存:...

\"\"\"

+绘制否则(_凭依,模块)->+[del](,+绘制否则)...
->的(绘制否则,M代码2)->的(绘制否则,M代码0)...
->的(绘制否则,M代码3)...

->+的(_凭依,+否则模块)->+在(+否则模块,+空间点)->+是(模块,+否则模块)...
->+的(+否则模块,+在)->+的(+否则模块,+空间点)->+的(模块,+是)...

->+[修改内容]\"else\"(,+否则模块)...

->+[matlab](Matlab,+空间点)->+[.]\"siz0\"(+[matlab],模块)...
->[]{
    []:->内部(模块#2,模块)->模块#2->是(模块#2,_模块2)->在(_模块2,空间点#2)...
        ->+[code](+[matlab],M代码2)...
        ->+[.]\"siz1\"(+[matlab],模块#2)->+[.]\"pt1\"(+[matlab],空间点#2),

    ->+[code](+[matlab],M代码0)
}


"(,)
的#25""(绘制否则#24,M代码0#26)
M代码0#26"%{

%}

ans=[0,0];


"(,)
的#27""(绘制否则#24,M代码2#28)
M代码2#28"%{
记住\"Matlab\"
siz0
siz1
%}

ans=[siz1(1)/2-siz0(3)/2,-0.7]+pt1;



"(,)
的#29""(绘制否则#24,M代码#30)
M代码#30"%{

%}

ans=[siz0(1),0]+pt1;


"(,)
的#31""(绘制否则#24,M代码3#32)
M代码3#32"%{

%}

W=siz0(3);
L=siz0(4);

x=[-1,1,1,-1]*W/2;
y=-[0,0,1,1]*L;

"(,)
的#33""(绘制否则#24,保存#34)
保存#34"\"\"\"
M代码:...
M代码0:...
M代码2:...
M代码3:...

保存:...

\"\"\"

+绘制否则(_凭依,模块)->+[del](,+绘制否则)...
->的(绘制否则,M代码2)->的(绘制否则,M代码0)...
->的(绘制否则,M代码3)...

->+的(_凭依,+否则模块)->+在(+否则模块,+空间点)->+是(模块,+否则模块)...
->+的(+否则模块,+在)->+的(+否则模块,+空间点)->+的(模块,+是)...

->+样式\"多边形\"(+否则模块,)->+的(+否则模块,+样式)...
->+的(+否则模块,+宽度)->+的(+否则模块,+长度)...
->+的(+否则模块,+x)->+的(+否则模块,+y)...

->+[matlab](Matlab,)->+[code](+[matlab],M代码3)->+[.]\"siz0\"(+[matlab],模块)...
->+[o]\"W\"(+[matlab],+宽度)->+[o]\"L\"(+[matlab],+长度)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)...

->+[matlab](Matlab,+空间点)...
->[]{
    []:->内部(模块#2,模块)->模块#2->是(模块#2,_模块2)->在(_模块2,空间点#2)...
        ->+[code](+[matlab],M代码2)...
        ->+[.]\"siz1\"(+[matlab],模块#2)->+[.]\"pt1\"(+[matlab],空间点#2),

    ->+[code](+[matlab],M代码0)
}


"(,)
的#35""(库#12,绘制函数#36)
绘制函数#36"\"\"\"
M代码:...
M代码0:...
M代码2:...
M代码3:...

\"\"\"

+绘制函数(_凭依,模块)->+[del](,+绘制函数)...
->的(绘制函数,M代码)->的(绘制函数,M代码2)->的(绘制函数,M代码0)...
->的(绘制函数,M代码3)...

->函数(模块,)...
->+的(_凭依,+函数模块)->+在(+函数模块,+空间点)->+是(模块,+函数模块)...
->+的(+函数模块,+在)->+的(+函数模块,+空间点)->+的(模块,+是)...

->+[matlab](Matlab,+空间点)->+[.]\"siz0\"(+[matlab],模块)...
->[]{
    []:->顺序(模块#1,模块)->模块#1->是(模块#1,_模块1)->在(_模块1,空间点#1)...
        ->+[code](+[matlab],M代码)...
        ->+[.]\"siz1\"(+[matlab],模块#1)->+[.]\"pt1\"(+[matlab],空间点#1),

    ->内部(模块#2,模块)->模块#2->是(模块#2,_模块2)->在(_模块2,空间点#2)...
        ->+[code](+[matlab],M代码2)...
        ->+[.]\"siz1\"(+[matlab],模块#2)->+[.]\"pt1\"(+[matlab],空间点#2),

    ->+[code](+[matlab],M代码0)
}...

->+样式\"多边形\"(+函数模块,)->+的(+函数模块,+样式)...
->+的(+函数模块,+宽度)->+的(+函数模块,+长度)...
->+的(+函数模块,+x)->+的(+函数模块,+y)...

->+文字->[m_text](函数,+文字)->+的(_凭依,+文字)->+的(+函数模块,+文字)...
->+的(+文字,+文字位置)->+文字位置\"居中\"...
->+在(+文字,+空间点#2)->+的(+文字,+在)->+的(+文字,+空间点#2)...

->+[matlab](Matlab,+空间点#2)->+[code](+[matlab],M代码3)...
->+[.]\"pt0\"(+[matlab],+空间点)...
->+[o]\"W\"(+[matlab],+宽度)->+[o]\"L\"(+[matlab],+长度)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)

"(,)
的#37""(绘制函数#36,M代码0#38)
M代码0#38"%{

%}

ans=[0,0];


"(,)
的#39""(绘制函数#36,M代码2#40)
M代码2#40"%{
记住\"Matlab\"
siz0
siz1
%}

ans=[0,-siz1(2)]+pt1;



"(,)
的#41""(绘制函数#36,M代码#42)
M代码#42"%{

%}

ans=[0,-siz1(4)]+pt1;


"(,)
的#43""(绘制函数#36,M代码3#44)
M代码3#44"%{

%}

W=siz0(1);
L=siz0(2);

x=[-1,1,1,-1]*W/2;
y=[0,0,-1,-1]*L;

% ans=pt0+[-1,0]*W/2+[1,1];
ans=pt0+[0,-0.5];

"(,)
的#45""(库#12,绘制运算#46)
绘制运算#46"\"\"\"
M代码:...
M代码0:...
M代码2:...
M代码3:...

\"\"\"

+绘制运算(_凭依,模块)->+[del](,+绘制运算)...
->的(绘制运算,M代码)->的(绘制运算,M代码2)->的(绘制运算,M代码0)...
->的(绘制运算,M代码3)...

->+的(_凭依,+运算模块)->+在(+运算模块,+空间点)->+是(模块,+运算模块)...
->+的(+运算模块,+在)->+的(+运算模块,+空间点)->+的(模块,+是)...

->+[matlab](Matlab,+空间点)->+[.]\"siz0\"(+[matlab],模块)...
->[]{
    []:->顺序(模块#1,模块)->模块#1->是(模块#1,_模块1)->在(_模块1,空间点#1)...
        ->+[code](+[matlab],M代码)...
        ->+[.]\"siz1\"(+[matlab],模块#1)->+[.]\"pt1\"(+[matlab],空间点#1),

    ->内部(模块#2,模块)->模块#2->是(模块#2,_模块2)->在(_模块2,空间点#2)...
        ->+[code](+[matlab],M代码2)...
        ->+[.]\"siz1\"(+[matlab],模块#2)->+[.]\"pt1\"(+[matlab],空间点#2),

    ->+[code](+[matlab],M代码0)
}...


->+样式\"多边形\"(+运算模块,)->+的(+运算模块,+样式)...
->+的(+运算模块,+宽度)->+的(+运算模块,+长度)...
->+的(+运算模块,+x)->+的(+运算模块,+y)...

->+文字\"code\"->+的(_凭依,+文字)->+的(+运算模块,+文字)...
->+的(+文字,+文字位置)->+文字位置\"居中\"...
->+在(+文字,+空间点#2)->+的(+文字,+在)->+的(+文字,+空间点#2)...

->+[matlab](Matlab,+空间点#2)->+[code](+[matlab],M代码3)...
->+[.]\"pt0\"(+[matlab],+空间点)...
->+[o]\"W\"(+[matlab],+宽度)->+[o]\"L\"(+[matlab],+长度)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)


"(,)
的#47""(绘制运算#46,M代码#48)
M代码#48"%{

%}

ans=[0,-siz1(4)]+pt1;


"(,)
的#49""(绘制运算#46,M代码2#50)
M代码2#50"%{
记住\"Matlab\"
siz0
siz1
%}

ans=[0,-1]+pt1;



"(,)
的#51""(绘制运算#46,M代码0#52)
M代码0#52"%{

%}

ans=[0,0];


"(,)
的#53""(绘制运算#46,M代码3#54)
M代码3#54"%{

%}

W=siz0(3)-1;
L=siz0(4)-0.3;

x=[-1,1,1,-1]*W/2;
y=-[0,0,1,1]*L;

ans=pt0+[0,-1/2]*L;"(,)
的#55""(库#12,绘制条件#56)
绘制条件#56"\"\"\"
M代码:...
M代码0:...
M代码2:...
M代码3:...

保存:...

\"\"\"

+绘制条件(_凭依,模块)->+[del](,+绘制条件)...
->的(绘制条件,M代码)->的(绘制条件,M代码2)->的(绘制条件,M代码0)...
->的(绘制条件,M代码3)...

->+的(_凭依,+条件模块)->+在(+条件模块,+空间点)->+是(模块,+条件模块)...
->+的(+条件模块,+在)->+的(+条件模块,+空间点)->+的(模块,+是)...

->条件(模块,)->+[修改内容](条件,+条件模块)...
->+[matlab](Matlab,+空间点)->+[.]\"siz0\"(+[matlab],模块)...
->[]{
    []:->相邻(模块,模块#1)->模块#1->是(模块#1,_模块1)->在(_模块1,空间点#1)...
        ->+[code](+[matlab],M代码)...
        ->+[.]\"siz1\"(+[matlab],模块#1)->+[.]\"pt1\"(+[matlab],空间点#1),

    ->内部(模块#2,模块)->模块#2->是(模块#2,_模块2)->在(_模块2,空间点#2)...
        ->+[code](+[matlab],M代码2)...
        ->+[.]\"siz1\"(+[matlab],模块#2)->+[.]\"pt1\"(+[matlab],空间点#2),

    ->+[code](+[matlab],M代码0)
}


"(,)
的#57""(绘制条件#56,M代码#58)
M代码#58"%{
-siz0(3)/2
%}

ans=[-siz0(1)/2-siz1(1)/2,0]+pt1;


"(,)
的#59""(绘制条件#56,M代码2#60)
M代码2#60"%{
记住\"Matlab\"
siz0
siz1
%}

ans=[siz1(1)/2-siz0(3)/2,-0.7]+pt1;



"(,)
的#61""(绘制条件#56,M代码0#62)
M代码0#62"%{

%}

ans=[0,0];


"(,)
的#63""(绘制条件#56,M代码3#64)
M代码3#64"%{

%}

W=siz0(3);
L=siz0(4);

x=[-1,1,1,-1]*W/2;
y=-[0,0,1,1]*L;

"(,)
的#65""(绘制条件#56,保存#66)
保存#66"\"\"\"
M代码:...
M代码0:...
M代码2:...
M代码3:...

\"\"\"

+绘制条件(_凭依,模块)->+[del](,+绘制条件)...
->的(绘制条件,M代码)->的(绘制条件,M代码2)->的(绘制条件,M代码0)...
->的(绘制条件,M代码3)...

->+的(_凭依,+条件模块)->+在(+条件模块,+空间点)->+是(模块,+条件模块)...
->+的(+条件模块,+在)->+的(+条件模块,+空间点)->+的(模块,+是)...

->+样式\"多边形\"(+条件模块,)->+的(+条件模块,+样式)...
->+的(+条件模块,+宽度)->+的(+条件模块,+长度)...
->+的(+条件模块,+x)->+的(+条件模块,+y)...

->+[matlab](Matlab,)->+[code](+[matlab],M代码3)->+[.]\"siz0\"(+[matlab],模块)...
->+[o]\"W\"(+[matlab],+宽度)->+[o]\"L\"(+[matlab],+长度)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)...

->+[matlab](Matlab,+空间点)...
->[]{
    []:->相邻(模块,模块#1)->模块#1->是(模块#1,_模块1)->在(_模块1,空间点#1)...
        ->+[code](+[matlab],M代码)...
        ->+[.]\"siz1\"(+[matlab],模块#1)->+[.]\"pt1\"(+[matlab],空间点#1),

    ->内部(模块#2,模块)->模块#2->是(模块#2,_模块2)->在(_模块2,空间点#2)...
        ->+[code](+[matlab],M代码2)...
        ->+[.]\"siz1\"(+[matlab],模块#2)->+[.]\"pt1\"(+[matlab],空间点#2),

    ->+[code](+[matlab],M代码0)
}


"(,)
的#67""(降临规则#2,模块连线#68)
模块连线#68"\"\"\"
描述结构:...
库:...
+[新建阅读窗口](,库)
+[新建阅读窗口](,描述结构)

\"\"\"

+模块连线(_媒介,_凭依)->+[del](,+模块连线)...
->的(模块连线,描述结构)->的(模块连线,库)...

->的(_凭依,结构)...
->+[code]([想],描述结构)->[想](_媒介,结构)...
->操作([想],)->[]{
    []=>的(操作,_操作)->_操作(_模块1,_模块2)->_模块1->_模块2(,)...
        =>[说]\"连线: \"(,_操作)->的(库,_条目)->_条目->[eq](_条目,_操作)...
        ->+[做](_模块1,_模块2)->+[code](+[做],_条目)->+[.](+[做],_凭依)
}


"(,)
的#69""(模块连线#68,库#70)
库#70"+[删除结构](,库)


画顺序:...
画if开头:...
将条目\"画if开头\"复制为条目\"画if结尾\"

画if结尾:...

"(,)
的#71""(库#70,画if开头#72)
画if开头#72"\"\"\"
M代码:...

\"\"\"
+画if开头(模块#1,模块#2)->+[del](,+画if开头)...
->的(画if开头,M代码)...

->.(+画if开头,_凭依)...
->是(模块#1,_模块1)->在(_模块1,空间点#1)...
->是(模块#2,_模块2)->在(_模块2,空间点#2)...

->+的(_凭依,+连线)...
->+连线(_模块1,_模块2)->+样式\"曲线\"(+连线,)->+的(+连线,+样式)...
->+的(+连线,+x)->+的(+连线,+y)...

->+[matlab](Matlab,)->+[code](+[matlab],M代码)...
->+[.]\"pt1\"(+[matlab],空间点#1)->+[.]\"pt2\"(+[matlab],空间点#2)...
->+[.]\"siz1\"(+[matlab],模块#1)->+[.]\"siz2\"(+[matlab],模块#2)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)



"(,)
的#73""(画if开头#72,M代码#74)
M代码#74"%{

%}


Dy1=1-0.3;
Dy2=0.2;

x=[pt1(1),pt1(1),pt2(1)];
y=[pt1(2)-Dy1,pt2(2)-Dy2,pt2(2)-Dy2];


"(,)
的#75""(库#70,画顺序#76)
画顺序#76"\"\"\"
M代码:...

\"\"\"
+画顺序(模块#1,模块#2)->+[del](,+画顺序)...
->的(画顺序,M代码)...

->.(+画顺序,_凭依)...
->是(模块#1,_模块1)->在(_模块1,空间点#1)...
->是(模块#2,_模块2)->在(_模块2,空间点#2)...

->+的(_凭依,+连线)...
->+连线(_模块1,_模块2)->+样式\"折线\"(+连线,)->+的(+连线,+样式)...
->+的(+连线,+x)->+的(+连线,+y)...

->+[matlab](Matlab,)->+[code](+[matlab],M代码)...
->+[.]\"pt1\"(+[matlab],空间点#1)->+[.]\"pt2\"(+[matlab],空间点#2)...
->+[.]\"siz1\"(+[matlab],模块#1)->+[.]\"siz2\"(+[matlab],模块#2)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)



"(,)
的#77""(画顺序#76,M代码#78)
M代码#78"%{

%}


L=siz1(4)-0.3;

x=[pt1(1),pt2(1)];
y=[pt1(2)-L,pt2(2)];


"(,)
的#79""(库#70,画if结尾#80)
画if结尾#80"\"\"\"
M代码:...

\"\"\"
+画if结尾(模块#1,模块#2)->+[del](,+画if结尾)...
->的(画if结尾,M代码)...

->.(+画if结尾,_凭依)...
->是(模块#1,_模块1)->在(_模块1,空间点#1)...
->是(模块#2,_模块2)->在(_模块2,空间点#2)...

->+的(_凭依,+连线)...
->+连线(_模块1,_模块2)->+样式\"曲线\"(+连线,)->+的(+连线,+样式)...
->+的(+连线,+x)->+的(+连线,+y)...

->+[matlab](Matlab,)->+[code](+[matlab],M代码)...
->+[.]\"pt1\"(+[matlab],空间点#1)->+[.]\"pt2\"(+[matlab],空间点#2)...
->+[.]\"siz1\"(+[matlab],模块#1)->+[.]\"siz2\"(+[matlab],模块#2)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)



"(,)
的#81""(画if结尾#80,M代码#82)
M代码#82"%{
siz2
%}


Dy1=siz1(4)-0.3;
Dy2=siz2(4)-0.3;

x=[pt1(1),pt2(1),pt2(1)];
y=[pt1(2)-Dy1,pt1(2)-Dy1,pt2(2)-Dy2];

% x=[pt1(1),pt2(1)];
% y=[pt1(2)-Dy1,pt2(2)-Dy2];


"(,)
的#83""(模块连线#68,描述结构#84)
描述结构#84"\"\"\"
绘制模块:...

\"\"\"
+描述结构(_媒介,结构)->+操作(+描述结构,)...

->的(结构,起点)->起点(,模块)...
->+[code]([想],绘制模块)->+[.]([想],+操作)->[想](结构,模块)


"(,)
的#85""(描述结构#84,绘制模块#86)
绘制模块#86"\"\"\"
连线类型:...

\"\"\"

+绘制模块(结构,模块)->.(+绘制模块,操作)...

->+结构->[]{
    []=>内部(模块,模块#2)->模块#2=>+[code]([想],绘制模块)->+[.]([想],操作)...
        ->[想](结构,模块#2)
}...

->[]{
    []:->顺序(模块,模块#2)->模块#2->+[code]([想],绘制模块)->+[.]([想],操作)...
        ->[想](结构,模块#2),
    ->[]
}...

->+[code]([想]#0,连线类型)->[想]#0(操作,模块)


"(,)
的#87""(绘制模块#86,连线类型#88)
连线类型#88"\"\"\"


\"\"\"
+连线类型(操作,模块)...

->[]{
    []:->顺序(模块,模块#2)->模块#2->+画顺序(模块,模块#2)->+的(操作,+画顺序),
    ->[]
}...
->[]{
    []:->内容\"if\"(模块,)=>内部(模块,模块#2)->模块#2->结尾(模块#2,模块#3)...
        =>+画if开头(模块,模块#2)->+的(操作,+画if开头)...
        ->+画if结尾(模块,模块#3)->+的(操作,+画if结尾),
    ->[]
}


"(,)
的#89""(降临规则#2,整理结构#90)
整理结构#90"\"\"\"
...
->+[显示PPT场景]\"1\"(,_凭依)->+[PPT场景转H代码](_凭依,_凭依)

\"\"\"
+整理结构(_媒介,_凭依)->+[del](,+整理结构)...

->的(_凭依,召唤规则)->+[删除结构](,召唤规则)->+[del](,召唤规则)...
->的(_凭依,降临规则)->+[删除结构](,降临规则)->+[del](,降临规则)


"(,)
的#91""(降临规则#2,生成结构#92)
生成结构#92"\"\"\"
描述结构:...
库:...
+[新建阅读窗口](,库)

\"\"\"

+生成结构(_媒介,_凭依)->+[del](,+生成结构)...
->的(生成结构,描述结构)->的(生成结构,库)...

->[]{
    []:->的(_凭依,结构)->结构->+[删除结构](,结构),
    ->+的(_凭依,+结构)
}->的(_凭依,结构)...

->+[code]([想],描述结构)->[想](_媒介,结构)...
->操作([想],)->[]{
    []=>的(操作,_操作)->_操作(,_模块)->_模块=>[说]\"操作: \"(,_操作)...
        ->的(库,_条目)->_条目->[eq](_条目,_操作)...
        ->+[做](_凭依,_模块)->+[code](+[做],_条目)
}


"(,)
的#93""(生成结构#92,库#94)
库#94"
描述模块:...


"(,)
的#95""(库#94,描述模块#96)
描述模块#96"\"\"\"
写模块:...

\"\"\"
+描述模块(_凭依,_模块)->+[del](,+描述模块)...
->的(描述模块,写模块)...

->+[做](_凭依,_模块)->+[code](+[做],写模块)

"(,)
的#97""(描述模块#96,写模块#98)
写模块#98"\"\"\"
P代码:...
P代码b:...
P代码2:...
P代码3:...

\"\"\"
+写模块(_文本,_模块)->+[del](,+写模块)...
->的(写模块,P代码)...
->的(写模块,P代码2)->的(写模块,P代码3)...

->+[临时文本]#内部->[]{
    []=>内部(_模块,_模块1)->_模块1=>+[做](+[临时文本]#a,_模块1)...
        ->+[code](+[做],写模块)...
        ->+[python](Python,+[临时文本]#内部)->+[code](+[python],P代码2)...
        ->+[s]\"text_a\"(+[python],+[临时文本]#a)...
        ->+[s]\"text_0\"(+[python],+[临时文本]#内部)
}...

->_re\"函数|内容|条件\"(_模块,)->+[标题](_re,)...
->+[python](Python,_文本)->+[code](+[python],P代码)...
    ->+[s]\"var_name\"(+[python],_re)->+[s]\"pt_name\"(+[python],+[标题])...
    ->+[s]\"text_0\"(+[python],+[临时文本]#内部)...

->[]{
    []:->顺序(_模块,_模块1)->_模块1(,)...
        ->+[做](+[临时文本]#a,_模块1)->+[code](+[做],写模块)...
        ->+[python](Python,_文本)->+[code](+[python],P代码3)...
        ->+[s]\"text_a\"(+[python],+[临时文本]#a)...
        ->+[s]\"text_0\"(+[python],_文本),

    ->[]
}
"(,)
的#99""(写模块#98,P代码b#100)
P代码b#100""(,)
的#101""(写模块#98,P代码3#102)
P代码3#102"\"\"\"


\"\"\"

ans=text_0+\"\n\"+text_a
"(,)
的#103""(写模块#98,P代码2#104)
P代码2#104"\"\"\"
记住\"Python\"
+[P函数](,P代码2)
测试:...

\"\"\"
import numpy as np

ans=\"\"
pat_line_0=\"{s:─<{n}}\"
pat_line_1=\"{s: <{n}}\"
if text_0!=\"\":
    list_line_0=text_0.split(\"\n\")
    n_0=np.max([len(line) for line in list_line_0])
    l_0=len(list_line_0)
    list_line_a=text_a.split(\"\n\")
    n_a=np.max([len(line) for line in list_line_a])
    l_a=len(list_line_a)

    for i in range(np.max([l_a,l_0])):
        pat_line=pat_line_1

        if i>=l_a:
            line_a=pat_line.format(s=\" \",n=n_a)
        else:
            line_a=pat_line.format(s=list_line_a[i],n=n_a)
        
        if i>=l_0:
            line_0=pat_line.format(s=\" \",n=n_0)
        else:
            line_0=pat_line.format(s=list_line_0[i],n=n_0)

        if i==0:
            line_a=line_a.replace(\" \",\"─\")
            ans+=line_a+\"────\"+line_0+\"\n\"
        else:
            ans+=line_a+\"    \"+line_0+\"\n\"

    ans=ans[0:-1]
else:
    ans=text_a



"(,)
的#105""(P代码2#104,测试#106)
测试#106"\"\"\"
+[P函数](,测试)

\"\"\"
text_a=\"\"\"
aaa
c
v
\"\"\"
text_0=text_a

list_line=text_0.split(\"\n\")
list_ns=[len(line) for line in list_line]
print(list_ns)




\"\"\"
+[P函数](,测试)
print('{s:X<{n}}'.format(s=\"11\",n=10))
print(f'{\"dog\": <10}'+'1')
print(f'{\"%s\":X<10}'%(\"AAA\"))

\"\"\""(,)
的#107""(写模块#98,P代码#108)
P代码#108"\"\"\"
    text_0=str_a+text_0.replace(\"\n\",\"\n\"+str_a)
print(text_0)
print(text_1)
+[P函数](,P代码)

\"\"\"
# print(var_name,pt_name)
if text_0==\"\":
    ans=var_name
else:
    str_a=\"├\"
    list_line=text_0.split(\"\n\")
    list_line_1=[]
    n_last=0
    for i in range(len(list_line)):
        line=list_line[i]
        if line[0]==\"|\" or line[0]==\"├\" or line[0]==\"└\" or line[0]==\" \":
            line=\"|\"+line
        else:
            n_last=i
            line=\"├\"+line
        list_line_1.append(line)
    for i in range(n_last,len(list_line_1)):
        if list_line_1[i][0]==\"|\":
            list_line_1[i]=' '+list_line_1[i][1:]
        else:
            list_line_1[i]='└'+list_line_1[i][1:]

    text_1=\"\n\".join(list_line_1)
    ans=var_name+\"\n\"+text_1


\"\"\"
print(text_1)
+[P函数](,P代码)

\"\"\""(,)
的#109""(生成结构#92,描述结构#110)
描述结构#110"\"\"\"
收集块:...

\"\"\"
+描述结构(_媒介,结构)->+操作(+描述结构,)...

->+记录描述(记忆,收集块)...
->的(_媒介,起点)->起点(,_块)->+观察(+结构块,_块)->[描述结构](_媒介,+观察)...
->+[code]([想],收集块)->[想](结构,+观察)->o([想],模块)...
->+起点(,模块)->+的(结构,+起点)->[投影](,+起点)->[投影](,+的)...

->+描述模块(,模块)->+的(+操作,+描述模块)

"(,)
的#111""(描述结构#110,收集块#112)
收集块#112"\"\"\"
收集行:...

\"\"\"
+收集块(结构,观察)...

->观察(,_块)...
    ->+的(结构,+模块#0)->[投影](,+的)->[投影](,+模块#0)...
    ->+的(结构,+内容)->+内容\"-\"(+模块#0,)->[投影](,+的)->[投影](,+内容)...
->+[code]([想],收集行)->+[.]([想],+模块#0)->[想](结构,观察)...
->+[o](+收集块,+模块#0)


"(,)
的#113""(收集块#112,收集行#114)
收集行#114"\"\"\"
收集点:...

\"\"\"

+收集行(结构,观察)->.(+收集行,模块)...

->然后\"内部\"(观察,观察#0)...
    ->+[code]([想]#0,收集点)->[想]#0(结构,观察#0)->o([想]#0,模块#0)...
    ->+[o](+收集行,模块#0)...
->+内部(模块,模块#0)->+的(结构,+内部)->[投影](,+的)->[投影](,+内部)...

->[]{
    []=>然后\"平行\"(观察,观察#1)->观察#1(,)...
        =>+[code]([想],收集行)->+[.]([想],模块)->[想](结构,观察#1)
}



"(,)
的#115""(收集行#114,收集点#116)
收集点#116"\"\"\"


\"\"\"

+收集点(结构,观察)...
->记录描述(记忆,收集块)...

->观察(,_块)->.\"名字\"(观察,name)...
    ->+的(结构,+模块)->+模块(,_块)->[投影](,+的)->[投影](,+模块)...
    ->+的(结构,+内容)->+内容(+模块,)->[m_text](name,+内容)...
        ->[投影](,+的)->[投影](,+内容)...
->[]{
    []=>然后\"子集\"(观察,观察#1)->观察#1(,)...
        =>+[code]([想]#1,收集块)->[想]#1(结构,观察#1)->o([想]#1,模块#1)...
        ->+内部(+模块,模块#1)->+的(结构,+内部)->[投影](,+的)->[投影](,+内部)
}...
->[]{
    []=>然后\"顺序\"(观察,观察#1)->观察#1(,)...
        =>+[code]([想]#1,收集点)->[想]#1(结构,观察#1)->o([想]#1,模块#1)...
        ->+顺序(+模块,模块#1)->+的(结构,+顺序)->[投影](,+的)->[投影](,+顺序)
}...
->+[o](+收集点,+模块)


"(,)
的#117""(一般结构转流程图#0,召唤规则#118)
召唤规则#118"\"\"\"

\"\"\"

+召唤规则(_题目,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_代码)...

->[==]\"一般结构转流程图\"(,召唤星辰)...

->+整理结构(_题目,_代码)->+的(操作,+整理结构)...
->+模块连线(_题目,_代码)->+的(操作,+模块连线)...
->+布置位置(_题目,_代码)->+的(操作,+布置位置)...
->+生成结构(_题目,_代码)->+的(操作,+生成结构)


"(,)

## end
#1502, 440:
"""
收集点:...
P代码_内部:...

"""

+收集行(结构,观察)->.(+收集行,模块)...

->然后"内部"(观察,观察#0)...
    ->+[code]([想]#0,收集点)->[想]#0(结构,观察#0)->o([想]#0,模块#0)...
    ->+[o](+收集行,模块#0)...
->+内部(模块,模块#0)->+的(结构,+内部)->[投影](,+的)->[投影](,+内部)...

->[]{
    []=>然后"平行"(观察,观察#1)->观察#1(,)...
        =>+[code]([想],收集行)->+[.]([想],模块)->[想](结构,观察#1)->o([想],模块#1)
}...
->+[code]([python],P代码_内部)...
->+[.]"bk0"([python],模块)->+[.]"bk1"([python],模块#0)...
->[python](Python,模块)




## end
#1504, 1011:
"""
P代码_内部:...
P代码_自身:...
P代码_传递:...

"""

+收集点(结构,观察)...
->记录描述(记忆,收集块)...

->观察(,_块)->."名字"(观察,name)...
    ->+的(结构,+模块)->+模块"0,1,0,1"(,_块)->[投影](,+的)->[投影](,+模块)...
    ->+的(结构,+内容)->+内容(+模块,)->[m_text](name,+内容)...
        ->[投影](,+的)->[投影](,+内容)...
->[]{
    []=>然后"子集"(观察,观察#1)->观察#1(,)...
        =>+[code]([想]#1,收集块)->[想]#1(结构,观察#1)->o([想]#1,模块#1)...
        ->+内部"子集"(+模块,模块#1)->+的(结构,+内部)->[投影](,+的)->[投影](,+内部)...
        ->+[code]([python],P代码_内部)...
        ->+[.]"bk0"([python],+模块)->+[.]"bk1"([python],模块#1)...
        ->[python](Python,+模块)
}...

->+[code]([python]#0,P代码_自身)...
->+[s]"func_name"([python]#0,+内容)->+[.]"bk0"([python]#0,+模块)...
->[python]#0(Python,+模块)...

->[]{
    []=>然后"顺序"(观察,观察#1)->观察#1(,)...
        =>+[code]([想]#1,收集点)->[想]#1(结构,观察#1)->o([想]#1,模块#1)...
        ->+顺序(+模块,模块#1)->+的(结构,+顺序)->[投影](,+的)->[投影](,+顺序)...
        ->+[code]([python],P代码_传递)...
        ->+[.]"bk0"([python],+模块)->+[.]"bk1"([python],模块#1)...
        ->[python](Python,+模块)
}...
->+[o](+收集点,+模块)



## end
#1506, 51:
https://en.wikipedia.org/wiki/Box-drawing_character
## end
#1509, 244:
"""
记住"Python"
print(func_type)

"""

state=True

bk0[0]=np.max([len(func_name),bk0[0]])
bk0[2]=np.max([len(func_name),bk0[0]])


# if func_type=="如果":
#     bk0[1]=bk0[1]+1
# elif func_type=="函数":
#     bk0[1]=bk0[1]+1
bk0[3]=bk0[1]

ans=bk0


## end
#1511, 75:
"""


"""
state=True
bk0[1]+=bk1[1]
bk0[0]=np.max([bk0[2],bk1[0]])
ans=bk0

## end
#1513, 141:
"""
记住"Python"
print(np.max([1,2]))
print(func_name)

"""

state=True
bk0[0]+=bk1[0]
bk0[1]=np.max([bk0[1],bk1[1]])
# bk1[2]=bk1[1]

ans=bk0

## end
#1514, 22:
-0.0, -0.0, -0.7, -0.7
## end
#1516, 20:
-0.0, 0.0, 0.0, -0.0
## end
#1518, 3:
0.7
## end
#1520, 3:
0.0
## end
#1524, 3:
多边形
## end
#1525, 22:
-0.0, -0.0, -0.7, -0.7
## end
#1527, 20:
0.5, -0.5, -0.5, 0.5
## end
#1529, 3:
0.7
## end
#1531, 4:
-1.0
## end
#1535, 3:
多边形
## end
#1536, 22:
-0.0, -0.0, -0.7, -0.7
## end
#1538, 20:
-0.0, 0.0, 0.0, -0.0
## end
#1540, 3:
0.7
## end
#1542, 3:
0.0
## end
#1546, 3:
多边形
## end
#1547, 22:
-0.0, -0.0, -0.7, -0.7
## end
#1549, 20:
-0.0, 0.0, 0.0, -0.0
## end
#1551, 3:
0.7
## end
#1553, 3:
0.0
## end
#1557, 3:
多边形
## end
#1558, 22:
-0.0, -0.0, -0.7, -0.7
## end
#1560, 20:
-0.0, 0.0, 0.0, -0.0
## end
#1562, 3:
0.7
## end
#1564, 3:
0.0
## end
#1568, 3:
多边形
## end
#1570, 244:
"""
记住"Python"
print(func_type)

"""

state=True

bk0[0]=np.max([len(func_name),bk0[0]])
bk0[2]=np.max([len(func_name),bk0[0]])


# if func_type=="如果":
#     bk0[1]=bk0[1]+1
# elif func_type=="函数":
#     bk0[1]=bk0[1]+1
bk0[3]=bk0[1]

ans=bk0


## end
#1572, 141:
"""
记住"Python"
print(np.max([1,2]))
print(func_name)

"""

state=True
bk0[0]+=bk1[0]
bk0[1]=np.max([bk0[1],bk1[1]])
# bk1[2]=bk1[1]

ans=bk0

## end
#1573, 222:
"""

"""

+召唤规则(_题目,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_代码)...

->[==]"一般结构转分类图"(,召唤星辰)...

->+整理结构(_题目,_代码)->+的(操作,+整理结构)...
->+模块连线(_题目,_代码)->+的(操作,+模块连线)...
->+布置位置(_题目,_代码)->+的(操作,+布置位置)...
->+生成结构(_题目,_代码)->+的(操作,+生成结构)



## end
#1574, 171:
"""
记住"Python"
print(func_type)

"""

state=True

bk0[0]=np.max([len(func_name),bk0[0]])
bk0[2]=np.max([len(func_name),bk0[0]])

bk0[2]=bk0[0]+2
bk0[0]=bk0[0]+2

ans=bk0


## end
#1575, 141:
"""
记住"Python"
print(np.max([1,2]))
print(func_name)

"""

state=True
bk0[1]+=bk1[1]
bk0[0]=np.max([bk0[0],bk1[0]])
# bk1[2]=bk1[1]

ans=bk0

## end
#1576, 185:
"""
记住"Python"
print(func_type)

"""

state=True

bk0[0]=np.max([len(func_name),bk0[0]])
bk0[2]=np.max([len(func_name),bk0[0]])

bk0[3]=bk0[1]
bk0[2]=bk0[0]+2
bk0[0]=bk0[0]+2

ans=bk0


## end
#1577, 75:
"""


"""
state=True
bk0[0]+=bk1[0]
bk0[1]=np.max([bk0[3],bk1[1]])
ans=bk0

## end
#1578, 143:
"""
记住"Python"
print(func_type)

"""

state=True

l_str=2
bk0[0]=np.max([l_str,bk0[0]])
bk0[2]=np.max([l_str,bk0[0]])

bk0[3]=bk0[1]

ans=bk0


## end
#1582, 988:
"""
P代码_内部:...
P代码_自身:...
P代码_传递:...

"""

+收集点(结构,观察)...
->记录描述(记忆,收集块)...

->观察(,_块)->."名字"(观察,name)...
    ->+的(结构,+模块)->+模块"0,1,0,1"(,_块)->[投影](,+的)->[投影](,+模块)...
    ->+的(结构,+内容)->+内容(+模块,)->[m_text](name,+内容)...
        ->[投影](,+的)->[投影](,+内容)...

->Python->[]{
    []:->然后"子集"(观察,观察#1)->观察#1(,)...
        ->+[code]([想]#1,收集块)->+[.]([想]#1,+模块)->[想]#1(结构,观察#1)...
        ->+[code]([python]#1,P代码_内部)...
        ->+[s]"func_name"([python]#1,+内容)->+[.]"bk0"([python]#1,+模块)...
        ->[python]#1(Python,+模块),

    ->+[code]([python]#0,P代码_自身)...
        ->+[s]"func_name"([python]#0,+内容)->+[.]"bk0"([python]#0,+模块)...
        ->[python]#0(Python,+模块)
}...

->[]{
    []=>然后"顺序"(观察,观察#1)->观察#1(,)...
        =>+[code]([想]#1,收集点)->[想]#1(结构,观察#1)->o([想]#1,模块#1)...
        ->+顺序(+模块,模块#1)->+的(结构,+顺序)->[投影](,+的)->[投影](,+顺序)...
        ->+[code]([python],P代码_传递)...
        ->+[.]"bk0"([python],+模块)->+[.]"bk1"([python],模块#1)...
        ->[python](Python,+模块)
}...
->+[o](+收集点,+模块)



## end
#1585, 440:
"""
收集点:...
P代码_内部:...

"""

+收集行(结构,观察)->.(+收集行,模块)...

->然后"内部"(观察,观察#0)...
    ->+[code]([想]#0,收集点)->[想]#0(结构,观察#0)->o([想]#0,模块#0)...
    ->+[o](+收集行,模块#0)...
->+内部(模块,模块#0)->+的(结构,+内部)->[投影](,+的)->[投影](,+内部)...

->[]{
    []=>然后"平行"(观察,观察#1)->观察#1(,)...
        =>+[code]([想],收集行)->+[.]([想],模块)->[想](结构,观察#1)->o([想],模块#1)
}...
->+[code]([python],P代码_内部)...
->+[.]"bk0"([python],模块)->+[.]"bk1"([python],模块#0)...
->[python](Python,模块)




## end
#1588, 342:
"""
收集行:...
P代码_自身:...

"""
+收集块(结构,观察)...

->Python->[]{
    []:->.(+收集块,模块)->模块,

    ->+[.](+收集块,+模块#0)...
        ->+的(结构,+模块#0)->+模块#0"2,1,2,1"->[投影](,+的)->[投影](,+模块#0)...
        ->+的(结构,+内容)->+内容"起点"(+模块#0,)->[投影](,+的)->[投影](,+内容)
}->.(+收集块,模块#0)...

->观察(,_块)...
->+[code]([想],收集行)->+[.]([想],模块#0)->[想](结构,观察)...
->+[o](+收集块,模块#0)




## end
#1590, 247:
"""
收集块:...

"""
+描述结构(_媒介,结构)->+操作(+描述结构,)...

->+记录描述(记忆,收集块)...
->的(_媒介,起点)->起点(,_块)->+观察(+结构块,_块)->[描述结构](_媒介,+观察)...
->+[code]([想],收集块)->[想](结构,+观察)->o([想],模块)...
->+起点(,模块)->+的(结构,+起点)->[投影](,+起点)->[投影](,+的)...

->+描述模块(,模块)->+的(+操作,+描述模块)


## end
#1591, 792:
"""
    text_0=str_a+text_0.replace("\n","\n"+str_a)
print(text_0)
print(text_1)
+[P函数](,P代码)

"""
# print(var_name,pt_name)
if text_0=="":
    ans=var_name
else:
    str_a="├"
    list_line=text_0.split("\n")
    list_line_1=[]
    n_last=0
    for i in range(len(list_line)):
        line=list_line[i]
        if line[0]=="|" or line[0]=="├" or line[0]=="└" or line[0]==" ":
            line="|"+line
        else:
            n_last=i
            line="├"+line
        list_line_1.append(line)
    for i in range(n_last,len(list_line_1)):
        if list_line_1[i][0]=="|":
            list_line_1[i]=' '+list_line_1[i][1:]
        else:
            list_line_1[i]='└'+list_line_1[i][1:]

    text_1="\n".join(list_line_1)
    ans=var_name+"\n"+text_1


"""
print(text_1)
+[P函数](,P代码)

"""
## end
#1592, 265:
"""
+[P函数](,测试)

"""
text_a="""
aaa
c
v
"""
text_0=text_a

list_line=text_0.split("\n")
list_ns=[len(line) for line in list_line]
print(list_ns)




"""
+[P函数](,测试)
print('{s:X<{n}}'.format(s="11",n=10))
print(f'{"dog": <10}'+'1')
print(f'{"%s":X<10}'%("AAA"))

"""
## end
#1594, 915:
"""
记住"Python"
+[P函数](,P代码2)
测试:...

"""
import numpy as np

ans=""
pat_line_0="{s:─<{n}}"
pat_line_1="{s: <{n}}"
if text_0!="":
    list_line_0=text_0.split("\n")
    n_0=np.max([len(line) for line in list_line_0])
    l_0=len(list_line_0)
    list_line_a=text_a.split("\n")
    n_a=np.max([len(line) for line in list_line_a])
    l_a=len(list_line_a)

    for i in range(np.max([l_a,l_0])):
        pat_line=pat_line_1

        if i>=l_a:
            line_a=pat_line.format(s=" ",n=n_a)
        else:
            line_a=pat_line.format(s=list_line_a[i],n=n_a)
        
        if i>=l_0:
            line_0=pat_line.format(s=" ",n=n_0)
        else:
            line_0=pat_line.format(s=list_line_0[i],n=n_0)

        if i==0:
            line_a=line_a.replace(" ","─")
            ans+=line_a+"────"+line_0+"\n"
        else:
            ans+=line_a+"    "+line_0+"\n"

    ans=ans[0:-1]
else:
    ans=text_a




## end
#1595, 34:
"""


"""

ans=text_0+"\n"+text_a

## end
#1601, 845:
"""
P代码:...
P代码b:...
P代码2:...
P代码3:...

"""
+写模块(_文本,_模块)->+[del](,+写模块)...
->的(写模块,P代码)...
->的(写模块,P代码2)->的(写模块,P代码3)...

->+[临时文本]#内部->[]{
    []=>内部(_模块,_模块1)->_模块1=>+[做](+[临时文本]#a,_模块1)...
        ->+[code](+[做],写模块)...
        ->+[python](Python,+[临时文本]#内部)->+[code](+[python],P代码2)...
        ->+[s]"text_a"(+[python],+[临时文本]#a)...
        ->+[s]"text_0"(+[python],+[临时文本]#内部)
}...

->_re"函数|内容|条件"(_模块,)->+[标题](_re,)...
->+[python](Python,_文本)->+[code](+[python],P代码)...
    ->+[s]"var_name"(+[python],_re)->+[s]"pt_name"(+[python],+[标题])...
    ->+[s]"text_0"(+[python],+[临时文本]#内部)...

->[]{
    []:->顺序(_模块,_模块1)->_模块1(,)...
        ->+[做](+[临时文本]#a,_模块1)->+[code](+[做],写模块)...
        ->+[python](Python,_文本)->+[code](+[python],P代码3)...
        ->+[s]"text_a"(+[python],+[临时文本]#a)...
        ->+[s]"text_0"(+[python],_文本),

    ->[]
}

## end
#1603, 105:
"""
写模块:...

"""
+描述模块(_凭依,_模块)->+[del](,+描述模块)...
->的(描述模块,写模块)...

->+[做](_凭依,_模块)->+[code](+[做],写模块)


## end
#1605, 12:

描述模块:...



## end
#1608, 377:
"""
描述结构:...
库:...
+[新建阅读窗口](,库)

"""

+生成结构(_媒介,_凭依)->+[del](,+生成结构)...
->的(生成结构,描述结构)->的(生成结构,库)...

->[]{
    []:->的(_凭依,结构)->结构->+[删除结构](,结构),
    ->+的(_凭依,+结构)
}->的(_凭依,结构)...

->+[code]([想],描述结构)->[想](_媒介,结构)...
->操作([想],)->[]{
    []=>的(操作,_操作)->_操作(,_模块)->_模块=>[说]"操作: "(,_操作)...
        ->的(库,_条目)->_条目->[eq](_条目,_操作)...
        ->+[做](_凭依,_模块)->+[code](+[做],_条目)
}



## end
#1609, 187:
"""

"""
+整理结构(_媒介,_凭依)->+[del](,+整理结构)...

->的(_凭依,召唤规则)->+[删除结构](,召唤规则)->+[del](,召唤规则)...
->的(_凭依,降临规则)->+[删除结构](,降临规则)->+[del](,降临规则)...
->+[显示PPT场景]"1"(,_凭依)->+[PPT场景转H代码](_凭依,_凭依)



## end
#1610, 249:
"""
保存:...

"""
+连线类型(操作,模块)...

->[]{
    []:->顺序(模块,模块#2)->模块#2{[]=>内部(模块,)}...
        ->+画顺序(模块,模块#2)->+的(操作,+画顺序),
    ->[]
}...
->[]{
    []:->内容(模块,)=>内部(模块,模块#2)->模块#2->结尾(模块#2,模块#3)...
        =>+画if开头(模块,模块#2)->+的(操作,+画if开头),
    ->[]
}



## end
#1612, 297:
"""
连线类型:...

"""

+绘制模块(结构,模块)->.(+绘制模块,操作)...

->+结构->[]{
    []=>内部(模块,模块#2)->模块#2=>+[code]([想],绘制模块)->+[.]([想],操作)...
        ->[想](结构,模块#2)
}...

->[]{
    []:->顺序(模块,模块#2)->模块#2->+[code]([想],绘制模块)->+[.]([想],操作)...
        ->[想](结构,模块#2),
    ->[]
}...

->+[code]([想]#0,连线类型)->[想]#0(操作,模块)



## end
#1614, 121:
"""
绘制模块:...

"""
+描述结构(_媒介,结构)->+操作(+描述结构,)...

->的(结构,起点)->起点(,模块)...
->+[code]([想],绘制模块)->+[.]([想],+操作)->[想](结构,模块)



## end
#1615, 349:
%{
siz2
%}

L=1-0.3;
W=2-0.5;

Dy1=siz1(3)-0.15;
Dy2=siz2(3)-0.3;

% x=[pt1(1),pt1(1),pt2(1),pt2(1)];
% y=[pt1(2)-siz1(4),pt1(2)-Dy1,pt1(2)-Dy1,pt2(2)-Dy2];

x=[pt1(1)-W/2+siz1(3),pt1(1)-W/2+Dy1,pt1(1)-W/2+Dy1,pt2(1)+W/2];
y=[pt1(2),pt1(2),pt2(2),pt2(2)]-L/2;

if flag2==1
    x(end)=[];
    y(end)=[];
end
if flag1==1
    x(1)=[];
    y(1)=[];
end

## end
#1617, 690:
"""
M代码:...

"""
+画if结尾(模块#1,模块#2)->+[del](,+画if结尾)...
->的(画if结尾,M代码)...

->.(+画if结尾,_凭依)...
->是(模块#1,_模块1)->在(_模块1,空间点#1)...
->是(模块#2,_模块2)->在(_模块2,空间点#2)...

->+的(_凭依,+连线)...
->+连线(_模块1,_模块2)->+样式"曲线"(+连线,)->+的(+连线,+样式)...
->+的(+连线,+x)->+的(+连线,+y)...

->+[matlab](Matlab,)->+[code](+[matlab],M代码)...
->+[.]"pt1"(+[matlab],空间点#1)->+[.]"pt2"(+[matlab],空间点#2)...
->+[.]"siz1"(+[matlab],模块#1)->+[.]"siz2"(+[matlab],模块#2)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)...

->+[临时文本]"0"->+[.]"flag1"(+[matlab],+[临时文本])->[]{
    []:->结尾(,模块#1)->[m_text]"1"(,+[临时文本]),
    ->[]
}...
->+[临时文本]"0"->+[.]"flag2"(+[matlab],+[临时文本])->[]{
    []:->结尾(,模块#2)->内部(模块#2,)->[m_text]"1"(,+[临时文本]),
    ->[]
}


## end
#1618, 92:
%{

%}


W=siz1(3)-0.5;
L=siz1(4)-0.3;

x=[pt1(1)+W/2,pt2(1)-W/2];
y=[pt1(2),pt2(2)]-L/2;



## end
#1620, 458:
"""
M代码:...

"""
+画顺序(模块#1,模块#2)->+[del](,+画顺序)...
->的(画顺序,M代码)...

->.(+画顺序,_凭依)...
->是(模块#1,_模块1)->在(_模块1,空间点#1)...
->是(模块#2,_模块2)->在(_模块2,空间点#2)...

->+的(_凭依,+连线)...
->+连线(_模块1,_模块2)->+样式"折线"(+连线,)->+的(+连线,+样式)...
->+的(+连线,+x)->+的(+连线,+y)...

->+[matlab](Matlab,)->+[code](+[matlab],M代码)...
->+[.]"pt1"(+[matlab],空间点#1)->+[.]"pt2"(+[matlab],空间点#2)...
->+[.]"siz1"(+[matlab],模块#1)->+[.]"siz2"(+[matlab],模块#2)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)




## end
#1621, 271:
%{
plot([pt1(1),pt2(1)],[pt1(2),pt2(2)],'ro-')
%}

W=2-0.5;
L=1-0.3;
Dy1=1-0.3;
Dy2=-0.15;

% x=[pt1(1),pt1(1),pt2(1),pt2(1)];
% y=[pt1(2)-Dy1,pt2(2)-Dy2,pt2(2)-Dy2,pt2(2)];

x=[pt1(1)+W/2,pt2(1)-W/2+Dy2,pt2(1)-W/2+Dy2,pt2(1)-W/2];
y=[pt1(2),pt1(2),pt2(2),pt2(2)]-L/2;



## end
#1623, 466:
"""
M代码:...

"""
+画if开头(模块#1,模块#2)->+[del](,+画if开头)...
->的(画if开头,M代码)...

->.(+画if开头,_凭依)...
->是(模块#1,_模块1)->在(_模块1,空间点#1)...
->是(模块#2,_模块2)->在(_模块2,空间点#2)...

->+的(_凭依,+连线)...
->+连线(_模块1,_模块2)->+样式"曲线"(+连线,)->+的(+连线,+样式)...
->+的(+连线,+x)->+的(+连线,+y)...

->+[matlab](Matlab,)->+[code](+[matlab],M代码)...
->+[.]"pt1"(+[matlab],空间点#1)->+[.]"pt2"(+[matlab],空间点#2)...
->+[.]"siz1"(+[matlab],模块#1)->+[.]"siz2"(+[matlab],模块#2)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)




## end
#1627, 67:
+[删除结构](,库)


画顺序:...
画if开头:...
将条目"画if开头"复制为条目"画if结尾"

画if结尾:...


## end
#1630, 363:
"""
描述结构:...
库:...
+[新建阅读窗口](,库)
+[新建阅读窗口](,描述结构)

"""

+模块连线(_媒介,_凭依)->+[del](,+模块连线)...
->的(模块连线,描述结构)->的(模块连线,库)...

->的(_凭依,结构)...
->+[code]([想],描述结构)->[想](_媒介,结构)...
->操作([想],)->[]{
    []=>的(操作,_操作)->_操作(_模块1,_模块2)->_模块1->_模块2(,)...
        =>[说]"连线: "(,_操作)->的(库,_条目)->_条目->[eq](_条目,_操作)...
        ->+[做](_模块1,_模块2)->+[code](+[做],_条目)->+[.](+[做],_凭依)
}



## end
#1631, 903:
"""
M代码:...
M代码0:...
M代码2:...
M代码3:...

"""

+绘制条件(_凭依,模块)->+[del](,+绘制条件)...
->的(绘制条件,M代码)->的(绘制条件,M代码2)->的(绘制条件,M代码0)...
->的(绘制条件,M代码3)...

->+的(_凭依,+条件模块)->+在(+条件模块,+空间点)->+是(模块,+条件模块)...
->+的(+条件模块,+在)->+的(+条件模块,+空间点)->+的(模块,+是)...

->+样式"多边形"(+条件模块,)->+的(+条件模块,+样式)...
->+的(+条件模块,+宽度)->+的(+条件模块,+长度)...
->+的(+条件模块,+x)->+的(+条件模块,+y)...

->+[matlab](Matlab,)->+[code](+[matlab],M代码3)->+[.]"siz0"(+[matlab],模块)...
->+[o]"W"(+[matlab],+宽度)->+[o]"L"(+[matlab],+长度)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)...

->+[matlab](Matlab,+空间点)...
->[]{
    []:->相邻(模块,模块#1)->模块#1->是(模块#1,_模块1)->在(_模块1,空间点#1)...
        ->+[code](+[matlab],M代码)...
        ->+[.]"siz1"(+[matlab],模块#1)->+[.]"pt1"(+[matlab],空间点#1),

    ->内部(模块#2,模块)->模块#2->是(模块#2,_模块2)->在(_模块2,空间点#2)...
        ->+[code](+[matlab],M代码2)...
        ->+[.]"siz1"(+[matlab],模块#2)->+[.]"pt1"(+[matlab],空间点#2),

    ->+[code](+[matlab],M代码0)
}



## end
#1632, 94:
%{

%}

W=siz0(3)-0.5;
L=siz0(4)-0.3;

x=[-1,1,1,-1]*W/2;
y=-[0,0,1,1]*L;

ans=pt0+[0,-1/2]*L;
## end
#1633, 21:
%{

%}

ans=[0,0];



## end
#1634, 63:
%{
记住"Matlab"
siz0
siz1
%}

ans=[2,-siz1(2)/2+siz0(4)]+pt1;




## end
#1635, 53:
%{
-siz0(3)/2
%}

ans=[0,siz0(2)/2+siz1(2)/2]+pt1;



## end
#1641, 785:
"""
M代码:...
M代码0:...

M代码2:...
M代码2b:...

M代码3:...

保存:...


"""

+布置支路(_凭依,模块)->+[del](,+布置支路)...
->的(布置支路,M代码)->的(布置支路,M代码0)...
->的(布置支路,M代码2)->的(布置支路,M代码2b)...
->的(布置支路,M代码3)...

->内容(模块,)...
->+的(_凭依,+支路模块)->+在(+支路模块,+空间点)->+是(模块,+支路模块)...
->+的(+支路模块,+在)->+的(+支路模块,+空间点)->+的(模块,+是)...

->+[matlab](Matlab,+空间点)->+[.]"siz0"(+[matlab],模块)...
->[]{
    []:->相邻(模块,模块#1)->模块#1->是(模块#1,_模块1)->在(_模块1,空间点#1)...
        ->+[code](+[matlab],M代码)...
        ->+[.]"siz1"(+[matlab],模块#1)->+[.]"pt1"(+[matlab],空间点#1),

    ->内部(模块#2,模块)->模块#2->是(模块#2,_模块2)->在(_模块2,空间点#2)...
        ->+[.]"siz1"(+[matlab],模块#2)->+[.]"pt1"(+[matlab],空间点#2)...
        ->[]{
            []:->相邻(,模块)->+[code](+[matlab],M代码2),
            ->+[code](+[matlab],M代码2b)
        },

    ->+[code](+[matlab],M代码0)
}


## end
#1642, 94:
%{

%}

W=siz0(3)-0.5;
L=siz0(4)-0.3;

x=[-1,1,1,-1]*W/2;
y=-[0,0,1,1]*L;

ans=pt0+[0,-1/2]*L;
## end
#1643, 21:
%{

%}

ans=[0,0];



## end
#1644, 46:
%{
记住"Matlab"
siz0
siz1
%}

ans=[2,0]+pt1;




## end
#1645, 31:
%{

%}

ans=[siz1(3),0]+pt1;



## end
#1650, 664:
"""
M代码:...
M代码0:...
M代码2:...
M代码3:...

"""

+布置运算(_凭依,模块)->+[del](,+布置运算)...
->的(布置运算,M代码)->的(布置运算,M代码2)->的(布置运算,M代码0)...
->的(布置运算,M代码3)...

->内容(模块,)...
->+的(_凭依,+运算模块)->+在(+运算模块,+空间点)->+是(模块,+运算模块)...
->+的(+运算模块,+在)->+的(+运算模块,+空间点)->+的(模块,+是)...

->+[matlab](Matlab,+空间点)->+[.]"siz0"(+[matlab],模块)...
->[]{
    []:->顺序(模块#1,模块)->模块#1->是(模块#1,_模块1)->在(_模块1,空间点#1)...
        ->+[code](+[matlab],M代码)...
        ->+[.]"siz1"(+[matlab],模块#1)->+[.]"pt1"(+[matlab],空间点#1),

    ->内部(模块#2,模块)->模块#2->是(模块#2,_模块2)->在(_模块2,空间点#2)...
        ->+[code](+[matlab],M代码2)...
        ->+[.]"siz1"(+[matlab],模块#2)->+[.]"pt1"(+[matlab],空间点#2),

    ->+[code](+[matlab],M代码0)
}

## end
#1651, 531:
"""
M代码:...

"""

+绘制分支(_凭依,模块)->+[del](,+绘制分支)...
->的(绘制分支,M代码)...

->是(模块,_模块)->在(_模块,空间点)...
->内容(模块,)...

->+样式"多边形"(_模块,)->+的(_模块,+样式)...
->+的(_模块,+宽度)->+的(_模块,+长度)->+的(_模块,+x)->+的(_模块,+y)...

->[m_text](内容,+文字)->+的(_凭依,+文字)->+的(_模块,+文字)...
->+的(+文字,+文字位置)->+文字位置"居中"...
->+在(+文字,+空间点#2)->+的(+文字,+在)->+的(+文字,+空间点#2)...

->+[matlab](Matlab,+空间点#2)->+[code](+[matlab],M代码)...
->+[.]"pt0"(+[matlab],空间点)->+[.]"siz0"(+[matlab],模块)...
->+[o]"W"(+[matlab],+宽度)->+[o]"L"(+[matlab],+长度)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)




## end
#1655, 80:

+[修改标题]"布置支路"(,绘制支路)
布置运算:...
布置支路:...

绘制分支:...
绘制运算:...
+[新建阅读窗口](,绘制运算)





## end
#1656, 371:
"""
->+绘制运算(,模块)->+的(操作,+绘制运算),
    

"""

+模块类型(操作,模块)...

->[]{
    []:->内容(模块,)->[]{
        []:->[==]"if"(,内容)->+绘制如果(,模块)->+的(操作,+绘制如果),
        ->[==]"else"(,内容)->+绘制否则(,模块)->+的(操作,+绘制否则),
        ->[==]"code"(,内容)->+绘制运算(,模块)->+的(操作,+绘制运算)
    },
    ->条件(模块,)->+绘制条件(,模块)->+的(操作,+绘制条件),
    ->函数(模块,)->+绘制函数(,模块)->+的(操作,+绘制函数),
    ->+绘制运算(,模块)->+的(操作,+绘制运算)
}



## end
#1658, 207:
"""
保存:...

"""

+模块类型(操作,模块)...

->[]{
    []:->内部(模块,)->+绘制分支(,模块)->+的(操作,+绘制分支),
    ->+绘制运算(,模块)->+的(操作,+绘制运算)
}...

->[]{
    []:->内部(,模块)->+布置支路(,模块)->+的(操作,+布置支路),
    ->+布置运算(,模块)->+的(操作,+布置运算)
}




## end
#1660, 604:
"""
模块类型:...

"""

+绘制模块(结构,模块)->.(+绘制模块,操作)...

->+结构->[]{
    []=>内部(模块,模块#2)->模块#2=>+[code]([想],绘制模块)->+[.]([想],操作)...
        ->[想](结构,模块#2)->结尾([想],模块#3)...
        ->+结尾(模块#2,模块#3)->+的(结构,+结尾)->[投影](,+的)->[投影](,+结尾):
            ->上一个(+结构,)...
                ->+上一个(+结构,模块#1)->模块#1->+[上一个](+结构,模块#2)...
                ->+相邻(模块#1,模块#2)->+的(结构,+相邻)->[投影](,+的)->[投影](,+相邻),
            ->+[上一个](+结构,模块#2)
}...

->[]{
    []:->顺序(模块,模块#2)->模块#2->+[code]([想],绘制模块)->+[.]([想],操作)...
        ->[想](结构,模块#2)->结尾([想],模块#3)->+结尾(+绘制模块,模块#3),
    ->+结尾(+绘制模块,模块)
}...

->+[code]([想]#0,模块类型)->[想]#0(操作,模块)



## end
#1662, 121:
"""
绘制模块:...

"""
+描述结构(_媒介,结构)->+操作(+描述结构,)...

->的(结构,起点)->起点(,模块)...
->+[code]([想],绘制模块)->+[.]([想],+操作)->[想](结构,模块)



## end
#1665, 330:
"""
描述结构:...
库:...
+[新建阅读窗口](,库)
+[新建阅读窗口](,描述结构)

"""

+布置位置(_媒介,_凭依)->+[del](,+布置位置)...
->的(布置位置,描述结构)->的(布置位置,库)...

->的(_凭依,结构)...
->+[code]([想],描述结构)->[想](_媒介,结构)...
->操作([想],)->[]{
    []=>的(操作,_操作)->_操作(,_模块)->_模块=>[说]"操作: "(,_操作)...
        ->的(库,_条目)->_条目->[eq](_条目,_操作)...
        ->+[做](_凭依,_模块)->+[code](+[做],_条目)
}



## end
#1670, 73:


生成结构:...
布置位置:...
模块连线:...
整理结构:...
+[新建阅读窗口](,生成结构)
+[新建阅读窗口](,模块连线)


## end
#1673, 23:


召唤规则:...
降临规则:...




## end
#1680, 80:
%{
记住"Matlab"
siz0
siz1
ans=[siz1(1)/2-siz0(3)/2,-1]+pt1;
%}

ans=[2,0]+pt1;




## end
#1682, 530:
"""
M代码:...

"""

+绘制运算(_凭依,模块)->+[del](,+绘制运算)...
->的(绘制运算,M代码)...

->是(模块,_模块)->在(_模块,空间点)...
->内容(模块,)...

->+样式"多边形"(_模块,)->+的(_模块,+样式)...
->+的(_模块,+宽度)->+的(_模块,+长度)->+的(_模块,+x)->+的(_模块,+y)...

->[m_text](内容,+文字)->+的(_凭依,+文字)->+的(_模块,+文字)...
->+的(+文字,+文字位置)->+文字位置"居中"...
->+在(+文字,+空间点#2)->+的(+文字,+在)->+的(+文字,+空间点#2)...

->+[matlab](Matlab,+空间点#2)->+[code](+[matlab],M代码)...
->+[.]"pt0"(+[matlab],空间点)->+[.]"siz0"(+[matlab],模块)...
->+[o]"W"(+[matlab],+宽度)->+[o]"L"(+[matlab],+长度)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)



## end
#1684, 97:
%{
pt0
%}

W=siz0(3)-0.5;
L=siz0(4)-0.3;

x=[-1,1,1,-1]*W/2;
y=-[0,0,1,1]*L;

ans=pt0+[0,-1/2]*L;
## end
#1693, 85:
%{
pt0
%}

W=2-0.5;
L=1-0.3;

x=[-1,1,1,-1]*W/2;
y=-[0,0,1,1]*L;

ans=pt0+[0,-1/2]*L;
## end
#1695, 155:
"""

"""

+召唤规则(_题目,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_代码)...

->[==]"一般结构转结构文字"(,召唤星辰)...

->+整理结构(_题目,_代码)->+的(操作,+整理结构)...
->+生成结构(_题目,_代码)->+的(操作,+生成结构)



## end
#1697, 7726:
一般结构转结构文字#0"

召唤规则:...
降临规则:...



"(,)
的#1""(一般结构转结构文字#0,降临规则#2)
降临规则#2"

生成结构:...
整理结构:...
+[新建阅读窗口](,生成结构)
+[新建阅读窗口](,模块连线)

"(,)
的#3""(降临规则#2,整理结构#4)
整理结构#4"\"\"\"


\"\"\"
+整理结构(_媒介,_凭依)->+[del](,+整理结构)...

->的(_凭依,召唤规则)->+[删除结构](,召唤规则)->+[del](,召唤规则)...
->的(_凭依,降临规则)->+[删除结构](,降临规则)->+[del](,降临规则)...
->+[修改内容](_凭依,+[显示])->+[显示]->+[删除结构](,_凭依)

"(,)
的#5""(降临规则#2,生成结构#6)
生成结构#6"\"\"\"
描述结构:...
库:...
+[新建阅读窗口](,库)

\"\"\"

+生成结构(_媒介,_凭依)->+[del](,+生成结构)...
->的(生成结构,描述结构)->的(生成结构,库)...

->[]{
    []:->的(_凭依,结构)->结构->+[删除结构](,结构),
    ->+的(_凭依,+结构)
}->的(_凭依,结构)...

->+[code]([想],描述结构)->[想](_媒介,结构)...
->操作([想],)->[]{
    []=>的(操作,_操作)->_操作(,_模块)->_模块=>[说]\"操作: \"(,_操作)...
        ->的(库,_条目)->_条目->[eq](_条目,_操作)...
        ->+[做](_凭依,_模块)->+[code](+[做],_条目)
}


"(,)
的#7""(生成结构#6,库#8)
库#8"
描述模块:...


"(,)
的#9""(库#8,描述模块#10)
描述模块#10"\"\"\"
写模块:...

\"\"\"
+描述模块(_凭依,_模块)->+[del](,+描述模块)...
->的(描述模块,写模块)...

->+[做](_凭依,_模块)->+[code](+[做],写模块)

"(,)
的#11""(描述模块#10,写模块#12)
写模块#12"\"\"\"
P代码:...
P代码b:...
P代码2:...
P代码3:...

\"\"\"
+写模块(_文本,_模块)->+[del](,+写模块)...
->的(写模块,P代码)...
->的(写模块,P代码2)->的(写模块,P代码3)...

->+[临时文本]#内部->[]{
    []=>内部(_模块,_模块1)->_模块1=>+[做](+[临时文本]#a,_模块1)...
        ->+[code](+[做],写模块)...
        ->+[python](Python,+[临时文本]#内部)->+[code](+[python],P代码2)...
        ->+[s]\"text_a\"(+[python],+[临时文本]#a)...
        ->+[s]\"text_0\"(+[python],+[临时文本]#内部)
}...

->_re\"函数|内容|条件\"(_模块,)->+[标题](_re,)...
->+[python](Python,_文本)->+[code](+[python],P代码)...
    ->+[s]\"var_name\"(+[python],_re)->+[s]\"pt_name\"(+[python],+[标题])...
    ->+[s]\"text_0\"(+[python],+[临时文本]#内部)...

->[]{
    []:->顺序(_模块,_模块1)->_模块1(,)...
        ->+[做](+[临时文本]#a,_模块1)->+[code](+[做],写模块)...
        ->+[python](Python,_文本)->+[code](+[python],P代码3)...
        ->+[s]\"text_a\"(+[python],+[临时文本]#a)...
        ->+[s]\"text_0\"(+[python],_文本),

    ->[]
}
"(,)
的#13""(写模块#12,P代码b#14)
P代码b#14""(,)
的#15""(写模块#12,P代码3#16)
P代码3#16"\"\"\"


\"\"\"

ans=text_0+\"\n\"+text_a
"(,)
的#17""(写模块#12,P代码2#18)
P代码2#18"\"\"\"
记住\"Python\"
+[P函数](,P代码2)
测试:...

\"\"\"
import numpy as np

ans=\"\"
pat_line_0=\"{s:─<{n}}\"
pat_line_1=\"{s: <{n}}\"
if text_0!=\"\":
    list_line_0=text_0.split(\"\n\")
    n_0=np.max([len(line) for line in list_line_0])
    l_0=len(list_line_0)
    list_line_a=text_a.split(\"\n\")
    n_a=np.max([len(line) for line in list_line_a])
    l_a=len(list_line_a)

    for i in range(np.max([l_a,l_0])):
        pat_line=pat_line_1

        if i>=l_a:
            line_a=pat_line.format(s=\" \",n=n_a)
        else:
            line_a=pat_line.format(s=list_line_a[i],n=n_a)
        
        if i>=l_0:
            line_0=pat_line.format(s=\" \",n=n_0)
        else:
            line_0=pat_line.format(s=list_line_0[i],n=n_0)

        if i==0:
            line_a=line_a.replace(\" \",\"─\")
            ans+=line_a+\"────\"+line_0+\"\n\"
        else:
            ans+=line_a+\"    \"+line_0+\"\n\"

    ans=ans[0:-1]
else:
    ans=text_a



"(,)
的#19""(P代码2#18,测试#20)
测试#20"\"\"\"
+[P函数](,测试)

\"\"\"
text_a=\"\"\"
aaa
c
v
\"\"\"
text_0=text_a

list_line=text_0.split(\"\n\")
list_ns=[len(line) for line in list_line]
print(list_ns)




\"\"\"
+[P函数](,测试)
print('{s:X<{n}}'.format(s=\"11\",n=10))
print(f'{\"dog\": <10}'+'1')
print(f'{\"%s\":X<10}'%(\"AAA\"))

\"\"\""(,)
的#21""(写模块#12,P代码#22)
P代码#22"\"\"\"
    text_0=str_a+text_0.replace(\"\n\",\"\n\"+str_a)
print(text_0)
print(text_1)
+[P函数](,P代码)

\"\"\"
# print(var_name,pt_name)
if text_0==\"\":
    ans=var_name
else:
    str_a=\"├\"
    list_line=text_0.split(\"\n\")
    list_line_1=[]
    n_last=0
    for i in range(len(list_line)):
        line=list_line[i]
        if line[0]==\"|\" or line[0]==\"├\" or line[0]==\"└\" or line[0]==\" \":
            line=\"|\"+line
        else:
            n_last=i
            line=\"├\"+line
        list_line_1.append(line)
    for i in range(n_last,len(list_line_1)):
        if list_line_1[i][0]==\"|\":
            list_line_1[i]=' '+list_line_1[i][1:]
        else:
            list_line_1[i]='└'+list_line_1[i][1:]

    text_1=\"\n\".join(list_line_1)
    ans=var_name+\"\n\"+text_1


\"\"\"
print(text_1)
+[P函数](,P代码)

\"\"\""(,)
的#23""(生成结构#6,描述结构#24)
描述结构#24"\"\"\"
收集块:...

\"\"\"
+描述结构(_媒介,结构)->+操作(+描述结构,)...

->+记录描述(记忆,收集块)...
->的(_媒介,起点)->起点(,_块)->+观察(+结构块,_块)->[描述结构](_媒介,+观察)...
->+[code]([想],收集块)->[想](结构,+观察)->o([想],模块)...
->+起点(,模块)->+的(结构,+起点)->[投影](,+起点)->[投影](,+的)...

->+描述模块(,模块)->+的(+操作,+描述模块)

"(,)
的#25""(描述结构#24,收集块#26)
收集块#26"\"\"\"
收集行:...
P代码_自身:...

\"\"\"
+收集块(结构,观察)...

->观察(,_块)...
    ->+的(结构,+模块#0)->+模块#0\"0,1,0,1\"->[投影](,+的)->[投影](,+模块#0)...
    ->+的(结构,+内容)->+内容\"┐\"(+模块#0,)->[投影](,+的)->[投影](,+内容)...
->+[code]([想],收集行)->+[.]([想],+模块#0)->[想](结构,观察)...
->+[o](+收集块,+模块#0)...

->+[code]([python]#0,P代码_自身)...
->+[s]\"func_name\"([python]#0,+内容)->+[.]\"bk0\"([python]#0,+模块#0)...
->[python]#0(Python,+模块#0)


"(,)
的#27""(收集块#26,收集行#28)
收集行#28"\"\"\"
收集点:...
P代码_内部:...

\"\"\"

+收集行(结构,观察)->.(+收集行,模块)...

->然后\"内部\"(观察,观察#0)...
    ->+[code]([想]#0,收集点)->[想]#0(结构,观察#0)->o([想]#0,模块#0)...
    ->+[o](+收集行,模块#0)...
->+内部(模块,模块#0)->+的(结构,+内部)->[投影](,+的)->[投影](,+内部)...

->[]{
    []=>然后\"平行\"(观察,观察#1)->观察#1(,)...
        =>+[code]([想],收集行)->+[.]([想],模块)->[想](结构,观察#1)->o([想],模块#1)
}...
->+[code]([python],P代码_内部)...
->+[.]\"bk0\"([python],模块)->+[.]\"bk1\"([python],模块#0)...
->[python](Python,模块)



"(,)
的#29""(收集行#28,收集点#30)
收集点#30"\"\"\"
P代码_内部:...
P代码_自身:...
P代码_传递:...

\"\"\"

+收集点(结构,观察)...
->记录描述(记忆,收集块)...

->观察(,_块)->.\"名字\"(观察,name)...
    ->+的(结构,+模块)->+模块\"0,1,0,1\"(,_块)->[投影](,+的)->[投影](,+模块)...
    ->+的(结构,+内容)->+内容(+模块,)->[m_text](name,+内容)...
        ->[投影](,+的)->[投影](,+内容)...
->[]{
    []=>然后\"子集\"(观察,观察#1)->观察#1(,)...
        =>+[code]([想]#1,收集块)->[想]#1(结构,观察#1)->o([想]#1,模块#1)...
        ->+内部\"子集\"(+模块,模块#1)->+的(结构,+内部)->[投影](,+的)->[投影](,+内部)...
        ->+[code]([python],P代码_内部)...
        ->+[.]\"bk0\"([python],+模块)->+[.]\"bk1\"([python],模块#1)...
        ->[python](Python,+模块)
}...

->+[code]([python]#0,P代码_自身)...
->+[s]\"func_name\"([python]#0,+内容)->+[.]\"bk0\"([python]#0,+模块)...
->[python]#0(Python,+模块)...

->[]{
    []=>然后\"顺序\"(观察,观察#1)->观察#1(,)...
        =>+[code]([想]#1,收集点)->[想]#1(结构,观察#1)->o([想]#1,模块#1)...
        ->+顺序(+模块,模块#1)->+的(结构,+顺序)->[投影](,+的)->[投影](,+顺序)...
        ->+[code]([python],P代码_传递)...
        ->+[.]\"bk0\"([python],+模块)->+[.]\"bk1\"([python],模块#1)...
        ->[python](Python,+模块)
}...
->+[o](+收集点,+模块)


"(,)
的#31""(收集点#30,P代码_自身#32)
P代码_自身#32"\"\"\"
记住\"Python\"
print(func_type)

\"\"\"

state=True

bk0[0]=np.max([len(func_name),bk0[0]])
bk0[2]=np.max([len(func_name),bk0[0]])


# if func_type==\"如果\":
#     bk0[1]=bk0[1]+1
# elif func_type==\"函数\":
#     bk0[1]=bk0[1]+1
bk0[3]=bk0[1]

ans=bk0

"(,)
的#33""(收集点#30,P代码_传递#34)
P代码_传递#34"\"\"\"


\"\"\"
state=True
bk0[1]+=bk1[1]
bk0[0]=np.max([bk0[2],bk1[0]])
ans=bk0
"(,)
的#35""(收集点#30,P代码_内部#36)
P代码_内部#36"\"\"\"
记住\"Python\"
print(np.max([1,2]))
print(func_name)

\"\"\"

state=True
bk0[0]+=bk1[0]
bk0[1]=np.max([bk0[1],bk1[1]])
# bk1[2]=bk1[1]

ans=bk0
"(,)
的#37""(收集行#28,P代码_内部#38)
P代码_内部#38"\"\"\"
记住\"Python\"
print(np.max([1,2]))
print(func_name)

\"\"\"

state=True
bk0[0]+=bk1[0]
bk0[1]=np.max([bk0[1],bk1[1]])
# bk1[2]=bk1[1]

ans=bk0
"(,)
的#39""(收集块#26,P代码_自身#40)
P代码_自身#40"\"\"\"
记住\"Python\"
print(func_type)

\"\"\"

state=True

bk0[0]=np.max([len(func_name),bk0[0]])
bk0[2]=np.max([len(func_name),bk0[0]])


# if func_type==\"如果\":
#     bk0[1]=bk0[1]+1
# elif func_type==\"函数\":
#     bk0[1]=bk0[1]+1
bk0[3]=bk0[1]

ans=bk0

"(,)
的#41""(一般结构转结构文字#0,召唤规则#42)
召唤规则#42"\"\"\"

\"\"\"

+召唤规则(_题目,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_代码)...

->[==]\"一般结构转结构文字\"(,召唤星辰)...

->+整理结构(_题目,_代码)->+的(操作,+整理结构)...
->+生成结构(_题目,_代码)->+的(操作,+生成结构)


"(,)

## end
#1698, 371:
"""
->+绘制运算(,模块)->+的(操作,+绘制运算),
    

"""

+模块类型(操作,模块)...

->[]{
    []:->内容(模块,)->[]{
        []:->[==]"if"(,内容)->+绘制如果(,模块)->+的(操作,+绘制如果),
        ->[==]"else"(,内容)->+绘制否则(,模块)->+的(操作,+绘制否则),
        ->[==]"code"(,内容)->+绘制运算(,模块)->+的(操作,+绘制运算)
    },
    ->条件(模块,)->+绘制条件(,模块)->+的(操作,+绘制条件),
    ->函数(模块,)->+绘制函数(,模块)->+的(操作,+绘制函数),
    ->+绘制运算(,模块)->+的(操作,+绘制运算)
}



## end
#1700, 207:
"""
保存:...

"""

+模块类型(操作,模块)...

->[]{
    []:->内部(模块,)->+绘制分支(,模块)->+的(操作,+绘制分支),
    ->+绘制运算(,模块)->+的(操作,+绘制运算)
}...

->[]{
    []:->内部(,模块)->+布置支路(,模块)->+的(操作,+布置支路),
    ->+布置运算(,模块)->+的(操作,+布置运算)
}




## end
#1702, 604:
"""
模块类型:...

"""

+绘制模块(结构,模块)->.(+绘制模块,操作)...

->+结构->[]{
    []=>内部(模块,模块#2)->模块#2=>+[code]([想],绘制模块)->+[.]([想],操作)...
        ->[想](结构,模块#2)->结尾([想],模块#3)...
        ->+结尾(模块#2,模块#3)->+的(结构,+结尾)->[投影](,+的)->[投影](,+结尾):
            ->上一个(+结构,)...
                ->+上一个(+结构,模块#1)->模块#1->+[上一个](+结构,模块#2)...
                ->+相邻(模块#1,模块#2)->+的(结构,+相邻)->[投影](,+的)->[投影](,+相邻),
            ->+[上一个](+结构,模块#2)
}...

->[]{
    []:->顺序(模块,模块#2)->模块#2->+[code]([想],绘制模块)->+[.]([想],操作)...
        ->[想](结构,模块#2)->结尾([想],模块#3)->+结尾(+绘制模块,模块#3),
    ->+结尾(+绘制模块,模块)
}...

->+[code]([想]#0,模块类型)->[想]#0(操作,模块)



## end
#1704, 121:
"""
绘制模块:...

"""
+描述结构(_媒介,结构)->+操作(+描述结构,)...

->的(结构,起点)->起点(,模块)...
->+[code]([想],绘制模块)->+[.]([想],+操作)->[想](结构,模块)



## end
#1705, 97:
%{
pt0
%}

W=siz0(3)-0.5;
L=siz0(4)-0.3;

x=[-1,1,1,-1]*W/2;
y=-[0,0,1,1]*L;

ans=pt0+[0,-1/2]*L;
## end
#1707, 530:
"""
M代码:...

"""

+绘制运算(_凭依,模块)->+[del](,+绘制运算)...
->的(绘制运算,M代码)...

->是(模块,_模块)->在(_模块,空间点)...
->内容(模块,)...

->+样式"多边形"(_模块,)->+的(_模块,+样式)...
->+的(_模块,+宽度)->+的(_模块,+长度)->+的(_模块,+x)->+的(_模块,+y)...

->[m_text](内容,+文字)->+的(_凭依,+文字)->+的(_模块,+文字)...
->+的(+文字,+文字位置)->+文字位置"居中"...
->+在(+文字,+空间点#2)->+的(+文字,+在)->+的(+文字,+空间点#2)...

->+[matlab](Matlab,+空间点#2)->+[code](+[matlab],M代码)...
->+[.]"pt0"(+[matlab],空间点)->+[.]"siz0"(+[matlab],模块)...
->+[o]"W"(+[matlab],+宽度)->+[o]"L"(+[matlab],+长度)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)



## end
#1708, 85:
%{
pt0
%}

W=2-0.5;
L=1-0.3;

x=[-1,1,1,-1]*W/2;
y=-[0,0,1,1]*L;

ans=pt0+[0,-1/2]*L;
## end
#1710, 531:
"""
M代码:...

"""

+绘制分支(_凭依,模块)->+[del](,+绘制分支)...
->的(绘制分支,M代码)...

->是(模块,_模块)->在(_模块,空间点)...
->内容(模块,)...

->+样式"多边形"(_模块,)->+的(_模块,+样式)...
->+的(_模块,+宽度)->+的(_模块,+长度)->+的(_模块,+x)->+的(_模块,+y)...

->[m_text](内容,+文字)->+的(_凭依,+文字)->+的(_模块,+文字)...
->+的(+文字,+文字位置)->+文字位置"居中"...
->+在(+文字,+空间点#2)->+的(+文字,+在)->+的(+文字,+空间点#2)...

->+[matlab](Matlab,+空间点#2)->+[code](+[matlab],M代码)...
->+[.]"pt0"(+[matlab],空间点)->+[.]"siz0"(+[matlab],模块)...
->+[o]"W"(+[matlab],+宽度)->+[o]"L"(+[matlab],+长度)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)




## end
#1711, 32:
%{

%}

ans=[0,-siz1(4)]+pt1;



## end
#1712, 47:
%{
记住"Matlab"
siz0
siz1
%}

ans=[0,-1]+pt1;




## end
#1713, 21:
%{

%}

ans=[0,0];



## end
#1714, 94:
%{

%}

W=siz0(3)-0.5;
L=siz0(4)-0.3;

x=[-1,1,1,-1]*W/2;
y=-[0,0,1,1]*L;

ans=pt0+[0,-1/2]*L;
## end
#1719, 664:
"""
M代码:...
M代码0:...
M代码2:...
M代码3:...

"""

+布置运算(_凭依,模块)->+[del](,+布置运算)...
->的(布置运算,M代码)->的(布置运算,M代码2)->的(布置运算,M代码0)...
->的(布置运算,M代码3)...

->内容(模块,)...
->+的(_凭依,+运算模块)->+在(+运算模块,+空间点)->+是(模块,+运算模块)...
->+的(+运算模块,+在)->+的(+运算模块,+空间点)->+的(模块,+是)...

->+[matlab](Matlab,+空间点)->+[.]"siz0"(+[matlab],模块)...
->[]{
    []:->顺序(模块#1,模块)->模块#1->是(模块#1,_模块1)->在(_模块1,空间点#1)...
        ->+[code](+[matlab],M代码)...
        ->+[.]"siz1"(+[matlab],模块#1)->+[.]"pt1"(+[matlab],空间点#1),

    ->内部(模块#2,模块)->模块#2->是(模块#2,_模块2)->在(_模块2,空间点#2)...
        ->+[code](+[matlab],M代码2)...
        ->+[.]"siz1"(+[matlab],模块#2)->+[.]"pt1"(+[matlab],空间点#2),

    ->+[code](+[matlab],M代码0)
}

## end
#1720, 81:
%{
记住"Matlab"
siz0
siz1
ans=[siz1(1)/2-siz0(3)/2,-1]+pt1;
%}

ans=[0,-1]+pt1;




## end
#1721, 54:
%{
-siz0(3)/2
%}

ans=[-siz0(1)/2-siz1(1)/2,0]+pt1;



## end
#1722, 65:
%{
记住"Matlab"
siz0
siz1
%}

ans=[siz1(1)/2-siz0(3)/2,-1]+pt1;




## end
#1723, 21:
%{

%}

ans=[0,0];



## end
#1724, 94:
%{

%}

W=siz0(3)-0.5;
L=siz0(4)-0.3;

x=[-1,1,1,-1]*W/2;
y=-[0,0,1,1]*L;

ans=pt0+[0,-1/2]*L;
## end
#1725, 903:
"""
M代码:...
M代码0:...
M代码2:...
M代码3:...

"""

+绘制条件(_凭依,模块)->+[del](,+绘制条件)...
->的(绘制条件,M代码)->的(绘制条件,M代码2)->的(绘制条件,M代码0)...
->的(绘制条件,M代码3)...

->+的(_凭依,+条件模块)->+在(+条件模块,+空间点)->+是(模块,+条件模块)...
->+的(+条件模块,+在)->+的(+条件模块,+空间点)->+的(模块,+是)...

->+样式"多边形"(+条件模块,)->+的(+条件模块,+样式)...
->+的(+条件模块,+宽度)->+的(+条件模块,+长度)...
->+的(+条件模块,+x)->+的(+条件模块,+y)...

->+[matlab](Matlab,)->+[code](+[matlab],M代码3)->+[.]"siz0"(+[matlab],模块)...
->+[o]"W"(+[matlab],+宽度)->+[o]"L"(+[matlab],+长度)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)...

->+[matlab](Matlab,+空间点)...
->[]{
    []:->相邻(模块,模块#1)->模块#1->是(模块#1,_模块1)->在(_模块1,空间点#1)...
        ->+[code](+[matlab],M代码)...
        ->+[.]"siz1"(+[matlab],模块#1)->+[.]"pt1"(+[matlab],空间点#1),

    ->内部(模块#2,模块)->模块#2->是(模块#2,_模块2)->在(_模块2,空间点#2)...
        ->+[code](+[matlab],M代码2)...
        ->+[.]"siz1"(+[matlab],模块#2)->+[.]"pt1"(+[matlab],空间点#2),

    ->+[code](+[matlab],M代码0)
}



## end
#1732, 1205:
"""
M代码:...
M代码0:...

M代码2:...
M代码2b:...

M代码3:...

保存:...

...

->+样式"多边形"(+支路模块,)->+的(+支路模块,+样式)...
->+的(+支路模块,+宽度)->+的(+支路模块,+长度)...
->+的(+支路模块,+x)->+的(+支路模块,+y)...

->[m_text](内容,+文字)->+的(_凭依,+文字)->+的(+支路模块,+文字)...
->+的(+文字,+文字位置)->+文字位置"居中"...
->+在(+文字,+空间点#2)->+的(+文字,+在)->+的(+文字,+空间点#2)...

->+[matlab](Matlab,+空间点#2)->+[code](+[matlab],M代码3)...
->+[.]"pt0"(+[matlab],+空间点)...
->+[o]"W"(+[matlab],+宽度)->+[o]"L"(+[matlab],+长度)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)




"""

+布置支路(_凭依,模块)->+[del](,+布置支路)...
->的(布置支路,M代码)->的(布置支路,M代码0)...
->的(布置支路,M代码2)->的(布置支路,M代码2b)...
->的(布置支路,M代码3)...

->内容(模块,)...
->+的(_凭依,+支路模块)->+在(+支路模块,+空间点)->+是(模块,+支路模块)...
->+的(+支路模块,+在)->+的(+支路模块,+空间点)->+的(模块,+是)...

->+[matlab](Matlab,+空间点)->+[.]"siz0"(+[matlab],模块)...
->[]{
    []:->相邻(模块,模块#1)->模块#1->是(模块#1,_模块1)->在(_模块1,空间点#1)...
        ->+[code](+[matlab],M代码)...
        ->+[.]"siz1"(+[matlab],模块#1)->+[.]"pt1"(+[matlab],空间点#1),

    ->内部(模块#2,模块)->模块#2->是(模块#2,_模块2)->在(_模块2,空间点#2)...
        ->+[.]"siz1"(+[matlab],模块#2)->+[.]"pt1"(+[matlab],空间点#2)...
        ->[]{
            []:->相邻(,模块)->+[code](+[matlab],M代码2),
            ->+[code](+[matlab],M代码2b)
        },

    ->+[code](+[matlab],M代码0)
}


## end
#1737, 80:

+[修改标题]"布置支路"(,绘制支路)
布置运算:...
布置支路:...

绘制分支:...
绘制运算:...
+[新建阅读窗口](,绘制运算)





## end
#1740, 330:
"""
描述结构:...
库:...
+[新建阅读窗口](,库)
+[新建阅读窗口](,描述结构)

"""

+布置位置(_媒介,_凭依)->+[del](,+布置位置)...
->的(布置位置,描述结构)->的(布置位置,库)...

->的(_凭依,结构)...
->+[code]([想],描述结构)->[想](_媒介,结构)...
->操作([想],)->[]{
    []=>的(操作,_操作)->_操作(,_模块)->_模块=>[说]"操作: "(,_操作)...
        ->的(库,_条目)->_条目->[eq](_条目,_操作)...
        ->+[做](_凭依,_模块)->+[code](+[做],_条目)
}



## end
#1741, 155:
%{
plot([pt1(1),pt2(1)],[pt1(2),pt2(2)],'ro-')
%}


Dy1=1-0.3;
Dy2=-0.15;

x=[pt1(1),pt1(1),pt2(1),pt2(1)];
y=[pt1(2)-Dy1,pt2(2)-Dy2,pt2(2)-Dy2,pt2(2)];



## end
#1743, 466:
"""
M代码:...

"""
+画if开头(模块#1,模块#2)->+[del](,+画if开头)...
->的(画if开头,M代码)...

->.(+画if开头,_凭依)...
->是(模块#1,_模块1)->在(_模块1,空间点#1)...
->是(模块#2,_模块2)->在(_模块2,空间点#2)...

->+的(_凭依,+连线)...
->+连线(_模块1,_模块2)->+样式"曲线"(+连线,)->+的(+连线,+样式)...
->+的(+连线,+x)->+的(+连线,+y)...

->+[matlab](Matlab,)->+[code](+[matlab],M代码)...
->+[.]"pt1"(+[matlab],空间点#1)->+[.]"pt2"(+[matlab],空间点#2)...
->+[.]"siz1"(+[matlab],模块#1)->+[.]"siz2"(+[matlab],模块#2)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)




## end
#1744, 67:
%{

%}


L=siz1(4)-0.3;

x=[pt1(1),pt2(1)];
y=[pt1(2)-L,pt2(2)];



## end
#1746, 458:
"""
M代码:...

"""
+画顺序(模块#1,模块#2)->+[del](,+画顺序)...
->的(画顺序,M代码)...

->.(+画顺序,_凭依)...
->是(模块#1,_模块1)->在(_模块1,空间点#1)...
->是(模块#2,_模块2)->在(_模块2,空间点#2)...

->+的(_凭依,+连线)...
->+连线(_模块1,_模块2)->+样式"折线"(+连线,)->+的(+连线,+样式)...
->+的(+连线,+x)->+的(+连线,+y)...

->+[matlab](Matlab,)->+[code](+[matlab],M代码)...
->+[.]"pt1"(+[matlab],空间点#1)->+[.]"pt2"(+[matlab],空间点#2)...
->+[.]"siz1"(+[matlab],模块#1)->+[.]"siz2"(+[matlab],模块#2)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)




## end
#1747, 224:
%{
siz2
%}


Dy1=siz1(4)-0.15;
Dy2=siz2(4)-0.3;

x=[pt1(1),pt1(1),pt2(1),pt2(1)];
y=[pt1(2)-siz1(4),pt1(2)-Dy1,pt1(2)-Dy1,pt2(2)-Dy2];

if flag2==1
    x(end)=[];
    y(end)=[];
end
if flag1==1
    x(1)=[];
    y(1)=[];
end

## end
#1749, 690:
"""
M代码:...

"""
+画if结尾(模块#1,模块#2)->+[del](,+画if结尾)...
->的(画if结尾,M代码)...

->.(+画if结尾,_凭依)...
->是(模块#1,_模块1)->在(_模块1,空间点#1)...
->是(模块#2,_模块2)->在(_模块2,空间点#2)...

->+的(_凭依,+连线)...
->+连线(_模块1,_模块2)->+样式"曲线"(+连线,)->+的(+连线,+样式)...
->+的(+连线,+x)->+的(+连线,+y)...

->+[matlab](Matlab,)->+[code](+[matlab],M代码)...
->+[.]"pt1"(+[matlab],空间点#1)->+[.]"pt2"(+[matlab],空间点#2)...
->+[.]"siz1"(+[matlab],模块#1)->+[.]"siz2"(+[matlab],模块#2)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)...

->+[临时文本]"0"->+[.]"flag1"(+[matlab],+[临时文本])->[]{
    []:->结尾(,模块#1)->[m_text]"1"(,+[临时文本]),
    ->[]
}...
->+[临时文本]"0"->+[.]"flag2"(+[matlab],+[临时文本])->[]{
    []:->结尾(,模块#2)->内部(模块#2,)->[m_text]"1"(,+[临时文本]),
    ->[]
}


## end
#1753, 67:
+[删除结构](,库)


画顺序:...
画if开头:...
将条目"画if开头"复制为条目"画if结尾"

画if结尾:...


## end
#1754, 337:
"""


"""
+连线类型(操作,模块)...

->[]{
    []:->顺序(模块,模块#2)->模块#2{[]=>内部(模块,)}...
        ->+画顺序(模块,模块#2)->+的(操作,+画顺序),
    ->[]
}...
->[]{
    []:->内容(模块,)=>内部(模块,模块#2)->模块#2->结尾(模块#2,模块#3)...
    =>+画if开头(模块,模块#2)->+的(操作,+画if开头)...
        ->[]{
            []:->起点(,模块),
            ->+画if结尾(模块,模块#3)->+的(操作,+画if结尾)
        },
    ->[]
}



## end
#1756, 297:
"""
连线类型:...

"""

+绘制模块(结构,模块)->.(+绘制模块,操作)...

->+结构->[]{
    []=>内部(模块,模块#2)->模块#2=>+[code]([想],绘制模块)->+[.]([想],操作)...
        ->[想](结构,模块#2)
}...

->[]{
    []:->顺序(模块,模块#2)->模块#2->+[code]([想],绘制模块)->+[.]([想],操作)...
        ->[想](结构,模块#2),
    ->[]
}...

->+[code]([想]#0,连线类型)->[想]#0(操作,模块)



## end
#1758, 121:
"""
绘制模块:...

"""
+描述结构(_媒介,结构)->+操作(+描述结构,)...

->的(结构,起点)->起点(,模块)...
->+[code]([想],绘制模块)->+[.]([想],+操作)->[想](结构,模块)



## end
#1761, 363:
"""
描述结构:...
库:...
+[新建阅读窗口](,库)
+[新建阅读窗口](,描述结构)

"""

+模块连线(_媒介,_凭依)->+[del](,+模块连线)...
->的(模块连线,描述结构)->的(模块连线,库)...

->的(_凭依,结构)...
->+[code]([想],描述结构)->[想](_媒介,结构)...
->操作([想],)->[]{
    []=>的(操作,_操作)->_操作(_模块1,_模块2)->_模块1->_模块2(,)...
        =>[说]"连线: "(,_操作)->的(库,_条目)->_条目->[eq](_条目,_操作)...
        ->+[做](_模块1,_模块2)->+[code](+[做],_条目)->+[.](+[做],_凭依)
}



## end
#1762, 188:
"""

"""
+整理结构(_媒介,_凭依)->+[del](,+整理结构)...

->的(_凭依,召唤规则)->+[删除结构](,召唤规则)->+[del](,召唤规则)...
->的(_凭依,降临规则)->+[删除结构](,降临规则)->+[del](,降临规则)...
->+[显示PPT场景]"1"(,_凭依)->+[PPT场景转H代码](_凭依,_凭依)




## end
#1764, 34:
"""


"""

ans=text_0+"\n"+text_a

## end
#1765, 265:
"""
+[P函数](,测试)

"""
text_a="""
aaa
c
v
"""
text_0=text_a

list_line=text_0.split("\n")
list_ns=[len(line) for line in list_line]
print(list_ns)




"""
+[P函数](,测试)
print('{s:X<{n}}'.format(s="11",n=10))
print(f'{"dog": <10}'+'1')
print(f'{"%s":X<10}'%("AAA"))

"""
## end
#1767, 915:
"""
记住"Python"
+[P函数](,P代码2)
测试:...

"""
import numpy as np

ans=""
pat_line_0="{s:─<{n}}"
pat_line_1="{s: <{n}}"
if text_0!="":
    list_line_0=text_0.split("\n")
    n_0=np.max([len(line) for line in list_line_0])
    l_0=len(list_line_0)
    list_line_a=text_a.split("\n")
    n_a=np.max([len(line) for line in list_line_a])
    l_a=len(list_line_a)

    for i in range(np.max([l_a,l_0])):
        pat_line=pat_line_1

        if i>=l_a:
            line_a=pat_line.format(s=" ",n=n_a)
        else:
            line_a=pat_line.format(s=list_line_a[i],n=n_a)
        
        if i>=l_0:
            line_0=pat_line.format(s=" ",n=n_0)
        else:
            line_0=pat_line.format(s=list_line_0[i],n=n_0)

        if i==0:
            line_a=line_a.replace(" ","─")
            ans+=line_a+"────"+line_0+"\n"
        else:
            ans+=line_a+"    "+line_0+"\n"

    ans=ans[0:-1]
else:
    ans=text_a




## end
#1768, 792:
"""
    text_0=str_a+text_0.replace("\n","\n"+str_a)
print(text_0)
print(text_1)
+[P函数](,P代码)

"""
# print(var_name,pt_name)
if text_0=="":
    ans=var_name
else:
    str_a="├"
    list_line=text_0.split("\n")
    list_line_1=[]
    n_last=0
    for i in range(len(list_line)):
        line=list_line[i]
        if line[0]=="|" or line[0]=="├" or line[0]=="└" or line[0]==" ":
            line="|"+line
        else:
            n_last=i
            line="├"+line
        list_line_1.append(line)
    for i in range(n_last,len(list_line_1)):
        if list_line_1[i][0]=="|":
            list_line_1[i]=' '+list_line_1[i][1:]
        else:
            list_line_1[i]='└'+list_line_1[i][1:]

    text_1="\n".join(list_line_1)
    ans=var_name+"\n"+text_1


"""
print(text_1)
+[P函数](,P代码)

"""
## end
#1773, 845:
"""
P代码:...
P代码b:...
P代码2:...
P代码3:...

"""
+写模块(_文本,_模块)->+[del](,+写模块)...
->的(写模块,P代码)...
->的(写模块,P代码2)->的(写模块,P代码3)...

->+[临时文本]#内部->[]{
    []=>内部(_模块,_模块1)->_模块1=>+[做](+[临时文本]#a,_模块1)...
        ->+[code](+[做],写模块)...
        ->+[python](Python,+[临时文本]#内部)->+[code](+[python],P代码2)...
        ->+[s]"text_a"(+[python],+[临时文本]#a)...
        ->+[s]"text_0"(+[python],+[临时文本]#内部)
}...

->_re"函数|内容|条件"(_模块,)->+[标题](_re,)...
->+[python](Python,_文本)->+[code](+[python],P代码)...
    ->+[s]"var_name"(+[python],_re)->+[s]"pt_name"(+[python],+[标题])...
    ->+[s]"text_0"(+[python],+[临时文本]#内部)...

->[]{
    []:->顺序(_模块,_模块1)->_模块1(,)...
        ->+[做](+[临时文本]#a,_模块1)->+[code](+[做],写模块)...
        ->+[python](Python,_文本)->+[code](+[python],P代码3)...
        ->+[s]"text_a"(+[python],+[临时文本]#a)...
        ->+[s]"text_0"(+[python],_文本),

    ->[]
}

## end
#1775, 105:
"""
写模块:...

"""
+描述模块(_凭依,_模块)->+[del](,+描述模块)...
->的(描述模块,写模块)...

->+[做](_凭依,_模块)->+[code](+[做],写模块)


## end
#1777, 12:

描述模块:...



## end
#1778, 278:
"""
记住"Python"
print(func_type)

"""

state=True

l_str=int(len(func_name)/8)
l_str=np.max([2,l_str])
bk0[0]=np.max([l_str,bk0[0]])
bk0[2]=np.max([l_str,bk0[0]])


# if func_type=="如果":
#     bk0[1]=bk0[1]+1
# elif func_type=="函数":
#     bk0[1]=bk0[1]+1
bk0[3]=bk0[1]

ans=bk0


## end
#1779, 75:
"""


"""
state=True
bk0[1]+=bk1[1]
bk0[0]=np.max([bk0[2],bk1[0]])
ans=bk0

## end
#1780, 222:
"""
记住"Python"
print(func_type)
print(int(15/5))

"""

state=True

l_str=int(len(func_name)/8)
l_str=np.max([2,l_str])
bk0[0]=np.max([l_str,bk0[0]])
bk0[2]=np.max([l_str,bk0[0]])

bk0[3]=bk0[1]+1
bk0[1]=bk0[1]+1

ans=bk0


## end
#1784, 988:
"""
P代码_内部:...
P代码_自身:...
P代码_传递:...

"""

+收集点(结构,观察)...
->记录描述(记忆,收集块)...

->观察(,_块)->."名字"(观察,name)...
    ->+的(结构,+模块)->+模块"0,1,0,1"(,_块)->[投影](,+的)->[投影](,+模块)...
    ->+的(结构,+内容)->+内容(+模块,)->[m_text](name,+内容)...
        ->[投影](,+的)->[投影](,+内容)...

->Python->[]{
    []:->然后"子集"(观察,观察#1)->观察#1(,)...
        ->+[code]([想]#1,收集块)->+[.]([想]#1,+模块)->[想]#1(结构,观察#1)...
        ->+[code]([python]#1,P代码_内部)...
        ->+[s]"func_name"([python]#1,+内容)->+[.]"bk0"([python]#1,+模块)...
        ->[python]#1(Python,+模块),

    ->+[code]([python]#0,P代码_自身)...
        ->+[s]"func_name"([python]#0,+内容)->+[.]"bk0"([python]#0,+模块)...
        ->[python]#0(Python,+模块)
}...

->[]{
    []=>然后"顺序"(观察,观察#1)->观察#1(,)...
        =>+[code]([想]#1,收集点)->[想]#1(结构,观察#1)->o([想]#1,模块#1)...
        ->+顺序(+模块,模块#1)->+的(结构,+顺序)->[投影](,+的)->[投影](,+顺序)...
        ->+[code]([python],P代码_传递)...
        ->+[.]"bk0"([python],+模块)->+[.]"bk1"([python],模块#1)...
        ->[python](Python,+模块)
}...
->+[o](+收集点,+模块)



## end
#1785, 141:
"""
记住"Python"
print(np.max([1,2]))
print(func_name)

"""

state=True
bk0[0]+=bk1[0]
bk0[1]=np.max([bk0[1],bk1[1]])
# bk1[2]=bk1[1]

ans=bk0

## end
#1788, 440:
"""
收集点:...
P代码_内部:...

"""

+收集行(结构,观察)->.(+收集行,模块)...

->然后"内部"(观察,观察#0)...
    ->+[code]([想]#0,收集点)->[想]#0(结构,观察#0)->o([想]#0,模块#0)...
    ->+[o](+收集行,模块#0)...
->+内部(模块,模块#0)->+的(结构,+内部)->[投影](,+的)->[投影](,+内部)...

->[]{
    []=>然后"平行"(观察,观察#1)->观察#1(,)...
        =>+[code]([想],收集行)->+[.]([想],模块)->[想](结构,观察#1)->o([想],模块#1)
}...
->+[code]([python],P代码_内部)...
->+[.]"bk0"([python],模块)->+[.]"bk1"([python],模块#0)...
->[python](Python,模块)




## end
#1789, 319:
"""
记住"Python"
print(func_type)

"""

state=True

l_str=int(len(func_name)/8)
l_str=np.max([2,l_str])
# l_str=len(func_name)
bk0[0]=np.max([l_str,bk0[0]])
bk0[2]=np.max([l_str,bk0[0]])


# if func_type=="如果":
#     bk0[1]=bk0[1]+1
# elif func_type=="函数":
#     bk0[1]=bk0[1]+1
bk0[3]=bk0[1]+1
bk0[1]=bk0[1]+1

ans=bk0


## end
#1792, 342:
"""
收集行:...
P代码_自身:...

"""
+收集块(结构,观察)...

->Python->[]{
    []:->.(+收集块,模块)->模块,

    ->+[.](+收集块,+模块#0)...
        ->+的(结构,+模块#0)->+模块#0"2,1,2,1"->[投影](,+的)->[投影](,+模块#0)...
        ->+的(结构,+内容)->+内容"起点"(+模块#0,)->[投影](,+的)->[投影](,+内容)
}->.(+收集块,模块#0)...

->观察(,_块)...
->+[code]([想],收集行)->+[.]([想],模块#0)->[想](结构,观察)...
->+[o](+收集块,模块#0)




## end
#1794, 247:
"""
收集块:...

"""
+描述结构(_媒介,结构)->+操作(+描述结构,)...

->+记录描述(记忆,收集块)...
->的(_媒介,起点)->起点(,_块)->+观察(+结构块,_块)->[描述结构](_媒介,+观察)...
->+[code]([想],收集块)->[想](结构,+观察)->o([想],模块)...
->+起点(,模块)->+的(结构,+起点)->[投影](,+起点)->[投影](,+的)...

->+描述模块(,模块)->+的(+操作,+描述模块)


## end
#1797, 377:
"""
描述结构:...
库:...
+[新建阅读窗口](,库)

"""

+生成结构(_媒介,_凭依)->+[del](,+生成结构)...
->的(生成结构,描述结构)->的(生成结构,库)...

->[]{
    []:->的(_凭依,结构)->结构->+[删除结构](,结构),
    ->+的(_凭依,+结构)
}->的(_凭依,结构)...

->+[code]([想],描述结构)->[想](_媒介,结构)...
->操作([想],)->[]{
    []=>的(操作,_操作)->_操作(,_模块)->_模块=>[说]"操作: "(,_操作)...
        ->的(库,_条目)->_条目->[eq](_条目,_操作)...
        ->+[做](_凭依,_模块)->+[code](+[做],_条目)
}



## end
#1802, 73:


生成结构:...
布置位置:...
模块连线:...
整理结构:...
+[新建阅读窗口](,生成结构)
+[新建阅读窗口](,模块连线)


## end
#1803, 222:
"""

"""

+召唤规则(_题目,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_代码)...

->[==]"一般结构转流程图"(,召唤星辰)...

->+整理结构(_题目,_代码)->+的(操作,+整理结构)...
->+模块连线(_题目,_代码)->+的(操作,+模块连线)...
->+布置位置(_题目,_代码)->+的(操作,+布置位置)...
->+生成结构(_题目,_代码)->+的(操作,+生成结构)



## end
#1806, 23:


召唤规则:...
降临规则:...




## end
#1808, 222:
"""

"""

+召唤规则(_题目,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_代码)...

->[==]"一般结构转分类图"(,召唤星辰)...

->+整理结构(_题目,_代码)->+的(操作,+整理结构)...
->+模块连线(_题目,_代码)->+的(操作,+模块连线)...
->+布置位置(_题目,_代码)->+的(操作,+布置位置)...
->+生成结构(_题目,_代码)->+的(操作,+生成结构)



## end
#1810, 18640:
一般结构转分类图#0"

召唤规则:...
降临规则:...



"(,)
的#1""(一般结构转分类图#0,召唤规则#2)
召唤规则#2"\"\"\"

\"\"\"

+召唤规则(_题目,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_代码)...

->[==]\"一般结构转分类图\"(,召唤星辰)...

->+整理结构(_题目,_代码)->+的(操作,+整理结构)...
->+模块连线(_题目,_代码)->+的(操作,+模块连线)...
->+布置位置(_题目,_代码)->+的(操作,+布置位置)...
->+生成结构(_题目,_代码)->+的(操作,+生成结构)


"(,)
的#3""(一般结构转分类图#0,降临规则#4)
降临规则#4"

生成结构:...
布置位置:...
模块连线:...
整理结构:...
+[新建阅读窗口](,生成结构)
+[新建阅读窗口](,模块连线)

"(,)
的#5""(降临规则#4,生成结构#6)
生成结构#6"\"\"\"
描述结构:...
库:...
+[新建阅读窗口](,库)

\"\"\"

+生成结构(_媒介,_凭依)->+[del](,+生成结构)...
->的(生成结构,描述结构)->的(生成结构,库)...

->[]{
    []:->的(_凭依,结构)->结构->+[删除结构](,结构),
    ->+的(_凭依,+结构)
}->的(_凭依,结构)...

->+[code]([想],描述结构)->[想](_媒介,结构)...
->操作([想],)->[]{
    []=>的(操作,_操作)->_操作(,_模块)->_模块=>[说]\"操作: \"(,_操作)...
        ->的(库,_条目)->_条目->[eq](_条目,_操作)...
        ->+[做](_凭依,_模块)->+[code](+[做],_条目)
}


"(,)
的#7""(生成结构#6,描述结构#8)
描述结构#8"\"\"\"
收集块:...

\"\"\"
+描述结构(_媒介,结构)->+操作(+描述结构,)...

->+记录描述(记忆,收集块)...
->的(_媒介,起点)->起点(,_块)->+观察(+结构块,_块)->[描述结构](_媒介,+观察)...
->+[code]([想],收集块)->[想](结构,+观察)->o([想],模块)...
->+起点(,模块)->+的(结构,+起点)->[投影](,+起点)->[投影](,+的)...

->+描述模块(,模块)->+的(+操作,+描述模块)

"(,)
的#9""(描述结构#8,收集块#10)
收集块#10"\"\"\"
收集行:...
P代码_自身:...

\"\"\"
+收集块(结构,观察)...

->Python->[]{
    []:->.(+收集块,模块)->模块,

    ->+[.](+收集块,+模块#0)...
        ->+的(结构,+模块#0)->+模块#0\"2,1,2,1\"->[投影](,+的)->[投影](,+模块#0)...
        ->+的(结构,+内容)->+内容\"起点\"(+模块#0,)->[投影](,+的)->[投影](,+内容)
}->.(+收集块,模块#0)...

->观察(,_块)...
->+[code]([想],收集行)->+[.]([想],模块#0)->[想](结构,观察)...
->+[o](+收集块,模块#0)



"(,)
的#11""(收集块#10,P代码_自身#12)
P代码_自身#12"\"\"\"
记住\"Python\"
print(func_type)

\"\"\"

state=True

bk0[0]=np.max([len(func_name),bk0[0]])
bk0[2]=np.max([len(func_name),bk0[0]])

bk0[2]=bk0[0]+2
bk0[0]=bk0[0]+2

ans=bk0

"(,)
的#13""(收集块#10,收集行#14)
收集行#14"\"\"\"
收集点:...
P代码_内部:...

\"\"\"

+收集行(结构,观察)->.(+收集行,模块)...

->然后\"内部\"(观察,观察#0)...
    ->+[code]([想]#0,收集点)->[想]#0(结构,观察#0)->o([想]#0,模块#0)...
    ->+[o](+收集行,模块#0)...
->+内部(模块,模块#0)->+的(结构,+内部)->[投影](,+的)->[投影](,+内部)...

->[]{
    []=>然后\"平行\"(观察,观察#1)->观察#1(,)...
        =>+[code]([想],收集行)->+[.]([想],模块)->[想](结构,观察#1)->o([想],模块#1)
}...
->+[code]([python],P代码_内部)...
->+[.]\"bk0\"([python],模块)->+[.]\"bk1\"([python],模块#0)...
->[python](Python,模块)



"(,)
的#15""(收集行#14,P代码_内部#16)
P代码_内部#16"\"\"\"
记住\"Python\"
print(np.max([1,2]))
print(func_name)

\"\"\"

state=True
bk0[1]+=bk1[1]
bk0[0]=np.max([bk0[0],bk1[0]])
# bk1[2]=bk1[1]

ans=bk0
"(,)
的#17""(收集行#14,收集点#18)
收集点#18"\"\"\"
P代码_内部:...
P代码_自身:...
P代码_传递:...

\"\"\"

+收集点(结构,观察)...
->记录描述(记忆,收集块)...

->观察(,_块)->.\"名字\"(观察,name)...
    ->+的(结构,+模块)->+模块\"0,1,0,1\"(,_块)->[投影](,+的)->[投影](,+模块)...
    ->+的(结构,+内容)->+内容(+模块,)->[m_text](name,+内容)...
        ->[投影](,+的)->[投影](,+内容)...

->Python->[]{
    []:->然后\"子集\"(观察,观察#1)->观察#1(,)...
        ->+[code]([想]#1,收集块)->+[.]([想]#1,+模块)->[想]#1(结构,观察#1)...
        ->+[code]([python]#1,P代码_内部)...
        ->+[s]\"func_name\"([python]#1,+内容)->+[.]\"bk0\"([python]#1,+模块)...
        ->[python]#1(Python,+模块),

    ->+[code]([python]#0,P代码_自身)...
        ->+[s]\"func_name\"([python]#0,+内容)->+[.]\"bk0\"([python]#0,+模块)...
        ->[python]#0(Python,+模块)
}...

->[]{
    []=>然后\"顺序\"(观察,观察#1)->观察#1(,)...
        =>+[code]([想]#1,收集点)->[想]#1(结构,观察#1)->o([想]#1,模块#1)...
        ->+顺序(+模块,模块#1)->+的(结构,+顺序)->[投影](,+的)->[投影](,+顺序)...
        ->+[code]([python],P代码_传递)...
        ->+[.]\"bk0\"([python],+模块)->+[.]\"bk1\"([python],模块#1)...
        ->[python](Python,+模块)
}...
->+[o](+收集点,+模块)


"(,)
的#19""(收集点#18,P代码_内部#20)
P代码_内部#20"\"\"\"
记住\"Python\"
print(func_type)

\"\"\"

state=True

bk0[0]=np.max([len(func_name),bk0[0]])
bk0[2]=np.max([len(func_name),bk0[0]])

bk0[3]=bk0[1]
bk0[2]=bk0[0]+2
bk0[0]=bk0[0]+2

ans=bk0

"(,)
的#21""(收集点#18,P代码_传递#22)
P代码_传递#22"\"\"\"


\"\"\"
state=True
bk0[0]+=bk1[0]
bk0[1]=np.max([bk0[3],bk1[1]])
ans=bk0
"(,)
的#23""(收集点#18,P代码_自身#24)
P代码_自身#24"\"\"\"
记住\"Python\"
print(func_type)

\"\"\"

state=True

l_str=2
bk0[0]=np.max([l_str,bk0[0]])
bk0[2]=np.max([l_str,bk0[0]])

bk0[3]=bk0[1]

ans=bk0

"(,)
的#25""(生成结构#6,库#26)
库#26"
描述模块:...


"(,)
的#27""(库#26,描述模块#28)
描述模块#28"\"\"\"
写模块:...

\"\"\"
+描述模块(_凭依,_模块)->+[del](,+描述模块)...
->的(描述模块,写模块)...

->+[做](_凭依,_模块)->+[code](+[做],写模块)

"(,)
的#29""(描述模块#28,写模块#30)
写模块#30"\"\"\"
P代码:...
P代码b:...
P代码2:...
P代码3:...

\"\"\"
+写模块(_文本,_模块)->+[del](,+写模块)...
->的(写模块,P代码)...
->的(写模块,P代码2)->的(写模块,P代码3)...

->+[临时文本]#内部->[]{
    []=>内部(_模块,_模块1)->_模块1=>+[做](+[临时文本]#a,_模块1)...
        ->+[code](+[做],写模块)...
        ->+[python](Python,+[临时文本]#内部)->+[code](+[python],P代码2)...
        ->+[s]\"text_a\"(+[python],+[临时文本]#a)...
        ->+[s]\"text_0\"(+[python],+[临时文本]#内部)
}...

->_re\"函数|内容|条件\"(_模块,)->+[标题](_re,)...
->+[python](Python,_文本)->+[code](+[python],P代码)...
    ->+[s]\"var_name\"(+[python],_re)->+[s]\"pt_name\"(+[python],+[标题])...
    ->+[s]\"text_0\"(+[python],+[临时文本]#内部)...

->[]{
    []:->顺序(_模块,_模块1)->_模块1(,)...
        ->+[做](+[临时文本]#a,_模块1)->+[code](+[做],写模块)...
        ->+[python](Python,_文本)->+[code](+[python],P代码3)...
        ->+[s]\"text_a\"(+[python],+[临时文本]#a)...
        ->+[s]\"text_0\"(+[python],_文本),

    ->[]
}
"(,)
的#31""(写模块#30,P代码#32)
P代码#32"\"\"\"
    text_0=str_a+text_0.replace(\"\n\",\"\n\"+str_a)
print(text_0)
print(text_1)
+[P函数](,P代码)

\"\"\"
# print(var_name,pt_name)
if text_0==\"\":
    ans=var_name
else:
    str_a=\"├\"
    list_line=text_0.split(\"\n\")
    list_line_1=[]
    n_last=0
    for i in range(len(list_line)):
        line=list_line[i]
        if line[0]==\"|\" or line[0]==\"├\" or line[0]==\"└\" or line[0]==\" \":
            line=\"|\"+line
        else:
            n_last=i
            line=\"├\"+line
        list_line_1.append(line)
    for i in range(n_last,len(list_line_1)):
        if list_line_1[i][0]==\"|\":
            list_line_1[i]=' '+list_line_1[i][1:]
        else:
            list_line_1[i]='└'+list_line_1[i][1:]

    text_1=\"\n\".join(list_line_1)
    ans=var_name+\"\n\"+text_1


\"\"\"
print(text_1)
+[P函数](,P代码)

\"\"\""(,)
的#33""(写模块#30,P代码2#34)
P代码2#34"\"\"\"
记住\"Python\"
+[P函数](,P代码2)
测试:...

\"\"\"
import numpy as np

ans=\"\"
pat_line_0=\"{s:─<{n}}\"
pat_line_1=\"{s: <{n}}\"
if text_0!=\"\":
    list_line_0=text_0.split(\"\n\")
    n_0=np.max([len(line) for line in list_line_0])
    l_0=len(list_line_0)
    list_line_a=text_a.split(\"\n\")
    n_a=np.max([len(line) for line in list_line_a])
    l_a=len(list_line_a)

    for i in range(np.max([l_a,l_0])):
        pat_line=pat_line_1

        if i>=l_a:
            line_a=pat_line.format(s=\" \",n=n_a)
        else:
            line_a=pat_line.format(s=list_line_a[i],n=n_a)
        
        if i>=l_0:
            line_0=pat_line.format(s=\" \",n=n_0)
        else:
            line_0=pat_line.format(s=list_line_0[i],n=n_0)

        if i==0:
            line_a=line_a.replace(\" \",\"─\")
            ans+=line_a+\"────\"+line_0+\"\n\"
        else:
            ans+=line_a+\"    \"+line_0+\"\n\"

    ans=ans[0:-1]
else:
    ans=text_a



"(,)
的#35""(P代码2#34,测试#36)
测试#36"\"\"\"
+[P函数](,测试)

\"\"\"
text_a=\"\"\"
aaa
c
v
\"\"\"
text_0=text_a

list_line=text_0.split(\"\n\")
list_ns=[len(line) for line in list_line]
print(list_ns)




\"\"\"
+[P函数](,测试)
print('{s:X<{n}}'.format(s=\"11\",n=10))
print(f'{\"dog\": <10}'+'1')
print(f'{\"%s\":X<10}'%(\"AAA\"))

\"\"\""(,)
的#37""(写模块#30,P代码3#38)
P代码3#38"\"\"\"


\"\"\"

ans=text_0+\"\n\"+text_a
"(,)
的#39""(写模块#30,P代码b#40)
P代码b#40""(,)
的#41""(降临规则#4,整理结构#42)
整理结构#42"\"\"\"
...
->+[显示PPT场景]\"1\"(,_凭依)->+[PPT场景转H代码](_凭依,_凭依)

\"\"\"
+整理结构(_媒介,_凭依)->+[del](,+整理结构)...

->的(_凭依,召唤规则)->+[删除结构](,召唤规则)->+[del](,召唤规则)...
->的(_凭依,降临规则)->+[删除结构](,降临规则)->+[del](,降临规则)


"(,)
的#43""(降临规则#4,模块连线#44)
模块连线#44"\"\"\"
描述结构:...
库:...
+[新建阅读窗口](,库)
+[新建阅读窗口](,描述结构)

\"\"\"

+模块连线(_媒介,_凭依)->+[del](,+模块连线)...
->的(模块连线,描述结构)->的(模块连线,库)...

->的(_凭依,结构)...
->+[code]([想],描述结构)->[想](_媒介,结构)...
->操作([想],)->[]{
    []=>的(操作,_操作)->_操作(_模块1,_模块2)->_模块1->_模块2(,)...
        =>[说]\"连线: \"(,_操作)->的(库,_条目)->_条目->[eq](_条目,_操作)...
        ->+[做](_模块1,_模块2)->+[code](+[做],_条目)->+[.](+[做],_凭依)
}


"(,)
的#45""(模块连线#44,描述结构#46)
描述结构#46"\"\"\"
绘制模块:...

\"\"\"
+描述结构(_媒介,结构)->+操作(+描述结构,)...

->的(结构,起点)->起点(,模块)...
->+[code]([想],绘制模块)->+[.]([想],+操作)->[想](结构,模块)


"(,)
的#47""(描述结构#46,绘制模块#48)
绘制模块#48"\"\"\"
连线类型:...

\"\"\"

+绘制模块(结构,模块)->.(+绘制模块,操作)...

->+结构->[]{
    []=>内部(模块,模块#2)->模块#2=>+[code]([想],绘制模块)->+[.]([想],操作)...
        ->[想](结构,模块#2)
}...

->[]{
    []:->顺序(模块,模块#2)->模块#2->+[code]([想],绘制模块)->+[.]([想],操作)...
        ->[想](结构,模块#2),
    ->[]
}...

->+[code]([想]#0,连线类型)->[想]#0(操作,模块)


"(,)
的#49""(绘制模块#48,连线类型#50)
连线类型#50"\"\"\"
保存:...

\"\"\"
+连线类型(操作,模块)...

->[]{
    []:->顺序(模块,模块#2)->模块#2{[]=>内部(模块,)}...
        ->+画顺序(模块,模块#2)->+的(操作,+画顺序),
    ->[]
}...
->[]{
    []:->内容(模块,)=>内部(模块,模块#2)->模块#2->结尾(模块#2,模块#3)...
        =>+画if开头(模块,模块#2)->+的(操作,+画if开头),
    ->[]
}


"(,)
的#51""(连线类型#50,保存#52)
保存#52"\"\"\"
保存:...

\"\"\"
+连线类型(操作,模块)...

->[]{
    []:->顺序(模块,模块#2)->模块#2{[]=>内部(模块,)}...
        ->+画顺序(模块,模块#2)->+的(操作,+画顺序),
    ->[]
}...
->[]{
    []:->内容(模块,)=>内部(模块,模块#2)->模块#2->结尾(模块#2,模块#3)...
    =>+画if开头(模块,模块#2)->+的(操作,+画if开头)...
        ->[]{
            []:->起点(,模块),
            ->+画if结尾(模块,模块#3)->+的(操作,+画if结尾)
        },
    ->[]
}


"(,)
的#53""(模块连线#44,库#54)
库#54"+[删除结构](,库)


画顺序:...
画if开头:...
将条目\"画if开头\"复制为条目\"画if结尾\"

画if结尾:...

"(,)
的#55""(库#54,画if结尾#56)
画if结尾#56"\"\"\"
M代码:...

\"\"\"
+画if结尾(模块#1,模块#2)->+[del](,+画if结尾)...
->的(画if结尾,M代码)...

->.(+画if结尾,_凭依)...
->是(模块#1,_模块1)->在(_模块1,空间点#1)...
->是(模块#2,_模块2)->在(_模块2,空间点#2)...

->+的(_凭依,+连线)...
->+连线(_模块1,_模块2)->+样式\"曲线\"(+连线,)->+的(+连线,+样式)...
->+的(+连线,+x)->+的(+连线,+y)...

->+[matlab](Matlab,)->+[code](+[matlab],M代码)...
->+[.]\"pt1\"(+[matlab],空间点#1)->+[.]\"pt2\"(+[matlab],空间点#2)...
->+[.]\"siz1\"(+[matlab],模块#1)->+[.]\"siz2\"(+[matlab],模块#2)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)...

->+[临时文本]\"0\"->+[.]\"flag1\"(+[matlab],+[临时文本])->[]{
    []:->结尾(,模块#1)->[m_text]\"1\"(,+[临时文本]),
    ->[]
}...
->+[临时文本]\"0\"->+[.]\"flag2\"(+[matlab],+[临时文本])->[]{
    []:->结尾(,模块#2)->内部(模块#2,)->[m_text]\"1\"(,+[临时文本]),
    ->[]
}

"(,)
的#57""(画if结尾#56,M代码#58)
M代码#58"%{
siz2
%}

L=1-0.3;
W=2-0.5;

Dy1=siz1(3)-0.15;
Dy2=siz2(3)-0.3;

% x=[pt1(1),pt1(1),pt2(1),pt2(1)];
% y=[pt1(2)-siz1(4),pt1(2)-Dy1,pt1(2)-Dy1,pt2(2)-Dy2];

x=[pt1(1)-W/2+siz1(3),pt1(1)-W/2+Dy1,pt1(1)-W/2+Dy1,pt2(1)+W/2];
y=[pt1(2),pt1(2),pt2(2),pt2(2)]-L/2;

if flag2==1
    x(end)=[];
    y(end)=[];
end
if flag1==1
    x(1)=[];
    y(1)=[];
end
"(,)
的#59""(库#54,画顺序#60)
画顺序#60"\"\"\"
M代码:...

\"\"\"
+画顺序(模块#1,模块#2)->+[del](,+画顺序)...
->的(画顺序,M代码)...

->.(+画顺序,_凭依)...
->是(模块#1,_模块1)->在(_模块1,空间点#1)...
->是(模块#2,_模块2)->在(_模块2,空间点#2)...

->+的(_凭依,+连线)...
->+连线(_模块1,_模块2)->+样式\"折线\"(+连线,)->+的(+连线,+样式)...
->+的(+连线,+x)->+的(+连线,+y)...

->+[matlab](Matlab,)->+[code](+[matlab],M代码)...
->+[.]\"pt1\"(+[matlab],空间点#1)->+[.]\"pt2\"(+[matlab],空间点#2)...
->+[.]\"siz1\"(+[matlab],模块#1)->+[.]\"siz2\"(+[matlab],模块#2)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)



"(,)
的#61""(画顺序#60,M代码#62)
M代码#62"%{

%}


W=siz1(3)-0.5;
L=siz1(4)-0.3;

x=[pt1(1)+W/2,pt2(1)-W/2];
y=[pt1(2),pt2(2)]-L/2;


"(,)
的#63""(库#54,画if开头#64)
画if开头#64"\"\"\"
M代码:...

\"\"\"
+画if开头(模块#1,模块#2)->+[del](,+画if开头)...
->的(画if开头,M代码)...

->.(+画if开头,_凭依)...
->是(模块#1,_模块1)->在(_模块1,空间点#1)...
->是(模块#2,_模块2)->在(_模块2,空间点#2)...

->+的(_凭依,+连线)...
->+连线(_模块1,_模块2)->+样式\"曲线\"(+连线,)->+的(+连线,+样式)...
->+的(+连线,+x)->+的(+连线,+y)...

->+[matlab](Matlab,)->+[code](+[matlab],M代码)...
->+[.]\"pt1\"(+[matlab],空间点#1)->+[.]\"pt2\"(+[matlab],空间点#2)...
->+[.]\"siz1\"(+[matlab],模块#1)->+[.]\"siz2\"(+[matlab],模块#2)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)



"(,)
的#65""(画if开头#64,M代码#66)
M代码#66"%{
plot([pt1(1),pt2(1)],[pt1(2),pt2(2)],'ro-')
%}

W=2-0.5;
L=1-0.3;
Dy1=1-0.3;
Dy2=-0.15;

% x=[pt1(1),pt1(1),pt2(1),pt2(1)];
% y=[pt1(2)-Dy1,pt2(2)-Dy2,pt2(2)-Dy2,pt2(2)];

x=[pt1(1)+W/2,pt2(1)-W/2+Dy2,pt2(1)-W/2+Dy2,pt2(1)-W/2];
y=[pt1(2),pt1(2),pt2(2),pt2(2)]-L/2;


"(,)
的#67""(降临规则#4,布置位置#68)
布置位置#68"\"\"\"
描述结构:...
库:...
+[新建阅读窗口](,库)
+[新建阅读窗口](,描述结构)

\"\"\"

+布置位置(_媒介,_凭依)->+[del](,+布置位置)...
->的(布置位置,描述结构)->的(布置位置,库)...

->的(_凭依,结构)...
->+[code]([想],描述结构)->[想](_媒介,结构)...
->操作([想],)->[]{
    []=>的(操作,_操作)->_操作(,_模块)->_模块=>[说]\"操作: \"(,_操作)...
        ->的(库,_条目)->_条目->[eq](_条目,_操作)...
        ->+[做](_凭依,_模块)->+[code](+[做],_条目)
}


"(,)
的#69""(布置位置#68,库#70)
库#70"
+[修改标题]\"布置支路\"(,绘制支路)
布置运算:...
布置支路:...

绘制分支:...
绘制运算:...
+[新建阅读窗口](,绘制运算)




"(,)
的#71""(库#70,布置支路#72)
布置支路#72"\"\"\"
M代码:...
M代码0:...

M代码2:...
M代码2b:...

M代码3:...

保存:...


\"\"\"

+布置支路(_凭依,模块)->+[del](,+布置支路)...
->的(布置支路,M代码)->的(布置支路,M代码0)...
->的(布置支路,M代码2)->的(布置支路,M代码2b)...
->的(布置支路,M代码3)...

->内容(模块,)...
->+的(_凭依,+支路模块)->+在(+支路模块,+空间点)->+是(模块,+支路模块)...
->+的(+支路模块,+在)->+的(+支路模块,+空间点)->+的(模块,+是)...

->+[matlab](Matlab,+空间点)->+[.]\"siz0\"(+[matlab],模块)...
->[]{
    []:->相邻(模块,模块#1)->模块#1->是(模块#1,_模块1)->在(_模块1,空间点#1)...
        ->+[code](+[matlab],M代码)...
        ->+[.]\"siz1\"(+[matlab],模块#1)->+[.]\"pt1\"(+[matlab],空间点#1),

    ->内部(模块#2,模块)->模块#2->是(模块#2,_模块2)->在(_模块2,空间点#2)...
        ->+[.]\"siz1\"(+[matlab],模块#2)->+[.]\"pt1\"(+[matlab],空间点#2)...
        ->[]{
            []:->相邻(,模块)->+[code](+[matlab],M代码2),
            ->+[code](+[matlab],M代码2b)
        },

    ->+[code](+[matlab],M代码0)
}

"(,)
的#73""(布置支路#72,保存#74)
保存#74"\"\"\"
M代码:...
M代码0:...
M代码2:...
M代码3:...

\"\"\"

+绘制条件(_凭依,模块)->+[del](,+绘制条件)...
->的(绘制条件,M代码)->的(绘制条件,M代码2)->的(绘制条件,M代码0)...
->的(绘制条件,M代码3)...

->+的(_凭依,+条件模块)->+在(+条件模块,+空间点)->+是(模块,+条件模块)...
->+的(+条件模块,+在)->+的(+条件模块,+空间点)->+的(模块,+是)...

->+样式\"多边形\"(+条件模块,)->+的(+条件模块,+样式)...
->+的(+条件模块,+宽度)->+的(+条件模块,+长度)...
->+的(+条件模块,+x)->+的(+条件模块,+y)...

->+[matlab](Matlab,)->+[code](+[matlab],M代码3)->+[.]\"siz0\"(+[matlab],模块)...
->+[o]\"W\"(+[matlab],+宽度)->+[o]\"L\"(+[matlab],+长度)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)...

->+[matlab](Matlab,+空间点)...
->[]{
    []:->相邻(模块,模块#1)->模块#1->是(模块#1,_模块1)->在(_模块1,空间点#1)...
        ->+[code](+[matlab],M代码)...
        ->+[.]\"siz1\"(+[matlab],模块#1)->+[.]\"pt1\"(+[matlab],空间点#1),

    ->内部(模块#2,模块)->模块#2->是(模块#2,_模块2)->在(_模块2,空间点#2)...
        ->+[code](+[matlab],M代码2)...
        ->+[.]\"siz1\"(+[matlab],模块#2)->+[.]\"pt1\"(+[matlab],空间点#2),

    ->+[code](+[matlab],M代码0)
}


"(,)
的#75""(布置支路#72,M代码3#76)
M代码3#76"%{

%}

W=siz0(3)-0.5;
L=siz0(4)-0.3;

x=[-1,1,1,-1]*W/2;
y=-[0,0,1,1]*L;

ans=pt0+[0,-1/2]*L;"(,)
的#77""(布置支路#72,M代码0#78)
M代码0#78"%{

%}

ans=[0,0];


"(,)
的#79""(布置支路#72,M代码2#80)
M代码2#80"%{
记住\"Matlab\"
siz0
siz1
%}

ans=[2,-siz1(2)/2+siz0(4)]+pt1;



"(,)
的#81""(布置支路#72,M代码#82)
M代码#82"%{
-siz0(3)/2
%}

ans=[0,siz0(2)/2+siz1(2)/2]+pt1;


"(,)
的#83""(布置支路#72,M代码2b#84)
M代码2b#84"%{
记住\"Matlab\"
siz0
siz1
ans=[siz1(1)/2-siz0(3)/2,-1]+pt1;
%}

ans=[2,0]+pt1;



"(,)
的#85""(库#70,布置运算#86)
布置运算#86"\"\"\"
M代码:...
M代码0:...
M代码2:...
M代码3:...

\"\"\"

+布置运算(_凭依,模块)->+[del](,+布置运算)...
->的(布置运算,M代码)->的(布置运算,M代码2)->的(布置运算,M代码0)...
->的(布置运算,M代码3)...

->内容(模块,)...
->+的(_凭依,+运算模块)->+在(+运算模块,+空间点)->+是(模块,+运算模块)...
->+的(+运算模块,+在)->+的(+运算模块,+空间点)->+的(模块,+是)...

->+[matlab](Matlab,+空间点)->+[.]\"siz0\"(+[matlab],模块)...
->[]{
    []:->顺序(模块#1,模块)->模块#1->是(模块#1,_模块1)->在(_模块1,空间点#1)...
        ->+[code](+[matlab],M代码)...
        ->+[.]\"siz1\"(+[matlab],模块#1)->+[.]\"pt1\"(+[matlab],空间点#1),

    ->内部(模块#2,模块)->模块#2->是(模块#2,_模块2)->在(_模块2,空间点#2)...
        ->+[code](+[matlab],M代码2)...
        ->+[.]\"siz1\"(+[matlab],模块#2)->+[.]\"pt1\"(+[matlab],空间点#2),

    ->+[code](+[matlab],M代码0)
}
"(,)
的#87""(布置运算#86,M代码3#88)
M代码3#88"%{

%}

W=siz0(3)-0.5;
L=siz0(4)-0.3;

x=[-1,1,1,-1]*W/2;
y=-[0,0,1,1]*L;

ans=pt0+[0,-1/2]*L;"(,)
的#89""(布置运算#86,M代码0#90)
M代码0#90"%{

%}

ans=[0,0];


"(,)
的#91""(布置运算#86,M代码2#92)
M代码2#92"%{
记住\"Matlab\"
siz0
siz1
%}

ans=[2,0]+pt1;



"(,)
的#93""(布置运算#86,M代码#94)
M代码#94"%{

%}

ans=[siz1(3),0]+pt1;


"(,)
的#95""(库#70,绘制分支#96)
绘制分支#96"\"\"\"
M代码:...

\"\"\"

+绘制分支(_凭依,模块)->+[del](,+绘制分支)...
->的(绘制分支,M代码)...

->是(模块,_模块)->在(_模块,空间点)...
->内容(模块,)...

->+样式\"多边形\"(_模块,)->+的(_模块,+样式)...
->+的(_模块,+宽度)->+的(_模块,+长度)->+的(_模块,+x)->+的(_模块,+y)...

->[m_text](内容,+文字)->+的(_凭依,+文字)->+的(_模块,+文字)...
->+的(+文字,+文字位置)->+文字位置\"居中\"...
->+在(+文字,+空间点#2)->+的(+文字,+在)->+的(+文字,+空间点#2)...

->+[matlab](Matlab,+空间点#2)->+[code](+[matlab],M代码)...
->+[.]\"pt0\"(+[matlab],空间点)->+[.]\"siz0\"(+[matlab],模块)...
->+[o]\"W\"(+[matlab],+宽度)->+[o]\"L\"(+[matlab],+长度)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)



"(,)
的#97""(绘制分支#96,M代码#98)
M代码#98"%{
pt0
%}

W=2-0.5;
L=1-0.3;

x=[-1,1,1,-1]*W/2;
y=-[0,0,1,1]*L;

ans=pt0+[0,-1/2]*L;"(,)
的#99""(库#70,绘制运算#100)
绘制运算#100"\"\"\"
M代码:...

\"\"\"

+绘制运算(_凭依,模块)->+[del](,+绘制运算)...
->的(绘制运算,M代码)...

->是(模块,_模块)->在(_模块,空间点)...
->内容(模块,)...

->+样式\"多边形\"(_模块,)->+的(_模块,+样式)...
->+的(_模块,+宽度)->+的(_模块,+长度)->+的(_模块,+x)->+的(_模块,+y)...

->[m_text](内容,+文字)->+的(_凭依,+文字)->+的(_模块,+文字)...
->+的(+文字,+文字位置)->+文字位置\"居中\"...
->+在(+文字,+空间点#2)->+的(+文字,+在)->+的(+文字,+空间点#2)...

->+[matlab](Matlab,+空间点#2)->+[code](+[matlab],M代码)...
->+[.]\"pt0\"(+[matlab],空间点)->+[.]\"siz0\"(+[matlab],模块)...
->+[o]\"W\"(+[matlab],+宽度)->+[o]\"L\"(+[matlab],+长度)...
->+[o](+[matlab],+x)->+[o](+[matlab],+y)


"(,)
的#101""(绘制运算#100,M代码#102)
M代码#102"%{
pt0
%}

W=siz0(3)-0.5;
L=siz0(4)-0.3;

x=[-1,1,1,-1]*W/2;
y=-[0,0,1,1]*L;

ans=pt0+[0,-1/2]*L;"(,)
的#103""(布置位置#68,描述结构#104)
描述结构#104"\"\"\"
绘制模块:...

\"\"\"
+描述结构(_媒介,结构)->+操作(+描述结构,)...

->的(结构,起点)->起点(,模块)...
->+[code]([想],绘制模块)->+[.]([想],+操作)->[想](结构,模块)


"(,)
的#105""(描述结构#104,绘制模块#106)
绘制模块#106"\"\"\"
模块类型:...

\"\"\"

+绘制模块(结构,模块)->.(+绘制模块,操作)...

->+结构->[]{
    []=>内部(模块,模块#2)->模块#2=>+[code]([想],绘制模块)->+[.]([想],操作)...
        ->[想](结构,模块#2)->结尾([想],模块#3)...
        ->+结尾(模块#2,模块#3)->+的(结构,+结尾)->[投影](,+的)->[投影](,+结尾):
            ->上一个(+结构,)...
                ->+上一个(+结构,模块#1)->模块#1->+[上一个](+结构,模块#2)...
                ->+相邻(模块#1,模块#2)->+的(结构,+相邻)->[投影](,+的)->[投影](,+相邻),
            ->+[上一个](+结构,模块#2)
}...

->[]{
    []:->顺序(模块,模块#2)->模块#2->+[code]([想],绘制模块)->+[.]([想],操作)...
        ->[想](结构,模块#2)->结尾([想],模块#3)->+结尾(+绘制模块,模块#3),
    ->+结尾(+绘制模块,模块)
}...

->+[code]([想]#0,模块类型)->[想]#0(操作,模块)


"(,)
的#107""(绘制模块#106,模块类型#108)
模块类型#108"\"\"\"
保存:...

\"\"\"

+模块类型(操作,模块)...

->[]{
    []:->内部(模块,)->+绘制分支(,模块)->+的(操作,+绘制分支),
    ->+绘制运算(,模块)->+的(操作,+绘制运算)
}...

->[]{
    []:->内部(,模块)->+布置支路(,模块)->+的(操作,+布置支路),
    ->+布置运算(,模块)->+的(操作,+布置运算)
}



"(,)
的#109""(模块类型#108,保存#110)
保存#110"\"\"\"
->+绘制运算(,模块)->+的(操作,+绘制运算),
    

\"\"\"

+模块类型(操作,模块)...

->[]{
    []:->内容(模块,)->[]{
        []:->[==]\"if\"(,内容)->+绘制如果(,模块)->+的(操作,+绘制如果),
        ->[==]\"else\"(,内容)->+绘制否则(,模块)->+的(操作,+绘制否则),
        ->[==]\"code\"(,内容)->+绘制运算(,模块)->+的(操作,+绘制运算)
    },
    ->条件(模块,)->+绘制条件(,模块)->+的(操作,+绘制条件),
    ->函数(模块,)->+绘制函数(,模块)->+的(操作,+绘制函数),
    ->+绘制运算(,模块)->+的(操作,+绘制运算)
}


"(,)

## end
#1812, 343:
"""
保存:...

"""
+连线类型(操作,模块)...

->[]{
    []:->顺序(模块,模块#2)->模块#2{[]=>内部(模块,)}...
        ->+画顺序(模块,模块#2)->+的(操作,+画顺序),
    ->[]
}...
->[]{
    []:->内容(模块,)=>内部(模块,模块#2)->模块#2->结尾(模块#2,模块#3)...
    =>+画if开头(模块,模块#2)->+的(操作,+画if开头)...
        ->[]{
            []:->起点(,模块),
            ->+画if结尾(模块,模块#3)->+的(操作,+画if结尾)
        },
    ->[]
}



## end
#1814, 6856:

<svg xmlns="http://www.w3.org/2000/svg"  viewBox="0 0 1000 501.33495638060464" style="overflow: hidden;border: 2px solid #888888;"> 
<polygon points="393,103 484,103 484,146 393,146 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="696,164 787,164 787,206 696,206 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="909,224 1000,224 1000,267 909,267 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="696,224 787,224 787,267 696,267 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="757,285 848,285 848,327 757,327 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="757,346 848,346 848,388 757,388 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="606,285 696,285 696,327 606,327 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="484,224 575,224 575,267 484,267 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="181,164 272,164 272,206 181,206 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="363,224 454,224 454,267 363,267 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="363,285 454,285 454,327 363,327 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="242,224 333,224 333,267 242,267 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="60,224 151,224 151,267 60,267 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="121,285 212,285 212,327 121,327 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polygon points="0,285 90,285 90,327 0,327 " style="fill:rgb(255,255,255);stroke:black;stroke-width:5;fill-rule:evenodd;" />
<polyline points="439,146 439,155 742,155 742,164 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="439,146 439,155 227,155 227,164 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="742,397 954,397 954,267 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="742,206 742,215 954,215 954,224 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="742,397 742,397 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="742,206 742,215 742,215 742,224 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="742,397 530,397 530,267 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="742,206 742,215 530,215 530,224 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="742,397 803,397 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="742,267 742,276 803,276 803,285 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="742,397 651,397 651,327 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="742,267 742,276 651,276 651,285 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="803,397 803,397 803,388 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="803,327 803,337 803,337 803,346 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="227,337 409,337 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="227,206 227,215 409,215 409,224 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="227,337 287,337 287,267 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="227,206 227,215 287,215 287,224 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="227,337 106,337 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="227,206 227,215 106,215 106,224 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="409,337 409,337 409,327 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="409,267 409,276 409,276 409,285 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="106,337 166,337 166,327 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="106,267 106,276 166,276 166,285 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="106,337 45,337 45,327 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<polyline points="106,267 106,276 45,276 45,285 " style="fill:none;stroke:rgb(0,0,0);stroke-width:5;fill-rule:evenodd;" />
<text dominant-baseline="middle" text-anchor="middle" x="45.454545" y="306.728084" font-size="15">D2</text>
<text dominant-baseline="middle" text-anchor="middle" x="166.666667" y="306.728084" font-size="15">D3</text>
<text dominant-baseline="middle" text-anchor="middle" x="106.060606" y="246.122024" font-size="15">D</text>
<text dominant-baseline="middle" text-anchor="middle" x="287.878788" y="246.122024" font-size="15">D4</text>
<text dominant-baseline="middle" text-anchor="middle" x="409.090909" y="306.728084" font-size="15">D51</text>
<text dominant-baseline="middle" text-anchor="middle" x="409.090909" y="246.122024" font-size="15">D5</text>
<text dominant-baseline="middle" text-anchor="middle" x="227.272727" y="185.515963" font-size="15">A</text>
<text dominant-baseline="middle" text-anchor="middle" x="530.303030" y="246.122024" font-size="15">C1</text>
<text dominant-baseline="middle" text-anchor="middle" x="651.515152" y="306.728084" font-size="15">C21</text>
<text dominant-baseline="middle" text-anchor="middle" x="803.030303" y="367.334145" font-size="15">C221</text>
<text dominant-baseline="middle" text-anchor="middle" x="803.030303" y="306.728084" font-size="15">C22</text>
<text dominant-baseline="middle" text-anchor="middle" x="742.424242" y="246.122024" font-size="15">C2</text>
<text dominant-baseline="middle" text-anchor="middle" x="954.545455" y="246.122024" font-size="15">C3</text>
<text dominant-baseline="middle" text-anchor="middle" x="742.424242" y="185.515963" font-size="15">C</text>
<text dominant-baseline="middle" text-anchor="middle" x="439.393939" y="124.909902" font-size="15">起点</text>

</svg>


## end
#1816, 221:
+[打开文件夹]"文档/S应用/结构化文本/md文件"

样本md:...
md模板:...
+[新建阅读窗口](,样本md)


文本内容:...
文本结构::
+[删除结构](,文本结构)->+[召唤星辰]"文本结构化"(文本内容,文本结构)

输出报告:...
+[删除结构](,输出报告)
'输出报告'的地址是"文档/S应用/结构化文本/md文件/README1.md"
+[召唤星辰]"结构文本转md"(文本结构,输出报告)




## end
#1818, 11428:

<div align="center">
  <img width="500px" src="https://github.com/taichi-dev/taichi/raw/master/misc/logo.png"/>
</div>

---
[![Latest Release](https://img.shields.io/github/v/release/taichi-dev/taichi?color=blue&label=Latest%20Release)](https://github.com/taichi-dev/taichi/releases/latest)
[![downloads](https://pepy.tech/badge/taichi)](https://pepy.tech/project/taichi)
[![CI](https://github.com/taichi-dev/taichi/actions/workflows/testing.yml/badge.svg)](https://github.com/taichi-dev/taichi/actions/workflows/testing.yml)
[![Nightly Release](https://github.com/taichi-dev/taichi/actions/workflows/release.yml/badge.svg)](https://github.com/taichi-dev/taichi/actions/workflows/release.yml)
<a href="https://discord.gg/f25GRdXRfg"><img alt="discord invitation link" src="https://dcbadge.vercel.app/api/server/f25GRdXRfg?style=flat"></a>

```shell
pip install taichi  # Install Taichi Lang
ti gallery          # Launch demo gallery
```

## What is Taichi Lang?

Taichi Lang is an open-source, imperative, parallel programming language for high-performance numerical computation. It is embedded in Python and uses just-in-time (JIT) compiler frameworks, for example LLVM, to offload the compute-intensive Python code to the native GPU or CPU instructions.

<a href="https://github.com/taichi-dev/taichi/blob/master/python/taichi/examples/simulation/fractal.py#L1-L31"> <img src="https://github.com/taichi-dev/public_files/raw/master/taichi/fractal_code.png" height="270px"></a>  <img src="https://raw.githubusercontent.com/taichi-dev/public_files/master/taichi/fractal_small.gif" height="270px">

The language has broad applications spanning real-time physical simulation, numerical computation, augmented reality, artificial intelligence, vision and robotics, visual effects in films and games, general-purpose computing, and much more.

<a href="https://github.com/taichi-dev/taichi/blob/master/python/taichi/examples/simulation/mpm128.py"><img src="https://github.com/taichi-dev/public_files/raw/master/taichi/mpm128.gif" height="192px"></a>
<a href="https://github.com/taichi-dev/quantaichi"> <img src="https://raw.githubusercontent.com/taichi-dev/public_files/master/taichi/smoke_3d.gif" height="192px"></a>
<a href="https://github.com/taichi-dev/taichi/blob/master/python/taichi/examples/rendering/sdf_renderer.py"><img src="https://github.com/taichi-dev/public_files/raw/master/taichi/sdf_renderer.jpg" height="192px"></a>
<a href="https://github.com/taichi-dev/taichi/blob/master/python/taichi/examples/simulation/euler.py"><img src="https://github.com/taichi-dev/public_files/raw/master/taichi/euler.gif" height="192px"></a>

<a href="https://github.com/taichi-dev/quantaichi"><img src="https://raw.githubusercontent.com/taichi-dev/public_files/master/taichi/elastic_letters.gif" height="213px"></a>
<a href="https://github.com/taichi-dev/quantaichi"><img src="https://raw.githubusercontent.com/taichi-dev/public_files/master/taichi/fluid_with_bunnies.gif" height="213px"></a>

[...More](#demos)

## Why Taichi Lang?

- Built around Python: Taichi Lang shares almost the same syntax with Python, allowing you to write algorithms with minimal language barrier. It is also well integrated into the Python ecosystem, including NumPy and PyTorch.
- Flexibility: Taichi Lang provides a set of generic data containers known as *SNode* (/ˈsnoʊd/), an effective mechanism for composing hierarchical, multi-dimensional fields. This can cover many use patterns in numerical simulation (e.g. [spatially sparse computing](https://docs.taichi-lang.org/docs/sparse)).
- Performance: With the `@ti.kernel` decorator, Taichi Lang's JIT compiler automatically compiles your Python functions into efficient GPU or CPU machine code for parallel execution.
- Portability: Write your code once and run it everywhere. Currently, Taichi Lang supports most mainstream GPU APIs, such as CUDA and Vulkan.
- ... and many more features! A cross-platform, Vulkan-based 3D visualizer, [differentiable programming](https://docs.taichi-lang.org/docs/differentiable_programming),  [quantized computation](https://github.com/taichi-dev/quantaichi) (experimental), etc.

## Getting Started

### Installation

<details>
  <summary>Prerequisites</summary>

<!--TODO: Precise OS versions-->

- Operating systems
  - Windows
  - Linux
  - macOS
- Python: 3.6 ~ 3.10 (64-bit only)
- Compute backends
  - x64/ARM CPUs
  - CUDA
  - Vulkan
  - OpenGL (4.3+)
  - Apple Metal
  - WebAssembly (experiemental)
 </details>

Use Python's package installer **pip** to install Taichi Lang:

```bash
pip install --upgrade taichi
```

*We also provide a nightly package. Note that nightly packages may crash because they are not fully tested.  We cannot guarantee their validity, and you are at your own risk trying out our latest, untested features. The nightly packages can be installed from our self-hosted PyPI (Using self-hosted PyPI allows us to provide more frequent releases over a longer period of time)*

```bash
pip install -i https://pypi.taichi.graphics/simple/ taichi-nightly
```

### Run your "Hello, world!"

Here is how you can program a 2D fractal in Taichi:

```py
# python/taichi/examples/simulation/fractal.py

import taichi as ti

ti.init(arch=ti.gpu)

n = 320
pixels = ti.field(dtype=float, shape=(n * 2, n))


@ti.func
def complex_sqr(z):
    return ti.Vector([z[0]**2 - z[1]**2, z[1] * z[0] * 2])


@ti.kernel
def paint(t: float):
    for i, j in pixels:  # Parallelized over all pixels
        c = ti.Vector([-0.8, ti.cos(t) * 0.2])
        z = ti.Vector([i / n - 1, j / n - 0.5]) * 2
        iterations = 0
        while z.norm() < 20 and iterations < 50:
            z = complex_sqr(z) + c
            iterations += 1
        pixels[i, j] = 1 - iterations * 0.02


gui = ti.GUI("Julia Set", res=(n * 2, n))

for i in range(1000000):
    paint(i * 0.03)
    gui.set_image(pixels)
    gui.show()
```

*If Taichi Lang is properly installed, you should get the animation below 🎉:*

<a href="https://github.com/taichi-dev/taichi/blob/master/python/taichi/examples/simulation/fractal.py#L1-L31"> </a><img src="https://raw.githubusercontent.com/taichi-dev/public_files/master/taichi/fractal_small.gif" height="270px">

See [Get started](https://docs.taichi-lang.org) for more information.

### Build from source

If you wish to try our our experimental features or build Taichi Lang for your own environments, see [Developer installation](https://docs.taichi-lang.org/docs/dev_install).

## Documentation

- [Technical documents](https://docs.taichi-lang.org/)
- [API Reference](https://docs.taichi-lang.org/api/)
- [Blog](https://docs.taichi-lang.org/blog)

## Community activity [![Time period](https://images.repography.com/32602247/taichi-dev/taichi/recent-activity/RlhQybvihwEjfE7ngXyQR9tudBDYAvl27v-NVNMxUrg_badge.svg)](https://repography.com)
[![Timeline graph](https://images.repography.com/32602247/taichi-dev/taichi/recent-activity/RlhQybvihwEjfE7ngXyQR9tudBDYAvl27v-NVNMxUrg_timeline.svg)](https://github.com/taichi-dev/taichi/commits)
[![Issue status graph](https://images.repography.com/32602247/taichi-dev/taichi/recent-activity/RlhQybvihwEjfE7ngXyQR9tudBDYAvl27v-NVNMxUrg_issues.svg)](https://github.com/taichi-dev/taichi/issues)
[![Pull request status graph](https://images.repography.com/32602247/taichi-dev/taichi/recent-activity/RlhQybvihwEjfE7ngXyQR9tudBDYAvl27v-NVNMxUrg_prs.svg)](https://github.com/taichi-dev/taichi/pulls)
[![Trending topics](https://images.repography.com/32602247/taichi-dev/taichi/recent-activity/RlhQybvihwEjfE7ngXyQR9tudBDYAvl27v-NVNMxUrg_words.svg)](https://github.com/taichi-dev/taichi/commits)

## Contributing

Kudos to all of our amazing contributors! Taichi Lang thrives through open-source. In that spirit, we welcome all kinds of contributions from the community. If you would like to participate, check out the [Contribution Guidelines](CONTRIBUTING.md) first.

<a href="https://github.com/taichi-dev/taichi/graphs/contributors"><img src="https://raw.githubusercontent.com/taichi-dev/public_files/master/taichi/contributors_taichi-dev_taichi_18.png" width="800px"></a>

*Contributor avatars are randomly shuffled.*

## License

Taichi Lang is distributed under the terms of Apache License (Version 2.0).

See [Apache License](https://github.com/taichi-dev/taichi/blob/master/LICENSE) for details.

## Community

For more information about the events or community, please refer to [this page](https://github.com/taichi-dev/community)


### Join our discussions

- [Discord](https://discord.gg/f25GRdXRfg)
- [GitHub Discussions](https://github.com/taichi-dev/taichi/discussions)
- [太极编程语言中文论坛](https://forum.taichi.graphics/)

### Report an issue

- If you spot an technical or documentation issue, file an issue at [GitHub Issues](https://github.com/taichi-dev/taichi/issues)
- If you spot any security issue, mail directly to <a href = "mailto:security@taichi.graphics?subject = Taichi Security Problem">security@taichi.graphics</a>.

### Contact us

- [Discord](https://discord.gg/f25GRdXRfg)
- [WeChat](https://forum.taichi-lang.cn/t/topic/2884)

## Reference

### Demos

- [Nerf with Taichi](https://github.com/taichi-dev/taichi-nerfs)
- [Taichi Lang examples](https://github.com/taichi-dev/taichi/tree/master/python/taichi/examples)
- [Advanced Taichi Lang examples](https://github.com/taichi-dev/advanced_examples)
- [Awesome Taichi](https://github.com/taichi-dev/awesome-taichi)
- [DiffTaichi](https://github.com/taichi-dev/difftaichi)
- [Taichi elements](https://github.com/taichi-dev/taichi_elements)
- [Taichi Houdini](https://github.com/taichi-dev/taichi_houdini)
- [More...](misc/links.md)


### AOT deployment

- [Taichi AOT demos & tutorial](https://github.com/taichi-dev/taichi-aot-demo/)


### Lectures & talks

- SIGGRAPH 2020 course on Taichi basics: [YouTube](https://youtu.be/Y0-76n3aZFA), [Bilibili](https://www.bilibili.com/video/BV1kA411n7jk/), [slides (pdf)](https://yuanming.taichi.graphics/publication/2020-taichi-tutorial/taichi-tutorial.pdf).
- Chinagraph 2020 用太极编写物理引擎: [哔哩哔哩](https://www.bilibili.com/video/BV1gA411j7H5)
- GAMES 201 高级物理引擎实战指南 2020: [课件](https://github.com/taichi-dev/games201)
- 太极图形课第一季：[课件](https://github.com/taichiCourse01)
- [TaichiCon](https://github.com/taichi-dev/taichicon): Taichi Developer Conferences
- More to come...

### Citations

If you use Taichi Lang in your research, please cite the corresponding papers:

- [**(SIGGRAPH Asia 2019) Taichi: High-Performance Computation on Sparse Data Structures**](https://yuanming.taichi.graphics/publication/2019-taichi/taichi-lang.pdf) [[Video]](https://youtu.be/wKw8LMF3Djo) [[BibTex]](https://raw.githubusercontent.com/taichi-dev/taichi/master/misc/taichi_bibtex.txt) [[Code]](https://github.com/taichi-dev/taichi)
- [**(ICLR 2020) DiffTaichi: Differentiable Programming for Physical Simulation**](https://arxiv.org/abs/1910.00935) [[Video]](https://www.youtube.com/watch?v=Z1xvAZve9aE) [[BibTex]](https://raw.githubusercontent.com/taichi-dev/taichi/master/misc/difftaichi_bibtex.txt) [[Code]](https://github.com/yuanming-hu/difftaichi)
- [**(SIGGRAPH 2021) QuanTaichi: A Compiler for Quantized Simulations**](https://yuanming.taichi.graphics/publication/2021-quantaichi/quantaichi.pdf) [[Video]](https://www.youtube.com/watch?v=0jdrAQOxJlY) [[BibTex]](https://raw.githubusercontent.com/taichi-dev/taichi/master/misc/quantaichi_bibtex.txt) [[Code]](https://github.com/taichi-dev/quantaichi)
## end
#1820, 1724:

<div align="center">
  <img width="500px" src="https://github.com/taichi-dev/taichi/raw/master/misc/logo.png"/>
</div>

---
[![Latest Release](https://img.shields.io/github/v/release/taichi-dev/taichi?color=blue&label=Latest%20Release)](https://github.com/taichi-dev/taichi/releases/latest)
[![downloads](https://pepy.tech/badge/taichi)](https://pepy.tech/project/taichi)
[![CI](https://github.com/taichi-dev/taichi/actions/workflows/testing.yml/badge.svg)](https://github.com/taichi-dev/taichi/actions/workflows/testing.yml)
[![Nightly Release](https://github.com/taichi-dev/taichi/actions/workflows/release.yml/badge.svg)](https://github.com/taichi-dev/taichi/actions/workflows/release.yml)
<a href="https://discord.gg/f25GRdXRfg"><img alt="discord invitation link" src="https://dcbadge.vercel.app/api/server/f25GRdXRfg?style=flat"></a>

```shell
pip install taichi  # Install Taichi Lang
ti gallery          # Launch demo gallery
```

## 标题

<a href="https://github.com/taichi-dev/taichi/blob/master/python/taichi/examples/simulation/fractal.py#L1-L31"> <img src="https://github.com/taichi-dev/public_files/raw/master/taichi/fractal_code.png" height="270px"></a>  <img src="https://raw.githubusercontent.com/taichi-dev/public_files/master/taichi/fractal_small.gif" height="270px">

[...More](#标题2)

## 标题2

- pt1
- pt2


### 三级标题

<details>
  <summary>Prerequisites</summary>
内容
 </details>

Use Python's package installer **加粗** to install Taichi Lang:

```类型(shell/bash/py)
代码
```

*斜体*
See [Get started](链接) for more information.



## License

Taichi Lang is distributed under the terms of Apache License (Version 2.0).

See [Apache License](https://github.com/taichi-dev/taichi/blob/master/LICENSE) for details.




## end
#1821, 431:
"""
Nini, 打开人体模型(文件)
Nini, 打开CBS(文件)

"""

+召唤规则(_媒介,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_凭依)...

->[==]"结构文本转博客"(,召唤星辰)...
    ->+整理图片(_媒介,_凭依)->+的(操作,+整理图片)...
    ->+整理内容(_媒介,_凭依)->+的(操作,+整理内容)...
    ->+整理引用(_媒介,_凭依)->+的(操作,+整理引用)...

    ->+整体架构(_媒介,_凭依)->+的(操作,+整体架构)...

->[]{
    []=>的(_媒介,_章节)->_章节=>+章节内容(_章节,_凭依)->+的(操作,+章节内容)
}...
->[]{
    []:->.(_媒介,_原始结构)->_原始结构(,)...
        ->+引用文章(_原始结构,_凭依)->+的(操作,+引用文章),
    ->[]
}

## end
#1822, 438:
"""
描述结构:...

"""
+设置关联(_媒介,_凭依)->+[del](,+设置关联)...
->的(设置关联,描述结构)...

->+[临时文本]"/index.html"...
->+[code]([想],描述结构)->[想](_媒介,_凭依)...
->操作([想],)->[]{
    []=>的(操作,_操作)->_操作(,_章节)->_章节(,)...
        =>."next"(_操作,_next)->的(_next,地址#n)->[说](,地址#n)...
        ->."prev"(_操作,_prev)->的(_prev,地址#p)->[说](,地址#p)...
    ->+[模板文本](_章节,_章节)...
        ->+[.]"next"(+[模板文本],地址#n)->+[.]"prev"(+[模板文本],地址#p)...
        ->+[.]"home"(+[模板文本],+[临时文本])
}

## end
#1823, 693:
"""


"""

+描述结构(_媒介,_凭依)->+操作(+描述结构,)...

->的(_媒介,一级标题)->原型(_章节0,一级标题)...
    ->+补充按键(,_章节0)->+的(+操作,+补充按键)...
->[]{
    []:->的(_媒介,二级标题#1)->二级标题#1{[]=>然后(,二级标题#1)}...
        ->原型(_章节1,二级标题#1)->+[.]"next"(+补充按键,_章节1)...
    ->的(_媒介,二级标题#2)->二级标题#2{[]=>然后(二级标题#2,)}...
        ->原型(_章节2,二级标题#2)->+[.]"prev"(+补充按键,_章节2),
    ->+[.]"next"(+补充按键,_章节0)->+[.]"prev"(+补充按键,_章节0)
}...

=>的(_凭依,_章节)->_章节->原型(_章节,二级标题)...
=>+补充按键(,_章节)->+的(+操作,+补充按键)...
->[]{
    []:->然后(二级标题,_next)->_next->原型(_章节1,_next)...
        ->+[.]"next"(+补充按键,_章节1),
    ->+[.]"next"(+补充按键,_章节0)
}...
->[]{
    []:->然后(_prev,二级标题)->_prev->原型(_章节1,_prev)...
        ->+[.]"prev"(+补充按键,_章节1),
    ->+[.]"prev"(+补充按键,_章节0)
}


## end
#1826, 414:
"""
描述结构:...

"""
+设置关联(_媒介,_凭依)->+[del](,+设置关联)...
->的(设置关联,描述结构)...

->+[临时文本]"/index.html"...
->+[code]([想],描述结构)->[想](_媒介,_凭依)...
->操作([想],)->[]{
    []=>的(操作,_操作)->_操作(,_章节)->_章节(,)...
        =>."next"(_操作,_next)->的(_next,地址#n)...
        ->."prev"(_操作,_prev)->的(_prev,地址#p)...
    ->+[模板文本](_章节,_章节)...
        ->+[.]"next"(+[模板文本],地址#n)->+[.]"prev"(+[模板文本],地址#p)...
        ->+[.]"home"(+[模板文本],+[临时文本])
}

## end
#1827, 50:
"""


"""

ans="%s/css/styleSheet.css"%(address)


## end
#1828, 864:
* {
  box-sizing: border-box;
  font-family: Arial, Helvetica, sans-serif;
}

body {
  margin: 0;
  font-family: Arial, Helvetica, sans-serif;
}

/* Style the top navigation bar */
.topnav {
  overflow: hidden;
  background-color: #333;
}

/* Style the topnav links */
.topnav a {
  float: left;
  display: block;
  color: #f2f2f2;
  text-align: center;
  padding: 14px 16px;
  text-decoration: none;
}

/* Change color on hover */
.topnav a:hover {
  background-color: #ddd;
  color: black;
}


/* Style the content */
.content {
  background-color: #fff;
  padding: 10px;
}

/* Style the footer */
.footer {
  background-color: #333;
  padding: 10px;
  margin-top: 20px
}

.footer p {
  color: #ddd
}

.w3D {
    background-color: #000;
    width: 95%;
    height: 400px;
    border: 2px solid black;
    position: float; /* fixed or static */
    left: 2.5%;
}

## end
#1831, 205:
"""
css1:...
P代码:...

"""
+设置css(,_地址)->+[del](,+设置css)...
->的(设置css,css1)->的(设置css,P代码)...

->+[python](Python,+[保存文本])->+[code](+[python],P代码)...
    ->+[.]"address"(+[python],_地址)...

->+[保存文本](,css1)


## end
#1832, 8520:
/**
 * @author qiao / https://github.com/qiao
 * @author mrdoob / http://mrdoob.com
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 */

function print() {
    document.getElementById("cmd_window").innerHTML+="<br>";
    for (var i=0; i < arguments.length; i++) {
        text=arguments[i];
        document.getElementById("cmd_window").innerHTML+=" "+text;
    }
}

THREE.OrbitControls = function ( object, domElement ) {

	this.object = object;
	this.domElement = ( domElement !== undefined ) ? domElement : document;

	// API

	this.enabled = true;

	this.center = new THREE.Vector3();

	this.userZoom = true;
	this.userZoomSpeed = 1.0;

	this.userRotate = true;
	this.userRotateSpeed = 1.0;

	this.userPan = true;
	this.userPanSpeed = 2.0;

	this.autoRotate = false;
	this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

	this.minPolarAngle = 0; // radians
	this.maxPolarAngle = Math.PI; // radians

	this.minDistance = 0;
	this.maxDistance = Infinity;

	// 65 /*A*/, 83 /*S*/, 68 /*D*/
	this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40, ROTATE: 65, ZOOM: 83, PAN: 68, A: 65, D: 68};

	// internals

	var scope = this;

	var EPS = 0.000001;
	var PIXELS_PER_ROUND = 1800;

	var rotateStart = new THREE.Vector2();
	var rotateEnd = new THREE.Vector2();
	var rotateDelta = new THREE.Vector2();

	var zoomStart = new THREE.Vector2();
	var zoomEnd = new THREE.Vector2();
	var zoomDelta = new THREE.Vector2();

	var phiDelta = 0;
	var thetaDelta = 0;
	var scale = 1;

	var lastPosition = new THREE.Vector3();

	var STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2 };
	var state = STATE.NONE;

	// events

	var changeEvent = { type: 'change' };


	this.rotateLeft = function ( angle ) {

		if ( angle === undefined ) {

			angle = getAutoRotationAngle();

		}

		thetaDelta -= angle;

	};

	this.rotateRight = function ( angle ) {

		if ( angle === undefined ) {

			angle = getAutoRotationAngle();

		}

		thetaDelta += angle;

	};

	this.rotateUp = function ( angle ) {

		if ( angle === undefined ) {

			angle = getAutoRotationAngle();

		}

		phiDelta -= angle;

	};

	this.rotateDown = function ( angle ) {

		if ( angle === undefined ) {

			angle = getAutoRotationAngle();

		}

		phiDelta += angle;

	};

	this.zoomIn = function ( zoomScale ) {

		if ( zoomScale === undefined ) {

			zoomScale = getZoomScale();

		}

		scale /= zoomScale;

	};

	this.zoomOut = function ( zoomScale ) {

		if ( zoomScale === undefined ) {

			zoomScale = getZoomScale();

		}

		scale *= zoomScale;

	};

	this.pan = function ( distance ) {

		distance.transformDirection( this.object.matrix );
		distance.multiplyScalar( scope.userPanSpeed );

		this.object.position.add( distance );
		this.center.add( distance );

	};

	this.update = function () {
	
		var position = this.object.position;
		var offset = position.clone().sub( this.center );

		// angle from z-axis around y-axis

		var theta = Math.atan2( offset.x, offset.z );

		// angle from y-axis

		var phi = Math.atan2( Math.sqrt( offset.x * offset.x + offset.z * offset.z ), offset.y );

		if ( this.autoRotate ) {

			this.rotateLeft( getAutoRotationAngle() );

		}

		theta += thetaDelta;
		phi += phiDelta;

		// restrict phi to be between desired limits
		phi = Math.max( this.minPolarAngle, Math.min( this.maxPolarAngle, phi ) );

		// restrict phi to be betwee EPS and PI-EPS
		phi = Math.max( EPS, Math.min( Math.PI - EPS, phi ) );

		var radius = offset.length() * scale;

		// restrict radius to be between desired limits
		radius = Math.max( this.minDistance, Math.min( this.maxDistance, radius ) );

		offset.x = radius * Math.sin( phi ) * Math.sin( theta );
		offset.y = radius * Math.cos( phi );
		offset.z = radius * Math.sin( phi ) * Math.cos( theta );


		position.copy( this.center ).add( offset );

		this.object.lookAt( this.center );

		thetaDelta = 0;
		phiDelta = 0;
		scale = 1;

		if ( lastPosition.distanceTo( this.object.position ) > 0 ) {

			this.dispatchEvent( changeEvent );

			lastPosition.copy( this.object.position );

		}

	};


	function getAutoRotationAngle() {

		return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

	}

	function getZoomScale() {

		return Math.pow( 0.95, scope.userZoomSpeed );

	}

	function onMouseDown( event ) {

		if ( scope.enabled === false ) return;
		if ( scope.userRotate === false ) return;

		event.preventDefault();
		
		if ( state === STATE.NONE )
		{
			if ( event.button === 0 )		
//print("左键1!!");
				//state = STATE.ZOOM;
				state = STATE.ROTATE;
			if ( event.button === 1 )		
//print("滚动!!",STATE.ZOOM,STATE.ROTATE);
				state = STATE.ZOOM;
			if ( event.button === 2 )
//print("右键");
				state = STATE.PAN;
				//state = STATE.ROTATE;
		}
		
		
		if ( state === STATE.ROTATE ) {

			//state = STATE.ROTATE;

			rotateStart.set( event.clientX, event.clientY );

		} else if ( state === STATE.ZOOM ) {

			//state = STATE.ZOOM;

			zoomStart.set( event.clientX, event.clientY );

		} else if ( state === STATE.PAN ) {

			//state = STATE.PAN;

		}

		document.addEventListener( 'mousemove', onMouseMove, false );
		document.addEventListener( 'mouseup', onMouseUp, false );

	}

	function onMouseMove( event ) {

		if ( scope.enabled === false ) return;

		event.preventDefault();

		
		if ( state === STATE.ROTATE ) {
		//if ( state === 0 ) {
//print(event.clientX, event.clientY ,rotateEnd, rotateStart);
			rotateEnd.set( event.clientX, event.clientY );
			rotateDelta.subVectors( rotateEnd, rotateStart );

			scope.rotateLeft( 2 * Math.PI * rotateDelta.x / PIXELS_PER_ROUND * scope.userRotateSpeed );
			scope.rotateUp( 2 * Math.PI * rotateDelta.y / PIXELS_PER_ROUND * scope.userRotateSpeed );

			scope.update();
			rotateStart.copy( rotateEnd );

		} else if ( state === STATE.ZOOM ) {

			zoomEnd.set( event.clientX, event.clientY );
			zoomDelta.subVectors( zoomEnd, zoomStart );

			if ( zoomDelta.y > 0 ) {

				scope.zoomIn();

			} else {

				scope.zoomOut();

			}

			zoomStart.copy( zoomEnd );

		} else if ( state === STATE.PAN ) {

			var movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
			var movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

			scope.pan( new THREE.Vector3( - movementX, movementY, 0 ) );

		}

	}

	function onMouseUp( event ) {

		if ( scope.enabled === false ) return;
		if ( scope.userRotate === false ) return;

		document.removeEventListener( 'mousemove', onMouseMove, false );
		document.removeEventListener( 'mouseup', onMouseUp, false );

		state = STATE.NONE;

	}

	function onMouseWheel( event ) {

		if ( scope.enabled === false ) return;
		if ( scope.userZoom === false ) return;

		var delta = 0;

		if ( event.wheelDelta ) { // WebKit / Opera / Explorer 9

			delta = event.wheelDelta;

		} else if ( event.detail ) { // Firefox

			delta = - event.detail;

		}

		if ( delta > 0 ) {

			scope.zoomOut();

		} else {

			scope.zoomIn();

		}

	}

	function onKeyDown( event ) {

		if ( scope.enabled === false ) return;
		if ( scope.userPan === false ) return;

		switch ( event.keyCode ) {

			
			case scope.keys.A:
				scope.zoomIn(1.1);
				scope.update();
				break;
			case scope.keys.D:
				scope.zoomOut(1.1);
				scope.update();
				break;
			case scope.keys.UP:
				scope.pan( new THREE.Vector3( 0, 1, 0 ) );
				break;
			case scope.keys.BOTTOM:
				scope.pan( new THREE.Vector3( 0, - 1, 0 ) );
				break;
			case scope.keys.LEFT:
				scope.pan( new THREE.Vector3( - 1, 0, 0 ) );
				break;
			case scope.keys.RIGHT:
				scope.pan( new THREE.Vector3( 1, 0, 0 ) );
				break;
			
			case scope.keys.ROTATE:
				state = STATE.ROTATE;
				break;
			case scope.keys.ZOOM:
				state = STATE.ZOOM;
				break;
			case scope.keys.PAN:
				state = STATE.PAN;
				break;
				
		}

	}
	
	function onKeyUp( event ) {

		switch ( event.keyCode ) {

			case scope.keys.ROTATE:
			case scope.keys.ZOOM:
			case scope.keys.PAN:
				state = STATE.NONE;
				break;
		}

	}

	this.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );
	this.domElement.addEventListener( 'mousedown', onMouseDown, false );
	this.domElement.addEventListener( 'mousewheel', onMouseWheel, false );
	this.domElement.addEventListener( 'DOMMouseScroll', onMouseWheel, false ); // firefox
	window.addEventListener( 'keydown', onKeyDown, false );
	window.addEventListener( 'keyup', onKeyUp, false );

};

THREE.OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );
## end
#1833, 6653:
/*

*/


// MAIN

// standard global variables
var container, scene, camera, renderer, controls, stats;
var cube;

class Scene3D {
    constructor(ID='') {
        this.m_ID=ID;
        this.m_container='';
        this.m_scene='';
        this.m_camera='';
        this.m_render='';
        this.m_control='';
    }

    init(ID='') {
        if(ID!=="") {
            this.m_ID=ID;
            this.m_container = document.getElementById(this.m_ID);
        }
        else {
            this.m_container=document.body;
        }
        if(this.m_container===null) {
            this.m_container=document.body;
        }

        // SCENE
        this.m_scene = new THREE.Scene();
    
        // CAMERA
        var SCREEN_WIDTH = this.m_container.offsetWidth; 
        var SCREEN_HEIGHT = this.m_container.offsetHeight;
        var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
        this.m_camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
        this.m_scene.add(this.m_camera);
        this.m_camera.position.set(0,150,400);
        this.m_camera.lookAt(this.m_scene.position);
        //this.m_camera.lookAt(new THREE.Vector3(0,600,0));
        //this.m_camera.lookAt(0,600,0);
    
        //RENDER
        this.m_renderer = new THREE.WebGLRenderer( {antialias:true} );
        this.m_renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
        
        this.m_container.appendChild( this.m_renderer.domElement );
    
        // CONTROLS
        this.m_controls = new THREE.OrbitControls( this.m_camera, this.m_renderer.domElement );
        // LIGHT
        var light = new THREE.PointLight(0xffffff);
        light.position.set(0,150,100);
        this.m_scene.add(light);
    
        // FLOOR
        var floorTexture = new THREE.ImageUtils.loadTexture( 'https://stemkoski.github.io/Three.js/images/checkerboard.jpg' );
        floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping; 
        floorTexture.repeat.set( 10, 10 );
        var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } );
    
        var floorGeometry = new THREE.PlaneGeometry(1000, 1000, 10, 10);
        var floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.position.y = -0.5;
        floor.rotation.x = Math.PI / 2;
        this.m_scene.add(floor);
    
        // SKYBOX/FOG
        var skyBoxGeometry = new THREE.CubeGeometry( 10000, 10000, 10000 );
        var skyBoxMaterial = new THREE.MeshBasicMaterial( { color: 0x9999ff, side: THREE.BackSide } );
        var skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );
        this.m_scene.add(skyBox);
    }

    update() {
        this.m_renderer.render( this.m_scene, this.m_camera );
        this.m_controls.update();
    }

    addBox(L,W,H,x,y,z) {
        var material = new THREE.MeshNormalMaterial();
        var cubeGeometry = new THREE.CubeGeometry( 1, 1, 1 );
        var cube = new THREE.Mesh( cubeGeometry, material );
        cube.position.set(x,y,z);
        cube.scale.x=L;
        cube.scale.y=W;
        cube.scale.z=H;
        this.m_scene.add( cube );
        return cube;
    }

    addCylinder(R,H,x,y,z) {
        var material = new THREE.MeshNormalMaterial();
        var geometry = new THREE.CylinderGeometry( 1,1,1,80,4 );
        var shape = new THREE.Mesh( geometry, material );
        shape.position.set(x, y, z);
        shape.scale.x=R;
        shape.scale.y=H;
        shape.scale.z=R;
        this.m_scene.add( shape );
        return shape;
    }

    addSphere(R,x,y,z) {
        var material = new THREE.MeshNormalMaterial();
        var geometry = new THREE.SphereGeometry( 1,32,16 );
        var shape = new THREE.Mesh( geometry, material );
        shape.scale.x=R;
        shape.scale.y=R;
        shape.scale.z=R;
        shape.position.set(x, y, z);
        this.m_scene.add( shape );
        return shape;
    }

    addExtrudePolygon(shx,shy,height,x,y,z) {
        const shape = new THREE.Shape();
        for (var i=0;i<shx.length;i++) {
            if(i==0) {
                shape.moveTo(shx[i],shy[i]);
            }
            else {
                shape.lineTo(shx[i],shy[i]);
            }
        }
        const extrudeSettings = {
        	steps: 2,
                amount: height,
        	bevelEnabled: false,
        };
        
        const geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );
        const material = new THREE.MeshNormalMaterial();
        const mesh = new THREE.Mesh( geometry, material ) ;
        mesh.position.set(x,y,z);
        this.m_scene.add(mesh);
        
        return mesh;
    }

    setRotationByEuler(shape,alpha,beta,gamma) {
        shape.setRotationFromEuler(new THREE.Euler(0,0,0,'XYZ'));
        shape.rotateZ(alpha/180*Math.PI);
        shape.rotateX(beta/180*Math.PI);
        shape.rotateZ(gamma/180*Math.PI);
        return shape;
    }

    rotateInWorld(shape,pt,angle,axis='Z') {
        var T=new THREE.Matrix4().identity();
        T=T.multiply(new THREE.Matrix4().makeTranslation(pt[0],pt[1],pt[2]));
        if(axis==='X') {
            T=T.multiply(new THREE.Matrix4().makeRotationX(angle/180*Math.PI));
        }
        else if(axis==='Y') {
            T=T.multiply(new THREE.Matrix4().makeRotationY(angle/180*Math.PI));
        }
        else if(axis==='Z') {
            T=T.multiply(new THREE.Matrix4().makeRotationZ(angle/180*Math.PI));
        }
        T=T.multiply(new THREE.Matrix4().makeTranslation(-pt[0],-pt[1],-pt[2]));
        
        shape.updateMatrix();
        shape.applyMatrix(T);
        return shape;
    }

    lookAt_pt(shape,pt) {
        shape.lookAt(new THREE.Vector3(pt[0],pt[1],pt[2]));
        return shape;
    }

    lookAt(shape,shape0) {
        shape.lookAt(shape0.position);
        return shape;
    }

    cameraLookAt_pt(pt) {
        this.lookAt_pt(this.m_camera,pt);
        this.m_controls.center.x=pt[0];
        this.m_controls.center.y=pt[1];
        this.m_controls.center.z=pt[2];
    }

    cameraLookAt(shape) {
        this.lookAt(this.m_camera,shape);
        this.m_controls.center.x=shape.position.x;
        this.m_controls.center.y=shape.position.y;
        this.m_controls.center.z=shape.position.z;
    }

}

var world_3D=new Scene3D();

function animate_3D() {
    requestAnimationFrame(animate_3D);
    world_3D.update();
}

function printMatrix(matrix) {
    var list_val=matrix.elements;
    var str_line='';
    for(var i=0;i<4;i++) {
        for(var j=0;j<4;j++) {
            str_line+=`${list_val[j+i*4]}, `;
        }
        //print(str_line);
        str_line='';
    }
    //print();
}



## end
#1834, 87:
"""


"""

ans="%s/js/threeWorld.js"%(address)
js2="%s/js/OrbitControls.js"%(address)


## end
#1838, 273:
"""
js1:...
js2:...
P代码:...

"""
+设置js(,_地址)->+[del](,+设置js)...
->的(设置js,js1)->的(设置js,js2)->的(设置js,P代码)...

->+[python](Python,+[保存文本])->+[code](+[python],P代码)...
    ->+[.]"address"(+[python],_地址)...
->+[o]"js2"(+[python],+[保存文本]#2)...

->+[保存文本](,js1)->+[保存文本]#2(,js2)



## end
#1839, 338:
"""
记住"Python"
Nini, 打开网页画板(文件)
print(address.split('/')[-1])

"""

# pattern="<h2><a href=\"/%s%s\">%s</a></h2>\n"
pattern1="<h2><a href=\"./%s\">%s</a></h2>\n"
ans=''

proj_name=address.split('/')[-1]
for i in range(len(list_ads)):
#    ans+=pattern%(proj_name,list_ads[i],list_names[i])
    ans+=pattern1%(list_ads[i],list_names[i])



## end
#1840, 745:
<!--
+[返回目录]

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="./css/styleSheet.css">
  </head>


<body>
<div class="topnav">
  <a href="#">Link</a>
  <a href="#">Link</a>
  <a href="#">Link</a>
</div>

<div class="content">
    <p><mathjax style=\"font-size:1.5em\">
%内容
    </mathjax></p>
</div>

<div class="footer">
  <p>Footer</p>
</div>

</body>
</html>

## end
#1843, 599:
"""
P代码:...
正文模板:...

"""
+设置index(,_地址)->+[del](,+设置index)...
->的(设置index,正文模板)->的(设置index,P代码)...

->+[python]"list_ads=[]
list_names=[]"(Python,)->[]{
    []=>.(+设置index,_章节)->_章节->的(_章节,地址#1)...
        ->的(_章节,原型)->原型(,_原型)->的(_原型,题目)...
    =>+[python]"list_ads.append(address)
list_names.append(name)"(Python,)...
        ->+[.]"address"(+[python],地址#1)->+[.]"name"(+[python],题目)
}...

->+[python](Python,+[临时文本])->+[code](+[python],P代码)...
    ->+[.]"address"(+[python],_地址)...

->+[模板文本](正文模板,+[临时文本])->+[.]"内容"(+[模板文本],+[临时文本])...
->+[增加内容2](_地址,+[保存文本])->+[保存文本]"/index.html"(,+[临时文本])



## end
#1848, 43:

设置index:...
设置js:...
设置css:...

设置关联:...


## end
#1849, 227:
"""


"""
+描述结构(_媒介,_凭依)->+操作(+描述结构,)...

->的(_凭依,地址#0)...
->+设置index(,地址#0)->+的(+操作,+设置index)...
->[]{
    []=>的(_凭依,_章节)->的(_章节,地址)=>+[.](+设置index,_章节)
}...

->+设置js(,地址#0)->+的(+操作,+设置js)...
->+设置css(,地址#0)->+的(+操作,+设置css)



## end
#1850, 224:
"""
记住"Python"
运行指令"nautilus tools"
system

"""
import os
os.system('mkdir %s/css'%(proj_address))
os.system('mkdir %s/pages'%(proj_address))
os.system('mkdir %s/res'%(proj_address))
os.system('mkdir %s/js'%(proj_address))


## end
#1854, 493:
"""
P代码:...
描述结构:...
库:...
+[新建阅读窗口](,描述结构)

"""
+整体架构(_媒介,_凭依)->+[del](,+整体架构)...
->的(整体架构,P代码)->的(整体架构,描述结构)->的(整体架构,库)...
->的(库,设置关联)...

->的(_凭依,地址)...
->+[python](Python,)->+[code](+[python],P代码)...
->+[.]"proj_address"(+[python],地址)...

->+[code]([想],描述结构)->[想](_媒介,_凭依)...
->操作([想],)->[]{
    []=>的(操作,_操作)->_操作(,_宾语)->_宾语(,)...
    =>的(库,_条目)->[eq](_操作,_条目)...
        ->+[做](,_宾语)->+[code](+[做],_条目)...
        =>.(_操作,_输入)=>+[.](+[做],_输入)
}...

->+[做](_媒介,_凭依)->+[code](+[做],设置关联)



## end
#1855, 543:
"""
+[P函数](,测试)
Nini, 打开公式分析器(文件)

"""

list_lk=['a1','a2','c1']
paper_text="""
[a1,a2]
[1].
[c1],[c1]

"""

import re

link_pat='\[([a-zA-Z]+\d*)(, ?[a-zA-Z]+\d*)*\]'
i=0
out_text=''

while True:
    if i>=len(paper_text):
        break
    a=re.match(link_pat,paper_text[i:])
    if a!=None and a.group(1) in list_lk:
        new_text='\\cite{%s}'%(a.group()[1:-1])
        di0=a.span()[1]
        out_text+=new_text
        i+=di0-1
    else:
        out_text+=paper_text[i]

    i+=1

print(out_text)


"""
print(a.span())
+[P函数](,测试)

"""
## end
#1857, 422:
"""
记住"Python"
测试:...

"""

import re

link_pat='\[([a-zA-Z]+\d*)(, ?[a-zA-Z]+\d*)*\]'
i=0
out_text=''

while True:
    if i>=len(paper_text):
        break
    a=re.match(link_pat,paper_text[i:])
    if a!=None and a.group(1) in list_lk:
        new_text='\\cite{%s}'%(a.group()[1:-1])
        di0=a.span()[1]
        out_text+=new_text
        i+=di0-1
    else:
        out_text+=paper_text[i]
    i+=1

ans=out_text



## end
#1859, 390:
"""
P代码:...
print(list_lk)
print(paper_text)

"""

+整理引用(_媒介,_文本)->+[del](,+整理引用)...
->的(整理引用,P代码)...

->.(_媒介,_文章)...
->+[python]"list_lk=[]"(Python,)->[]{
    []=>的(_文章,_节点)->_节点->引用(_节点,)...
    =>+[标题](_节点,)->+[python]"list_lk.append(name)"(Python,)...
        ->+[s]"name"(+[python],+[标题])
}...

->+[python](Python,_文本)->+[code](+[python],P代码)...
->+[s]"paper_text"(+[python],_文本)





## end
#1860, 491:
"""


"""
+描述结构(_章节结构,_文本)->+操作(+描述结构,)...

->[]{
    []:->[is](_章节结构,一级标题)->一级标题(,)...
        ->+生成标题(一级标题,_文本)->+的(+操作,+生成标题),
    ->[is](_章节结构,文本)->文本(,)...
        ->+生成作者(文本,_文本)->+的(+操作,+生成作者),
    ->[is](_章节结构,_章节)->_章节->的(_章节,题目)->[==]"Abstract"(,题目)...
        ->+生成概述(_章节,_文本)->+的(+操作,+生成概述),
    ->[is](_章节结构,_附录)->_附录->的(_附录,题目#2)->[==]"Appendix"(,题目#2)...
        ->+生成附录(_附录,_文本)->+的(+操作,+生成附录),
    ->[is](_章节结构,二级标题)->二级标题(,)...
        ->+生成章节(二级标题,_文本)->+的(+操作,+生成章节)
}



## end
#1861, 19:

<h1>%题目</h1>
%内容


## end
#1862, 37:
<img src="..%目标地址" width="95%"><br>


## end
#1863, 94:
"""
记住"Python"

"""

fig_type=source_dir.split('.')[-1]
ans="/res/%s.%s"%(fig_name,fig_type)


## end
#1864, 38:
<img src="..%目标地址" height="200"><br>


## end
#1868, 550:
"""
P代码:...
L模板:...
L模板2:...

"""

+图片结构(_节点,_内容)->+[del](,+图片结构)...
->的(图片结构,L模板)->的(图片结构,L模板2)->的(图片结构,P代码)...

->."输出"(+图片结构,_输出)->的(_输出,地址)...

->的(_节点,类型)->的(_节点,位置)...
->的(_节点,名字)->的(_节点,图例)->的(_节点,源地址)...
->的(_节点,目标地址)...

->+[python](Python,目标地址)->+[code](+[python],P代码)...
->+[.]"source_dir"(+[python],源地址)->+[.]"fig_name"(+[python],名字)...
->+[.]"address"(+[python],地址)...

->+[模板文本](,+[增加内容2])->+[增加内容2](,_内容)...
->+[.](+[模板文本],目标地址)->+[.](+[模板文本],图例)->+[.](+[模板文本],位置):

->[==]"normal"(,类型)->+[code](+[模板文本],L模板),
->+[code](+[模板文本],L模板2)


## end
#1869, 130:

<div id="%名字" class="w3D"></div>
<script>
world_3D.init("%名字");
</script>
<script type="text/javascript" src="..%目标地址"></script>

## end
#1870, 50:
"""
记住"Python"

"""

ans="/res/%s.js"%(fig_name)


## end
#1871, 62:
var shape, pt, eulers;

%内容

animate_3D();
world_3D.update();

## end
#1875, 536:
"""
P代码:...
L模板:...
模板2:...

"""

+3D结构(_节点,_内容)->+[del](,+3D结构)...
->的(3D结构,L模板)->的(3D结构,模板2)->的(3D结构,P代码)...

->."输出"(+3D结构,_输出)->的(_输出,地址)...

->的(_节点,名字)->的(_节点,内容)...
->+的(_节点,+目标地址)...

->+[python](Python,+目标地址)->+[code](+[python],P代码)...
->+[.]"fig_name"(+[python],名字)->+[.]"address"(+[python],地址)...

->+[模板文本](,+[增加内容2])->+[增加内容2](,_内容)...
->+[code](+[模板文本],L模板)...
->+[.](+[模板文本],+目标地址)->+[.](+[模板文本],名字)...

->+[模板文本](模板2,+[临时文本])->+[.](+[模板文本],内容)...
->+[增加内容](地址,+[保存文本])->+[增加内容](+目标地址,+[保存文本])...
    ->+[保存文本](,+[临时文本])

## end
#1876, 160:
<style>
table, th, td{
    border: 1px solid black;
    text-align: left;
    font-size:20px;
    #color:red;
}
</style>

<table style="width:50%">
%内容
</table>
## end
#1877, 648:
"""
记住"Python"
+[P函数](,P代码)

"""
import numpy as np
import re

rows=txt_in.split('\n')
txt_out=''
type_out=''
len_max=0

for row in rows:
    row0=re.sub('; *','',row)
    if row0=='':
        continue
    list_ele=re.split('[,] *',row0)

    len_max=np.max([len_max,len(list_ele)])

    if txt_out=='':
        for txt_ele in list_ele:
            txt_out+="\n\\textrm{%s}&"%(txt_ele)
        txt_out=txt_out[0:-1]
        txt_out+='\\\\\n\\colrule'
    else:
        for txt_ele in list_ele:
            txt_out+=" %s &"%(txt_ele)
        txt_out=txt_out[0:-1]
        txt_out+='\\\\\n'

for i in range(len_max):
    type_out+='c'

ans=txt_out



## end
#1879, 562:
"""
记住"Python"
+[P函数](,P代码)
保存:...

"""
import numpy as np
import re

rows=txt_in.split('\n')
txt_out=''
type_out=''
len_max=0

for row in rows:
    row0=re.sub('; *','',row)
    if row0=='':
        continue
    list_ele=re.split('[,] *',row0)

    len_max=np.max([len_max,len(list_ele)])

    if txt_out=='':
        line='<tr><th>'+'</th><th>'.join(list_ele)+'</th></tr>'
        txt_out+=line+'\n'
    else:
        line='<tr><td>'+'</td><td>'.join(list_ele)+'</td></tr>'
        txt_out+=line+'\n'

for i in range(len_max):
    type_out+='c'

ans=txt_out



## end
#1880, 37:
<img src="..%目标地址" width="95%"><br>


## end
#1884, 572:
"""
P代码:...
L模板:...
L模板2:...

"""

+表格结构(_节点,_内容)->+[del](,+表格结构)...
->的(表格结构,L模板)->的(表格结构,L模板2)->的(表格结构,P代码)...

->的(_节点,类型)->的(_节点,位置)...
->的(_节点,名字)->的(_节点,图例)...
->的(_节点,内容)...
->+[python](Python,+[临时文本])->+[code](+[python],P代码)...
->+[.]"txt_in"(+[python],内容)->+[.]"fig_name"(+[python],名字)...

->+[模板文本](,+[增加内容2])->+[增加内容2](,_内容)...
->+[.](+[模板文本],名字)->+[.](+[模板文本],图例)->+[.](+[模板文本],位置)...
->+[.]"内容"(+[模板文本],+[临时文本])...
->+[o]"type_out"(+[python],+格式)->+[.](+[模板文本],+格式)->+[del](,+格式)...
->[]:

->[==]"normal"(,类型)->+[code](+[模板文本],L模板),
->+[code](+[模板文本],L模板2)



## end
#1886, 136:
"""
记住"Python"
str0='1 1 1'
print(str0,str0.replace(' ','_'))

"""

name=name0.replace(' ','_')
ans='/pages/%s.html'%(name)
print(ans)


## end
#1887, 1552:
<!--
+[返回目录]

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="https://stemkoski.github.io/Three.js/js/Three.js"></script>
<script src="../js/OrbitControls.js"></script>
<script type="text/javascript" src="../js/threeWorld.js"></script>


<script>
window.addEventListener("keydown", function (event) {
  if (event.defaultPrevented) {
    return; // Do nothing if the event was already processed
  }
  switch (event.key) {
    case "Left": // IE/Edge specific value
    case "ArrowLeft":
      window.location="..%prev";
      break;
    case "Right": // IE/Edge specific value
    case "ArrowRight":
      window.location="..%next";
      break;
    default:
      return; // Quit when this doesn't handle the key event.
  }

  // Cancel the default action to avoid it being handled twice
  event.preventDefault();
}, true);
</script>



<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="../css/styleSheet.css">
  </head>


<body>
<div class="topnav">
  <a href="..%prev">Prev</a>
  <a href="..%home">Home</a>
  <a href="..%next">Next</a>
</div>


<div class="content">
    <p><mathjax style=\"font-size:1.5em\">
%内容
    </mathjax></p>
</div>

<div class="footer">
  <p>Footer</p>
</div>

</body>
</html>

## end
#1891, 250:
"""
描述结构:...
P代码:...
模板:...

"""
+输出页面(_节点,_章节)->+[del](,+输出页面)...
->的(输出页面,模板)->的(输出页面,P代码)...

->的(_节点,题目)->+的(_章节,+地址)...
->+[python](Python,+地址)->+[code](+[python],P代码)...
->+[.]"name0"(+[python],题目)...

->+[模板文本](模板,_章节)->+[.]"内容"(+[模板文本],_章节)


## end
#1892, 5:
%内容


## end
#1893, 51:
"""
记住"Python"

"""

ans="/res/%s.svg"%(fig_name)


## end
#1894, 26:
<img src="..%目标地址"></img>

## end
#1898, 542:
"""
P代码:...
L模板:...
模板2:...

"""

+SVG结构(_节点,_内容)->+[del](,+SVG结构)...
->的(SVG结构,L模板)->的(SVG结构,模板2)->的(SVG结构,P代码)...

->."输出"(+SVG结构,_输出)->的(_输出,地址)...

->的(_节点,名字)->的(_节点,内容)...
->+的(_节点,+目标地址)...

->+[python](Python,+目标地址)->+[code](+[python],P代码)...
->+[.]"fig_name"(+[python],名字)->+[.]"address"(+[python],地址)...

->+[模板文本](,+[增加内容2])->+[增加内容2](,_内容)...
->+[code](+[模板文本],L模板)...
->+[.](+[模板文本],+目标地址)->+[.](+[模板文本],名字)...

->+[模板文本](模板2,+[临时文本])->+[.](+[模板文本],内容)...
->+[增加内容](地址,+[保存文本])->+[增加内容](+目标地址,+[保存文本])...
    ->+[保存文本](,+[临时文本])

## end
#1899, 104:
"""
记住"Python"

"""

if len(name)>3 and name[0]=='[' and name[-2:]=='].':
    name=name[1:-2]
ans=name


## end
#1900, 24:

$$
%LaTeX
\tag{%名字}
$$

## end
#1901, 25:

$$
%LaTeX
\tag{%名字}
$$


## end
#1902, 172:
"""
记住"Python"
测试:...
print(LaTeX_text0)

"""

list_eqs=LaTeX_text0.split('\\\\')

state=False
for eqn in list_eqs:
    if len(eqn)>110:
        state=True
        break



## end
#1903, 525:
LaTeX_text0="\frac{\sigma_E}{E}\approx \frac{1}{\beta-\theta}*\sqrt{(\frac{L_0+L_1}{L_0*L_2})^{2}*\sigma_s^{2}+(\frac{L_0+L_1+L_2}{L_0*L_2})^{2}*\sigma_f^{2}+(\frac{1}{L_0})^{2}*\sigma_o^{2}}"


LaTeX_text0="\begin{cases}\n\sigma=A_{3}/E^{3}+A_{2}/E^{2}+A_{1}/E+A_{0}\\\\ A_{3}=-4.583\times 10^{3}\ MeV^{3}\ rad\\ A_{2}=34.984\ MeV^{2}\ rad\\ A_{1}=3.421\ MeV\ rad\\\\ A_{0}=4.925\times 10^{-6}\ rad\n\end{cases}\n"

LaTeX_text0=""

print(len(LaTeX_text0)>100,len(LaTeX_text0))
print(LaTeX_text0.split('\n'))
print(list_eqs)

## end
#1906, 626:
"""
记住"Python"
测试:...
保存:...
print(LaTeX_text0)
print(re.sub('\n+$','',LaTeX_text0))
LaTeX_text

txt=r'I_{scatter}=\frac{1}{L_{2}}\ \int_{}^{}{d\theta\ }{S(E_{f}(\theta))\ f(\theta)\ \frac{\partial E_{f}}{\partial \theta}\ exp(-\frac{\alpha^{2}}{\sigma_{s}(E_{f}(\theta))^{2}})}'
print(txt.replace('\ ','\\\\ \n',1))


"""

state=True
ans=1
if len(LaTeX_text0)<150 or 'cases' in LaTeX_text0:
    LaTeX_text=LaTeX_text0
    ans=1
elif len(LaTeX_text0)<200:
    LaTeX_text=LaTeX_text0.replace('\ ','\\\\ \n',1)
    ans=3
else:
    LaTeX_text=LaTeX_text0
    ans=2

LaTeX_text=re.sub('\n+$','',LaTeX_text)
print(LaTeX_text,ans)


## end
#1907, 25:

$$
%LaTeX
\tag{%名字}
$$


## end
#1913, 664:
"""
P代码:...
设置公式:...
L模板:短公式...
L模板2:长公式...
L模板3:多行...

"""

+公式结构(_节点,_内容)->+[del](,+公式结构)...
->的(公式结构,L模板)->的(公式结构,L模板2)->的(公式结构,L模板3)...
->的(公式结构,P代码)->的(公式结构,设置公式)...

->的(_节点,名字)->的(_节点,LaTeX)...

->+[python](Python,+[临时文本]#名字)...
    ->+[code](+[python],设置公式)->+[.]"name"(+[python],名字)...

->+[模板文本](,+[增加内容2])->+[增加内容2](,_内容)...
->+[.]"名字"(+[模板文本],+[临时文本]#名字)...
->+[.]"LaTeX"(+[模板文本],+[临时文本]#t)...

->+[.]"LaTeX_text0"([python],LaTeX)...
->+[o]"LaTeX_text"([python],+[临时文本]#t)...
->+[code]([python],P代码)->[python](Python,+[临时文本]):
    ->[==]"1"(,+[临时文本])->+[code](+[模板文本],L模板),
    ->[==]"2"(,+[临时文本])->+[code](+[模板文本],L模板2),
    ->+[code](+[模板文本],L模板3)



## end
#1914, 169:
"""
print(text_context)

"""

if len(text_context)>4 and text_context[0:4]=='<h3>':
    ans='<h2>%s</h2>\n\n'%(text_context[4:-5])
else:
    ans=text_context+'<br>\n'



## end
#1916, 184:
"""
P代码:...

"""

+文本结构(_节点,_内容)->+[del](,+文本结构)...
->的(文本结构,P代码)...

->+[python](Python,+[增加内容2])->+[code](+[python],P代码)...
->+[.]"text_context"(+[python],_节点)...

->+[增加内容2](,_内容)


## end
#1924, 114:


文本结构:...
公式结构:...
图片结构:...
3D结构:...
SVG结构:...
将条目"3D结构"复制为条目"SVG结构"

表格结构:...
将条目"图片结构"复制为条目"表格结构"

输出页面:...




## end
#1925, 428:
"""


"""

+描述结构(_章节,_文本)->+操作(+描述结构,)...

->[]{
    []=>的(_章节,_节点)->_节点=>[]:
        ->[is](_节点,文本)->文本->+文本结构(_节点,)->+的(+操作,+文本结构),
        ->[is](_节点,公式)->公式->+公式结构(_节点,)->+的(+操作,+公式结构),
        ->的(_节点,3D)->3D->+3D结构(_节点,)->+的(+操作,+3D结构),
        ->的(_节点,SVG)->SVG->+SVG结构(_节点,)->+的(+操作,+SVG结构),
        ->[is](_节点,图片)->图片->+图片结构(_节点,)->+的(+操作,+图片结构),
        ->[is](_节点,表格)->表格->+表格结构(_节点,)->+的(+操作,+表格结构),
        ->[]
}


## end
#1929, 540:
"""
描述结构:...
库:...
L模板:...
+[新建阅读窗口](,描述结构)

"""

+生成章节(_章节,_文本)->+[del](,+生成章节)...
->的(生成章节,描述结构)->的(生成章节,库)...
->的(生成章节,L模板)->的(库,输出页面)...

->+的(_文本,+章节)->+的(+章节,+原型)->+原型(+章节,_章节)...
->+[code]([想],描述结构)->[想](_章节,+章节)...

->操作([想],)...
->+[临时文本]#内容->[]{
    []=>的(操作,_操作)->_操作(_主语,)->_主语(,)...
    =>[说](,_操作)->的(库,_条目)->[eq](_条目,_操作)...
    ->+[做](_主语,+[临时文本]#内容)->+[code](+[做],_条目)->+[.]"输出"(+[做],_文本)
}...

->的(_章节,题目)...
->+[模板文本](L模板,+章节)...
->+[.]"内容"(+[模板文本],+[临时文本]#内容)->+[.](+[模板文本],题目)...

->+[做](_章节,+章节)->+[code](+[做],输出页面)



## end
#1930, 1377:
<!--
+[返回目录]

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


<script>
window.addEventListener("keydown", function (event) {
  if (event.defaultPrevented) {
    return; // Do nothing if the event was already processed
  }
  switch (event.key) {
    case "Left": // IE/Edge specific value
    case "ArrowLeft":
      window.location="..%prev";
      break;
    case "Right": // IE/Edge specific value
    case "ArrowRight":
      window.location="..%next";
      break;
    default:
      return; // Quit when this doesn't handle the key event.
  }

  // Cancel the default action to avoid it being handled twice
  event.preventDefault();
}, true);
</script>



<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="../css/styleSheet.css">
  </head>


<body>
<div class="topnav">
  <a href="..%prev">Prev</a>
  <a href="..%home">Home</a>
  <a href="..%next">Next</a>
</div>


<div class="content">
    <p><mathjax style=\"font-size:1.5em\">
<h1>%题目</h1>
    </mathjax></p>
</div>

<div class="footer">
  <p>Footer</p>
</div>

</body>
</html>




## end
#1932, 217:
"""
L模板:...

"""

+生成标题(一级标题,_文本)->+[del](,+生成标题)...
->的(生成标题,L模板)...

->+的(_文本,+标题)->+的(+标题,+地址)->+地址"/pages/title.html"...
    ->+的(+标题,+原型)->+原型(+标题,一级标题)...

->的(一级标题,题目)...
->+[模板文本](L模板,+标题)->+[.](+[模板文本],题目)



## end
#1933, 8:
%[临时文本]

## end
#1935, 199:
"""
L模板:...

"""

+生成概述(二级标题,_文本)->+[del](,+生成概述)...
->的(生成概述,L模板)...

->+的(_文本,+概述)...

->+[临时文本]->[]{
    []=>的(二级标题,文本)->文本=>+[增加内容2](文本,+[临时文本])
}...

->+[模板文本](L模板,+概述)->+[.](+[模板文本],+[临时文本])



## end
#1936, 259:
"""


"""

+描述结构(_章节,)->+操作(+描述结构,)...

->[]{
    []=>的(_章节,_节点)->_节点=>[]:
        ->[is](_节点,文本)->文本->+文本结构(_节点,)->+的(+操作,+文本结构),
        ->[is](_节点,公式)->公式->+公式结构(_节点,)->+的(+操作,+公式结构),
        ->[is](_节点,图片)->图片->+图片结构(_节点,)->+的(+操作,+图片结构),
        ->[]
}


## end
#1937, 169:
"""
print(text_context)

"""

if len(text_context)>4 and text_context[0:4]=='<h3>':
    ans='\\section{%s}\n\n'%(text_context[4:-5])
else:
    ans=text_context+'\n\n'



## end
#1939, 184:
"""
P代码:...

"""

+文本结构(_节点,_内容)->+[del](,+文本结构)...
->的(文本结构,P代码)...

->+[python](Python,+[增加内容2])->+[code](+[python],P代码)...
->+[.]"text_context"(+[python],_节点)...

->+[增加内容2](,_内容)


## end
#1940, 88:

\begin{widetext}
\begin{equation}
%LaTeX
\label{eq:%名字}
\end{equation}
\end{widetext}


## end
#1941, 671:
"""
记住"Python"
LaTeX_text0="\frac{\sigma_E}{E}\approx \frac{1}{\beta-\theta}*\sqrt{(\frac{L_0+L_1}{L_0*L_2})^{2}*\sigma_s^{2}+(\frac{L_0+L_1+L_2}{L_0*L_2})^{2}*\sigma_f^{2}+(\frac{1}{L_0})^{2}*\sigma_o^{2}}"


LaTeX_text0="\begin{cases}\n\sigma=A_{3}/E^{3}+A_{2}/E^{2}+A_{1}/E+A_{0}\\\\ A_{3}=-4.583\times 10^{3}\ MeV^{3}\ rad\\ A_{2}=34.984\ MeV^{2}\ rad\\ A_{1}=3.421\ MeV\ rad\\\\ A_{0}=4.925\times 10^{-6}\ rad\n\end{cases}\n"

LaTeX_text0=""

print(len(LaTeX_text0)>100,len(LaTeX_text0))
print(LaTeX_text0.split('\n'))
print(list_eqs)

"""

list_eqs=LaTeX_text0.split('\\\\')

state=False
for eqn in list_eqs:
    if len(eqn)>110:
        state=True
        break



## end
#1942, 56:

\begin{equation}
%LaTeX
\label{eq:%名字}
\end{equation}


## end
#1946, 373:
"""
P代码:...
L模板:...
L模板2:...

"""

+公式结构(_节点,_内容)->+[del](,+公式结构)...
->的(公式结构,L模板)->的(公式结构,L模板2)...
->的(公式结构,P代码)...

->的(_节点,名字)->的(_节点,LaTeX)...
->+[模板文本](,+[增加内容2])->+[增加内容2](,_内容)...
->+[.](+[模板文本],名字)->+[.](+[模板文本],LaTeX)...

->[]{+[.]"LaTeX_text0"([python],LaTeX)->+[code]([python],P代码)->[python](Python,)}:
    ->+[code](+[模板文本],L模板2),
    ->>+[code](+[模板文本],L模板)



## end
#1947, 107:

\begin{figure}[b]
\includegraphics[width=0.45\textwidth]{%名字}
\caption{\label{fig:%名字}%图例}
\end{figure}



## end
#1948, 89:
"""
记住"Python"

"""

fig_type=source_dir.split('.')[-1]
ans='\\'+fig_name+'.'+fig_type



## end
#1951, 347:
"""
P代码:...
L模板:...

"""

+图片结构(_节点,_内容)->+[del](,+图片结构)...
->的(图片结构,L模板)->的(图片结构,P代码)...

->的(_节点,名字)->的(_节点,图例)->的(_节点,源地址)...
->的(_节点,目标地址)...
->+[python](Python,目标地址)->+[code](+[python],P代码)...
->+[.]"source_dir"(+[python],源地址)->+[.]"fig_name"(+[python],名字)...

->+[模板文本](L模板,+[增加内容2])->+[增加内容2](,_内容)...
->+[.](+[模板文本],名字)->+[.](+[模板文本],图例)


## end
#1955, 33:


文本结构:...
公式结构:...
图片结构:...





## end
#1956, 16:

\appendix
%内容


## end
#1960, 438:
"""
描述结构:...
库:...
L模板:...
+[新建阅读窗口](,描述结构)

"""

+生成附录(_章节,_文本)->+[del](,+生成附录)...
->的(生成附录,描述结构)->的(生成附录,库)...
->的(生成附录,L模板)...

->+的(_文本,+章节)...
->+[code]([想],描述结构)->[想](_章节,)...

->操作([想],)...
->+[临时文本]#内容->[]{
    []=>的(操作,_操作)->_操作(_主语,)->_主语(,)...
    =>[说](,_操作)->的(库,_条目)->[eq](_条目,_操作)...
    ->+[做](_主语,+[临时文本]#内容)->+[code](+[做],_条目)
}...

->的(_章节,题目)...
->+[模板文本](L模板,+章节)...
->+[.]"内容"(+[模板文本],+[临时文本]#内容)->+[.](+[模板文本],题目)


## end
#1961, 46:

\author{%名 %姓}
\email{%邮箱}
\affiliation{%单位}

## end
#1963, 230:
"""
L模板:...

"""
+通讯作者(_A,_输出)->+[del](,+通讯作者)...
->的(通讯作者,L模板)...

->的(_A,名)->的(_A,姓)->的(_A,单位)->的(_A,邮箱)...

->+[模板文本](L模板,+[增加内容2])->+[增加内容2](,_输出)...
->+[.](+[模板文本],名)->+[.](+[模板文本],姓)...
->+[.](+[模板文本],单位)->+[.](+[模板文本],邮箱)


## end
#1964, 34:

\author{%名 %姓}
\affiliation{%单位}

## end
#1966, 212:
"""
L模板:...

"""
+普通作者(_A,_输出)->+[del](,+普通作者)...
->的(普通作者,L模板)...

->的(_A,名)->的(_A,姓)->的(_A,单位)->的(_A,邮箱)...

->+[模板文本](L模板,+[增加内容2])->+[增加内容2](,_输出)...
->+[.](+[模板文本],名)->+[.](+[模板文本],姓)...
->+[.](+[模板文本],单位)


## end
#1969, 40:


通讯作者:...
普通作者:...
将'普通作者'的"通讯"替换为"普通"

## end
#1970, 70:
"""
记住"Python"

"""

state=True
list_au=text_au.split(', ')
list_i=0


## end
#1971, 134:
"""


"""

name=list_au[list_i]
list_i+=1
if name[-1]=='*':
    name=name[0:-1]
    type_name='通讯'
else:
    type_name="普通"
ans=name


## end
#1974, 347:
"""
P代码:...
P代码2:...

"""

+描述结构(_作者,)->+操作(+描述结构,)...
->的(描述结构,P代码)->的(描述结构,P代码2)...

->+[.]"text_au"([python],_作者)...
->+[code]([python],P代码)->[python](Python,)...
->+[code]([python]#2,P代码2)...

->+不终止=>[python]"state=(list_i<len(list_au))"(Python,+不终止)...
=>+的(+操作,+作者)->+作者(+类型,)...
->+[o]"type_name"([python]#2,+类型)->[python]#2(Python,+作者)



## end
#1977, 428:
"""
描述结构:...
库:...

"""

+生成作者(_作者,_文本)->+[del](,+生成作者)...
->的(生成作者,描述结构)->的(生成作者,库)...
->的(库,通讯作者)->的(库,普通作者)...

->+的(_文本,+作者)...
->+[code]([想],描述结构)->[想](_作者,)...

->操作([想],)...
->+[临时文本]#内容->[]{
    []=>的(操作,作者)->作者(类型,)->类型(,)...
    =>+[获取作者信息](,+作者A)->[m_text](作者,+[获取作者信息])...
    ->+[做](+作者A,+作者)...
    ->+[删除结构](,+作者A)->+[del](,+作者A)->[]:
        ->[==]"通讯"(,类型)->+[code](+[做],通讯作者),
        ->+[code](+[做],普通作者)
}



## end
#1983, 89:


生成标题:...
生成作者:...
生成概述:...
生成章节:...
生成附录:...
将条目"生成章节"复制为条目"生成附录"
将'生成作者'的"章节"替换为"作者"


## end
#1986, 309:
"""
描述结构:...
库:...
+[新建阅读窗口](,库)

"""
+章节内容(_章节结构,_文本)->+[del](,+章节内容)...
->的(章节内容,描述结构)->的(章节内容,库)...

->+[code]([想],描述结构)->[想](_章节结构,_文本)...
->操作([想],)...
->[]{
    []=>的(操作,_操作)->_操作(_主语,_宾语)->_主语->_宾语(,)...
    =>[说](,_操作)...
        ->的(库,_条目)->_条目->[eq](_条目,_操作)->+[做](_主语,_宾语)->+[code](+[做],_条目)
}





## end
#1987, 545:
"""
P代码:...
L模板:...

"""

+整理内容(_媒介,_内容)->+[del](,+整理内容)...
->的(整理内容,L模板)->的(整理内容,P代码)...

->+[临时文本]#章节->[]{
    []=>的(_内容,章节)->章节=>+[增加内容](章节,+[临时文本]#章节)
}...
->+[python](Python,+[临时文本]#章节)->+[code](+[python],P代码)...
->+[s]"file_text"(+[python],+[临时文本]#章节)...

->+[模板文本](L模板,_内容)...
->+[.]"章节"(+[模板文本],+[临时文本]#章节)...
->[]{
    []:->的(_内容,标题)->标题->+[.](+[模板文本],标题),->[]
}...
->[]{
    []:->的(_内容,作者)->作者->+[.](+[模板文本],作者),->[]
}...
->[]{
    []:->的(_内容,概述)->概述->+[.](+[模板文本],概述),->[]
}...
->[]{
    []:->的(_内容,引用)->引用->+[.](+[模板文本],引用),->[]
}



## end
#1988, 23:

%标题
%作者

%概述


%章节




## end
#1989, 82:
"""
print("112%13%1".replace('%','\\%'))

"""

ans=file_text.replace('%','\\%')



## end
#1993, 292:
"""
P代码:...
L模板:...

保存:...

"""

+整理内容(_媒介,_内容)->+[del](,+整理内容)...
->的(整理内容,L模板)->的(整理内容,P代码)...

->+[临时文本]->的(_内容,地址#0)->[]{
    []=>的(_内容,_章节)->的(_章节,地址)=>+[增加内容2](地址#0,地址)...
        ->+[保存文本](,_章节)...
        ->+[标题](_章节,)->+[增加内容]"%s:...
"(+[标题],+[临时文本])
}...

->+[修改内容](+[临时文本],_内容)



## end
#1994, 61:
"""
记住"Python"

"""

ans=paper_link.split('#')[0]
state=True

## end
#1996, 203:
"""
P代码:...

"""

+描述结构(_文章,)->+操作(+描述结构,)...
->的(描述结构,P代码)...

=>的(_文章,_节点)->引用(_节点,)...
=>+的(+操作,+文章)->+文章(_节点,)...
->+[.]"paper_link"([python],_节点)->+[code]([python],P代码)...
->[python](Python,+文章)




## end
#1997, 217:

@ARTICLE{%引用名, 
   author        = "%作者", 
   title         = "%标题", 
   journal = {ArXiv e-prints},
   archivePrefix = "arXiv",
   eprint        = {%eprint},
   primaryClass  = "%类别",
   year          = "%日期",
}




## end
#1998, 169:

@ARTICLE{%引用名,
   author       = "%作者",
   title        = "%标题",
   journal      = "%期刊",
   volume       = "%编号", 
   pages        = "%页数",
   year         = "%年份",
}

## end
#1999, 213:

@PROCEEDINGS{%引用名,
   title = "%标题",
   number = "%编号",
   editor = "", 

   series = "All ACM Conferences",
   month = "",
   year = "%年份",
   address = "%城市地址",
   organization = "%组织",
   publisher = "%会议",
}

## end
#2003, 25:


文章:...
会议:...
预印本:...


## end
#2004, 296:
"""
记住"Python"

print(text_aus)
print(list_aus)

"""

# print(text_aus)
# print(text_aus.split(', '))
# print(' and '.join(text_aus.split(', ')))

list_aus0=text_aus.split(', ')
if len(list_aus0)>3:
    list_aus=list_aus0[0:3]+['others']
else:
    list_aus=list_aus0
ans=' and '.join(list_aus)



## end
#2007, 568:
"""
P代码:...
模板库:...

"""

+设置引用(文章A,引用)->+[del](,+设置引用)...
->的(设置引用,模板库)->的(设置引用,P代码)...

->的(文章A,类型)->的(文章A,作者)...
->+[python](Python,作者)->+[code](+[python],P代码)...
->+[s]"text_aus"(+[python],作者)...

->+[模板文本](,+[增加内容2])->+[增加内容2](,引用)...
->[]{
    []:->[==]"ARTICLE"(,类型)->的(模板库,文章#0)->+[code](+[模板文本],文章#0),
    ->[==]"PROCEEDINGS"(,类型)->的(模板库,会议#0)->+[code](+[模板文本],会议#0),
    ->[==]"ArXiv"(,类型)->的(模板库,预印本#0)->+[code](+[模板文本],预印本#0),
    ->的(模板库,文章#1)->+[code](+[模板文本],文章#1)
}...

->+[.]"引用名"(+[模板文本],文章A)...
->[]{
    []=>的(文章A,_性质)->_性质=>+[.](+[模板文本],_性质)
}




## end
#2010, 426:
"""
描述结构:...
设置引用:...
+[新建阅读窗口](,描述结构)

"""

+引用文章(_文章,_文本)->+[del](,+引用文章)...
->的(引用文章,描述结构)->的(引用文章,设置引用)...

->+的(_文本,+引用)...
->+[code]([想],描述结构)->[想](_文章,)...

->操作([想],)...
->+[临时文本]#内容->[]{
    []=>的(操作,文章)->文章(_节点,)->_节点(,)...
    =>+[获取论文信息](+[临时文本],+文章A)->[m_text](文章,+[临时文本])...
        ->[标题](_节点,)->[m_text]([标题],+文章A)...
        ->+[做](+文章A,+引用)->+[code](+[做],设置引用)...
        ->+[删除结构](,+文章A)->+[del](,+文章A)
}



## end
#2011, 45:
"""


"""


ans="%s\\text.tex"%(folder_dir)


## end
#2012, 204:
"""
import shutil
shutil.copy(src_dir,"%s\\fig.png"%(folder_dir))

"""

import shutil
# print(src_dir,tar_dir)
# ans="%s\%s.tex"%(folder_dir,file_name)
shutil.copy(src_dir,"%s\\%s"%(folder_dir,tar_dir))


## end
#2014, 144:
"""
import shutil
shutil.copy(src_dir,"%s\\fig.png"%(folder_dir))
保存:...

"""

import os
os.system("cp %s %s/%s"%(src_dir,folder_dir,tar_dir))


## end
#2017, 699:
"""
P代码:...
P代码2:...
+[新建阅读窗口](,P代码)

->的(_凭依,召唤规则)->+[删除结构](,召唤规则)->+[del](,召唤规则)...
->的(_凭依,降临规则)->+[删除结构](,降临规则)->+[del](,降临规则)...

"""

+整理图片(_媒介,_凭依)->+[del](,+整理图片)...
->的(整理图片,P代码)->的(整理图片,P代码2)...

->的#0(_凭依,地址)->+[标题](_凭依,)...
->+[python](Python,+[临时文本])->+[code](+[python],P代码)...
->+[.]"file_name"(+[python],+[标题])->+[.]"folder_dir"(+[python],地址)...
->+[保存文本](+[临时文本],_凭依)...

->[]{
    []=>的(_媒介,二级标题)->二级标题->的(二级标题,图片)...
    ->的(图片,源地址)->的(图片,目标地址)...
        =>+[python](Python,)->+[code](+[python],P代码2)...
        ->+[.]"src_dir"(+[python],源地址)->+[.]"tar_dir"(+[python],目标地址)...
        ->+[.]"folder_dir"(+[python],地址)
}...

->+[del](,的#0)...
->+[删除结构](,_凭依)...
->+[有](_凭依,地址)





## end
#2024, 109:
+[粘贴](,降临规则)

引用文章:...
章节内容:...

整体架构:...

整理引用:...
整理内容:...
整理图片:...
+[新建阅读窗口](,章节内容)
将'引用文章'的"作者"替换为"文章"



## end
#2027, 24:


召唤规则:...
降临规则:...





## end
#2030, 331:
<!--
+[H函数](,文本内容)
-->

<h1>CM and BNL simulations</h1>

<h2>CM simulations</h2>
%fig.2_*
%fig.1_*

<h2>BNL simulations</h2>
$$
n_e=1 \times 10^{17}\ cm^{-3},\ a_0=2.
$$
%fig.3_*



<!--
fig.1_(图片)::文档/S应用/周报告/20230609/fig1_.png
fig.2_(图片)::文档/S应用/周报告/20230609/fig2_.png
fig.3_(图片)::文档/S应用/周报告/20230609/fig3_.png

+[H函数](,文本内容)
-->
## end
#2032, 238:
# CM and BNL simulations
## CM simulations
<img src="../res/fig.2_.png" width="95%"/>
<img src="../res/fig.1_.png" width="95%"/>

## BNL simulations
$$
n_e=1 \times 10^{17}\ cm^{-3},\ a_0=2.
$$
<img src="../res/fig.3_.png" width="95%"/>


## end
#2034, 29:
文档/S应用/周报告/20230609/fig1_.png
## end
#2037, 29:
文档/S应用/周报告/20230609/fig2_.png
## end
#2040, 29:
文档/S应用/周报告/20230609/fig3_.png
## end
#2043, 154:

<h1>CM and BNL simulations</h1>
<h2>CM simulations</h2>
%fig.2_*
%fig.1_*
<h2>BNL simulations</h2>
$$
n_e=1 \times 10^{17}\ cm^{-3},\ a_0=2.
$$
%fig.3_*

## end
#2044, 22:
CM and BNL simulations
## end
#2046, 32:
CM simulations
%fig.2_*
%fig.1_*
## end
#2048, 70:
BNL simulations
$$
n_e=1 \times 10^{17}\ cm^{-3},\ a_0=2.
$$
%fig.3_*

## end
#2050, 15:
BNL simulations
## end
#2054, 2:
$$
## end
#2058, 38:
n_e=1 \times 10^{17}\ cm^{-3},\ a_0=2.
## end
#2062, 2:
$$
## end
#2066, 8:
%fig.3_*
## end
#2068, 15:
/res/fig.3_.png
## end
#2070, 29:
文档/S应用/周报告/20230609/fig3_.png
## end
#2072, 1:
b
## end
#2074, 4:
wide
## end
#2078, 6:
fig.3_
## end
#2080, 14:
CM simulations
## end
#2084, 8:
%fig.2_*
## end
#2088, 8:
%fig.1_*
## end
#2090, 15:
/res/fig.1_.png
## end
#2092, 29:
文档/S应用/周报告/20230609/fig1_.png
## end
#2094, 1:
b
## end
#2096, 4:
wide
## end
#2100, 6:
fig.1_
## end
#2102, 15:
/res/fig.2_.png
## end
#2104, 29:
文档/S应用/周报告/20230609/fig2_.png
## end
#2106, 1:
b
## end
#2108, 4:
wide
## end
#2112, 6:
fig.2_
## end
#2114, 22:
CM and BNL simulations
## end
#2118, 467:
"""
Nini, 打开人体模型(文件)
Nini, 打开CBS(文件)
    ->+整体架构(_媒介,_凭依)->+的(操作,+整体架构)...

"""

+召唤规则(_媒介,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_凭依)...

->[==]"结构文本转md"(,召唤星辰)...
    ->+整理图片(_媒介,_凭依)->+的(操作,+整理图片)...
    ->+整理内容(_媒介,_凭依)->+的(操作,+整理内容)...
    ->+整理引用(_媒介,_凭依)->+的(操作,+整理引用)...


->[]{
    []=>的(_媒介,_章节)->_章节=>+章节内容(_章节,_凭依)->+的(操作,+章节内容)
}...
->[]{
    []:->.(_媒介,_原始结构)->_原始结构(,)...
        ->+引用文章(_原始结构,_凭依)->+的(操作,+引用文章),
    ->[]
}...
->+整理地址(_媒介,_凭依)->+的(操作,+整理地址)



## end
#2120, 25238:
文本转换_md#0"

召唤规则:...
降临规则:...




"(,)
的#1""(文本转换_md#0,降临规则#2)
降临规则#2"+[粘贴](,降临规则)

整理地址:...
引用文章:...
章节内容:...

整理引用:...
整理内容:...
整理图片:...
+[新建阅读窗口](,章节内容)
将'引用文章'的\"作者\"替换为\"文章\"


"(,)
的#3""(降临规则#2,整理图片#4)
整理图片#4"\"\"\"
P代码:...
P代码2:...
+[新建阅读窗口](,P代码)

保存:...

\"\"\"

+整理图片(_媒介,_凭依)->+[del](,+整理图片)...
->的(整理图片,P代码)->的(整理图片,P代码2)...

->的#0(_凭依,地址)->+[标题](_凭依,)...
->+[python](Python,+[临时文本])->+[code](+[python],P代码)...
->+[.]\"file_name\"(+[python],+[标题])->+[.]\"folder_dir\"(+[python],地址)...

->[]{
    []=>的(_媒介,二级标题)->二级标题->的(二级标题,图片)...
    ->的(图片,源地址)->的(图片,目标地址)...
        =>+[python](Python,)->+[code](+[python],P代码2)...
        ->+[.]\"src_dir\"(+[python],源地址)->+[.]\"tar_dir\"(+[python],目标地址)...
        ->+[.]\"folder_dir\"(+[python],地址)
}...

->+[del](,的#0)...
->+[删除结构](,_凭依)...
->+[有](_凭依,地址)




"(,)
的#5""(整理图片#4,P代码2#6)
P代码2#6"\"\"\"
import shutil
shutil.copy(src_dir,\"%s\\fig.png\"%(folder_dir))
保存:...

\"\"\"

import os
os.system(\"cp %s %s/%s\"%(src_dir,folder_dir,tar_dir))

"(,)
的#7""(P代码2#6,保存#8)
保存#8"\"\"\"
import shutil
shutil.copy(src_dir,\"%s\\fig.png\"%(folder_dir))

\"\"\"

import shutil
# print(src_dir,tar_dir)
# ans=\"%s\%s.tex\"%(folder_dir,file_name)
shutil.copy(src_dir,\"%s\\%s\"%(folder_dir,tar_dir))

"(,)
的#9""(整理图片#4,P代码#10)
P代码#10"\"\"\"
记住\"Python\"
print(folder_dir.split('/')[0:-1])

\"\"\"

import os
cmd_folder=\"mkdir %s/res\"%(folder_dir)
os.system(cmd_folder)


"(,)
的#11""(整理图片#4,保存#12)
保存#12"\"\"\"
P代码:...
P代码2:...
+[新建阅读窗口](,P代码)

\"\"\"

+整理图片(_媒介,_凭依)->+[del](,+整理图片)...
->的(整理图片,P代码)->的(整理图片,P代码2)...

->的#0(_凭依,地址)->+[标题](_凭依,)...
->+[python](Python,+[临时文本])->+[code](+[python],P代码)...
->+[.]\"file_name\"(+[python],+[标题])->+[.]\"folder_dir\"(+[python],地址)...
->+[保存文本](+[临时文本],_凭依)...

->[]{
    []=>的(_媒介,二级标题)->二级标题->的(二级标题,图片)...
    ->的(图片,源地址)->的(图片,目标地址)...
        =>+[python](Python,)->+[code](+[python],P代码2)...
        ->+[.]\"src_dir\"(+[python],源地址)->+[.]\"tar_dir\"(+[python],目标地址)...
        ->+[.]\"folder_dir\"(+[python],地址)
}...

->+[del](,的#0)...
->+[删除结构](,_凭依)...
->+[有](_凭依,地址)




"(,)
的#13""(降临规则#2,引用文章#14)
引用文章#14"\"\"\"
描述结构:...
设置引用:...
+[新建阅读窗口](,描述结构)

\"\"\"

+引用文章(_文章,_文本)->+[del](,+引用文章)...
->的(引用文章,描述结构)->的(引用文章,设置引用)...

->+的(_文本,+引用)...
->+[code]([想],描述结构)->[想](_文章,)...

->操作([想],)...
->+[临时文本]#内容->[]{
    []=>的(操作,文章)->文章(_节点,)->_节点(,)...
    =>+[获取论文信息](+[临时文本],+文章A)->[m_text](文章,+[临时文本])...
        ->[标题](_节点,)->[m_text]([标题],+文章A)...
        ->+[做](+文章A,+引用)->+[code](+[做],设置引用)...
        ->+[删除结构](,+文章A)->+[del](,+文章A)
}


"(,)
的#15""(引用文章#14,设置引用#16)
设置引用#16"\"\"\"
P代码:...
模板库:...

\"\"\"

+设置引用(文章A,引用)->+[del](,+设置引用)...
->的(设置引用,模板库)->的(设置引用,P代码)...

->的(文章A,类型)->的(文章A,作者)...
->+[python](Python,作者)->+[code](+[python],P代码)...
->+[s]\"text_aus\"(+[python],作者)...

->+[模板文本](,+[增加内容2])->+[增加内容2](,引用)...
->[]{
    []:->[==]\"ARTICLE\"(,类型)->的(模板库,文章#0)->+[code](+[模板文本],文章#0),
    ->[==]\"PROCEEDINGS\"(,类型)->的(模板库,会议#0)->+[code](+[模板文本],会议#0),
    ->[==]\"ArXiv\"(,类型)->的(模板库,预印本#0)->+[code](+[模板文本],预印本#0),
    ->的(模板库,文章#1)->+[code](+[模板文本],文章#1)
}...

->+[.]\"引用名\"(+[模板文本],文章A)...
->[]{
    []=>的(文章A,_性质)->_性质=>+[.](+[模板文本],_性质)
}



"(,)
的#17""(设置引用#16,P代码#18)
P代码#18"\"\"\"
记住\"Python\"

print(text_aus)
print(list_aus)

\"\"\"

# print(text_aus)
# print(text_aus.split(', '))
# print(' and '.join(text_aus.split(', ')))

list_aus0=text_aus.split(', ')
if len(list_aus0)>3:
    list_aus=list_aus0[0:3]+['others']
else:
    list_aus=list_aus0
ans=' and '.join(list_aus)


"(,)
的#19""(设置引用#16,模板库#20)
模板库#20"

文章:...
会议:...
预印本:...

"(,)
的#21""(模板库#20,会议#22)
会议#22"
@PROCEEDINGS{%引用名,
   title = \"%标题\",
   number = \"%编号\",
   editor = \"\", 

   series = \"All ACM Conferences\",
   month = \"\",
   year = \"%年份\",
   address = \"%城市地址\",
   organization = \"%组织\",
   publisher = \"%会议\",
}
"(,)
的#23""(模板库#20,文章#24)
文章#24"
@ARTICLE{%引用名,
   author       = \"%作者\",
   title        = \"%标题\",
   journal      = \"%期刊\",
   volume       = \"%编号\", 
   pages        = \"%页数\",
   year         = \"%年份\",
}
"(,)
的#25""(模板库#20,预印本#26)
预印本#26"
@ARTICLE{%引用名, 
   author        = \"%作者\", 
   title         = \"%标题\", 
   journal = {ArXiv e-prints},
   archivePrefix = \"arXiv\",
   eprint        = {%eprint},
   primaryClass  = \"%类别\",
   year          = \"%日期\",
}



"(,)
的#27""(引用文章#14,描述结构#28)
描述结构#28"\"\"\"
P代码:...

\"\"\"

+描述结构(_文章,)->+操作(+描述结构,)...
->的(描述结构,P代码)...

=>的(_文章,_节点)->引用(_节点,)...
=>+的(+操作,+文章)->+文章(_节点,)...
->+[.]\"paper_link\"([python],_节点)->+[code]([python],P代码)...
->[python](Python,+文章)



"(,)
的#29""(描述结构#28,P代码#30)
P代码#30"\"\"\"
记住\"Python\"

\"\"\"

ans=paper_link.split('#')[0]
state=True
"(,)
的#31""(降临规则#2,整理内容#32)
整理内容#32"\"\"\"


\"\"\"

+整理内容(_媒介,_内容)->+[del](,+整理内容)...

->+[临时文本]->的(_内容,地址#0)->的(_内容,文件名)->[]{
    []=>的(_内容,_章节)->的(_章节,地址)=>+[增加内容2](地址#0,地址)...
        ->+[增加内容](_章节,+[临时文本])
}...

->+[修改内容](+[临时文本],_内容)...
->+[模板文本]\"%地址/%文件名\"(,+[临时文本]#地址)...
    ->+[.](+[模板文本],地址#0)->+[.](+[模板文本],文件名)...
->+[保存文本](+[临时文本]#地址,_内容)


"(,)
的#33""(整理内容#32,P代码#34)
P代码#34"\"\"\"
print(\"112%13%1\".replace('%','\\%'))

\"\"\"

ans=file_text.replace('%','\\%')


"(,)
的#35""(整理内容#32,L模板#36)
L模板#36"
%标题
%作者

%概述


%章节



"(,)
的#37""(整理内容#32,保存#38)
保存#38"\"\"\"
P代码:...
L模板:...

\"\"\"

+整理内容(_媒介,_内容)->+[del](,+整理内容)...
->的(整理内容,L模板)->的(整理内容,P代码)...

->+[临时文本]#章节->[]{
    []=>的(_内容,章节)->章节=>+[增加内容](章节,+[临时文本]#章节)
}...
->+[python](Python,+[临时文本]#章节)->+[code](+[python],P代码)...
->+[s]\"file_text\"(+[python],+[临时文本]#章节)...

->+[模板文本](L模板,_内容)...
->+[.]\"章节\"(+[模板文本],+[临时文本]#章节)...
->[]{
    []:->的(_内容,标题)->标题->+[.](+[模板文本],标题),->[]
}...
->[]{
    []:->的(_内容,作者)->作者->+[.](+[模板文本],作者),->[]
}...
->[]{
    []:->的(_内容,概述)->概述->+[.](+[模板文本],概述),->[]
}...
->[]{
    []:->的(_内容,引用)->引用->+[.](+[模板文本],引用),->[]
}


"(,)
的#39""(降临规则#2,章节内容#40)
章节内容#40"\"\"\"
描述结构:...
库:...
+[新建阅读窗口](,库)

\"\"\"
+章节内容(_章节结构,_文本)->+[del](,+章节内容)...
->的(章节内容,描述结构)->的(章节内容,库)...

->+[code]([想],描述结构)->[想](_章节结构,_文本)...
->操作([想],)...
->[]{
    []=>的(操作,_操作)->_操作(_主语,_宾语)->_主语->_宾语(,)...
    =>[说](,_操作)...
        ->的(库,_条目)->_条目->[eq](_条目,_操作)->+[做](_主语,_宾语)->+[code](+[做],_条目)
}




"(,)
的#41""(章节内容#40,库#42)
库#42"

生成标题:...
生成作者:...
生成概述:...
生成章节:...
生成附录:...
将条目\"生成章节\"复制为条目\"生成附录\"
将'生成作者'的\"章节\"替换为\"作者\"

"(,)
的#43""(库#42,生成作者#44)
生成作者#44"\"\"\"
描述结构:...
库:...

\"\"\"

+生成作者(_作者,_文本)->+[del](,+生成作者)...
->的(生成作者,描述结构)->的(生成作者,库)...
->的(库,通讯作者)->的(库,普通作者)...

->+的(_文本,+作者)...
->+[code]([想],描述结构)->[想](_作者,)...

->操作([想],)...
->+[临时文本]#内容->[]{
    []=>的(操作,作者)->作者(类型,)->类型(,)...
    =>+[获取作者信息](,+作者A)->[m_text](作者,+[获取作者信息])...
    ->+[做](+作者A,+作者)...
    ->+[删除结构](,+作者A)->+[del](,+作者A)->[]:
        ->[==]\"通讯\"(,类型)->+[code](+[做],通讯作者),
        ->+[code](+[做],普通作者)
}


"(,)
的#45""(生成作者#44,描述结构#46)
描述结构#46"\"\"\"
P代码:...
P代码2:...

\"\"\"

+描述结构(_作者,)->+操作(+描述结构,)...
->的(描述结构,P代码)->的(描述结构,P代码2)...

->+[.]\"text_au\"([python],_作者)...
->+[code]([python],P代码)->[python](Python,)...
->+[code]([python]#2,P代码2)...

->+不终止=>[python]\"state=(list_i<len(list_au))\"(Python,+不终止)...
=>+的(+操作,+作者)->+作者(+类型,)...
->+[o]\"type_name\"([python]#2,+类型)->[python]#2(Python,+作者)


"(,)
的#47""(描述结构#46,P代码2#48)
P代码2#48"\"\"\"


\"\"\"

name=list_au[list_i]
list_i+=1
if name[-1]=='*':
    name=name[0:-1]
    type_name='通讯'
else:
    type_name=\"普通\"
ans=name

"(,)
的#49""(描述结构#46,P代码#50)
P代码#50"\"\"\"
记住\"Python\"

\"\"\"

state=True
list_au=text_au.split(', ')
list_i=0

"(,)
的#51""(生成作者#44,库#52)
库#52"

通讯作者:...
普通作者:...
将'普通作者'的\"通讯\"替换为\"普通\"
"(,)
的#53""(库#52,普通作者#54)
普通作者#54"\"\"\"
L模板:...

\"\"\"
+普通作者(_A,_输出)->+[del](,+普通作者)...
->的(普通作者,L模板)...

->的(_A,名)->的(_A,姓)->的(_A,单位)->的(_A,邮箱)...

->+[模板文本](L模板,+[增加内容2])->+[增加内容2](,_输出)...
->+[.](+[模板文本],名)->+[.](+[模板文本],姓)...
->+[.](+[模板文本],单位)

"(,)
的#55""(普通作者#54,L模板#56)
L模板#56"
\author{%名 %姓}
\affiliation{%单位}
"(,)
的#57""(库#52,通讯作者#58)
通讯作者#58"\"\"\"
L模板:...

\"\"\"
+通讯作者(_A,_输出)->+[del](,+通讯作者)...
->的(通讯作者,L模板)...

->的(_A,名)->的(_A,姓)->的(_A,单位)->的(_A,邮箱)...

->+[模板文本](L模板,+[增加内容2])->+[增加内容2](,_输出)...
->+[.](+[模板文本],名)->+[.](+[模板文本],姓)...
->+[.](+[模板文本],单位)->+[.](+[模板文本],邮箱)

"(,)
的#59""(通讯作者#58,L模板#60)
L模板#60"
\author{%名 %姓}
\email{%邮箱}
\affiliation{%单位}
"(,)
的#61""(库#42,生成附录#62)
生成附录#62"\"\"\"
描述结构:...
库:...
L模板:...
+[新建阅读窗口](,描述结构)

\"\"\"

+生成附录(_章节,_文本)->+[del](,+生成附录)...
->的(生成附录,描述结构)->的(生成附录,库)...
->的(生成附录,L模板)...

->+的(_文本,+章节)...
->+[code]([想],描述结构)->[想](_章节,)...

->操作([想],)...
->+[临时文本]#内容->[]{
    []=>的(操作,_操作)->_操作(_主语,)->_主语(,)...
    =>[说](,_操作)->的(库,_条目)->[eq](_条目,_操作)...
    ->+[做](_主语,+[临时文本]#内容)->+[code](+[做],_条目)
}...

->的(_章节,题目)...
->+[模板文本](L模板,+章节)...
->+[.]\"内容\"(+[模板文本],+[临时文本]#内容)->+[.](+[模板文本],题目)

"(,)
的#63""(生成附录#62,L模板#64)
L模板#64"
\appendix
%内容

"(,)
的#65""(生成附录#62,库#66)
库#66"

文本结构:...
公式结构:...
图片结构:...




"(,)
的#67""(库#66,图片结构#68)
图片结构#68"\"\"\"
P代码:...
L模板:...

\"\"\"

+图片结构(_节点,_内容)->+[del](,+图片结构)...
->的(图片结构,L模板)->的(图片结构,P代码)...

->的(_节点,名字)->的(_节点,图例)->的(_节点,源地址)...
->的(_节点,目标地址)...
->+[python](Python,目标地址)->+[code](+[python],P代码)...
->+[.]\"source_dir\"(+[python],源地址)->+[.]\"fig_name\"(+[python],名字)...

->+[模板文本](L模板,+[增加内容2])->+[增加内容2](,_内容)...
->+[.](+[模板文本],名字)->+[.](+[模板文本],图例)

"(,)
的#69""(图片结构#68,P代码#70)
P代码#70"\"\"\"
记住\"Python\"

\"\"\"

fig_type=source_dir.split('.')[-1]
ans='\\'+fig_name+'.'+fig_type


"(,)
的#71""(图片结构#68,L模板#72)
L模板#72"
\begin{figure}[b]
\includegraphics[width=0.45\textwidth]{%名字}
\caption{\label{fig:%名字}%图例}
\end{figure}


"(,)
的#73""(库#66,公式结构#74)
公式结构#74"\"\"\"
P代码:...
L模板:...
L模板2:...

\"\"\"

+公式结构(_节点,_内容)->+[del](,+公式结构)...
->的(公式结构,L模板)->的(公式结构,L模板2)...
->的(公式结构,P代码)...

->的(_节点,名字)->的(_节点,LaTeX)...
->+[模板文本](,+[增加内容2])->+[增加内容2](,_内容)...
->+[.](+[模板文本],名字)->+[.](+[模板文本],LaTeX)...

->[]{+[.]\"LaTeX_text0\"([python],LaTeX)->+[code]([python],P代码)->[python](Python,)}:
    ->+[code](+[模板文本],L模板2),
    ->>+[code](+[模板文本],L模板)


"(,)
的#75""(公式结构#74,L模板#76)
L模板#76"
\begin{equation}
%LaTeX
\label{eq:%名字}
\end{equation}

"(,)
的#77""(公式结构#74,P代码#78)
P代码#78"\"\"\"
记住\"Python\"
LaTeX_text0=\"\frac{\sigma_E}{E}\approx \frac{1}{\beta-\theta}*\sqrt{(\frac{L_0+L_1}{L_0*L_2})^{2}*\sigma_s^{2}+(\frac{L_0+L_1+L_2}{L_0*L_2})^{2}*\sigma_f^{2}+(\frac{1}{L_0})^{2}*\sigma_o^{2}}\"


LaTeX_text0=\"\begin{cases}\n\sigma=A_{3}/E^{3}+A_{2}/E^{2}+A_{1}/E+A_{0}\\\\ A_{3}=-4.583\times 10^{3}\ MeV^{3}\ rad\\ A_{2}=34.984\ MeV^{2}\ rad\\ A_{1}=3.421\ MeV\ rad\\\\ A_{0}=4.925\times 10^{-6}\ rad\n\end{cases}\n\"

LaTeX_text0=\"\"

print(len(LaTeX_text0)>100,len(LaTeX_text0))
print(LaTeX_text0.split('\n'))
print(list_eqs)

\"\"\"

list_eqs=LaTeX_text0.split('\\\\')

state=False
for eqn in list_eqs:
    if len(eqn)>110:
        state=True
        break


"(,)
的#79""(公式结构#74,L模板2#80)
L模板2#80"
\begin{widetext}
\begin{equation}
%LaTeX
\label{eq:%名字}
\end{equation}
\end{widetext}

"(,)
的#81""(库#66,文本结构#82)
文本结构#82"\"\"\"
P代码:...

\"\"\"

+文本结构(_节点,_内容)->+[del](,+文本结构)...
->的(文本结构,P代码)...

->+[python](Python,+[增加内容2])->+[code](+[python],P代码)...
->+[.]\"text_context\"(+[python],_节点)...

->+[增加内容2](,_内容)

"(,)
的#83""(文本结构#82,P代码#84)
P代码#84"\"\"\"
print(text_context)

\"\"\"

if len(text_context)>4 and text_context[0:4]=='<h3>':
    ans='\\section{%s}\n\n'%(text_context[4:-5])
else:
    ans=text_context+'\n\n'


"(,)
的#85""(生成附录#62,描述结构#86)
描述结构#86"\"\"\"


\"\"\"

+描述结构(_章节,)->+操作(+描述结构,)...

->[]{
    []=>的(_章节,_节点)->_节点=>[]:
        ->[is](_节点,文本)->文本->+文本结构(_节点,)->+的(+操作,+文本结构),
        ->[is](_节点,公式)->公式->+公式结构(_节点,)->+的(+操作,+公式结构),
        ->[is](_节点,图片)->图片->+图片结构(_节点,)->+的(+操作,+图片结构),
        ->[]
}

"(,)
的#87""(库#42,生成概述#88)
生成概述#88"\"\"\"
L模板:...

\"\"\"

+生成概述(二级标题,_文本)->+[del](,+生成概述)...
->的(生成概述,L模板)...

->+的(_文本,+概述)...

->+[临时文本]->[]{
    []=>的(二级标题,文本)->文本=>+[增加内容2](文本,+[临时文本])
}...

->+[模板文本](L模板,+概述)->+[.](+[模板文本],+[临时文本])


"(,)
的#89""(生成概述#88,L模板#90)
L模板#90"%[临时文本]
"(,)
的#91""(库#42,生成标题#92)
生成标题#92"\"\"\"
L模板:...

\"\"\"

+生成标题(一级标题,_文本)->+[del](,+生成标题)...
->的(生成标题,L模板)...

->+的(_文本,+标题)->+的(+标题,+地址)->+地址\"/pages/title.html\"...
    ->+的(+标题,+原型)->+原型(+标题,一级标题)...

->的(一级标题,题目)...
->+[模板文本](L模板,+标题)->+[.](+[模板文本],题目)


"(,)
的#93""(生成标题#92,L模板#94)
L模板#94"# %题目
"(,)
的#95""(库#42,生成章节#96)
生成章节#96"\"\"\"
描述结构:...
库:...
L模板:...
+[新建阅读窗口](,描述结构)

\"\"\"

+生成章节(_章节,_文本)->+[del](,+生成章节)...
->的(生成章节,描述结构)->的(生成章节,库)...
->的(生成章节,L模板)->的(库,输出页面)...

->+的(_文本,+章节)->+的(+章节,+原型)->+原型(+章节,_章节)...
->+[code]([想],描述结构)->[想](_章节,+章节)...

->操作([想],)...
->+[临时文本]#内容->[]{
    []=>的(操作,_操作)->_操作(_主语,)->_主语(,)...
    =>[说](,_操作)->的(库,_条目)->[eq](_条目,_操作)...
    ->+[做](_主语,+[临时文本]#内容)->+[code](+[做],_条目)->+[.]\"输出\"(+[做],_文本)
}...

->的(_章节,题目)...
->+[模板文本](L模板,+章节)...
->+[.]\"内容\"(+[模板文本],+[临时文本]#内容)->+[.](+[模板文本],题目)...

->+[做](_章节,+章节)->+[code](+[做],输出页面)


"(,)
的#97""(生成章节#96,描述结构#98)
描述结构#98"\"\"\"


\"\"\"

+描述结构(_章节,_文本)->+操作(+描述结构,)...

->[]{
    []=>的(_章节,_节点)->_节点=>[]:
        ->[is](_节点,文本)->文本->+文本结构(_节点,)->+的(+操作,+文本结构),
        ->[is](_节点,公式)->公式->+公式结构(_节点,)->+的(+操作,+公式结构),
        ->的(_节点,3D)->3D->+3D结构(_节点,)->+的(+操作,+3D结构),
        ->的(_节点,SVG)->SVG->+SVG结构(_节点,)->+的(+操作,+SVG结构),
        ->[is](_节点,图片)->图片->+图片结构(_节点,)->+的(+操作,+图片结构),
        ->[is](_节点,表格)->表格->+表格结构(_节点,)->+的(+操作,+表格结构),
        ->[]
}

"(,)
的#99""(生成章节#96,库#100)
库#100"

文本结构:...
公式结构:...
图片结构:...
3D结构:...
SVG结构:...
将条目\"3D结构\"复制为条目\"SVG结构\"

表格结构:...
将条目\"图片结构\"复制为条目\"表格结构\"

输出页面:...



"(,)
的#101""(库#100,文本结构#102)
文本结构#102"\"\"\"
P代码:...

\"\"\"

+文本结构(_节点,_内容)->+[del](,+文本结构)...
->的(文本结构,P代码)...

->+[python](Python,+[增加内容2])->+[code](+[python],P代码)...
->+[.]\"text_context\"(+[python],_节点)...

->+[增加内容2](,_内容)

"(,)
的#103""(文本结构#102,P代码#104)
P代码#104"\"\"\"
print(text_context)

\"\"\"

if len(text_context)>4 and text_context[0:4]=='<h3>':
    ans='### %s\n'%(text_context[4:-5])
else:
    ans=text_context+'\n'


"(,)
的#105""(库#100,公式结构#106)
公式结构#106"\"\"\"
P代码:...
设置公式:...
L模板:短公式...
L模板2:长公式...
L模板3:多行...

\"\"\"

+公式结构(_节点,_内容)->+[del](,+公式结构)...
->的(公式结构,L模板)->的(公式结构,L模板2)->的(公式结构,L模板3)...
->的(公式结构,P代码)->的(公式结构,设置公式)...

->的(_节点,名字)->的(_节点,LaTeX)...

->+[python](Python,+[临时文本]#名字)...
    ->+[code](+[python],设置公式)->+[.]\"name\"(+[python],名字)...

->+[模板文本](,+[增加内容2])->+[增加内容2](,_内容)...
->+[.]\"名字\"(+[模板文本],+[临时文本]#名字)...
->+[.]\"LaTeX\"(+[模板文本],+[临时文本]#t)...

->+[.]\"LaTeX_text0\"([python],LaTeX)...
->+[o]\"LaTeX_text\"([python],+[临时文本]#t)...
->+[code]([python],P代码)->[python](Python,+[临时文本]):
    ->[==]\"1\"(,+[临时文本])->+[code](+[模板文本],L模板),
    ->[==]\"2\"(,+[临时文本])->+[code](+[模板文本],L模板2),
    ->+[code](+[模板文本],L模板3)


"(,)
的#107""(公式结构#106,L模板2#108)
L模板2#108"
$$
%LaTeX
\tag{%名字}
$$

"(,)
的#109""(公式结构#106,P代码#110)
P代码#110"\"\"\"
记住\"Python\"
测试:...
保存:...
print(LaTeX_text0)
print(re.sub('\n+$','',LaTeX_text0))
LaTeX_text

txt=r'I_{scatter}=\frac{1}{L_{2}}\ \int_{}^{}{d\theta\ }{S(E_{f}(\theta))\ f(\theta)\ \frac{\partial E_{f}}{\partial \theta}\ exp(-\frac{\alpha^{2}}{\sigma_{s}(E_{f}(\theta))^{2}})}'
print(txt.replace('\ ','\\\\ \n',1))


\"\"\"

state=True
ans=1
if len(LaTeX_text0)<150 or 'cases' in LaTeX_text0:
    LaTeX_text=LaTeX_text0
    ans=1
elif len(LaTeX_text0)<200:
    LaTeX_text=LaTeX_text0.replace('\ ','\\\\ \n',1)
    ans=3
else:
    LaTeX_text=LaTeX_text0
    ans=2

LaTeX_text=re.sub('\n+$','',LaTeX_text)
print(LaTeX_text,ans)

"(,)
的#111""(P代码#110,测试#112)
测试#112"LaTeX_text0=\"\frac{\sigma_E}{E}\approx \frac{1}{\beta-\theta}*\sqrt{(\frac{L_0+L_1}{L_0*L_2})^{2}*\sigma_s^{2}+(\frac{L_0+L_1+L_2}{L_0*L_2})^{2}*\sigma_f^{2}+(\frac{1}{L_0})^{2}*\sigma_o^{2}}\"


LaTeX_text0=\"\begin{cases}\n\sigma=A_{3}/E^{3}+A_{2}/E^{2}+A_{1}/E+A_{0}\\\\ A_{3}=-4.583\times 10^{3}\ MeV^{3}\ rad\\ A_{2}=34.984\ MeV^{2}\ rad\\ A_{1}=3.421\ MeV\ rad\\\\ A_{0}=4.925\times 10^{-6}\ rad\n\end{cases}\n\"

LaTeX_text0=\"\"

print(len(LaTeX_text0)>100,len(LaTeX_text0))
print(LaTeX_text0.split('\n'))
print(list_eqs)
"(,)
的#113""(P代码#110,保存#114)
保存#114"\"\"\"
记住\"Python\"
测试:...
print(LaTeX_text0)

\"\"\"

list_eqs=LaTeX_text0.split('\\\\')

state=False
for eqn in list_eqs:
    if len(eqn)>110:
        state=True
        break


"(,)
的#115""(公式结构#106,L模板#116)
L模板#116"
$$
%LaTeX
\tag{%名字}
$$

"(,)
的#117""(公式结构#106,L模板3#118)
L模板3#118"
$$
%LaTeX
\tag{%名字}
$$
"(,)
的#119""(公式结构#106,设置公式#120)
设置公式#120"\"\"\"
记住\"Python\"

\"\"\"

if len(name)>3 and name[0]=='[' and name[-2:]=='].':
    name=name[1:-2]
ans=name

"(,)
的#121""(库#100,SVG结构#122)
SVG结构#122"\"\"\"
P代码:...
L模板:...
模板2:...

\"\"\"

+SVG结构(_节点,_内容)->+[del](,+SVG结构)...
->的(SVG结构,L模板)->的(SVG结构,模板2)->的(SVG结构,P代码)...

->.\"输出\"(+SVG结构,_输出)->的(_输出,地址)...

->的(_节点,名字)->的(_节点,内容)...
->+的(_节点,+目标地址)...

->+[python](Python,+目标地址)->+[code](+[python],P代码)...
->+[.]\"fig_name\"(+[python],名字)->+[.]\"address\"(+[python],地址)...

->+[模板文本](,+[增加内容2])->+[增加内容2](,_内容)...
->+[code](+[模板文本],L模板)...
->+[.](+[模板文本],+目标地址)->+[.](+[模板文本],名字)...

->+[模板文本](模板2,+[临时文本])->+[.](+[模板文本],内容)...
->+[增加内容](地址,+[保存文本])->+[增加内容](+目标地址,+[保存文本])...
    ->+[保存文本](,+[临时文本])
"(,)
的#123""(SVG结构#122,L模板#124)
L模板#124"<img src=\"..%目标地址\"/>
"(,)
的#125""(SVG结构#122,P代码#126)
P代码#126"\"\"\"
记住\"Python\"

\"\"\"

ans=\"/res/%s.svg\"%(fig_name)

"(,)
的#127""(SVG结构#122,模板2#128)
模板2#128"%内容
"(,)
的#129""(库#100,输出页面#130)
输出页面#130"\"\"\"
描述结构:...
P代码:...
模板:...

\"\"\"
+输出页面(_节点,_章节)->+[del](,+输出页面)...
->的(输出页面,模板)->的(输出页面,P代码)...

->的(_节点,题目)->+的(_章节,+地址)...
->+[python](Python,+地址)->+[code](+[python],P代码)...
->+[.]\"name0\"(+[python],题目)...

->+[模板文本](模板,_章节)->+[.]\"内容\"(+[模板文本],_章节)

"(,)
的#131""(输出页面#130,模板#132)
模板#132"%内容"(,)
的#133""(输出页面#130,P代码#134)
P代码#134"\"\"\"
记住\"Python\"
str0='1 1 1'
print(str0,str0.replace(' ','_'))

\"\"\"

name=name0.replace(' ','_')
ans='/pages/%s.html'%(name)
print(ans)

"(,)
的#135""(输出页面#130,描述结构#136)
描述结构#136""(,)
的#137""(库#100,表格结构#138)
表格结构#138"\"\"\"
P代码:...
L模板:...
L模板2:...

\"\"\"

+表格结构(_节点,_内容)->+[del](,+表格结构)...
->的(表格结构,L模板)->的(表格结构,L模板2)->的(表格结构,P代码)...

->的(_节点,类型)->的(_节点,位置)...
->的(_节点,名字)->的(_节点,图例)...
->的(_节点,内容)...
->+[python](Python,+[临时文本])->+[code](+[python],P代码)...
->+[.]\"txt_in\"(+[python],内容)->+[.]\"fig_name\"(+[python],名字)...

->+[模板文本](,+[增加内容2])->+[增加内容2](,_内容)...
->+[.](+[模板文本],名字)->+[.](+[模板文本],图例)->+[.](+[模板文本],位置)...
->+[.]\"内容\"(+[模板文本],+[临时文本])...
->+[o]\"type_out\"(+[python],+格式)->+[.](+[模板文本],+格式)->+[del](,+格式)...
->[]:

->[==]\"normal\"(,类型)->+[code](+[模板文本],L模板),
->+[code](+[模板文本],L模板2)


"(,)
的#139""(表格结构#138,L模板2#140)
L模板2#140"<img src=\"..%目标地址\" width=\"95%\"><br>

"(,)
的#141""(表格结构#138,P代码#142)
P代码#142"\"\"\"
记住\"Python\"
+[P函数](,P代码)
保存:...

\"\"\"
import numpy as np
import re

rows=txt_in.split('\n')
txt_out=''
type_out=''
len_max=0

for row in rows:
    row0=re.sub('; *','',row)
    if row0=='':
        continue
    list_ele=re.split('[,] *',row0)

    len_max=np.max([len_max,len(list_ele)])

    if txt_out=='':
        line='<tr><th>'+'</th><th>'.join(list_ele)+'</th></tr>'
        txt_out+=line+'\n'
    else:
        line='<tr><td>'+'</td><td>'.join(list_ele)+'</td></tr>'
        txt_out+=line+'\n'

for i in range(len_max):
    type_out+='c'

ans=txt_out


"(,)
的#143""(P代码#142,保存#144)
保存#144"\"\"\"
记住\"Python\"
+[P函数](,P代码)

\"\"\"
import numpy as np
import re

rows=txt_in.split('\n')
txt_out=''
type_out=''
len_max=0

for row in rows:
    row0=re.sub('; *','',row)
    if row0=='':
        continue
    list_ele=re.split('[,] *',row0)

    len_max=np.max([len_max,len(list_ele)])

    if txt_out=='':
        for txt_ele in list_ele:
            txt_out+=\"\n\\textrm{%s}&\"%(txt_ele)
        txt_out=txt_out[0:-1]
        txt_out+='\\\\\n\\colrule'
    else:
        for txt_ele in list_ele:
            txt_out+=\" %s &\"%(txt_ele)
        txt_out=txt_out[0:-1]
        txt_out+='\\\\\n'

for i in range(len_max):
    type_out+='c'

ans=txt_out


"(,)
的#145""(表格结构#138,L模板#146)
L模板#146"<style>
table, th, td{
    border: 1px solid black;
    text-align: left;
    font-size:20px;
    #color:red;
}
</style>

<table style=\"width:50%\">
%内容
</table>"(,)
的#147""(库#100,3D结构#148)
3D结构#148"\"\"\"
P代码:...
L模板:...
模板2:...

\"\"\"

+3D结构(_节点,_内容)->+[del](,+3D结构)...
->的(3D结构,L模板)->的(3D结构,模板2)->的(3D结构,P代码)...

->.\"输出\"(+3D结构,_输出)->的(_输出,地址)...

->的(_节点,名字)->的(_节点,内容)...
->+的(_节点,+目标地址)...

->+[python](Python,+目标地址)->+[code](+[python],P代码)...
->+[.]\"fig_name\"(+[python],名字)->+[.]\"address\"(+[python],地址)...

->+[模板文本](,+[增加内容2])->+[增加内容2](,_内容)...
->+[code](+[模板文本],L模板)...
->+[.](+[模板文本],+目标地址)->+[.](+[模板文本],名字)...

->+[模板文本](模板2,+[临时文本])->+[.](+[模板文本],内容)...
->+[增加内容](地址,+[保存文本])->+[增加内容](+目标地址,+[保存文本])...
    ->+[保存文本](,+[临时文本])
"(,)
的#149""(3D结构#148,模板2#150)
模板2#150"var shape, pt, eulers;

%内容

animate_3D();
world_3D.update();
"(,)
的#151""(3D结构#148,P代码#152)
P代码#152"\"\"\"
记住\"Python\"

\"\"\"

ans=\"/res/%s.js\"%(fig_name)

"(,)
的#153""(3D结构#148,L模板#154)
L模板#154"
<div id=\"%名字\" class=\"w3D\"></div>
<script>
world_3D.init(\"%名字\");
</script>
<script type=\"text/javascript\" src=\"..%目标地址\"></script>
"(,)
的#155""(库#100,图片结构#156)
图片结构#156"\"\"\"
P代码:...
L模板:...
L模板2:...

\"\"\"

+图片结构(_节点,_内容)->+[del](,+图片结构)...
->的(图片结构,L模板)->的(图片结构,L模板2)->的(图片结构,P代码)...

->.\"输出\"(+图片结构,_输出)->的(_输出,地址)...

->的(_节点,类型)->的(_节点,位置)...
->的(_节点,名字)->的(_节点,图例)->的(_节点,源地址)...
->的(_节点,目标地址)...

->+[python](Python,目标地址)->+[code](+[python],P代码)...
->+[.]\"source_dir\"(+[python],源地址)->+[.]\"fig_name\"(+[python],名字)...
->+[.]\"address\"(+[python],地址)...

->+[模板文本](,+[增加内容2])->+[增加内容2](,_内容)...
->+[.](+[模板文本],目标地址)->+[.](+[模板文本],图例)->+[.](+[模板文本],位置):

->[==]\"normal\"(,类型)->+[code](+[模板文本],L模板),
->+[code](+[模板文本],L模板2)

"(,)
的#157""(图片结构#156,L模板#158)
L模板#158"<img src=\"..%目标地址\" height=\"200\"/>
"(,)
的#159""(图片结构#156,P代码#160)
P代码#160"\"\"\"
记住\"Python\"

\"\"\"

fig_type=source_dir.split('.')[-1]
ans=\"/res/%s.%s\"%(fig_name,fig_type)

"(,)
的#161""(图片结构#156,L模板2#162)
L模板2#162"<img src=\"..%目标地址\" width=\"95%\"/>
"(,)
的#163""(生成章节#96,L模板#164)
L模板#164"## %题目
%内容
"(,)
的#165""(章节内容#40,描述结构#166)
描述结构#166"\"\"\"


\"\"\"
+描述结构(_章节结构,_文本)->+操作(+描述结构,)...

->[]{
    []:->[is](_章节结构,一级标题)->一级标题(,)...
        ->+生成标题(一级标题,_文本)->+的(+操作,+生成标题),
    ->[is](_章节结构,文本)->文本(,)...
        ->+生成作者(文本,_文本)->+的(+操作,+生成作者),
    ->[is](_章节结构,_章节)->_章节->的(_章节,题目)->[==]\"Abstract\"(,题目)...
        ->+生成概述(_章节,_文本)->+的(+操作,+生成概述),
    ->[is](_章节结构,_附录)->_附录->的(_附录,题目#2)->[==]\"Appendix\"(,题目#2)...
        ->+生成附录(_附录,_文本)->+的(+操作,+生成附录),
    ->[is](_章节结构,二级标题)->二级标题(,)...
        ->+生成章节(二级标题,_文本)->+的(+操作,+生成章节)
}


"(,)
的#167""(降临规则#2,整理引用#168)
整理引用#168"\"\"\"
P代码:...
print(list_lk)
print(paper_text)

\"\"\"

+整理引用(_媒介,_文本)->+[del](,+整理引用)...
->的(整理引用,P代码)...

->.(_媒介,_文章)...
->+[python]\"list_lk=[]\"(Python,)->[]{
    []=>的(_文章,_节点)->_节点->引用(_节点,)...
    =>+[标题](_节点,)->+[python]\"list_lk.append(name)\"(Python,)...
        ->+[s]\"name\"(+[python],+[标题])
}...

->+[python](Python,_文本)->+[code](+[python],P代码)...
->+[s]\"paper_text\"(+[python],_文本)




"(,)
的#169""(整理引用#168,P代码#170)
P代码#170"\"\"\"
记住\"Python\"
测试:...

\"\"\"

import re

link_pat='\[([a-zA-Z]+\d*)(, ?[a-zA-Z]+\d*)*\]'
i=0
out_text=''

while True:
    if i>=len(paper_text):
        break
    a=re.match(link_pat,paper_text[i:])
    if a!=None and a.group(1) in list_lk:
        new_text='\\cite{%s}'%(a.group()[1:-1])
        di0=a.span()[1]
        out_text+=new_text
        i+=di0-1
    else:
        out_text+=paper_text[i]
    i+=1

ans=out_text


"(,)
的#171""(P代码#170,测试#172)
测试#172"\"\"\"
+[P函数](,测试)
Nini, 打开公式分析器(文件)

\"\"\"

list_lk=['a1','a2','c1']
paper_text=\"\"\"
[a1,a2]
[1].
[c1],[c1]

\"\"\"

import re

link_pat='\[([a-zA-Z]+\d*)(, ?[a-zA-Z]+\d*)*\]'
i=0
out_text=''

while True:
    if i>=len(paper_text):
        break
    a=re.match(link_pat,paper_text[i:])
    if a!=None and a.group(1) in list_lk:
        new_text='\\cite{%s}'%(a.group()[1:-1])
        di0=a.span()[1]
        out_text+=new_text
        i+=di0-1
    else:
        out_text+=paper_text[i]

    i+=1

print(out_text)


\"\"\"
print(a.span())
+[P函数](,测试)

\"\"\""(,)
的#173""(降临规则#2,整理地址#174)
整理地址#174"\"\"\"
P代码:...
P代码2:...

\"\"\"

+整理地址(_媒介,_凭依)->+[del](,+整理地址)...
->的(整理地址,P代码)->的(整理地址,P代码2)...

->的(_凭依,地址)...
->+[python](Python,地址)->+[s]\"folder_name\"(+[python],地址)...
->[]{
    []:->的(_凭依,文件名)->文件名(,)...
        ->+[s]\"file_name\"(+[python],文件名)->+[code](+[python],P代码),
    ->+的(_凭依,+文件名)...
        ->+[o]\"file_name\"(+[python],+文件名)->+[code](+[python],P代码2)
}


"(,)
的#175""(整理地址#174,P代码#176)
P代码#176"\"\"\"


\"\"\"

ans=folder_name

"(,)
的#177""(整理地址#174,P代码2#178)
P代码2#178"\"\"\"
ans=folder_name
print([i for i in range(1,3)])

\"\"\"

folders=folder_name.split('/')
list_folders=[folders[0]]
for i in range(1,len(folders)):
    folder=folders[i]
    if folder!=\"\":
        list_folders.append(folder)

file_name=list_folders[-1]
if '.' in file_name:
    ans=\"/\".join(list_folders[0:-1])
else:
    ans=\"/\".join(list_folders)
    file_name=\"README.md\"

"(,)
的#179""(文本转换_md#0,召唤规则#180)
召唤规则#180"\"\"\"
Nini, 打开人体模型(文件)
Nini, 打开CBS(文件)
    ->+整体架构(_媒介,_凭依)->+的(操作,+整体架构)...

\"\"\"

+召唤规则(_媒介,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_凭依)...

->[==]\"结构文本转md\"(,召唤星辰)...
    ->+整理图片(_媒介,_凭依)->+的(操作,+整理图片)...
    ->+整理内容(_媒介,_凭依)->+的(操作,+整理内容)...
    ->+整理引用(_媒介,_凭依)->+的(操作,+整理引用)...


->[]{
    []=>的(_媒介,_章节)->_章节=>+章节内容(_章节,_凭依)->+的(操作,+章节内容)
}...
->[]{
    []:->.(_媒介,_原始结构)->_原始结构(,)...
        ->+引用文章(_原始结构,_凭依)->+的(操作,+引用文章),
    ->[]
}...
->+整理地址(_媒介,_凭依)->+的(操作,+整理地址)


"(,)

## end
#2122, 602:
"""
P代码:...
P代码2:...
+[新建阅读窗口](,P代码)

"""

+整理图片(_媒介,_凭依)->+[del](,+整理图片)...
->的(整理图片,P代码)->的(整理图片,P代码2)...

->的#0(_凭依,地址)->+[标题](_凭依,)...
->+[python](Python,+[临时文本])->+[code](+[python],P代码)...
->+[.]"file_name"(+[python],+[标题])->+[.]"folder_dir"(+[python],地址)...
->+[保存文本](+[临时文本],_凭依)...

->[]{
    []=>的(_媒介,二级标题)->二级标题->的(二级标题,图片)...
    ->的(图片,源地址)->的(图片,目标地址)...
        =>+[python](Python,)->+[code](+[python],P代码2)...
        ->+[.]"src_dir"(+[python],源地址)->+[.]"tar_dir"(+[python],目标地址)...
        ->+[.]"folder_dir"(+[python],地址)
}...

->+[del](,的#0)...
->+[删除结构](,_凭依)...
->+[有](_凭依,地址)





## end
#2124, 363:
"""
P代码:...
P代码2:...

"""

+整理地址(_媒介,_凭依)->+[del](,+整理地址)...
->的(整理地址,P代码)->的(整理地址,P代码2)...

->的(_凭依,地址)...
->+[python](Python,地址)->+[s]"folder_name"(+[python],地址)...
->[]{
    []:->的(_凭依,文件名)->文件名(,)...
        ->+[s]"file_name"(+[python],文件名)->+[code](+[python],P代码),
    ->+的(_凭依,+文件名)...
        ->+[o]"file_name"(+[python],+文件名)->+[code](+[python],P代码2)
}



## end
#2126, 28:
"""


"""

ans=folder_name


## end
#2128, 373:
"""
ans=folder_name
print([i for i in range(1,3)])

"""

folders=folder_name.split('/')
list_folders=[folders[0]]
for i in range(1,len(folders)):
    folder=folders[i]
    if folder!="":
        list_folders.append(folder)

file_name=list_folders[-1]
if '.' in file_name:
    ans="/".join(list_folders[0:-1])
else:
    ans="/".join(list_folders)
    file_name="README.md"


## end
#2129, 17:
文档/S应用/结构化文本/md文件
## end
#2131, 5:

%内容

## end
#2132, 648:
"""
记住"Python"
+[P函数](,P代码)

"""
import numpy as np
import re

rows=txt_in.split('\n')
txt_out=''
type_out=''
len_max=0

for row in rows:
    row0=re.sub('; *','',row)
    if row0=='':
        continue
    list_ele=re.split('[,] *',row0)

    len_max=np.max([len_max,len(list_ele)])

    if txt_out=='':
        for txt_ele in list_ele:
            txt_out+="\n\\textrm{%s}&"%(txt_ele)
        txt_out=txt_out[0:-1]
        txt_out+='\\\\\n\\colrule'
    else:
        for txt_ele in list_ele:
            txt_out+=" %s &"%(txt_ele)
        txt_out=txt_out[0:-1]
        txt_out+='\\\\\n'

for i in range(len_max):
    type_out+='c'

ans=txt_out



## end
#2134, 610:
"""
记住"Python"
+[P函数](,P代码)
保存:...
print("!!!!")

"""
import numpy as np
import re

rows=txt_in.split('\n')
txt_out=''
type_out=''
len_max=0

for row in rows:
    row0=re.sub('; *','',row)
    if row0=='':
        continue
    list_ele=re.split('[,] *',row0)

    len_max=np.max([len_max,len(list_ele)])

    if txt_out=='':
        line='|'+'|'.join(list_ele)+'|'
        txt_out+=line+'\n|'
        for ele in list_ele:
            txt_out+=":---:|"
        txt_out+="\n"
    else:
        line='|'+'|'.join(list_ele)+'|'
        txt_out+=line+'\n'

for i in range(len_max):
    type_out+='c'

ans=txt_out



## end
#2137, 499:
"""
P代码:...
L模板:...

"""

+表格结构(_节点,_内容)->+[del](,+表格结构)...
->的(表格结构,L模板)->的(表格结构,P代码)...

->的(_节点,类型)->的(_节点,位置)...
->的(_节点,名字)->的(_节点,图例)...
->的(_节点,内容)...
->+[python](Python,+[临时文本])->+[code](+[python],P代码)...
->+[.]"txt_in"(+[python],内容)->+[.]"fig_name"(+[python],名字)...

->+[模板文本](,+[增加内容2])->+[增加内容2](,_内容)...
->+[.](+[模板文本],名字)->+[.](+[模板文本],图例)->+[.](+[模板文本],位置)...
->+[.]"内容"(+[模板文本],+[临时文本])...
->+[o]"type_out"(+[python],+格式)->+[.](+[模板文本],+格式)->+[del](,+格式)...
->+[code](+[模板文本],L模板)




## end
### 结束