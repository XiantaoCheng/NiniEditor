### 节点
地址, 几何画板, 起始角度, 半径, 中心, 标记, 数值, 的, 的, 的, 的, 的, 输入, 的, HTML, 的, 画图, 等于, pt11, 等于, pt12, 等于, pt21, 等于, pt22, 等于, angle, 的, 的, 的, 的, 的, 的, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 输出, 的, 的, P代码, 类型, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 夹角, 线型, 线粗细, 线颜色, 终点, 起点, 的, 的, 的, 的, 的, 输入, 的, HTML, LaTeX数学记号, 的, 点线公式, 输出, 的, 的, 输入, 的, 的, 的, 选中区域, 类型, 选中框, 图形, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 入射光线, 线型, 线粗细, 线颜色, 终点, 起点, 的, 的, 的, 的, 的, 输入, 的, HTML, LaTeX数学记号, 的, 点线公式, 输出, 的, 的, 输入, 的, 的, 的, 选中区域, 类型, 选中框, 图形, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 光栅表面, 地址, 线颜色, 面颜色, 线粗细, 线型, 字体, 文字, 类型, 尺寸, 起点, 的, 的, 的, 的, 的, 的, 的, 的, 的, 输入, 输出, 的, 的, HTML, 输出, 的, 的, 选中区域, 图形, 选中框, 的, 的, 输出, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 光栅照片, 的, 的, 的, 的, 画板, 的, 的, 的, 测量角度, 目录, 的, 的, 三维测量, 的, 星图, 的, 三维建模, 的, Blender, P函数, 的, 地址, 的, 场景描述, 的, 相机, 的, 的, 的, 的, 空间点, 看向, 空间点, 在, 的, 街道, 的, 的, 的, 的, 的, 的, 的, 中心, 的, 长, 的, 宽, 的, 平面, 的, 楼房A, 的, 的, 的, 的, 的, 的, 的, 的, 的, 空间点, 在, 宽, 的, 长, 的, 高, 的, 立方体, 的, 的, 空间点, 在, 的, 动词, 的, 结构转Blender, 的, 库, 的, 文本结构, 的, 立方体, 的, 平面, 的, 相机, 的, P代码, 的, P代码, 的, P代码, 的, 主体, 的, 的, 是, 是, 的, 描述三维场景, 的, P代码, 的, 相机参数, 的, 计算相机方向, html, 的, 参考, 的, 网页画板, 的, 测试公式, M函数, 的, 参考, 的, 场景, M函数, 的, 交点公式, 的, intersection_lines, M函数, 的, 地址, 的, 测试灭点公式, M函数, 的, 灭点场景, M函数, 的, 测试灭点, M函数, 的, alpha+180, M函数, 的, 验证scale公式, M函数, 的, 关于重根问题, 的, 计算相机位置, html, 的, 测试公式, M函数, 的, 测试cot, M函数, 的, 办公室场景, 的, 相片, 的, 相机, 的, 拍摄, 的, 图片, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 画图, 的, 的, 的, 的, 输出, 的, 的, 选中框, 图形, 选中区域, 的, 的, 输出, HTML, 的, 的, 输出, 输入, 的, 的, 的, 的, 的, 的, 的, 的, 的, 起点, 尺寸, 类型, 文字, 字体, 线型, 线粗细, 面颜色, 线颜色, 地址, 比例, 的, 尺寸, 的, 原点, 的, 坐标系, 的, 的, 的, 的, 方向, 朝着, 空间点, 在, 的, 自由四边形, P函数, 的, X坐标, 的, Y坐标, 的, 画图, 的, 输出, 的, 输入, 的, 的, 的, 设置形状, P函数, 的, 设置形状_P, P函数, 的, 输出, 的, 输入, 的, 的, 的, 的, 计算相机参数, M函数, 的, camera_from_photo, M函数, 的, 地址, 的, 计算相机参数, M函数, 的, 平面投影, html, 的, 计算投影, M函数, 的, Euler_frame, 的, 地址, 的, camera_To_3D, 的, 地址, 的, 测试场景, M函数, 的, 节点数目统计, 20210926, 的, M函数, 的, 测试算法, 的, 测试代码, M函数, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, Z, 的, Y, 的, X, 的, 样式, 方向, 朝向, 空间点, 在, Z, 的, Y, 的, X, 的, 样式, 方向, 朝向, 空间点, 在, Z, 的, Y, 的, X, 的, 样式, 方向, 朝向, 空间点, 在, Z, 的, Y, 的, X, 的, 样式, 方向, 朝向, 空间点, 在, Z, 的, Y, 的, X, 的, 样式, 方向, 朝向, 空间点, 在, Z, 的, Y, 的, X, 的, 样式, 方向, 朝向, 空间点, 在, Z, 的, Y, 的, X, 的, 样式, 方向, 朝向, 空间点, 在, Z, 的, Y, 的, X, 的, 样式, 方向, 朝向, 空间点, 在, 键盘2, 键盘1, 窗子, 黑板, 柜子, 桌子2, 桌子1, 房间, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, D, 的, 形状, 的, Z, 的, Y, 的, X, 的, 样式, 方向, 朝向, 空间点, 在, 相机, 的, 相片场景, 的, 相片场景, 的, 的, 的, 的, 的, 的, 的, 的, 内容, 的, 样式, 尺寸, 的, 空间点, 在, 相片, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, y, 的, x, 的, 样式, 方向, 朝向, 空间点, 在, y, 的, x, 的, 样式, 方向, 朝向, 空间点, 在, y, 的, x, 的, 样式, 方向, 朝向, 空间点, 在, y, 的, x, 的, 样式, 方向, 朝向, 空间点, 在, y, 的, x, 的, 样式, 方向, 朝向, 空间点, 在, y, 的, x, 的, 样式, 方向, 朝向, 空间点, 在, y, 的, x, 的, 样式, 方向, 朝向, 空间点, 在, y, 的, x, 的, 样式, 方向, 朝向, 空间点, 在, 键盘2, 键盘1, 窗子, 黑板, 柜子, 桌子2, 桌子1, 房间, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 空间点, 在, 空间点, 在, 空间点, 在, 空间点, 在, D, C, B, A, 的, 的, 的, 的, 边, 边, 边, 边, 20210928, 的, 20210930, 的, 20211002, 的, 的, 句子, 的, 空间点, 的, 空间点, 20211128, 的, 20211205, 的, 的, PPT, 的, 描述, 的, 库, 的, 标记多边形, 的, M代码, M函数, 的, getRefPlane, M函数, 的, 地址, 的, 设置n边形, 的, 设置相机参数, 的, 设置对应关系, 的, 匹配模板, 的, 输出模板, 的, 设置对应关系2, 的, 匹配模板, 的, 输出模板, 的, M代码, M函数, 的, 设置相机位置, 的, 匹配模板, 的, 输出模板, 的, 空间投影, 20211206, 的, 的, 拍照, 的, M代码, M函数, 的, 拍摄照片, 的, 匹配模板, 的, 输出模板, 20211207, 的, 20211208, 的, 20211209, 的, 的, GetPointOnPlane, M函数, 的, 地址, 的, 标记区域, 的, 匹配模板, 的, 输出模板, 的, 标记区域2, 的, 匹配模板, 的, 输出模板, 的, 记录区域, 的, 匹配模板, 的, 输出模板, 的, 获取三维坐标, 的, 匹配模板, 的, 输出模板, 的, 获取三维坐标, 的, M代码, M函数, 的, get3DPointFromPhoto, M函数, 的, 地址, 的, 测试, M函数, 的, 全局方案存档, 的, get3DPointFromPhoto, M函数, 的, 坐标变换, 的, 三维坐标变换, 的, 匹配模板, 的, 输出模板, 的, 三维坐标变换, 的, M代码, M函数, 20211210, 的, 的, 标记区域3, 的, 输出模板, 的, 匹配模板, 的, 标记区域4, 的, 匹配模板, 的, 输出模板, 的, 获取标记区域, 的, M代码, M函数, 的, 设置约束关系, 的, 匹配模板, 的, 输出模板, 的, 二维坐标转三维坐标, 的, M代码, M函数, 的, 获取三维坐标2, 的, 匹配模板, 的, 输出模板, 的, 三维坐标转二维坐标, 的, M代码, M函数, 的, 获取二维坐标, 的, 匹配模板, 的, 输出模板, 的, 直线交点, 的, 输出模板, 的, 匹配模板, 的, 直线交点, 的, M代码, M函数, 的, 公式, 的, M代码2, M函数, 20211211, 的, 20211213, 的, 20211214, 的, 20220608, 的, 20220609, 的, 设置相机参数, 的, 记忆, 设置相机参数, GetPointOnPlane, 的, GetPointOnPlane, camera_from_photo, 的, camera_from_photo, 的, 场景, M函数, 的, intersection_lines, M函数, 手, 的, 工具库, 的, 测试场景, 的, 地址, 的, 显示测量场景, 的, 描述结构, 的, 库, 的, 显示照片, 的, M代码, 尺寸, 的, 手, 手, Z, 的, Y, 的, X, 的, 方向, 朝向, 空间点, 在, 的, 参考平面, 方向, 朝向, 空间点, 在, 的, 相机, y, 的, x, 的, 长度, 的, 类型, 的, Z, 的, Y, 的, X, 的, 平面A, 的, 的, 垂直, Z, 的, Y, 的, X, 的, 空间点, 在, 宽度, 的, 长度, 的, 类型, 的, 方向, 朝向, 的, 图形投影, 的, M代码, 线段A, 的, Z, 的, Y, 的, X, 的, 空间点, 在, 长度, 的, 类型, 的, 的, 垂直, 方向, 朝向, 平面B, 的, 的, 垂直, 方向, 朝向, 空间点, 在, Z, 的, Y, 的, X, 的, 宽度, 的, 长度, 的, 类型, 的, 的, 标记物体节点, 的, M代码, 的, 描述相对坐标, 的, 召唤规则, 的, 降临规则, 的, 召唤结构, 的, 整理描述, 的, 描述结构, 的, 库, 的, P代码, 的, 单句描述, 的, M代码, 在, 在, 召唤规则, 的, 描述相对坐标, 
### 关联
#, #, #, #, #, #, #, 12#5, 12#4, 12#3, 12#2, 12#6, #, 14#12, #, 16#12, #, 18#71, #, 20#70, #, 22#114, #, 24#113, #, 26#6, #, 34#2, 34#4, 34#26, 34#24, 34#22, 34#20, 34#18, #, 42#18, 42#20, 42#22, 42#24, 42#26, 42#4, 42#2, #, 45#34, 45#42, #, #, 66#2, 66#3, 66#4, 66#14, 66#5, 66#16, 66#17, 66#18, 66#19, 66#20, 66#21, 66#22, 66#23, 66#24, 66#25, 66#26, 66#45, 66#46, 66#6, 109#152, #, #, #, #, #, 77#68, 77#67, 77#69, 77#70, 77#71, #, 79#77, #, #, 82#80, #, #, 86#70, 86#71, #, 90#82, 90#83, 90#86, #, #, #, #, #, 99#92, 99#93, 99#94, 99#77, #, 109#67, 109#79, 109#68, 109#69, 109#90, 109#91, 109#99, 109#70, 109#71, #, #, #, #, #, #, 120#111, 120#110, 120#112, 120#113, 120#114, #, 122#120, #, #, 125#123, #, #, 129#113, 129#114, #, 133#125, 133#126, 133#129, #, #, #, #, #, 142#135, 142#136, 142#137, 142#120, #, 152#110, 152#122, 152#111, 152#112, 152#133, 152#134, 152#142, 152#113, 152#114, #, #, #, #, #, #, #, #, #, #, #, 172#153, 172#162, 172#161, 172#158, 172#159, 172#156, 172#157, 172#154, 172#155, #, #, 176#172, 176#173, #, #, 180#172, 180#177, #, #, #, 185#161, 185#162, #, 190#181, 190#182, 190#185, 190#172, #, 204#153, 204#154, 204#155, 204#156, 204#157, 204#158, 204#159, 204#160, 204#161, 204#162, 204#176, 204#180, 204#190, #, 209#66, 209#109, 209#152, 209#204, #, 213#0, 213#1, 213#209, #, #, 214#213, 214#217, #, 217#219, #, 217#221, #, 217#223, #, 223#, 223#226, #, 217#228, #, 228#230, #, 228#235, 228#236, 228#237, 228#238, #, 230#235, #, 230#237, 228#240, #, 228#248, 228#249, 228#250, 228#251, 228#252, 228#253, 228#254, #, 240#248, #, 240#250, #, 240#252, 240#, 228#256, #, 228#266, 228#267, 228#268, 228#269, 228#270, 228#271, 228#272, 228#273, 228#274, #, 256#266, #, 256#268, #, 256#270, #, 256#272, 256#, 228#277, 228#278, #, 248#277, 217#280, #, 280#282, #, 282#284, #, 217#286, #, 284#288, #, 284#290, #, 284#292, #, 288#294, #, 290#296, #, 292#298, #, 228#300, #, 228#303, 228#304, 240#300, 256#300, 280#306, #, 306#308, #, 217#310, #, 310#312, #, 312#, 312#315, #, 217#317, #, 312#319, #, 319#, 319#322, #, 319#324, #, 324#, 312#327, #, 319#329, #, 329#, 329#332, #, 312#334, #, 334#, 334#337, #, 337#, 334#340, #, 340#, 334#343, #, 343#, 312#346, #, 346#, 310#349, #, 310#351, #, 351#, 351#354, #, 354#, 319#357, #, 357#, 217#360, #, 360#362, #, 360#364, #362, 360#366, 364#360, 362#368, #, 368#382, 368#392, 368#396, 368#410, 368#411, 368#412, 368#413, 368#414, 368#415, 368#416, 368#417, 368#418, 368#419, #, 382#400, 382#387, 382#390, 382#391, #, 387#410, 387#411, #, #, #, 392#395, 392#400, #, #, 396#399, 396#400, #, #, 400#417, 400#418, 400#415, 400#416, 400#413, 400#414, 400#411, 400#410, 400#419, #, #, #, #, #, #, #, #, #, #, #, 426#420, #, 426#422, #, 426#424, 362#, 360#431, 360#432, 360#433, 360#434, #, 364#431, #, 364#433, 362#436, #, #, 436#439, #, 436#441, #, 436#443, #, 443#445, #, 443#447, #, 447#439, 447#441, 436#451, #, 451#, 436#454, #, 454#, 454#457, #, 454#459, #, 457#439, 457#441, 451#454, 310#464, #, 464#, 464#467, #, 467#, 467#470, #, 360#472, #, 472#, 217#475, #, 475#, 475#478, #, 478#, 478#481, #, 481#483, #, 478#485, #, 485#487, #, 475#489, #, 489#, 214#492, #, #, 492#493, #, 485#497, #, 467#499, #, 499#, 489#597, 489#598, 489#599, 489#600, 489#601, 489#602, 489#603, 489#604, 489#605, 489#606, 489#607, 489#608, 489#609, 489#610, 489#611, 489#612, 489#613, 489#614, 489#615, 489#616, 489#617, 489#618, 489#619, 489#620, 489#621, 489#622, 489#623, 489#624, 489#625, 489#626, 489#627, 489#628, 489#629, 489#630, 489#631, 489#632, 489#633, 489#634, 489#635, 489#636, 489#637, 489#638, 489#639, 489#640, 489#641, 489#642, 489#643, 489#644, 489#645, 489#646, 489#647, 489#648, 489#649, 489#650, 489#651, 489#652, 489#653, 489#654, 489#655, 489#656, 489#657, 489#658, 489#659, 489#660, 489#661, 489#662, 489#663, 489#664, 489#665, 489#666, 489#667, 489#668, 489#669, 489#670, 489#671, 489#672, 489#673, 489#674, 489#675, 489#676, 489#677, 489#678, 489#679, 489#680, 489#681, 489#682, 489#683, 489#684, 489#685, 489#686, 489#687, 489#688, 489#689, 489#690, 489#691, 489#692, #, 685#597, #, 685#599, #, 685#601, 685#, #, 685#604, #, 685#606, #, 686#608, #, 686#610, #, 686#612, 686#, #, 686#615, #, 686#617, #, 687#619, #, 687#621, #, 687#623, 687#, #, 687#626, #, 687#628, #, 688#630, #, 688#632, #, 688#634, 688#, #, 688#637, #, 688#639, #, 689#641, #, 689#643, #, 689#645, 689#, #, 689#648, #, 689#650, #, 690#652, #, 690#654, #, 690#656, 690#, #, 690#659, #, 690#661, #, 691#663, #, 691#665, #, 691#667, 691#, #, 691#670, #, 691#672, #, 692#674, #, 692#676, #, 692#678, 692#, #, 692#681, #, 692#683, #, #, #, #, #, #, #, #, 489#709, 489#710, 489#711, 489#712, 489#713, 489#714, 489#715, 489#716, 489#717, 489#718, 489#719, 489#720, 489#721, 489#722, 489#723, 489#724, #, 711#709, #, 724#711, #, 724#713, #, 724#715, #, 724#717, 724#, #, 724#720, #, 724#722, #, 489#726, #, 475#728, #, 728#737, 728#738, 728#739, 728#740, 728#741, 728#742, 728#743, 728#744, #, 744#737, 744#, #, 744#740, #, 744#742, #, 728#825, 728#826, 728#827, 728#828, 728#829, 728#830, 728#831, 728#832, 728#833, 728#834, 728#835, 728#836, 728#837, 728#838, 728#839, 728#840, 728#841, 728#842, 728#843, 728#844, 728#845, 728#846, 728#847, 728#848, 728#849, 728#850, 728#851, 728#852, 728#853, 728#854, 728#855, 728#856, 728#857, 728#858, 728#859, 728#860, 728#861, 728#862, 728#863, 728#864, 728#865, 728#866, 728#867, 728#868, 728#869, 728#870, 728#871, 728#872, 728#873, 728#874, 728#875, 728#876, 728#877, 728#878, 728#879, 728#880, 728#881, 728#882, 728#883, 728#884, 728#885, 728#886, 728#887, 728#888, 728#889, 728#890, 728#891, 728#892, 728#893, 728#894, 728#895, 728#896, 728#897, 728#898, 728#899, 728#900, 728#901, 728#902, 728#903, 728#904, #, 897#825, #, 897#827, 897#, #, 897#830, #, 897#832, #, 898#834, #, 898#836, 898#, #, 898#839, #, 898#841, #, 899#843, #, 899#845, 899#, #, 899#848, #, 899#850, #, 900#852, #, 900#854, 900#, #, 900#857, #, 900#859, #, 901#861, #, 901#863, 901#, #, 901#866, #, 901#868, #, 902#870, #, 902#872, 902#, #, 902#875, #, 902#877, #, 903#879, #, 903#881, 903#, #, 903#884, #, 903#886, #, 904#888, #, 904#890, 904#, #, 904#893, #, 904#895, #, #, #, #, #, #, #, #, 728#917, 728#918, 728#919, 728#920, 728#921, 728#922, 728#923, 728#924, 728#925, 728#926, 728#927, 728#928, #, 925#917, #, 926#919, #, 927#921, #, 928#923, #, #, #, #, 728#933, 728#934, 728#935, 728#936, 917#923, 919#917, 921#919, 923#921, #, 492#937, #, 492#939, #, 492#941, 489#944, #, 489#946, #, 489#948, #, #, 492#949, #, 492#951, 217#954, #, 280#956, #, 956#958, #, 280#960, #, 960#962, #, 962#, 962#965, #, 965#, 965#968, #, 958#970, #, 280#972, #, 958#974, #, 974#976, #, 974#978, #, 958#980, #, 980#982, #, 980#984, #, 972#986, #, 986#, 958#989, #, 989#991, #, 989#993, #, 217#995, #, #, 492#996, 280#999, #, 999#1001, #, 1001#, 958#1004, #, 1004#1006, #, 1004#1008, #, #, 492#1009, #, 492#1011, #, 492#1013, 986#1016, #, 1016#, 1016#1019, #, 958#1021, #, 1021#1023, #, 1021#1025, #, 958#1027, #, 1027#1029, #, 1027#1031, #, 958#1033, #, 1033#1035, #, 1033#1037, #, 958#1039, #, 1039#1041, #, 1039#1043, #, 280#1045, #, 1045#1047, #, 1047#, 1047#1050, #, 1050#, 1050#1053, #, 1047#1055, #, 1055#, 1047#1058, #, 1058#1060, #, 1060#, 217#1063, #, 958#1065, #, 1065#1067, #, 1065#1069, #, 280#1071, #, 1071#1073, #, 1073#, #, 492#1075, 958#1078, #, 1078#1080, #, 1078#1082, #, 958#1084, #, 1084#1086, #, 1084#1088, #, 280#1090, #, 1090#1092, #, 1092#, 958#1095, #, 1095#1097, #, 1095#1099, #, 280#1101, #, 1101#1103, #, 1103#, 958#1106, #, 1106#1108, #, 1106#1110, #, 280#1112, #, 1112#1114, #, 1114#, 958#1117, #, 1117#1119, #, 1117#1121, #, 958#1123, #, 1123#1125, #, 1123#1127, #, 280#1129, #, 1129#1131, #, 1131#, 1129#1134, #, 1101#1136, #, 1136#, #, 492#1138, #, 492#1140, #, 492#1142, #, 492#1144, #, 492#1146, #972, 1150#1148, 214#, #, #1016, 1150#1152, #, #467, 1150#1155, #, 346#1159, #, 1159#, 346#1162, #, 1162#, #1168, 217#1166, #, 217#1168, #, 1168#1170, #, 280#1172, #, 1172#1174, #, 1172#1176, #, 1176#1178, #, 1178#1180, #, 1168#, 1168#1181, #1168, #1168, #, 1196#1185, #, 1196#1187, #, 1196#1189, #, 1196#1191, #, 1196#1193, 1168#1196, 1168#, #, 1202#1197, #, 1202#1199, 1168#1202, 1168#, #, 1202#1203, #, 1202#1205, #, 1202#1207, #, 1202#1209, #, 1202#1211, #, 1202#1213, #, 1202#1215, #, 1168#1217, 1168#1220, 1217#1196, #, 1217#1221, #, 1217#1223, #, 1217#1225, #, 1217#1227, #, 1217#1229, #, 1217#1231, #, 1217#1233, #, 1217#1235, 1176#1238, #, 1238#1240, #, #, 1168#1241, #, 1241#1243, #, 1241#1245, #, 1241#1247, #, 1241#1249, #, 1241#1251, #, 1241#1253, 1168#1256, 1241#1196, #, 1241#1257, #, 1168#1259, 1168#1262, 1259#1217, #, 1259#1263, #, 1259#1265, #, 1259#1267, #, 1259#1269, #, 1259#1271, #, 1259#1273, #, 1259#1275, #, 1259#1277, 280#1280, #, 1280#1282, #, 1166#1284, #, 1284#1286, #, 1284#1288, #, 1288#1290, #, 1288#1292, #, 1290#1294, #, 1290#1296, #, 1294#1298, #, 1296#1300, #, 1300#1302, #, #, #, #, 1307#1305, #, 
### 内容
#0, 16:
文档\S应用\照片测量.ftxt
## end
#1, 17:
文档\S应用\几何样本库.ftxt
## end
#2, 18:
-89.05233668945337
## end
#3, 6:
[20.0]
## end
#4, 39:
-105.04889601399111, 139.45598630037165
## end
#5, 3:
%数值
## end
#6, 17:
42.72011683558373
## end
#12, 121:
+[返回目录]
+[内容]
标记::%数值
中心::-338.8789230341691, -3.8202594274802757
半径::10
起始角度::136.10929165904932
数值::62.220685781962224

## end
#14, 775:
/*
+[返回目录](,HTML)

+[新建阅读窗口](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var pt0=[%中心];
var r=%半径;
var Dangle=%数值;
var angle0=%起始角度;
var text="%标记";

dx=1.5*r*Math.cos((angle0+Dangle)/180*Math.PI/2);
dy=1.5*r*Math.sin((angle0+Dangle)/180*Math.PI/2);


ctx.beginPath();
if(Dangle>0) {
    ctx.arc(pt0[0],pt0[1],r,angle0/180*Math.PI,(angle0+Dangle)/180*Math.PI);
} else {
    ctx.arc(pt0[0],pt0[1],r,(angle0+Dangle)/180*Math.PI,angle0/180*Math.PI);
}

ctx.strokeStyle='rgba(0,0,0)';
ctx.stroke();

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center';
ctx.textBaseline='middle';
ctx.font=8*2+'px serif';

if (text[0]==='%') {
    ctx.fillText(`${-Dangle.toFixed(2)}`,pt0[0]+dx,pt0[1]+dy);
} else {
    ctx.fillText(text,pt0[0]+dx,pt0[1]+dy);
}


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/

## end
#16, 562:
"""
+[返回目录](,画图)

输入:...
+[设置结构](,输入)

"""

pt0=中心
r=半径[0]
angle0=-起始角度[0]
Dangle=-数值[0]

dx=r*np.cos(np.deg2rad(angle0+Dangle)/2)
dy=r*np.sin(np.deg2rad(angle0+Dangle)/2)


qp.setPen(QPen(QColor(0,0,0)))
qp.setBrush(QBrush(QColor(255,255,255)))

qp.drawArc(pt0[0]-r,pt0[1]-r,2*r,2*r,angle0*16,Dangle*16)

qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",10))


if 标记=='%数值':
    qp.drawText(pt0[0]+dx,pt0[1]+dy,"%.2f"%(Dangle))
else:
    qp.drawText(pt0[0]+dx,pt0[1]+dy,str(标记))

qp.drawPoint(pt0[0]+dx,pt0[1]+dy)

qp.setFont(QFont())




## end
#18, 13:
-105.0, 136.5
## end
#20, 13:
-94.0, -528.5
## end
#22, 13:
145.0, -122.5
## end
#24, 13:
-128.0, 163.5
## end
#26, 17:
42.72011683558373
## end
#34, 14:
+[返回目录]
+[内容]

## end
#42, 62:
+[返回目录]
+[内容]
pt11::
pt12::
pt21::
pt22::
angle::
中心::
起始角度::

## end
#45, 940:
"""
+[返回目录](,P代码)

+[P函数](,P代码)

输出:...
+[设置结构](,输出)

"""

Dx1=pt11[0]-pt12[0]
Dy1=pt11[1]-pt12[1]

Dx2=pt21[0]-pt22[0]
Dy2=pt21[1]-pt22[1]

D1=pt11[0]*Dy1-pt11[1]*Dx1
D2=pt21[0]*Dy2-pt21[1]*Dx2

L=Dy1*Dx2-Dy2*Dx1
if L==0:
    pt0="None"
else:
    pt0=[(D1*Dx2-D2*Dx1)/L, (D1*Dy2-D2*Dy1)/L]
    if np.sqrt((pt0[0]-pt11[0])**2+(pt0[1]-pt11[1])**2) < np.sqrt((pt0[0]-pt12[0])**2+(pt0[1]-pt12[1])**2):
        Dx1=-Dx1
        Dy1=-Dy1
    
    if np.sqrt((pt0[0]-pt21[0])**2+(pt0[1]-pt21[1])**2) < np.sqrt((pt0[0]-pt22[0])**2+(pt0[1]-pt22[1])**2):
        Dx2=-Dx2
        Dy2=-Dy2

    sign=np.sign(Dx1*Dy2-Dx2*Dy1)
    Dtheta=np.arccos((Dx1*Dx2+Dy1*Dy2)/np.sqrt((Dx1**2+Dy1**2)*(Dx2**2+Dy2**2)))
    angle=np.rad2deg(Dtheta)*sign

    theta0=np.arccos(Dx1/np.sqrt(Dx1**2+Dy1**2))
    angle0=np.rad2deg(theta0)*np.sign(Dy1)

    print(Dy1/np.sqrt(Dx1**2+Dy1**2),theta0,angle0)

    中心=pt0
    起始角度=angle0


"""
+[P函数](,P代码)
+[设置结构](,输出)

"""
## end
#46, 2:
角度
## end
#66, 111:
+[返回目录](,角度)

数值::
中心::
半径::20
起始角度::
类型::角度

标记::%数值

画图:...
HTML:...
P代码:...
+[P函数](,P代码)



+[创建输入](标记,画图)


## end
#67, 9:
SolidLine
## end
#68, 1:
4
## end
#69, 7:
255,0,0
## end
#70, 13:
-94.0, -528.5
## end
#71, 13:
-105.0, 136.5
## end
#77, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#79, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#80, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#82, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#83, 14:
+[返回目录]
+[内容]

## end
#86, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#90, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#91, 2:
直线
## end
#92, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#93, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#99, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#109, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#110, 8:
DashLine
## end
#111, 1:
4
## end
#112, 7:
255,0,0
## end
#113, 13:
-128.0, 163.5
## end
#114, 13:
145.0, -122.5
## end
#120, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#122, 546:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*//*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;
if('%线型'==='DashLine') {
    ctx.setLineDash([5,5])
}

ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();
ctx.setLineDash([])

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#123, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#125, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#126, 14:
+[返回目录]
+[内容]

## end
#129, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#133, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#134, 2:
直线
## end
#135, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#136, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#142, 450:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    if lineType=="DashLine":
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth,Qt.DashLine))
    else:
        qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#152, 130:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::SolidLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#153, 61:
C:\Users\cheng\Dropbox\iFAST_log\resources\20210713\pic\1.jpg
## end
#154, 5:
0,0,0
## end
#155, 11:
255,255,255
## end
#156, 1:
2
## end
#157, 8:
DashLine
## end
#158, 2:
10
## end
#160, 2:
矩形
## end
#161, 36:
889.8798773515625, 667.4099080136718
## end
#162, 39:
-460.8798773515625, -277.65990801367195
## end
#172, 115:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100
地址::test1.png

## end
#173, 14:
+[返回目录]
+[内容]

## end
#176, 1178:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];
var img1=new Image();
var img=new Image();

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(%起点,%尺寸);
}

/*
if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}*/


/*
var img2 = new Image(),
        f = document.getElementById("uploadimage").files[0],
        url = window.URL || window.webkitURL,
        //src = url.createObjectURL(f);
        src=f;

    img2.src = src;
    img2.onload = function() {
        ctx.drawImage(img2, 0, 0);
        url.revokeObjectURL(src);
    }
*/



img1.onload=function() {
    ctx.drawImage(img1,%起点,%尺寸);
}
img1.src='https://img.moegirl.org.cn/common/thumb/8/86/Aj353_19.jpg/800px-Aj353_19.jpg'




//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#177, 14:
+[返回目录]
+[内容]

## end
#180, 231:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


## end
#181, 841:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""


from PyQt5.QtGui import QPixmap



pt=起点
size=尺寸
size_F=字体[0]
pic_file=地址

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


#qp.drawRect(pt[0],pt[1],size[0],size[1])

pixmap=QPixmap(pic_file)
size[1]=pixmap.height()/pixmap.width()*size[0]
qp.drawPixmap(pt[0],pt[1],size[0],size[1],pixmap)
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())


尺寸=size







## end
#182, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#185, 85:
起点::281.49455475000013, -84.73663301562507
尺寸::397.9895365000002, 241.94621603125017

## end
#190, 841:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""


from PyQt5.QtGui import QPixmap



pt=起点
size=尺寸
size_F=字体[0]
pic_file=地址

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


#qp.drawRect(pt[0],pt[1],size[0],size[1])

pixmap=QPixmap(pic_file)
size[1]=pixmap.height()/pixmap.width()*size[0]
qp.drawPixmap(pt[0],pt[1],size[0],size[1],pixmap)
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())


尺寸=size







## end
#204, 175:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10
地址::test.png

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

+[创建输入](地址,画图)

## end
#209, 87:


光栅照片:...
+[创建图片](,光栅照片)

入射光线:
光栅表面:
+[创建直线](,光栅表面)
夹角:
夹角(入射光线,光栅表面)->+[创建角度](,夹角)


## end
#213, 120:
+[返回目录](,测量角度)
地址::文档\S应用\照片测量.ftxt
+[导出结构](,测量角度)

几何画板::文档\S应用\几何样本库.ftxt
+[打开文件](+新窗口,几何画板)

画板:...
+[画板](+新窗口,画板)



## end
#214, 57:
测量角度:...
三维测量:...
创建于 20210714

节点数目统计::
+[设置结构](,节点数目统计)
## end
#217, 566:


动词:...
+[设置动词](,动词)
工具库:...
+[新建阅读窗口](,动词)
+[新建阅读窗口](,工具库)

Nini, 打开空间投影(文件)

星图::文档\S应用\星图.txt
+[打开文件](+新窗口,星图)
三维建模::文档\S应用\三维建模.ftxt
+[打开文件](+新窗口,三维建模)
文本结构::文档\S应用\文本结构.ftxt
+[打开文件](+新窗口,文本结构)
网页画板::文档\S应用\网页画板.ftxt
+[打开文件](+新窗口,网页画板)
PPT::文档\S应用\PPT.ftxt
+[打开文件](+新窗口,PPT)
空间投影::文档\数学问题\空间投影.ftxt
+[打开文件](+新窗口,空间投影)
坐标变换::文档\数学问题\三维旋转.ftxt
+[打开文件](+新窗口,坐标变换)


测试场景:...
+[新建阅读窗口](,测试场景)
Blender(P函数):...
+[描述三维场景](场景描述,Blender)->+[保存文本](,Blender)
场景描述:...
+[新建阅读窗口](,场景描述)
相机参数:...
平面投影(html):...
+[新建阅读窗口](,平面投影)
+[H函数](,平面投影)
办公室场景:...
+[新建阅读窗口](,办公室场景)




## end
#219, 13:
文档\S应用\星图.txt
## end
#221, 16:
文档\S应用\三维建模.ftxt
## end
#223, 1466:
"""
+[返回目录](,Blender)
地址::output\scene.py
+[保存文本](,Blender)

"""


import bpy
from math import pi, sin, cos
import colorsys
import mathutils

# 太阳
# Create light datablock
light_data = bpy.data.lights.new(name="my-light-data", type='SUN')
light_data.energy = 100
# Create new object, pass the light data 
light_object = bpy.data.objects.new(name="my-light", object_data=light_data)
# Link object to collection in context
bpy.context.collection.objects.link(light_object)
# Change light position
light_object.location = (0, 0, 90)


# 相机
pos=[0,-30,1.8]
P0=(0,0,0)

looking_direction = mathutils.Vector(pos) - mathutils.Vector(P0)
rot_quat = looking_direction.to_track_quat('Z', 'Y')
Camera_rte = rot_quat.to_euler()
camera_data = bpy.data.cameras.new(name='Camera')
camera_object = bpy.data.objects.new('Camera', camera_data)
bpy.context.scene.collection.objects.link(camera_object)
bpy.data.objects['Camera'].location=(pos[0],pos[1],pos[2])
bpy.data.objects['Camera'].rotation_euler=(Camera_rte[0],Camera_rte[1],Camera_rte[2])

# 楼房A
bpy.ops.mesh.primitive_cube_add()
bpy.context.selected_objects[0].name='楼房A'
pos=[20,0,0]
bpy.context.selected_objects[0].location=(pos[0],pos[1],pos[2]+60/2)
bpy.context.selected_objects[0].scale=(30/2,20/2,60/2)

# 街道
bpy.ops.mesh.primitive_plane_add(size=1)
bpy.context.selected_objects[0].name='街道'
pos=[0,0,0]
bpy.context.selected_objects[0].location=(pos[0],pos[1],pos[2])
bpy.context.selected_objects[0].scale=(10,2000,1)



## end
#226, 15:
output\scene.py
## end
#228, 806:
+[返回目录](,场景描述)
+[显示星图](,场景描述)

相机在某个位置, 看向某个位置. 
街道是一个平面, 街道宽10m, 长2000m. 中心在(0,0,0). 
街道左边有一排楼房, 全部高90m, 长20m, 宽30m. 每个楼房之间间隔1.5m. 
街道右边也有一排楼房, 全部高60m, 长20m, 宽30m. 每个楼房之间间隔1.5m. 
楼房是六面体. 

暂时不用高级描述吧. 也不要有楼房和街道之间的关联. 就算有也不要用好吧. 

相机::
相机在某个位置, 看向某个位置. 
+在(相机,+空间点)->+看向(相机,+空间点#2)
在(相机,空间点)->+[修改内容]"0,-50,3"(,空间点)
看向(相机,空间点)->+[修改内容]"0,10000,3"(,空间点)

街道是一个平面, 街道宽10m, 长2000m. 中心在(0,0,0). 
街道::
+平面(街道,)->+的(街道,+宽)->+宽"10"->+的(街道,+长)->+长"2000"...
->+的(街道,+中心)->+在(+中心,+空间点)->+空间点"0,0,0"

楼房A是立方体. 高60m, 长20m, 宽30m. 在空间点(20,0,0)的位置
楼房A::
+立方体(楼房A,)->+的(楼房A,+高)->+高"60"->+的(楼房A,+长)->+长"20"...
->+的(楼房A,+宽)->+宽"30"->+在(楼房A,+空间点)->+空间点"20,0,0"

在(相机,空间点)->+[修改内容]"0,-30,1.8"(,空间点)
看向(相机,空间点)->+[修改内容]"0,0,0"(,空间点)

+[结构转Blender](相机,+[显示])

主体::
+是(楼房A,主体)->+是(街道,主体)

+[描述三维场景](场景描述,+[显示])->+[复制内容](,+[显示])



## end
#235, 5:
0,0,0
## end
#237, 9:
0,-30,1.8
## end
#248, 5:
0,0,0
## end
#250, 4:
2000
## end
#252, 2:
10
## end
#266, 6:
20,0,0
## end
#268, 2:
30
## end
#270, 2:
20
## end
#272, 2:
60
## end
#277, 5:
0,0,0
## end
#280, 261:
+[返回目录](,动词)

结构转Blender:...
描述三维场景:...

标记多边形:...
+[复制结构](,获取标记区域)
获取标记区域:...
设置相机参数:...
拍照:...

获取三维坐标:...
二维坐标转三维坐标:...
三维坐标转二维坐标:...
三维坐标转二维坐标的"二维坐标转三维坐标"替换为"三维坐标转二维坐标"
三维坐标变换:...

直线交点:...

标记物体节点:...
显示测量场景:...
+[新建阅读窗口](,标记物体节点)

描述:...
+[新建阅读窗口](,描述)



## end
#282, 373:
"""
+[返回目录](,结构转Blender)
+[显示动词结构](,结构转Blender)
库:...

"""

+结构转Blender(_结构,_代码)->+[del](,+结构转Blender)...
->的(结构转Blender,库)->+[临时文本]->[]{
    []:->立方体(_结构,)->的(库,立方体#1)->+[做](_结构,+[临时文本])->+[code](+[做],立方体#1),
    ->平面(_结构,)->的(库,平面#1)->+[做](_结构,+[临时文本])->+[code](+[做],平面#1),
    ->[is](_结构,相机)->的(库,相机#1)->+[做](_结构,+[临时文本])->+[code](+[做],相机#1)
}->+[增加内容](+[临时文本],_代码)





## end
#284, 38:
+[返回目录](,库)


立方体:...
平面:...
相机:...



## end
#286, 16:
文档\S应用\文本结构.ftxt
## end
#288, 321:
"""
+[返回目录](,立方体)
+[显示动词结构](,立方体)

P代码:...

是([动词库],动词)->+[打开文件](+新窗口,动词)

"""
+立方体(_结构,_代码)->+[del](,+立方体)...
->的(立方体,P代码)...
->的(_结构,高)->的(_结构,长)->的(_结构,宽)->在(_结构,_位置)...
->+[标题](_结构,)...

->+[模板文本](P代码,_代码)...
->+[.](+[模板文本],+[标题])...
->+[.](+[模板文本],长)->+[.](+[模板文本],宽)->+[.](+[模板文本],高)...
->+[.]"空间点"(+[模板文本],_位置)




## end
#290, 298:
"""
+[返回目录](,平面)
+[显示动词结构](,平面)

P代码:...

是([动词库],动词)->+[打开文件](+新窗口,动词)

"""
+平面(_结构,_代码)->+[del](,+平面)...
->的(平面,P代码)...
->的(_结构,长)->的(_结构,宽)->的(_结构,中心)->在(中心,_位置)...
->+[标题](_结构,)...

->+[模板文本](P代码,_代码)...
->+[.](+[模板文本],+[标题])...
->+[.](+[模板文本],长)->+[.](+[模板文本],宽)...
->+[.]"位置"(+[模板文本],_位置)




## end
#292, 226:
"""
+[返回目录](,相机)
+[显示动词结构](,相机)

P代码:...

是([动词库],动词)->+[打开文件](+新窗口,动词)

"""
+相机(_结构,_代码)->+[del](,+相机)...
->的(相机,P代码)...
->在(_结构,_位置)->看向(_结构,_位置2)...

->+[模板文本](P代码,_代码)...
->+[.]"位置"(+[模板文本],_位置)->+[.]"目标"(+[模板文本],_位置2)




## end
#294, 223:

# %[标题]
bpy.ops.mesh.primitive_cube_add()
bpy.context.selected_objects[0].name='%[标题]'
pos=[%空间点]
bpy.context.selected_objects[0].location=(pos[0],pos[1],pos[2]+%高/2)
bpy.context.selected_objects[0].scale=(%宽/2,%长/2,%高/2)

## end
#296, 217:

# %[标题]
bpy.ops.mesh.primitive_plane_add(size=1)
bpy.context.selected_objects[0].name='%[标题]'
pos=[%位置]
bpy.context.selected_objects[0].location=(pos[0],pos[1],pos[2])
bpy.context.selected_objects[0].scale=(%宽,%长,1)

## end
#298, 489:

# 相机
pos=[%位置]
P0=(%目标)

looking_direction = mathutils.Vector(pos) - mathutils.Vector(P0)
rot_quat = looking_direction.to_track_quat('Z', 'Y')
Camera_rte = rot_quat.to_euler()
camera_data = bpy.data.cameras.new(name='Camera')
camera_object = bpy.data.objects.new('Camera', camera_data)
bpy.context.scene.collection.objects.link(camera_object)
bpy.data.objects['Camera'].location=(pos[0],pos[1],pos[2])
bpy.data.objects['Camera'].rotation_euler=(Camera_rte[0],Camera_rte[1],Camera_rte[2])

## end
#306, 324:
"""
+[返回目录](,描述三维场景)
+[显示动词结构](,描述三维场景)

P代码:...

"""
+描述三维场景(_场景,_代码)->+[del](,+描述三维场景)...
->的(描述三维场景,P代码)->+[临时文本](,)...
->[]{
    []->的(_场景,相机)->+[结构转Blender](相机,+[临时文本])...
    ->的(_场景,主体)=>是(_物体,主体)=>+[结构转Blender](_物体,+[临时文本])
}...

->+[标题](_代码,)...
->+[模板文本](P代码,_代码)...
->+[.](+[模板文本],+[标题])->+[.](+[模板文本],+[临时文本])



## end
#308, 536:
"""
+[返回目录](,%[标题])
地址::output\scene.py
+[保存文本](,%[标题])

"""


import bpy
from math import pi, sin, cos
import colorsys
import mathutils

# 太阳
# Create light datablock
light_data = bpy.data.lights.new(name="my-light-data", type='SUN')
light_data.energy = 100
# Create new object, pass the light data 
light_object = bpy.data.objects.new(name="my-light", object_data=light_data)
# Link object to collection in context
bpy.context.collection.objects.link(light_object)
# Change light position
light_object.location = (0, 0, 90)

%[临时文本]


## end
#310, 342:
+[返回目录](,相机参数)

Nini, 导入网页画板的库

OK, 基本思路是, 地平线的方向能确定相机相对轴转动的角度. 
地平线和中点的距离可以确定相机的theta角度, 也可以确定z轴的灭点. 
现在的问题是, 如何用x轴和y轴的灭点, 确定相机的phi角度. 

计算相机方向(html):...
有很大问题. 我完全没有考虑z对图象的影响. 也没有考虑到多重解的含义. 还需要花时间考虑清楚原理. 
(问题其实不大, 见下面考虑的结果)
关于重根问题:...
+[新建阅读窗口](,关于重根问题)
计算相机位置(html):...
+[新建阅读窗口](,计算相机位置)
+[H函数](,计算相机方向)
+[H函数](,计算相机位置)

计算相机参数(M函数):...


## end
#312, 7939:
<!--
+[H函数](,计算相机方向)
参考::文档\S应用\三维建模.ftxt
+[打开文件](+新窗口,参考)
的(参考,相机投影)->html(相机投影,)->+[H函数](,相机投影)
-->

<b><u>Vanishing points of a frame</u></b><br>
Let's assume the local frame of a camera is, 
$$
\begin{cases}
\mathbf{X}=
(-sin\gamma sin\alpha cos\beta + cos\gamma cos\alpha,
sin\gamma cos\alpha cos\beta + cos\gamma sin\alpha,
sin\gamma sin\beta)
\\
\mathbf{Y}=
(-cos\gamma sin\alpha cos\beta - sin\gamma cos\alpha,
cos\gamma cos\alpha cos\beta - sin\gamma sin\alpha,
cos\gamma sin\beta)
\\
\mathbf{Z}=(sin\alpha sin\beta,-cos\alpha sin\beta,cos\beta)
\end{cases}
$$

Then the directions of \(\hat{x}\), \(\hat{y}\) and \(\hat{z}\) axis in the camera local frame are, 
$$
\begin{cases}
\hat{x}=(1,0,0)
\\
\hat{y}=(0,1,0)
\\
\hat{z}=(0,0,1)
\end{cases}

\\\Rightarrow

\begin{cases}
\hat{x}'=
(
-sin\gamma sin\alpha cos\beta + cos\gamma cos\alpha,
-cos\gamma sin\alpha cos\beta - sin\gamma cos\alpha,
sin\alpha sin\beta

)
\\
\hat{y}'=
(
sin\gamma cos\alpha cos\beta + cos\gamma sin\alpha,
cos\gamma cos\alpha cos\beta - sin\gamma sin\alpha,
-cos\alpha sin\beta

)
\\
\hat{z}'=(
sin\gamma sin\beta,
cos\gamma sin\beta,
cos\beta
)
\end{cases}

$$

Then the vanishing points are, 
$$
V_x=
(
- \frac{sin\gamma\ sin\alpha\ cos\beta}{sin\alpha\ sin\beta} 
+ \frac{cos\gamma\ cos\alpha}{sin\alpha\ sin\beta},
- \frac{cos\gamma\ sin\alpha\ cos\beta}{sin\alpha\ sin\beta}
- \frac{sin\gamma\ cos\alpha}{sin\alpha\ sin\beta}
)
\\=
(
- \frac{sin\gamma}{tan\beta} 
+ \frac{cos\gamma}{tan\alpha\ sin\beta},
- \frac{cos\gamma}{tan\beta}
- \frac{sin\gamma}{tan\alpha\ sin\beta}
)
$$
$$
V_y=
(
\frac{sin\gamma\ cos\alpha\ cos\beta}{-cos\alpha\ sin\beta} 
+ \frac{cos\gamma\ sin\alpha}{-cos\alpha\ sin\beta},
\frac{cos\gamma\ cos\alpha\ cos\beta}{-cos\alpha\ sin\beta}
- \frac{sin\gamma\ sin\alpha}{-cos\alpha\ sin\beta}
)\\=
(
- \frac{sin\gamma}{tan\beta} 
- \frac{cos\gamma\ tan\alpha}{sin\beta},
- \frac{cos\gamma}{tan\beta}
+ \frac{sin\gamma\ tan\alpha}{sin\beta}
)
$$
$$
V_z
=(
\frac{sin\gamma\ sin\beta}{cos\beta},
\frac{cos\gamma\ sin\beta}{cos\beta}
)=(
sin\gamma\ tan\beta,
cos\gamma\ tan\beta
)

$$
<br><br><br><br>



<b><u>Euler angles of the camera</u></b><br>
OK, then the problem is how can we calculate the Euler angles with those vanishing points? 
That's not difficult. 
The horizontal line of the x-y plane is, 
$$
\frac{x-V_{x1}}{V_{x1}-V_{y1}}=\frac{y-V_{x2}}{V_{x2}-V_{y2}}
$$$$
(x-V_{x1})(V_{x2}-V_{y2})=(y-V_{x2})(V_{x1}-V_{y1})
$$$$
-(x+ \frac{sin\gamma}{tan\beta} 
- \frac{cos\gamma}{tan\alpha\ sin\beta}
)
\frac{sin\gamma}{sin\beta}
(
\frac{1}{tan\alpha} + tan\alpha
)=
(y+ \frac{cos\gamma}{tan\beta}
+ \frac{sin\gamma}{tan\alpha\ sin\beta}
)
\frac{cos\gamma}{sin\beta}
(\frac{1}{tan\alpha}
+ tan\alpha)
$$$$
-(x+ \frac{sin\gamma}{tan\beta} 
- \frac{cos\gamma}{tan\alpha\ sin\beta}
)sin\gamma
=
(y+ \frac{cos\gamma}{tan\beta}
+ \frac{sin\gamma}{tan\alpha\ sin\beta}
)cos\gamma
$$$$
x\ sin\gamma+
y\ cos\gamma+ \frac{1}{tan\beta}
=0
$$
As a result, once you know the vanishing points for x and y, then you know everything. <br>
That is, 
$$
\mathbf{u}=(u_1,u_2),\ 
\mathbf{v}=(v_1,v_2)
\\
Ax'+By'+C=0
\\
A=u_2-v_2,\ B=-u_1+v_1,\ C=u_1 v_2 - u_2 v_1
$$
Then, 
$$
\beta=arccot\left(
\frac{C}{\sqrt{A^2+B^2}}
\right)
$$
$$
\gamma=sign(A) arccos(\frac{B}{\sqrt{A^2+B^2}})
$$
<!--
+[H函数](,计算相机方向)
-->

The \(\alpha\) can be calculated from \(\beta\) and \(\gamma\), 
$$
v_1=
- \frac{sin\gamma}{tan\beta} 
- \frac{cos\gamma\ tan\alpha}{sin\beta}
\Rightarrow
\frac{cos\gamma\ tan\alpha}{sin\beta}
=-v_1-\frac{sin\gamma}{tan\beta} 
\\\Rightarrow
tan\alpha
=-\frac{sin\beta}{cos\gamma} v_1
-\frac{sin\beta}{cos\gamma} \frac{sin\gamma}{tan\beta} 
=-\frac{sin\beta}{cos\gamma} v_1
-tan\gamma\ cos\beta
$$
Then, \(\alpha\) is, 
$$
\alpha
=- arctan\left(
\frac{sin\beta}{cos\gamma} v_1
+tan\gamma\ cos\beta
\right)
$$
<br><br><br><br>


<b><u>Intersection of two lines</u></b><br>
If the two lines are, 
$$
\frac{x-x_1}{y-y_1}=\frac{x_2-x_1}{y_2-y_1}\equiv \frac{\Delta x}{\Delta y}
$$$$
\frac{x-x'_1}{y-y'_1}=\frac{x'_2-x'_1}{y'_2-y'_1}\equiv \frac{\Delta x'}{\Delta y'}
$$
Then the intersection is, 
$$
x_0=\frac{D \Delta x' - D' \Delta x}{\Delta y \Delta x' - \Delta y' \Delta x}
$$$$
y_0=\frac{D \Delta y' - D' \Delta y}{\Delta y \Delta x' - \Delta y' \Delta x}
$$$$
D=x_1 (y_2-y_1) - y_1 (x_2-x_1)=x_1 y_2-y_1 x_2
$$
<br><br><br>



<b><u>Re-scale problem</u></b><br>
Since a photo can be scaled by an arbitrary number, but the position of a vanishing point is the direction angle, which isn't scalable, we have to re-scale the image to the correct one at first. <br>
The photo can be re-scaled according to x-axis and y-axis vanishing points, which are perpendicular to each others.  <br>
By rotating a \(\gamma\) angle, the vanishing points are,
$$
T(-\gamma)=
\left(
\begin{matrix}
cos\gamma && -sin\gamma
\\
sin\gamma && cos\gamma
\end{matrix}
\right)
$$
$$
V_x=
\left(
\begin{matrix}
- \frac{sin\gamma}{tan\beta} 
+ \frac{cos\gamma}{tan\alpha\ sin\beta}
\\
- \frac{cos\gamma}{tan\beta}
- \frac{sin\gamma}{tan\alpha\ sin\beta}
\end{matrix}
\right)
,\ 
V_y=
\left(
\begin{matrix}
- \frac{sin\gamma}{tan\beta} 
- \frac{cos\gamma\ tan\alpha}{sin\beta}
\\
- \frac{cos\gamma}{tan\beta}
+ \frac{sin\gamma\ tan\alpha}{sin\beta}
\end{matrix}
\right)
$$

Then, 
$$
V'_x=T(-\gamma) V_x=
\left(
\begin{matrix}
- \frac{sin\gamma\ cos\gamma}{tan\beta} 
+ \frac{cos\gamma^2}{tan\alpha\ sin\beta}

+ \frac{cos\gamma\ sin\gamma}{tan\beta}
+ \frac{sin\gamma^2}{tan\alpha\ sin\beta}

\\

- \frac{sin\gamma^2}{tan\beta} 
+ \frac{cos\gamma\ sin\gamma}{tan\alpha\ sin\beta}

- \frac{cos\gamma^2}{tan\beta}
- \frac{sin\gamma\ cos\gamma}{tan\alpha\ sin\beta}
\end{matrix}
\right)
=
\left(
\begin{matrix}
\frac{1}{tan\alpha\ sin\beta}
\\
- \frac{1}{tan\beta} 
\end{matrix}
\right)
$$

$$
V'_y=T(-\gamma) V_y=
\left(
\begin{matrix}
- \frac{sin\gamma\ cos\gamma}{tan\beta} 
- \frac{cos\gamma^2\ tan\alpha}{sin\beta}
+ \frac{cos\gamma\ sin\gamma}{tan\beta}
- \frac{sin\gamma^2\ tan\alpha}{sin\beta}

\\


- \frac{sin\gamma^2}{tan\beta} 
- \frac{cos\gamma\ sin\gamma\ tan\alpha}{sin\beta}
- \frac{cos\gamma^2}{tan\beta}
+ \frac{sin\gamma\ cos\gamma\ tan\alpha}{sin\beta}
\end{matrix}
\right)
=
\left(
\begin{matrix}
- \frac{tan\alpha}{sin\beta}
\\
- \frac{1}{tan\beta} 
\end{matrix}
\right)
$$
Then we have,
$$
V'_{x1}\cdot V'_{y1}=
-\frac{1}{sin\beta^2}
$$
OK, let's assume the \(k\) is the correct scale, then we have, 
$$
\mathbf{u}=(u_1,u_2)^T,
\ 
\mathbf{v}=(v_1,v_2)^T
$$$$
\mathbf{u}'=(u_1 cos\gamma - u_2 sin\gamma, u_1 sin\gamma + u_2 cos\gamma)^T
$$$$
\mathbf{v}'=(v_1 cos\gamma - v_2 sin\gamma, v_1 sin\gamma + v_2 cos\gamma)^T
$$
Then, 
$$
\frac{1}{sin\beta^2}=-k^2 u'_1 v'_1
$$$$
\frac{1}{tan\beta}=\frac{C}{\sqrt{A^2+B^2}}
=k \frac{u'_1 v'_2-u'_2 v'_1}{\sqrt{(u'_2-v'_2)^2+(u'_1-v'_1)^2}}
$$
And,
$$
tan\beta^2=\frac{sin\beta^2}{cos\beta^2}
=\frac{sin\beta^2}{1-sin\beta^2}
=-\frac{1}{k^2 u'_1 v'_1+1}
\\
=
\frac{1}{k^2} \frac{(u'_2-v'_2)^2+(u'_1-v'_1)^2}{(u'_1 v'_2-u'_2 v'_1)^2}
$$
Finally, we have,
$$
-\frac{1}{k^2 u'_1 v'_1+1}
=
\frac{1}{k^2} \frac{(u'_2-v'_2)^2+(u'_1-v'_1)^2}{(u'_1 v'_2-u'_2 v'_1)^2}
$$
$$
\Rightarrow
\frac{k^2 u'_1 v'_1+1}{k^2}
=
-\frac{(u'_1 v'_2-u'_2 v'_1)^2}{(u'_2-v'_2)^2+(u'_1-v'_1)^2}
$$
$$
\Rightarrow
\frac{1}{k^2}
=
-u'_1 v'_1
-\frac{(u'_1 v'_2-u'_2 v'_1)^2}{(u'_2-v'_2)^2+(u'_1-v'_1)^2}
$$
Let's define,
$$
S=1/k=\sqrt{
-u'_1 v'_1
-\frac{(u'_1 v'_2-u'_2 v'_1)^2}{(u'_2-v'_2)^2+(u'_1-v'_1)^2}
}
$$


Then we have a modified Euler angles calculation, 
$$
\mathbf{u}=(u_1,u_2),\ 
\mathbf{v}=(v_1,v_2)
\\
A=u_2-v_2,\ B=-u_1+v_1,\ C=u_1 v_2 - u_2 v_1
$$$$
\gamma=sign(A) arccos(\frac{B}{\sqrt{A^2+B^2}})
$$$$
\beta=arccot\left(
\frac{k C}{\sqrt{A^2+B^2}}
\right)
$$$$
\alpha
=- arctan\left(
\frac{sin\beta}{cos\gamma} k v_1
+tan\gamma\ cos\beta
\right)
$$

<!--
+[H函数](,计算相机方向)

交点公式::文档\S应用\几何样本库.ftxt
+[打开文件](+新窗口,交点公式)
测试公式(M函数):...
+[复制内容](,测试公式)
最后的结果不对劲, 所以开始检验中间结果了. 

测试灭点公式(M函数):...
验证scale公式(M函数):...

-->
## end
#315, 16:
文档\S应用\三维建模.ftxt
## end
#317, 16:
文档\S应用\网页画板.ftxt
## end
#319, 1283:
%{
+[返回目录](,测试公式)
+[M函数](,测试公式)

参考::文档\S应用\三维建模.ftxt
+[删除结构](,参考)
+[打开文件](+新窗口,参考)
场景(M函数):...
intersection_lines(M函数):...
测试cot(M函数):...

+[M函数](,测试公式)
%}

clf
addpath('Matlab\space');

% camera
p0=[0,0,0];
r0=[4,2,3];
theta=0;
D=1;

X=[-2,-2,-2;2,2,2];
Y=[0,1,1;0,1,1];
Z=[0,0,1;0,0,1];


Eulers=camera_lookat(r0,p0,theta);
[x2,y2]=camera_click(r0,Eulers,D,X,Y,Z);
x=x2([1,2],[1,2]);
y=y2([1,2],[1,2]);

[x01,y01]=intersection_lines(x(1,:),y(1,:),x(2,:),y(2,:));
[x02,y02]=intersection_lines(x(:,1),y(:,1),x(:,2),y(:,2));
v=[x01,y01];
u=[x02,y02];

A=u(2)-v(2);
B=v(1)-u(1);
C=u(1)*v(2)-u(2)*v(1);

gamma=sign(A)*acosd(B/sqrt(A^2+B^2));
beta=90-atand(C/sqrt(A^2+B^2));
% beta=acotd(C/sqrt(A^2+B^2))+180;
alpha=-atand(sind(beta)/cosd(gamma)*v(1)+tand(gamma)*cosd(beta));

L3=3;
Eulers3=[alpha,beta,gamma]; 
r3=p0-L3*[sind(beta)*sind(alpha),-sind(beta)*cosd(alpha),cosd(beta)];
D3=1;

[x3,y3]=camera_click(r3,Eulers3,D3,X,Y,Z);

subplot(1,2,1)
hold on
show_camera(r0,Eulers,D);
hold on
show_camera(r3,Eulers3,D3);
hold on
plot3(p0(1),p0(2),p0(3),'r+')
plot3(X,Y,Z,'b-',X',Y',Z','b-')
axis equal
view([0,90])

subplot(2,2,2)
plot(x2,y2,'b-',x2',y2','b-',x,y,'r-',x',y','r-',x01,y01,'r+',x02,y02,'r+')

subplot(2,2,4)
plot(x3,y3,'b-',x3',y3','b-')

Eulers
Eulers3

%{
+[M函数](,测试公式)
%}
## end
#322, 16:
文档\S应用\三维建模.ftxt
## end
#324, 547:
%{
+[M函数](,场景)
%}

clf
addpath('Matlab\space');

% camera
p0=[0,0,0];
r0=[1,-2,1.8];
theta=0;
D=1;

X=[-2,-2,-2;2,2,2];
Y=[0,1,1;0,1,1];
Z=[0,0,1;0,0,1];


Eulers=camera_lookat(r0,p0,theta);
[x2,y2]=camera_click(r0,Eulers,D,X,Y,Z);

x=x2([1,2],[1,2]);
y=y2([1,2],[1,2]);
%{
+[M函数](,场景)
%}

% plot
subplot(1,2,1)
show_camera(r0,Eulers,D);
hold on
plot3(p0(1),p0(2),p0(3),'r+')
plot3(X,Y,Z,'b-',X',Y',Z','b-')
hold off
axis equal

subplot(1,2,2)
plot(x2,y2,'b-',x2',y2','b-',x,y,'r--',x',y','r--')
axis equal
axis([-1,1,-1,1])





%{
+[M函数](,场景)
%}
## end
#327, 17:
文档\S应用\几何样本库.ftxt
## end
#329, 398:
%{
+[返回目录](,intersection_lines)
地址::Matlab\space\intersection_lines.m
+[保存文本](,intersection_lines)
%}


function [x0,y0]=intersection_lines(L1x,L1y,L2x,L2y)
x1=L1x;
y1=L1y;
x2=L2x;
y2=L2y;
D1=x1(1).*y1(2)-x1(2).*y1(1);
D2=x2(1).*y2(2)-x2(2).*y2(1);
Dx1=x1(2)-x1(1);
Dx2=x2(2)-x2(1);
Dy1=y1(2)-y1(1);
Dy2=y2(2)-y2(1);
x0=(D1*Dx2-D2*Dx1)/(Dy1*Dx2-Dy2*Dx1);
y0=(D1*Dy2-D2*Dy1)/(Dy1*Dx2-Dy2*Dx1);
end


## end
#332, 33:
Matlab\space\intersection_lines.m
## end
#334, 1249:
%{
+[M函数](,测试灭点公式)

灭点场景(M函数):...
测试灭点(M函数):...
alpha+180(M函数):...
%}

figure
clf
addpath('Matlab\space');

% camera
p0=[-10000,-20000,-10000];
r0=[-1,-1,1];
theta=190;
D=1;

t1=linspace(0,20,10);
t2=linspace(0,200000,2);
[X1,Y1]=meshgrid(t1,t2);
Z1=zeros(size(X1));
[Y2,X2]=meshgrid(t1,t2);
Z2=zeros(size(X2));

Eulers=camera_lookat(r0,p0,theta);
[PX1,PY1]=camera_click(r0,Eulers,D,X1,Y1,Z1);
[PX2,PY2]=camera_click(r0,Eulers,D,X2,Y2,Z2);

alpha=Eulers(1);
beta=Eulers(2);
gamma=Eulers(3);

Vx=[-sind(gamma)/tand(beta)+cosd(gamma)/tand(alpha)/sind(beta),-cosd(gamma)/tand(beta)-sind(gamma)/tand(alpha)/sind(beta)];
Vy=[-sind(gamma)/tand(beta)-cosd(gamma)*tand(alpha)/sind(beta),-cosd(gamma)/tand(beta)+sind(gamma)*tand(alpha)/sind(beta)];
Vz=[sind(gamma)*tand(beta),cosd(gamma)*tand(beta)];
Ly=@(x)-tand(gamma)*x-1/tand(beta)/cosd(gamma);
x=[Vx(1),Vy(1)];



subplot(1,2,1)
hold on
show_camera(r0,Eulers,D);
hold on
plot3(X1,Y1,Z1,'b-',X2,Y2,Z2,'r-')
axis equal
axis([-5,10,-5,10,-2,5])
view([0,90])


Ly(x)
subplot(1,2,2)
plot(PX1,PY1,'b-',PX2,PY2,'r-',[Vx(1),Vy(1)],[Vx(2),Vy(2)],'r*',x,Ly(x),'r--')
% plot([Vx(1),Vy(1)],[Vx(2),Vy(2)],'r*',x,Ly(x),'r--')
hold on
plot([0,Vz(1)],[0,Vz(2)],'b-')
axis equal
axis([-1,1,-1,1])


%{
+[M函数](,测试灭点公式)
%}
## end
#337, 576:
%{
+[M函数](,测试灭点公式)

灭点场景(M函数):...
%}

clf
addpath('Matlab\space');

% camera
p0=[10000,20000,0];
r0=[-4,-2,3];
theta=0;
D=1;

t1=linspace(100,200,10);
t2=linspace(100,2000000,2);
[X1,Y1]=meshgrid(t1,t2);
Z1=zeros(size(X1));
[Y2,X2]=meshgrid(t1,t2);
Z2=zeros(size(X2));

Eulers=camera_lookat(r0,p0,theta);
[PX1,PY1]=camera_click(r0,Eulers,D,X1,Y1,Z1);
[PX2,PY2]=camera_click(r0,Eulers,D,X2,Y2,Z2);


subplot(1,2,1)
hold on
show_camera(r0,Eulers,D);
hold on
plot3(X1,Y1,Z1,'b-',X2,Y2,Z2,'r-')
view([0,90])

subplot(1,2,2)
plot(PX1,PY1,'b-',PX2,PY2,'r-')



%{
+[M函数](,测试灭点公式)
%}
## end
#340, 1082:
%{
+[M函数](,测试灭点公式)

灭点场景(M函数):...
测试灭点(M函数):...
%}

clf
addpath('Matlab\space');

% camera
p0=[-10000,20000,10000];
r0=[-1,-1,1];
theta=1;
D=1;

t1=linspace(0,20,10);
t2=linspace(0,200000,2);
[X1,Y1]=meshgrid(t1,t2);
Z1=zeros(size(X1));
[Y2,X2]=meshgrid(t1,t2);
Z2=zeros(size(X2));

Eulers=camera_lookat(r0,p0,theta);
[PX1,PY1]=camera_click(r0,Eulers,D,X1,Y1,Z1);
[PX2,PY2]=camera_click(r0,Eulers,D,X2,Y2,Z2);

alpha=Eulers(1);
beta=Eulers(2);
gamma=Eulers(3);

Vx=[-sind(gamma)/tand(beta)+cosd(gamma)/tand(alpha)/sind(beta),-cosd(gamma)/tand(beta)-sind(gamma)/tand(alpha)/sind(beta)];
Vy=[-sind(gamma)/tand(beta)-cosd(gamma)*tand(alpha)/sind(beta),-cosd(gamma)/tand(beta)+sind(gamma)*tand(alpha)/sind(beta)];
Vz=[sind(gamma)*tand(beta),cosd(gamma)*tand(beta)];



subplot(1,2,1)
hold on
show_camera(r0,Eulers,D);
hold on
plot3(X1,Y1,Z1,'b-',X2,Y2,Z2,'r-')
axis equal
axis([-10,20,-10,20,-2,10])
view([0,90])

subplot(1,2,2)
plot(PX1,PY1,'b-',PX2,PY2,'r-',[Vx(1),Vy(1)],[Vx(2),Vy(2)],'r*-')
hold on
plot([0,Vz(1)],[0,Vz(2)],'b-')
axis equal
axis([-1,1,-1,1])


%{
+[M函数](,测试灭点公式)
%}
## end
#343, 2150:
%{
+[M函数](,alpha+180)
%}

clf
addpath('Matlab\space');


t1=linspace(0,20,10);
t2=linspace(0,200000,2);
[X1,Y1]=meshgrid(t1,t2);
Z1=zeros(size(X1));
[Y2,X2]=meshgrid(t1,t2);
Z2=zeros(size(X2));

% camera
p0=[-10000,-20000,10000];
r0=[-1,-1,1];
theta=10;
D=1;

Eulers=camera_lookat(r0,p0,theta);
[PX1,PY1]=camera_click(r0,Eulers,D,X1,Y1,Z1);
[PX2,PY2]=camera_click(r0,Eulers,D,X2,Y2,Z2);

alpha=Eulers(1);
beta=Eulers(2);
gamma=Eulers(3);

Vx=[-sind(gamma)/tand(beta)+cosd(gamma)/tand(alpha)/sind(beta),-cosd(gamma)/tand(beta)-sind(gamma)/tand(alpha)/sind(beta)];
Vy=[-sind(gamma)/tand(beta)-cosd(gamma)*tand(alpha)/sind(beta),-cosd(gamma)/tand(beta)+sind(gamma)*tand(alpha)/sind(beta)];
Vz=[sind(gamma)*tand(beta),cosd(gamma)*tand(beta)];
Ly=@(x)-tand(gamma)*x-1/tand(beta);
x=[Vx(1),Vy(1)];



subplot(2,2,1)
hold on
show_camera(r0,Eulers,D);
hold on
plot3(X1,Y1,Z1,'b-',X2,Y2,Z2,'r-')
axis equal
axis([-5,10,-5,10,-2,5])
view([0,90])

subplot(2,2,2)
plot(PX1,PY1,'b-',PX2,PY2,'r-',[Vx(1),Vy(1)],[Vx(2),Vy(2)],'r*',x,Ly(x),'r--')
% plot([Vx(1),Vy(1)],[Vx(2),Vy(2)],'r*',x,Ly(x),'r--')
hold on
plot([0,Vz(1)],[0,Vz(2)],'b-')
axis equal
axis([-1,1,-1,1])


% camera, alpha+180
p0=[10000,20000,10000];
r0=[-1,-1,1];
theta=10;
D=1;

Eulers=camera_lookat(r0,p0,theta);
[PX1,PY1]=camera_click(r0,Eulers,D,X1,Y1,Z1);
[PX2,PY2]=camera_click(r0,Eulers,D,X2,Y2,Z2);

alpha=Eulers(1);
beta=Eulers(2);
gamma=Eulers(3);

Vx=[-sind(gamma)/tand(beta)+cosd(gamma)/tand(alpha)/sind(beta),-cosd(gamma)/tand(beta)-sind(gamma)/tand(alpha)/sind(beta)];
Vy=[-sind(gamma)/tand(beta)-cosd(gamma)*tand(alpha)/sind(beta),-cosd(gamma)/tand(beta)+sind(gamma)*tand(alpha)/sind(beta)];
Vz=[sind(gamma)*tand(beta),cosd(gamma)*tand(beta)];
Ly=@(x)-tand(gamma)*x-1/tand(beta);
x=[Vx(1),Vy(1)];



subplot(2,2,3)
hold on
show_camera(r0,Eulers,D);
hold on
plot3(X1,Y1,Z1,'b-',X2,Y2,Z2,'r-')
axis equal
axis([-5,10,-5,10,-2,5])
view([0,90])

subplot(2,2,4)
plot(PX1,PY1,'b-',PX2,PY2,'r-',[Vx(1),Vy(1)],[Vx(2),Vy(2)],'r*',x,Ly(x),'r--')
% plot([Vx(1),Vy(1)],[Vx(2),Vy(2)],'r*',x,Ly(x),'r--')
hold on
plot([0,Vz(1)],[0,Vz(2)],'b-')
axis equal
axis([-1,1,-1,1])


%{
+[M函数](,alpha+180)
%}
## end
#346, 773:
%{
+[返回目录](,测试公式)
+[M函数](,测试公式)

参考::文档\S应用\三维建模.ftxt
+[删除结构](,参考)
+[打开文件](+新窗口,参考)
场景(M函数):...
intersection_lines(M函数):...

+[M函数](,测试公式)
%}

figure
clf
addpath('Matlab\space');

% camera
p0=[0,0,0];
r0=[-4,-2,3];
theta=0;
D=1;

k=123

X=[-2,-2,-2;2,2,2];
Y=[0,1,1;0,1,1];
Z=[0,0,1;0,0,1];


Eulers=camera_lookat(r0,p0,theta);
[x2,y2]=camera_click(r0,Eulers,D,X,Y,Z);
x=x2([1,2],[1,2])*k;
y=y2([1,2],[1,2])*k;

[x01,y01]=intersection_lines(x,y);
[x02,y02]=intersection_lines(x',y');
u=[x01,y01]';
v=[x02,y02]';

A=u(2)-v(2);
B=v(1)-u(1);
C=u(1)*v(2)-u(2)*v(1);

gamma=sign(A)*acosd(B/sqrt(A^2+B^2));
T=[cosd(gamma),-sind(gamma);sind(gamma),cosd(gamma)];
u1=T*u;
v1=T*v;

k2=-u1(1)*v1(1)-(u1(1)*v1(2)-u1(2)*v1(1))^2/(sum((u1-v1).^2));
k0=sqrt(k2);

%{
+[M函数](,验证scale公式)
%}
## end
#349, 865:
今天先解决三维测量的问题. 
灭点公式应该是完全没有问题的. 接下来可以测试一下灭线的公式. 灭线也没有问题... 
神奇, 所以, alpha+180的话, 投影的图象确实不一样了, 但是灭点和灭线都还在原来的位置上. 
然后, beta+180是不存在的, beta+180等价于alpha+180, 180-beta

很好, 灭线的公式出问题了! 灭点不变. 又没问题了, 是我的问题... 
然后关于这个多值问题其实是不存在的, 因为alpha和beta都只应该取0到180之间的值... (不对)
(但是, 怎么体现相机看不到自己背后的图象这件事情呢? )
多值问题是这样的, beta只会在0和180之间取值, alpha则是, 只用灭点确实无法区分是0还是180. 所以是有两重重根的问题, 而不是四个. 
这两个重根是可以通过给定x轴和y轴的方向来确定的. 

然后, 这个公式确实还没完, 我需要解决一下方向空间的scale的问题. 然后, 公式应该是没有问题的, 但是输入的信息不够. 
灭点我需要标记上是x还是y, 是正灭点还是负灭点. 以及参考长度的端点位置, 以及其实际所处的平面. 

所以, 现在我缺少的是, 从照片上面的位置变换到实际空间坐标的变换公式. 
OK, 所以计算相机的位置也非常重要. 计算的过程是: 
1.将给定的两点坐标写成z的表达式, z是其三维坐标中唯一的未知量; 
2.利用两点构成的直线的方向, 写出z1和z2之间的关系; 
3.利用两点间的距离, 计算出z1的具体数值; 
4.用欧拉角计算出直角坐标系的方向(在相机坐标系中), 然后把相机和原点的方向矢量投影到直角坐标系中即可. 

在有了相机位置和方向之后, 还需要把相片上的坐标转换成三维空间中的坐标. 注意一下, 这个问题是一个逆向问题, 需要额外的约束条件才能获得解. 对于任意类型的约束条件, 解不一定唯一, 也不一定是解析的. 所以, 先就做两个最简单的情况: 设定高度的水平平面, 设定落点的竖直方向. 
## end
#351, 2533:
<!--
+[H函数](,计算相机位置)
-->

<b><u>Position of camera</u></b><br>
After calculating the direction of the camera, we can get the location of the camera in the frame marked in the photo in the follow steps:<br>
1.Write the positions of given points in the camera frame, 
$$
\mathbf{p}_1=(x_1, y_1, 1) t_1
\\
\mathbf{p}_2=(x_2, y_2, 1) t_2
$$
2.The direction of the line passing through the two points is determined by the vanishing point. That direction makes a constraint relation for \(t_1\) and \(t_2\),
$$
\mathbf{v} t=\mathbf{p}_1-\mathbf{p}_2
\Rightarrow
\begin{cases}
v_x t=x_1 t_1 -x_2 t_2,
\\
v_y t=y_1 t_1 -y_2 t_2,
\\
v_z t=t_1 -t_2
\end{cases}
$$
The vanishing point is \(\mathbf{u}=(u_1,u_2)\), then,
$$
u_1=v_x/v_z
=\frac{x_1 t_1 -x_2 t_2}{t_1-t_2}
$$$$
\Rightarrow
(u_1-x_1) t_1=(u_1-x_2) t_2

\Rightarrow
t_1=\frac{u_1-x_2}{u_1-x_1} t_2
$$

Since \(\mathbf{p}_1\), \(\mathbf{p}_2\) and \(\mathbf{u}\) are in the same line, then, 
$$
t_1=\frac{u_1-x_2}{u_1-x_1} t_2
=\frac{u_2-y_2}{u_2-y_1} t_2
$$
3. The distance between \(\mathbf{p}_1\) and \(\mathbf{p}_2\) is assumed to be \(L\), then, 
$$
L=\sqrt{
(x_1 t_1 - x_2 t_2)^2+(y_1 t_1 - y_2 t_2)^2
+(t_1 - t_2)^2
}
\\
=t_2 \sqrt{
(x_1\frac{u_1-x_2}{u_1-x_1}  - x_2)^2
+(y_1\frac{u_2-y_2}{u_2-y_1} - y_2)^2
+(\frac{u_1-x_2}{u_1-x_1} - 1)^2
}
\\
=t_2 \sqrt{
(\frac{u_1 x_1-u_1 x_2}{u_1-x_1})^2
+(\frac{u_2 y_1-u_2 y_2}{u_2-y_1})^2
+(\frac{x_1-x_2}{u_1-x_1})^2
}
\\
=t_2 \sqrt{
u_1^2 (\frac{x_1-x_2}{u_1-x_1})^2
+u_2^2 (\frac{y_1-y_2}{u_2-y_1})^2
+(\frac{x_1-x_2}{u_1-x_1})^2
}
\\
=t_2 \frac{x_1-x_2}{u_1-x_1} \sqrt{
u_1^2+u_2^2+1
}
$$
As a result,
$$
t_1=\frac{u_1-x_2}{x_1-x_2}
\frac{L}{\sqrt{u_1^2+u_2^2+1}}
$$$$
t_2=\frac{u_1-x_1}{x_1-x_2}
\frac{L}{\sqrt{u_1^2+u_2^2+1}}
$$

4.The position of \(\mathbf{p}_1\) in the camera frame is also the displacement from the camera to that point. The displacement vector of the camera is \(\mathbf{r}=-\mathbf{p}_1\). The unit vector of the local frame axis is, 
$$
\begin{cases}
\hat{x}'=
(
-sin\gamma sin\alpha cos\beta + cos\gamma cos\alpha,
-cos\gamma sin\alpha cos\beta - sin\gamma cos\alpha,
sin\alpha sin\beta

)
\\
\hat{y}'=
(
sin\gamma cos\alpha cos\beta + cos\gamma sin\alpha,
cos\gamma cos\alpha cos\beta - sin\gamma sin\alpha,
-cos\alpha sin\beta

)
\\
\hat{z}'=(
sin\gamma sin\beta,
cos\gamma sin\beta,
cos\beta
)
\end{cases}
$$
Then, the position of the camera in the local frame is, 
$$
\vec{r}=(
\mathbf{r}\cdot \hat{x}',
\mathbf{r}\cdot \hat{y}',
\mathbf{r}\cdot \hat{z}'
)
$$

<!--
+[H函数](,计算相机位置)

测试公式(M函数):...
-->
## end
#354, 1612:
%{
+[返回目录](,测试公式)
+[M函数](,测试公式)
%}

clf
addpath('Matlab\space');

% camera
p0=[-1,0,0];
r0=[4,2,3];
theta=0;
D=20;

X=[0,0,0;2,2,2];
Y=[0,1,1;0,1,1];
Z=[0,0,1;0,0,1];


Eulers=camera_lookat(r0,p0,theta);
[x2,y2]=camera_click(r0,Eulers,D,X,Y,Z);
x=x2([1,2],[1,2]);
y=y2([1,2],[1,2]);

[x01,y01]=intersection_lines(x(1,:),y(1,:),x(2,:),y(2,:));
[x02,y02]=intersection_lines(x(:,1),y(:,1),x(:,2),y(:,2));
v=[x01,y01];
u=[x02,y02];

A=u(2)-v(2);
B=v(1)-u(1);
C=u(1)*v(2)-u(2)*v(1);

gamma=sign(A)*acosd(B/sqrt(A^2+B^2));
T=[cosd(gamma),-sind(gamma);sind(gamma),cosd(gamma)];
u1=T*u';
v1=T*v';

k2=-u1(1)*v1(1)-(u1(1)*v1(2)-u1(2)*v1(1))^2/(sum((u1-v1).^2));
k0=sqrt(k2)

beta=90-atand(C/sqrt(A^2+B^2));
% beta=acotd(C/sqrt(A^2+B^2))+180;
alpha=-atand(sind(beta)/cosd(gamma)*v(1)+tand(gamma)*cosd(beta));
Eulers1=[alpha,beta,gamma];

L=sqrt((X(1,1)-X(1,2))^2+(Y(1,1)-Y(1,2))^2+(Z(1,1)-Z(1,2))^2);
t1=(v(1)-x(1,2))/(x(1,1)-x(1,2))*L/sqrt(v(1)^2+v(2)^2+1);
r1=-[x(1,1),y(1,1),1]*t1;




%{
+[M函数](,测试公式)
%}

xhat=[
-sind(gamma)*sind(alpha)*cosd(beta)+cosd(gamma)*cosd(alpha),
-cosd(gamma)*sind(alpha)*cosd(beta)-sind(gamma)*cosd(alpha),
sind(alpha)*sind(beta)]';

yhat=[
sind(gamma)*cosd(alpha)*cosd(beta)+cosd(gamma)*sind(alpha),
cosd(gamma)*cosd(alpha)*cosd(beta)-sind(gamma)*sind(alpha),
-cosd(alpha)*sind(beta)]';

zhat=[
sind(gamma)*sind(beta),
cosd(gamma)*sind(beta),
cosd(beta)]';

r01=[r1*xhat',r1*yhat',r1*zhat'];

hold on
show_camera(r0,Eulers,D);
hold on
show_camera(r01,Eulers1,1);
hold on
plot3(p0(1),p0(2),p0(3),'r+')
plot3(X,Y,Z,'b-',X',Y',Z','b-')
axis equal
view([0,90])

r0./r01
t1

%{
+[M函数](,测试公式)
%}
## end
#357, 110:
%{
+[M函数](,测试cot)
%}

clf
x=linspace(-180,180,10000);
y1=acotd(x);
y2=atand(x);
y3=90-y2;
plot(x,y1,x,y3)





## end
#360, 593:
+[返回目录](,办公室场景)
+[显示星图](,办公室场景)
+相片
+相机(,相片)
+拍摄(相机,办公室场景)

相片:...
+[画板](+新画板,相片)
+[新建阅读窗口](,相片)

相机在某个位置, 朝着某个方向. 
+在(相机,+空间点)->+朝着(相机,+方向)

的(相片,自由四边形)->的(自由四边形,设置形状)->+mouseMove(新画板,设置形状)
+[del](,mouseMove)

将相片的自由多边形的X和Y坐标作为输入, 计算相机参数. 
的(相片,自由四边形)->的(自由四边形,X坐标)->的(自由四边形,Y坐标)...
->的(相片,图片)->的(图片,起点)->的(图片,尺寸)...
->在(相机,空间点)->朝着(相机,方向)...
->+[matlab](Matlab,)->+[code](+[matlab],计算相机参数)...
->+[.]"x"(+[matlab],X坐标)->+[.]"y"(+[matlab],Y坐标)...
->+[.]"pt"(+[matlab],起点)->+[.]"size"(+[matlab],尺寸)...
->+[o]"Eulers"(+[matlab],方向)->+[o]"r0"(+[matlab],空间点)
计算相机参数(M函数):...
+[新建阅读窗口](,计算相机参数)




## end
#362, 67:
+[返回目录](,相片)

有图片
+[创建图片](,+图片)
图片:...
图片有什么
图片的地址是什么
自由四边形:...




## end
#368, 197:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10
地址::test.png
+[显示](,地址)
+[记住](,地址)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

+[创建输入](地址,画图)

## end
#382, 1518:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""


from PyQt5.QtGui import QPixmap



pt=起点
size=尺寸
size_F=字体[0]
pic_file=地址

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


#qp.drawRect(pt[0],pt[1],size[0],size[1])

pixmap=QPixmap(pic_file)
size[1]=pixmap.height()/pixmap.width()*size[0]
qp.drawPixmap(pt[0],pt[1],size[0],size[1],pixmap)
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())


尺寸=size






"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#387, 85:
起点::281.49455475000013, -84.73663301562507
尺寸::397.9895365000002, 241.94621603125017

## end
#390, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#391, 841:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""


from PyQt5.QtGui import QPixmap



pt=起点
size=尺寸
size_F=字体[0]
pic_file=地址

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


#qp.drawRect(pt[0],pt[1],size[0],size[1])

pixmap=QPixmap(pic_file)
size[1]=pixmap.height()/pixmap.width()*size[0]
qp.drawPixmap(pt[0],pt[1],size[0],size[1],pixmap)
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())


尺寸=size







## end
#392, 231:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


## end
#395, 14:
+[返回目录]
+[内容]

## end
#396, 1178:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];
var img1=new Image();
var img=new Image();

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(%起点,%尺寸);
}

/*
if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}*/


/*
var img2 = new Image(),
        f = document.getElementById("uploadimage").files[0],
        url = window.URL || window.webkitURL,
        //src = url.createObjectURL(f);
        src=f;

    img2.src = src;
    img2.onload = function() {
        ctx.drawImage(img2, 0, 0);
        url.revokeObjectURL(src);
    }
*/



img1.onload=function() {
    ctx.drawImage(img1,%起点,%尺寸);
}
img1.src='https://img.moegirl.org.cn/common/thumb/8/86/Aj353_19.jpg/800px-Aj353_19.jpg'




//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#399, 14:
+[返回目录]
+[内容]

## end
#400, 115:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100
地址::test1.png

## end
#410, 22:
-1050.8023, -725.84235
## end
#411, 14:
2000.0, 1500.0
## end
#412, 2:
矩形
## end
#414, 2:
10
## end
#415, 8:
DashLine
## end
#416, 1:
2
## end
#417, 11:
255,255,255
## end
#418, 5:
0,0,0
## end
#419, 11:
input/1.jpg
## end
#420, 1:
1
## end
#422, 10:
1920, 1001
## end
#424, 12:
150.0, 200.0
## end
#431, 58:
-28.138933678750668, 74.85531804948387, 0.5529739200987372
## end
#433, 59:
-2.3101135313042476, -4.906578102317954, 1.4653443679673157
## end
#436, 169:
+[返回目录](,自由四边形)


X坐标::-1100,100,2000,200
Y坐标::100,0,0,100

画图(P函数):...
+[创建函数](,画图)
+[创建输入](X坐标,画图)
+[创建输入](Y坐标,画图)

设置形状_P(P函数):...
设置形状(S函数):...
+[有](设置形状,设置形状_P)




## end
#439, 76:
13.975905852500063, 100.78181190749109, 829.5469001907768, 861.0021499363303
## end
#441, 78:
23.403400986067027, -24.214512511788683, 52.06346956112057, 130.45718654582592
## end
#443, 580:
"""
+[P函数](,画图)

"""

x=X坐标
y=Y坐标

面颜色=[255,255,255]
线颜色=[255,255,255]


if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2],100)))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))



x.append(x[0])
y.append(y[0])

path=QPainterPath()
for i in range(len(x)):
    if i==0:
        path.moveTo(x[i],y[i])
    else:
        path.lineTo(x[i],y[i])


qp.drawPath(path)
qp.setBrush(QBrush())
qp.setPen(QPen())


## end
#445, 14:
+[返回目录]
+[内容]

## end
#447, 56:
+[返回目录]
+[内容]
X坐标::1,1,2,2;0,0,1,1
Y坐标::0,0,1,1;1,1,2,2

## end
#451, 164:
"""
+[返回目录](,设置形状)

"""

+设置形状(_画板,)->+[del](,+设置形状)...
->的(设置形状,设置形状_P)...
->的(_画板,m_mouse)->+[python](Python,)->+[.]"m"(+[python],m_mouse)...
->+[P函数](,设置形状_P)



## end
#454, 240:
"""
+[P函数](,设置形状_P)

输出:...

"""

x=X坐标
y=Y坐标

i_min=None
R_min=200
for i in range(4):
    R=np.sqrt((m[0]-x[i])**2+(m[1]-y[i])**2)
    if R<R_min:
        R_min=R
        i_min=i

if i_min!=None:
    X坐标[i_min]=m[0]
    Y坐标[i_min]=m[1]




## end
#457, 55:
+[返回目录]
+[内容]
X坐标::-1100,100,2000,200
Y坐标::100,0,0,100

## end
#459, 14:
+[返回目录]
+[内容]

## end
#464, 750:
%{
+[返回目录](,计算相机参数)
+[M函数](,计算相机参数)

camera_from_photo(M函数):...
+[新建阅读窗口](,camera_from_photo)
%}

clf
addpath('Matlab\space');

% camera
p0=[-1,0,0];
r0=[4,2,3];
theta=0;
D=20;

X=[0,0,0;2,2,2];
Y=[0,1,1;0,1,1];
Z=[0,0,1;0,0,1];


Eulers=camera_lookat(r0,p0,theta);
[x2,y2]=camera_click(r0,Eulers,D,X,Y,Z);
% x=reshape(x2([1,2],[1,2]),1,4)
% y=reshape(y2([1,2],[1,2]),1,4)
x=[x2(1,1),x2(1,2),x2(2,2),x2(2,1)];
y=[y2(1,1),y2(1,2),y2(2,2),y2(2,1)];
L=sqrt((X(1,1)-X(1,2))^2+(Y(1,1)-Y(1,2))^2+(Z(1,1)-Z(1,2))^2);

[Eulers1,r01,S]=camera_from_photo(x,y,L);

hold on
show_camera(r0,Eulers,D);
hold on
show_camera(r01,Eulers1,1);
hold on
plot3(p0(1),p0(2),p0(3),'r+')
plot3(X,Y,Z,'b-',X',Y',Z','b-')
axis equal
view([0,90])

r0./r01;

%{
+[M函数](,计算相机参数)
%}
## end
#467, 1491:
%{
地址::Matlab\space\camera_from_photo.m
+[保存M函数](,camera_from_photo)

测试代码(M函数):...
%}

function [Eulers,r0,S]=camera_from_photo(x,y,L,type)

%L=1;
%x=[1.3875   -2.2156    1.0902    5.9724];
%y=[-1.6881   -2.5159   -9.0195   -7.2663];

%if type~=1
%x=[x(4),x(1),x(2),x(3)];
%y=[y(4),y(1),y(2),y(3)];
%end
if length(x)==4
    x(5)=x(1);
end
if length(y)==4
    y(5)=y(1);
end

[x01,y01]=intersection_lines(x([1,2]),y([1,2]),x([4,3]),y([4,3]));
[x02,y02]=intersection_lines(x([4,5]),y([4,5]),x([2,3]),y([2,3]));

v=[x01,y01];
u=[x02,y02];

A=u(2)-v(2);
B=v(1)-u(1);
C=u(1)*v(2)-u(2)*v(1);

gamma=sign(A)*acosd(B/sqrt(A^2+B^2));
T=[cosd(gamma),-sind(gamma);sind(gamma),cosd(gamma)];
u1=T*u';
v1=T*v';

S2=-u1(1)*v1(1)-(u1(1)*v1(2)-u1(2)*v1(1))^2/(sum((u1-v1).^2));
S=sqrt(S2);

beta=90-atand(C/S/sqrt(A^2+B^2));
% beta=acotd(C/sqrt(A^2+B^2))+180;
alpha=-atand(sind(beta)/cosd(gamma)*v(1)/S+tand(gamma)*cosd(beta));
Eulers=[alpha,beta,gamma];

t1=(v(1)-x(1,2))/(x(1,1)-x(1,2))*L/sqrt(v(1)^2/S^2+v(2)^2/S^2+1);
r1=-[x(1,1)/S,y(1,1)/S,1]*t1;



xhat=[
-sind(gamma)*sind(alpha)*cosd(beta)+cosd(gamma)*cosd(alpha),
-cosd(gamma)*sind(alpha)*cosd(beta)-sind(gamma)*cosd(alpha),
sind(alpha)*sind(beta)]';

yhat=[
sind(gamma)*cosd(alpha)*cosd(beta)+cosd(gamma)*sind(alpha),
cosd(gamma)*cosd(alpha)*cosd(beta)-sind(gamma)*sind(alpha),
-cosd(alpha)*sind(beta)]';

zhat=[
sind(gamma)*sind(beta),
cosd(gamma)*sind(beta),
cosd(beta)]';

r0=[r1*xhat',r1*yhat',r1*zhat'];

%Eulers,r0,S
end

%{
+[M函数](,测试公式)
%}
## end
#470, 32:
Matlab\space\camera_from_photo.m
## end
#472, 261:
%{
+[M函数](,计算相机参数)
%}

addpath('Matlab/space')
addpath('Matlab/draw')

center=pt+size/2;
x=x-center(1);
y=y-center(2);
[Eulers,r0,S]=camera_from_photo(x,y,1)

clf
show_camera(r0,Eulers,-1);
hold on
patch([0,0,1,1],[0,1,1,0],zeros(1,4))
axis equal
view([0,90])


## end
#475, 4471:
<!--
+[H函数](,平面投影)
-->

<b><u>Coordinates of points on a plane</u></b><br>
If the origin, \(\vec{r}_0\), \(\hat{x}\) and \(\hat{y}\) are, 
$$
\vec{r}_0=(x_0,y_0,z_0),\ 
\hat{x}=(u_1,u_2,u_3),\ 
\hat{y}=(v_1,v_2,v_3)
$$
Then the coordinates are, 
$$
\vec{r}=\vec{r}_0+a\ \hat{x}+b\ \hat{y}
$$
Or,
$$
\begin{cases}
x=x_0+a\ u_1+b\ v_1
\\
y=y_0+a\ u_2+b\ v_2
\\
z=z_0+a\ u_3+b\ v_3
\end{cases}
$$
<br><br>
<b><u>Projection on a camera</u></b><br>
The parameters for camera are: the pointing (\(\alpha, \beta, \gamma\)), the position (\(r_1=(x_1, y_1, z_1)\)) and the photo distance (\(D\)). <br>
The projection algorithm is very simple by two steps: <br>
<br>
1.Calculate the local coordinate of the objects. <br>
The axis for the local frame is, 
$$
\begin{cases}
\mathbf{X}=
(-sin\gamma sin\alpha cos\beta + cos\gamma cos\alpha,
sin\gamma cos\alpha cos\beta + cos\gamma sin\alpha,
sin\gamma sin\beta)
\\
\mathbf{Y}=
(-cos\gamma sin\alpha cos\beta - sin\gamma cos\alpha,
cos\gamma cos\alpha cos\beta - sin\gamma sin\alpha,
cos\gamma sin\beta)
\\
\mathbf{Z}=(sin\alpha sin\beta,-cos\alpha sin\beta,cos\beta)
\end{cases}
$$

The coordinate of points will be transformed,
$$
x_1=(\vec{r}-\vec{r}_1)\cdot \mathbf{X}
=(\vec{r}_0-\vec{r}_1+a\ \hat{x}+b\ \hat{y})\cdot \mathbf{X}
\\
=(\Delta\vec{r}\cdot \mathbf{X})+a\ (\hat{x}\cdot \mathbf{X})
+b\ (\hat{y}\cdot \mathbf{X})
$$
And others,
$$
\begin{cases}
x_1=(\Delta\vec{r}\cdot \mathbf{X})+a\ (\hat{x}\cdot \mathbf{X})
+b\ (\hat{y}\cdot \mathbf{X})
\\
y_1=(\Delta\vec{r}\cdot \mathbf{Y})+a\ (\hat{x}\cdot \mathbf{Y})
+b\ (\hat{y}\cdot \mathbf{Y})
\\
z_1=(\Delta\vec{r}\cdot \mathbf{Z})+a\ (\hat{x}\cdot \mathbf{Z})
+b\ (\hat{y}\cdot \mathbf{Z})
\\
\end{cases}
$$


<!--
+[H函数](,平面投影)
-->



<br>
2.Project points onto the photo. <br>
$$
\begin{cases}
x_2
=D \frac{(\Delta\vec{r}\cdot \mathbf{X})+a\ (\hat{x}\cdot \mathbf{X})
+b\ (\hat{y}\cdot \mathbf{X})}
{(\Delta\vec{r}\cdot \mathbf{Z})+a\ (\hat{x}\cdot \mathbf{Z})
+b\ (\hat{y}\cdot \mathbf{Z})}
\\
y_2=D \frac{(\Delta\vec{r}\cdot \mathbf{Y})+a\ (\hat{x}\cdot \mathbf{Y})
+b\ (\hat{y}\cdot \mathbf{Y})}
{(\Delta\vec{r}\cdot \mathbf{Z})+a\ (\hat{x}\cdot \mathbf{Z})
+b\ (\hat{y}\cdot \mathbf{Z})}
\end{cases}
$$

$$
\Rightarrow
\begin{cases}
x_2[
{(\Delta\vec{r}\cdot \mathbf{Z})+a\ (\hat{x}\cdot \mathbf{Z})
+b\ (\hat{y}\cdot \mathbf{Z})}
]
=D[
(\Delta\vec{r}\cdot \mathbf{X})+a\ (\hat{x}\cdot \mathbf{X})
+b\ (\hat{y}\cdot \mathbf{X})]

\\
y_2[
(\Delta\vec{r}\cdot \mathbf{Z})+a\ (\hat{x}\cdot \mathbf{Z})
+b\ (\hat{y}\cdot \mathbf{Z})]
=D[
(\Delta\vec{r}\cdot \mathbf{Y})+a\ (\hat{x}\cdot \mathbf{Y})
+b\ (\hat{y}\cdot \mathbf{Y})]
\end{cases}
$$

$$
\Rightarrow
\begin{cases}

a[x_2 (\hat{x}\cdot \mathbf{Z})-D (\hat{x}\cdot \mathbf{X})]
+b[x_2 (\hat{y}\cdot \mathbf{Z})-D (\hat{y}\cdot \mathbf{X})]
=D(\Delta\vec{r}\cdot \mathbf{X})-x_2(\Delta\vec{r}\cdot \mathbf{Z})

\\

a[y_2 (\hat{x}\cdot \mathbf{Z})-D (\hat{x}\cdot \mathbf{Y})]
+b[y_2 (\hat{y}\cdot \mathbf{Z})-D (\hat{y}\cdot \mathbf{Y})]
=D(\Delta\vec{r}\cdot \mathbf{Y})-y_2(\Delta\vec{r}\cdot \mathbf{Z})

\end{cases}
$$

Or, equivalently we will have, 
$$
\left(
\begin{matrix}
A & B
\\
C & D
\end{matrix}
\right)

\left(
\begin{matrix}
a
\\
b
\end{matrix}
\right)
=

\left(
\begin{matrix}
V_x
\\
V_y
\end{matrix}
\right)
$$
$$
\left(
\begin{matrix}
a
\\
b
\end{matrix}
\right)
=
\frac{1}{AD-BC}
\left(
\begin{matrix}
D & -B
\\
-C & A
\end{matrix}
\right)

\left(
\begin{matrix}
V_x
\\
V_y
\end{matrix}
\right)
$$
<!--
+[H函数](,平面投影)
-->

With equations, 
$$
\begin{cases}
A=x_2 (\hat{x}\cdot \mathbf{Z})-D (\hat{x}\cdot \mathbf{X})
\\
B=x_2 (\hat{y}\cdot \mathbf{Z})-D (\hat{y}\cdot \mathbf{X})
\\
C=y_2 (\hat{x}\cdot \mathbf{Z})-D (\hat{x}\cdot \mathbf{Y})
\\
D=y_2 (\hat{y}\cdot \mathbf{Z})-D (\hat{y}\cdot \mathbf{Y})
\\
V_x=D(\Delta\vec{r}\cdot \mathbf{X})-x_2(\Delta\vec{r}\cdot \mathbf{Z})
\\
V_y=D(\Delta\vec{r}\cdot \mathbf{Y})-y_2(\Delta\vec{r}\cdot \mathbf{Z})
\end{cases}
$$



<!--
是指, 给定相机的欧拉角, 位置和尺寸, 以及约束平面的位置和单位向量, 计算给定点对应的三维坐标. 
计算投影(M函数):...
+[M函数](,计算投影)

测试场景:...
测试场景的"\"(测试场景,)"替换为"."
相片场景:...
相片场景的"\"(相片场景,)"替换为"."
+[新建阅读窗口](,测试场景)
+[新建阅读窗口](,相片场景)
+[显示PPT场景]"3"(,相片场景)
+[显示三维场景]"4"(,测试场景)

+[回答]"的(相片场景,A)->的(相片场景,B)->的(相片场景,C)->的(相片场景,D)...
->的(相片场景,相片)->的(测试场景,相机)...
->:<描述\"以四边形(A,B,C,D)作为相片中的参考平面, 设置相机参数\">"(平面投影,)

+[回答]"的(相片场景,相片)->的(测试场景,相机)...
=>的(测试场景,_桌子1)->的(_桌子1,X)...
->的(相片场景,_桌子1#1)->[eq](_桌子1,_桌子1#1)...
=>:<描述\"相机拍摄_桌子1, 显示为相片上的_桌子1#1\">"(平面投影,)


+[H函数](,平面投影)
-->
## end
#478, 351:
%{
+[M函数](,计算投影)
Euler_frame:...
camera_To_3D:...
%}

addpath('Matlab\space')

r1=[-2.907704081479481, -6.024253426461256, -1.139908100021243];
Eulers=[-27.73232875275092, 50.64828866565346, -0.30776320780374067];
D=1;

r0=[0,0,0];
ux=[1,0,0];
uy=[0,1,0];

x2=[1,2,3];
y2=[1,2,3];

[x,y,z]=camera_To_3D(x2,y2,r1,Eulers,D,r0,ux,uy)

%{
+[M函数](,计算投影)
%}
## end
#481, 561:
%{
+[M函数](,Euler_frame)
地址::Matlab\space\Euler_frame.m
+[保存文本](,Euler_frame)
%}


function [X,Y,Z]=Euler_frame(alpha,beta,gamma)


% Dr=[1,1,1];
% alpha=45;
% beta=45;
% gamma=0; 


X=[
-sind(gamma)*sind(alpha)*cosd(beta)+cosd(gamma)*cosd(alpha),
sind(gamma)*cosd(alpha)*cosd(beta)+cosd(gamma)*sind(alpha),
sind(gamma)*sind(beta)]';


Y=[
-cosd(gamma)*sind(alpha)*cosd(beta)-sind(gamma)*cosd(alpha),
cosd(gamma)*cosd(alpha)*cosd(beta)-sind(gamma)*sind(alpha),
cosd(gamma)*sind(beta)]';


Z=[
sind(alpha)*sind(beta),
-cosd(alpha)*sind(beta),
cosd(beta)]';

end


## end
#483, 26:
Matlab\space\Euler_frame.m
## end
#485, 938:
%{
+[M函数](,camera_To_3D)
地址::Matlab\space\camera_To_3D.m
+[保存文本](,camera_To_3D)

测试算法:...
%}

function [x,y,z]=camera_To_3D(tx,ty,r1,Eulers,D,r0,ux,uy)
% r1=[-2.907704081479481, -6.024253426461256, -1.139908100021243];
% Eulers=[-27.73232875275092, 50.64828866565346, -0.30776320780374067];
% D=1;

% r0=[0,0,0];
% ux=[1,0,0];
% uy=[0,1,0];

% x2=[1,2,3];
% y2=[1,2,3];

x2=reshape(tx,1,numel(tx));
y2=reshape(ty,1,numel(ty));

[X,Y,Z]=Euler_frame(Eulers(1),Eulers(2),Eulers(3));
Dr=r0-r1;


T11=x2*dot(ux,Z)-D*dot(ux,X);
T12=x2*dot(uy,Z)-D*dot(uy,X);
T21=y2*dot(ux,Z)-D*dot(ux,Y);
T22=y2*dot(uy,Z)-D*dot(uy,Y);

V1=D*dot(Dr,X)-x2*dot(Dr,Z);
V2=D*dot(Dr,Y)-y2*dot(Dr,Z);

Det=T11.*T22-T12.*T21;
a=(T22.*V1-T12.*V2)./Det;
b=(-T21.*V1+T11.*V2)./Det;

x=r0(1)+a*ux(1)+b*uy(1);
y=r0(2)+a*ux(2)+b*uy(2);
z=r0(3)+a*ux(3)+b*uy(3);

x=reshape(x,size(tx,1),size(tx,2));
y=reshape(y,size(tx,1),size(tx,2));
z=reshape(z,size(tx,1),size(tx,2));


end
## end
#487, 27:
Matlab\space\camera_To_3D.m
## end
#489, 1171:
+[返回目录](,测试场景)
+[删除结构](,测试场景)
+[显示星图](,测试场景)

+房间, +桌子1, +桌子2, +柜子, +黑板, +窗子, +键盘1, +键盘2都是网格
+相机都是相机

房间是(0.5,-0.5,-0.5)的立方体. 桌子1是(3,1,-1.4)的立方体. 桌子2是(3,1,-1.4)的立方体.
柜子是(2,0.6,-3.05)的立方体. 黑板是(3,0.2,-2.5)的立方体. 窗子是(2,0.4,-2.5)的立方体.
键盘1是(1,0.5,-0.01)的立方体. 键盘2是(1,0.5,-0.01)的立方体

桌子1在(-1.5,0.5,1.4). 房间距离桌子1为(0,-0,-2).
房间朝向相机的方向. 房间朝向45,45,45的角度.
键盘1距离桌子1为(-1.3,0.25,-1.4). 窗子距离桌子1为(0.2,0.7,-1.6)

柜子距离桌子1为(2.6,0.2,0). 桌子2朝向0,0,90的角度
桌子2距离柜子为(0.5,-2.7,0). 键盘2朝向0,0,90的角度.
键盘2距离桌子2为(0.25,-1,-1.4). 黑板朝向0,0,90的角度. 黑板距离桌子2为(0.4,0,-2)

桌子2的Z是什么

相机是(-0.3,-0.15,-0.3)的相机.
相机是(-1,-1,-1)的相机.

[方向](相机,黑板)->[m_text]([方向],+[显示])


+[显示三维场景]"2"(,测试场景)
[m_text]"123"(,+[显示])

相机绕X轴旋转180度角
+[旋转](,相机)...
->+方向(+[旋转],)->+[del](,+方向)...
->+角度(+[旋转],)->+[del](,+角度)

相机相对(1,1,1)绕桌子1物体旋转180度角
相机相对原点绕X轴旋转180度角

 
测试场景=>的(测试场景,_物体)->的(_物体,X)...
=>:<描述\"_物体相对原点绕X轴旋转180度角\">.


+[设置结构](,桌子2)
[]=>方向=>+[修改内容]"0,0,0"(,方向)
在(桌子1,空间点)->+[显示](,空间点)

测试场景=>的(测试场景,_物体)->的(_物体,X)...
=>+[旋转](,_物体)...
->+方向(+[旋转],)->+[del](,+方向)->[m_text]"1,0,0"(,+方向)...
->+角度"180"(+[旋转],)->+[del](,+角度)

+[显示PPT场景]"1"(,相片场景)
+[显示三维场景]"1"(,测试场景)

在(相机,空间点)->+[复制内容](,空间点)
朝向(相机,方向)->+[复制内容](,方向)


+[显示三维场景]"2"(,测试场景)
## end
#493, 3:
947
## end
#497, 451:
%{
+[M函数](,测试算法)
%}



[X,Y,Z]=Euler_frame(Eulers(1),Eulers(2),Eulers(3));
Dr=r0-r1;


T11=x2*dot(ux,Z)-D*dot(ux,X);
T12=x2*dot(uy,Z)-D*dot(uy,X);
T21=y2*dot(ux,Z)-D*dot(ux,Y);
T22=y2*dot(uy,Z)-D*dot(uy,Y);

V1=D*dot(Dr,X)-x2*dot(Dr,Z);
V2=D*dot(Dr,Y)-y2*dot(Dr,Z);

Det=T11.*T22-T12.*T21;
a=(T22.*V1-T12.*V2)./Det;
b=(-T21.*V1+T11.*V2)./Det;

x=r0(1)+a*ux(1)+b*uy(1);
y=r0(2)+a*ux(2)+b*uy(2);
z=r0(3)+a*ux(3)+b*uy(3);

a
b
x
y
z

%{
+[M函数](,测试算法)
%}

## end
#499, 282:
%{
plot(refPts.XData,-refPts.YData,'--')
plot(list_x0,list_y0)
axis equal
center
+[M函数](,测试代码)
%}


x=[-287.1794 -160.6036  511.2634  525.3380 -227.2552];
y=[86.4059 -911.8621 -756.7443  121.5343   87.9459];

[Eulers0,pt0,S0]=camera_from_photo(x,y,1)

figure
plot(x,-y)
axis equal


## end
#597, 142:
0.0, 0.0, 0.0, 0.0, -0.01, -0.01, -0.01, -0.01, 0.0, 0.0, 0.0, 0.0;
0.0, 0.0, 0.0, 0.0, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01
## end
#599, 154:
-0.25, -0.25, 0.25, 0.25, -0.25, -0.25, 0.25, 0.25, -0.25, -0.25, 0.25, 0.25;
-0.25, 0.25, 0.25, -0.25, -0.25, 0.25, 0.25, -0.25, -0.25, -0.25, 0.25, 0.25
## end
#601, 130:
-0.5, 0.5, 0.5, -0.5, -0.5, 0.5, 0.5, -0.5, -0.5, 0.5, 0.5, -0.5;
0.5, 0.5, -0.5, -0.5, 0.5, 0.5, -0.5, -0.5, -0.5, 0.5, 0.5, -0.5
## end
#603, 2:
网格
## end
#604, 17:
0.0, 180.0, -90.0
## end
#606, 16:
-1.85, -3.0, 0.0
## end
#608, 142:
0.0, 0.0, 0.0, 0.0, -0.01, -0.01, -0.01, -0.01, 0.0, 0.0, 0.0, 0.0;
0.0, 0.0, 0.0, 0.0, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01, -0.01
## end
#610, 154:
-0.25, -0.25, 0.25, 0.25, -0.25, -0.25, 0.25, 0.25, -0.25, -0.25, 0.25, 0.25;
-0.25, 0.25, 0.25, -0.25, -0.25, 0.25, 0.25, -0.25, -0.25, -0.25, 0.25, 0.25
## end
#612, 130:
-0.5, 0.5, 0.5, -0.5, -0.5, 0.5, 0.5, -0.5, -0.5, 0.5, 0.5, -0.5;
0.5, 0.5, -0.5, -0.5, 0.5, 0.5, -0.5, -0.5, -0.5, 0.5, 0.5, -0.5
## end
#614, 2:
网格
## end
#615, 18:
0.0, 180.0, -180.0
## end
#617, 14:
2.8, 0.75, 0.0
## end
#619, 130:
0.0, 0.0, 0.0, 0.0, -2.5, -2.5, -2.5, -2.5, 0.0, 0.0, 0.0, 0.0;
0.0, 0.0, 0.0, 0.0, -2.5, -2.5, -2.5, -2.5, -2.5, -2.5, -2.5, -2.5
## end
#621, 130:
-0.2, -0.2, 0.2, 0.2, -0.2, -0.2, 0.2, 0.2, -0.2, -0.2, 0.2, 0.2;
-0.2, 0.2, 0.2, -0.2, -0.2, 0.2, 0.2, -0.2, -0.2, -0.2, 0.2, 0.2
## end
#623, 130:
-1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0;
1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0, 1.0, 1.0, -1.0
## end
#625, 2:
网格
## end
#626, 18:
0.0, 180.0, -180.0
## end
#628, 29:
1.3, 1.2, 0.20000000000000018
## end
#630, 130:
0.0, 0.0, 0.0, 0.0, -2.5, -2.5, -2.5, -2.5, 0.0, 0.0, 0.0, 0.0;
0.0, 0.0, 0.0, 0.0, -2.5, -2.5, -2.5, -2.5, -2.5, -2.5, -2.5, -2.5
## end
#632, 130:
-0.1, -0.1, 0.1, 0.1, -0.1, -0.1, 0.1, 0.1, -0.1, -0.1, 0.1, 0.1;
-0.1, 0.1, 0.1, -0.1, -0.1, 0.1, 0.1, -0.1, -0.1, -0.1, 0.1, 0.1
## end
#634, 130:
-1.5, 1.5, 1.5, -1.5, -1.5, 1.5, 1.5, -1.5, -1.5, 1.5, 1.5, -1.5;
1.5, 1.5, -1.5, -1.5, 1.5, 1.5, -1.5, -1.5, -1.5, 1.5, 1.5, -1.5
## end
#636, 2:
网格
## end
#637, 17:
0.0, 180.0, -90.0
## end
#639, 30:
-2.0, -2.0, 0.6000000000000001
## end
#641, 142:
0.0, 0.0, 0.0, 0.0, -3.05, -3.05, -3.05, -3.05, 0.0, 0.0, 0.0, 0.0;
0.0, 0.0, 0.0, 0.0, -3.05, -3.05, -3.05, -3.05, -3.05, -3.05, -3.05, -3.05
## end
#643, 130:
-0.3, -0.3, 0.3, 0.3, -0.3, -0.3, 0.3, 0.3, -0.3, -0.3, 0.3, 0.3;
-0.3, 0.3, 0.3, -0.3, -0.3, 0.3, 0.3, -0.3, -0.3, -0.3, 0.3, 0.3
## end
#645, 130:
-1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0;
1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0, 1.0, 1.0, -1.0
## end
#647, 2:
网格
## end
#648, 18:
0.0, 180.0, -180.0
## end
#650, 15:
-1.1, 0.7, -1.4
## end
#652, 130:
0.0, 0.0, 0.0, 0.0, -1.4, -1.4, -1.4, -1.4, 0.0, 0.0, 0.0, 0.0;
0.0, 0.0, 0.0, 0.0, -1.4, -1.4, -1.4, -1.4, -1.4, -1.4, -1.4, -1.4
## end
#654, 130:
-0.5, -0.5, 0.5, 0.5, -0.5, -0.5, 0.5, 0.5, -0.5, -0.5, 0.5, 0.5;
-0.5, 0.5, 0.5, -0.5, -0.5, 0.5, 0.5, -0.5, -0.5, -0.5, 0.5, 0.5
## end
#656, 130:
-1.5, 1.5, 1.5, -1.5, -1.5, 1.5, 1.5, -1.5, -1.5, 1.5, 1.5, -1.5;
1.5, 1.5, -1.5, -1.5, 1.5, 1.5, -1.5, -1.5, -1.5, 1.5, 1.5, -1.5
## end
#658, 2:
网格
## end
#659, 17:
0.0, 180.0, -90.0
## end
#661, 16:
-1.6, -2.0, -1.4
## end
#663, 130:
0.0, 0.0, 0.0, 0.0, -1.4, -1.4, -1.4, -1.4, 0.0, 0.0, 0.0, 0.0;
0.0, 0.0, 0.0, 0.0, -1.4, -1.4, -1.4, -1.4, -1.4, -1.4, -1.4, -1.4
## end
#665, 130:
-0.5, -0.5, 0.5, 0.5, -0.5, -0.5, 0.5, 0.5, -0.5, -0.5, 0.5, 0.5;
-0.5, 0.5, 0.5, -0.5, -0.5, 0.5, 0.5, -0.5, -0.5, -0.5, 0.5, 0.5
## end
#667, 130:
-1.5, 1.5, 1.5, -1.5, -1.5, 1.5, 1.5, -1.5, -1.5, 1.5, 1.5, -1.5;
1.5, 1.5, -1.5, -1.5, 1.5, 1.5, -1.5, -1.5, -1.5, 1.5, 1.5, -1.5
## end
#669, 2:
网格
## end
#670, 18:
0.0, 180.0, -180.0
## end
#672, 14:
1.5, 0.5, -1.4
## end
#674, 130:
0.0, 0.0, 0.0, 0.0, -0.5, -0.5, -0.5, -0.5, 0.0, 0.0, 0.0, 0.0;
0.0, 0.0, 0.0, 0.0, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5
## end
#676, 154:
0.25, 0.25, -0.25, -0.25, 0.25, 0.25, -0.25, -0.25, 0.25, 0.25, -0.25, -0.25;
0.25, -0.25, -0.25, 0.25, 0.25, -0.25, -0.25, 0.25, 0.25, 0.25, -0.25, -0.25
## end
#678, 154:
-0.25, 0.25, 0.25, -0.25, -0.25, 0.25, 0.25, -0.25, -0.25, 0.25, 0.25, -0.25;
0.25, 0.25, -0.25, -0.25, 0.25, 0.25, -0.25, -0.25, -0.25, 0.25, 0.25, -0.25
## end
#680, 2:
网格
## end
#681, 47:
-44.999999999999986, 135.0, -135.00000000000003
## end
#683, 28:
1.5, 0.5, 0.6000000000000001
## end
#709, 18:
0.6440011498478455
## end
#713, 112:
0.0, 0.0, -1.0, -1.0;
-1.0, -1.0, -1.0, -1.0;
-1.0, -1.0, -1.0, -1.0;
0.0, 0.0, -1.0, -1.0;
0.0, 0.0, -1.0, -1.0
## end
#715, 102:
0.0, 0.0, 0.5, 0.6;
0.5, 0.5, -0.5, 0.6;
-0.5, -0.5, -0.5, 1.1;
0.0, 0.0, 0.5, 0.6;
0.0, 0.0, 0.5, 0.6
## end
#717, 103:
0.0, 0.0, 0.5, 0.0;
-0.5, 0.5, 0.5, -0.5;
-0.5, 0.5, -0.5, 0.0;
0.0, 0.0, -0.5, 0.5;
0.0, 0.0, 0.5, 0.0
## end
#719, 2:
网格
## end
#720, 55:
29.47573058416852, 74.1467330644296, 178.54748374831715
## end
#722, 58:
2.4196102865480205, -4.842540228631023, 1.5455314494331314
## end
#728, 307:
+[返回目录](,相片场景)
+[删除结构](,相片场景)
+[显示星图](,相片场景)

+相片都是图片. 相片的尺寸是"1,2". 相片的内容是"input/1.jpg"

+房间, +桌子1, +桌子2, +柜子, +黑板, +窗子, +键盘1, +键盘2都是图形.
+A, +B, +C, +D都是点. 有一个四边形(A,B,C,D)

B距离A为(1,0). D距离A为(0,1). C距离A为(1,1)

A在鼠标的位置
B在鼠标的位置
C在鼠标的位置
D在鼠标的位置

的(相片,尺寸)->+[显示](,尺寸)

+[显示PPT场景]"1"(,相片场景)
显示区域(0.53,1,0.23,0.5)

## end
#737, 11:
input/1.jpg
## end
#739, 2:
图片
## end
#740, 9:
1.0, 0.75
## end
#742, 3:
0,0
## end
#825, 490:
0.2592443204719462, 0.31690304116066276, 0.30512920598210425, 0.2405606253398726, 0.2608607259645587, 0.31825204288499553, 0.3065459763857481, 0.24227456143922527, 0.2592443204719462, 0.31690304116066276, 0.30512920598210425, 0.2405606253398726;
0.31690304116066276, 0.30512920598210425, 0.2405606253398726, 0.2592443204719462, 0.31825204288499553, 0.3065459763857481, 0.24227456143922527, 0.2608607259645587, 0.2608607259645587, 0.31825204288499553, 0.3065459763857481, 0.24227456143922527
## end
#827, 508:
-0.06132665588978081, 0.11360507254775948, 0.1583961071629461, -0.01767933183107473, -0.06179160393364669, 0.11333399896411478, 0.158138771890657, -0.018141574925469306, -0.06132665588978081, 0.11360507254775948, 0.1583961071629461, -0.01767933183107473;
0.11360507254775948, 0.1583961071629461, -0.01767933183107473, -0.06132665588978081, 0.11333399896411478, 0.158138771890657, -0.018141574925469306, -0.06179160393364669, -0.06179160393364669, 0.11333399896411478, 0.158138771890657, -0.018141574925469306
## end
#829, 3:
多边形
## end
#830, 1:
0
## end
#832, 3:
0,0
## end
#834, 487:
0.33929334145643547, 0.35730825647597975, 0.3736861607419817, 0.3587938689302687, 0.34065490351984656, 0.3585495672242673, 0.3748389941518402, 0.3600498562465296, 0.33929334145643547, 0.35730825647597975, 0.3736861607419817, 0.3587938689302687;
0.35730825647597975, 0.3736861607419817, 0.3587938689302687, 0.33929334145643547, 0.3585495672242673, 0.3748389941518402, 0.3600498562465296, 0.34065490351984656, 0.34065490351984656, 0.3585495672242673, 0.3748389941518402, 0.3600498562465296
## end
#836, 475:
0.9891754954844091, 0.8288252696097727, 0.8323180929754567, 0.9792985382475741, 0.989438909320193, 0.8289750072656006, 0.8324579296786704, 0.9795339106193806, 0.9891754954844091, 0.8288252696097727, 0.8323180929754567, 0.9792985382475741;
0.8288252696097727, 0.8323180929754567, 0.9792985382475741, 0.9891754954844091, 0.8289750072656006, 0.8324579296786704, 0.9795339106193806, 0.989438909320193, 0.989438909320193, 0.8289750072656006, 0.8324579296786704, 0.9795339106193806
## end
#838, 3:
多边形
## end
#839, 1:
0
## end
#841, 3:
0,0
## end
#843, 481:
0.3969679010687106, 0.41674120919097657, 0.4243900589568315, 0.4070698045185271, 0.7343092934981685, 0.6992783380839194, 0.6918114688999748, 0.7230583329566321, 0.3969679010687106, 0.41674120919097657, 0.4243900589568315, 0.4070698045185271;
0.41674120919097657, 0.4243900589568315, 0.4070698045185271, 0.3969679010687106, 0.6992783380839194, 0.6918114688999748, 0.7230583329566321, 0.7343092934981685, 0.7343092934981685, 0.6992783380839194, 0.6918114688999748, 0.7230583329566321
## end
#845, 478:
0.8351421279006495, 0.6048329677332376, 0.6184785495837739, 0.8374234035230104, 0.8760610566647611, 0.6106270505115262, 0.6255198390774555, 0.8758973914076498, 0.8351421279006495, 0.6048329677332376, 0.6184785495837739, 0.8374234035230104;
0.6048329677332376, 0.6184785495837739, 0.8374234035230104, 0.8351421279006495, 0.6106270505115262, 0.6255198390774555, 0.8758973914076498, 0.8760610566647611, 0.8760610566647611, 0.6106270505115262, 0.6255198390774555, 0.8758973914076498
## end
#847, 3:
多边形
## end
#848, 1:
0
## end
#850, 3:
0,0
## end
#852, 478:
0.360727394554509, 0.4474610935734724, 0.44617036259705356, 0.35604791940271374, 0.9118432473911363, 0.7486967012130772, 0.7527110324982755, 0.925323786906783, 0.360727394554509, 0.4474610935734724, 0.44617036259705356, 0.35604791940271374;
0.4474610935734724, 0.44617036259705356, 0.35604791940271374, 0.360727394554509, 0.7486967012130772, 0.7527110324982755, 0.925323786906783, 0.9118432473911363, 0.9118432473911363, 0.7486967012130772, 0.7527110324982755, 0.925323786906783
## end
#854, 505:
-0.09051757178051933, 0.31407812648821243, 0.33018921106666244, -0.07376310889666737, -0.2490422977177561, 0.2827373152383076, 0.3003909931649691, -0.23360966875166178, -0.09051757178051933, 0.31407812648821243, 0.33018921106666244, -0.07376310889666737;
0.31407812648821243, 0.33018921106666244, -0.07376310889666737, -0.09051757178051933, 0.2827373152383076, 0.3003909931649691, -0.23360966875166178, -0.2490422977177561, -0.2490422977177561, 0.2827373152383076, 0.3003909931649691, -0.23360966875166178
## end
#856, 3:
多边形
## end
#857, 1:
0
## end
#859, 3:
0,0
## end
#861, 478:
0.2501984001445002, 0.2860295908409843, 0.3040710566892365, 0.2733317367736167, 0.5715441228762863, 0.5651739566796729, 0.5653346421069364, 0.5712014670497234, 0.2501984001445002, 0.2860295908409843, 0.3040710566892365, 0.2733317367736167;
0.2860295908409843, 0.3040710566892365, 0.2733317367736167, 0.2501984001445002, 0.5651739566796729, 0.5653346421069364, 0.5712014670497234, 0.5715441228762863, 0.5715441228762863, 0.5651739566796729, 0.5653346421069364, 0.5712014670497234
## end
#863, 481:
0.5421070705559181, 0.38324060763010387, 0.4146830513890385, 0.5662840516213736, 0.5398002958602358, 0.36090951155823825, 0.397694628209354, 0.5674943893020078, 0.5421070705559181, 0.38324060763010387, 0.4146830513890385, 0.5662840516213736;
0.38324060763010387, 0.4146830513890385, 0.5662840516213736, 0.5421070705559181, 0.36090951155823825, 0.397694628209354, 0.5674943893020078, 0.5398002958602358, 0.5398002958602358, 0.36090951155823825, 0.397694628209354, 0.5674943893020078
## end
#865, 3:
多边形
## end
#866, 1:
0
## end
#868, 3:
0,0
## end
#870, 490:
0.05462514862564022, 0.2518163607910525, 0.23025957468966704, -0.00850817798263187, 0.2592443204719462, 0.38511825884429807, 0.373222892065112, 0.2190828350163666, 0.05462514862564022, 0.2518163607910525, 0.23025957468966704, -0.00850817798263187;
0.2518163607910525, 0.23025957468966704, -0.00850817798263187, 0.05462514862564022, 0.38511825884429807, 0.373222892065112, 0.2190828350163666, 0.2592443204719462, 0.2592443204719462, 0.38511825884429807, 0.373222892065112, 0.2190828350163666
## end
#872, 511:
-0.002469343091602738, 0.33443317246109017, 0.4143495591905142, 0.08909132583531343, -0.06132665588978081, 0.32056432853896294, 0.40470773454314246, 0.032495329427753405, -0.002469343091602738, 0.33443317246109017, 0.4143495591905142, 0.08909132583531343;
0.33443317246109017, 0.4143495591905142, 0.08909132583531343, -0.002469343091602738, 0.32056432853896294, 0.40470773454314246, 0.032495329427753405, -0.06132665588978081, -0.06132665588978081, 0.32056432853896294, 0.40470773454314246, 0.032495329427753405
## end
#874, 3:
多边形
## end
#875, 1:
0
## end
#877, 3:
0,0
## end
#879, 487:
0.13818926101696488, 0.23031593345015197, 0.2715715045346957, 0.2044754552910813, 0.3229350397613949, 0.3746716417910448, 0.39965671641791023, 0.3635552503252601, 0.13818926101696488, 0.23031593345015197, 0.2715715045346957, 0.2044754552910813;
0.23031593345015197, 0.2715715045346957, 0.2044754552910813, 0.13818926101696488, 0.3746716417910448, 0.39965671641791023, 0.3635552503252601, 0.3229350397613949, 0.3229350397613949, 0.3746716417910448, 0.39965671641791023, 0.3635552503252601
## end
#881, 439:
0.9117591838715549, 0.5333155643415243, 0.5749652120632489, 0.9058713025327809, 0.9439966822091481, 0.5316716417910448, 0.576, 0.9323057740448351, 0.9117591838715549, 0.5333155643415243, 0.5749652120632489, 0.9058713025327809;
0.5333155643415243, 0.5749652120632489, 0.9058713025327809, 0.9117591838715549, 0.5316716417910448, 0.576, 0.9323057740448351, 0.9439966822091481, 0.9439966822091481, 0.5316716417910448, 0.576, 0.9323057740448351
## end
#883, 3:
多边形
## end
#884, 1:
0
## end
#886, 3:
0,0
## end
#888, 490:
0.43356458060769015, 0.41324107171133534, 0.4478216473964619, 0.4705196347853176, 0.48351571656710013, 0.4588278809605676, 0.49182387942244615, 0.5185745330172745, 0.43356458060769015, 0.41324107171133534, 0.4478216473964619, 0.4705196347853176;
0.41324107171133534, 0.4478216473964619, 0.4705196347853176, 0.43356458060769015, 0.4588278809605676, 0.49182387942244615, 0.5185745330172745, 0.48351571656710013, 0.48351571656710013, 0.4588278809605676, 0.49182387942244615, 0.5185745330172745
## end
#890, 475:
0.754450425050524, 0.7505122483645048, 0.7013796834985977, 0.7006730804328988, 0.7988713256040443, 0.7910668359105357, 0.7404437864174952, 0.7433120098233392, 0.754450425050524, 0.7505122483645048, 0.7013796834985977, 0.7006730804328988;
0.7505122483645048, 0.7013796834985977, 0.7006730804328988, 0.754450425050524, 0.7910668359105357, 0.7404437864174952, 0.7433120098233392, 0.7988713256040443, 0.7988713256040443, 0.7910668359105357, 0.7404437864174952, 0.7433120098233392
## end
#892, 3:
多边形
## end
#893, 1:
0
## end
#895, 3:
0,0
## end
#917, 38:
0.9556119402985077, 0.3214776119402985
## end
#919, 38:
0.9419104477611943, 0.3625820895522388
## end
#921, 26:
0.576, 0.39965671641791045
## end
#923, 38:
0.5316716417910448, 0.3746716417910448
## end
#937, 3:
939
## end
#939, 3:
941
## end
#941, 3:
949
## end
#944, 24:
相机相对(1,1,1)绕桌子1物体旋转180度角
## end
#946, 5:
1,1,1
## end
#948, 5:
1,1,1
## end
#949, 3:
955
## end
#951, 4:
1010
## end
#954, 15:
文档\S应用\PPT.ftxt
## end
#956, 496:
"""
+[返回目录](,描述)
库:...
+[新建阅读窗口](,库)

是([名词库],名词)->+[打开文件](+新窗口,名词)

"""
+描述(_句子,_结构)->+[del](,+描述)...
->的(描述,库)...
->的(库,_模板)->的(_模板,匹配模板)->[模式匹配](匹配模板,_句子)...
->+[临时文本]->[]{
    []:->的(_模板,转述)->+[做](_句子,+[临时文本])->+[code](+[做],转述)...
    ->+匹配模板(+[做],匹配模板)->+[del](,+匹配模板),
    ->的(_模板,输出模板)->+[转述](_句子,+[临时文本])...
    ->+匹配模板(+[转述],匹配模板)->+[del](,+匹配模板)...
    ->+输出模板(+[转述],输出模板)->+[del](,+输出模板)
}...

->+[复制内容](,+[临时文本])->+[修改内容](+[临时文本],+[显示]):
    ->_结构->+[修改内容](+[临时文本],_结构),
    ->[]





## end
#958, 311:


设置n边形:...
设置对应关系:...
设置对应关系2:...

设置约束关系:...

标记区域:标记%[瑜伽毯]的区域...
标记区域2:...
标记区域3:...
标记区域4:...
记录区域:...
+[复制结构](,记录区域)

获取三维坐标:在%[瑜伽毯]的%[XY]平面上, 从%[相机1]上获取坐标...
获取三维坐标2:从%[相机1]上, 获取%[A点]的三维坐标...
获取二维坐标:在%[相机1]上, 更新%[AB]的二维坐标...
三维坐标变换:%[瑜伽毯]坐标系中的%[相机]转换为%[立方体]坐标系中的%[相机2]...

直线交点:...

设置相机位置:...

拍摄照片:...


## end
#960, 376:
"""
M代码(M函数):...

"""

+标记多边形(,_多边形)...
->的(标记多边形,M代码)...

->Matlab{
    []:->多边形(+标记多边形,)->+[matlab]"x=zeros(1,n);y=x;"(Matlab,)...
        ->+[.]"n"(+[matlab],多边形),
    ->_多边形->的(_多边形,x)->的(_多边形,y)->+[matlab](Matlab,)...
        ->+[.](+[matlab],x)->+[.](+[matlab],y)
}...

->+[matlab](Matlab,)->+[code](+[matlab],M代码)...
->+[.]"n"(+[matlab],+标记多边形)...

->+[del](,+标记多边形)



## end
#962, 462:
%{
+[M函数](,M代码)
getRefPlane(M函数):...

class(h)
%}

addpath('Matlab\photo');

global refPlane;

if isa(refPlane,'matlab.graphics.primitive.Patch')
    delete(refPlane)
elseif isa(refPlane,'matlab.graphics.chart.primitive.Line')
    delete(refPlane)
end

if numel(x)>2
    refPlane=patch(x,y,[1,1,0],'FaceAlpha',0.5)
else
    hold on
    refPlane=plot(x,y,'r*-')
end

set(gcf,'WindowButtonDownFcn',@getRefPlane);
% set(gcf,'WindowButtonMotionFcn',@getRefPlane);



## end
#965, 549:
%{
地址::Matlab\photo\getRefPlane.m
+[保存文本](,getRefPlane)
%}

function getRefPlane(hObject,~)
    pt=get(gca,'CurrentPoint');
    cType=get(hObject,'SelectionType');
    if strcmp(cType,'alt')
        global refPlane;
        x=get(refPlane,'XData');
        y=get(refPlane,'YData');
        r=sqrt((x-pt(1,1)).^2+(y-pt(1,2)).^2);
        xi=find(r==min(r));
        x(xi(1))=pt(1,1);
        yi=find(r==min(r));
        y(yi(1))=pt(1,2);
        set(refPlane,'XData',x);
        set(refPlane,'YData',y);
    end

    clipboard('copy', [x';y']);
end


## end
#968, 26:
Matlab\photo\getRefPlane.m
## end
#972, 653:
"""
+[返回目录](,设置相机参数)
记住设置相机参数(节点)

M代码(M函数):...

"""
+设置相机参数(,_相机)->+[del](,+设置相机参数)...
->的(设置相机参数,M代码)...

->的(_相机,参考平面)->参考平面(,_平面)...
->的(_相机,照片)->照片(,_相片)...
->对应(_三维物体,_平面)...

->在(_相片,空间点#0)->的(_相片,尺寸)...
->在(_相机,空间点#y)->朝向(_相机,方向#y)...
->的(_相机,形状)->的(形状,D#形状)...
->的(_平面,x)->的(_平面,y)...
->的(_三维物体,X)->的(_三维物体,Y)->的(_三维物体,Z)...

->+[matlab](Matlab,)->+[code](+[matlab],M代码)...

->+[.]"x0"(+[matlab],x)->+[.]"y0"(+[matlab],y)...
->+[.]"pt"(+[matlab],空间点#0)->+[.]"siz"(+[matlab],尺寸)...
->+[o]"Eulers"(+[matlab],方向#y)->+[o]"r0"(+[matlab],空间点#y)...
->+[o]"X"(+[matlab],X)->+[o]"Y"(+[matlab],Y)->+[o]"Z"(+[matlab],Z)...
->+[o]"S"(+[matlab],D#形状)







## end
#974, 117:


匹配模板::^%[相机]的%[瑜伽毯]对应%[瑜伽毯2]$
输出模板::的(%[相机],%[瑜伽毯])->%[瑜伽毯2]#2:->对应(%[瑜伽毯],%[瑜伽毯2]#2),
    ->+对应(%[瑜伽毯],%[瑜伽毯2]#2)

## end
#976, 23:
^%[相机]的%[瑜伽毯]对应%[瑜伽毯2]$
## end
#978, 78:
的(%[相机],%[瑜伽毯])->%[瑜伽毯2]#2:->对应(%[瑜伽毯],%[瑜伽毯2]#2),
    ->+对应(%[瑜伽毯],%[瑜伽毯2]#2)
## end
#980, 117:


匹配模板::^%[瑜伽毯2]对应%[相机]的%[瑜伽毯]$
输出模板::的(%[相机],%[瑜伽毯])->%[瑜伽毯2]#2:->对应(%[瑜伽毯2]#2,%[瑜伽毯]),
    ->+对应(%[瑜伽毯2]#2,%[瑜伽毯])

## end
#982, 23:
^%[瑜伽毯2]对应%[相机]的%[瑜伽毯]$
## end
#984, 78:
的(%[相机],%[瑜伽毯])->%[瑜伽毯2]#2:->对应(%[瑜伽毯2]#2,%[瑜伽毯]),
    ->+对应(%[瑜伽毯2]#2,%[瑜伽毯])
## end
#986, 406:
%{
+[M函数](,M代码)

GetPointOnPlane(M函数):...
Nini, 打开照片测量的camera_from_photo(节点)
%}

% x=[ptA(1),ptB(1),ptC(1),ptD(1)];
% y=[ptA(2),ptB(2),ptC(2),ptD(2)];
addpath('Matlab/space');

center=pt+siz/2;
x=x0-center(1);
y=y0-center(2);
[Eulers,r0,S]=camera_from_photo(x,y,1);

abc=[0,0,1];
pt0=[0,0,0];
[X,Y,Z]=GetPointOnPlane(x,y,pt0,abc,Eulers,r0,S)
X(end+1)=X(1);
Y(end+1)=Y(1);
Z(end+1)=Z(1);

%{
+[M函数](,M代码)
%}
## end
#989, 57:


匹配模板::设置%[相机1]的参数和其参考平面的位置
输出模板::+[设置相机参数](,%[相机1])




## end
#991, 20:
设置%[相机1]的参数和其参考平面的位置
## end
#993, 18:
+[设置相机参数](,%[相机1])
## end
#995, 17:
文档\数学问题\空间投影.ftxt
## end
#996, 4:
1021
## end
#999, 904:
"""
+[返回目录](,拍照)

M代码(M函数):...

"""

+拍照(_相机,_物体)->Matlab{
    []:->[==](,+显示三维场景),
    ->+[matlab]"if ~isempty(n)
figure(n);
end"(Matlab,)->+[.]"n"(+[matlab],+拍照)
}->+[del](,+拍照)...
->的(拍照,M代码)...

->的(_相机,照片)->照片(,_相片)...
->在(_相片,空间点#0)->的(_相片,尺寸)...
->在(_相机,空间点)->朝向(_相机,方向)...
->的(_物体,X)->的(_物体,Y)->的(_物体,Z)...

->+[matlab](Matlab,)->+[code](+[matlab],M代码)...
->+[.]"r0"(+[matlab],空间点)->+[.]"Eulers"(+[matlab],方向)...
->+[.]"pt0"(+[matlab],空间点#0)->+[.]"siz"(+[matlab],尺寸)...
->+[.](+[matlab],X)->+[.](+[matlab],Y)->+[.](+[matlab],Z)...

->[]{
    []:->的(_相机,形状)->的(形状,D)->+[.](+[matlab],D),
    ->+D"1"->+[.](+[matlab],+D)->+[del](,+D)
}...

->[]{
    []:->在(_物体,空间点#2)->空间点#2->+[.]"r2"(+[matlab],空间点#2),
    ->+r2"0,0,0"->+[.](+[matlab],+r2)->+[del](,+r2)
}...

->[]{
    []:->朝向(_物体,方向#2)->方向#2->+[.]"Eulers2"(+[matlab],方向#2),
    ->+Eulers2"0,0,0"->+[.](+[matlab],+Eulers2)->+[del](,+Eulers2)
}




## end
#1001, 182:
%{
+[M函数](,M代码)
%}

[X,Y,Z]=transform_3D(r2,Eulers2(1),Eulers2(2),Eulers2(3),X,Y,Z);
[tx,ty]=camera_click(r0,Eulers,D,X,Y,Z);
x=tx+pt0(1)+siz(1)/2;
y=ty+pt0(2)+siz(2)/2;

plot(x,y)


## end
#1004, 70:


匹配模板::在窗口%[n]中, 显示%[相机]拍摄%[物体]的照片
输出模板::+[拍照]"%[n]"(%[相机],%[物体])




## end
#1006, 27:
在窗口%[n]中, 显示%[相机]拍摄%[物体]的照片
## end
#1008, 24:
+[拍照]"%[n]"(%[相机],%[物体])
## end
#1009, 4:
1026
## end
#1011, 4:
1013
## end
#1013, 4:
1094
## end
#1016, 623:
%{
+[M函数](,GetPointOnPlane)
Nini, 打开空间投影(文件)

地址::Matlab\space\GetPointOnPlane.m
+[保存M函数](,GetPointOnPlane)
%}

function [X,Y,Z]=GetPointOnPlane(x,y,pt0,abc,Eulers,r0,S)
% center=pt+siz/2;
% x=x0-center(1);
% y=y0-center(2);
% [Eulers,r0,S]=camera_from_photo(x,y,1);

% abc=[0,0,1];
% pt0=[0,0,0];

[Xu,Yu,Zu]=Euler_frame(Eulers(1),Eulers(2),Eulers(3));
T=[Xu',Yu',Zu'];
abc1=abc*T;
pt01=(pt0-r0)*T;
p1=x/S;
q1=y/S;

Z1=sum(abc1.*pt01)./(abc1(1)*p1+abc1(2)*q1+abc1(3));
X1=p1.*Z1;
Y1=q1.*Z1;

X=Xu(1)*X1+Yu(1)*Y1+Zu(1)*Z1;
Y=Xu(2)*X1+Yu(2)*Y1+Zu(2)*Z1;
Z=Xu(3)*X1+Yu(3)*Y1+Zu(3)*Z1;

X=X+r0(1);
Y=Y+r0(2);
Z=Z+r0(3);

end


## end
#1019, 30:
Matlab\space\GetPointOnPlane.m
## end
#1021, 45:


匹配模板::标记%[瑜伽毯]的区域
输出模板::+[标记多边形](,%[瑜伽毯])


## end
#1023, 11:
标记%[瑜伽毯]的区域
## end
#1025, 17:
+[标记多边形](,%[瑜伽毯])
## end
#1027, 75:


匹配模板::标记%[n]边形区域
输出模板::+[标记多边形]->+多边形"%[n]"(+[标记多边形],)->+[del](,+多边形)




## end
#1029, 10:
标记%[n]边形区域
## end
#1031, 46:
+[标记多边形]->+多边形"%[n]"(+[标记多边形],)->+[del](,+多边形)
## end
#1033, 70:


匹配模板::将标记区域记录为%[瑜伽毯]
输出模板::+[获取标记区域](,+[设置n边形])->+[设置n边形](,%[瑜伽毯])


## end
#1035, 14:
将标记区域记录为%[瑜伽毯]
## end
#1037, 39:
+[获取标记区域](,+[设置n边形])->+[设置n边形](,%[瑜伽毯])
## end
#1039, 110:


匹配模板::在%[瑜伽毯]的%[XY]平面上, 从%[相机1]上获取坐标
输出模板::+[获取三维坐标](%[相机1],)->+平面"%[XY]"(+[获取三维坐标],%[瑜伽毯])->+[del](,+平面)



## end
#1041, 30:
在%[瑜伽毯]的%[XY]平面上, 从%[相机1]上获取坐标
## end
#1043, 62:
+[获取三维坐标](%[相机1],)->+平面"%[XY]"(+[获取三维坐标],%[瑜伽毯])->+[del](,+平面)
## end
#1045, 517:
"""
M代码(M函数):...

"""

+获取三维坐标(_相机,)->+[del](,+获取三维坐标)...
->的(获取三维坐标,M代码)...

->平面(+获取三维坐标,_物体)...
->在(_物体,空间点)->朝向(_物体,方向)...
->在(_相机,空间点#1)->朝向(_相机,方向#1)...
->的(_相机,形状)->的(形状,D)...
->的(_相机,照片)->照片(,_照片)...
->在(_照片,空间点#2)->的(_照片,尺寸)...

->+[matlab](Matlab,)->+[code](+[matlab],M代码)...
->+[.]"pt"(+[matlab],空间点)->+[.]"Eulers"(+[matlab],方向)...
->+[.]"pt1"(+[matlab],空间点#1)->+[.]"Eulers1"(+[matlab],方向#1)->+[.](+[matlab],D)...
->+[.]"pt2"(+[matlab],空间点#2)->+[.]"siz"(+[matlab],尺寸)...
->+[s]"plane_type"(+[matlab],平面)



## end
#1047, 702:
%{
+[M函数](,M代码)

get3DPointFromPhoto(M函数):...

测试(M函数):...
全局方案存档:...
%}

%pt,Eulers,pt1,Eulers1,D,pt2,siz
%plane_type
addpath('Matlab\space');
addpath('Matlab\photo');

center=pt2+siz/2;

[Xu,Yu,Zu]=Euler_frame(Eulers(1),Eulers(2),Eulers(3));
if sum(plane_type=='Y') && sum(plane_type=='Z')
    abc=Xu;
elseif sum(plane_type=='X') && sum(plane_type=='Z')
    abc=Yu;
else
    abc=Zu;
end

global GET3DPOINT;

GET3DPOINT.PT=pt
GET3DPOINT.ABC=abc
GET3DPOINT.PT1=pt1;
GET3DPOINT.EULERS1=Eulers1;
GET3DPOINT.DD=D;
GET3DPOINT.CENTER=center;

% f=@(hObject,~)get3DPointFromPhoto(hObject,pt,abc,pt1,Eulers1,D,center);
% set(gcf,'WindowButtonDownFcn',@f)
set(gcf,'WindowButtonDownFcn',@get3DPointFromPhoto)



## end
#1050, 609:
%{
地址::Matlab\photo\get3DPointFromPhoto.m
+[保存文本](,get3DPointFromPhoto)
%}

function get3DPointFromPhoto(hObject,~)
    pt_m=get(gca,'CurrentPoint');
    cType=get(hObject,'SelectionType');

    global GET3DPOINT
    if strcmp(cType,'alt')
        pt=GET3DPOINT.PT;
        abc=GET3DPOINT.ABC;
        pt1=GET3DPOINT.PT1;
        Eulers1=GET3DPOINT.EULERS1;
        D=GET3DPOINT.DD;
        center=GET3DPOINT.CENTER;

        x=pt_m(1)-center(1);
        y=pt_m(2)-center(2);

        [X,Y,Z]=GetPointOnPlane(x,y,pt,abc,Eulers1,pt1,D);
    end
    clipboard('copy', [X,Y,Z]);
    GET3DPOINT.XYZ=[X,Y,Z];
end


## end
#1053, 34:
Matlab\photo\get3DPointFromPhoto.m
## end
#1055, 522:
%{
+[M函数](,M代码)

get3DPointFromPhoto(M函数):...
get3DPointFromPhoto的"getRefPlane"替换为"get3DPointFromPhoto"
测试(M函数):...
%}

pt,Eulers,pt1,Eulers1,D,pt2,siz
plane_type

addpath('Matlab\space');

x0=2;
y0=3;
center=pt2+siz/2;
x=x0-center(1);
y=y0-center(2);

[Xu,Yu,Zu]=Euler_frame(Eulers(1),Eulers(2),Eulers(3));
if sum(plane_type=='Y') && sum(plane_type=='Z')
    abc=Xu;
elseif sum(plane_type=='X') && sum(plane_type=='Z')
    abc=Yu;
else
    abc=Zu
end

f=@(x,y)GetPointOnPlane(x,y,pt,abc,Eulers1,pt1,D);
[X,Y,Z]=f(x,y)




## end
#1058, 726:
%{
+[M函数](,M代码)

get3DPointFromPhoto(M函数):...

测试(M函数):...
全局方案存档:...
%}

%pt,Eulers,pt1,Eulers1,D,pt2,siz
%plane_type

addpath('Matlab\space');
addpath('Matlab\photo');

center=pt2+siz/2;

[Xu,Yu,Zu]=Euler_frame(Eulers(1),Eulers(2),Eulers(3));
if sum(plane_type=='Y') && sum(plane_type=='Z')
    abc=Xu;
elseif sum(plane_type=='X') && sum(plane_type=='Z')
    abc=Yu;
else
    abc=Zu;
end

global PT;
global ABC;
global PT1;
global EULERS1;
global DD;
global CENTER;

PT=pt
ABC=abc
PT1=pt1;
EULERS1=Eulers1;
DD=D;
CENTER=center;

% f=@(hObject,~)get3DPointFromPhoto(hObject,pt,abc,pt1,Eulers1,D,center);
% set(gcf,'WindowButtonDownFcn',@f)
set(gcf,'WindowButtonDownFcn',@get3DPointFromPhoto)
get(gcf,'WindowButtonDownFcn')



## end
#1060, 619:
%{
地址::Matlab\photo\get3DPointFromPhoto.m
+[保存文本](,get3DPointFromPhoto)
%}

function get3DPointFromPhoto(hObject,pt,abc,pt1,Eulers1,D,center)
    pt_m=get(gca,'CurrentPoint');
    cType=get(hObject,'SelectionType');
    global PT;
    global ABC;
    global PT1;
    global EULERS1;
    global DD;
    global CENTER;
    if strcmp(cType,'alt')
        pt=PT;
        abc=ABC;
        pt1=PT1;
        Eulers1=EULERS1;
        D=DD;
        center=CENTER;

        x=pt_m(1)-center(1);
        y=pt_m(2)-center(2);

        [X,Y,Z]=GetPointOnPlane(x,y,pt,abc,Eulers1,pt1,D);
    end
    clipboard('copy', [X,Y,Z]);
end


## end
#1063, 17:
文档\数学问题\三维旋转.ftxt
## end
#1065, 191:



匹配模板::%[瑜伽毯]坐标系中的%[相机]转换为%[立方体]坐标系中的%[相机2]
输出模板::+[三维坐标变换](%[相机],%[相机2])...
->+起始坐标系(+[三维坐标变换],%[瑜伽毯])->+[del](,+起始坐标系)...
->+终末坐标系(+[三维坐标变换],%[立方体])->+[del](,+终末坐标系);
+[显示三维图形](,%[相机2])


## end
#1067, 36:
%[瑜伽毯]坐标系中的%[相机]转换为%[立方体]坐标系中的%[相机2]
## end
#1069, 137:
+[三维坐标变换](%[相机],%[相机2])...
->+起始坐标系(+[三维坐标变换],%[瑜伽毯])->+[del](,+起始坐标系)...
->+终末坐标系(+[三维坐标变换],%[立方体])->+[del](,+终末坐标系);
+[显示三维图形](,%[相机2])
## end
#1071, 578:
"""
M代码(M函数):...

"""

+三维坐标变换(_物体1,_物体2)->+[del](,+三维坐标变换)...
->的(三维坐标变换,M代码)...

->起始坐标系(+三维坐标变换,_坐标1)->终末坐标系(+三维坐标变换,_坐标2)...
->在(_物体1,空间点#1)->朝向(_物体1,方向#1)...
->在(_坐标1,空间点#01)->朝向(_坐标1,方向#01)...
->在(_物体2,空间点#2)->朝向(_物体2,方向#2)...
->在(_坐标2,空间点#02)->朝向(_坐标2,方向#02)...

->+[matlab](Matlab,)->+[code](+[matlab],M代码)...
->+[.]"pt1"(+[matlab],空间点#1)->+[.]"Eulers1"(+[matlab],方向#1)...
->+[.]"pt01"(+[matlab],空间点#01)->+[.]"Eulers01"(+[matlab],方向#01)...
->+[.]"pt02"(+[matlab],空间点#02)->+[.]"Eulers02"(+[matlab],方向#02)...
->+[o]"pt2"(+[matlab],空间点#2)->+[o]"Eulers2"(+[matlab],方向#2)




## end
#1073, 421:
%{
+[M函数](,M代码)
%}


[X1,Y1,Z1]=Euler_frame(Eulers1(1),Eulers1(2),Eulers1(3));
T1=[X1;Y1;Z1]';
dp1=pt1-pt01;

[X01,Y01,Z01]=Euler_frame(Eulers01(1),Eulers01(2),Eulers01(3));
[X02,Y02,Z02]=Euler_frame(Eulers02(1),Eulers02(2),Eulers02(3));
T01=[X01;Y01;Z01]';
T02=[X02;Y02;Z02]';
T21=T02*T01';

T2=T21*T1;
dp2=dp1*T21';
pt2=dp2+pt02;


X2=T2(:,1);
Y2=T2(:,2);
Z2=T2(:,3);

Eulers2=frame2Eulers(X2,Y2,Z2)

%{
+[M函数](,M代码)
%}
## end
#1075, 4:
1159
## end
#1078, 65:


匹配模板::标记点
输出模板::+[标记多边形]->+多边形"1"(+[标记多边形],)->+[del](,+多边形)




## end
#1080, 43:
+[标记多边形]->+多边形"1"(+[标记多边形],)->+[del](,+多边形)
## end
#1082, 3:
标记点
## end
#1084, 66:


匹配模板::标记线段
输出模板::+[标记多边形]->+多边形"2"(+[标记多边形],)->+[del](,+多边形)




## end
#1086, 4:
标记线段
## end
#1088, 43:
+[标记多边形]->+多边形"2"(+[标记多边形],)->+[del](,+多边形)
## end
#1090, 128:
"""
M代码(M函数):...

"""

+获取标记区域(,_目标)->+[del](,+获取标记区域)...
->的(获取标记区域,M代码)...

->+[matlab](Matlab,_目标)->+[code](+[matlab],M代码)



## end
#1092, 102:


X=refPlane.XData;
Y=refPlane.YData;

X=reshape(X,1,numel(X));
Y=reshape(Y,1,numel(Y));


ans=[X;Y]


## end
#1095, 104:


匹配模板::%[A点]在%[外壳]上
输出模板::%[外壳]:->上(%[外壳],),->+上(%[外壳],);
%[A点]->上(%[外壳],):->的(上,%[A点]),->+的(上,%[A点])


## end
#1097, 12:
%[A点]在%[外壳]上
## end
#1099, 75:
%[外壳]:->上(%[外壳],),->+上(%[外壳],);
%[A点]->上(%[外壳],):->的(上,%[A点]),->+的(上,%[A点])
## end
#1101, 994:
"""
M代码(M函数):...
M代码2(M函数):...

"""

+二维坐标转三维坐标(,_三维坐标)->+[del](,+二维坐标转三维坐标)...
->的(二维坐标转三维坐标,M代码)->的(二维坐标转三维坐标,M代码2)...

->相机(+二维坐标转三维坐标,_相机)...
->的(上,_三维坐标)->上(_物体,)...
->对应(_二维坐标,_三维坐标)->的(_相机,_二维坐标)...

->在(_相机,空间点#1)->朝向(_相机,方向#1)...
->的(_相机,形状)->的(形状,D)...
->的(_相机,照片)->照片(,_照片)...
->在(_照片,空间点#2)->的(_照片,尺寸)...

->的(_二维坐标,x)->的(_二维坐标,y)...

->+[matlab](Matlab,)...

->[]{
    []:->+[code](+[matlab],M代码)...
    ->在(_物体,空间点)->空间点->朝向(_物体,方向)->方向(,)...
    ->+[.]"pt"(+[matlab],空间点)->+[.]"Eulers"(+[matlab],方向)...
    ->+[s]"plane_type"(+[matlab],上),

    ->+[code](+[matlab],M代码2)...
    ->的(_物体,X)->X->的(_物体,Y)->Y->的(_物体,Z)->Z(,)...
    ->+[.](+[matlab],X)->+[.](+[matlab],Y)->+[.](+[matlab],Z)
}...

->+[.]"pt1"(+[matlab],空间点#1)->+[.]"Eulers1"(+[matlab],方向#1)->+[.](+[matlab],D)...
->+[.]"pt2"(+[matlab],空间点#2)->+[.]"siz"(+[matlab],尺寸)...
->+[.]"x0"(+[matlab],x)->+[.]"y0"(+[matlab],y):
    ->在(_三维坐标,空间点#3)->+[o]"pt3"(+[matlab],空间点#3),
    ->+在(_三维坐标,+空间点)->+[o]"pt3"(+[matlab],+空间点)



## end
#1103, 433:
%{
+[M函数](,M代码)
%}

%pt,Eulers,pt1,Eulers1,D,pt2,siz
%plane_type
addpath('Matlab\space');
addpath('Matlab\photo');

center=pt2+siz/2;

[Xu,Yu,Zu]=Euler_frame(Eulers(1),Eulers(2),Eulers(3));
if sum(plane_type=='Y') && sum(plane_type=='Z')
    abc=Xu;
elseif sum(plane_type=='X') && sum(plane_type=='Z')
    abc=Yu;
else
    abc=Zu;
end

x=x0-center(1);
y=y0-center(2);
[X,Y,Z]=GetPointOnPlane(x,y,pt,abc,Eulers1,pt1,D);

pt3=[X,Y,Z];

## end
#1106, 100:


匹配模板::从%[相机1]上, 获取%[A点]的三维坐标
输出模板::+[二维坐标转三维坐标](,%[A点])->+相机(+[二维坐标转三维坐标],%[相机1])->+[del](,+相机)



## end
#1108, 22:
从%[相机1]上, 获取%[A点]的三维坐标
## end
#1110, 60:
+[二维坐标转三维坐标](,%[A点])->+相机(+[二维坐标转三维坐标],%[相机1])->+[del](,+相机)
## end
#1112, 742:
"""
M代码(M函数):...

"""

+三维坐标转二维坐标(,_二维坐标)->+[del](,+三维坐标转二维坐标)...
->的(三维坐标转二维坐标,M代码)...

->相机(+三维坐标转二维坐标,_相机)->的(_相机,_二维坐标)...
->对应(_三维坐标,_二维坐标)...

->在(_相机,空间点#1)->朝向(_相机,方向#1)...
->的(_相机,形状)->的(形状,D)...
->的(_相机,照片)->照片(,_照片)...
->在(_照片,空间点#2)->的(_照片,尺寸)...
->的(_三维坐标,X)->的(_三维坐标,Y)->的(_三维坐标,Z)...

->+[matlab](Matlab,)->+[code](+[matlab],M代码)...
->+[.]"pt1"(+[matlab],空间点#1)->+[.]"Eulers1"(+[matlab],方向#1)->+[.](+[matlab],D)...
->+[.]"pt2"(+[matlab],空间点#2)->+[.]"siz"(+[matlab],尺寸)...
->+[.]"X0"(+[matlab],X)->+[.]"Y0"(+[matlab],Y)->+[.]"Z0"(+[matlab],Z)...
->[]{
    []:->的(_二维坐标,x)->+[o](+[matlab],x),
    ->+的(_二维坐标,+x)->+[o](+[matlab],+x)
}...

->[]{
    []:->的(_二维坐标,y)->+[o](+[matlab],y),
    ->+的(_二维坐标,+y)->+[o](+[matlab],+y)
}





## end
#1114, 195:
%{
+[M函数](,M代码)

[X,Y,Z]=transform_3D(r2,Eulers2(1),Eulers2(2),Eulers2(3),X,Y,Z);
%}

X=X0;
Y=Y0;
Z=Z0;

[tx,ty]=camera_click(pt1,Eulers1,D,X,Y,Z);
x=tx+pt2(1)+siz(1)/2;
y=ty+pt2(2)+siz(2)/2;




## end
#1117, 117:


匹配模板::在%[相机1]上, 更新%[AB]的二维坐标
输出模板::的(%[相机1],%[AB])->+[三维坐标转二维坐标](,%[AB])->+相机(+[三维坐标转二维坐标],%[相机1])->+[del](,+相机)



## end
#1119, 22:
在%[相机1]上, 更新%[AB]的二维坐标
## end
#1121, 77:
的(%[相机1],%[AB])->+[三维坐标转二维坐标](,%[AB])->+相机(+[三维坐标转二维坐标],%[相机1])->+[del](,+相机)
## end
#1123, 94:


匹配模板::%[AB]和%[辅助线]相交于%[B点]
输出模板::+[直线交点](%[AB],%[辅助线])->+交点(+[直线交点],%[B点])->+[del](,+交点)




## end
#1125, 55:
+[直线交点](%[AB],%[辅助线])->+交点(+[直线交点],%[B点])->+[del](,+交点)
## end
#1127, 20:
%[AB]和%[辅助线]相交于%[B点]
## end
#1129, 545:
"""
M代码(M函数):...

公式::文档\数学问题\直线交点.ftxt
+[打开文件](+新窗口,公式)

"""

+直线交点(_线1,_线2)->+[del](,+直线交点)...
->的(直线交点,M代码)...
->交点(+直线交点,_交点)...

->的(_线1,x#1)->的(_线1,y#1)...
->的(_线2,x#2)->的(_线2,y#2)...

->+[matlab](Matlab,)->+[code](+[matlab],M代码)...
->+[.]"x1"(+[matlab],x#1)->+[.]"y1"(+[matlab],y#1)...
->+[.]"x2"(+[matlab],x#2)->+[.]"y2"(+[matlab],y#2)...

->[]{
    []:->的(_交点,x#0)->+[o]"x0"(+[matlab],x#0),
    ->+的(_交点,+x)->+[o]"x0"(+[matlab],+x)
}...

->[]{
    []:->的(_交点,y#0)->+[o]"y0"(+[matlab],y#0),
    ->+的(_交点,+y)->+[o]"y0"(+[matlab],+y)
}




## end
#1131, 63:
%{
+[M函数](,M代码)
%}


[x0,y0]=intersection_lines(x1,y1,x2,y2);


## end
#1134, 17:
文档\数学问题\直线交点.ftxt
## end
#1136, 217:
%{
+[M函数](,M代码2)
%}

addpath('Matlab\space');

center=pt2+siz/2;

k=[X(2)-X(1),Y(2)-Y(1),Z(2)-Z(1)];
k0=k/norm(k);

x=x0-center(1);
y=y0-center(2);
[x1,y1,z1]=getPointOnLine(x,y,pt,k0,Eulers1,pt1,D);

pt3=[x1,y1,z1];

## end
#1138, 4:
1140
## end
#1140, 4:
1142
## end
#1142, 4:
1144
## end
#1144, 4:
1146
## end
#1146, 4:
1171
## end
#1166, 43:

描述相对坐标:...
+[新建阅读窗口](,描述相对坐标)
封印'描述相对坐标'


## end
#1168, 512:
+[显示测量场景](,测试场景)
地址::/home/xiantao/Dropbox/Struct/Structure1.2.1/Nini/input/1.png
地址::input/1.jpg
运行指令"nautilus input"
addpath('Matlab/space')

在屏幕"1", 添加标记点
在屏幕"1", 添加折线的标记点
修改折线的标记点"4"

根据标记点"1,2,3,4,5", 设置相机的参数
有平面A
平面A是平面"1,1"
平面A和参考平面垂直
根据标记点"1,2", 设置平面A的位置

有线段A
线段A是三维线段"1"
线段A和参考平面垂直
在屏幕"1"中, 添加折线的标记点
修改折线的标记点"2"
根据标记点"3,2", 设置线段A的位置

有平面B
平面B是平面(1,1)
平面B和平面A垂直
在屏幕"3"中, 添加折线的标记点
修改折线的标记点"2"
根据标记点"1,2", 设置平面B的位置


axis equal
figure
相机是三维线段"1"
+[显示三维场景]"2"(,测试场景)
+[显示测量场景]"1"(,测试场景)
+[显示测量场景]"3"(,测试场景)
## end
#1170, 11:
input/1.jpg
## end
#1172, 459:
"""
描述结构:...
库:...

"""
+显示测量场景(,_场景)->+[del](,+显示测量场景)...
->的(显示测量场景,描述结构)->的(显示测量场景,库)...

->Matlab->[]{
    []:->[==](,+显示测量场景),
    ->+[matlab]"figure(n);"(Matlab,)...
        ->+[.]"n"(+[matlab],+[临时文本])->[m_text](+显示测量场景,+[临时文本])
}...

->+[code]([想],描述结构)->[想](+显示测量场景,_场景)...
->操作([想],)->[]{
    []=>的(操作,_操作)->_操作(_主语,_宾语)->_主语->_宾语=>[说](,_操作)...
        ->的(库,_条目)->[eq](_条目,_操作)...
        ->+[做](_主语,_宾语)->+[code](+[做],_条目)->+[.]"场景"(+[做],_场景)
}



## end
#1174, 238:
"""
Nini, 打开图形库(文件)

"""
+描述结构(_动词,_场景)->+操作(+描述结构,)...

->的(_场景,地址)->[]:
->相机(_场景,)->[]{
    []=>的(_场景,_物体)->_物体->的(_物体,X)...
    =>+图形投影(_场景,_物体)->+的(+操作,+图形投影)
}...
    ->+显示照片(_场景,地址)->+的(+操作,+显示照片),

->+显示照片(_场景,地址)->+的(+操作,+显示照片)



## end
#1176, 61:

图形投影:...
将'图形投影'的"单个投影"替换为"图形投影"
+[新建阅读窗口](,图形投影)
显示照片:...


## end
#1178, 238:
"""
M代码:...

"""
+显示照片(_场景,地址)->+[del](,+显示照片)...
->的(显示照片,M代码)...

->[]{
    []:->尺寸(_场景,),->+的(_场景,+尺寸)->+尺寸(_场景,)
}->尺寸(_场景,)...

->+[matlab](Matlab,)->+[code](+[matlab],M代码)...
->+[.]"address"(+[matlab],地址)->+[o]"siz"(+[matlab],尺寸)



## end
#1180, 252:
%{
+[M函数](,M代码)
address="/home/xiantao/Dropbox/Struct/Structure1.2.1/Nini/input/1.png"
%}

clf
clear size
data=imread(address);
image(data)
axis equal
axis([0,size(data,2),0,size(data,1)])
% set(gca,'Ydir','normal')

siz=size(data);

%{
+[M函数](,M代码)
%}
## end
#1181, 19:
3024.0, 4032.0, 3.0
## end
#1185, 80:
0.0, -5.551115123125783e-17, -5.551115123125783e-17, -5.551115123125783e-17, 0.0
## end
#1187, 90:
0.0, 1.0000000000000007, 1.0000000000000007, -0.003143853798991736, -0.0031438537989911808
## end
#1189, 93:
0.0, -5.551115123125783e-15, -0.33520573882265947, -0.33520573882265325, -0.06365488408783837
## end
#1191, 13:
0.0, 0.0, 0.0
## end
#1193, 13:
0.0, 0.0, 0.0
## end
#1197, 59:
-61.36616583565714, 104.94873559649224, -179.33494487117704
## end
#1199, 58:
1.6611893565277558, 0.8047567616911638, 0.4922280473317577
## end
#1202, 17:
2737.968374949613
## end
#1203, 8:
0.0, 0.0
## end
#1205, 8:
0.0, 0.1
## end
#1207, 3:
1.0
## end
#1209, 4:
三维线段
## end
#1211, 8:
0.0;
1.0
## end
#1213, 8:
0.0;
0.0
## end
#1215, 8:
0.0;
0.0
## end
#1221, 23:
0.0, 0.0, 0.0, 0.0, 0.0
## end
#1223, 23:
0.0, 0.0, 1.0, 1.0, 0.0
## end
#1225, 53:
0.0, 0.3582004308363752, 0.3582004308363752, 0.0, 0.0
## end
#1227, 66:
-0.2677007276903518, 0.029296910112672325, -1.1102230246251565e-16
## end
#1229, 3:
1.0
## end
#1231, 3:
1.0
## end
#1233, 2:
平面
## end
#1235, 28:
61.16893591083371, 90.0, 0.0
## end
#1238, 594:
"""
M代码:...
Nini, 打开三维场景(文件)
Nini, 打开词典的条目(节点)
+[新建阅读窗口](,M代码)

"""
+图形投影(_场景,_物体)->+[del](,+图形投影)...
->的(图形投影,M代码)...

->尺寸(_场景,)...
->相机(_场景,)->在(相机,空间点#0)->朝向(相机,方向#0)...
->在(_物体,空间点#1)...
->[]{
    []:->朝向(_物体,方向)->方向, ->+朝向(_物体,+方向)->+方向"0,0,0"
}->朝向(_物体,方向#1)...
->的(_物体,X)->的(_物体,Y)->的(_物体,Z)...

->+[matlab](Matlab,)->+[code](+[matlab],M代码)...
->+[.]"pt0"(+[matlab],空间点#0)->+[.]"Eulers0"(+[matlab],方向#0)...
->+[.]"siz0"(+[matlab],尺寸)->+[.]"S0"(+[matlab],相机)...
->+[.]"pt1"(+[matlab],空间点#1)->+[.]"Eulers1"(+[matlab],方向#1)...
->+[.](+[matlab],X)->+[.](+[matlab],Y)->+[.](+[matlab],Z)





## end
#1240, 356:
%{
记住"Matlab"
+[M函数](,M代码)
Nini, 打开词典的条目(节点)
%}

addpath("Matlab/space");

[X,Y,Z]=transform_3D(pt1,Eulers1(1),Eulers1(2),Eulers1(3),X,Y,Z);
[tx,ty,tz]=Local_coordinates(X,Y,Z,pt0,Eulers0);
x=tx./tz*S0;
y=ty./tz*S0;

x(isnan(x))=[];
y(isnan(y))=[];
x=reshape(x,1,numel(x))+siz0(2)/2;
y=reshape(y,1,numel(y))+siz0(1)/2;

patch(x,y,[1,1,1],'faceAlpha',0.2)


## end
#1243, 26:
-0.0, -0.46116195261721127
## end
#1245, 8:
0.0, 0.0
## end
#1247, 8:
0.0, 0.0
## end
#1249, 67:
-0.003381604398186022, 0.004981749140367309, -5.551115123125783e-17
## end
#1251, 3:
1.0
## end
#1253, 4:
三维线段
## end
#1257, 13:
0.0, 0.0, 0.0
## end
#1263, 45:
-28.831064089166293, 91.81569927588036, -90.0
## end
#1265, 61:
-0.23056254989677738, 0.09676433280659202, 0.7645941650304112
## end
#1267, 23:
0.0, 0.0, 0.0, 0.0, 0.0
## end
#1269, 23:
0.0, 0.0, 1.0, 1.0, 0.0
## end
#1271, 53:
0.0, 0.6846695034701449, 0.6846695034701449, 0.0, 0.0
## end
#1273, 3:
2.0
## end
#1275, 3:
1.0
## end
#1277, 2:
平面
## end
#1280, 684:
"""
M代码:...

"""
+标记物体节点(_场景,_物体)->+[del](,+标记物体节点)...
->的(标记物体节点,M代码)...

->尺寸(_场景,)...
->相机(_场景,)->在(相机,空间点#0)->朝向(相机,方向#0)...
->在(_物体,空间点#1)...
->[]{
    []:->朝向(_物体,方向)->方向, ->+朝向(_物体,+方向)->+方向"0,0,0"
}->朝向(_物体,方向#1)...
->的(_物体,X)->的(_物体,Y)->的(_物体,Z)...

->+[matlab](Matlab,)->+[code](+[matlab],M代码)...
->+[.]"pt0"(+[matlab],空间点#0)->+[.]"Eulers0"(+[matlab],方向#0)...
->+[.]"siz0"(+[matlab],尺寸)->+[.]"S0"(+[matlab],相机)...
->+[.]"pt1"(+[matlab],空间点#1)->+[.]"Eulers1"(+[matlab],方向#1)...
->+[.](+[matlab],X)->+[.](+[matlab],Y)->+[.](+[matlab],Z)...

->+[.]"color"(+[matlab],+[临时文本])->[m_text](+标记物体节点,+[临时文本])...
->[]{
    []:->[==](,+[临时文本])->[m_text]"1,0,0"(,+[临时文本]),
    ->[]
}




## end
#1282, 439:
%{
记住"Matlab"
+[M函数](,M代码)
Nini, 打开词典的条目(节点)
%}

addpath("Matlab/space");

[X,Y,Z]=transform_3D(pt1,Eulers1(1),Eulers1(2),Eulers1(3),X,Y,Z);
[tx,ty,tz]=Local_coordinates(X,Y,Z,pt0,Eulers0);
x=tx./tz*S0;
y=ty./tz*S0;

x(isnan(x))=[];
y(isnan(y))=[];
x=reshape(x,1,numel(x))+siz0(2)/2;
y=reshape(y,1,numel(y))+siz0(1)/2;

patch(x,y,[1,1,1],'faceAlpha',0,'edgeColor',color)
for i=1:length(x)
    text(x(i),y(i),num2str(i),'color',color)
end


## end
#1284, 22:

召唤规则:...
降临规则:...




## end
#1286, 153:
"""


"""

+召唤规则(_题目,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_代码)...

->[==]"描述相对坐标"(,召唤星辰)...

->+整理描述(_题目,_代码)->+的(操作,+整理描述)...
->+召唤结构(_题目,_代码)->+的(操作,+召唤结构)



## end
#1288, 21:

召唤结构:...
整理描述:...



## end
#1290, 419:
"""
描述结构:...
库:...
+[新建阅读窗口](,描述结构)

"""
+召唤结构(_媒介,_凭依)->+[del](,+召唤结构)...
->的(召唤结构,描述结构)->的(召唤结构,库)...

->+顺序"
"(_凭依,)->+的(_凭依,+顺序)...
->+[matlab]"n_name=1;"(Matlab,)...

->+[code]([想],描述结构)->[想](_媒介,_凭依)...
->操作([想],)->[]{
    []=>的(操作,_操作)->_操作(_主语,_宾语)->_主语->_宾语=>[说](,_操作)...
        ->的(库,_条目)->[eq](_条目,_操作)...
        ->+[做](_主语,_宾语)->+[code](+[做],_条目)...
        ->+[.](+[做],+[临时文本])->[m_text](_操作,+[临时文本])
}


## end
#1292, 164:
"""
+[修改内容](+[临时文本],记忆)
+[显示](,记忆)
记住"Matlab"

"""
+整理描述(_媒介,_凭依)->+[del](,+整理描述)...
->+[修改内容](+[临时文本],_凭依)...
->+[结构转文本](_凭依,_凭依)->+[记住](,_凭依)...
->+[删除结构](,_凭依)


## end
#1294, 330:
"""
P代码:...

"""
+描述结构(_媒介,_凭依)->+操作(+描述结构,)...
->的(描述结构,P代码)...

->."坐标序号"(_媒介,_坐标)...
->+[.]"list_n"([python],_坐标)->[python]"i=0
state=True"(Python,)...
->+坐标->+不终止->[]{
    +[code]([python]#1,P代码)->+[o]"n"([python]#1,+坐标)...
        =>[python]#1(Python,+不终止)...
        =>+单句描述(_媒介,_凭依)->+的(+操作,+单句描述)->[m_text](+坐标,+单句描述)
}



## end
#1296, 38:

单句描述:...
在选择区域中, 将'单句描述'的"0"替换为"1"



## end
#1298, 79:
"""


"""

state=(i<len(list_n))
if state==True:
    n=int(list_n[i])
i=i+1




## end
#1300, 1478:
"""
M代码:...
+[新建阅读窗口](,M代码)
在选择区域中, 将'M代码'的"0"替换为"1"

"""
+单句描述(_媒介,_凭依)->+[del](,+单句描述)...
->的(单句描述,M代码)...

->.(+单句描述,_i)...
->."原点"(_媒介,_原点)->."原点序号"(_媒介,_i0)->."坐标"(_媒介,_坐标)...

->+[文本结构_插入尾部](_凭依,+节点)...
    ->+节点"%A距离%B为(%位移)"...
->+[文本结构_插入](+节点,+A)->+[文本结构_插入](+节点,+B)...
->+[文本结构_插入](+节点,+位移)...

->+A"坐标"->+[增加内容](_i,+A)->+B"坐标"->+[增加内容](_i0,+B)...

->在(_原点,空间点#0)->朝向(_原点,方向#0)...
->的(_原点,X#0)->的(_原点,Y#0)->的(_原点,Z#0)...
->在(_坐标,空间点#1)->朝向(_坐标,方向#1)...
->的(_坐标,X#1)->的(_坐标,Y#1)->的(_坐标,Z#1)...

->+[matlab](Matlab,+位移)->+[code](+[matlab],M代码)...
->+[.]"pt0"(+[matlab],空间点#0)->+[.]"an0"(+[matlab],方向#0)...
->+[.]"X0"(+[matlab],X#0)->+[.]"Y0"(+[matlab],Y#0)->+[.]"Z0"(+[matlab],Z#0)...
->+[.]"pt1"(+[matlab],空间点#1)->+[.]"an1"(+[matlab],方向#1)...
->+[.]"X1"(+[matlab],X#1)->+[.]"Y1"(+[matlab],Y#1)->+[.]"Z1"(+[matlab],Z#1)...

->+[.]"n0"(+[matlab],_i0)->+[.]"n"(+[matlab],_i)...
->[]{
    []:->."角度"(_媒介,_角度)->_角度->+[.]"angle"(+[matlab],_角度),
    ->+[临时文本]"0"->+[.]"angle"(+[matlab],+[临时文本])
}...
->[]{
    []:->."反射面"(_媒介,_反射面)->_反射面->+[s]"ref_ax"(+[matlab],_反射面),
    ->+[临时文本]"0"->+[s]"ref_ax"(+[matlab],+[临时文本])
}...
->[]{
    []:->."单位"(_媒介,_单位)->_单位->+[.]"unit_name"(+[matlab],_单位),
    ->+[临时文本]"m"->+[.]"unit_name"(+[matlab],+[临时文本])
}...
->[]{
    []:->."名字"(_媒介,_名字)->_名字(,)...
        ->+[.]"names"(+[matlab],_名字)->+[o]"name"(+[matlab],+A),
    ->+[临时文本]->+[.]"names"(+[matlab],+[临时文本])
}...
->[]{
    []:->."原点名字"(_媒介,_名字)->_名字->+[修改内容](_名字,+B),
    ->[]
}




## end
#1302, 947:
%{
angle
%}

addpath('Matlab/space')

[x0,y0,z0]=transform_3D(pt0,an0(1),an0(2),an0(3),X0,Y0,Z0);
[x1,y1,z1]=transform_3D(pt1,an1(1),an1(2),an1(3),X1,Y1,Z1);

xs=x1(n)-x0(n0);
ys=y1(n)-y0(n0);

x=xs*cosd(angle)-ys*sind(angle);
y=ys*cosd(angle)+xs*sind(angle);

if strcmp(ref_ax,'zx') || strcmp(ref_ax,'ZX')
    y=-y;
elseif strcmp(ref_ax,'yz') || strcmp(ref_ax,'YZ')
    x=-x;
end

if ~isempty(names)
    list_name=split(names,', ');
    name=list_name{end+1-n_name};
    n_name=n_name+1;
end

if strcmp(unit_name,'cm')
    ans=sprintf('%.2f*cm,%.2f*cm',x/1e-2,y/1e-2);
elseif strcmp(unit_name,'inch')
    ans=sprintf('%.2f*inch,%.2f*inch',x/2.54e-2,y/2.54e-2);
elseif strcmp(unit_name,'mm')
    ans=sprintf('%.2f*mm,%.2f*mm',x/1e-3,y/1e-3);
elseif strcmp(unit_name,'um')
    ans=sprintf('%.2f*um,%.2f*um',x/1e-6,y/1e-6);
elseif strcmp(unit_name,'nm')
    ans=sprintf('%.2f*nm,%.2f*nm',x/1e-9,y/1e-9);
else
    ans=sprintf('%.2f,%.2f',x,y);
end



## end
#1305, 153:
"""


"""

+召唤规则(_题目,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_代码)...

->[==]"描述相对坐标"(,召唤星辰)...

->+整理描述(_题目,_代码)->+的(操作,+整理描述)...
->+召唤结构(_题目,_代码)->+的(操作,+召唤结构)



## end
#1307, 3291:
描述相对坐标#0"
召唤规则:...
降临规则:...



"(,)
的#1""(描述相对坐标#0,召唤规则#2)
召唤规则#2"\"\"\"


\"\"\"

+召唤规则(_题目,召唤星辰)->.(+召唤规则,操作)...
->召唤星辰(,_代码)...

->[==]\"描述相对坐标\"(,召唤星辰)...

->+整理描述(_题目,_代码)->+的(操作,+整理描述)...
->+召唤结构(_题目,_代码)->+的(操作,+召唤结构)


"(,)
的#3""(描述相对坐标#0,降临规则#4)
降临规则#4"
召唤结构:...
整理描述:...


"(,)
的#5""(降临规则#4,召唤结构#6)
召唤结构#6"\"\"\"
描述结构:...
库:...
+[新建阅读窗口](,描述结构)

\"\"\"
+召唤结构(_媒介,_凭依)->+[del](,+召唤结构)...
->的(召唤结构,描述结构)->的(召唤结构,库)...

->+顺序\"
\"(_凭依,)->+的(_凭依,+顺序)...

->+[code]([想],描述结构)->[想](_媒介,_凭依)...
->操作([想],)->[]{
    []=>的(操作,_操作)->_操作(_主语,_宾语)->_主语->_宾语=>[说](,_操作)...
        ->的(库,_条目)->[eq](_条目,_操作)...
        ->+[做](_主语,_宾语)->+[code](+[做],_条目)...
        ->+[.](+[做],+[临时文本])->[m_text](_操作,+[临时文本])
}

"(,)
的#7""(召唤结构#6,描述结构#8)
描述结构#8"\"\"\"
P代码:...

\"\"\"
+描述结构(_媒介,_凭依)->+操作(+描述结构,)...
->的(描述结构,P代码)...

->.\"坐标序号\"(_媒介,_坐标)...
->+[.]\"list_n\"([python],_坐标)->[python]\"i=0
state=True\"(Python,)...
->+坐标->+不终止->[]{
    +[code]([python]#1,P代码)->+[o]\"n\"([python]#1,+坐标)...
        =>[python]#1(Python,+不终止)...
        =>+单句描述(_媒介,_凭依)->+的(+操作,+单句描述)->[m_text](+坐标,+单句描述)
}


"(,)
的#9""(描述结构#8,P代码#10)
P代码#10"\"\"\"


\"\"\"

state=(i<len(list_n))
if state==True:
    n=int(list_n[i])
i=i+1



"(,)
的#11""(召唤结构#6,库#12)
库#12"
单句描述:...
在选择区域中, 将'单句描述'的\"0\"替换为\"1\"


"(,)
的#13""(库#12,单句描述#14)
单句描述#14"\"\"\"
M代码:...
+[新建阅读窗口](,M代码)
在选择区域中, 将'M代码'的\"0\"替换为\"1\"

\"\"\"
+单句描述(_媒介,_凭依)->+[del](,+单句描述)...
->的(单句描述,M代码)...

->.(+单句描述,_i)...
->.\"原点\"(_媒介,_原点)->.\"原点序号\"(_媒介,_i0)->.\"坐标\"(_媒介,_坐标)...

->+[文本结构_插入尾部](_凭依,+节点)...
    ->+节点\"%A距离%B为(%位移)\"...
->+[文本结构_插入](+节点,+A)->+[文本结构_插入](+节点,+B)...
->+[文本结构_插入](+节点,+位移)...

->+A\"坐标\"->+[增加内容](_i,+A)->+B\"坐标\"->+[增加内容](_i0,+B)...

->在(_原点,空间点#0)->朝向(_原点,方向#0)...
->的(_原点,X#0)->的(_原点,Y#0)->的(_原点,Z#0)...
->在(_坐标,空间点#1)->朝向(_坐标,方向#1)...
->的(_坐标,X#1)->的(_坐标,Y#1)->的(_坐标,Z#1)...

->+[matlab](Matlab,+位移)->+[code](+[matlab],M代码)...
->+[.]\"pt0\"(+[matlab],空间点#0)->+[.]\"an0\"(+[matlab],方向#0)...
->+[.]\"X0\"(+[matlab],X#0)->+[.]\"Y0\"(+[matlab],Y#0)->+[.]\"Z0\"(+[matlab],Z#0)...
->+[.]\"pt1\"(+[matlab],空间点#1)->+[.]\"an1\"(+[matlab],方向#1)...
->+[.]\"X1\"(+[matlab],X#1)->+[.]\"Y1\"(+[matlab],Y#1)->+[.]\"Z1\"(+[matlab],Z#1)...

->+[.]\"n0\"(+[matlab],_i0)->+[.]\"n\"(+[matlab],_i)...
->[]{
    []:->.\"角度\"(_媒介,_角度)->_角度->+[.]\"angle\"(+[matlab],_角度),
    ->+[临时文本]\"0\"->+[.]\"angle\"(+[matlab],+[临时文本])
}...
->[]{
    []:->.\"单位\"(_媒介,_单位)->_单位->+[.]\"unit_name\"(+[matlab],_单位),
    ->+[临时文本]\"m\"->+[.]\"angle\"(+[matlab],+[临时文本])
}
"(,)
的#15""(单句描述#14,M代码#16)
M代码#16"%{

%}

addpath('Matlab/space')

[x0,y0,z0]=transform_3D(pt0,an0(1),an0(2),an0(3),X0,Y0,Z0);
[x1,y1,z1]=transform_3D(pt1,an1(1),an1(2),an1(3),X1,Y1,Z1);

xs=x1(n)-x0(n0);
ys=y0(n0)-y1(n);

x=xs*cosd(angle)-ys*sind(angle);
y=ys*cosd(angle)+xs*sind(angle);


if strcmp(unit_name,'cm')
    ans=sprintf('%.2f*cm,%.2f*cm',x/1e-2,y/1e-2);
elseif strcmp(unit_name,'inch')
    ans=sprintf('%.2f*inch,%.2f*inch',x/2.54e-2,y/2.54e-2);
elseif strcmp(unit_name,'mm')
    ans=sprintf('%.2f*mm,%.2f*mm',x/1e-3,y/1e-3);
else
    ans=sprintf('%.2f,%.2f',x,y);
end


"(,)
的#17""(降临规则#4,整理描述#18)
整理描述#18"\"\"\"
+[修改内容](+[临时文本],记忆)
+[显示](,记忆)
记住\"Matlab\"

\"\"\"
+整理描述(_媒介,_凭依)->+[del](,+整理描述)...
->+[修改内容](+[临时文本],_凭依)...
->+[结构转文本](_凭依,_凭依)->+[记住](,_凭依)...
->+[删除结构](,_凭依)

"(,)

## end
### 结束