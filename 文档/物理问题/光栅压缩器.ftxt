### 节点
地址, 的, 光栅压缩器, 目录, 的, 的, 光栅原理, 的, 网页画板, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 输入, 输出, 选中框, 图形, 的, 的, 的, 的, 画图, 类型, 输出, 的, 的, 输入, 的, 的, 选中区域, 的, HTML, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 光栅1, 厚度, 中心, 半径, 角度, 面颜色, 线颜色, 线型, 线粗细, 名字, 的, 的, 的, 的, 的, 的, 的, 的, 的, 输入, 输出, 选中框, 图形, 的, 的, 的, 的, 画图, 类型, 输出, 的, 的, 输入, 的, 的, 选中区域, 的, HTML, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 光栅2, 起点, 终点, 线颜色, 线型, 线粗细, 的, 的, 的, 的, 的, 输入, 输出, 图形, 选中框, 的, 的, 的, 的, 画图, 类型, 的, 的, 输入, 输出, LaTeX数学记号, 的, 点线公式, 的, 的, 的, 选中区域, 的, HTML, 的, 的, 的, 的, 的, 的, 的, 的, 的, theta, 入射光线, 起点, 终点, 线颜色, 线型, 线粗细, 的, 的, 的, 的, 的, 输入, 输出, 图形, 选中框, 的, 的, 的, 的, 画图, 类型, 的, 的, 输入, 输出, LaTeX数学记号, 的, 点线公式, 的, 的, 的, 选中区域, 的, HTML, 的, 的, 的, 的, 的, 的, 的, 的, 的, beta, 内部光线1, 起点, 终点, 线颜色, 线型, 线粗细, 的, 的, 的, 的, 的, 输入, 输出, 图形, 选中框, 的, 的, 的, 的, 画图, 类型, 的, 的, 输入, 输出, LaTeX数学记号, 的, 点线公式, 的, 的, 的, 选中区域, 的, HTML, 的, 的, 的, 的, 的, 的, 的, 的, 的, 出射光线1, 起点, 终点, 线颜色, 线型, 线粗细, 的, 的, 的, 的, 的, 输入, 输出, 图形, 选中框, 的, 的, 的, 的, 画图, 类型, 的, 的, 输入, 输出, LaTeX数学记号, 的, 点线公式, 的, 的, 的, 选中区域, 的, HTML, 的, 的, 的, 的, 的, 的, 的, 的, 的, 内部光线2, 起点, 终点, 线颜色, 线型, 线粗细, 的, 的, 的, 的, 的, 输入, 输出, 图形, 选中框, 的, 的, 的, 的, 画图, 类型, 的, 的, 输入, 输出, LaTeX数学记号, 的, 点线公式, 的, 的, 的, 选中区域, 的, HTML, 的, 的, 的, 的, 的, 的, 的, 的, 的, 出射光线2, 起点, 终点, 线颜色, 线型, 线粗细, 的, 的, 的, 的, 的, 输入, 输出, 图形, 选中框, 的, 的, 的, 的, 画图, 类型, 的, 的, 输入, 输出, LaTeX数学记号, 的, 点线公式, 的, 的, 的, 选中区域, 的, HTML, 的, 的, 的, 的, 的, 的, 的, 的, 的, 法线1, 起始角度, 半径, 中心, 标记, 数值, 的, 的, 的, 的, 的, 输入, 的, HTML, 的, 画图, 等于, pt11, 等于, pt12, 等于, pt21, 等于, pt22, 等于, angle, 的, 的, 的, 的, 的, 的, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 输出, 的, 的, P代码, 类型, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 起始角度, 半径, 中心, 标记, 数值, 的, 的, 的, 的, 的, 输入, 的, HTML, 的, 画图, 等于, pt11, 等于, pt12, 等于, pt21, 等于, pt22, 等于, angle, 的, 的, 的, 的, 的, 的, 的, 输入, 的, 的, 的, 的, 的, 的, 的, 输出, 的, 的, P代码, 类型, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 起点, 终点, 线颜色, 线型, 线粗细, 文字, 位移距离, 的, 的, 的, 的, 的, 的, 的, 输入, 输出, 图形, 选中框, 的, 的, 的, 的, 画图, 类型, 的, 的, 输入, 输出, LaTeX数学记号, 的, 点线公式, 的, 的, 的, 选中区域, 的, HTML, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 间距, 面颜色, 线颜色, 线型, 线粗细, 文字, 字体, 尺寸, 起点, 的, 的, 的, 的, 的, 的, 的, 的, 输入, 输出, 选中框, 图形, 的, 的, 的, 的, 画图, 输出, 的, 的, 选中区域, 输出, 的, 的, HTML, 类型, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 矩形, 起点, 终点, 线颜色, 线型, 线粗细, 的, 的, 的, 的, 的, 输入, 输出, 图形, 选中框, 的, 的, 的, 的, 画图, 类型, 的, 的, 输入, 输出, LaTeX数学记号, 的, 点线公式, 的, 的, 的, 选中区域, 的, HTML, 的, 的, 的, 的, 的, 的, 的, 的, 的, 水平距离, 起点, 终点, 线颜色, 线型, 线粗细, 文字, 位移距离, 的, 的, 的, 的, 的, 的, 的, 输入, 输出, 图形, 选中框, 的, 的, 的, 的, 画图, 类型, 的, 的, 输入, 输出, LaTeX数学记号, 的, 点线公式, 的, 的, 的, 选中区域, 的, HTML, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 标记水平距离, 坐标系, 的, 坐标系, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 的, 光栅对, 参考, 参考2, html, 的, 的, 的, 光栅色散, 的, 的, 完整色散与二阶色散, html, 的, 波包, 的, 色散曲线, M函数, 的, 检验相位函数, M函数, 的, 验证推导, M函数, 的, 高阶相位, M函数, 的, grating_compressor_dtau, M函数, 的, 地址, 的, 测试, M函数, M函数, 的, 扫参数, M函数, 的, 直接扫参数, M函数, 的, 节点数目统计, 打开网页, grating_compressor_dtau, 的, 记忆, grating_compressor_dtau, 20220407, 的, 色散曲线, 的, 色散曲线, 20220420, 的, 20220422, 的, 打开网页, 20220529, 的, 的, 示意图场景, 的, G1, 的, G2, 的, M0, 的, 入射光0, y, 的, x, 的, 宽度, 的, 长度, 的, 空间点, 在, 类型, 的, 20220530, 的, y, 的, x, 的, 宽度, 的, 长度, 的, 空间点, 在, 类型, 的, y, 的, x, 的, 宽度, 的, 长度, 的, 空间点, 在, 类型, 的, 方向, 朝向, 方向, 朝向, 方向, 朝向, 20220603, 的, 20220604, 的, 的, grating_compressor_phase, M函数, 的, 地址, grating_compressor_phase, 的, grating_compressor_phase, 20220721, 的, 的, 散射路径, html, 的, 光栅对场景, 的, P1, 的, G2, 的, G1, 手, y, 的, x, 的, 空间点, 在, 宽度, 的, 长度, 的, 类型, 的, y, 的, x, 的, 空间点, 在, 宽度, 的, 长度, 的, 类型, 的, y, 的, x, 的, 空间点, 在, 宽度, 的, 长度, 的, 类型, 的, 的, 光线路径, M函数, 的, 的, 方向, 朝向, 的, 的, 方向, 朝向, 的, 的, 方向, 朝向, 的, 单发路径, 的, grating_compressor_path, M函数, 的, 地址, grating_compressor_path, 的, grating_compressor_path, 的, 偏移扫描, 光线路径, 的, 光线路径, 打开网页, 的, 参考公式, html, 的, 来源, 的, [1]., 的, [2]., 手, 表达式, 的, 公式, 的, 来源2, 表达式, 的, 公式, 的, 验证公式, M函数, 的, 公式库, 
### 关联
#, 2#0, #, #, 3#2, 2#6, #, 2#8, #, #, #, #, #, #, #, #, #, #, 27#9, 27#10, 27#11, 27#12, 27#13, 27#14, 27#15, 27#16, 27#17, #, #, #, #, 35#27, 35#28, 35#29, 35#30, #, #, #, 40#10, 40#11, #, 43#37, 43#40, #, 45#27, #, 59#9, 59#10, 59#11, 59#35, 59#36, 59#12, 59#43, 59#13, 59#14, 59#15, 59#16, 59#17, 59#45, #, #, #, #, #, #, #, #, #, #, 78#60, 78#61, 78#62, 78#63, 78#64, 78#65, 78#66, 78#67, 78#68, #, #, #, #, 86#78, 86#79, 86#80, 86#81, #, #, #, 91#61, 91#62, #, 94#88, 94#91, #, 96#78, #, 110#60, 110#61, 110#62, 110#86, 110#87, 110#63, 110#94, 110#64, 110#65, 110#66, 110#67, 110#68, 110#96, #, #, #, #, #, #, 121#111, 121#112, 121#113, 121#114, 121#115, #, #, #, #, 129#121, 129#122, 129#123, 129#124, #, #, 133#111, 133#112, #, #, #, 137#135, #, 141#133, 141#134, 141#137, #, 143#121, #, 154#111, 154#112, 154#129, 154#130, 154#141, 154#113, 154#114, 154#115, 154#143, 154#370, #, #, #, #, #, #, 165#155, 165#156, 165#157, 165#158, 165#159, #, #, #, #, 173#165, 173#166, 173#167, 173#168, #, #, 177#155, 177#156, #, #, #, 181#179, #, 185#177, 185#178, 185#181, #, 187#165, #, 198#155, 198#156, 198#173, 198#174, 198#185, 198#157, 198#158, 198#159, 198#187, 198#370, #, #, #, #, #, #, 209#199, 209#200, 209#201, 209#202, 209#203, #, #, #, #, 217#209, 217#210, 217#211, 217#212, #, #, 221#199, 221#200, #, #, #, 225#223, #, 229#221, 229#222, 229#225, #, 231#209, #, 241#199, 241#200, 241#217, 241#218, 241#229, 241#201, 241#202, 241#203, 241#231, #, #, #, #, #, #, 252#242, 252#243, 252#244, 252#245, 252#246, #, #, #, #, 260#252, 260#253, 260#254, 260#255, #, #, 264#242, 264#243, #, #, #, 268#266, #, 272#264, 272#265, 272#268, #, 274#252, #, 284#242, 284#243, 284#260, 284#261, 284#272, 284#244, 284#245, 284#246, 284#274, #, #, #, #, #, #, 295#285, 295#286, 295#287, 295#288, 295#289, #, #, #, #, 303#295, 303#296, 303#297, 303#298, #, #, 307#285, 307#286, #, #, #, 311#309, #, 315#307, 315#308, 315#311, #, 317#295, #, 327#285, 327#286, 327#303, 327#304, 327#315, 327#287, 327#288, 327#289, 327#317, #, #, #, #, #, #, 338#328, 338#329, 338#330, 338#331, 338#332, #, #, #, #, 346#338, 346#339, 346#340, 346#341, #, #, 350#328, 350#329, #, #, #, 354#352, #, 358#350, 358#351, 358#354, #, 360#338, #, 370#328, 370#329, 370#346, 370#347, 370#358, 370#330, 370#331, 370#332, 370#360, #, #, #, #, #, #, 381#374, 381#373, 381#372, 381#371, 381#375, #, 383#381, #, 385#381, #, 387#111, #, 389#112, #, 391#328, #, 393#329, #, 395#375, #, 403#371, 403#373, 403#395, 403#393, 403#391, 403#389, 403#387, #, 411#387, 411#389, 411#391, 411#393, 411#395, 411#373, 411#371, #, 414#403, 414#411, #, #, 153#371, 153#372, 153#373, 153#383, 153#374, 153#385, 153#386, 153#387, 153#388, 153#389, 153#390, 153#391, 153#392, 153#393, 153#394, 153#395, 153#414, 153#415, 153#375, #, #, #, #, #, 445#438, 445#437, 445#436, 445#435, 445#439, #, 447#445, #, 449#445, #, 451#155, #, 453#156, #, 455#328, #, 457#329, #, 459#439, #, 467#435, 467#437, 467#459, 467#457, 467#455, 467#453, 467#451, #, 475#451, 475#453, 475#455, 475#457, 475#459, 475#437, 475#435, #, 478#467, 478#475, #, #, 197#435, 197#436, 197#437, 197#447, 197#438, 197#449, 197#450, 197#451, 197#452, 197#453, 197#454, 197#455, 197#456, 197#457, 197#458, 197#459, 197#478, 197#479, 197#439, #, #, #, #, #, #, #, 513#499, 513#500, 513#501, 513#502, 513#503, 513#504, 513#505, #, #, #, #, 521#513, 521#514, 521#515, 521#516, #, #, 525#499, 525#500, #, #, #, 529#527, #, 533#525, 533#526, 533#529, #, 535#513, #, 547#499, 547#500, 547#521, 547#522, 547#533, 547#501, 547#502, 547#503, 547#504, 547#505, 547#535, #, #, #, #, #, #, #, #, #, 564#548, 564#549, 564#550, 564#551, 564#552, 564#553, 564#554, 564#555, #, #, #, #, 572#564, 572#565, 572#566, 572#567, #, #, 576#573, 576#564, #, #, 580#577, 580#564, #, #, 594#572, 594#576, 594#580, 594#555, 594#554, 594#581, 594#552, 594#553, 594#550, 594#551, 594#548, 594#549, #, #, #, #, #, #, 605#595, 605#596, 605#597, 605#598, 605#599, #, #, #, #, 613#605, 613#606, 613#607, 613#608, #, #, 617#595, 617#596, #, #, #, 621#619, #, 625#617, 625#618, 625#621, #, 627#605, #, 637#595, 637#596, 637#613, 637#614, 637#625, 637#597, 637#598, 637#599, 637#627, #, #, #, #, #, #, #, #, 652#638, 652#639, 652#640, 652#641, 652#642, 652#643, 652#644, #, #, #, #, 660#652, 660#653, 660#654, 660#655, #, #, 664#638, 664#639, #, #, #, 668#666, #, 672#664, 672#665, 672#668, #, 674#652, #, 686#638, 686#639, 686#660, 686#661, 686#672, 686#640, 686#641, 686#642, 686#643, 686#644, 686#674, #, 703#, 703#59, 703#, 703#110, 703#154, 703#198, 703#241, 703#284, 703#327, 703#370, 703#153, 703#197, 703#547, 703#594, 703#637, 703#686, #, #, #, 710#, 710#703, 710#704, 710#705, #, 2#710, 2#713, #, 713#, 2#716, #, 713#718, #, 718#, 718#721, #, 721#, 710#724, #, 724#, 718#727, #, 727#, 718#730, #, 730#, 730#733, #, 730#735, #, 735#, #, 713#739, #, 739#, 739#742, #, 742#, 3#745, #, #704, #730, 749#747, 3#, #, #, 745#751, #718, 749#753, #, #, 745#756, #, 745#758, #705, #, 745#761, 713#764, #, 764#766, #, 764#768, #, 764#770, #, 764#772, #, #, 766#773, #, 766#775, #, 766#777, #, 766#779, #, 766#781, #, 766#783, #, 745#785, #, 768#787, #, 768#789, #, 768#791, #, 768#793, #, 768#795, #, 768#797, #, 770#799, #, 770#801, #, 770#803, #, 770#805, #, 770#807, #, 770#809, #, 770#811, #, 766#813, #, 768#815, #, 745#817, #, 745#819, 718#822, #, 822#, 822#825, #, #822, 749#826, #, #, 745#829, 2#832, #, 832#, 832#835, #, 835#837, #, 835#839, #, 835#841, #, #835, #, 841#843, #, 841#845, #, 841#847, #, 841#849, #, 841#851, #, 841#853, #, 839#855, #, 839#857, #, 839#859, #, 839#861, #, 839#863, #, 839#865, #, 837#867, #, 837#869, #, 837#871, #, 837#873, #, 837#875, #, 837#877, 835#880, #, 880#, 835#884, 835#885, #, 839#884, 835#888, 835#889, #, 841#888, 835#892, 835#893, #, 837#892, 880#895, #, 880#897, #, 897#, 897#900, #, #897, 749#901, #, 880#905, #, #880, 749#906, #, #704, 2#911, #, 911#, 911#914, #, 911#916, #, 911#918, #, #911, #, 916#920, 916#, 911#924, #, #, 918#925, 918#, 911#929, #, 929#, 2#932, #, 
### 内容
#0, 18:
文档\物理问题\光栅压缩器.ftxt
## end
#2, 314:
+[返回目录](,光栅压缩器)
地址::文档\物理问题\光栅压缩器.ftxt

网页画板::文档\S应用\网页画板.ftxt
光栅原理::文档\物理问题\光栅原理.ftxt
波包::文档\物理问题\波包.ftxt


公式库:...
+[新建阅读窗口](,公式库)

Nini, 打开星辰(文件)

Nini, 导入PPT的库
Nini, 导入网页画板的库

我打算把光栅原理里面的公式补全, 然后在这里研究高阶色散的问题. 
光栅色散(html):...
完整色散与二阶色散(html):...
散射路径(html):...
参考公式(html):...
+[H函数](,光栅色散)
+[新建阅读窗口](,参考公式)





## end
#3, 49:
光栅压缩器:...
创建于 20210721

节点数目统计::
+[设置结构](,节点数目统计)
## end
#6, 17:
文档\物理问题\光栅原理.ftxt
## end
#8, 16:
文档\S应用\网页画板.ftxt
## end
#9, 2:
10
## end
#10, 11:
17.0, -40.0
## end
#11, 18:
48.373546489791295
## end
#12, 3:
120
## end
#13, 11:
255,255,255
## end
#14, 5:
0,0,0
## end
#15, 8:
DashLine
## end
#16, 1:
2
## end
#17, 9:
Grating A
## end
#27, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#29, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#30, 804:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


x0=pt[0]
y0=pt[1]
M=qp.transform()
M.translate(x0,y0)
M.rotate(-angle+90)
M.translate(-x0,-y0)

M0=qp.transform()
qp.setTransform(M)

qp.drawRect(x0-r,y0,2*r,d)

qp.setTransform(M0)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(x0-area,y0+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#35, 804:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


x0=pt[0]
y0=pt[1]
M=qp.transform()
M.translate(x0,y0)
M.rotate(-angle+90)
M.translate(-x0,-y0)

M0=qp.transform()
qp.setTransform(M)

qp.drawRect(x0-r,y0,2*r,d)

qp.setTransform(M0)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(x0-area,y0+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#36, 2:
圆形
## end
#37, 14:
+[返回目录]
+[内容]

## end
#40, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#43, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#45, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#59, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#60, 2:
10
## end
#61, 13:
-13.0, -140.0
## end
#62, 18:
48.373546489791295
## end
#63, 3:
-60
## end
#64, 11:
255,255,255
## end
#65, 5:
0,0,0
## end
#66, 8:
DashLine
## end
#67, 1:
2
## end
#68, 9:
Grating B
## end
#78, 80:
+[返回目录](,输入)

角度::0
面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2
厚度::10
名字::镜子

## end
#80, 493:
"""
+[返回目录](,选中框)

"""

X=[pt[0],pt[0]+r*np.cos(theta),pt[0]+r]
Y=[pt[1],pt[1]-r*np.sin(theta),pt[1]]
R=6

qp.drawEllipse(pt[0]-r,pt[1]-r,2*r,2*r)

qp.setPen(QPen(Qt.black,1,Qt.DashLine))
qp.drawLine(X[0],Y[0],X[1],Y[1])
qp.setPen(QPen(Qt.black,1,Qt.SolidLine))
qp.drawLine(X[0],Y[0],X[2],Y[2])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))



## end
#81, 804:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


x0=pt[0]
y0=pt[1]
M=qp.transform()
M.translate(x0,y0)
M.rotate(-angle+90)
M.translate(-x0,-y0)

M0=qp.transform()
qp.setTransform(M)

qp.drawRect(x0-r,y0,2*r,d)

qp.setTransform(M0)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(x0-area,y0+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#86, 804:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:....
选中框:...

"""
pt=中心
r=半径[0]
d=厚度[0]
angle=角度[0]
theta=np.deg2rad(angle)
area=100
size_F=10

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0:
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


x0=pt[0]
y0=pt[1]
M=qp.transform()
M.translate(x0,y0)
M.rotate(-angle+90)
M.translate(-x0,-y0)

M0=qp.transform()
qp.setTransform(M)

qp.drawRect(x0-r,y0,2*r,d)

qp.setTransform(M0)
qp.setBrush(QBrush())
qp.setPen(QPen())

qp.setFont(QFont("Decorative",size_F))
qp.drawText(x0-area,y0+(r+10)-area,2*area,2*area,Qt.AlignHCenter|Qt.AlignVCenter,名字)



## end
#87, 2:
圆形
## end
#88, 14:
+[返回目录]
+[内容]

## end
#91, 39:
+[返回目录](,输入)
+[内容]
中心::200,100
半径::100

## end
#94, 164:
"""
+[返回目录](,选中区域)
输入:...

"""

pt=中心
r=半径[0]
pt0=mouse_pos

Dx=pt[0]-pt0[0]
Dy=pt[1]-pt0[1]
Dr=np.sqrt(Dx**2+Dy**2)

if Dr<=r:
    state=True
else:
    state=False
## end
#96, 728:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

pt=[%中心];
r=%半径;
d=%厚度;
angle=%角度;
theta=angle/180*Math.PI;
area=100;
x0=pt[0];
y0=pt[1];


ctx.save();

ctx.translate(x0,y0);
ctx.rotate(-theta+90/180*Math.PI);
ctx.translate(-x0,-y0);

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(x0-r,y0,2*r,d);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(x0-r,y0,2*r,d);
}
ctx.restore()

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
ctx.fillText('%名字',x0,y0+r+10);



/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#110, 148:
+[返回目录](,镜子)
+[设置结构](,镜子)

中心::200,100
半径::100
厚度::10
类型::圆形
角度::0
名字::镜子


面颜色::255,255,0
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...

## end
#111, 38:
-463.9490300000001, -34.05676999999999
## end
#112, 10:
9.5, -34.5
## end
#113, 5:
0,0,0
## end
#114, 8:
DashLine
## end
#115, 1:
1
## end
#121, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#123, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#124, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#129, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#130, 2:
直线
## end
#133, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#134, 14:
+[返回目录]
+[内容]

## end
#135, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#137, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#141, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#143, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#153, 113:
+[返回目录](,角度)

数值::
中心::
半径::20
起始角度::
类型::角度

标记::theta

画图:...
HTML:...
P代码:...
+[P函数](,P代码)



+[创建输入](标记,画图)


## end
#154, 144:
+[返回目录](,直线)
+[设置结构](,入射光线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#155, 39:
-29.06394388401367, -131.12721744944702
## end
#156, 37:
7.351082000000034, -34.05676999999999
## end
#157, 7:
255,0,0
## end
#158, 8:
DashLine
## end
#159, 1:
1
## end
#165, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#167, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#168, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#173, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#174, 2:
直线
## end
#177, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#178, 14:
+[返回目录]
+[内容]

## end
#179, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#181, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#185, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#187, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#197, 112:
+[返回目录](,角度)

数值::
中心::
半径::20
起始角度::
类型::角度

标记::beta

画图:...
HTML:...
P代码:...
+[P函数](,P代码)



+[创建输入](标记,画图)


## end
#198, 129:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#199, 13:
240.0, -131.0
## end
#200, 13:
-27.0, -131.0
## end
#201, 7:
255,0,0
## end
#202, 8:
DashLine
## end
#203, 1:
1
## end
#209, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#211, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#212, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#217, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#218, 2:
直线
## end
#221, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#222, 14:
+[返回目录]
+[内容]

## end
#223, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#225, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#229, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#231, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#241, 129:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#242, 10:
7.0, -34.0
## end
#243, 12:
-1.0, -147.0
## end
#244, 7:
0,0,255
## end
#245, 8:
DashLine
## end
#246, 1:
1
## end
#252, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#254, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#255, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#260, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#261, 2:
直线
## end
#264, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#265, 14:
+[返回目录]
+[内容]

## end
#266, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#268, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#272, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#274, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#284, 129:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#285, 13:
244.0, -148.0
## end
#286, 6:
0,-148
## end
#287, 7:
0,0,255
## end
#288, 8:
DashLine
## end
#289, 1:
1
## end
#295, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#297, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#298, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#303, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#304, 2:
直线
## end
#307, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#308, 14:
+[返回目录]
+[内容]

## end
#309, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#311, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#315, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#317, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#327, 129:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#328, 39:
-44.73013599999998, -122.80741700000003
## end
#329, 38:
5.482750000000095, -36.123484999999995
## end
#330, 5:
0,0,0
## end
#331, 8:
DashLine
## end
#332, 1:
1
## end
#338, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#340, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#341, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#346, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#347, 2:
直线
## end
#350, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#351, 14:
+[返回目录]
+[内容]

## end
#352, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#354, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#358, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#360, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#370, 129:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#371, 18:
179.94636127792435
## end
#372, 6:
[20.0]
## end
#373, 37:
6.424844134934674, -34.49712112339934
## end
#374, 5:
theta
## end
#375, 17:
59.97146796251176
## end
#381, 121:
+[返回目录]
+[内容]
标记::%数值
中心::-338.8789230341691, -3.8202594274802757
半径::10
起始角度::136.10929165904932
数值::62.220685781962224

## end
#383, 775:
/*
+[返回目录](,HTML)

+[新建阅读窗口](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var pt0=[%中心];
var r=%半径;
var Dangle=%数值;
var angle0=%起始角度;
var text="%标记";

dx=1.5*r*Math.cos((angle0+Dangle)/180*Math.PI/2);
dy=1.5*r*Math.sin((angle0+Dangle)/180*Math.PI/2);


ctx.beginPath();
if(Dangle>0) {
    ctx.arc(pt0[0],pt0[1],r,angle0/180*Math.PI,(angle0+Dangle)/180*Math.PI);
} else {
    ctx.arc(pt0[0],pt0[1],r,(angle0+Dangle)/180*Math.PI,angle0/180*Math.PI);
}

ctx.strokeStyle='rgba(0,0,0)';
ctx.stroke();

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center';
ctx.textBaseline='middle';
ctx.font=8*2+'px serif';

if (text[0]==='%') {
    ctx.fillText(`${-Dangle.toFixed(2)}`,pt0[0]+dx,pt0[1]+dy);
} else {
    ctx.fillText(text,pt0[0]+dx,pt0[1]+dy);
}


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/

## end
#385, 562:
"""
+[返回目录](,画图)

输入:...
+[设置结构](,输入)

"""

pt0=中心
r=半径[0]
angle0=-起始角度[0]
Dangle=-数值[0]

dx=r*np.cos(np.deg2rad(angle0+Dangle)/2)
dy=r*np.sin(np.deg2rad(angle0+Dangle)/2)


qp.setPen(QPen(QColor(0,0,0)))
qp.setBrush(QBrush(QColor(255,255,255)))

qp.drawArc(pt0[0]-r,pt0[1]-r,2*r,2*r,angle0*16,Dangle*16)

qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",10))


if 标记=='%数值':
    qp.drawText(pt0[0]+dx,pt0[1]+dy,"%.2f"%(Dangle))
else:
    qp.drawText(pt0[0]+dx,pt0[1]+dy,str(标记))

qp.drawPoint(pt0[0]+dx,pt0[1]+dy)

qp.setFont(QFont())




## end
#387, 38:
-463.9490300000001, -34.05676999999999
## end
#389, 10:
9.5, -34.5
## end
#391, 39:
-44.73013599999998, -122.80741700000003
## end
#393, 38:
5.482750000000095, -36.123484999999995
## end
#395, 17:
59.97146796251176
## end
#403, 14:
+[返回目录]
+[内容]

## end
#411, 62:
+[返回目录]
+[内容]
pt11::
pt12::
pt21::
pt22::
angle::
中心::
起始角度::

## end
#414, 940:
"""
+[返回目录](,P代码)

+[P函数](,P代码)

输出:...
+[设置结构](,输出)

"""

Dx1=pt11[0]-pt12[0]
Dy1=pt11[1]-pt12[1]

Dx2=pt21[0]-pt22[0]
Dy2=pt21[1]-pt22[1]

D1=pt11[0]*Dy1-pt11[1]*Dx1
D2=pt21[0]*Dy2-pt21[1]*Dx2

L=Dy1*Dx2-Dy2*Dx1
if L==0:
    pt0="None"
else:
    pt0=[(D1*Dx2-D2*Dx1)/L, (D1*Dy2-D2*Dy1)/L]
    if np.sqrt((pt0[0]-pt11[0])**2+(pt0[1]-pt11[1])**2) < np.sqrt((pt0[0]-pt12[0])**2+(pt0[1]-pt12[1])**2):
        Dx1=-Dx1
        Dy1=-Dy1
    
    if np.sqrt((pt0[0]-pt21[0])**2+(pt0[1]-pt21[1])**2) < np.sqrt((pt0[0]-pt22[0])**2+(pt0[1]-pt22[1])**2):
        Dx2=-Dx2
        Dy2=-Dy2

    sign=np.sign(Dx1*Dy2-Dx2*Dy1)
    Dtheta=np.arccos((Dx1*Dx2+Dy1*Dy2)/np.sqrt((Dx1**2+Dy1**2)*(Dx2**2+Dy2**2)))
    angle=np.rad2deg(Dtheta)*sign

    theta0=np.arccos(Dx1/np.sqrt(Dx1**2+Dy1**2))
    angle0=np.rad2deg(theta0)*np.sign(Dy1)

    print(Dy1/np.sqrt(Dx1**2+Dy1**2),theta0,angle0)

    中心=pt0
    起始角度=angle0


"""
+[P函数](,P代码)
+[设置结构](,输出)

"""
## end
#415, 2:
角度
## end
#435, 19:
-110.56308679580577
## end
#436, 6:
[20.0]
## end
#437, 38:
8.584541118517363, -30.768774848590777
## end
#438, 4:
beta
## end
#439, 18:
-9.519083963752843
## end
#445, 121:
+[返回目录]
+[内容]
标记::%数值
中心::-338.8789230341691, -3.8202594274802757
半径::10
起始角度::136.10929165904932
数值::62.220685781962224

## end
#447, 775:
/*
+[返回目录](,HTML)

+[新建阅读窗口](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var pt0=[%中心];
var r=%半径;
var Dangle=%数值;
var angle0=%起始角度;
var text="%标记";

dx=1.5*r*Math.cos((angle0+Dangle)/180*Math.PI/2);
dy=1.5*r*Math.sin((angle0+Dangle)/180*Math.PI/2);


ctx.beginPath();
if(Dangle>0) {
    ctx.arc(pt0[0],pt0[1],r,angle0/180*Math.PI,(angle0+Dangle)/180*Math.PI);
} else {
    ctx.arc(pt0[0],pt0[1],r,(angle0+Dangle)/180*Math.PI,angle0/180*Math.PI);
}

ctx.strokeStyle='rgba(0,0,0)';
ctx.stroke();

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center';
ctx.textBaseline='middle';
ctx.font=8*2+'px serif';

if (text[0]==='%') {
    ctx.fillText(`${-Dangle.toFixed(2)}`,pt0[0]+dx,pt0[1]+dy);
} else {
    ctx.fillText(text,pt0[0]+dx,pt0[1]+dy);
}


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/

## end
#449, 562:
"""
+[返回目录](,画图)

输入:...
+[设置结构](,输入)

"""

pt0=中心
r=半径[0]
angle0=-起始角度[0]
Dangle=-数值[0]

dx=r*np.cos(np.deg2rad(angle0+Dangle)/2)
dy=r*np.sin(np.deg2rad(angle0+Dangle)/2)


qp.setPen(QPen(QColor(0,0,0)))
qp.setBrush(QBrush(QColor(255,255,255)))

qp.drawArc(pt0[0]-r,pt0[1]-r,2*r,2*r,angle0*16,Dangle*16)

qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",10))


if 标记=='%数值':
    qp.drawText(pt0[0]+dx,pt0[1]+dy,"%.2f"%(Dangle))
else:
    qp.drawText(pt0[0]+dx,pt0[1]+dy,str(标记))

qp.drawPoint(pt0[0]+dx,pt0[1]+dy)

qp.setFont(QFont())




## end
#451, 39:
-29.06394388401367, -131.12721744944702
## end
#453, 37:
7.351082000000034, -34.05676999999999
## end
#455, 39:
-44.73013599999998, -122.80741700000003
## end
#457, 38:
5.482750000000095, -36.123484999999995
## end
#459, 18:
-9.519083963752843
## end
#467, 14:
+[返回目录]
+[内容]

## end
#475, 62:
+[返回目录]
+[内容]
pt11::
pt12::
pt21::
pt22::
angle::
中心::
起始角度::

## end
#478, 940:
"""
+[返回目录](,P代码)

+[P函数](,P代码)

输出:...
+[设置结构](,输出)

"""

Dx1=pt11[0]-pt12[0]
Dy1=pt11[1]-pt12[1]

Dx2=pt21[0]-pt22[0]
Dy2=pt21[1]-pt22[1]

D1=pt11[0]*Dy1-pt11[1]*Dx1
D2=pt21[0]*Dy2-pt21[1]*Dx2

L=Dy1*Dx2-Dy2*Dx1
if L==0:
    pt0="None"
else:
    pt0=[(D1*Dx2-D2*Dx1)/L, (D1*Dy2-D2*Dy1)/L]
    if np.sqrt((pt0[0]-pt11[0])**2+(pt0[1]-pt11[1])**2) < np.sqrt((pt0[0]-pt12[0])**2+(pt0[1]-pt12[1])**2):
        Dx1=-Dx1
        Dy1=-Dy1
    
    if np.sqrt((pt0[0]-pt21[0])**2+(pt0[1]-pt21[1])**2) < np.sqrt((pt0[0]-pt22[0])**2+(pt0[1]-pt22[1])**2):
        Dx2=-Dx2
        Dy2=-Dy2

    sign=np.sign(Dx1*Dy2-Dx2*Dy1)
    Dtheta=np.arccos((Dx1*Dx2+Dy1*Dy2)/np.sqrt((Dx1**2+Dy1**2)*(Dx2**2+Dy2**2)))
    angle=np.rad2deg(Dtheta)*sign

    theta0=np.arccos(Dx1/np.sqrt(Dx1**2+Dy1**2))
    angle0=np.rad2deg(theta0)*np.sign(Dy1)

    print(Dy1/np.sqrt(Dx1**2+Dy1**2),theta0,angle0)

    中心=pt0
    起始角度=angle0


"""
+[P函数](,P代码)
+[设置结构](,输出)

"""
## end
#479, 2:
角度
## end
#499, 37:
9.009738751968428, -152.1073579834598
## end
#500, 37:
61.88526633696034, -65.13094666611808
## end
#501, 5:
0,0,0
## end
#502, 8:
DashLine
## end
#503, 1:
1
## end
#504, 1:
D
## end
#505, 3:
-80
## end
#513, 50:
线颜色::0,0,0
线型::DashLine
线粗细::2
文字::10 cm
位移距离::20

## end
#515, 1610:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

angle=30
l=20
D=位移距离[0]
d=10
text=文字


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush(QColor(edgeColor[0],edgeColor[1],edgeColor[2])))

r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
if r!=0:
    theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]

Dx=D*np.cos(np.deg2rad(theta-90))
Dy=-D*np.sin(np.deg2rad(theta-90))
pt10=[0,0]
pt20=[0,0]
pt10[0]=pt1[0]+Dx
pt10[1]=pt1[1]+Dy
pt20[0]=pt2[0]+Dx
pt20[1]=pt2[1]+Dy

path1=QPainterPath()
path1.moveTo(pt10[0],pt10[1])
path1.lineTo(pt10[0]+dp21[0],pt10[1]+dp21[1])
path1.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1])
path1.lineTo(pt10[0],pt10[1])

path2=QPainterPath()
path2.moveTo(pt20[0],pt20[1])
path2.lineTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])
path2.lineTo(pt20[0],pt20[1])

qp.drawPath(path1)
qp.drawPath(path2)
qp.drawLine(pt1[0],pt1[1],pt10[0],pt10[1])
qp.drawLine(pt2[0],pt2[1],pt20[0],pt20[1])


dx=d*np.cos(np.deg2rad(theta-90))
dy=-d*np.sin(np.deg2rad(theta-90))
pt0=[0,0]
pt0[0]=(pt10[0]+pt20[0])/2+dx
pt0[1]=(pt10[1]+pt20[1])/2+dy

L=300
H=100
qp.drawText(pt0[0]-L/2,pt0[1]-H/2,L,H,Qt.AlignHCenter|Qt.AlignVCenter,text)

qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])

qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#516, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#521, 1610:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

angle=30
l=20
D=位移距离[0]
d=10
text=文字


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush(QColor(edgeColor[0],edgeColor[1],edgeColor[2])))

r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
if r!=0:
    theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]

Dx=D*np.cos(np.deg2rad(theta-90))
Dy=-D*np.sin(np.deg2rad(theta-90))
pt10=[0,0]
pt20=[0,0]
pt10[0]=pt1[0]+Dx
pt10[1]=pt1[1]+Dy
pt20[0]=pt2[0]+Dx
pt20[1]=pt2[1]+Dy

path1=QPainterPath()
path1.moveTo(pt10[0],pt10[1])
path1.lineTo(pt10[0]+dp21[0],pt10[1]+dp21[1])
path1.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1])
path1.lineTo(pt10[0],pt10[1])

path2=QPainterPath()
path2.moveTo(pt20[0],pt20[1])
path2.lineTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])
path2.lineTo(pt20[0],pt20[1])

qp.drawPath(path1)
qp.drawPath(path2)
qp.drawLine(pt1[0],pt1[1],pt10[0],pt10[1])
qp.drawLine(pt2[0],pt2[1],pt20[0],pt20[1])


dx=d*np.cos(np.deg2rad(theta-90))
dy=-d*np.sin(np.deg2rad(theta-90))
pt0=[0,0]
pt0[0]=(pt10[0]+pt20[0])/2+dx
pt0[1]=(pt10[1]+pt20[1])/2+dy

L=300
H=100
qp.drawText(pt0[0]-L/2,pt0[1]-H/2,L,H,Qt.AlignHCenter|Qt.AlignVCenter,text)

qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])

qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#522, 2:
直线
## end
#525, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#526, 14:
+[返回目录]
+[内容]

## end
#527, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#529, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#533, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#535, 1487:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var pt1=[%起点];
var pt2=[%终点];


//arrows
var angle=30/180*Math.PI;
var l=20;
var D=%位移距离;
var d=10;

r=Math.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2);
if (r!=0) {
    theta=Math.sign(pt1[1]-pt2[1])*Math.acos((pt2[0]-pt1[0])/r);
}

dp21=[l*Math.cos(theta-angle/2),-l*Math.sin(theta-angle/2)];
dp22=[l*Math.cos(theta+angle/2),-l*Math.sin(theta+angle/2)];

Dx=D*Math.cos(theta-90/180*Math.PI);
Dy=-D*Math.sin(theta-90/180*Math.PI);
pt10=[0,0];
pt20=[0,0];
pt10[0]=pt1[0]+Dx;
pt10[1]=pt1[1]+Dy;
pt20[0]=pt2[0]+Dx;
pt20[1]=pt2[1]+Dy;


ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();


ctx.moveTo(pt10[0],pt10[1]);
ctx.lineTo(pt10[0]+dp21[0],pt10[1]+dp21[1]);
ctx.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1]);
ctx.lineTo(pt10[0],pt10[1]);

ctx.moveTo(pt20[0],pt20[1]);
ctx.lineTo(pt20[0]-dp21[0],pt20[1]-dp21[1]);
ctx.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1]);
ctx.lineTo(pt20[0],pt20[1]);

ctx.moveTo(pt1[0],pt1[1]);
ctx.lineTo(pt10[0],pt10[1]);
ctx.moveTo(pt2[0],pt2[1]);
ctx.lineTo(pt20[0],pt20[1]);

ctx.moveTo(pt10[0],pt10[1]);
ctx.lineTo(pt20[0],pt20[1]);

ctx.stroke()
ctx.fill()


// text
dx=d*Math.cos(theta-90/180*Math.PI)
dy=-d*Math.sin(theta-90/180*Math.PI)
pt0=[0,0]
pt0[0]=(pt10[0]+pt20[0])/2+dx
pt0[1]=(pt10[1]+pt20[1])/2+dy


ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
L=300
H=100
ctx.fillText('%文字',pt0[0],pt0[1]);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#547, 125:
+[返回目录](,长度)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1
文字::10 cm
位移距离::20

画图:...
选中区域:...
HTML:...


## end
#548, 4:
None
## end
#549, 4:
None
## end
#550, 8:
DashLine
## end
#551, 1:
2
## end
#552, 3:
l_1
## end
#553, 2:
10
## end
#554, 38:
45.501511843215226, 43.702116580501304
## end
#555, 40:
-2.9574080317545715, -127.69909289407087
## end
#564, 101:
+[返回目录](,输入)

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::1
文字::测试
字体::20
尺寸::100,100
起点::-200,100

## end
#566, 677:
"""
+[返回目录](,选中框)

"""


X=[pt[0],pt[0]+size[0]/2,pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]/2,pt[1]+size[1]]
R=6

qp.setBrush(QBrush())
qp.drawRect(pt[0],pt[1],size[0],size[1])

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[0]-R,2*R,2*R)

if size[0]>30 or size[0]<-30:
    qp.drawEllipse(X[1]-R,Y[0]-R,2*R,2*R)
    qp.drawEllipse(X[1]-R,Y[2]-R,2*R,2*R)

if size[1]>30 or size[1]<-30:
    qp.drawEllipse(X[0]-R,Y[1]-R,2*R,2*R)
    qp.drawEllipse(X[2]-R,Y[1]-R,2*R,2*R)


qp.drawEllipse(X[0]-R,Y[2]-R,2*R,2*R)
qp.drawEllipse(X[2]-R,Y[2]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))

## end
#567, 855:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#572, 855:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...

图形:...
选中框:...

"""


pt=起点
size=尺寸
size_F=字体[0]

lineWidth=线粗细[0]
lineType=线型

if len(面颜色)==0 or 面颜色=='None':
    qp.setBrush(QBrush())
else:
    faceColor=面颜色
    qp.setBrush(QBrush(QColor(faceColor[0],faceColor[1],faceColor[2])))

if len(线颜色)==0 or 线颜色=='None':
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawRect(pt[0],pt[1],size[0],size[1])
qp.setBrush(QBrush())
qp.setPen(QPen())


qp.setFont(QFont("Decorative",size_F))
qp.drawText(pt[0],pt[1],size[0],size[1],Qt.AlignHCenter|Qt.AlignVCenter,文字)
qp.setFont(QFont())

#if isinstance(文字,str):
#    qp.setFont(QFont("Decorative",size_F))
#    dy=size_F*1.4
#    dx=len(文字)*size_F*1.65
#    qp.drawText(pt[0]-dx/2+size[0]/2,pt[1]+dy/2+size[1]/2,文字)
#    qp.setFont(QFont())





## end
#573, 14:
+[返回目录]
+[内容]

## end
#576, 231:
"""
+[返回目录](,选中区域)
输入:...
+[设置结构](,输入)

"""

pt=起点
pt0=mouse_pos
size=尺寸

X=[pt[0],pt[0]+size[0]]
Y=[pt[1],pt[1]+size[1]]

if (pt0[0]-X[0])*(pt0[0]-X[1])<=0 and (pt0[1]-Y[0])*(pt0[1]-Y[1])<=0:
    state=True
else:
    state=False


## end
#577, 14:
+[返回目录]
+[内容]

## end
#580, 655:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/


var size=[%尺寸];
var pos=[%起点];

if('%线颜色'==='None') {
	ctx.strokeStyle='rgba(255,255,255)';
} else {
	ctx.strokeStyle='rgb(%线颜色)';
        ctx.lineWidth=%线粗细;
        ctx.strokeRect(%起点,%尺寸);
}

if('%面颜色'==='None') {
	ctx.fillStyle='rgba(255,255,255,0)';
} else {
	ctx.fillStyle='rgb(%面颜色)';
        ctx.fillRect(%起点,%尺寸);
}

//ctx.strokeStyle='rgb(%线颜色)';
//ctx.lineWidth=%线粗细;
//ctx.strokeRect(%起点,%尺寸);

ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font=%字体*2+'px serif'
ctx.fillText('%文字',pos[0]+size[0]/2,pos[1]+size[1]/2);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#581, 2:
矩形
## end
#594, 148:
+[返回目录](,矩形)
+[设置结构](,矩形)

起点::-200,100
尺寸::100,100
类型::矩形
文字::
字体::10

面颜色::255,255,255
线颜色::0,0,0
线型::DashLine
线粗细::2

画图:...
选中区域:...
HTML:...



## end
#595, 24:
0.0, -120.24319670553152
## end
#596, 38:
-46.10634974150391, -120.6033260550735
## end
#597, 5:
0,0,0
## end
#598, 8:
DashLine
## end
#599, 1:
1
## end
#605, 31:
线颜色::0,0,0
线型::DashLine
线粗细::2

## end
#607, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#608, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#613, 313:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))


qp.drawLine(pt1[0],pt1[1],pt2[0],pt2[1])
qp.setPen(QPen())



## end
#614, 2:
直线
## end
#617, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#618, 14:
+[返回目录]
+[内容]

## end
#619, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#621, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#625, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#627, 200:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();
ctx.moveTo(%起点);
ctx.lineTo(%终点)
ctx.stroke();

/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#637, 129:
+[返回目录](,直线)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1

画图:...
选中区域:...
HTML:...
的(画图,输入)->+[有](HTML,输入)

## end
#638, 39:
-44.98488156784782, -122.55922224361282
## end
#639, 40:
-1.7993952627139151, -122.55922224361282
## end
#640, 5:
0,0,0
## end
#641, 8:
DashLine
## end
#642, 1:
1
## end
#643, 3:
l_2
## end
#644, 4:
-100
## end
#652, 50:
线颜色::0,0,0
线型::DashLine
线粗细::2
文字::10 cm
位移距离::20

## end
#654, 1610:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

angle=30
l=20
D=位移距离[0]
d=10
text=文字


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush(QColor(edgeColor[0],edgeColor[1],edgeColor[2])))

r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
if r!=0:
    theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]

Dx=D*np.cos(np.deg2rad(theta-90))
Dy=-D*np.sin(np.deg2rad(theta-90))
pt10=[0,0]
pt20=[0,0]
pt10[0]=pt1[0]+Dx
pt10[1]=pt1[1]+Dy
pt20[0]=pt2[0]+Dx
pt20[1]=pt2[1]+Dy

path1=QPainterPath()
path1.moveTo(pt10[0],pt10[1])
path1.lineTo(pt10[0]+dp21[0],pt10[1]+dp21[1])
path1.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1])
path1.lineTo(pt10[0],pt10[1])

path2=QPainterPath()
path2.moveTo(pt20[0],pt20[1])
path2.lineTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])
path2.lineTo(pt20[0],pt20[1])

qp.drawPath(path1)
qp.drawPath(path2)
qp.drawLine(pt1[0],pt1[1],pt10[0],pt10[1])
qp.drawLine(pt2[0],pt2[1],pt20[0],pt20[1])


dx=d*np.cos(np.deg2rad(theta-90))
dy=-d*np.sin(np.deg2rad(theta-90))
pt0=[0,0]
pt0[0]=(pt10[0]+pt20[0])/2+dx
pt0[1]=(pt10[1]+pt20[1])/2+dy

L=300
H=100
qp.drawText(pt0[0]-L/2,pt0[1]-H/2,L,H,Qt.AlignHCenter|Qt.AlignVCenter,text)

qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])

qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#655, 258:
"""
+[返回目录](,选中框)

"""
X=[pt1[0],pt2[0]]
Y=[pt1[1],pt2[1]]
R=6

qp.setPen(QPen(QColor(140,140,140),2.5))
qp.setBrush(QBrush(Qt.white))
qp.drawEllipse(X[0]-R,Y[0]-R,2*R,2*R)
qp.drawEllipse(X[1]-R,Y[1]-R,2*R,2*R)
qp.setBrush(QBrush())
qp.setPen(QPen(Qt.black))
## end
#660, 1610:
"""
+[返回目录](,画图)
+[返回目录](,图形)
输入:...
输出:...

图形:...
选中框:...

"""
pt1=起点
pt2=终点

angle=30
l=20
D=位移距离[0]
d=10
text=文字


lineWidth=线粗细[0]
lineType=线型

if len(线颜色)==0:
    qp.setPen(QPen())
else:
    edgeColor=线颜色
    qp.setPen(QPen(QColor(edgeColor[0],edgeColor[1],edgeColor[2]),lineWidth))
    qp.setBrush(QBrush(QColor(edgeColor[0],edgeColor[1],edgeColor[2])))

r=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
if r!=0:
    theta=np.rad2deg(np.sign(pt1[1]-pt2[1])*np.arccos((pt2[0]-pt1[0])/r))
dp21=[l*np.cos(np.deg2rad(theta-angle/2)),-l*np.sin(np.deg2rad(theta-angle/2))]
dp22=[l*np.cos(np.deg2rad(theta+angle/2)),-l*np.sin(np.deg2rad(theta+angle/2))]

Dx=D*np.cos(np.deg2rad(theta-90))
Dy=-D*np.sin(np.deg2rad(theta-90))
pt10=[0,0]
pt20=[0,0]
pt10[0]=pt1[0]+Dx
pt10[1]=pt1[1]+Dy
pt20[0]=pt2[0]+Dx
pt20[1]=pt2[1]+Dy

path1=QPainterPath()
path1.moveTo(pt10[0],pt10[1])
path1.lineTo(pt10[0]+dp21[0],pt10[1]+dp21[1])
path1.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1])
path1.lineTo(pt10[0],pt10[1])

path2=QPainterPath()
path2.moveTo(pt20[0],pt20[1])
path2.lineTo(pt20[0]-dp21[0],pt20[1]-dp21[1])
path2.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1])
path2.lineTo(pt20[0],pt20[1])

qp.drawPath(path1)
qp.drawPath(path2)
qp.drawLine(pt1[0],pt1[1],pt10[0],pt10[1])
qp.drawLine(pt2[0],pt2[1],pt20[0],pt20[1])


dx=d*np.cos(np.deg2rad(theta-90))
dy=-d*np.sin(np.deg2rad(theta-90))
pt0=[0,0]
pt0[0]=(pt10[0]+pt20[0])/2+dx
pt0[1]=(pt10[1]+pt20[1])/2+dy

L=300
H=100
qp.drawText(pt0[0]-L/2,pt0[1]-H/2,L,H,Qt.AlignHCenter|Qt.AlignVCenter,text)

qp.drawLine(pt10[0],pt10[1],pt20[0],pt20[1])

qp.setBrush(QBrush())
qp.setPen(QPen())



## end
#661, 2:
直线
## end
#664, 42:
+[返回目录](,输入)

起点::200,100
终点::218.0, -9.0

## end
#665, 14:
+[返回目录]
+[内容]

## end
#666, 56:
https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
## end
#668, 886:
<!--
+[返回目录](,点线公式)
+[网页](web,点线公式)

LaTeX数学记号::https://oeis.org/wiki/List_of_LaTeX_mathematical_symbols
+[打开](,LaTeX数学记号)
-->

<html>
  <head><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  </head>
  <body>
    <p><mathjax style="font-size:1.5em">
如果有两个点, 
$$
\vec{p}_A=(x_1,y_1), \vec{p}_B=(x_2,y_2)
$$
那么, \(\overrightarrow{AB}\)平行方向的向量和垂直方向的向量分别是,
$$
\vec{r}_\|=(x_2-x_1,y_2-y_1)
$$$$
\vec{r}_\perp=(-y_2+y_1,x_2-x_1)
$$
于是, 第三个点\(C\)到线段\(AB\)的距离为,
$$
d=\frac{\vec{r}_{AC}\cdot \vec{r}_\perp}{\|\vec{r}_\perp\|}\\
=\frac{(y-y_1)(x_2-x_1)-(x-x_1)(y_2-y_1)}{\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}}
$$
而判断\(C\)在\(A\)和\(B\)之间的判据为,
$$
l=\frac{\vec{r}_{AC}\cdot \vec{r}_\|}{\|\vec{r}_\|\|^2}\\
=\frac{(y-y_1)(y_2-y_1)+(x-x_1)(x_2-x_1)}{(x_2-x_1)^2+(y_2-y_1)^2}
$$

    </mathjax></p>
  </body>
</html>

## end
#672, 347:
"""
+[返回目录](,选中区域)
输入:...

点线公式:...
+[网页](web,点线公式)

"""

pt1=起点
pt2=终点
pt=mouse_pos

R=np.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2)
d=np.abs(((pt[1]-pt1[1])*(pt2[0]-pt1[0])-(pt[0]-pt1[0])*(pt2[1]-pt1[1]))/R)
l=((pt[1]-pt1[1])*(pt2[1]-pt1[1])+(pt[0]-pt1[0])*(pt2[0]-pt1[0]))/R**2


if l>=0 and l<=1 and d<3:
    state=True
else:
    state=False

## end
#674, 1487:
/*
+[返回目录](,HTML)

+[JS函数](,HTML)
+[设置结构](,输入)
*/

var pt1=[%起点];
var pt2=[%终点];


//arrows
var angle=30/180*Math.PI;
var l=20;
var D=%位移距离;
var d=10;

r=Math.sqrt((pt1[0]-pt2[0])**2+(pt1[1]-pt2[1])**2);
if (r!=0) {
    theta=Math.sign(pt1[1]-pt2[1])*Math.acos((pt2[0]-pt1[0])/r);
}

dp21=[l*Math.cos(theta-angle/2),-l*Math.sin(theta-angle/2)];
dp22=[l*Math.cos(theta+angle/2),-l*Math.sin(theta+angle/2)];

Dx=D*Math.cos(theta-90/180*Math.PI);
Dy=-D*Math.sin(theta-90/180*Math.PI);
pt10=[0,0];
pt20=[0,0];
pt10[0]=pt1[0]+Dx;
pt10[1]=pt1[1]+Dy;
pt20[0]=pt2[0]+Dx;
pt20[1]=pt2[1]+Dy;


ctx.strokeStyle='rgb(%线颜色)';
ctx.lineWidth=%线粗细;


ctx.beginPath();


ctx.moveTo(pt10[0],pt10[1]);
ctx.lineTo(pt10[0]+dp21[0],pt10[1]+dp21[1]);
ctx.lineTo(pt10[0]+dp22[0],pt10[1]+dp22[1]);
ctx.lineTo(pt10[0],pt10[1]);

ctx.moveTo(pt20[0],pt20[1]);
ctx.lineTo(pt20[0]-dp21[0],pt20[1]-dp21[1]);
ctx.lineTo(pt20[0]-dp22[0],pt20[1]-dp22[1]);
ctx.lineTo(pt20[0],pt20[1]);

ctx.moveTo(pt1[0],pt1[1]);
ctx.lineTo(pt10[0],pt10[1]);
ctx.moveTo(pt2[0],pt2[1]);
ctx.lineTo(pt20[0],pt20[1]);

ctx.moveTo(pt10[0],pt10[1]);
ctx.lineTo(pt20[0],pt20[1]);

ctx.stroke()
ctx.fill()


// text
dx=d*Math.cos(theta-90/180*Math.PI)
dy=-d*Math.sin(theta-90/180*Math.PI)
pt0=[0,0]
pt0[0]=(pt10[0]+pt20[0])/2+dx
pt0[1]=(pt10[1]+pt20[1])/2+dy


ctx.fillStyle='rgba(0,0,0,1)';
ctx.textAlign='center'
ctx.textBaseline='middle'
ctx.font='15px serif'
L=300
H=100
ctx.fillText('%文字',pt0[0],pt0[1]);


/*
+[JS函数](,HTML)
+[设置结构](,输入)
*/
## end
#686, 123:
+[返回目录](,长度)

起点::300,-150
终点::100,-100
类型::直线

线颜色::0,0,0
线型::DashLine
线粗细::1
文字::l_2
位移距离::20

画图:...
选中区域:...
HTML:...


## end
#703, 217:
+[返回目录](,光栅对)


光栅1:...
光栅2:...
入射光线:
内部光线1:
出射光线1:
内部光线2:
出射光线2:
法线1:...
theta:...
beta:...
水平距离:...
标记水平距离:...

+[删除结构](,beta)
+[创建角度](,beta)

间距:
+[创建长度](,标记水平距离)
+beta(内部光线1,法线1)->+[创建角度](,+beta)
+[创建直线](,水平距离)



## end
#704, 65:
file:///C:/Users/cheng/Desktop/paper/gratingTreacy(69).pdf#page=2
## end
#705, 45:
http://toolbox.lightcon.com/tools/gratingpair
## end
#710, 5370:
<!--
+[返回目录](,光栅色散)
+[H函数](,光栅色散)

光栅对(画板):...
+画板(光栅对,)
画板(光栅对,)->+[del](,画板)
+[画板](+光栅画板,光栅对)
-->
%光栅对
<br>
<b><u>Phase of a grating compressor</u></b><br>
Consider a grating compressor with two gratings. The grating constant for both of them is \(d\). The distance between them is \(D\). Assuming \(\theta\) is the angle between the incoming beam and the normal line of the grating and \(\beta\) is the diffraction angle.<br>
Then, 
$$
sin(\theta)+sin(\beta) = \frac{n \lambda}{d}
$$
The total length of the light path is,
$$
l=l_1-l_2
\\
l_1=D/cos(\beta)
\\
l_2=-D\ tan(\beta) sin(\theta)
$$
Then, 
$$
l
=D\left(\frac{1+sin(\beta)sin(\theta)}{cos(\beta)}\right)
$$
The phase on the surface of the grating is changing over the distance. When you scattered different color beams into one beam, those beams should be scattered from different locations. We need to add this difference to compensate the phase shift. <br>
If the distance is \(d\), which is the cycle length, the phase difference will be \(2 n \pi\). Then if the distance is \(\Delta=D tan \beta\), the phase difference is, 
$$
\Delta \phi = -(2 n \pi)\frac{\Delta}{d}
=\frac{2 n \pi D tan \beta}{d}
$$
Since here \(n\), the total phase shift is, 
$$
\phi=\frac{\omega l}{c}+\Delta \phi
=
\frac{\omega D}{c}
\left(\frac{1+sin(\beta)sin(\theta)}{cos(\beta)}\right)
-
\frac{2 n \pi D tan \beta}{d}
$$
The 1st order differential over \(\omega\) is, 
$$
\frac{\partial \phi}{\partial \omega}
=
\frac{\partial}{\partial \omega}
\frac{\omega D}{c}
\left(\frac{1+sin(\beta)sin(\theta)}{cos(\beta)}\right)
-
\frac{\partial}{\partial \omega}
\frac{2 n \pi D tan \beta}{d}
$$$$
=
\frac{D}{c}
\left(\frac{1+sin(\beta)sin(\theta)}{cos(\beta)}\right)
+
\frac{\omega D}{c}
\frac{\partial}{\partial \omega}
\left(\frac{1+sin(\beta)sin(\theta)}{cos(\beta)}\right)
-
\frac{\partial}{\partial \omega}
\frac{2 n \pi D tan \beta}{d}
$$

Since \(\beta\) is a function of the wavelength \(\lambda\), we have,
$$
sin(\beta)=\frac{n\lambda}{d}-sin(\theta)
=\frac{2 n \pi c}{\omega d}
-sin(\theta)
$$$$
\frac{d sin(\beta)}{d \omega}
=cos(\beta)\frac{d \beta}{d \omega}
=\frac{d}{d \omega}
\frac{2 n \pi c}{\omega d}
=-\frac{2 n \pi c}{\omega^2 d}
$$
$$
\frac{d \beta}{d \omega}
=-\frac{2 n \pi c}{cos(\beta)\omega^2 d}
$$
And we have, 
$$
\frac{d}{d\omega} tan\beta
=\frac{1}{cos\beta^2}\frac{d\beta}{d\omega}
$$$$
\frac{d}{d\omega} \frac{1}{cos\beta}
=\frac{sin\beta}{cos\beta^2}\frac{d\beta}{d\omega}
$$

Then the result is, 
$$
\frac{\partial \phi}{\partial \omega}
=
\frac{D}{c}
\left(\frac{1+sin(\beta)sin(\theta)}{cos(\beta)}\right)
+
\frac{\omega D}{c}
\frac{\partial}{\partial \omega}
\left(\frac{1+sin(\beta)sin(\theta)}{cos(\beta)}\right)
-
\frac{\partial}{\partial \omega}
\frac{2 n \pi D tan \beta}{d}
$$$$
=
\frac{l}{c}
+
\frac{\omega D}{c}
\frac{\partial}{\partial \omega}\frac{1}{cos\beta}
+
\frac{\omega D sin\theta}{c}
\frac{\partial}{\partial \omega}
tan\beta
-
\frac{2 n \pi D}{d}
\frac{\partial}{\partial \omega}
tan \beta
$$$$
=
\frac{l}{c}
+
\frac{\omega D}{c}
\frac{sin\beta}{cos\beta^2}\frac{d\beta}{d\omega}
+
\left(
\frac{\omega D sin\theta}{c}
-
\frac{2 n \pi D}{d}
\right)
\frac{1}{cos\beta^2}\frac{d\beta}{d\omega}
$$
$$
=
\frac{l}{c}
+
\frac{\omega D}{c}
\frac{(sin\beta+sin\theta)}
{cos\beta^2}\frac{d\beta}{d\omega}
-
\frac{2 n \pi D}{d}
\frac{1}{cos\beta^2}\frac{d\beta}{d\omega}

=

\frac{l}{c}
$$
And,
$$
l
=D\left(\frac{1+sin(\beta)sin(\theta)}{cos(\beta)}\right)
$$
<br>


<b><u>Second order dispersion</u></b><br>
$$
\frac{\partial^2 \phi}{\partial \omega^2}
=\frac{\partial}{\partial \omega}
\frac{l}{c}
=
\frac{D}{c}
\frac{(sin\beta+sin\theta)}
{cos\beta^2}\frac{d\beta}{d\omega}
=
\frac{2 n \pi D}{\omega d}
\frac{1}{cos\beta^2}\frac{d\beta}{d\omega}
\\
=
-
\frac{2 n \pi D}{\omega d^2}
\frac{2 n \pi c}{cos\beta^3\omega^2}
=
-\frac{4 n^2 \pi^2 c D}{\omega^3 d^2}
\frac{1}{cos\beta^3}
=
-\frac{4 n^2 \pi^2 c D}{\omega^3 d^2}
\frac{1}{(1-sin\beta^2)^{3/2}}
\\
=
-\frac{4 n^2 \pi^2 c D}{\omega^3 d^2}
\frac{1}{[1-(n\lambda/d-sin\theta)^2]^{3/2}}
$$
<br>



(something wrong...)
<b><u>Third order dispersion</u></b><br>
$$
\frac{\partial^3 \phi}{\partial \omega^3}
=-
\frac{4 \pi^2 c D}{d^2}
\frac{\partial}{\partial \omega}
\frac{1}{\omega^2 cos\beta^3}
=
\frac{4 \pi^2 c D}{d^2}
\left(
\frac{2}{\omega^3}
\frac{1}{cos\beta^3}
-
\frac{1}{\omega^2}
\frac{\partial}{\partial \omega}
\frac{1}{cos\beta^3}
\right)
\\
=
\frac{4 \pi^2 c D}{d^2}
\left(
\frac{2}{\omega^3}
\frac{1}{cos\beta^3}
-
\frac{1}{\omega^2}
\frac{3 sin\beta}{cos\beta^4}
\right)
=
\frac{4 \pi^2 c D}
{\omega^2 d^2}
\frac{1}{cos\beta^3}
\left(
\frac{2}{\omega}
-
\frac{3 sin\beta}{cos\beta}
\right)
$$
We can write \(
(
2/\omega
-3 sin\beta/cos\beta
)
\) as a function of the incident angle, 
$$
\frac{2}{\omega}-\frac{3 sin\beta}{cos\beta}
=
\frac{1}{\omega}\frac{2 cos\beta-3 \omega sin\beta}{cos\beta}
$$$$
=
\frac{1}{\omega}\frac{2 \sqrt{1-sin\beta^2}
-3 \omega sin\beta}{\sqrt{1-sin\beta^2}}
$$




<!--
+[H函数](,光栅色散)
-->




<br><br><br><br><br>
I'm using the formula from Optics Toolbox directly then, 
$$
GDD(\lambda)=-\frac{\lambda^3 D}{\pi c^2 d^2}
\left[
1-\left(
\frac{\lambda}{d}-sin\theta
\right)^2
\right]^{-\frac{3}{2}}
$$

<!--
+[H函数](,光栅色散)

参考::file:///C:/Users/cheng/Desktop/paper/gratingTreacy(69).pdf#page=2
+[打开网页](,参考)
参考2::http://toolbox.lightcon.com/tools/gratingpair
+[打开网页](,参考2)

验证推导(M函数):...
-->
## end
#713, 3051:
<!--
Nini, 导入网页画板的库
+[H函数](,完整色散与二阶色散)
+[新建阅读窗口](,完整色散与二阶色散)
Nini, 打开波包(文件)
-->

<b><u>Phase of a grating compressor</u></b><br>

The complete phase of a grating compressor is, 
$$
\phi
=
\frac{\omega D}{c}
\left(\frac{1+sin(\beta)sin(\theta)}{cos(\beta)}\right)
-
\frac{2 n \pi D tan \beta}{d}
\\
=
\frac{\omega D}{c}
\left(\frac{1+sin(\beta)sin(\theta)}{cos(\beta)}\right)
-
\frac{2 \pi D n \lambda tan \beta}{\lambda d}
\\
=
\frac{\omega D}{c}
\left(\frac{1+sin(\beta)sin(\theta)}{cos(\beta)}\right)
-
\frac{\omega D}{c}(sin\theta+sin\beta)tan \beta
\\
=
\frac{\omega D}{c}
\left(\frac{1-sin(\beta)^2}{cos \beta}\right)
=
\frac{\omega D}{c}cos(\beta)

$$



The \(\omega\) is the angular frequency of light. The distance between two gratings are \(D\). The grating constant is \(d\). The incoming angle is \(\theta\). And the diffraction angle is \(\beta\). <br>
While the relation between the \(\theta\) and the \(\beta\) is, 
$$
sin(\theta)+sin(\beta) = \frac{n \lambda}{d}
$$
Here, \(n\) is the \(n\)-th order diffraction of a grating. Here we take \(n=1\)<br>
Then it's easy to get the second order dispersion, 
$$
\frac{\partial^2 \phi}{\partial \omega^2}
=
-\frac{4 n^2 \pi^2 c D}{\omega^3 d^2}
\frac{1}{[1-(n\lambda/d-sin\theta)^2]^{3/2}}
$$
<br><br>



<b><u>Effects on the pulse shape</u></b><br>
Here let's take the following parameters to study the effects on the pulse shape,
$$
D=67\ cm,\ \theta=47.28^\circ,\ G=1480\ mm^{-1}
$$
The pulse is, 
$$
\lambda_0=800\ nm,\ FWHM=65\ fs
$$
Assuming the spectrum of the pulse is gaussian and no phase exists when the above parameters are applied to the grating compressor. <br>
In this case, the fact is, 
$$
\delta \tau=\frac{2}{\delta \omega}
\approx FWHM/2
$$
in which \(\delta\tau\) and \(\delta\omega\) are defined as,
$$
S(\omega)=A exp\left[-\frac{(\omega-\omega_0)^2}{\delta \omega^2}\right]
$$$$
f(t)=B
exp
\left[-\frac{(t-t_0)^2}{\delta\tau}
\right]
$$
And we have,
$$
\lambda=\frac{2\pi c}{\omega}, 
\delta\lambda=-\frac{\lambda}{\omega}\delta\omega
$$
<br><br>



<b><u>Optimal separation</u></b><br>
The second order dispersion is, 
$$
S
\equiv
\frac{\partial^2 \phi}{\partial \omega^2}
=
-\frac{4 n^2 \pi^2 c D}{\omega^3 d^2}
\frac{1}{[1-(n\lambda/d-sin\theta)^2]^{3/2}}
$$
To keep the second order dispersion as a constant value, \(S=S_0\), the separation and the incident angle is a function, 
$$
S_0
=
-\frac{4 n^2 \pi^2 c D_0}{\omega^3 d^2}
\frac{1}{[1-(n\lambda/d-sin\theta_0)^2]^{3/2}}
$$$$
[1-(n\lambda/d-sin\theta)^2]^{3}
=\frac{16 n^4 \pi^4 c^2}{\omega^6 d^4 S_0^2}
D^2
\equiv
A^3 D^2
$$$$
D
=
\sqrt{\frac{[1-(n\lambda/d-sin\theta)^2]^{3}}{A^3}}
$$
Or, we can write \(\theta\) as a function of \(D\), 
$$
1-(n\lambda/d-sin\theta)^2
=
A D^{2/3}
$$
$$
n\lambda/d-sin\theta
=
\pm
\sqrt{1-A D^{2/3}}
$$$$
sin\theta
=
n\lambda/d
\mp
\sqrt{1-A D^{2/3}}
$$
Here the definition of A is, 
$$
A=
\sqrt[3]{\frac{16 n^4 \pi^4 c^2}{\omega^6 d^4 S_0^2}}
=\frac{1-(n\lambda/d-sin\theta_0)^2}{D_0^{2/3}}
$$

<!--
+[H函数](,完整色散与二阶色散)

色散曲线(M函数):...
扫参数(M函数):...

示意图场景:...
+[M函数](,扫参数)
-->
## end
#716, 15:
文档\物理问题\波包.ftxt
## end
#718, 2301:
%{
+[M函数](,色散曲线)
figure
记住色散曲线(节点)

检验相位函数(M函数):...
高阶相位(M函数):...
+[M函数](,检验相位函数)

grating_compressor_dtau(M函数):...
grating_compressor_phase(M函数):...
+[新建阅读窗口](,grating_compressor_phase)
Nini, 打开花园(文件)
%}
clf

addpath('Matlab\optics');
physics_constant;

D=0.67;
theta=47.28;

D_0=0.67;
theta_0=47.28;
G=1480;
d=1e-3/G;

lm_0=800e-9;
FWHM=66e-15;
dtau=FWHM/2/sqrt(log(2));

dw=2/dtau;
Dw=40*dw;
n=1;

w_0=2*pi*c./lm_0;
w=linspace(w_0-Dw,w_0+Dw,35000);
lm=2*pi*c./w;

t0=1200e-15;

beta=@(w,theta,n)asind(-sind(theta)+n*2*pi*c./w/d);
l=@(w,D,theta,n)D*((1+sind(beta(w,theta,n))*sind(theta))./cosd(beta(w,theta,n)));
phase=@(w,D,theta,n)w.*D/c.*cosd(beta(w,theta,n));

dphi=@(w,D,theta,n)l(w,D,theta,n)/c;
d2phi=@(w,D,theta,n)-4*n^2*pi^2*c*D./w.^3/d^2./cosd(beta(w,theta,n)).^3;

phase_0=phase(w,D_0,theta_0,n)-phase(w_0,D_0,theta_0,n)-dphi(w_0,D_0,theta_0,n)*(w-w_0);

phase_a=phase(w,D,theta,n);
phase01=phase(w_0,D,theta,n)+dphi(w_0,D,theta,n)*(w-w_0);
phase2=1/2*d2phi(w_0,D,theta,n)*(w-w_0).^2;
phase2_0=1/2*d2phi(w_0,D_0,theta_0,n)*(w-w_0).^2;
phase2_a=phase_a-phase01;

S0=exp(-(w-w_0).^2/dw^2).*exp(-1i*t0*w);

% real
S=S0.*exp(-1i*phase_0);
S=S.*exp(1i*phase2_a);
S(isnan(S))=0;
S(isinf(S))=0;
[t,f]=ifft_k(w,S);

f_abs=abs(f);
f_max=max(f_abs);
Df=f_abs(f_abs>f_max/2);
Dt=t(f_abs>f_max/2);

t01=t(f_abs==f_max);
FWHM1=(max(Dt)-min(Dt));

% 2nd
S2=S0.*exp(-1i*phase2_0);
S2=S2.*exp(1i*phase2);
S2(isnan(S2))=0;
S2(isinf(S2))=0;
[t,f2]=ifft_k(w,S2);

f_abs=abs(f2);
f_max=max(f_abs);
Df2=f_abs(f_abs>f_max/2);
Dt2=t(f_abs>f_max/2);

t02=t(f_abs==f_max);
FWHM2=(max(Dt2)-min(Dt2));


% drawing
subplot(2,2,1)
plot(lm/1e-9,abs(S));
title('Spectrum')
xlabel('\lambda [nm]')
axis([700,900,0,1])

subplot(2,2,3)
plot(lm/1e-9,phase2,lm/1e-9,phase2_a);
title('Phase from compressor')
xlabel('\lambda [nm]')
axis([700,900,-1e5,7e4])
legend('2nd order phase','2nd and higher order phase')

subplot(2,2,2)
plot(t/1e-15,real(f),t/1e-15,abs(f),Dt/1e-15,Df,'o');
xlabel('t [fs]')
axis([t01/1e-15-500,t01/1e-15+500,-max(abs(f)),max(abs(f))])
title(sprintf('FWHM = %.2f fs',FWHM1/1e-15))

subplot(2,2,4)
plot(t/1e-15,real(f2),t/1e-15,abs(f2),Dt2/1e-15,Df2,'o');
xlabel('t [fs]')
axis([t02/1e-15-500,t02/1e-15+500,-max(abs(f2)),max(abs(f2))])
title(sprintf('FWHM = %.2f fs',FWHM2/1e-15))



%{
+[M函数](,色散曲线)
%}
## end
#721, 1442:
%{
+[M函数](,检验相位函数)
%}

physics_constant;

D=0.67;
theta=47.28;
G=1480;
d=1e-3/G;

lm_0=900e-9;
FWHM=65e-15;
dtau=FWHM/2;

dw=2/dtau;
Dw=5*dw;
n=1;

w_0=2*pi*c./lm_0;
w=linspace(w_0-Dw,w_0+Dw,350);
lm=2*pi*c./w;

beta=@(w)asind(-sind(theta)+n*2*pi*c./w/d);
l=@(w)D*((1+sind(beta(w))*sind(theta))./cosd(beta(w)));

% phase=@(w)w./c.*l(w)-2*n*pi*D*tand(beta(w))/d;
phase=@(w)w.*D/c.*((1+sind(beta(w))*sind(theta))./cosd(beta(w)))-2*n*pi*D*tand(beta(w))/d;
% phase=@(w)w.*D/c.*cosd(beta(w));

dphi=@(w)l(w)/c;

d2phi=@(w)-4*n^2*pi^2*c*D./w.^3/d^2./(1-(n*2*pi*c./w/d-sind(theta)).^2).^(3/2);
% d2phi=@(w)-4*n^2*pi^2*c*D./w.^3/d^2./cosd(beta(w)).^3;


dw=0.01*w;
dphi1=(phase(w+dw/2)-phase(w-dw/2))./dw;
d2phi1=(dphi(w+dw/2)-dphi(w-dw/2))./dw;
d2phi2=(phase(w+dw)+phase(w-dw)-2*phase(w))./dw.^2;

subplot(2,2,1)
plot(lm/1e-9,beta(w));
xlabel('\lambda [nm]')
ylabel('\beta [\circ]')
title('diffraction angle')

subplot(2,2,2)
plot(lm/1e-9,real(phase(w)),lm/1e-9,imag(phase(w)));
xlabel('\lambda [nm]')
title('phase')

subplot(2,2,3)
plot(lm/1e-9,dphi(w),lm/1e-9,dphi1);
xlabel('\lambda [nm]')
title('first order dispersion')
% set(gca,'YScale','log')


subplot(2,2,4)
plot(lm/1e-9,d2phi(w),lm/1e-9,d2phi1,lm/1e-9,d2phi2);
xlabel('\lambda [nm]')
title('Second order dispersion')



dw=0.0001*w_0;
(phase(w_0+dw)-phase(w_0))/dw
l(w_0)/c
% (phase(w_0+dw)+phase(w_0-dw)-2*phase(w_0))/dw^2
% (l(w_0+dw)/c-l(w_0)/c)/dw
% d2phi(w_0)


%{
+[M函数](,检验相位函数)
%}
## end
#724, 1440:
%{
+[M函数](,验证推导)
%}

physics_constant;

D=0.67;
theta=47.28;
G=1480;
d=1e-3/G;

lm_0=900e-9;
FWHM=65e-15;
dtau=FWHM/2;

dw=2/dtau;
Dw=5*dw;
n=1;

w_0=2*pi*c./lm_0;
w=linspace(w_0-Dw,w_0+Dw,350);
lm=2*pi*c./w;

beta=@(w)asind(-sind(theta)+n*2*pi*c./w/d);
l=@(w)D*((1+sind(beta(w))*sind(theta))./cosd(beta(w)));

% phase=@(w)w./c.*l(w)-2*n*pi*D*tand(beta(w))/d;
phase=@(w)w.*D/c.*((1+sind(beta(w))*sind(theta))./cosd(beta(w)))-2*n*pi*D*tand(beta(w))/d;
% phase=@(w)w.*D/c.*cosd(beta(w));

dphi=@(w)l(w)/c;

d2phi=@(w)-4*n^2*pi^2*c*D./w.^3/d^2./(1-(n*2*pi*c./w/d-sind(theta)).^2).^(3/2);
% d2phi=@(w)-4*n^2*pi^2*c*D./w.^3/d^2./cosd(beta(w)).^3;


dw=0.01*w;
dphi1=(phase(w+dw/2)-phase(w-dw/2))./dw;
d2phi1=(dphi(w+dw/2)-dphi(w-dw/2))./dw;
d2phi2=(phase(w+dw)+phase(w-dw)-2*phase(w))./dw.^2;

subplot(2,2,1)
plot(lm/1e-9,beta(w));
xlabel('\lambda [nm]')
ylabel('\beta [\circ]')
title('diffraction angle')

subplot(2,2,2)
plot(lm/1e-9,real(phase(w)),lm/1e-9,imag(phase(w)));
xlabel('\lambda [nm]')
title('phase')

subplot(2,2,3)
plot(lm/1e-9,dphi(w),lm/1e-9,dphi1);
xlabel('\lambda [nm]')
title('first order dispersion')
% set(gca,'YScale','log')


subplot(2,2,4)
plot(lm/1e-9,d2phi(w),lm/1e-9,d2phi1,lm/1e-9,d2phi2);
xlabel('\lambda [nm]')
title('Second order dispersion')



dw=0.0001*w_0;
(phase(w_0+dw)-phase(w_0))/dw
l(w_0)/c
% (phase(w_0+dw)+phase(w_0-dw)-2*phase(w_0))/dw^2
% (l(w_0+dw)/c-l(w_0)/c)/dw
% d2phi(w_0)


%{
+[M函数](,检验相位函数)
%}
## end
#727, 1114:
%{
+[M函数](,高阶相位)
%}
clf

physics_constant;

D=0.67;
theta=47.28;
G=1480;
d=1e-3/G;

lm_0=800e-9;
FWHM=65e-15;
dtau=FWHM/2;

dw=2/dtau;
Dw=10*dw;
n=1;

w_0=2*pi*c./lm_0;
w=linspace(w_0-Dw,w_0+Dw,3500);
lm=2*pi*c./w;

t0=200e-15;

beta=@(w)asind(-sind(theta)+n*2*pi*c./w/d);
l=@(w)D*((1+sind(beta(w))*sind(theta))./cosd(beta(w)));
% phase=@(w)w./c.*l(w)-2*n*pi*D*tand(beta(w))/d;
% phase=@(w)w.*D/c.*((1+sind(beta(w))*sind(theta))./cosd(beta(w)))-2*n*pi*D*tand(beta(w))/d;
phase=@(w)w.*D/c.*cosd(beta(w));
dphi=@(w)l(w)/c;
% d2phi=@(w)-4*n^2*pi^2*c*D./w.^3/d^2./(1-(n*2*pi*c./w/d-sind(theta)).^2).^(3/2);
d2phi=@(w)-4*n^2*pi^2*c*D./w.^3/d^2./cosd(beta(w)).^3;


phase_a=phase(w);
phase01=phase(w_0)+dphi(w_0)*(w-w_0);
phase2=1/2*d2phi(w_0)*(w-w_0).^2;
phase2_a=phase_a-phase01;

subplot(1,2,1)
plot(lm/1e-9,phase_a,lm/1e-9,phase01);
xlabel('\lambda [nm]')
legend('real phase','1st order phase')

subplot(1,2,2)
plot(lm/1e-9,phase2,lm/1e-9,phase2_a);
xlabel('\lambda [nm]')
axis([min(lm)/1e-9,max(lm)/1e-9,min(phase2_a),-0.3*min(phase2_a)])
legend('2nd order phase','2nd and higher order phase')


%{
+[M函数](,高阶相位)
%}
## end
#730, 1598:
%{
+[M函数](,grating_compressor_dtau)
地址::Matlab\optics\grating_compressor_dtau.m
+[保存M函数](,grating_compressor_dtau)

测试(M函数):...
%}

function [FWHM1,FWHM2]=grating_compressor_dtau(D,theta,D_0,theta_0,G,lm_0,FWHM)
physics_constant;

%D=0.67;
%theta=47.29;

%D_0=0.67;
%theta_0=47.28;
%G=1480;

%lm_0=800e-9;
%FWHM=66e-15;


d=1e-3/G;
dtau=FWHM/2/sqrt(log(2));

dw=2/dtau;
Dw=40*dw;
n=1;

w_0=2*pi*c./lm_0;
w=linspace(w_0-Dw,w_0+Dw,35000);
lm=2*pi*c./w;

t0=1200e-15;

beta=@(w,theta,n)asind(-sind(theta)+n*2*pi*c./w/d);
l=@(w,D,theta,n)D*((1+sind(beta(w,theta,n))*sind(theta))./cosd(beta(w,theta,n)));
phase=@(w,D,theta,n)w.*D/c.*cosd(beta(w,theta,n));

dphi=@(w,D,theta,n)l(w,D,theta,n)/c;
d2phi=@(w,D,theta,n)-4*n^2*pi^2*c*D./w.^3/d^2./cosd(beta(w,theta,n)).^3;

phase_0=phase(w,D_0,theta_0,n)-phase(w_0,D_0,theta_0,n)-dphi(w_0,D_0,theta_0,n)*(w-w_0);

phase_a=phase(w,D,theta,n);
phase01=phase(w_0,D,theta,n)+dphi(w_0,D,theta,n)*(w-w_0);
phase2=1/2*d2phi(w_0,D,theta,n)*(w-w_0).^2;
phase2_0=1/2*d2phi(w_0,D_0,theta_0,n)*(w-w_0).^2;
phase2_a=phase_a-phase01;

S0=exp(-(w-w_0).^2/dw^2).*exp(-1i*t0*w);

% real
S=S0.*exp(-1i*phase_0);
S=S.*exp(1i*phase2_a);
S(isnan(S))=0;
S(isinf(S))=0;
[t,f]=ifft_k(w,S);

f_abs=abs(f);
f_max=max(f_abs);
Df=f_abs(f_abs>f_max/2);
Dt=t(f_abs>f_max/2);

t01=t(f_abs==f_max);
FWHM1=(max(Dt)-min(Dt));

% 2nd
S2=S0.*exp(-1i*phase2_0);
S2=S2.*exp(1i*phase2);
S2(isnan(S2))=0;
S2(isinf(S2))=0;
[t,f2]=ifft_k(w,S2);

f_abs=abs(f2);
f_max=max(f_abs);
Df2=f_abs(f_abs>f_max/2);
Dt2=t(f_abs>f_max/2);

t02=t(f_abs==f_max);
FWHM2=(max(Dt2)-min(Dt2));

end

%{
+[M函数](,色散曲线)
%}
## end
#733, 39:
Matlab\optics\grating_compressor_dtau.m
## end
#735, 202:
%{
+[M函数](,测试)
%}


addpath('Matlab\optics');
D=0.67;
theta=47.29;

D_0=0.67;
theta_0=47.29;
G=1480;

lm_0=800e-9;
FWHM=66e-15;

[FWHM1,FWHM2]=grating_compressor_dtau(D,theta,D_0,theta_0,G,lm_0,FWHM)



## end
#739, 1166:
%{
+[M函数](,扫参数)
直接扫参数(M函数):...
%}

clf
addpath('Matlab\optics');
physics_constant;

D_0=0.67;
theta_0=47.28;
G=1480;
d=1e-3/G;

lm_0=800e-9;
FWHM=66e-15;

DD=0.2e-2;
Dtheta=5;

% optimal separation
A=(1-(lm_0/d-sind(theta_0))^2)/D_0^(2/3);
theta_o=@(D)asind(lm_0/d-sqrt(1-A*D.^(2/3)));
D_o=@(theta)sqrt((1-(lm_0/d-sind(theta)).^2).^3/A^3);

D=linspace(-DD/2,DD/2,100);
theta=linspace(theta_0-Dtheta/2,theta_0+Dtheta/2,100);

[Theta,Dis]=meshgrid(theta,D);

FWHM1=zeros(length(D),length(theta));
FWHM2=zeros(length(D),length(theta));
for i=1:length(D)
    for j=1:length(theta)
%         doi=Dis(i,j);
%         t=Theta(i,j)+theta_o(doi);
        t=Theta(i,j);
%        doi=Dis(i,j)+D_o(t);
        doi=Dis(i,j);
        [FWHM1(i,j),FWHM2(i,j)]=grating_compressor_dtau(doi,t,D_0,theta_0,G,lm_0,FWHM);
    end
end
D_0

subplot(1,2,1)
contourf(Dis/1e-2,Theta,FWHM1);
%surf(Dis/1e-2,Theta,FWHM1);
%shading interp
xlabel('D [cm]');
ylabel('\delta\theta [\circ]');
%set(gca,'ZScale','log')


subplot(1,2,2)
contourf(Dis/1e-2,Theta,FWHM2);
%surf(Dis/1e-2,Theta,FWHM2);
%shading interp
xlabel('D [cm]');
ylabel('\theta [\circ]');
%set(gca,'ZScale','log')

%{
+[M函数](,扫参数)
%}
## end
#742, 1007:
%{
+[M函数](,直接扫参数)
%}

clf
addpath('Matlab\optics');
physics_constant;

D_0=0.67;
theta_0=47.28;
G=1480;
d=1e-3/G;

lm_0=800e-9;
FWHM=66e-15;

DD=5e-2;
Dtheta=1;

% optimal separation
A=(1-(lm_0/d-sind(theta_0))^2)/D_0^(2/3);
theta_o=@(D)asind(lm_0/d-sqrt(1-A*D.^(2/3)));

D=linspace(D_0-DD/2,D_0+DD/2,110);
theta=linspace(theta_0-Dtheta/2,theta_0+Dtheta/2,100);

[Theta,Dis]=meshgrid(theta,D);

% FWHM1=zeros(length(D),length(theta));
% FWHM2=zeros(length(D),length(theta));
% for i=1:length(D)
%     for j=1:length(theta)
%         doi=Dis(i,j);
%         t=Theta(i,j);
%         [FWHM1(i,j),FWHM2(i,j)]=grating_compressor_dtau(doi,t,D_0,theta_0,G,lm_0,FWHM);
%     end
% end


subplot(1,2,1)
surf(Dis/1e-2,Theta,FWHM1);
shading interp
xlabel('D [cm]');
ylabel('\theta [\circ]');
set(gca,'ZScale','log')


subplot(1,2,2)
surf(Dis/1e-2,Theta,FWHM2);
shading interp
xlabel('D [cm]');
ylabel('\theta [\circ]');
set(gca,'ZScale','log')
hold on


plot3(D/1e-2,theta_o(D),ones(size(D))*1e-16)

%{
+[M函数](,扫参数)
%}
## end
#751, 3:
757
## end
#756, 3:
758
## end
#758, 3:
760
## end
#761, 3:
764
## end
#764, 289:
+[显示星图](,示意图场景)
+[显示PPT场景](,示意图场景)

G1::
G2::
M0::
入射光0::

G1是长方形"0.5,2". G2是长方形"0.5,2". M0是长方形"0.5,2"
G1在"0,0". G2距离G1为"2,-2". M0距离G1为"0,-2"
M0旋转"90". G1旋转"-40". G2旋转"140"
M0在"0,-3.5"
G1旋转"-40". G2旋转"-40"

G1距离G2是"1". 

A0是光栅压缩器
A0的光栅常数是"1450". A0的光栅间距是"30". A0的中心波长是"800"
A0的入射角是"49"




## end
#773, 20:
-1.0, 1.0, 1.0, -1.0
## end
#775, 20:
0.0, 0.0, -0.5, -0.5
## end
#777, 3:
0.5
## end
#779, 3:
2.0
## end
#781, 8:
0.0, 0.0
## end
#783, 3:
长方形
## end
#785, 3:
818
## end
#787, 20:
-1.0, 1.0, 1.0, -1.0
## end
#789, 20:
0.0, 0.0, -0.5, -0.5
## end
#791, 3:
0.5
## end
#793, 3:
2.0
## end
#795, 9:
2.0, -2.0
## end
#797, 3:
长方形
## end
#799, 20:
-1.0, 1.0, 1.0, -1.0
## end
#801, 20:
0.0, 0.0, -0.5, -0.5
## end
#803, 3:
0.5
## end
#805, 3:
2.0
## end
#807, 6:
0,-3.5
## end
#809, 3:
长方形
## end
#811, 4:
90.0
## end
#813, 5:
-60.0
## end
#815, 5:
120.0
## end
#817, 3:
819
## end
#819, 3:
828
## end
#822, 810:
%{
地址::Matlab\optics\grating_compressor_phase.m
+[保存M函数](,grating_compressor_phase)
%}


function phase_G=grating_compressor_phase(w,D,theta,D_0,theta_0,G)

physics_constant;
%D=0.67;
%theta=47.28;

%D_0=0.67;
%theta_0=47.28;
%G=1480;

d=1e-3/G;
n=1;
w_0=mean(w);

beta=@(w,theta,n)asind(-sind(theta)+n*2*pi*c./w/d);
l=@(w,D,theta,n)D*((1+sind(beta(w,theta,n))*sind(theta))./cosd(beta(w,theta,n)));
phase=@(w,D,theta,n)w.*D/c.*cosd(beta(w,theta,n));
dphi=@(w,D,theta,n)l(w,D,theta,n)/c;

phase_0=phase(w,D_0,theta_0,n)-phase(w_0,D_0,theta_0,n)-dphi(w_0,D_0,theta_0,n)*(w-w_0);
phase2_a=phase(w,D,theta,n)-phase(w_0,D,theta,n)-dphi(w_0,D,theta,n)*(w-w_0);

% phase_a=phase(w,D,theta,n);
% phase01=phase(w_0,D,theta,n)+dphi(w_0,D,theta,n)*(w-w_0);
% phase2_a=phase_a-phase01;

phase_G=phase2_a-phase_0;

end





## end
#825, 40:
Matlab\optics\grating_compressor_phase.m
## end
#829, 3:
912
## end
#832, 23:
<!--
光栅对场景:...
-->





## end
#835, 219:
Nini, 导入词典的库. 导入词典
Nini, 导入图形库的库
Nini, 导入三维场景的库

G1::
G2::
P1::

G1是长方形"2,10"
G2是长方形"2,10"
P1是长方形"2,10"

G2距离G1为"-10,10"
P1距离G2为"0,-20"
朝向(G2,方向)->+[修改内容]"-45"(,方向)

光线路径(M函数):...
+[新建阅读窗口](,光线路径)

+[显示PPT场景]"1"(,光栅对场景)
## end
#843, 20:
-5.0, 5.0, 5.0, -5.0
## end
#845, 20:
0.0, 0.0, -2.0, -2.0
## end
#847, 8:
0.0, 0.0
## end
#849, 3:
2.0
## end
#851, 4:
10.0
## end
#853, 3:
长方形
## end
#855, 20:
-5.0, 5.0, 5.0, -5.0
## end
#857, 20:
0.0, 0.0, -2.0, -2.0
## end
#859, 11:
-10.0, 10.0
## end
#861, 3:
2.0
## end
#863, 4:
10.0
## end
#865, 3:
长方形
## end
#867, 20:
-5.0, 5.0, 5.0, -5.0
## end
#869, 20:
0.0, 0.0, -2.0, -2.0
## end
#871, 12:
-10.0, -10.0
## end
#873, 3:
2.0
## end
#875, 4:
10.0
## end
#877, 3:
长方形
## end
#880, 2567:
%{
记住光线路径(节点)
Nini, 打开光栅原理(文件)
+[M函数](,光线路径)

+[修改天使]
单发路径:...
grating_compressor_path(M函数):...
偏移扫描:...
+[新建阅读窗口](,单发路径)
+[M函数](,光线路径)
%}


addpath('Matlab\space')
addpath('Matlab\optics')

N=1200;
n=-1;
d_an=-1.7;

pt0=[0,20];
angle0=-90;

G1_pt=[0,0];
G1_angle=135;
G2_pt=[-10,10];
G2_angle=-45;
P1_pt=[0,-10];
P1_angle=90;
M3_pt=[0,10];
M3_angle=-45;
tg_pt=[100,10];
tg_angle=180;

%{
+[M函数](,光线路径)
%}

% profile
R=1e-3;
D=5e-3;
x=linspace(-D*2,D*2,100);
y=linspace(-D*2,D*2,100);
[Y,X]=meshgrid(y,x);
In_p0=exp(-(X.^2+Y.^2)/R^2);

% spectrum
lm=linspace(550e-9,1100e-9,60);
Dlm=50e-9;
% In_s=exp(-(lm-800e-9).^2/Dlm^2);
In_s=exp(-(lm-740e-9).^2/Dlm^2)+exp(-(lm-900e-9).^2/Dlm^2);

% sum profile
im_G1=zeros(size(lm));
im_G2=zeros(size(lm));
im_P1=zeros(size(lm));
for i=1:length(lm)
[pt7,x,y]=grating_compressor_path(lm(i),n,N,pt0,angle0,G1_pt,G1_angle+d_an,G2_pt,G2_angle,P1_pt,P1_angle,M3_pt,M3_angle,tg_pt,tg_angle);
im_G1(i)=pt7(2)*1e-2;

[pt7,x,y]=grating_compressor_path(lm(i),n,N,pt0,angle0,G1_pt,G1_angle,G2_pt,G2_angle+d_an,P1_pt,P1_angle,M3_pt,M3_angle,tg_pt,tg_angle);
im_G2(i)=pt7(2)*1e-2;

[pt7,x,y]=grating_compressor_path(lm(i),n,N,pt0,angle0,G1_pt,G1_angle,G2_pt,G2_angle,P1_pt,P1_angle+d_an,M3_pt,M3_angle,tg_pt,tg_angle);
im_P1(i)=pt7(2)*1e-2;
end

im_G1=im_G1-mean(im_G1);
im_G2=im_G2-mean(im_G2);
im_P1=im_P1-mean(im_P1);

In_p_G1=zeros(size(In_p0));
In_p_G2=zeros(size(In_p0));
In_p_P1=zeros(size(In_p0));

for i=1:length(lm)
DIn_p=interp2(Y,X+im_G1(i),In_p0,Y,X);
DIn_p(isnan(DIn_p))=0;
In_p_G1=In_p_G1+DIn_p*In_s(i);

DIn_p=interp2(Y,X+im_G2(i),In_p0,Y,X);
DIn_p(isnan(DIn_p))=0;
In_p_G2=In_p_G2+DIn_p*In_s(i);

DIn_p=interp2(Y,X+im_P1(i),In_p0,Y,X);
DIn_p(isnan(DIn_p))=0;
In_p_P1=In_p_P1+DIn_p*In_s(i);
end



%{
+[新建阅读窗口](,偏移扫描)
+[M函数](,光线路径)
%}

clf
subplot(2,2,1)
surf(X/1e-3,Y/1e-3,In_p0)
shading interp
view([0,90])
axis equal
xlabel('X [mm]')
ylabel('Y [mm]')
title('Input profile')

subplot(2,2,2)
plot(lm/1e-9,In_s)
xlabel('Wavelength [nm]')
ylabel('Intensity [a.u.]')
title('Spectrum')

subplot(2,3,4)
surf(X/1e-3,Y/1e-3,In_p_G1)
shading interp
view([0,90])
axis equal
xlabel('X [mm]')
ylabel('Y [mm]')
title(sprintf('G1 shift angle: %.2f^\\circ',d_an))

subplot(2,3,5)
surf(X/1e-3,Y/1e-3,In_p_G2)
shading interp
view([0,90])
axis equal
xlabel('X [mm]')
ylabel('Y [mm]')
title(sprintf('G2 shift angle: %.2f^\\circ',d_an))

subplot(2,3,6)
surf(X/1e-3,Y/1e-3,In_p_P1)
shading interp
view([0,90])
axis equal
xlabel('X [mm]')
ylabel('Y [mm]')
title(sprintf('P1 shift angle: %.2f^\\circ',d_an))


%{
+[新建阅读窗口](,偏移扫描)
+[M函数](,光线路径)
%}
## end
#884, 3:
-45
## end
#888, 3:
135
## end
#892, 2:
90
## end
#895, 939:
%{
Nini, 打开光栅原理(文件)
+[M函数](,单发路径)

%}


addpath('Matlab\space')
addpath('Matlab\optics')

N=1200;
% lm_B=750e-9;
lm_B=750e-9;
n=-1;

%{
+[M函数](,光线路径)
%}
G1_pt=[0,0];
G1_angle=135;
G2_pt=[-10,10];
G2_angle=-44;
P0_pt=[0,-10];
P0_angle=90;
M3_pt=[0,10];
M3_angle=-45;
tg_pt=[100,10];
tg_angle=180;

pt0=[0,20];
angle0=-90;


[x1,y1,angle]=Reflection_grating(pt0,angle0,G1_pt,G1_angle,N,lm_B,n);
[x2,y2,angle]=Reflection_grating([x1,y1],angle,G2_pt,G2_angle,N,lm_B,n);
[x3,y3,angle]=Reflection_grating([x2,y2],angle,P0_pt,P0_angle,N,lm_B,0);
[x4,y4,angle]=Reflection_grating([x3,y3],angle,G2_pt,G2_angle,N,lm_B,n);
[x5,y5,angle]=Reflection_grating([x4,y4],angle,G1_pt,G1_angle,N,lm_B,n);
[x6,y6,angle]=Reflection_grating([x5,y5],angle,M3_pt,M3_angle,N,lm_B,0);
[x7,y7,angle]=Reflection_grating([x6,y6],angle,tg_pt,tg_angle,N,lm_B,0);


plot([pt0(1),x1,x2,x3,x4,x5,x6,x7],[pt0(2),y1,y2,y3,y4,y5,y6,y7])
axis equal


%{
+[M函数](,光线路径)
+[修改天使]
%}
## end
#897, 1166:
%{
地址::Matlab\optics\grating_compressor_path.m
+[保存M函数](,grating_compressor_path)
%}


function [pt7,x,y]=grating_compressor_path(lm_B,n,N,pt0,angle0,G1_pt,G1_angle,G2_pt,G2_angle,P0_pt,P0_angle,M3_pt,M3_angle,tg_pt,tg_angle)

addpath('Matlab\space')

%N=1200;
%lm_B=750e-9;
%n=-1;

%pt0=[0,20];
%angle0=-90;

%G1_pt=[0,0];
%G1_angle=135;
%G2_pt=[-10,10];
%G2_angle=-44;
%P0_pt=[0,-10];
%P0_angle=90;
%M3_pt=[0,10];
%M3_angle=-45;
%tg_pt=[100,10];
%tg_angle=180;


[x1,y1,angle]=Reflection_grating(pt0,angle0,G1_pt,G1_angle,N,lm_B,n);
[x2,y2,angle]=Reflection_grating([x1,y1],angle,G2_pt,G2_angle,N,lm_B,n);
[x3,y3,angle]=Reflection_grating([x2,y2],angle,P0_pt,P0_angle,N,lm_B,0);
[x4,y4,angle]=Reflection_grating([x3,y3],angle,G2_pt,G2_angle,N,lm_B,n);
[x5,y5,angle]=Reflection_grating([x4,y4],angle,G1_pt,G1_angle,N,lm_B,n);
[x6,y6,angle]=Reflection_grating([x5,y5],angle,M3_pt,M3_angle,N,lm_B,0);
[x7,y7,angle]=Reflection_grating([x6,y6],angle,tg_pt,tg_angle,N,lm_B,0);


%plot([pt0(1),x1,x2,x3,x4,x5,x6,x7],[pt0(2),y1,y2,y3,y4,y5,y6,y7])
%axis equal
pt7=[x7,y7];
x=[pt0(1),x1,x2,x3,x4,x5,x6,x7];
y=[pt0(2),y1,y2,y3,y4,y5,y6,y7];

end

%{
+[M函数](,光线路径)
+[修改天使]
%}
## end
#900, 39:
Matlab\optics\grating_compressor_path.m
## end
#905, 1201:
%{
Nini, 打开光栅原理(文件)
+[M函数](,偏移扫描)
%}


addpath('Matlab\space')
addpath('Matlab\optics')

N=1200;
n=-1;
d_an=1;

pt0=[0,20];
angle0=-90;

G1_pt=[0,0];
G1_angle=135;
G2_pt=[-10,10];
G2_angle=-45;
P1_pt=[0,-10];
P1_angle=90;
M3_pt=[0,10];
M3_angle=-45;
tg_pt=[100,10];
tg_angle=180;


lm=linspace(750e-9,850e-9,20);
im_G1=zeros(size(lm));
im_G2=zeros(size(lm));
im_P1=zeros(size(lm));


% G1
for i=1:length(lm)
[pt7,x,y]=grating_compressor_path(lm(i),n,N,pt0,angle0,G1_pt,G1_angle+d_an,G2_pt,G2_angle,P1_pt,P1_angle,M3_pt,M3_angle,tg_pt,tg_angle);
im_G1(i)=pt7(2);

% G2
[pt7,x,y]=grating_compressor_path(lm(i),n,N,pt0,angle0,G1_pt,G1_angle,G2_pt,G2_angle+d_an,P1_pt,P1_angle,M3_pt,M3_angle,tg_pt,tg_angle);
im_G2(i)=pt7(2);

% P1
[pt7,x,y]=grating_compressor_path(lm(i),n,N,pt0,angle0,G1_pt,G1_angle,G2_pt,G2_angle,P1_pt,P1_angle+d_an,M3_pt,M3_angle,tg_pt,tg_angle);
im_P1(i)=pt7(2);
end

subplot(1,3,1)
plot(lm/1e-9,im_G1)
xlabel('Wavelength [nm]')
ylabel('position [cm]')
title('G1')

subplot(1,3,2)
plot(lm/1e-9,im_G2)
xlabel('Wavelength [nm]')
ylabel('position [cm]')
title('G2')

subplot(1,3,3)
plot(lm/1e-9,im_P1)
xlabel('Wavelength [nm]')
ylabel('position [cm]')
title('P1')


%{
+[M函数](,光线路径)
%}
## end
#911, 939:
<!--
+[H函数](,参考公式)

来源::http://toolbox.lightcon.com/tools/gratingpair/
来源2::https://www.lasercalculator.com/grating-pair-dispersion-calculator/
-->

<h2>Grating pair compressor</h2>

The GDD and TOD of the main compressor are calculated from the following equations,
%[1].
%[2].
where L is the grating separation, d is the grating line separation and \(\theta_0\) is the angle of incidence. <br>
Here is an example of the main compressor in UT^3. <br>

Parameters of the main compressor in UT^3 are,
$$
L=43.69\ cm,\ G=1480\ mm^{-1},\ \theta_0=46.30^\circ
$$
where L is the grating separation, G is the grating density and \(\theta_0\) is the angle of incidence. <br>
The results are,
$$
GDD=-2.483\ ps^2,\ TOD=5.358\times 10^{-3}\ ps^3
$$

<!--
[2].:
将"TOD=-\frac{3*\lambda}{2*\pi*c}*\frac{1+\frac{\lambda}{d}*sin(\theta_0)-sin(\theta_0)^2}{1-(\frac{\lambda}{d}-sin(\theta_0))^2}*GDD"记作为式(2)
式(2)转换为"表达式"


验证公式(M函数):...
+[H函数](,参考公式)
-->
## end
#914, 46:
http://toolbox.lightcon.com/tools/gratingpair/
## end
#916, 140:
GDD=-\frac{\lambda^{3}\ L}{\pi\ c^{2}\ d^{2}}\ \left(1-\left(\frac{\lambda}{d}-sin(\theta_{0})\right)^{2}\right)^{\left(-\frac{3}{2}\right)}
## end
#918, 157:
TOD=-\frac{3\ \lambda}{2\ \pi\ c}\ \frac{1+\frac{\lambda}{d}\ sin(\theta_{0})-sin(\theta_{0})^{2}}{1-\left(\frac{\lambda}{d}-sin(\theta_{0})\right)^{2}}\ GDD
## end
#920, 91:
GDD=-\frac{\lambda^3*L}{\pi*c^2*d^2}*(1-(\frac{\lambda}{d}-sin(\theta_0))^2)^(-\frac{3}{2})
## end
#924, 67:
https://www.lasercalculator.com/grating-pair-dispersion-calculator/
## end
#925, 130:
TOD=-\frac{3*\lambda}{2*\pi*c}*\frac{1+\frac{\lambda}{d}*sin(\theta_0)-sin(\theta_0)^2}{1-(\frac{\lambda}{d}-sin(\theta_0))^2}*GDD
## end
#929, 424:
%{
+[M函数](,验证公式)
%}

physics_constant;

L=43.69e-2;
lm_0=800e-9;
G=1480;
theta_0=46.30;

d=1e-3./G;

GDD=-(lm_0.^(3).*L)./(pi.*c.^(2).*d.^(2)).*(1-((lm_0)./(d)-sind(theta_0)).^(2)).^((-(3)./(2)));
TOD=-(3.*lm_0)./(2.*pi.*c).*(1+(lm_0)./(d).*sind(theta_0)-sind(theta_0).^(2))./(1-((lm_0)./(d)-sind(theta_0)).^(2)).*GDD;

disp(sprintf("GDD: %.3f ps^2",GDD/1e-24))
disp(sprintf("TOD: %.3e ps^3",TOD/1e-36))

%{
+[M函数](,验证公式)
%}
## end
#932, 20:



光栅GDD公式
光栅TOD公式


## end
### 结束